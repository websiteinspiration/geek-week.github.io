<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏾 👭 ℹ️ SwiftUI sur les étagères: Animation. Partie 1 👶🏿 👩‍👩‍👦‍👦 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, je suis tombé sur un nouvel article dans lequel les gars essayaient de reproduire un concept intéressant en utilisant SwiftUI. Voici ce qu'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI sur les étagères: Animation. Partie 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Récemment, je suis tombé sur un nouvel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans lequel les gars essayaient de reproduire un concept intéressant en utilisant SwiftUI. Voici ce qu'ils ont fait: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
j'ai étudié leur code avec intérêt, mais j'ai vécu une certaine frustration. Non, pas dans le sens où ils ont fait quelque chose de mal, pas du tout. Je n'ai tout simplement pas appris de leur code pratiquement rien de nouveau. Leur implémentation concerne plus la combinaison que l'animation. Et j'ai décidé de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construire mon lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour écrire mon article sur l'animation dans SwiftUI, en mettant en œuvre le même concept, mais en utilisant 100% des capacités de l'animation intégrée, même si elle n'est pas très efficace. Pour étudier - jusqu'à la fin. Pour expérimenter - donc avec un clin d'œil :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici ce que j'ai obtenu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, pour une divulgation complète du sujet, j'ai dû parler en détail des bases mêmes. Le texte s'est avéré volumineux et, par conséquent, je l'ai divisé en deux articles. Voici la première partie de celui-ci - plutôt, un tutoriel sur l'animation en général, pas directement lié à l'animation arc-en-ciel, dont je parlerai en détail dans le prochain article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, je vais parler des bases, sans lesquelles vous pouvez facilement vous perdre dans des exemples plus complexes. Une grande partie de ce dont je vais parler, sous une forme ou une autre, a déjà été décrite dans des articles en anglais tels que cette série ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Pour ma part, je me suis concentré non pas tant sur l'énumération des méthodes de travail que sur la description exacte de son fonctionnement. </font><font style="vertical-align: inherit;">Et comme toujours, j'ai beaucoup expérimenté, donc je m'empresse de partager les résultats les plus intéressants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
avertissement: sous le chat il y a beaucoup d'images et d'animations gif.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet est disponible sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez voir le résultat actuel avec une animation arc-en-ciel dans TransitionRainbowView (), mais je ne me précipiterais pas à votre place, mais j'ai attendu le prochain article. </font><font style="vertical-align: inherit;">De plus, lors de sa préparation, je peigne un peu le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous aborderons uniquement les bases et n'affecterons que le contenu du dossier Bases.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'avoue, je n'allais pas écrire cet article maintenant. J'avais un plan selon lequel un article sur l'animation était censé être le troisième, voire le quatrième d'affilée. Cependant, je n'ai pas pu résister, je voulais vraiment apporter un point de vue alternatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux faire une réservation tout de suite. Je ne pense pas que des erreurs aient été commises dans l'article mentionné, ou l'approche utilisée dans celui-ci est incorrecte. Pas du tout. Il construit un modèle objet du processus (animation) qui, répondant au signal reçu, commence à faire quelque chose. Cependant, pour moi, cet article révèle très probablement un travail avec le framework Combine. Oui, ce framework est une partie importante de SwiftUI, mais il s'agit plus d'un style de réaction en général que d'animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon option n'est certainement pas plus élégante, plus rapide et plus facile à entretenir. Cependant, il révèle beaucoup mieux ce qui se trouve sous le capot de SwiftUI, et c'était d'ailleurs le but de l'article - de le comprendre en premier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article précédent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par SwiftUI, j'ai commencé ma plongée dans le monde du développement mobile tout de suite avec SwiftUI, en ignorant UIKit. Bien sûr, cela a un prix, mais il y a des avantages. Je n'essaie pas de vivre dans un nouveau monastère selon l'ancienne charte. Honnêtement, je ne connais pas encore de chartes, donc je n'ai pas de rejet de la nouvelle. C'est pourquoi, cet article, il me semble, peut être utile non seulement pour les débutants, comme moi, mais aussi pour ceux qui étudient SwiftUI ayant déjà des antécédents en matière de développement sur UIKit. Il me semble que beaucoup de gens manquent d'un nouveau regard. Ne faites pas la même chose, essayez d'intégrer un nouvel outil dans les anciens dessins, mais changez votre vision en fonction de nouvelles possibilités.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous 1c-nicks sommes passés par là avec des «formes contrôlées». C'est une sorte de SwiftUI dans le monde des 1, qui s'est produit il y a plus de 10 ans. En fait, l'analogie est assez précise, car les formulaires gérés ne sont qu'une nouvelle façon de dessiner une interface. Cependant, il a complètement changé l'interaction client-serveur de l'application dans son ensemble, et l'image du monde dans l'esprit des développeurs en particulier. Ce n’était pas facile, moi-même je ne voulais pas l’étudier pendant environ 5 ans, car Je pensais que beaucoup des opportunités qui y étaient fermées étaient simplement nécessaires pour moi. Mais, comme la pratique l'a montré, le codage sur les formulaires gérés est non seulement possible, mais seulement nécessaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais n'en parlons plus. </font><font style="vertical-align: inherit;">J'ai obtenu un guide détaillé et indépendant qui n'a pas de références, ou d'autres liens avec l'article mentionné ou le 1er passé. </font><font style="vertical-align: inherit;">Étape par étape, nous allons plonger dans les détails, les fonctionnalités, les principes et les limites. </font><font style="vertical-align: inherit;">Aller.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forme animée</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctionnement de l'animation en général</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, l'idée principale de l'animation est la transformation d'un changement particulier et discret en un processus continu. Par exemple, le rayon du cercle était de 100 unités, est devenu 50 unités. Sans animation, le changement se fera instantanément, avec animation - en douceur. Comment ça fonctionne? Très simple. Pour des changements en douceur, nous devons interpoler plusieurs valeurs dans le segment «C'était ... c'est devenu». Dans le cas du rayon, nous devrons dessiner plusieurs cercles intermédiaires avec un rayon de 98 unités, 95 unités, 90 unités ... 53 unités et, enfin, 50 unités. SwiftUI peut le faire facilement et naturellement, il suffit d'encapsuler le code qui effectue ce changement dans withAnimation {...}. Cela semble magique ... Jusqu'à ce que vous vouliez implémenter quelque chose d'un peu plus compliqué que "bonjour le monde".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons aux exemples. L'objet d'animation le plus simple et le plus compréhensible est considéré comme une animation de formes. La forme (j'appellerai toujours la structure conforme au protocole de forme de forme) dans SwiftUI est une structure avec des paramètres qui peuvent s'insérer dans ces limites. Ceux. c'est une structure qui a le corps de la fonction (en rect: CGRect) -&gt; Path. Tout ce dont le runtime a besoin pour dessiner ce formulaire est de demander son contour (le résultat de la fonction est un objet de type Path, en fait, c'est une courbe de Bézier) pour la taille requise (spécifiée comme paramètre de fonction, un rectangle de type CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forme est une structure stockée. En l'initialisant, vous stockez dans les paramètres tout ce dont vous avez besoin pour dessiner son contour. La taille de la sélection pour ce formulaire peut changer, alors tout ce qui est nécessaire est d'obtenir une nouvelle valeur Path pour la nouvelle trame CGRect, et le tour est joué. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons déjà le codage:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc un cercle (Circle ()), dont le rayon peut être modifié à l'aide du curseur. Cela se passe bien, car le curseur nous donne toutes les valeurs intermédiaires. Cependant, lorsque vous cliquez sur le bouton "définir le rayon par défaut", le changement ne se produit pas non plus instantanément, mais selon l'instruction withAnimation (.linear (duration: 1)). Linéairement, sans accélération, étiré pendant 1 seconde. Classe! Nous avons maîtrisé l'animation! Nous ne sommes pas d'accord :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que faire si nous voulons implémenter notre propre formulaire et animer ses changements? Est-ce difficile de faire ça? Allons vérifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai fait une copie de Circle comme suit:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rayon du cercle est calculé comme la moitié de la plus petite de la largeur et de la hauteur de la bordure de la zone d'écran qui nous est attribuée. </font><font style="vertical-align: inherit;">Si la largeur est supérieure à la hauteur, nous partons du milieu de la bordure supérieure (note 1), décrivons le cercle complet dans le sens des aiguilles d'une montre (note 2) et fermons notre contour à ce sujet. </font><font style="vertical-align: inherit;">Si la hauteur est supérieure à la largeur, nous partons du milieu de la bordure droite, nous décrivons également le cercle complet dans le sens horaire et fermons le contour.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x —  ,  y —  . ..        y.   y —   .  ,        .  90    , 180  — , 270  — .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 2</font></font></b>
                        <div class="spoiler_text">   1   ,   “ ”  “ ”         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifions comment notre nouveau cercle réagira aux modifications du bloc withAnimation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hou la la! </font><font style="vertical-align: inherit;">Nous avons appris à créer nos propres images de forme libre et à les animer! </font><font style="vertical-align: inherit;">Il en est ainsi? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pas vraiment. </font><font style="vertical-align: inherit;">Tout le travail ici est effectué par le modificateur .frame (largeur: self.radius * 2, hauteur: self.radius * 2). </font><font style="vertical-align: inherit;">À l'intérieur du bloc withAnimation {...} nous changeons</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une variable, il envoie un signal pour réinitialiser CustomCircleView () avec une nouvelle valeur de rayon, cette nouvelle valeur tombe dans le modificateur .frame (), et ce modificateur peut déjà animer les changements de paramètres. Notre formulaire CustomCircle () réagit à cela avec une animation, car cela ne dépend pas d'autre chose que de la taille de la zone sélectionnée. Le changement de zone se produit avec l'animation, (c'est-à-dire progressivement, interpolant les valeurs intermédiaires entre elles était-est devenue), donc notre cercle est dessiné avec la même animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simplifions (ou compliquons encore?) Notre forme un peu. Nous ne calculerons pas le rayon en fonction de la taille de la zone disponible, mais nous transférerons le rayon sous la forme finie, c'est-à-dire en faire un paramètre de structure stocké.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, la magie est irrémédiablement perdue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons exclu le modificateur frame () de notre CustomCircleView (), déplaçant la responsabilité de la taille du cercle sur la forme elle-même, et l'animation a disparu. </font><font style="vertical-align: inherit;">Mais cela n'a pas d'importance; apprendre à un formulaire à animer les changements de ses paramètres n'est pas trop difficile. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez implémenter les exigences du protocole Animatable:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">La magie est de retour! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous pouvons dire avec confiance que notre formulaire est vraiment animé - il peut refléter les changements de ses paramètres avec l'animation. </font><font style="vertical-align: inherit;">Nous avons donné au système une fenêtre où il peut entasser les valeurs interpolées nécessaires à l'animation. </font><font style="vertical-align: inherit;">S'il existe une telle fenêtre, les modifications sont animées. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, les modifications ont lieu sans animation, c'est-à-dire </font><font style="vertical-align: inherit;">immédiatement. </font><font style="vertical-align: inherit;">Rien de compliqué, non?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment animer des modifications dans une vue</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais allons directement à View. </font><font style="vertical-align: inherit;">Supposons que nous voulons animer la position d'un élément à l'intérieur d'un conteneur. </font><font style="vertical-align: inherit;">Dans notre cas, ce sera un simple rectangle de couleur verte et une largeur de 10 unités. </font><font style="vertical-align: inherit;">Nous animerons sa position horizontale.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe! </font><font style="vertical-align: inherit;">Travaux! </font><font style="vertical-align: inherit;">Maintenant, nous savons tout sur l'animation! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pas vraiment. </font><font style="vertical-align: inherit;">Si vous regardez la console, nous verrons ce qui suit:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calcul de l' </font><font style="vertical-align: inherit;">init BorderView </font><font style="vertical-align: inherit;">: 0,4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Position de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calcul de l' </font><font style="vertical-align: inherit;">init </font><font style="vertical-align: inherit;">BorderView: 0,468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Position de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calcul de l' </font><font style="vertical-align: inherit;">init BorderView </font><font style="vertical-align: inherit;">: 0,0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, chaque modification de la valeur de position à l'aide du curseur entraîne la réinitialisation de BorderView avec la nouvelle valeur. C'est pourquoi nous voyons un mouvement régulier de la ligne verte après le curseur, le curseur signale simplement très souvent un changement dans la variable, et cela ressemble à une animation, mais ce n'est pas le cas. L'utilisation du curseur est très pratique lorsque vous déboguez une animation. Vous pouvez l'utiliser pour suivre certains états de transition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxièmement, nous voyons que la position de calcul est simplement devenue égale à 0, et aucun journal intermédiaire, comme ce fut le cas avec l'animation correcte du cercle. Pourquoi?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La chose, comme dans l'exemple précédent, est dans le modificateur. </font><font style="vertical-align: inherit;">Cette fois, le modificateur .offset () obtient la nouvelle valeur de retrait, et il anime le changement lui-même. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">en fait, ce n'est pas le changement du paramètre de position que nous voulions animer, mais le changement horizontal du retrait dans le modificateur .offset () qui en dérive. </font><font style="vertical-align: inherit;">Dans ce cas, il s'agit d'un remplacement inoffensif, le résultat est le même. </font><font style="vertical-align: inherit;">Mais depuis qu'ils sont venus, creusons plus profondément. </font><font style="vertical-align: inherit;">Faisons notre propre modificateur, qui recevra la position (de 0 à 1) à l'entrée, il recevra la taille de la zone disponible et calculera le retrait.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le BorderView d'origine, respectivement, le GeometryReader n'est plus nécessaire, ainsi que la fonction de calcul du retrait:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, nous utilisons toujours le modificateur .offset () dans notre modificateur, mais après cela, nous avons ajouté le modificateur .animation (nil), qui bloque notre propre animation de décalage. </font><font style="vertical-align: inherit;">Je comprends qu'à ce stade, vous pouvez décider qu'il suffit de retirer ce verrou, mais nous n'irons pas au fond de la vérité. </font><font style="vertical-align: inherit;">Et la vérité est que notre astuce avec animatableData pour BorderView ne fonctionne pas. </font><font style="vertical-align: inherit;">En fait, si vous regardez la documentation du protocole </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous remarquerez que l'implémentation de ce protocole n'est prise en charge que pour AnimatableModifier, GeometryEffect et Shape. </font><font style="vertical-align: inherit;">La vue n'en fait pas partie.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bonne approche consiste à animer les modifications</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche elle-même, lorsque nous demandons à View d'animer certains changements, était incorrecte. </font><font style="vertical-align: inherit;">Pour View, vous ne pouvez pas utiliser la même approche que pour les formulaires. </font><font style="vertical-align: inherit;">Au lieu de cela, l'animation doit être intégrée à chaque modificateur. </font><font style="vertical-align: inherit;">La plupart des modificateurs intégrés prennent déjà en charge l'animation prête à l'emploi. </font><font style="vertical-align: inherit;">Si vous souhaitez une animation pour vos propres modificateurs, vous pouvez utiliser le protocole AnimatableModifier au lieu de ViewModifier. </font><font style="vertical-align: inherit;">Et là, vous pouvez implémenter la même chose que lors de l'animation des changements de forme, comme nous l'avons fait ci-dessus.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, tout va bien. </font><font style="vertical-align: inherit;">Les messages dans la console aident à comprendre que notre animation fonctionne vraiment et que l'animation (nil) à l'intérieur du modificateur ne la gêne pas du tout. </font><font style="vertical-align: inherit;">Mais voyons toujours comment cela fonctionne.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, vous devez comprendre ce qu'est un modificateur.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons une vue. Comme je l'ai dit dans la partie précédente, il s'agit d'une structure avec des paramètres stockés et des instructions d'assemblage. Cette instruction, dans l'ensemble, ne contient pas une séquence d'actions, qui est le code habituel que nous écrivons dans un style non déclaratif, mais une simple liste. Il répertorie l'autre vue, les modificateurs qui leur sont appliqués et les conteneurs dans lesquels ils sont inclus. Nous ne sommes pas encore intéressés par les conteneurs, mais parlons plus des modificateurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un modificateur est à nouveau une structure avec des paramètres stockés et des instructions de traitement View. </font><font style="vertical-align: inherit;">Il s'agit en fait de la même instruction que la vue - nous pouvons utiliser d'autres modificateurs, utiliser des conteneurs (par exemple, j'ai utilisé le GeometryReader un peu plus haut) et même une autre vue. </font><font style="vertical-align: inherit;">Mais nous n'avons que du contenu entrant, et nous devons en quelque sorte le modifier en utilisant cette instruction. </font><font style="vertical-align: inherit;">Les paramètres des modificateurs font partie de l'instruction. </font><font style="vertical-align: inherit;">Mais le plus intéressant est qu'ils sont stockés.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans un article précédent, j'ai dit que l'instruction elle-même n'est pas stockée, qu'elle est lancée à chaque fois après la mise à jour de la vue. </font><font style="vertical-align: inherit;">Tout est ainsi, mais il y a une nuance. </font><font style="vertical-align: inherit;">À la suite du travail de cette instruction, nous n'avons pas tout à fait une image, comme je l'ai dit plus tôt - c'était une simplification. </font><font style="vertical-align: inherit;">Les modificateurs ne disparaissent pas après l'exécution de cette instruction. </font><font style="vertical-align: inherit;">Ils le restent tant que la vue parent existe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques analogies primitives</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment décririons-nous un tableau dans un style déclaratif? </font><font style="vertical-align: inherit;">Eh bien, nous énumérons 4 pieds et un comptoir. </font><font style="vertical-align: inherit;">Ils les combineraient dans une sorte de conteneur, et avec l'aide de certains modificateurs, ils prescriraient comment ils sont attachés les uns aux autres. </font><font style="vertical-align: inherit;">Par exemple, chaque pied indiquerait l'orientation par rapport au plan de travail et la position - quel pied est épinglé à quel coin. </font><font style="vertical-align: inherit;">Oui, nous pouvons jeter les instructions après l'assemblage, mais les clous resteront dans le tableau. </font><font style="vertical-align: inherit;">Les modificateurs aussi. </font><font style="vertical-align: inherit;">A la sortie de la fonction body, nous n'avons pas tout à fait de tableau. </font><font style="vertical-align: inherit;">En utilisant le corps, nous créons des éléments de table (vue) et des attaches (modificateurs), et nous mettons tout cela dans des tiroirs. </font><font style="vertical-align: inherit;">La table elle-même est assemblée par un robot. </font><font style="vertical-align: inherit;">Quelles fixations vous mettez dans une boîte à chaque jambe, vous obtiendrez une telle table.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction .modifier (BorderPosition (position: position)), avec laquelle nous avons transformé la structure BorderPosition en modificateur, ne met qu'une vis supplémentaire dans le tiroir sur le pied de table. La structure BorderPosition est cette vis. Le rendu, au moment du rendu, prend cette case, en retire une jambe (Rectangle () dans notre cas), et obtient séquentiellement tous les modificateurs de la liste, avec les valeurs stockées en eux. La fonction corporelle de chaque modificateur est une instruction sur la façon de visser une jambe sur un dessus de table avec cette vis, et la structure elle-même avec des propriétés stockées, c'est cette vis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi est-il important de comprendre cela dans le contexte de l'animation? Parce que l'animation vous permet de modifier les paramètres d'un modificateur sans affecter les autres, puis de restituer l'image. Si vous faites de même en changeant certains</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètres - cela entraînera la réinitialisation de la vue imbriquée, des structures de modificateurs, etc., tout au long de la chaîne. Mais l'animation ne l'est pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, lorsque nous changeons la valeur de la position lorsque nous appuyons sur un bouton, cela change. Jusqu'au bout. Aucun état intermédiaire n'est stocké dans la variable elle-même, ce qui ne peut pas être dit au sujet du modificateur. Pour chaque nouvelle image, les valeurs des paramètres du modificateur changent en fonction de la progression de l'animation en cours. Si l'animation dure 1 seconde, puis tous les 1/60 de seconde (l'iphone affiche exactement ce nombre d'images par seconde), la valeur animatableData à l'intérieur du modificateur changera, puis elle sera lue par le rendu pour le rendu, après quoi, après encore 1/60 de seconde, ce sera changé à nouveau, et relu par le rendu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est caractéristique, nous obtenons d'abord l'état final de la vue entière, souvenez-vous-en, et ce n'est qu'alors que le mécanisme d'animation commence à délimiter les valeurs de position interpolées dans le modificateur. L'état initial n'est stocké nulle part. Quelque part dans les entrailles de SwiftUI, seule la différence entre l'état initial et l'état final est stockée. Cette différence est à chaque fois multipliée par la fraction du temps écoulé. C'est ainsi que la valeur interpolée est calculée, qui est ensuite remplacée par animatableData. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différence = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acier </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- Était </font></i><i><font style="vertical-align: inherit;">Valeur actuelle = Acier - Différence * (1 - Temps écoulé) </font></i><i><font style="vertical-align: inherit;">
Temps écoulé = Temps depuis StartAnimations / DurationAnimations La</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
valeur actuelle doit être calculée autant de fois que le nombre d'images que nous devons afficher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi le «n'a pas été» utilisé explicitement? Le fait est que SwiftUI ne stocke pas l'état initial. Seule la différence est enregistrée: ainsi, en cas d'échec, vous pouvez simplement désactiver l'animation et revenir à l'état actuel de «devenir». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche vous permet de rendre l'animation réversible. Supposons, quelque part au milieu d'une animation, que l'utilisateur ait à nouveau appuyé sur un bouton et que nous ayons à nouveau modifié la valeur de la même variable. Dans ce cas, tout ce que nous devons faire pour réussir ce changement est d'utiliser "Current" comme valeur actuelle dans l'animation au moment du nouveau changement, de se souvenir de la nouvelle différence et de démarrer une nouvelle animation basée sur le nouveau "Became" et la nouvelle "Difference" . Oui, en fait, ces transitions d'une animation à une autre peuvent être un peu plus difficiles à simuler l'inertie, mais le sens, je pense, est compréhensible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est intéressant, c'est que l'animation de chaque image demande la valeur actuelle à l'intérieur du modificateur (à l'aide d'un getter). Ceci, comme vous pouvez le voir dans les enregistrements de service dans le journal, est responsable du statut de «Acier». Ensuite, en utilisant le setter, nous définissons le nouvel état qui est courant pour cette trame. Après cela, pour la trame suivante, la valeur actuelle du modificateur est à nouveau demandée - et elle est de nouveau «est devenue», c'est-à-dire Valeur finale vers laquelle l'animation se déplace. Il est probable que des copies des structures de modificateurs soient utilisées pour l'animation, et un getter d'une structure (un modificateur réel de la vue réelle) est utilisé pour obtenir la valeur "Acier", et un setter d'une autre (un modificateur temporaire utilisé pour l'animation) est utilisé. Je n'ai pas trouvé de moyen de m'en assurer, mais par des indications indirectes, tout ressemble à ça. En tous cas,les modifications au sein de l'animation n'affectent pas la valeur stockée de la structure des modificateurs de la vue actuelle. Si vous avez des idées sur la façon de savoir exactement ce qui se passe exactement avec le getter et le setter, écrivez à ce sujet dans les commentaires, je mettrai à jour l'article.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs paramètres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à ce moment, nous n'avions qu'un seul paramètre pour l'animation. </font><font style="vertical-align: inherit;">La question peut se poser, mais qu'en est-il si plusieurs paramètres sont passés au modificateur? </font><font style="vertical-align: inherit;">Et si les deux doivent être animés en même temps? </font><font style="vertical-align: inherit;">Voici comment avec le modificateur de cadre (largeur: hauteur :) par exemple. </font><font style="vertical-align: inherit;">Après tout, nous pouvons changer simultanément la largeur et la hauteur de cette vue, et nous voulons que le changement se produise dans une animation, comment faire? </font><font style="vertical-align: inherit;">Après tout, le paramètre AnimatableData en est un, que puis-je lui substituer?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez, Apple n'a qu'une seule exigence pour animatableData. Le type de données que vous y remplacez doit respecter le protocole VectorArithmetic. Ce protocole nécessite que l'objet garantisse les opérations arithmétiques minimales nécessaires pour pouvoir former un segment de deux valeurs et interpoler les points à l'intérieur de ce segment. Les opérations nécessaires pour cela sont l'addition, la soustraction et la multiplication. La difficulté est que nous devons effectuer ces opérations avec un seul objet qui stocke plusieurs paramètres. Ceux. nous devons emballer la liste complète de nos paramètres dans un conteneur qui sera un vecteur. Apple fournit un tel objet hors de la boîte, et nous propose d'utiliser une solution clé en main pour les cas pas très difficiles. Il s'appelle AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Changeons un peu la tâche. </font><font style="vertical-align: inherit;">Nous avons besoin d'un nouveau modificateur qui non seulement déplacera la barre verte, mais changera également sa hauteur. </font><font style="vertical-align: inherit;">Ce seront deux paramètres modificateurs indépendants. </font><font style="vertical-align: inherit;">Je ne donnerai pas le code complet de toutes les modifications à effectuer, vous pouvez le voir sur le github dans le fichier SimpleBorderMove. </font><font style="vertical-align: inherit;">Je ne montrerai que le modificateur lui-même:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ajouté un autre curseur et un bouton pour modifier aléatoirement les deux paramètres à la fois dans la vue parent de SimpleView, mais il n'y a rien d'intéressant, donc pour le code complet, bienvenue dans le github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout fonctionne, nous obtenons vraiment un changement cohérent dans la paire de paramètres emballés dans le tuple AnimatablePair. </font><font style="vertical-align: inherit;">Pas mal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rien de confus dans cette mise en œuvre? </font><font style="vertical-align: inherit;">Personnellement, je me suis tendu quand j'ai vu ce design:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai indiqué nulle part lequel de ces paramètres devrait aller en premier et lequel en second. Comment SwiftUI décide quelle valeur mettre en premier et quelle valeur en deuxième? Eh bien, cela ne correspond-il pas aux noms des paramètres de fonction avec les noms des attributs de structure?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première idée était l'ordre des attributs dans les paramètres de la fonction et leurs types, comme cela arrive avec @EnvironmentObject. Là, nous mettons simplement les valeurs dans la boîte, sans leur attribuer d'étiquette, puis nous les sortons de là, également sans indiquer d'étiquette. Là, tapez les sujets, et dans un seul type, l'ordre. Dans quel ordre ils mettent dans la boîte, de la même manière et l'obtiennent. J'ai essayé un ordre différent des arguments de la fonction, l'ordre des arguments pour initialiser la structure, l'ordre des attributs de la structure elle-même, me cognais généralement la tête contre le mur, mais ne pouvais pas confondre SwiftUI afin qu'il commence à animer la position avec des valeurs de hauteur et vice versa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puis cela m'est apparu. J'indique moi-même quel paramètre sera le premier et quel second dans le getter. SwiftUI n'a pas besoin de savoir exactement comment nous initialisons cette structure. Il peut obtenir la valeur animatableData avant le changement, l'obtenir après le changement, calculer la différence entre eux et renvoyer la même différence, mise à l'échelle proportionnellement à l'intervalle de temps écoulé, à notre configurateur. Il n'a généralement pas besoin de connaître la valeur elle-même dans AnimatableData. Et si vous ne confondez pas l'ordre des variables sur deux lignes adjacentes, alors tout sera en ordre, quelle que soit la complexité de la structure du reste du code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais voyons ça. Après tout, nous pouvons créer notre propre vecteur conteneur (oh, j'adore, créer notre propre implémentation d'objets existants, vous l'avez peut-être remarqué dans un article précédent).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous décrivons la structure élémentaire, déclarons la prise en charge du protocole VectorArithmetic, ouvrons l'erreur sur le protocole non conforme, cliquons sur fix, et nous obtenons la déclaration de toutes les fonctions requises et des paramètres calculés. </font><font style="vertical-align: inherit;">Il ne reste plus qu'à les remplir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la même manière, nous remplissons notre objet avec les méthodes requises pour le protocole AdditiveArithmetic (VectorArithmetic inclut son support).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense pourquoi nous avons besoin de + et - évidemment. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'échelle est une fonction de la mise à l'échelle. </font><font style="vertical-align: inherit;">Nous prenons la différence «C'était - c'est devenu» et la multiplions par le stade actuel de l'animation (de 0 à 1). </font><font style="vertical-align: inherit;">"C'est devenu + Différence * (1 - Étape)" et il y aura une valeur actuelle que nous devrions supprimer dans animatableData</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zéro est probablement nécessaire pour initialiser de nouveaux objets dont les valeurs seront utilisées pour l'animation. </font><font style="vertical-align: inherit;">L'animation utilise .zero au tout début, mais je n'ai pas pu comprendre exactement comment. </font><font style="vertical-align: inherit;">Cependant, je ne pense pas que ce soit important.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magnitudeSquared est un produit scalaire d'un vecteur donné avec lui-même. </font><font style="vertical-align: inherit;">Pour un espace à deux dimensions, cela signifie la longueur du vecteur au carré. </font><font style="vertical-align: inherit;">Ceci est probablement utilisé pour pouvoir comparer deux objets l'un avec l'autre, non pas par élément, mais dans son ensemble. </font><font style="vertical-align: inherit;">Il ne semble pas être utilisé à des fins d'animation.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De manière générale, les fonctions «- =» «+ =» sont également incluses dans le support du protocole, mais pour la structure elles peuvent être générées automatiquement sous cette forme</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour plus de clarté, j'ai exposé toute cette logique sous forme de schéma. </font><font style="vertical-align: inherit;">
L'image est cliquable. </font><font style="vertical-align: inherit;">
Ce que nous obtenons pendant l'animation est surligné en rouge - à chaque tick (1/60 seconde), le temporisateur donne une nouvelle valeur de t, et nous, dans le régleur de notre modificateur, obtenons une nouvelle valeur de animatableData. </font><font style="vertical-align: inherit;">Voilà comment l'animation fonctionne sous le capot. </font><font style="vertical-align: inherit;">Dans le même temps, il est important de comprendre qu'un modificateur est une structure stockée et qu'une copie du modificateur actuel avec un nouvel état actuel est utilisée pour afficher l'animation.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi AnimatableData ne peut être qu'une structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a encore un point. Vous ne pouvez pas utiliser des classes en tant qu'objet AnimatableData. Formellement, vous pouvez décrire pour une classe toutes les méthodes nécessaires du protocole correspondant, mais cela ne décollera pas, et voici pourquoi. Comme vous le savez, une classe est un type de données de référence et une structure est un type de données basé sur des valeurs. Lorsque vous créez une variable basée sur une autre, dans le cas d'une classe, vous copiez un lien vers cet objet et dans le cas d'une structure, vous créez un nouvel objet basé sur les valeurs de l'existant. Voici un petit exemple illustrant cette différence:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'animation, exactement la même chose se produit. Nous avons un objet AnimatableData représentant la différence entre «était» et «est devenu». Nous devons calculer une partie de cette différence pour la refléter sur l'écran. Pour ce faire, nous devons copier cette différence et la multiplier par un nombre représentant l'étape actuelle de l'animation. Dans le cas de la structure, cela n'affectera pas la différence elle-même, mais dans le cas de la classe, ce sera le cas. Le premier cadre que nous dessinons est l'état «était». Pour ce faire, nous devons calculer Acier + Différence * Étape actuelle - Différence. Dans le cas de la classe, dans la première image, nous multiplions la différence par 0, en la mettant à zéro, et toutes les images suivantes sont dessinées de sorte que la différence = 0. l'animation semble être correctement dessinée, mais en fait, nous voyons une transition instantanée d'un état à un autre, comme s'il n'y avait pas d'animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez probablement écrire une sorte de code de bas niveau qui crée de nouvelles adresses mémoire pour le résultat de la multiplication - mais pourquoi? </font><font style="vertical-align: inherit;">Vous pouvez simplement utiliser des structures - elles sont créées pour cela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui veulent comprendre exactement comment SwiftUI calcule les valeurs intermédiaires, par quelles opérations et à quel moment, les </font><font style="vertical-align: inherit;">messages sont poussés dans la console </font><font style="vertical-align: inherit;">du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De plus, j'y ai inséré sleep 0.1 seconde pour simuler des calculs gourmands en ressources à l'intérieur de l'animation, amusez-vous :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation d'écran: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à ce point, nous avons parlé d'animer une modification d'une valeur passée à un modificateur ou à un formulaire. Ce sont des outils assez puissants. Mais il existe un autre outil qui utilise également l'animation - c'est l'animation de l'apparition et de la disparition de la vue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le dernier article, nous avons parlé du fait que dans le style déclaratif de if-else, ce n'est pas du tout le contrôle du flux de code lors de l'exécution, mais plutôt une vue de Schrödinger. Il s'agit d'un conteneur contenant deux vues en même temps, qui décide lequel afficher en fonction d'une certaine condition. Si vous manquez le bloc else, EmptyView s'affiche à la place de la deuxième vue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La commutation entre les deux vues peut également être animée. Pour ce faire, utilisez le modificateur .transition ().</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment cela fonctionne. Tout d'abord, à l'avance, même au stade de l'initialisation de la vue parent, nous avons créé et placé plusieurs vues dans le tableau. Le tableau est de type AnyView, car les éléments du tableau doivent avoir le même type, sinon ils ne peuvent pas être utilisés dans ForEach. Type de résultat opaque de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> précédent </font><font style="vertical-align: inherit;">, vous vous souvenez? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous avons prescrit l'énumération des indices de ce tableau, et pour chacun d'eux, nous affichons la vue par cet index. Nous sommes obligés de le faire et de ne pas itérer sur View immédiatement, car pour travailler avec ForEach, nous devons attribuer un identifiant interne à chaque élément afin que SwiftUI puisse parcourir le contenu de la collection. Comme alternative, nous devrions créer un identifiant de proxy dans chaque vue, mais pourquoi, si des index peuvent être utilisés?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous emballons chaque vue de la collection dans un état et nous la montrons uniquement si elle est active. Cependant, la construction if-else ne peut tout simplement pas exister ici, le compilateur la prend pour le contrôle de flux, nous mettons donc tout cela dans le groupe afin que le compilateur comprenne exactement ce que c'est View, ou plus précisément, les instructions pour que ViewBuilder crée un conteneur ConditionalContent facultatif &lt;View1, View2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, lorsque vous modifiez la valeur de currentViewInd, SwiftUI masque la vue active précédente et affiche la vue actuelle. Comment aimez-vous cette navigation dans l'application?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce qui reste à faire est de mettre la modification currentViewInd dans l'encapsuleur withAnimation, et le basculement entre les fenêtres deviendra fluide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez le modificateur .transition, en spécifiant .scale comme paramètre. </font><font style="vertical-align: inherit;">Cela rendra l'animation de l'apparence et de la disparition de chacune de ces vues différente - en utilisant la mise à l'échelle plutôt que la transparence utilisée par défaut SwiftUI.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez que la vue apparaît et disparaît avec la même animation, seule la disparition défile dans l'ordre inverse. </font><font style="vertical-align: inherit;">En fait, nous pouvons attribuer individuellement des animations à la fois pour l'apparition et la disparition d'une vue. </font><font style="vertical-align: inherit;">Une transition asymétrique est utilisée pour cela.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La même animation .scale est utilisée pour apparaître à l'écran, mais maintenant nous avons spécifié les paramètres pour son utilisation. Il ne commence pas par une taille zéro (point), mais par une taille de 0,1 par rapport à la taille habituelle. Et la position de départ de la petite fenêtre n'est pas au centre de l'écran, mais décalée vers le bord gauche. De plus, pas une transition n'est responsable de l'apparence, mais deux. Ils peuvent être combinés avec .combined (avec :). Dans ce cas, nous avons ajouté de la transparence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La disparition de la vue est maintenant rendue par une autre animation - balayant le bord droit de l'écran. J'ai rendu l'animation un peu plus lente pour que vous puissiez y jeter un œil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et comme toujours, j'ai hâte d'écrire ma propre version d'animation de transit. C'est encore plus simple que les formulaires animés ou les modificateurs.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, nous écrivons le modificateur habituel dans lequel nous transférons un certain nombre - l'angle de rotation en degrés, ainsi que le point par rapport auquel cette rotation se produit. Ensuite, nous étendons le type AnyTransition avec deux fonctions. Cela aurait pu en être un, mais cela me semblait plus pratique. J'ai trouvé plus facile d'attribuer des noms parlants à chacun d'eux que de contrôler les degrés de rotation directement dans la vue elle-même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type AnyTransition a une méthode de modificateur statique, dans laquelle nous transmettons deux modificateurs, et nous obtenons un objet AnyTransition qui décrit une transition en douceur d'un état à un autre. l'identité est le modificateur d'état normal de la vue animée. Actif est l'état du début de l'animation pour l'apparence de la vue, ou la fin de l'animation pour la disparition, c'est-à-dire l'autre extrémité du segment, les états dans lesquels seront interpolés.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, spinIn implique que je vais l'utiliser pour faire apparaître la vue de l'extérieur de l'écran (ou de l'espace alloué à la vue) en tournant dans le sens horaire autour du point spécifié. spinOut signifie que la vue disparaîtra de la même manière, en tournant autour du même point, également dans le sens des aiguilles d'une montre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon mon idée, si vous utilisez le même point pour l'apparition et la disparition de la vue, vous obtenez l'effet de tourner tout l'écran autour de ce point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute l'animation est basée sur la mécanique des modificateurs standard. Si vous écrivez un modificateur entièrement personnalisé, vous devez implémenter les exigences du protocole AnimatableModifier, comme nous l'avons fait avec TwoParameterBorder, ou utiliser les modificateurs intégrés à l'intérieur qui fournissent leur propre animation par défaut. Dans ce cas, je me suis appuyé sur l'animation .rotationEffect () intégrée dans mon modificateur SpinTransitionModifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modificateur .transition () précise uniquement ce qu'il faut considérer comme point de départ et d'arrivée de l'animation. Si nous devons demander l'état AnimatableData avant de démarrer l'animation, pour demander le modificateur AnimatableData de l'état actuel, calculez la différence, puis animez la diminution de 1 à 0, puis .transition () modifie simplement les données d'origine. Vous n'êtes pas attaché à l'état de votre vue, vous n'êtes pas basé sur celui-ci. Vous spécifiez explicitement l'état initial et final vous-même, à partir d'eux vous obtenez AnimatableData, calculez la différence et l'animez. Ensuite, à la fin de l'animation, votre vue actuelle apparaît au premier plan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, l'identité est un modificateur qui restera appliqué à votre vue à la fin de l'animation. Sinon, une erreur entraînerait des sauts à la fin de l'animation d'apparition et le début de l'animation de disparition. Ainsi, la transition peut être considérée comme «deux en un» - en appliquant un modificateur spécifique directement à la vue + la possibilité d'animer ses changements lorsque la vue apparaît et disparaît. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honnêtement, ce mécanisme de contrôle d'animation me semble très fort, et je suis un peu désolé de ne pouvoir l'utiliser pour aucune animation. Je ne refuserais pas une telle création d'animation fermée sans fin. Cependant, nous en parlerons dans le prochain article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour mieux voir comment le changement se produit, j'ai remplacé notre vue de test par des carrés élémentaires, signés avec des nombres et encadrés.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pour rendre ce mouvement encore meilleur, j'ai supprimé .clipped () du modificateur SpinTransitionModifier:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, nous avons maintenant besoin de SpinTransitionModifier dans notre propre modificateur. </font><font style="vertical-align: inherit;">Il a été créé uniquement afin de combiner les deux modificateurs, rotationEffect et clipped () en un seul, afin que l'animation de rotation ne dépasse pas la portée sélectionnée pour notre vue. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser .rotationEffect () directement à l'intérieur de .modifier (), nous n'avons pas besoin d'un intermédiaire sous la forme de SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand la vue meurt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un point intéressant est le cycle de vie de la vue s'il est placé dans un if-else. </font><font style="vertical-align: inherit;">La vue, bien qu'initiée et enregistrée en tant qu'élément de tableau, n'est pas stockée en mémoire. </font><font style="vertical-align: inherit;">Tout son</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les paramètres sont réinitialisés par défaut la prochaine fois qu'ils apparaissent à l'écran. C'est presque la même chose que l'initialisation. Malgré le fait que la structure objet elle-même existe toujours, le rendu l'a retirée de son champ de vision, car elle ne l'est pas. D'une part, cela réduit l'utilisation de la mémoire. Si vous avez un grand nombre de vues complexes dans le tableau, le rendu devra les dessiner toutes en permanence, réagissant aux changements - cela affecte négativement les performances. Si je ne me trompe pas, c'était le cas avant la mise à jour Xcode 11.3. Désormais, les vues inactives sont déchargées de la mémoire de rendu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un autre côté, nous devons déplacer tout état important au-delà de la portée de ce point de vue. Pour cela, il est préférable d'utiliser les variables @EnvironmentObject.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenant au cycle de vie, il convient également de noter que le modificateur .onAppear {}, s'il est enregistré dans cette vue, fonctionne immédiatement après avoir modifié la condition et l'apparence de la vue à l'écran, avant même le début de l'animation. </font><font style="vertical-align: inherit;">En conséquence, onDisappear {} est déclenché après la fin de l'animation de disparition. </font><font style="vertical-align: inherit;">Gardez cela à l'esprit si vous prévoyez de les utiliser avec une animation de transition.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et après? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
phew </font><font style="vertical-align: inherit;">Cela s'est avéré assez volumineux, mais en détail et, je l'espère, intelligible. </font><font style="vertical-align: inherit;">Honnêtement, j'espérais parler de l'animation arc-en-ciel dans le cadre d'un article, mais je ne pouvais pas m'arrêter à temps avec les détails. </font><font style="vertical-align: inherit;">Alors attendez la suite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie suivante nous attend:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisation des dégradés: linéaire, circulaire et angulaire - tout sera utile</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couleur n'est pas du tout la couleur: choisissez judicieusement.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animation en boucle: comment démarrer et comment arrêter, et comment arrêter immédiatement (sans animation, changer l'animation - oui, il y en a une aussi)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animation actuelle du flux: priorités, remplacements, animation différente pour différents objets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">détails sur les timings d'animation: nous allons conduire des timings à la fois dans la queue et dans la crinière, jusqu'à notre propre implémentation de timingCurve (oh, gardez-moi sept :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment trouver le moment actuel de l'animation jouée</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si SwiftUI ne suffit pas</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais parler de tout cela en détail en utilisant l'exemple de la création d'une animation arc-en-ciel, comme dans l'image:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne suis pas allé par la voie facile, mais j'ai rassemblé tous les râteaux que j'ai pu atteindre, incarnant cette animation selon les principes décrits ci-dessus. </font><font style="vertical-align: inherit;">L'histoire à ce sujet devrait s'avérer très informative et riche en astuces et en toutes sortes de hacks, sur lesquels il y avait peu de rapports, et qui sera utile à ceux qui décident de devenir un pionnier de SwiftUI. </font><font style="vertical-align: inherit;">Il apparaîtra environ dans une semaine ou deux. </font><font style="vertical-align: inherit;">Au fait, vous pouvez vous abonner pour ne rien manquer. </font><font style="vertical-align: inherit;">Mais cela, bien sûr, uniquement si le matériel vous semble utile et que la méthode de présentation est approuvée. </font><font style="vertical-align: inherit;">Ensuite, votre abonnement aidera à mettre rapidement de nouveaux articles au sommet, en les amenant tôt à un public plus large. </font><font style="vertical-align: inherit;">Sinon, écrivez dans les commentaires ce qui ne va pas.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504186/index.html">Paul Graham: Comment écrire des textes utiles (complet)</a></li>
<li><a href="../fr504188/index.html">Quarantaine, systèmes en ligne et science des données. Qui pense à la fidélisation de la clientèle?</a></li>
<li><a href="../fr504190/index.html">MVCC comme moyen d'assurer l'isolement des transactions</a></li>
<li><a href="../fr504194/index.html">Le résultat d'une enquête auprès des développeurs sur Stack Overflow 2020 (+ habraopros)</a></li>
<li><a href="../fr504196/index.html">NFC: Analyse de la technologie de communication en champ proche</a></li>
<li><a href="../fr504204/index.html">Ateliers IBM: Quarkus (Java ultrarapide pour microservices), Jakarta EE et OpenShift</a></li>
<li><a href="../fr504208/index.html">Comment automatiser un centre de services partagés</a></li>
<li><a href="../fr504210/index.html">Qu'est-ce que Deno et remplacera-t-il Node.js?</a></li>
<li><a href="../fr504214/index.html">Le développement de DATA VAULT et la transition vers BUSINESS DATA VAULT</a></li>
<li><a href="../fr504216/index.html">Quel âge a cette maison. Comment j'ai fait une carte de l'âge des maisons à Saint-Pétersbourg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>