<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍⚖️ 💳 🍴 Do erro ao alerta com ações 👩🏾‍🏭 ☎️ 👩🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Para o usuário, as mensagens de erro geralmente parecem "Algo está errado, AAAA!". Claro, ele preferiria, em vez de erros, ver o erro mágico...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Do erro ao alerta com ações</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/manychat/blog/495346/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá Habr! </font><font style="vertical-align: inherit;">Para o usuário, as mensagens de erro geralmente parecem "Algo está errado, AAAA!". </font><font style="vertical-align: inherit;">Claro, ele preferiria, em vez de erros, ver o erro mágico "Reparar tudo". </font><font style="vertical-align: inherit;">Bem, ou outras opções. </font><font style="vertical-align: inherit;">Começamos a adicioná-los ativamente a nós mesmos e quero falar sobre como você pode fazer isso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/cf/s3/6qcfs3uiu0o9ajdlcfi8frjb5pg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, apresento-me - meu nome é Alexander, nos últimos seis anos dediquei o desenvolvimento iOS. </font><font style="vertical-align: inherit;">Agora sou responsável pelo aplicativo móvel ManyChat e solucionarei problemas usando o exemplo dele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos formular imediatamente o que faremos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionar funcionalidade ao tipo de erro</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transforme erros em alertas amigáveis</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibimos as possíveis ações adicionais na interface e processamos seus cliques</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E tudo isso estará no Swift :)</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos resolver o problema com um exemplo. </font><font style="vertical-align: inherit;">O servidor retornou um erro com o código 500 em vez dos 200 esperados. O que o desenvolvedor deve fazer? </font><font style="vertical-align: inherit;">No mínimo, com tristeza em informar o usuário - o post esperado com selos não pôde ser baixado. </font><font style="vertical-align: inherit;">Na Apple, o padrão padrão é alerta, então vamos escrever uma função simples:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
  <span class="hljs-comment">// -   </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleFeedResponse</span><span class="hljs-params">(...)</span></span> {
	<span class="hljs-comment">/// -    </span>
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error {
		<span class="hljs-keyword">let</span> alertVC = <span class="hljs-type">UIAlertController</span>(<font></font>
			title: <span class="hljs-string">"Error"</span>,<font></font>
			message: <span class="hljs-string">"Error connecting to the server"</span>,<font></font>
			preferredStyle: .alert)<font></font>
		<span class="hljs-keyword">let</span> action = <span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">"OK"</span>, style: .<span class="hljs-keyword">default</span>, handler: <span class="hljs-literal">nil</span>)<font></font>
		alertVC.addAction(action)<font></font>
		<span class="hljs-keyword">self</span>.present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
	}<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por simplicidade, a maior parte do código estará no controlador. </font><font style="vertical-align: inherit;">Você é livre para usar as mesmas abordagens em sua arquitetura. </font><font style="vertical-align: inherit;">O código do artigo estará disponível no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositório</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; no final do artigo, este link também estará. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos a seguinte imagem: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9o/ra/ee/9oraeel1k7noyxjplcumz1b56jy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teoricamente, concluímos a tarefa. </font><font style="vertical-align: inherit;">Mas várias coisas são imediatamente evidentes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não tivemos a oportunidade de, de alguma forma, mudar de um cenário errôneo para um cenário bem-sucedido. </font><font style="vertical-align: inherit;">OK, no caso atual, apenas oculta o alerta - e isso não é uma solução</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do ponto de vista da experiência do usuário, o texto precisa ser mais claro e neutro. </font><font style="vertical-align: inherit;">Para que o usuário não tenha medo e não corra para colocar uma estrela na AppStore no seu aplicativo. </font><font style="vertical-align: inherit;">Nesse caso, um texto detalhado nos seria útil ao depurar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, para ser sincero, os alertas estão um pouco desatualizados como solução (cada vez mais, telas ou brindes simulados aparecem nos aplicativos). </font><font style="vertical-align: inherit;">Mas essa já é uma pergunta que deve ser discutida separadamente com a equipe</font></font></li>
</ul><br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/0z/oz/jv0zozzv3foowtocsqkk_pjdifo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você deve </font><font style="vertical-align: inherit;">
admitir que a opção apresentada abaixo parece muito mais simpática. </font><font style="vertical-align: inherit;">Qualquer que seja a opção escolhida, será necessário pensar em um mecanismo para exibir uma mensagem que parecerá ótima quando ocorrer um erro arbitrário, oferecer ao usuário um script claro para trabalhos adicionais no aplicativo e fornecer um conjunto de ações. </font><font style="vertical-align: inherit;">A solução é:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve ser extensível. </font><font style="vertical-align: inherit;">Todos sabemos sobre a variabilidade inerente ao design. </font><font style="vertical-align: inherit;">Nosso mecanismo deve estar pronto para qualquer coisa</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele é adicionado ao objeto (e removido) em algumas linhas de código</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem testado</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas antes disso, vamos mergulhar no mínimo teórico para erros no Swift. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erro no Swift</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este parágrafo é uma visão geral de nível superior dos erros em geral. </font><font style="vertical-align: inherit;">Se você já estiver usando ativamente seus erros no aplicativo, poderá prosseguir com segurança para o próximo parágrafo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que é um erro? </font><font style="vertical-align: inherit;">Algum tipo de ação errada ou resultado incorreto. </font><font style="vertical-align: inherit;">Frequentemente, podemos assumir possíveis erros e descrevê-los com antecedência no código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, a Apple nos fornece o tipo Erro. </font><font style="vertical-align: inherit;">Se abrirmos a documentação da Apple, o Erro será semelhante a este (relevante para o Swift 5.1):</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Error</span> </span>{<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apenas um protocolo sem requisitos adicionais. </font><font style="vertical-align: inherit;">A documentação explica gentilmente - a falta de parâmetros necessários permite que qualquer tipo seja usado no sistema de tratamento de erros Swift. </font><font style="vertical-align: inherit;">Com um protocolo tão gentil, simplesmente trabalharemos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A idéia de usar enum imediatamente vem à minha mente: há um número conhecido finito de erros, eles podem ter algum tipo de parâmetro. </font><font style="vertical-align: inherit;">É o que a Apple está fazendo. </font><font style="vertical-align: inherit;">Por exemplo, você pode considerar implementar um DecodingError:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DecodingError</span> : <span class="hljs-title">Error</span> </span>{<font></font>
    <font></font>
        <span class="hljs-comment">/// ,     . </span>
    	<span class="hljs-comment">///  ,    </span>
        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Context</span> </span>{<font></font>
    <font></font>
    	    <span class="hljs-comment">///      </span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> codingPath: [<span class="hljs-type">CodingKey</span>]
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> debugDescription: <span class="hljs-type">String</span><font></font>
    <font></font>
    	    <span class="hljs-comment">/// ,    . </span>
            <span class="hljs-comment">///      .   </span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> underlyingError: <span class="hljs-type">Error?</span><font></font>
    <font></font>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(codingPath: [<span class="hljs-type">CodingKey</span>], debugDescription: <span class="hljs-type">String</span>, underlyingError: <span class="hljs-type">Error?</span> = <span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    <font></font>
    	<span class="hljs-comment">/// N    </span>
        <span class="hljs-keyword">case</span> typeMismatch(<span class="hljs-type">Any</span>.<span class="hljs-type">Type</span>, <span class="hljs-type">DecodingError</span>.<span class="hljs-type">Context</span>)
        <span class="hljs-keyword">case</span> valueNotFound(<span class="hljs-type">Any</span>.<span class="hljs-type">Type</span>, <span class="hljs-type">DecodingError</span>.<span class="hljs-type">Context</span>)<font></font>
    <font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aproveite as melhores práticas da Apple. </font><font style="vertical-align: inherit;">Imagine um grupo de possíveis erros de rede de forma simplificada:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">Error</span> </span>{
       <span class="hljs-comment">//  500 </span>
	<span class="hljs-keyword">case</span> serverError
        <span class="hljs-comment">//   ,   </span>
	<span class="hljs-keyword">case</span> responseError
        <span class="hljs-comment">//  ,   ,  </span>
	<span class="hljs-keyword">case</span> internetError<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, em qualquer lugar do aplicativo em que o erro ocorra, podemos usar o nosso Network.Error. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como trabalhar com bugs? Existe um mecanismo de captura. Se uma função puder gerar um erro, ela será marcada com a palavra-chave throws. Agora, cada um de seus usuários precisa acessá-lo através da construção do catch. Se não houver erro, cairemos no bloco do, com um erro, no bloco catch. As funções que levam ao erro podem ser qualquer número no bloco do. O único aspecto negativo é que, na captura, recebemos um erro do tipo Error. Você precisará converter o erro no tipo desejado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como alternativa, podemos usar o opcional, ou seja, nulo em caso de erro e se livrar do design volumoso. Às vezes, é mais conveniente: digamos que quando obtemos uma variável opcional e, em seguida, aplique uma função throws a ela. O código pode ser colocado em um bloco if / guard e permanecerá conciso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um exemplo de como trabalhar com a função throws:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">blah</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">throws</span> {
    	<span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.serverError<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">do</span> {
    	<span class="hljs-keyword">let</span> string = <span class="hljs-keyword">try</span> blah()
    	<span class="hljs-comment">//     ,      </span>
    	<span class="hljs-keyword">let</span> anotherString = <span class="hljs-keyword">try</span> blah()<font></font>
    } <span class="hljs-keyword">catch</span> {
    	<span class="hljs-comment">//  NetworkError.serverError</span>
    	<span class="hljs-built_in">print</span>(error)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//  string = nil</span>
    <span class="hljs-keyword">let</span> string = <span class="hljs-keyword">try</span>? blah()</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Não confunda com do catch em outros idiomas. Swift não lança uma exceção, mas grava o valor do erro (se aconteceu) em um registro especial. Se houver um valor, ele será direcionado para o bloco de erro; caso contrário, o bloco do continuará. Fontes para os mais curiosos: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.mikeash.com/pyblog/friday-qa-2017-08-25-swift-error-handling-implementation.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esse método é bom para manipular eventos síncronos e não é tão conveniente para operações longas (por exemplo, solicitando dados pela rede), o que pode ser potencialmente demorado. Então você pode usar a conclusão simples.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como alternativa ao Swift 5, o Result foi introduzido - uma enumeração preparada que contém duas opções - sucesso e fracasso. </font><font style="vertical-align: inherit;">Por si só, não requer o uso de Erro. </font><font style="vertical-align: inherit;">E não tem relação direta com assincronia. </font><font style="vertical-align: inherit;">Porém, retornar com precisão esse tipo à conclusão é mais conveniente para eventos assíncronos (caso contrário, você precisará executar duas finalizações, êxito e falha ou retornar dois parâmetros). </font><font style="vertical-align: inherit;">Vamos escrever um exemplo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">blah</span>&lt;ResultType&gt;<span class="hljs-params">(handler: @escaping <span class="hljs-params">(Swift.Result&lt;ResultType, Error&gt;)</span></span></span> -&gt; <span class="hljs-type">Void</span>) {<font></font>
	handler(.failure(<span class="hljs-type">NetworkError</span>.serverError)<font></font>
}<font></font>
<font></font>
blah&lt;<span class="hljs-type">String</span>&gt;(handler { result <span class="hljs-keyword">in</span> 
	<span class="hljs-keyword">switch</span> result {
		<span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> value):
			<span class="hljs-built_in">print</span>(value)
		<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
			<span class="hljs-built_in">print</span>(error)<font></font>
	}<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta informação é suficiente para trabalharmos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais uma vez, brevemente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros no Swift é um protocolo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É conveniente apresentar erros na forma de enum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas maneiras de lidar com erros - síncrona (captura) e assíncrona (sua própria competição ou resultado)</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texto de erro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos voltar ao tópico do artigo. </font><font style="vertical-align: inherit;">No parágrafo acima, criamos nosso próprio tipo de erro. </font><font style="vertical-align: inherit;">Ali está ele:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">Error</span> </span>{
        <span class="hljs-comment">//  500 </span>
	<span class="hljs-keyword">case</span> serverError
        <span class="hljs-comment">//   ,   </span>
	<span class="hljs-keyword">case</span> responseError
        <span class="hljs-comment">//  ,   ,  </span>
	<span class="hljs-keyword">case</span> internetError<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, precisamos combinar cada erro com um texto que seja compreensível para o usuário. </font><font style="vertical-align: inherit;">Vamos exibi-lo na interface em caso de erro. </font><font style="vertical-align: inherit;">O Protocolo LocalizedError se apressa para nos ajudar. </font><font style="vertical-align: inherit;">Ele herda o erro de protocolo e o complementa com 4 propriedades:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">LocalizedError</span> : <span class="hljs-title">Error</span> </span>{
    <span class="hljs-keyword">var</span> errorDescription: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> failureReason: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> recoverySuggestion: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> helpAnchor: <span class="hljs-type">String?</span> { <span class="hljs-keyword">get</span> }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementamos o protocolo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">LocalizedError</span> </span>{
    	<span class="hljs-keyword">var</span> errorDescription: <span class="hljs-type">String?</span> {
            <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">case</span> .serverError, .responseError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Error"</span>
    	    <span class="hljs-keyword">case</span> .internetError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"No Internet Connection"</span><font></font>
            }<font></font>
        }<font></font>
    <font></font>
        <span class="hljs-keyword">var</span> failureReason: <span class="hljs-type">String?</span> {
            <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">case</span> .serverError, .responseError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Something went wrong"</span>
    	    <span class="hljs-keyword">case</span> .internetError:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
            }<font></font>
        }<font></font>
    <font></font>
        <span class="hljs-keyword">var</span> recoverySuggestion: <span class="hljs-type">String?</span> {
            <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">case</span> .serverError, .responseError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Please, try again"</span>
    	    <span class="hljs-keyword">case</span> .internetError:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Please check your internet connection and try again"</span><font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A exibição do erro dificilmente mudará:</font></font><br>
<br>
<pre><code class="swift hljs">	<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error {
		<span class="hljs-keyword">let</span> errorMessage = [error.failureReason, error.recoverySuggestion].<span class="hljs-built_in">compactMap</span>({ $<span class="hljs-number">0</span> }).joined(separator: <span class="hljs-string">". "</span>)
		<span class="hljs-keyword">let</span> alertVC = <span class="hljs-type">UIAlertController</span>(<font></font>
			title: error.errorDescription,<font></font>
			message: errorMessage,<font></font>
			preferredStyle: .alert)<font></font>
		<span class="hljs-keyword">let</span> action = <span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">"OK"</span>, style: .<span class="hljs-keyword">default</span>) { (<span class="hljs-number">_</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> }<font></font>
		alertVC.addAction(action)<font></font>
		<span class="hljs-keyword">self</span>.present(alertVC, animated: <span class="hljs-literal">true</span>, competion: <span class="hljs-literal">nil</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ótimo, tudo foi fácil com o texto. </font><font style="vertical-align: inherit;">Vamos para os botões.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recuperação de erro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos apresentar o algoritmo de tratamento de erros em um diagrama simples. </font><font style="vertical-align: inherit;">Para uma situação em que, como resultado de um erro, mostramos uma caixa de diálogo com as opções Tentar Novamente, Cancelar e, possivelmente, algumas específicas, obtemos o esquema: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a9/te/n3/a9ten3zbrffm7sz8kkupfo8xsuy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Começaremos a resolver o problema a partir do final. </font><font style="vertical-align: inherit;">Precisamos de uma função que mostre um alerta com n + 1 opções. </font><font style="vertical-align: inherit;">Jogamos, como gostaríamos de mostrar um erro:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecovableAction</span> </span>{
    	<span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>
    	<span class="hljs-keyword">let</span> action: () -&gt; <span class="hljs-type">Void</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showRecovableOptions</span><span class="hljs-params">(actions: [RecovableAction], from viewController: UIViewController)</span></span> {
    	<span class="hljs-keyword">let</span> alertActions = actions.<span class="hljs-built_in">map</span> { <span class="hljs-type">UIAlertAction</span>(name: $<span class="hljs-number">0</span>.title, action: $<span class="hljs-number">0</span>.action) }
    	<span class="hljs-keyword">let</span> cancelAction = <span class="hljs-type">UIAlertAction</span>(name: <span class="hljs-string">"Cancel"</span>, action: <span class="hljs-literal">nil</span>)
    	<span class="hljs-keyword">let</span> alertController = <span class="hljs-type">UIAlertController</span>(actions: alertActions)<font></font>
    	viewController.present(alertController, complition: <span class="hljs-literal">nil</span>)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma função que determina o tipo de erro e transmite um sinal para exibir um alerta:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleError</span><span class="hljs-params">(error: Error)</span></span> {
	<span class="hljs-keyword">if</span> error <span class="hljs-keyword">is</span> <span class="hljs-type">RecovableError</span> {<font></font>
		showRecovableOptions(actions: error.actions, from: viewController)<font></font>
		<span class="hljs-keyword">return</span><font></font>
	}<font></font>
	showErrorAlert(...)<font></font>
} </code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E um tipo de erro estendido, que possui um contexto e entendimento do que fazer com essa ou aquela opção.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecovableError</span>: <span class="hljs-title">Error</span> </span>{
	<span class="hljs-keyword">let</span> recovableACtions: [<span class="hljs-type">RecovableAction</span>]
	<span class="hljs-keyword">let</span> context: <span class="hljs-type">Context</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A cabeça desenha imediatamente um diagrama da sua bicicleta. </font><font style="vertical-align: inherit;">Mas primeiro, vamos verificar as docas da Apple. </font><font style="vertical-align: inherit;">Talvez parte do mecanismo já esteja em nossas mãos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação nativa?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um pouco de pesquisa na Internet resultará no protocolo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecoverableError</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">// A specialized error that may be recoverable by presenting several potential recovery options to the user.</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RecoverableError</span> : <span class="hljs-title">Error</span> </span>{
    <span class="hljs-keyword">var</span> recoveryOptions: [<span class="hljs-type">String</span>] { <span class="hljs-keyword">get</span> }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping <span class="hljs-params">(Bool)</span></span></span> -&gt; <span class="hljs-type">Void</span>)
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex recoveryOptionIndex: Int)</span></span> -&gt; <span class="hljs-type">Bool</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que estamos procurando:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recoveryOptions: [String] - uma propriedade que armazena opções de recuperação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">func tryRecovery (optionIndex: Int) -&gt; Bool - restaura de um erro de forma síncrona. </font><font style="vertical-align: inherit;">Verdadeiro - com sucesso</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">func tryRecovery (optionIndex: Int, resultHandler: (Bool) -&gt; Void) - opção assíncrona, a ideia é a mesma</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com os guias de uso, tudo é mais modesto. </font><font style="vertical-align: inherit;">Uma pequena pesquisa no site da Apple e na área circundante leva a um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo sobre tratamento de erros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito antes dos anúncios públicos de Swift. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumidamente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mecanismo foi desenvolvido para aplicativos MacOs e mostra uma caixa de diálogo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi originalmente construído em torno do NSError.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objeto RecoveryAttempter é encapsulado dentro do erro em userInfo, que conhece as condições do erro e pode escolher a melhor solução para o problema. </font><font style="vertical-align: inherit;">O objeto não deve ser nulo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecoveryAttempter deve oferecer suporte ao protocolo informal NSErrorRecoveryAttempting</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também em userInfo deve haver opção de recuperação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E tudo está ligado à chamada do método presentError, que está apenas no macOS SDK. </font><font style="vertical-align: inherit;">Ele mostra um alerta</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o alerta for mostrado através do presentError, quando você selecionar uma opção na janela pop-up no AppDelegate, uma função interessante será alterada:</font></font></li>
</ul><br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(fromError error: Error, optionIndex recoveryOptionIndex: Int, delegate: <span class="hljs-keyword">Any</span>?, didRecoverSelector: Selector?, contextInfo: UnsafeMutableRawPointer?)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas como não temos presentError, não podemos obtê-lo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vp/xo/cj/vpxocjapqc5ywmiq8hhq3djow6o.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste ponto, parece que desenterramos um cadáver em vez de um tesouro. </font><font style="vertical-align: inherit;">Teremos que transformar Error em NSError e escrever nossa própria função para exibir o alerta pelo aplicativo. </font><font style="vertical-align: inherit;">Um monte de conexões implícitas. </font><font style="vertical-align: inherit;">É possível, difícil e não totalmente claro - “Por quê?”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto a próxima xícara de chá estiver sendo preparada, pode-se perguntar por que a função acima usa delegate como Any e passa no seletor. </font><font style="vertical-align: inherit;">A resposta está abaixo:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Responda</font></font></b><div class="spoiler_text">      iOS 2.          !         ( ,   ).  :)<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construindo uma bicicleta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos implementar o protocolo, não vai nos machucar:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoverableError</span>: <span class="hljs-title">Foundation</span>.<span class="hljs-title">RecoverableError</span> </span>{
	<span class="hljs-keyword">let</span> error: <span class="hljs-type">Error</span>
	<span class="hljs-keyword">var</span> recoveryOptions: [<span class="hljs-type">String</span>] {
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"Try again"</span>]s<font></font>
	}<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex recoveryOptionIndex: Int)</span></span> -&gt; <span class="hljs-type">Bool</span> {
		<span class="hljs-comment">//  ,    </span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
	}<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(optionIndex: Int, resultHandler: <span class="hljs-params">(Bool)</span></span></span> -&gt; <span class="hljs-type">Void</span>) {
		<span class="hljs-comment">//      . </span>
               <span class="hljs-comment">//      </span>
		<span class="hljs-keyword">switch</span> optionIndex {
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
				resultHandler(<span class="hljs-literal">true</span>)
			<span class="hljs-keyword">default</span>: <font></font>
				resultHandler(<span class="hljs-literal">false</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A dependência de índice não é a solução mais conveniente (podemos facilmente ir além da matriz e travar o aplicativo). </font><font style="vertical-align: inherit;">Mas para MVP vai fazer. </font><font style="vertical-align: inherit;">Pegue a idéia da Apple, apenas modernize-a. </font><font style="vertical-align: inherit;">Precisamos de um objeto Attempter separado e de opções de botão que iremos fornecer:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoveryAttemper</span> </span>{
    	<span class="hljs-comment">//   </span>
    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _recoveryOptions: [<span class="hljs-type">RecoveryOptions</span>]<font></font>
    <font></font>
    	<span class="hljs-keyword">var</span> recoveryOptionsText: [<span class="hljs-type">String</span>] {
    		<span class="hljs-keyword">return</span> _recoveryOptions.<span class="hljs-built_in">map</span>({ $<span class="hljs-number">0</span>.title })<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">init</span>(options: [<span class="hljs-type">RecoveryOptions</span>] {<font></font>
    		_recoveryOptions = recoveryOptions<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-comment">//    </span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attemptRecovery</span><span class="hljs-params">(fromError error: Error, optionIndex: Int)</span></span> -&gt; <span class="hljs-type">Bool</span> {
    		<span class="hljs-keyword">let</span> option = _recoveryOptions[optionIndex]
    				<span class="hljs-keyword">switch</span> option {
    				<span class="hljs-keyword">case</span> .tryAgain(<span class="hljs-keyword">let</span> action)<font></font>
    					action()<font></font>
    					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    				<span class="hljs-keyword">case</span> .cancel:
    					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
    				}<font></font>
    		}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//  enum,       </span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RecoveryOptions</span> </span>{
    	<span class="hljs-comment">//      (,     )</span>
    	<span class="hljs-keyword">case</span> tryAgain(action: (() -&gt; <span class="hljs-type">Void</span>))
    	<span class="hljs-keyword">case</span> cancel<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você precisa mostrar o erro. </font><font style="vertical-align: inherit;">Eu realmente gosto de protocolos, então resolverei o problema através deles. </font><font style="vertical-align: inherit;">Vamos criar um protocolo universal para criar um UIAlertController a partir de erros:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertCreatable</span>: <span class="hljs-title">class</span>, <span class="hljs-title">ErrorReasonExtractable</span> </span>{
    	<span class="hljs-comment">//     </span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">UIAlertController</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertCreatable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">UIViewController</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-comment">//      </span>
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recoverableError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">RecoverableError</span> {
    			<span class="hljs-keyword">return</span> createRecoverableAlert(<span class="hljs-keyword">for</span>: recoverableError)<font></font>
    		}<font></font>
    		<span class="hljs-keyword">let</span> defaultTitle = <span class="hljs-string">"Error"</span>
    		<span class="hljs-keyword">let</span> description = errorReason(from: error)<font></font>
    <font></font>
    		<span class="hljs-comment">//          </span>
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localizedError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">LocalizedError</span> {
    			<span class="hljs-keyword">return</span> createAlert(<font></font>
    				title: localizedError.errorDescription ?? defaultTitle,<font></font>
    				message: description,<font></font>
    				actions: [.okAction],<font></font>
    				aboveAll: aboveAll)<font></font>
    		}<font></font>
    <font></font>
    		<span class="hljs-keyword">return</span> createAlert(title: defaultTitle, message: description, actions: [.okAction])<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(title: String?, message: String?, actions: [UIAlertAction])</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">let</span> alertViewController = <span class="hljs-type">UIAlertController</span>(title: title, message: message, preferredStyle: .alert)<font></font>
    		actions.forEach({ alertViewController.addAction($<span class="hljs-number">0</span>) })
    		<span class="hljs-keyword">return</span> alertViewController<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createRecoverableAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> recoverableError: RecoverableError)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">let</span> title = recoverableError.errorDescription
    		<span class="hljs-keyword">let</span> message = recoverableError.recoverySuggestion
    		<span class="hljs-comment">//     . </span>
    		<span class="hljs-keyword">let</span> actions = recoverableError.recoveryOptions.enumerated().<span class="hljs-built_in">map</span> { (element) -&gt; <span class="hljs-type">UIAlertAction</span> <span class="hljs-keyword">in</span>
    		<span class="hljs-keyword">let</span> style: <span class="hljs-type">UIAlertAction</span>.<span class="hljs-type">Style</span> = element.offset == <span class="hljs-number">0</span> ? .cancel : .<span class="hljs-keyword">default</span>
    		<span class="hljs-keyword">return</span> <span class="hljs-type">UIAlertAction</span>(title: element.element, style: style) { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span><font></font>
    			recoverableError.attemptRecovery(optionIndex: element.offset)<font></font>
    		      }<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> createAlert(title: title, message: message, actions: actions)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createOKAlert</span><span class="hljs-params">(with text: String)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">return</span> createAlert(title: text, message: <span class="hljs-literal">nil</span>, actions: [.okAction])<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ERror</span>
    
    //     <span class="hljs-title">ok</span>
    <span class="hljs-title">extension</span> <span class="hljs-title">UIAlertAction</span> </span>{
    	<span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> okAction = <span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">"OK"</span>, style: .cancel) { (<span class="hljs-number">_</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorReasonExtractable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorReason</span><span class="hljs-params">(from error: Error)</span></span> -&gt; <span class="hljs-type">String?</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorReasonExtractable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorReason</span><span class="hljs-params">(from error: Error)</span></span> -&gt; <span class="hljs-type">String?</span> {
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localizedError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">LocalizedError</span> {
    			<span class="hljs-keyword">return</span> localizedError.recoverySuggestion<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> <span class="hljs-string">"Something bad happened. Please try again"</span><font></font>
    	}<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o protocolo para mostrar alertas criados:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertPresentable</span>: <span class="hljs-title">class</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// MARK: - Default implementation</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertPresentable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">ErrorAlertCreatable</span> &amp; <span class="hljs-title">UIViewController</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span> {
		<span class="hljs-keyword">let</span> alertVC = createAlert(<span class="hljs-keyword">for</span>: error)<font></font>
		present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acabou sendo complicado, mas gerenciável. </font><font style="vertical-align: inherit;">Podemos criar novas maneiras de mostrar um erro (por exemplo, brindar ou mostrar uma exibição personalizada) e registrar a implementação padrão sem alterar nada no método chamado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que nossa visão fosse coberta por um protocolo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerInput</span>: <span class="hljs-title">class</span> </span>{
     <span class="hljs-comment">//  </span><font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewControllerInput</span>: <span class="hljs-title">ErrorAlertPresentable</span> </span>{ }<font></font>
    <font></font>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorAlertCreatable</span> </span>{ }
    <span class="hljs-comment">//  ,         ,    </span>
    <span class="hljs-comment">//    </span><font></font>
    <font></font>
    <span class="hljs-comment">//       "",    ErrorAlertPresentable      . </span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorToastCreatable</span> </span>{ }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas como nosso exemplo é muito mais simples, suportamos os dois protocolos e executamos o aplicativo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestFeed</span><span class="hljs-params">(...)</span></span> {<font></font>
    		service.requestObject { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    			<span class="hljs-keyword">switch</span> result {
    			<span class="hljs-keyword">case</span> .success:
    				<span class="hljs-keyword">break</span>
    			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    				<span class="hljs-comment">//           </span>
    				<span class="hljs-comment">// -     (   viewController)  ,</span>
    				<span class="hljs-comment">//    .     tryAgainOption </span>
    				<span class="hljs-keyword">let</span> tryAgainOption = <span class="hljs-type">RecoveryOptions</span>.tryAgain {
    					<span class="hljs-keyword">self</span>.requestFeed(...)<font></font>
    				}<font></font>
    				<span class="hljs-keyword">let</span> recoveryOptions = [tryAgainOption]
    				<span class="hljs-keyword">let</span> attempter = <span class="hljs-type">RecoveryAttemper</span>(recoveryOptions: recoveryOptions)
    				<span class="hljs-keyword">let</span> recovableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: attempter)
    				<span class="hljs-keyword">self</span>.presentAlert(from: recovableError)<font></font>
    			}<font></font>
    		}<font></font>
    	}<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertCreatable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorAlertCreatable</span> </span>{ }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertPresentable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorAlertPresentable</span> </span>{ }</code></pre><br>
<img src="https://habrastorage.org/webt/3h/fl/vh/3hflvhmxpfkuzgskzcpe9hodl2k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que tudo deu certo. </font><font style="vertical-align: inherit;">Uma das condições iniciais estava em 2-3 linhas. </font><font style="vertical-align: inherit;">Expandiremos nossa tentativa com um construtor conveniente:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoveryAttemper</span> </span>{
    	<span class="hljs-comment">//</span><font></font>
    	...<font></font>
    	<span class="hljs-comment">//</span>
    	<span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tryAgainAttempter</span><span class="hljs-params">(block: @escaping <span class="hljs-params">(<span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)) -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">RecoveryAttemper</span>(recoveryOptions: [.cancel, .tryAgain(action: block)])<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestFeed</span><span class="hljs-params">()</span></span> {<font></font>
    		service.requestObject { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    			<span class="hljs-keyword">switch</span> result {
    			<span class="hljs-keyword">case</span> .success:
    				<span class="hljs-keyword">break</span>
    			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    				<span class="hljs-comment">//    </span>
    				<span class="hljs-keyword">let</span> recovableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: .tryAgainAttempter(block: {
    					<span class="hljs-keyword">self</span>.requestFeed()<font></font>
    				}))<font></font>
    				<span class="hljs-keyword">self</span>.presentAlert(from: recovableError)<font></font>
    			}<font></font>
    		}<font></font>
    	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos a solução MVP, e não será difícil conectar e chamá-la em qualquer lugar do nosso aplicativo. </font><font style="vertical-align: inherit;">Vamos começar a verificar casos extremos e escalabilidade.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se tivermos vários cenários de saída?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que um usuário tenha um repositório em nosso aplicativo. </font><font style="vertical-align: inherit;">O cofre tem um limite de local. </font><font style="vertical-align: inherit;">Nesse caso, o usuário tem dois cenários para sair do erro: ele pode liberar espaço ou comprar mais. </font><font style="vertical-align: inherit;">Vamos escrever o seguinte código:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//  </span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runOutOfSpace</span><span class="hljs-params">()</span></span> {<font></font>
    		service.runOfSpace { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    			<span class="hljs-keyword">switch</span> result {
    			<span class="hljs-keyword">case</span> .success:
    				<span class="hljs-keyword">break</span>
    			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    				<span class="hljs-keyword">let</span> notEnoughSpace = <span class="hljs-type">RecoveryOptions</span>.freeSpace {
    					<span class="hljs-keyword">self</span>.freeSpace()<font></font>
    				}<font></font>
    <font></font>
    				<span class="hljs-keyword">let</span> buyMoreSpace = <span class="hljs-type">RecoveryOptions</span>.buyMoreSpace {
    					<span class="hljs-keyword">self</span>.buyMoreSpace()<font></font>
    				}<font></font>
    				<span class="hljs-keyword">let</span> options = [notEnoughSpace, buyMoreSpace]
    				<span class="hljs-keyword">let</span> recovableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: .cancalableAttemter(options: options))
    				<span class="hljs-keyword">self</span>.presentAlert(from: recovableError)<font></font>
    			}<font></font>
    		}<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">freeSpace</span><span class="hljs-params">()</span></span> {
    		<span class="hljs-keyword">let</span> alertViewController = createOKAlert(with: <span class="hljs-string">"Free space selected"</span>)<font></font>
    		present(alertViewController, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buyMoreSpace</span><span class="hljs-params">()</span></span> {
    		<span class="hljs-keyword">let</span> alertViewController = createOKAlert(with: <span class="hljs-string">"Buy more space selected"</span>)<font></font>
    		present(alertViewController, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    <font></font>
    <font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecoveryAttemper</span> </span>{
    	<span class="hljs-comment">//</span><font></font>
    	...<font></font>
    	<span class="hljs-comment">//</span>
    	<span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancalableAttemter</span><span class="hljs-params">(options: [RecoveryOptions])</span></span> -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">RecoveryAttemper</span>(recoveryOptions: [.cancel] + options)<font></font>
    	}<font></font>
    }<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/d5/eg/zq/d5egzquyykwxtjorhevcq2pe1mg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso foi facilmente resolvido. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se queremos mostrar não um alerta, mas uma exibição de informações no meio da tela?</font></font></h3><br>
<img src="https://habrastorage.org/webt/fg/xr/pq/fgxrpqsgg_yqmy4txescavcvdvc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns novos protocolos por analogia resolverão nosso problema:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorViewCreatable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createErrorView</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">ErrorView</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorViewCreatable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createErrorView</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error)</span></span> -&gt; <span class="hljs-type">ErrorView</span> {
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recoverableError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">RecoverableError</span> {
    			<span class="hljs-keyword">return</span> createRecoverableAlert(<span class="hljs-keyword">for</span>: recoverableError)<font></font>
    		}<font></font>
    <font></font>
    		<span class="hljs-keyword">let</span> defaultTitle = <span class="hljs-string">"Error"</span>
    		<span class="hljs-keyword">let</span> description = errorReason(from: error)
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localizedError = error <span class="hljs-keyword">as</span>? <span class="hljs-type">LocalizedError</span> {
    			<span class="hljs-keyword">return</span> createErrorView(<font></font>
    				title: localizedError.errorDescription ?? defaultTitle,<font></font>
    				message: description)<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> createErrorView(title: defaultTitle, message: description)<font></font>
    		}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createErrorView</span><span class="hljs-params">(title: String?, message: String?, actions: [ErrorView.Action] = [])</span></span> -&gt; <span class="hljs-type">ErrorView</span> {
    		<span class="hljs-comment">//  ErrorView        . </span>
                <span class="hljs-comment">//     github</span>
    		<span class="hljs-keyword">return</span> <span class="hljs-type">ErrorView</span>(title: title, description: message, actions: actions)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createRecoverableAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> recoverableError: RecoverableError)</span></span> -&gt; <span class="hljs-type">ErrorView</span> {
    		<span class="hljs-keyword">let</span> title = recoverableError.errorDescription
    		<span class="hljs-keyword">let</span> message = errorReason(from: recoverableError)
    		<span class="hljs-keyword">let</span> actions = recoverableError.recoveryOptions.enumerated().<span class="hljs-built_in">map</span> { (element) -&gt; <span class="hljs-type">ErrorView</span>.<span class="hljs-type">Action</span> <span class="hljs-keyword">in</span>
    			<span class="hljs-keyword">return</span> <span class="hljs-type">ErrorView</span>.<span class="hljs-type">Action</span>(title: element.element) {<font></font>
    				recoverableError.attemptRecovery(optionIndex: element.offset)<font></font>
    			}<font></font>
    		}<font></font>
    		<span class="hljs-keyword">return</span> createErrorView(title: title, message: message, actions: actions)<font></font>
    	}<font></font>
    }</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorViewAddable</span>: <span class="hljs-title">class</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentErrorView</span><span class="hljs-params">(from error: Error)</span></span><font></font>
    <font></font>
    	<span class="hljs-keyword">var</span> errorViewSuperview: <span class="hljs-type">UIView</span> { <span class="hljs-keyword">get</span> }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorViewAddable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">ErrorViewCreatable</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentErrorView</span><span class="hljs-params">(from error: Error)</span></span> {
    		<span class="hljs-keyword">let</span> errorView = createErrorView(<span class="hljs-keyword">for</span>: error)<font></font>
    		errorViewSuperview.addSubview(errorView)<font></font>
    		errorView.center = errorViewSuperview.center<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <font></font>
    <span class="hljs-comment">//    </span><font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertCreatable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorViewCreatable</span> </span>{ }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ErrorAlertPresentable</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ErrorViewAddable</span> </span>{
    	<span class="hljs-keyword">var</span> errorViewSuperview: <span class="hljs-type">UIView</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    	}<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos mostrar erros na forma de uma exibição de informações. </font><font style="vertical-align: inherit;">Além disso, podemos decidir como mostrá-los. </font><font style="vertical-align: inherit;">Por exemplo, a primeira vez que você entra na tela e o erro - mostra a exibição de informações. </font><font style="vertical-align: inherit;">E se a tela foi carregada com sucesso, mas a ação na tela retornou um erro - mostre um alerta.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se não houver acesso à exibição?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Às vezes, você precisa gerar um erro, mas não há acesso à exibição. </font><font style="vertical-align: inherit;">Ou não sabemos qual visualização está ativa no momento e queremos mostrar um alerta sobre tudo. </font><font style="vertical-align: inherit;">Como resolver este problema? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma das maneiras mais fáceis (na minha opinião) de fazer a mesma coisa que a Apple faz com o teclado. </font><font style="vertical-align: inherit;">Crie uma nova janela na parte superior da tela atual. </font><font style="vertical-align: inherit;">Vamos fazer isso:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-meta">@UIApplicationMain</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">UIResponder</span>, <span class="hljs-title">UIApplicationDelegate</span> </span>{<font></font>
<font></font>
	<span class="hljs-comment">//   –   . </span>
	<span class="hljs-comment">//              DI</span>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> errorWindow: <span class="hljs-type">UIWindow</span> = {
		<span class="hljs-keyword">let</span> alertWindow = <span class="hljs-type">UIWindow</span>.<span class="hljs-keyword">init</span>(frame: <span class="hljs-type">UIScreen</span>.main.bounds)<font></font>
		alertWindow.backgroundColor = .clear<font></font>
<font></font>
		<span class="hljs-comment">//  rootViewController,    present   viewController</span>
		<span class="hljs-keyword">let</span> viewController = <span class="hljs-type">UIViewController</span>()<font></font>
		viewController.view.backgroundColor = .clear<font></font>
		alertWindow.rootViewController = viewController<font></font>
<font></font>
		<span class="hljs-keyword">return</span> alertWindow<font></font>
	}()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crie um novo alerta que possa ser mostrado acima de tudo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AboveAllAlertController</span>: <span class="hljs-title">UIAlertController</span> </span>{
	<span class="hljs-keyword">var</span> alertWindow: <span class="hljs-type">UIWindow</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-type">AppDelegate</span>.alertWindow<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">let</span> topWindow = <span class="hljs-type">UIApplication</span>.shared.windows.last
		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> topWindow = topWindow {<font></font>
			alertWindow.windowLevel = topWindow.windowLevel + <span class="hljs-number">1</span><font></font>
		}<font></font>
<font></font>
		alertWindow.makeKeyAndVisible()<font></font>
		alertWindow.rootViewController?.present(<span class="hljs-keyword">self</span>, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewWillDisappear</span><span class="hljs-params">(<span class="hljs-number">_</span> animated: Bool)</span></span> {
		<span class="hljs-keyword">super</span>.viewWillDisappear(animated)<font></font>
<font></font>
		alertWindow.isHidden = <span class="hljs-literal">true</span><font></font>
	}<font></font>
}</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertCreatable</span>: <span class="hljs-title">class</span> </span>{
    	<span class="hljs-comment">//      </span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(<span class="hljs-keyword">for</span> error: Error, aboveAll: Bool)</span></span> -&gt; <span class="hljs-type">UIAlertController</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertCreatable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">UIViewController</span> </span>{<font></font>
    	...<font></font>
    	<span class="hljs-comment">//     </span>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createAlert</span><span class="hljs-params">(title: String?, message: String?, actions: [UIAlertAction], aboveAll: Bool)</span></span> -&gt; <span class="hljs-type">UIAlertController</span> {
    		<span class="hljs-keyword">let</span> alertViewController = aboveAll ?
    			<span class="hljs-type">AboveAllAlertController</span>(title: title, message: message, preferredStyle: .alert) :
    			<span class="hljs-type">UIAlertController</span>(title: title, message: message, preferredStyle: .alert)<font></font>
    		actions.forEach({ alertViewController.addAction($<span class="hljs-number">0</span>) })
    		<span class="hljs-keyword">return</span> alertViewController<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//     </span>
    <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ErrorAlertPresentable</span>: <span class="hljs-title">class</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlertAboveAll</span><span class="hljs-params">(from error: Error)</span></span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - Default implementation</span>
    <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ErrorAlertPresentable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">ErrorAlertCreatable</span> &amp; <span class="hljs-title">UIViewController</span> </span>{
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlert</span><span class="hljs-params">(from error: Error)</span></span> {
    		<span class="hljs-keyword">let</span> alertVC = createAlert(<span class="hljs-keyword">for</span>: error, aboveAll: <span class="hljs-literal">false</span>)<font></font>
    		present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentAlertAboveAll</span><span class="hljs-params">(from error: Error)</span></span> {
    		<span class="hljs-keyword">let</span> alertVC = createAlert(<span class="hljs-keyword">for</span>: error, aboveAll: <span class="hljs-literal">true</span>)
    		<span class="hljs-comment">//         </span>
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> alertVC = alertVC <span class="hljs-keyword">as</span>? <span class="hljs-type">AboveAllAlertController</span> {<font></font>
    			alertVC.show()<font></font>
    			<span class="hljs-keyword">return</span><font></font>
    		}<font></font>
    		<span class="hljs-comment">//    ,  - </span>
    		<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">"Should create AboveAllAlertController"</span>)<font></font>
    		present(alertVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<font></font>
    	}<font></font>
    }</code></pre><br>
<img src="https://habrastorage.org/webt/qr/es/uo/qresuobexdwaxevl3gnmsfjsc6i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na aparência, nada mudou, mas agora nos livramos da hierarquia de controladores de exibição. </font><font style="vertical-align: inherit;">Eu recomendo não se deixar levar por esta oportunidade. </font><font style="vertical-align: inherit;">É melhor chamar o código de exibição em um roteador ou entidade com os mesmos direitos. </font><font style="vertical-align: inherit;">Em nome da transparência e clareza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fornecemos aos usuários uma ótima ferramenta para enviar spam a servidores durante mau funcionamento, manutenção etc. </font><font style="vertical-align: inherit;">O que podemos melhorar?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo mínimo de solicitação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que desligemos a Internet e tente novamente. </font><font style="vertical-align: inherit;">Execute o carregador. </font><font style="vertical-align: inherit;">A resposta virá instantaneamente e obterá um mini-jogo "Clicker". </font><font style="vertical-align: inherit;">Com animação piscando. </font><font style="vertical-align: inherit;">Não é legal demais. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/3n/mu/uz3nmu7_ag_k4swmsiy8gw2y1z0.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos transformar um erro instantâneo em um processo. </font><font style="vertical-align: inherit;">A idéia é simples - faremos o tempo mínimo de solicitação. </font><font style="vertical-align: inherit;">Aqui a implementação depende da sua abordagem à rede. </font><font style="vertical-align: inherit;">Suponha que eu use Operation e, para mim, seja assim:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayOperation</span>: <span class="hljs-title">AsyncOperation</span> </span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _delayTime: <span class="hljs-type">Double</span><font></font>
<font></font>
	<span class="hljs-keyword">init</span>(delayTime: <span class="hljs-type">Double</span> = <span class="hljs-number">0.3</span>) {<font></font>
		_delayTime = delayTime<font></font>
	}<font></font>
	<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">super</span>.main()<font></font>
<font></font>
		<span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + _delayTime) {
			<span class="hljs-keyword">self</span>.state = .finished<font></font>
		}<font></font>
	}<font></font>
}<font></font>
		<font></font>
<span class="hljs-comment">// -  </span>
<span class="hljs-keyword">let</span> flowListOperation = flowService.list(<span class="hljs-keyword">for</span>: pageID, path: path, limiter: limiter)
<span class="hljs-keyword">let</span> handler = createHandler(<span class="hljs-keyword">for</span>: flowListOperation)
<span class="hljs-keyword">let</span> delayOperation = <span class="hljs-type">DelayOperation</span>(delayTime: <span class="hljs-number">0.5</span>)
<span class="hljs-comment">///  &gt;&gt;&gt;  addDependency. </span><font></font>
[flowListOperation, delayOperation] &gt;&gt;&gt; handler<font></font>
operationQueue.addOperations([flowListOperation, delayOperation, handler])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o caso geral, posso oferecer este design:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//  global      </span>
<span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + <span class="hljs-number">0.15</span>) {
    <span class="hljs-comment">// your code here</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou podemos fazer uma abstração sobre nossas ações assíncronas e adicionar gerenciamento a ela:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span> </span>{
    	<span class="hljs-keyword">let</span> closure: () -&gt; <span class="hljs-type">Void</span><font></font>
    <font></font>
    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _delayTime: <span class="hljs-type">Double?</span><font></font>
    <font></font>
    	<span class="hljs-keyword">init</span>(closure: @escaping () -&gt; <span class="hljs-type">Void</span>) {
    		<span class="hljs-keyword">self</span>.closure = closure<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">init</span>(closure: @escaping () -&gt; <span class="hljs-type">Void</span>, time: <span class="hljs-type">Double</span>) {
    		<span class="hljs-keyword">self</span>.closure = closure<font></font>
    		_delayTime = time<font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-meta">@discardableResult</span>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> delayTime = _delayTime {
    			<span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + delayTime) {
    				<span class="hljs-keyword">self</span>.closure()<font></font>
    			}<font></font>
    			<span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    		}<font></font>
    		closure()<font></font>
    		<span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    	}<font></font>
    <font></font>
    	<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">delayedTask</span><span class="hljs-params">(time: Double)</span></span> -&gt; <span class="hljs-type">Self</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">Task</span>(closure: closure, time: time)<font></font>
    	}<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestObject</span><span class="hljs-params">(completionHandler: @escaping <span class="hljs-params">(<span class="hljs-params">(Result&lt;Bool, Error&gt;)</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)) -&gt; <span class="hljs-type">Task</span> {
    		<span class="hljs-keyword">return</span> <span class="hljs-type">Task</span> {<font></font>
    			completionHandler(.failure(<span class="hljs-type">NetworkError</span>.internetError))<font></font>
    		}<font></font>
    			.delayedTask(time: <span class="hljs-number">0.5</span>)<font></font>
    		.run()<font></font>
    	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, nossa animação não parecerá tão nítida, mesmo quando estiver offline. </font><font style="vertical-align: inherit;">Eu recomendo usar essa abordagem na maioria dos lugares com animação. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9k/oq/46/9koq46qq0wffoivy0ucs18om1cm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o modo avião, é bom exibir um prompt de alerta (o usuário pode esquecer de desativar o modo para começar a trabalhar com o aplicativo). </font><font style="vertical-align: inherit;">Como, digamos, faz um telegrama. </font><font style="vertical-align: inherit;">E para consultas importantes, é bom repetir várias vezes antes de mostrar um alerta ... Mas mais sobre isso outra vez :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testabilidade</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando toda a lógica é despejada no viewController (como temos agora), é difícil testar. </font><font style="vertical-align: inherit;">No entanto, se o seu viewController for compartilhado com a lógica de negócios, o teste se tornará uma tarefa trivial. </font><font style="vertical-align: inherit;">Com um movimento das </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calças, a</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lógica de negócios se transforma em:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestFeed</span><span class="hljs-params">()</span></span> {<font></font>
		service.requestObject { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (result) <span class="hljs-keyword">in</span>
			<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> `<span class="hljs-keyword">self</span>` = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
			<span class="hljs-keyword">switch</span> result {
			<span class="hljs-keyword">case</span> .success:
				<span class="hljs-keyword">break</span>
			<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
				<span class="hljs-type">DispatchQueue</span>.main.async {
					<span class="hljs-keyword">let</span> recoverableError = <span class="hljs-type">RecoverableError</span>(error: error, attempter: .tryAgainAttempter(block: {
						<span class="hljs-keyword">self</span>.requestFeed()<font></font>
					}))<font></font>
					<span class="hljs-comment">//     </span>
					<span class="hljs-keyword">self</span>.viewInput?.presentAlert(from: recoverableError)<font></font>
				}<font></font>
			}<font></font>
		}<font></font>
	}</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">// -  </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRequestFeedFailed</span><span class="hljs-params">()</span></span> {
	<span class="hljs-comment">// Put out mock that conform to AlertPresntable protocol</span>
	controller.viewInput = <span class="hljs-type">ViewInputMock</span>()<font></font>
<font></font>
	<span class="hljs-comment">//  .    ,    </span>
	<span class="hljs-comment">//    expectation</span><font></font>
	controller.requestFeed()<font></font>
<font></font>
	<span class="hljs-comment">// Our mocked object should save to true to bool variable when method called</span>
	<span class="hljs-type">XCTAssert</span>(controller.viewInput.presentAlertCalled)
	<span class="hljs-comment">// Next we could compare recoverable error attempter to expected attempter</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juntamente com este artigo, nós:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criou um mecanismo conveniente para exibir alertas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deu aos usuários a opção de tentar novamente uma operação malsucedida</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E tentou melhorar a experiência do usuário com nosso aplicativo</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link para o código</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Obrigado a todos pelo seu tempo, teremos prazer em responder suas perguntas nos comentários.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt495336/index.html">Discórdia como mensageiro corporativo e não apenas</a></li>
<li><a href="../pt495338/index.html">Melhores práticas e diretrizes para o lançamento de contêineres e Kubernetes em ambientes de produção</a></li>
<li><a href="../pt495340/index.html">Como alterar o trabalho de um administrador em um restaurante para um bom trabalho em TI</a></li>
<li><a href="../pt495342/index.html">Liquidação de cartões bancários no comércio - criando um conjunto de dados e um infográfico abertos no Google Data Studio</a></li>
<li><a href="../pt495344/index.html">Unifique-o: como a Lamoda torna seus serviços Go consistentes</a></li>
<li><a href="../pt499818/index.html">Marketing de telegrama uzbeque</a></li>
<li><a href="../pt499820/index.html">Por que escolhemos o Kotlin como um dos nossos idiomas de destino. Parte 2: Multiplataforma Kotlin</a></li>
<li><a href="../pt499822/index.html">Ponto de acesso sem fio vs roteador: quais são as diferenças?</a></li>
<li><a href="../pt499824/index.html">Resumo dos eventos para recrutadores de RH e TI em maio de 2020</a></li>
<li><a href="../pt499826/index.html">Pressão arterial distribuída</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>