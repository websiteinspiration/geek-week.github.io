<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉑 🎡 ✒️ 3Dゲームレンダリングのしくみ：ラスタライズとレイトレーシング ✳️ ✡️ 🙋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="パート1：頂点処理
 
 この記事では、すべての頂点を処理した後に3Dワールドに何が起こるかを詳しく見ていきます。数学の教科書からほこりを払いのけ、切り捨てピラミッドの形状に慣れ、遠近法の謎を解く必要があります。また、レイトレーシング、照明、マテリアルの物理についても簡単に説明します。
 
 この記...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3Dゲームレンダリングのしくみ：ラスタライズとレイトレーシング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480338/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png" alt="画像"></div><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1：頂点処理</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この記事では、すべての頂点を処理した後に3Dワールドに何が起こるかを詳しく見ていきます。数学の教科書からほこりを払いのけ、切り捨てピラミッドの形状に慣れ、遠近法の謎を解く必要があります。また、レイトレーシング、照明、マテリアルの物理についても簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の主なトピックは重要なレンダリング段階であり、ポイント、セグメント、三角形の3次元の世界が、マルチカラーブロックの2次元グリッドになります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">前の記事で</font></a><font style="vertical-align: inherit;">説明したプロセスとは異なり、3Dから2Dへの変換は目に見えないため、このプロセスは目に見えないことがよくあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点シェーダーとテッセレーションの影響をすぐに確認できました。</font><font style="vertical-align: inherit;">まだ準備ができていない場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dゲームレンダリング101の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事から始めることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの測定の準備</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者の大多数は、完全にフラットなモニターまたはスマートフォンの画面でこのWebサイトを読みます。</font><font style="vertical-align: inherit;">しかし、もしあなたが現代の技術を持っているとしても-湾曲したモニターであるなら、それによって表示される画像もマルチカラーのピクセルのフラットグリッドで構成されています。</font><font style="vertical-align: inherit;">ただし、新しいCall of Mario：Deathduty Battleyardをプレイすると、画像は立体的に見えます。</font><font style="vertical-align: inherit;">オブジェクトはシーン内を動き、大きくなったり小さくなったり、カメラに近づいたり離れたりします。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/506/855/46b506855796dd802382dc4fde347751.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2014年のBethesdaの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fallout 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を例</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">とると</font><font style="vertical-align: inherit;">、ピークがどのように処理されるかを簡単に確認でき、奥行きと距離感が生まれます。これは、ワイヤーフレームモード（上記を参照）で特に顕著です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過去20年間に3Dゲームをプレイすると、ほぼすべてのアクションが同じ一連のアクションを実行して、頂点の3Dワールドを2Dピクセル配列に変換します。この変換は、多くの場合「</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラスタライズ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">と呼ばれます</font><font style="vertical-align: inherit;">が、これはプロセス全体の多くのステップの1つにすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな段階を分析し、その段階で使用される手法と計算を研究する必要があります。参考として、Direct3Dで使用されているシーケンスを使用します。下の画像は、世界の各頂点で何が起こるかを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/621/43c/77462143c6d436fe0ad9145815956cf5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプライン変換のDirect3D</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々はワールド空間（ワールドスペース）で何が起こっているのかを見Habré上]：ここでは、様々な行列計算を使用して、頂点が変換され、着色されています。</font><font style="vertical-align: inherit;">カメラ空間では、移動後に頂点のみが変換および調整され、カメラが基準点になるため、次の手順はスキップします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の手順は、3Dから2Dへの移行に絶対に必要であるため、スキップするには複雑すぎます。正しく実装されている場合、脳はフラットスクリーンを見るが、奥行きとスケールのあるシーンを「見る」ことができます。</font><font style="vertical-align: inherit;">すべてが間違っていると、画像は非常に奇妙になります！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべては視点に関するものです</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシーケンスの最初のステップは、カメラの視点からスコープを設定することです。これを行うには、最初に水平および垂直の可視領域の角度を設定する必要があります-人々は垂直方向のビジョンよりも周辺の水平方向のビジョンの方が優れているため、最初はゲームで頻繁に変更されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、人の視野で画像を見るとわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/37e/69b/75437e69be055c93670bb139fc2e47d9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視野の2つのコーナー（視野、視野）は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">錐台</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピラミッドの</font><font style="vertical-align: inherit;">形状を定義します</font><font style="vertical-align: inherit;">。これは、カメラから発する正方形の底面を持つ3Dピラミッドです。最初のコーナーは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直方向の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fovを</font><font style="vertical-align: inherit;">設定し</font><font style="vertical-align: inherit;">、2番目の</font><font style="vertical-align: inherit;">コーナーは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平方向を</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設定し</font><font style="vertical-align: inherit;">ます。それらを記号</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">α</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">βで示し</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。実際、私たちはこのような世界をそれほどよく見ていませんが、計算の観点からは、現実的な量の可視性を生成するよりも、切り捨てピラミッドを操作する方がはるかに簡単です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cc/62f/e5f/0cc62fe5fdb171e47cc3428fa5bdd427.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに2つのパラメータを設定する必要があります-ニア（またはフロント）およびファー（バック）</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリッピングプレーン（クリッピングプレーン）の位置</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1つ目はピラミッドの上部を切り取りますが、基本的にはすべてが描画されるカメラ位置にどれだけ近いかを決定します。</font><font style="vertical-align: inherit;">後者は同じことを行いますが、プリミティブがレンダリングされるカメラからの距離を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニアトランケーションプレーンのサイズと位置は、</font><em><font style="vertical-align: inherit;">ビューポート</font></em><font style="vertical-align: inherit;">と呼ばれるものになるため、非常に重要</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、これはモニターに表示されるものです。</font><font style="vertical-align: inherit;">レンダリングされたフレーム、およびほとんどのグラフィックAPIでは、ビューポートは左上隅から描画されます。</font><font style="vertical-align: inherit;">下の画像では、点（a1、b2）が平面の原点になります。平面の幅と高さは、それに対して相対的に測定されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf8/d66/f95/cf8d66f95ab085a290a35d996f94ed3d.png"></div><br>
<em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューポート</font><em><font style="vertical-align: inherit;">のアスペクト比は</font></em><font style="vertical-align: inherit;">、レンダリングされた世界を表示するだけでなく、モニターのアスペクト比と一致させることも重要です。長年の間、標準は4：3（または10進数で1.3333 ...）でした。ただし、今日の大半はワイドスクリーンとウルトラワイドスクリーンと呼ばれる16：9または21：9のアスペクト比で再生されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示すように、カメラ空間の各頂点の座標を変換して、それらがすべて近くの切り捨て面に収まるようにする必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/73f/69c/ba373f69c98de8b0000785606d1d56df.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピラミッドの側面と上面の切り捨て</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
変換は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透視投影行列</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる別の行列を使用して実行され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">以下の例では、スコープの角度と切り捨て面の位置を使用して変換を実行しています。</font><font style="vertical-align: inherit;">ただし、代わりにビューポートの寸法を使用できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/32e/2e1/d7632e2e15dd515df9f624a62f8fdce9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点位置ベクトルはこの行列で乗算され、変換された座標の新しいセットを提供します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/8d6/a1d/2678d6a1d623c710e22675d54d05eaa2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出来上がり！これで、すべての頂点は、ソースワールドが3Dパースペクティブとして表示されるように記述され、フロントトランケーションプレーンに近いプリミティブは、ファープレーンに近いプリミティブよりも大きく見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビューポートのサイズと視野角の角度は関連していますが、個別に処理できます。つまり、ビューポートとはサイズとアスペクト比が異なるニアトランケーションプレーンを取得するように、トランケーションピラミッドを設定できます。これを行うには、操作のチェーンに追加の手順が必要です。追加の手順では、この違いを考慮に入れるために、打ち切り平面に近い頂点を再度変換する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これにより、表示されるパースペクティブに歪みが生じる可能性があります。たとえば</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2011年のゲームSkyrim</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベセスダでは</font><font style="vertical-align: inherit;">、ビューポートの同じアスペクト比を維持しながら</font><font style="vertical-align: inherit;">スコープ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">βの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平角度を変更</font><font style="vertical-align: inherit;">すると、シーンに</font><font style="vertical-align: inherit;">どのように影響するかを確認できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/2b8/4f7/fe92b84f7381a559d307517a2d46258a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最初の画像では、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">β</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 75° </font><font style="vertical-align: inherit;">を設定</font><font style="vertical-align: inherit;">し、シーンは完全に正常に見えます。</font><font style="vertical-align: inherit;">ここで、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">β</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 120° </font><font style="vertical-align: inherit;">に設定してみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e0/bf9/a3b/4e0bf9a3b44c400447fb73393a26916d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの違いがすぐにわかります。まず、「視野」の側面に多くの違いが見られます。</font><font style="vertical-align: inherit;">次に、オブジェクトがはるかに遠くに見えるようになりました（特に木）。</font><font style="vertical-align: inherit;">ただし、プロセスがそのような可視性の領域用に設計されていないため、水面の視覚効果は今では間違って見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私たちのキャラクターがエイリアンの目を持っていると想像して、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">β</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 180°に</font><font style="vertical-align: inherit;">設定して</font><font style="vertical-align: inherit;">ください！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6e/548/b9f/a6e548b9faa9cba6e3fa80a33a95444d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような可視性の領域は、ほぼパノラマのシーンを作成しますが、エッジでレンダリングされたオブジェクトの深刻な量の歪みを支払う必要があります。</font><font style="vertical-align: inherit;">これは、ゲームデザイナーがそのような状況を予測せず、そのような視野角（標準値は約70度に等しい）のゲームリソースと視覚効果を作成しなかったために、再び起こりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の画像ではカメラが移動したように見えるかもしれませんが、そうではありません。唯一の変更は、トランケーションピラミッドを変更することです。これにより、トランケーションニアプレーンの寸法が変更されました。</font><font style="vertical-align: inherit;">各画像で、ビューポートのアスペクト比は同じままであるため、すべてに収まるようにスケーリングマトリックスが頂点に適用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それで、あなたはとどまるか、去るか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投影段階で変換を実行した後、いわゆる</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリップスペースに進みます</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">投影</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行われ</font><font style="vertical-align: inherit;">ますが、事前に操作を実行するとどうなるかを簡単に示すことができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d1/5aa/921/8d15aa92153b56847f0a3eaba62000a0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図では、コウモリの1つと木の一部であるゴム製のアヒルでは、三角形が切り捨てピラミッドの内側にあることがわかります。</font><font style="vertical-align: inherit;">ただし、他のコウモリと最も遠い木は切り捨てピラミッドの境界の外にあります。</font><font style="vertical-align: inherit;">これらのオブジェクトを構成する頂点はすでに処理されていますが、ビューポートには表示されません。</font><font style="vertical-align: inherit;">つまり、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリップされ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><em><font style="vertical-align: inherit;">ピラミッドに沿って切り詰められた</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
場合</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（錐台クリッピング）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切り捨てピラミッドの外側にあるすべてのプリミティブは完全に削除され、境界にあるプリミティブは新しいプリミティブに変換されます。これらのすべての非表示の頂点は、頂点シェーダーなどのこのステージの前にすでに処理されているため、切り捨てによってパフォーマンスが大幅に向上することはありません。必要に応じて、切り捨てステップ全体を完全にスキップすることもできますが、この機能はすべてのAPIでサポートされているわけではありません（たとえば、標準のOpenGLではスキップできませんが、API拡張を使用して実行できます）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e07/57c/7a5e0757c7f8368a6d419c59468ec03e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームエンジン自体が後者を制御しているため、ゲーム</font><font style="vertical-align: inherit;">
内の遠方打ち切り平面の位置が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描画距離</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と常に同じであるとは限らないことに注意してください</font><font style="vertical-align: inherit;">。エンジンはまた</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ピラミッド（錐台カリング）でクリッピングを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行します。これは、オブジェクトが切り捨てピラミッド内に描画されるかどうか、および可視オブジェクトに影響するかどうかを決定するコードを実行します。答えが</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、オブジェクトはレンダリングに転送されません。これは錐台のクリッピングとは異なります。ピラミッドの外側のプリミティブも破棄されるためですが、頂点の処理段階をすでに通過しています。カリングの間、それらはまったく処理されないため、かなりのリソースを節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての変換と切り捨てを行ったので、頂点はレンダリングシーケンスの次のステップの準備ができているようです。しかし、実際には、そうではありません。頂点処理段階およびワールド空間からトランケーション空間への変換操作で実行されるすべての計算は、統一座標系で実行する必要があるためです（つまり、各頂点には、3ではなく4つのコンポーネントがあります）。 。ただし、ビューポートは完全に2次元です。つまり、APIは頂点情報に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x、yの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値のみが含まれると想定します</font><font style="vertical-align: inherit;">（ただし、深度値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4番目のコンポーネントを取り除くために、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遠近法による除算</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が実行</font><font style="vertical-align: inherit;">され、各コンポーネントが</font><em><font style="vertical-align: inherit;">w</font></em><font style="vertical-align: inherit;">の値で除算されます。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この操作は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な値</font><em><font style="vertical-align: inherit;">の</font></em><font style="vertical-align: inherit;">間隔[-1,1]に</font><font style="vertical-align: inherit;">制限し</font><font style="vertical-align: inherit;">、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を間隔[0,1]に</font><font style="vertical-align: inherit;">制限します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正規化デバイス座標</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（NDC）</font><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今説明した内容について詳しく知りたい、数学が好きな場合は、</font><font style="vertical-align: inherit;">このトピック「Song Ho Ana」に関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れたチュートリアル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">読んで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの頂点をピクセルに変えましょう！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラスタライズをマスター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換の場合と同様に、Direct3Dの例を使用して、ビューポートをピクセルのグリッドに変換するために使用されるルールとプロセスを検討します。このテーブルは、行と列を含むExcelスプレッドシートに似ており、各セルにはさまざまなデータ値（色、深度値、テクスチャ座標など）が含まれています。通常、このグリッドが呼び出され</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ラスタ画像</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、及びその生成のプロセスがされている</font><font style="vertical-align: inherit;">と呼ば</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラスタライズ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dレンダリング101では、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この手順を簡略化しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/01f/0e7/3b601f0e71774ce64eeb0a8f75a83f67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像は、プリミティブが単に小さなブロックにカットされているような印象を与えますが、実際にはさらに多くの操作があります。最初のステップは、プリミティブがカメラの方を向いているかどうかを判断することです。たとえば、上の画像の切頭ピラミッドの場合、灰色のウサギの後ろを構成するプリミティブは表示されません。したがって、それらはビューポートに存在しますが、レンダリングする必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下の図を見て、これがどのように見えるかを大まかに想像することができます。立方体は、画面の2D空間に3Dモデルを配置するためにさまざまな変換が行われ、カメラの視点からは、立方体の一部の面が表示されません。すべてのサーフェスが不透明であると仮定すると、これらのプリミティブの一部は無視できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/60a/bf9/69360abf9888e28d60622cf189cbb6c3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左から右へ：ワールドスペース&gt;カメラスペース&gt;プロジェクションスペース&gt;スクリーンスペース</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Direct3Dでは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング状態</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をシステムに</font><font style="vertical-align: inherit;">指示することでこれを行うこと</font><font style="vertical-align: inherit;">ができ</font><font style="vertical-align: inherit;">、この指示</font><font style="vertical-align: inherit;">により</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">前方または後方（各プリミティブの側面</font><font style="vertical-align: inherit;">を削除（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カットオフ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">する必要があることが明確になります</font><font style="vertical-align: inherit;">（または、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイヤフレーム</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モード</font><font style="vertical-align: inherit;">などでまったくカットオフしない</font><font style="vertical-align: inherit;">）。しかし、彼女はどの側が前向きか後ろ向きかをどのようにして知るのでしょうか？</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">数学の頂点処理</font></a><font style="vertical-align: inherit;">を見たとき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すると、三角形（または頂点）に、システムがどのように見えるかを示す法線ベクトルがあることがわかりました。この情報のおかげで、単純なチェックを実行でき、プリミティブが失敗した場合は、プリミティブがレンダリングチェーンから削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ピクセルグリッドを適用します。ピクセルがプリミティブ内にあるかどうかをシステムが完全に、部分的に、またはまったく理解していないため、これも予想外に複雑なプロセスです。これを行うには、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カバレッジテスト</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスが実行され</font><font style="vertical-align: inherit;">ます。次の図は、Direct3D 11で三角形がどのようにラスタライズされるかを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/967/ee6/858967ee6e11144896c35c2c726ec606.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルールは非常に単純です。ピクセルの中心がチェックを通過した場合、ピクセルは三角形の内側にあると見なされます。これは、Microsoftが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「左上」ルール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼んでいます</font><font style="vertical-align: inherit;">。 「上」とは、水平線をチェックすることです。ピクセルの中心がなければならない</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このライン。 「左」は水平ではない線を指し、ピクセルの中心はそのような線の左側にある必要があります。単純なセグメントやポイントなど、非プリミティブに関連する他のルールがあり</font><font style="vertical-align: inherit;">ます。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチサンプリング</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">する場合、ルールに条件が表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoftのドキュメントをよく見ると、ピクセルによって作成された形状が元のプリミティブとあまり似ていないことがわかります。</font><font style="vertical-align: inherit;">これは、ピクセルが大きすぎて現実的な三角形を作成できないためです。ラスターイメージには元のオブジェクトに関する十分なデータが含まれていないため、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エイリアス</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる現象が発生し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ULベンチマーク3DMark03</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用したエイリアシングを見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/9d2/289/f119d2289c67082f66e4467385bc07be.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">720 x 480ピクセルのラスタライズ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初の画像では、ラスターイメージの解像度は非常に低く</font><i><font style="vertical-align: inherit;">、720 x 480ピクセルです</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">エイリアシングは、上部の兵士の武器によって投げかけられた手すりと影にはっきりと見えます。</font><font style="vertical-align: inherit;">これを、ピクセル数が24倍に増加したラスタライズ中に得られた結果と比較してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/eba/d3a/ea8ebad3a86c108326f069fc343baed7.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3840 x 2160ピクセルのラスタライズ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここでは、手すりとシャドウのエイリアシングが完全に消えていることがわかります。常に大きなビットマップを使用する必要があるようですが、グリッドサイズは、フレームが表示されるモニターでサポートされている必要があります。これらのすべてのピクセルを処理する必要があるという事実を考慮すると、パフォーマンスが低下することは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではマルチサンプリングが役立ちます。 Direct3Dでの動作は次のとおりです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/79e/62f/64b79e62fbcd12197ba9ff2c769045ae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルの中心がラスタライズのルールと一致するかどうかをチェックする代わりに、各ピクセル内のいくつかのポイント（サブピクセルサンプルまたはサブサンプルと呼ばれます</font><font style="vertical-align: inherit;">）が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックされ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それらのいくつかが要件を満たしている場合は、図の一部を形成します。メリットがないように思われ、エイリアシングも強化されていますが、マルチサンプリングを使用する場合、プリミティブによってカバーされるサブサンプルに関する情報とピクセルの処理結果がメモリのバッファーに格納されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このバッファーを使用してこれらのサブサンプルとピクセルを混合し、プリミティブのエッジが引き裂かれるのを防ぎます。別の記事でエイリアシングについてさらに詳しく見ていきますが、現時点では、この情報は、あまりにも少ないピクセルをラスタライズするためにマルチサンプリングを使用して何ができるかを理解するのに十分です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/466/b61/703466b61fe655bfe9956003b707d9d5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、さまざまな形状のエッジでのエイリアシングの量が大幅に減少しています。解像度の高いラスタライズは間違いなく優れていますが、パフォーマンスの低下によりマルチサンプリングを使用するように求められる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ラスタライズ中に、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オクルージョンテスト</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が実行され</font><font style="vertical-align: inherit;">ます。ビューポートは互いに重ね合わされたプリミティブで満たされるため、これは必要です。たとえば、上の図では、前景の兵士を構成する前向きの三角形が別の兵士の同じ三角形と重なっています。プリミティブがピクセルをカバーしているかどうかを確認することに加えて、相対的な深度を比較することもできます。1つのサーフェスが別のサーフェスの背後にある場合は、残りのレンダリングプロセスから削除する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、nearプリミティブが透明な場合、farプリミティブはオーバーラップテストに合格しませんが、表示されたままになります。そのため、ほとんどすべての3Dエンジン</font><font style="vertical-align: inherit;">は、GPUにデータを送信する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバーラップチェックを実行し</font><font style="vertical-align: inherit;">、代わり</font><font style="vertical-align: inherit;">にレンダリングプロセスの一部である</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z-buffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるものを作成し</font><font style="vertical-align: inherit;">ます。ここではフレームは通常の方法で作成されますが、完成したピクセルカラーをメモリに保存する代わりに、GPUは深度値のみを保存します。後でシェーダーで使用して、可視性をチェックしたり、オブジェクトのオーバーラップに関連するアスペクトを高度に制御したり正確にしたりできます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/2bc/c01/f532bcc017258005f427aaed4e3e482e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像では、ピクセルの色が暗いほど、被写体がカメラに近づきます。フレームは一度レンダリングされてZバッファーを作成し、次に再度レンダリングされますが、今回はピクセルの処理中に、Zバッファーの値を確認するためにシェーダーが起動されます。非表示の場合、ピクセルの色は完成したフレームのバッファに書き込まれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、最後のステップは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点属性の補間です。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の簡略化されたスキームでは、プリミティブは完全な三角形でしたが、ビューウィンドウが図のコーナーだけで埋められ、図自体では埋められていないことを忘れないでください。つまり、システムは、頂点間にプリミティブの色、深度、およびテクスチャを決定する必要があり、この操作は</font><em><font style="vertical-align: inherit;">補間</font></em><font style="vertical-align: inherit;">と呼ばれ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ご想像のとおり、これは別の計算であり、それほど単純ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラスタライズされた画面が2Dで表示されるという事実にもかかわらず、その内部の構造は3Dパースペクティブを表します。</font><font style="vertical-align: inherit;">線が実際に2次元である場合、</font><font style="vertical-align: inherit;">1つの頂点から別の頂点に移動するため</font><font style="vertical-align: inherit;">、単純な</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形方程式</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して色などを計算できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、シーンの3Dアスペクトのため、補間ではこのパースペクティブを考慮する必要があります。</font><font style="vertical-align: inherit;">このプロセスの詳細については</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Simon Yoonによる優れた記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をご覧</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでタスクが完了しました。頂点の3Dワールドは、マルチカラーブロックの2Dグリッドに変わります。</font><font style="vertical-align: inherit;">しかし、まだ完了していません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前面から背面（一部例外あり）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラスタライズを検討する前に、レンダリングシーケンスの順序について説明する必要があります。たとえば、テッセレーションが処理シーケンスに現れる段階については触れていません。プリミティブが処理される順序を意味します。オブジェクトは通常、インデックスバッファー（頂点がどのようにグループ化されるかをシステムに通知するメモリブロック）にある順序で処理され、これは透明なオブジェクトと効果の処理方法に大きな影響を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、プリミティブが一度に1つずつ処理され、最初にプリミティブをレンダリングした場合、プリミティブの背後にあるプリミティブはすべて非表示になり（オクルージョンカリングが作用する場所）、プロセスから破棄できるため（保存に役立ちます）パフォーマンス）。これは通常、「</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前から後ろへの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング</font><font style="vertical-align: inherit;">」と</font><font style="vertical-align: inherit;">呼ばれ</font><font style="vertical-align: inherit;">、このプロセスでは、インデックスバッファーをこのように並べる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これらのプリミティブの一部がカメラの前で透明である場合、前から後ろにレンダリングすると、透明の後ろにあるオブジェクトが失われます。 1つの解決策は、背面から前面にレンダリングすることです。この場合、透明なプリミティブと効果が最後に計算されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/c02/6f7/3cac026f78b545088b8de84fcdd11ee4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左から右へ：シーンの順序、前面から背面へのレンダリング、背面から前面へのレンダリング</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
つまり、最近のすべてのゲームでは、レンダリングは背面から前面に実行されますか？いずれにせよ-個々のプリミティブをレンダリングすると、目に見えるものだけをレンダリングする場合に比べて、パフォーマンスが大幅に低下することを忘れないでください。透明なオブジェクトを処理する方法は他にもありますが、一般的なケースでは、どのシステムにも適した理想的なソリューションはなく、それぞれの状況を個別に考慮する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これにより、ラスタライゼーションの主な長所と短所を理解できます。最新の機器では、これは迅速かつ効率的なプロセスですが、それでも私たちが目にするもののおおよその反映です。</font><font style="vertical-align: inherit;">現実の世界では、すべてのオブジェクトが光を吸収、反射、場合によっては屈折することがあり、これらすべてが表示されるシーンの最終的な外観に影響を与えます。</font><font style="vertical-align: inherit;">世界をプリミティブに分割し、その一部のみをレンダリングすると、高速になります。</font><font style="vertical-align: inherit;">しかし、非常に大まかな結果です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、他に方法があったら…</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう1つの方法は、レイトレーシングです。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
50年近く前に、アーサーエッペルという名前のコンピューターサイエンティストが、1つの光線がカメラからオブジェクトに衝突するまで直線状にカメラから放射されるコンピューターで画像をレンダリングするシステムに取り組みました。衝突後、マテリアルのプロパティ（色、反射率など）によって光線の明るさが変化しました。レンダリングされた画像の各ピクセルに対して、放出された光線が1つあり、アルゴリズムは一連の計算を実行してピクセルの色を決定しました。エッペルのプロセスは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイキャスティング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約10年後、別の科学者、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジョンホワイト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はエッペルプロセスを実装する数学的アルゴリズムを開発しましたが、ビームがオブジェクトに衝突すると、オブジェクトの材料に応じて、異なる方向に発散する追加の光線が生成されました。このシステムはオブジェクトとのすべての相互作用で新しい光線を生成したため、アルゴリズムは本質的に再帰的であり、計算的にはるかに複雑でした。ただし、反射、屈折、影を正しく考慮できるため、エッペルの方法よりもはるかに優れています。この手順は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイトレーシング（レイプレーヤートレーシング）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">（厳密には</font><font style="vertical-align: inherit;">、オブジェクトではなくカメラのビームを追跡するため</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、逆</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイトレーシングです）、それ以来、コンピューターグラフィックスや</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ムービーの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聖杯になっています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/733/8a8/5f07338a8846abdebe390b99bd364ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像から、Whitedアルゴリズムがどのように機能するかを理解できます。フレーム内のピクセルごとに、1つのビームがカメラから放出され、表面に到達するまで移動します。この例では、表面は半透明であるため、光を反射して屈折させることができます。どちらの場合も、表面に衝突するまで移動する2次光線が生成されます。光源の色とそれらが作成する影を説明するために、新しい二次光線も生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスの再帰性は、新しく放出された光線が表面と交差するたびに二次光線が生成されることです。これはすぐに手に負えなくなるため、生成される二次ビームの数は常に制限されます。ビーム経路が完了すると、この表面の材料特性に基づいて、各端点の色が計算されます。次に、この値は前のレイに沿って送信され、このサーフェスの色を変更するなどして、プライマリレイの開始点、つまりフレーム内のピクセルに到達します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなシステムは非常に複雑になる可能性があり、単純なシーンでさえ大量の計算を生成する可能性があります。幸いなことに、作業を簡略化するトリックがあります。まず、これらの数学的演算を高速化するために特別に設計された装置を使用できます。これは、頂点処理での行列数学で発生するのと同様です（これについては後で詳しく説明します）。もう1つの重要なトリックは、光線が落ちたオブジェクトとそれらの交差の正確な場所を特定するプロセスを加速する試みです。オブジェクトが多数の三角形で構成されている場合、このタスクは驚くほど難しい場合があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/3f8/dac/de43f8dac76ca9bda84700c168cde9ff.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース：Nvidia RTXによるリアルタイムレイトレーシングレイトレーシングを</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
行う前に各オブジェクトの個々の三角形をチェックする代わりに、バウンディングボリューム（BV）のリストが生成されます-これらはオブジェクトを表す通常の平行六面体です。オブジェクト内のさまざまな構造では、小さな境界ボリュームが周期的に作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、最初のBVはウサギ全体になります。次のカップルは彼の頭、脚、体、尾などについて説明します。次に、各ボリュームは、ヘッド、ボディなどの小さな構造のボリュームの別のコレクションになり、最後のボリュームレベルには、検証のために少数の三角形が含まれます。これらのボリュームはすべて、順序付けされたリスト（</font><em><font style="vertical-align: inherit;">BV階層</font></em><font style="vertical-align: inherit;">と呼ばれる）に配置されることがよくあり</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはBVH）; </font><font style="vertical-align: inherit;">このため、システムは毎回比較的少量のBVをチェックします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/319/454/3453194547f780d91a4231529f6f68b4.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳密に言えば、BVHの使用はレイトレーシング自体を高速化しませんが、階層と一般的な場合に必要な後続の検索アルゴリズムを生成することは、1つのレイと3Dワールド内の数百万の三角形の1つとの交差をチェックするよりもはるかに高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POV-ray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのプログラムは、</font><font style="vertical-align: inherit;">レイトレーシングと追加のアルゴリズム（フォトントレーシングやラジオシティなど）を使用して、非常にリアルな画像を生成しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/b2c/bf6/cfab2cbf6216eaa3e007bdd38f867cd6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかな問題が発生する可能性があります。レイトレーシングが非常に優れている場合、なぜそれがどこでも使用されないのですか？答えは2つの領域にあります。まず、単純なレイトレーシングでも何百万ものレイが作成され、それらを何度も計算する必要があります。システムは、画面のピクセルごとに1つのビームだけで開始します。つまり、800 x 600の解像度で、480,000の主光線を生成し、それぞれが多くの副光線を生成します。これは、現代のデスクトップPCであっても、非常に困難な作業です。 2番目の問題は、単純なレイトレーシングはあまり現実的ではなく、適切に実装するためには、非常に複雑な方程式がたくさん必要になることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新の機器を使用しても、3Dゲームの作業量はリアルタイム実装では達成できません。記事では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dレンダリング101</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイトレーシングベンチマークでは、単一の低解像度画像を作成するのに数十秒かかることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfenstein 3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は1992年にレイキャスティングを</font><font style="vertical-align: inherit;">どのように</font><font style="vertical-align: inherit;">実行しました</font><font style="vertical-align: inherit;">か？また、2019年にリリースされた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battlefield V</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metro Exodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの</font><font style="vertical-align: inherit;">ゲームが</font><font style="vertical-align: inherit;">レイトレーシング機能を提供するのはなぜですか？</font><font style="vertical-align: inherit;">ラスタ化またはレイトレーシングを実行しますか？</font><font style="vertical-align: inherit;">少しずつ。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在と未来のためのハイブリッドアプローチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2018年3月、MicrosoftはDXR（DirectX Raytracing）と呼ばれるDirect3D 12の新しいAPI拡張のリリースを発表しました。これは、標準のラスタライゼーションとコンピューティングパイプラインを補完する新しいグラフィックスパイプラインでした。シェーダーやデータ構造などを追加することで追加の機能が提供されましたが、Direct3D 12ですでに必要だったものを除いて、ハードウェアサポートは必要ありませんでした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c9/b88/e83/7c9b88e83184b2412b431ff990e39f89.png"></div><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicrosoftがDXRについて話し合っ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
た同じゲーム開発者会議で</font><font style="vertical-align: inherit;">、Electronic Artsは同社の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pica Pica Project（</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DXRを使用した3Dエンジンの実験）</font><font style="vertical-align: inherit;">について話しました</font><font style="vertical-align: inherit;">。同社は、レイトレーシングは使用できるが、フレーム全体のレンダリングには使用できないことを示しています。 DXRが特定の領域で使用されている間、作業の大部分は従来のラスタライゼーション技術と計算シェーダーを使用しています。つまり、生成される光線の数は、シーン全体の場合よりもはるかに少なくなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このハイブリッドアプローチは、それほどではありませんが、過去に使用されています。たとえば、Wolfenstein 3D </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はレイキャスティング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してフレームをレンダリングしましたが、これはピクセルではなくピクセル列ごとに1つのビームを使用して行われました。 640 x 480の解像度でゲームが動作したことを思い出さない限り、これは印象的に見えるかもしれません。変換：実際には320 x 200]、つまり、同時に放出される光線は640以下です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AMD Radeon RX 580やNvidia GeForce 1080 Tiなどの2018年初期のグラフィックスカードはDXR要件を満たしていましたが、コンピューティング機能を備えていても、DXRを意味あるものにするほど強力ではないという懸念がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nvidiaが最新のGPUアーキテクチャをリリースした2018年8月に状況は変化しました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードネームTuring</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このチップの最も重要な機能は、いわゆるRTコアの外観です。光線と三角形の交差の計算とバウンディングボリュームの階層（BVH）の通過を高速化する個別のロジックブロックです。これら2つのプロセスは、シーンオブジェクトを構成する三角形と光の相互作用のポイントを決定するための時間のかかる手順です。 RTコアは独自のチューリングプロセッサユニットであるため、それらへのアクセスはNvidia独自のAPIを介してのみ行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能をサポートする最初のゲームはEAのバトルフィールドVでした。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その中でDXRをテストしたとき</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、水中、草、金属での反射の改善、それに対応するパフォーマンスの低下に感銘を受けました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/e3e/aa1/1cce3eaa1c5db3688910ec0a1c052ce4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直なところ、後続のパッチによって状況は改善されましたが、フレームのレンダリング速度はまだ低下していました（現在もそうです）。 2019年までに、このAPIをサポートし、フレームの個々の部分のレイトレーシングを実行する他のゲームがいくつかありました。私たち</font><font style="vertical-align: inherit;">は同じ状況に直面している</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metro Exodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をテスト</font><font style="vertical-align: inherit;">しました。DXRのアクティブな使用により、フレームレートが大幅に低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ頃、ULベンチマーク</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3DMarkの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DXR機能テストの作成を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">発表しまし</font></a><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/60a/a0d/61260aa0d10ef6ed6c69731a6a3038f2.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DXRはNvidia Titan X（Pascal）グラフィックスカードで使用されています-はい、結果は8 fpsです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ただし、DXR対応のゲームと3DMarkテストの調査では、レイトレーシングは2019年でもGPUにとって非常に困難なタスクであり続けています。 1,000ドル以上の価格。これは、ラスタライゼーションに代わる真の選択肢がないということですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマー3Dグラフィックステクノロジーのプログレッシブ機能は、多くの場合非常に高価であり、新しいAPI機能の初期サポートはかなり断片化されているか、遅くなる可能性があります（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Max Payne 3のテストで</font></a><font style="vertical-align: inherit;">判明し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">よう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2012年のDirect3Dの異なるバージョン）。</font><font style="vertical-align: inherit;">後者の問題は通常、ゲーム開発者が製品に可能な限り多くの最新機能を組み込むことを試み、十分な経験がない場合に発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、頂点シェーダー、ピクセルシェーダー、テッセレーション、HDRレンダリング、画面空間アンビエントオクルージョンも、かつては強力なGPUにのみ適した高価な手法でしたが、現在ではゲームの標準であり、多くのグラフィックカードがサポートされています。</font><font style="vertical-align: inherit;">レイトレーシングでも同じことが起こります。</font><font style="vertical-align: inherit;">時間が経つと、ほとんどのプレーヤーでデフォルトで有効になる別の詳細パラメーターに変わります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的に</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、分析の第2部の終わりに到達しました。そこでは、3Dグラフィックスの世界をより深く見てきました。</font><font style="vertical-align: inherit;">ワールドとモデルの上部が3次元から転送され、フラットな2Dイメージに変わる方法を学びました。</font><font style="vertical-align: inherit;">スコープを考慮する必要があることを確認し、それがどのような影響を与えるかを認識しました。</font><font style="vertical-align: inherit;">これらのベリンをピクセルに変換するプロセスを検討し、最後に、従来のラスタライズプロセスの代替方法について簡単に説明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の記事と同様に、すべてのトピックを明らかにすることはできず、一部の詳細を見逃しました-結局、これは教科書ではありません！</font><font style="vertical-align: inherit;">しかし、皆さんが何か新しいことを学び、コンピューティングと科学を使用してこれをすべてお気に入りの3Dゲームに実装したプログラマーとエンジニアの仕事を尊重していただければ幸いです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja480326/index.html">F5 Networks Corporationは、NGINXの現在の状況について顧客に通知する手紙を顧客に送信します</a></li>
<li><a href="../ja480328/index.html">PyTorchとC ++の友達を作る方法。TorchScriptの使用</a></li>
<li><a href="../ja480330/index.html">理想的な従業員評価ツール</a></li>
<li><a href="../ja480332/index.html">モスクワ市下院における2019ブロックチェーン投票データの分析</a></li>
<li><a href="../ja480334/index.html">QtQML /クイック相関パネル</a></li>
<li><a href="../ja480340/index.html">私は無能なマネージャーに反対し、彼は昇進しました</a></li>
<li><a href="../ja480342/index.html">コメントによる開発のパラダイム</a></li>
<li><a href="../ja480348/index.html">ディープフェイクサイエンス、再現性の危機、そして空のリポジトリはどこから来るのか</a></li>
<li><a href="../ja480350/index.html">モバイル＃326開発者向けの興味深い資料のダイジェスト（12月9〜15日）</a></li>
<li><a href="../ja480352/index.html">ハーバード遺伝学者がプロトタイプDNA分析デートアプリを開発</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>