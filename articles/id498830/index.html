<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌺 🌯 🌻 Hash + cache: optimisasi pemrosesan aliran 👩🏾‍🎨 👍🏾 🐋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang harus saya lakukan jika saya ingin menuliskan banyak "fakta" dalam database dengan volume yang jauh lebih besar daripada yang bisa ditahan? P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hash + cache: optimisasi pemrosesan aliran</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang harus saya lakukan jika saya ingin menuliskan banyak "fakta" dalam database dengan volume yang jauh lebih besar daripada yang bisa ditahan? Pertama, tentu saja, kami membawa data ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bentuk normal yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih ekonomis </font><font style="vertical-align: inherit;">dan mendapatkan "kamus", yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan kami tulis satu kali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi bagaimana cara melakukannya paling efektif? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini persis pertanyaan yang kami hadapi ketika mengembangkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemantauan dan analisis log server PostgreSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ketika </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lain </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">untuk mengoptimalkan catatan dalam database</font></a><font style="vertical-align: inherit;"> habis.</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0y/34/cp/0y34cps5t4nqozitxa0xb7urypm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segera buat reservasi bahwa kolektor kami menjalankan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jadi kami tidak berinteraksi dengan register dan cache prosesor. </font><font style="vertical-align: inherit;">Dan opsi untuk menggunakan "seratus" atau layanan / basis data caching eksternal memberi terlalu banyak penundaan untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran masuk beberapa ratus Mbps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, kami mencoba untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">men</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><b><font style="vertical-align: inherit;">cache semuanya dalam RAM</font></b><font style="vertical-align: inherit;"> , khususnya dalam memori proses JavaScript. </font><font style="vertical-align: inherit;">Tentang cara mengatur ini lebih efisien, dan kami akan melangkah lebih jauh.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching Ketersediaan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas utama kami adalah memastikan bahwa satu-satunya instance dari objek apa pun masuk ke database. Ini adalah teks asli berulang dari query SQL, template </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rencana untuk implementasi mereka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , node dari rencana ini - singkatnya, beberapa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blok teks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara historis, sebagai pengidentifikasi kami menggunakan </font></font><code>UUID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai-, yang diperoleh sebagai hasil perhitungan langsung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hash MD5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari teks objek. Setelah itu, kami memeriksa ketersediaan hash semacam itu di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"kamus"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lokal </font><b><font style="vertical-align: inherit;">di memori proses</font></b><font style="vertical-align: inherit;"> , dan jika tidak ada di sana, hanya kemudian kami menulis dalam database di tabel "kamus".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, kita tidak perlu menyimpan nilai teks asli itu sendiri (dan kadang-kadang dibutuhkan puluhan kilobyte) - cukup </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fakta bahwa keberadaan hash yang sesuai</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam kamus </font><font style="vertical-align: inherit;">sudah cukup </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamus Kunci</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kamus semacam itu dapat disimpan </font></font><code>Array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan digunakan </font></font><code>Array.includes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memeriksa ketersediaan, tetapi ini cukup berlebihan - pencarian menurun (setidaknya dalam versi V8 sebelumnya) secara linear dari ukuran array, O (N). </font><font style="vertical-align: inherit;">Dan dalam implementasi modern, terlepas dari semua optimasi, ia kehilangan kecepatan 2-3%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, di era pra-ES6, penyimpanan adalah solusi tradisional </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dengan nilai yang disimpan sebagai kunci. </font><font style="vertical-align: inherit;">Tetapi semua orang menetapkan nilai kunci apa yang dia inginkan - misalnya </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> dict = {};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> dict[key] !== <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">key</span>) </span>{<font></font>
  dict[key] = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi cukup jelas bahwa kami jelas menyimpan kelebihan di sini - nilai kunci yang tidak diperlukan siapa pun. Tetapi bagaimana jika itu tidak disimpan sama sekali? Jadi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek Set</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muncul </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tes menunjukkan bahwa pencarian dengan bantuan </font></font><code>Set.has()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekitar 20-25% lebih cepat daripada verifikasi kunci c </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tapi ini bukan satu-satunya keuntungannya. Karena kita menyimpan lebih sedikit, maka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita perlu lebih sedikit memori</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dan ini secara langsung mempengaruhi kinerja ketika menyangkut ratusan ribu kunci semacam itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana terdapat 100 kunci UUID dalam representasi teks, ia menempati </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6216 byte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam memori </font><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1e/n6/ge/1en6gefozucw86wki6odp-j3ria.png"><br>
<br>
<code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan konten yang sama - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2632 byte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/59/cb/ri59cbgqbmmbqhivlopro2gspuu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, ia </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja lebih cepat dan pada saat yang sama membutuhkan</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,5 kali lebih sedikit memori</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pemenangnya jelas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengoptimalkan penyimpanan kunci UUID</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, dalam sifat sistem terdistribusi, kunci UUID cukup umum - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam VLSI kami</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , paling tidak, digunakan untuk mengidentifikasi dokumen dan peraturan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manajemen dokumen elektronik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , orang dalam </font><font style="vertical-align: inherit;">
pengiriman </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pesan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita perhatikan dengan cermat gambar di atas - setiap UUID- kunci yang disimpan dalam representasi hex "biaya" kami </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56 byte memori</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi kami memiliki ratusan ribu dari mereka, jadi masuk akal untuk bertanya: "Apakah mungkin memiliki lebih sedikit?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, ingat bahwa UUID adalah pengidentifikasi 16-byte. Pada dasarnya sepotong data biner. Dan untuk transmisi melalui email, misalnya, data biner dikodekan dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cobalah untuk menerapkannya:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'base64'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/pd/jc/ks/pdjckslsoycw92xnx4moahgmweg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masing-masing sudah 48 byte lebih baik, tetapi tidak sempurna. </font><font style="vertical-align: inherit;">Mari kita coba menerjemahkan representasi heksadesimal langsung menjadi string:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/nn/_5/6inn_5k8y3pnogatsv-r5ntrdzo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih 56 byte per kunci - 40 byte, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hemat hampir 30%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Master, pekerja - di mana menyimpan kamus?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mempertimbangkan bahwa data kosa kata dari pekerja berpotongan cukup kuat, kami membuat penyimpanan kamus dan menulisnya ke database dalam proses master, dan transfer data dari pekerja melalui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mekanisme pesan IPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, sebagian besar dari waktu master dihabiskan untuk </font></font><code>channel.onread</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- yaitu, memproses penerimaan paket dengan informasi "kamus" dari proses anak:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/kr/nr/sdkrnrm1c_amswktwm57kl3qsfo.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penghalang Tulis Set Ganda</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita berpikir sejenak - para pekerja mengirim dan mengirim master data kosa kata yang sama (pada dasarnya ini adalah templat rencana dan badan permintaan yang berulang), dia mem-parsing mereka dengan keringatnya dan ... tidak melakukan apa-apa, karena mereka telah dikirim ke database sebelumnya ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi jika kita </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"melindungi" database dari perekaman ulang dari master dengan kamus, mengapa tidak menggunakan pendekatan yang sama untuk "melindungi" master dari transfer dari pekerja? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, itu dilakukan, dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengurangi biaya langsung untuk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melayani saluran pertukaran </font><b><font style="vertical-align: inherit;">tiga kali</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/h4/aj/y1h4ajs-o3hdg1xfoyf9j_kflpc.png"><br>
<br>
<img src="https://habrastorage.org/webt/vl/be/na/vlbenalj_sd_2jk36xdkhaouhp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi sekarang para pekerja tampaknya lebih banyak bekerja - menyimpan kamus dan menyaringnya? </font><font style="vertical-align: inherit;">Atau tidak? ... Sebenarnya, mereka mulai bekerja secara signifikan lebih sedikit, karena transfer volume besar (bahkan melalui IPC!) Tidak murah.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/7k/mb/dz7kmbdj5jnirhajahmwrpcwzfw.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus bagus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika penyihir sekarang mulai menerima jumlah informasi yang jauh lebih kecil, ia mulai mengalokasikan lebih sedikit memori untuk wadah ini - yang berarti bahwa waktu yang dihabiskan untuk pekerjaan Pengumpul Sampah menurun secara signifikan, yang secara positif mempengaruhi latensi sistem secara keseluruhan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/af/el/fgafel26_6der0h-knhglqckt8k.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema semacam itu memberikan perlindungan terhadap entri yang berulang di tingkat kolektor, tetapi bagaimana jika kita memiliki beberapa kolektor? </font><font style="vertical-align: inherit;">Hanya pemicu dengan yang akan membantu di sini </font></font><code>INSERT ... ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mempercepat perhitungan hash</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam arsitektur kami, seluruh aliran log dari satu server PostgreSQL diproses oleh satu pekerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, satu server adalah satu tugas untuk pekerja. Pada saat yang sama, pemuatan pekerja diimbangi dengan tujuan tugas server sehingga konsumsi CPU oleh pekerja dari semua kolektor kurang lebih sama. Ini adalah operator layanan terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“Rata-rata,” setiap pekerja menangani lusinan tugas yang menghasilkan kira-kira beban total yang sama. Namun, ada server yang secara signifikan melampaui sisanya dalam jumlah entri log. Dan bahkan jika pengirim meninggalkan tugas ini satu-satunya pada pekerja, unduhannya jauh lebih tinggi daripada yang lain:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/p1/9a/olp19ahpqzn4e5aaek0oyg1tjt0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menghapus profil CPU pekerja ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2q/zk/fs/2qzkfsaqceti_tietxizjhfmioi.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di baris teratas, perhitungan hash MD5. </font><font style="vertical-align: inherit;">Dan mereka benar-benar menghitung jumlah yang besar - untuk seluruh aliran objek yang masuk.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana mengoptimalkan bagian ini, kecuali untuk hash ini, kita tidak bisa? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memutuskan untuk mencoba fungsi hash lain - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang mengimplementasikan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma hash non-cryptographic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang </font><i><font style="vertical-align: inherit;">sangat cepat</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan modul untuk Node.js adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxhash-addon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menggunakan versi terbaru dari pustaka xxHash 0.7.3 dengan algoritma XXH3 yang baru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa dengan menjalankan setiap opsi pada satu set baris dengan panjang berbeda:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> { XXHash3, XXHash64 } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'xxhash-addon'</span>);
<span class="hljs-keyword">const</span> hasher3 = <span class="hljs-keyword">new</span> XXHash3(<span class="hljs-number">0xDEADBEAF</span>);
<span class="hljs-keyword">const</span> hasher64 = <span class="hljs-keyword">new</span> XXHash64(<span class="hljs-number">0xDEADBEAF</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> getBinFromHash = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> buf.fill(hash, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> funcs = {
  <span class="hljs-attr">xxhash64</span> : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher64.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">xxhash3</span>  : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher3.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">md5</span>      : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> getBinFromHash(crypto.createHash(<span class="hljs-string">'md5'</span>).update(str).digest(<span class="hljs-string">'hex'</span>))<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> check = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> log = [];
  <span class="hljs-keyword">let</span> cnt = <span class="hljs-number">10000</span>;
  <span class="hljs-keyword">while</span> (cnt--) log.push(crypto.randomBytes(cnt).toString(<span class="hljs-string">'hex'</span>));<font></font>
<font></font>
  <span class="hljs-built_in">console</span>.time(hash);<font></font>
  log.forEach(funcs[hash]);<font></font>
  <span class="hljs-built_in">console</span>.timeEnd(hash);<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.keys(funcs).forEach(check);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil:</font></font><br>
<pre><code class="plaintext hljs">xxhash64 : 148.268ms<font></font>
xxhash3  : 108.337ms<font></font>
md5      : 317.584ms<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diharapkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , xxhash3 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jauh lebih cepat daripada MD5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masih untuk memeriksa resistensi terhadap tabrakan. </font><font style="vertical-align: inherit;">Bagian-bagian dari tabel kamus sedang dibuat untuk kita setiap hari, jadi di luar batas hari kita dapat dengan aman membiarkan persimpangan hash. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi untuk berjaga-jaga, kami memeriksa dengan margin dalam interval tiga hari - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada satu konflik pun</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang cocok untuk kami lebih dari cukup.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggantian Hash</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rz/ga/3drzgasyjhevujtp-etsjcwlnz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi kami tidak bisa mengambil dan menukar bidang UUID lama di tabel kamus dengan hash baru, karena basis data dan frontend yang ada menunggu objek untuk terus diidentifikasi oleh UUID. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, kami akan menambahkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu cache lagi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke kolektor </font><font style="vertical-align: inherit;">- untuk MD5 yang sudah dihitung. Sekarang akan menjadi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana kuncinya adalah xxhash3, nilainya MD5. Untuk baris yang identik, kami tidak menghitung MD5 "mahal" lagi, tetapi mengambilnya dari cache:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getHashFromBin = <span class="hljs-function">(<span class="hljs-params">bin</span>) =&gt;</span> Buffer.from(bin, <span class="hljs-string">'binary'</span>).toString(<span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> dictmd5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">const</span> getmd5 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> hash = xxhash(data);
  <span class="hljs-keyword">let</span> md5hash = dictmd5.get(hash);
  <span class="hljs-keyword">if</span> (!md5hash) {<font></font>
    md5hash = md5(data);<font></font>
    dictmd5.set(hash, getBinFromHash(md5hash));<font></font>
    <span class="hljs-keyword">return</span> md5hash;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> getHashFromBin(md5hash);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menghapus profil - sebagian kecil dari waktu untuk menghitung hash telah menurun secara nyata, tepuk tangan! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/5q/ce/el5qcei3ahbakyyerswutw2rulk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi sekarang kita hitung xxhash3, lalu periksa cache MD5 dan dapatkan MD5 yang diinginkan, lalu periksa cache kamus - jika md5 ini tidak ada, maka kirim ke database untuk menulis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sesuatu yang terlalu banyak diperiksa ... Mengapa memeriksa cache kamus jika Anda telah memeriksa cache MD5? </font><font style="vertical-align: inherit;">Ternyata semua cache kamus tidak lagi diperlukan dan cukup hanya memiliki satu cache - untuk MD5, yang dengannya semua operasi dasar akan dilakukan: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/e_/uc/wle_ucs0o22wpxmrjlg_2sokzvm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai hasilnya, kami mengganti cek di beberapa kamus "objek" dengan satu cache MD5, dan operasi penghitungan sumber daya yang intensif dari MD5 adalah Hash dilakukan hanya untuk entri baru, menggunakan xxhash yang jauh lebih efisien untuk aliran masuk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
terima kasih</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kilor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk bantuan dalam mempersiapkan artikel.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id498816/index.html">Kebenaran pertama-tama, atau mengapa sistem perlu dirancang berdasarkan pada perangkat basis data</a></li>
<li><a href="../id498820/index.html">Beberapa pertanyaan rumit tentang .NET dan C #</a></li>
<li><a href="../id498822/index.html">Pengembangan dan pembuatan dari awal mesin arcade untuk empat pemain</a></li>
<li><a href="../id498826/index.html">SIL dan Tenaga Pemasaran</a></li>
<li><a href="../id498828/index.html">Bagaimana garam meja dan protein akan meningkatkan kelangsungan hidup implan</a></li>
<li><a href="../id498832/index.html">Tinjauan tentang kemungkinan Qt Creator 4.12 dan QBS 1.16 untuk pemrograman mikrokontroler</a></li>
<li><a href="../id498834/index.html">33 mitaps online dalam seminggu. Pilih satu atau punya waktu untuk semuanya?</a></li>
<li><a href="../id498836/index.html">[Infografis] 50 besar waralaba game dengan pendapatan lebih dari satu miliar</a></li>
<li><a href="../id498840/index.html">Bot memonitor dan mengontrol komputer melalui telegram</a></li>
<li><a href="../id498842/index.html">Moderasi komentar: Namun, dapatkah kita mempercayai pengguna?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>