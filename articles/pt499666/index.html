<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 🎬 👯 PEP 572 (Expressões de atribuição no python 3.8) 🐻 📗 🕴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, Habr. Desta vez, veremos o PEP 572, que fala sobre expressões de atribuição. Se você ainda é cético em relação ao operador ": =" ou não entende c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572 (Expressões de atribuição no python 3.8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá, Habr. </font><font style="vertical-align: inherit;">Desta vez, veremos o PEP 572, que fala sobre expressões de atribuição. </font><font style="vertical-align: inherit;">Se você ainda é cético em relação ao operador ": =" ou não entende completamente as regras de uso, este artigo é para você. </font><font style="vertical-align: inherit;">Aqui você encontrará muitos exemplos e respostas para a pergunta: "Por que isso acontece?" </font><font style="vertical-align: inherit;">Este artigo acabou sendo o mais completo possível e, se você tiver pouco tempo, observe a seção que escrevi. </font><font style="vertical-align: inherit;">No início, as principais “teses” são coletadas para um trabalho confortável com expressões de atribuição. </font><font style="vertical-align: inherit;">Perdoe-me com antecedência se você encontrar erros (escreva sobre eles para mim, eu vou consertar). </font><font style="vertical-align: inherit;">Vamos começar:</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572 - Expressões de atribuição</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pep</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Título:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressões de atribuição</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autores:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;rosuav em gmail.com&gt;, Tim Peters &lt;tim.peters em gmail.com&gt;, Guido van Rossum &lt;guido em python.org&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussão:</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doc-sig em python.org</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aceitaram</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um tipo:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padrão</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criada:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28 de fevereiro de 2018</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versão Python:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publicar história:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-fev-2018, 02-mar-2018, 23-mar-2018, 04-abr-2018, 17-abr-2018, 25-abr-2018, 09-jul-2018, 05-ago-2019</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permissão para adotar o padrão:</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (com VPN por um longo tempo, mas é carregado)</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anotação</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justificação</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxe e semântica</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterações nas especificações durante a implementação</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativas rejeitadas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeções frequentes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomendações de estilo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obrigado</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apêndice A: Conclusões de Tim Peters</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apêndice B: Um Intérprete de Código Bruto para Geradores</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apêndice C: Nenhuma alteração na semântica do escopo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referências</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direito autoral</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minha parte</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anotação</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta convenção abordará a possibilidade de atribuição dentro de expressões, usando a nova notação NAME: = expr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como parte das inovações, o procedimento para calcular geradores de dicionário (compreensão de dicionário) foi atualizado. Isso garante que a expressão da chave seja avaliada antes da expressão do valor (isso permite vincular a chave a uma variável e, em seguida, reutilizar a variável criada no cálculo do valor correspondente à chave). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante uma discussão sobre esse PEP, esse operador ficou oficialmente conhecido como operador de morsa. O nome formal da construção é "Expressão de designação" (de acordo com o cabeçalho PEP: Expressões de designação), mas pode ser chamado de "Expressões nomeadas". Por exemplo, a implementação de referência no CPython usa esse mesmo nome.</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justificação</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A nomeação é uma parte importante da programação que permite o uso de um nome "descritivo" em vez de uma expressão mais longa, além de facilitar a reutilização de valores. </font><font style="vertical-align: inherit;">Atualmente, isso só pode ser feito na forma de instruções, o que torna esta operação indisponível ao gerar listas (compreensão da lista), bem como em outras expressões.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, nomear partes de uma expressão grande pode ajudar na depuração interativa, fornecendo ferramentas para exibir prompts e resultados intermediários. </font><font style="vertical-align: inherit;">Sem a capacidade de capturar os resultados de expressões aninhadas, você precisará alterar o código-fonte, mas, usando as expressões de atribuição, basta inserir alguns "marcadores" no formulário "nome: = expressão". </font><font style="vertical-align: inherit;">Isso elimina refatoração desnecessária e, portanto, reduz a probabilidade de alterações não intencionais do código durante a depuração (uma causa comum de Heisenbugs são erros que alteram as propriedades do código durante a depuração e podem aparecer inesperadamente na produção]), e esse código será mais compreensível para outro para o programador.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Importância do Código Real</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante o desenvolvimento deste PEP, muitas pessoas (tanto defensores quanto críticos) estavam muito focadas em exemplos de brinquedos, por um lado, e exemplos excessivamente complexos, por outro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O perigo dos exemplos de brinquedos é duplo: eles geralmente são muito abstratos para fazer alguém dizer "ah, isso é irresistível" e também são facilmente rejeitados com as palavras "eu nunca escreveria isso". O perigo de exemplos excessivamente complexos é que eles fornecem um ambiente conveniente para os críticos, sugerindo que essa funcionalidade seja removida ("Isso é muito confuso", dizem essas pessoas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, há um bom uso para tais exemplos: eles ajudam a esclarecer a semântica pretendida. Portanto, daremos alguns deles abaixo. No entanto, para ser </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convincente</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , os exemplos devem se basear em</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código </font><b><font style="vertical-align: inherit;">real</font></b><font style="vertical-align: inherit;"> que foi escrito sem pensar neste PEP. Ou seja, o código que faz parte de um aplicativo realmente útil (sem diferença: seja grande ou pequeno). Tim Peters nos ajudou muito olhando seus repositórios pessoais e escolhendo exemplos do código que ele escreveu, o que (em sua opinião) seria mais compreensível se eles fossem reescritos (sem fanatismo) usando expressões de atribuição. Sua conclusão é a seguinte: as mudanças atuais trariam uma melhoria modesta, mas óbvia, em alguns bits de seu código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro exemplo de código real é a observação indireta de como os programadores valorizam a compactação. Guido van Rossum verificou a base de código do Dropbox e encontrou algumas evidências de que os programadores preferem escrever menos linhas de código do que usar algumas expressões pequenas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caso em questão: Guido encontrou vários pontos ilustrativos quando um programador repete uma subexpressão (diminuindo a velocidade do programa), mas salva uma linha extra de código. </font><font style="vertical-align: inherit;">Por exemplo, em vez de escrever:</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os programadores preferiram esta opção:</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está outro exemplo, mostrando que os programadores às vezes estão dispostos a trabalhar mais para manter o "nível anterior" de indentação:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse código calcula o padrão2, mesmo que o padrão1 já corresponda (nesse caso, a segunda subcondição nunca será atendida). </font><font style="vertical-align: inherit;">Portanto, a seguinte solução é mais eficaz, mas menos atraente:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxe e semântica</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na maioria dos casos em que o Python usa expressões arbitrárias, agora você pode usar expressões de atribuição. </font><font style="vertical-align: inherit;">Eles têm o formato NAME: = expr, em que expr é qualquer expressão válida do Python, exceto a tupla não parênteses, e NAME é o identificador. </font><font style="vertical-align: inherit;">O valor dessa expressão coincide com o original, mas um efeito adicional é a atribuição de um valor ao objeto de destino:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casos excepcionais</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem vários locais em que expressões de atribuição não são permitidas para evitar ambiguidade ou confusão entre os usuários:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressões de atribuição que não estão entre parênteses são proibidas no nível "superior":</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa regra facilitará ao programador escolher entre um operador de atribuição e uma expressão de atribuição - não haverá situação sintática na qual as duas opções sejam equivalentes.</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma expressão de atribuição não introduz um novo escopo. Na maioria dos casos, o escopo no qual a variável será criada não requer explicação: será atual. Se a variável usou as palavras-chave não locais ou globais antes, a expressão de atribuição levará isso em consideração. Somente lambda (sendo uma definição anônima de uma função) é considerado um escopo separado para esses fins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há um caso especial: uma expressão de atribuição que ocorre em geradores de listas, conjuntos, dicionários ou nas próprias "expressões de geradores" (doravante denominadas coletivamente como "geradores" (compreensões)) vincula a variável ao escopo que o gerador contém, observando o modificador globab ou não global, se existir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lógica desse caso especial é dupla. </font><font style="vertical-align: inherit;">Em primeiro lugar, permite capturar convenientemente o "membro" nas expressões any () e all (), por exemplo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, fornece uma maneira compacta de atualizar uma variável de um gerador, por exemplo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, o nome da variável da expressão de atribuição não pode corresponder ao nome já usado nos geradores pelo loop for para iterar. </font><font style="vertical-align: inherit;">Os sobrenomes são locais para o gerador em que aparecem. </font><font style="vertical-align: inherit;">Seria inconsistente se as expressões de atribuição também se referissem ao escopo dentro do gerador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, [i: = i + 1 para i no intervalo (5)] não é válido: o loop for determina que i é local para o gerador, mas a parte “i: = i + 1” insiste que i é uma variável do externo escopo </font><font style="vertical-align: inherit;">Pelo mesmo motivo, os seguintes exemplos não funcionarão:</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora seja tecnicamente possível atribuir semântica consistente para esses casos, é difícil determinar se a maneira como entendemos essa semântica funcionará em seu código real. É por isso que a implementação de referência garante que esses casos aumentem o SyntaxError em vez de serem executados com um comportamento indefinido, dependendo da implementação específica do hardware. Esta restrição se aplica mesmo que uma expressão de atribuição nunca seja executada:</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o corpo do gerador (a parte antes da primeira palavra-chave “for”) e a expressão do filtro (a parte após o “if” e antes de qualquer “for” aninhado), essa restrição se aplica exclusivamente a nomes de variáveis ​​que são simultaneamente usados ​​como variáveis ​​iterativas. Como já dissemos, as expressões Lambda introduzem um novo escopo explícito da função e, portanto, podem ser usadas em expressões de geradores sem restrições adicionais. [Aproximadamente. novamente, exceto nesses casos: [i para i no intervalo (2, (lambda: (s: = 2) ()))]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido a limitações de design na implementação de referência (o analisador de tabela de símbolos não pode reconhecer se os nomes da parte esquerda do gerador são usados ​​na parte restante em que a expressão iterável está localizada), portanto, as expressões de atribuição são completamente proibidas como parte da iterável (na parte após cada "entrada" e antes de qualquer palavra-chave subsequente "se" ou "para"). </font><font style="vertical-align: inherit;">Ou seja, todos esses casos são inaceitáveis:</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra exceção ocorre quando uma expressão de atribuição é usada em geradores que estão no escopo de uma classe. </font><font style="vertical-align: inherit;">Se, ao usar as regras acima, ocorrer a criação de uma classe medida novamente no escopo, essa expressão de atribuição será inválida e resultará em um SyntaxError:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(O motivo da última exceção é o escopo implícito da função criada pelo gerador - atualmente não há mecanismo de tempo de execução para as funções se referirem a uma variável localizada no escopo da classe e não queremos adicionar esse mecanismo. Se esse problema for resolvido, esse caso especial (possivelmente) será removido da especificação das expressões de atribuição.Por favor, observe que esse problema ocorrerá mesmo que você tenha criado uma variável anteriormente no escopo da classe e tente alterá-la com uma expressão de atribuição do gerador.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consulte o Apêndice B para obter exemplos de como expressões de atribuição encontradas em geradores são convertidas em código equivalente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioridade relativa: =</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O operador: = é agrupado mais forte que a vírgula em todas as posições sintáticas, sempre que possível, mas mais fraco que todos os outros operadores, incluindo ou, e, e não, e expressões condicionais (A se C mais B). Como segue na seção "Casos excepcionais" acima, as expressões de atribuição nunca funcionam no mesmo "nível" que a atribuição clássica =. Se uma ordem diferente de operações for necessária, use parênteses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O operador: = pode ser usado diretamente ao chamar o argumento posicional de uma função. No entanto, isso não funcionará diretamente no argumento. Alguns exemplos que esclarecem o que é tecnicamente permitido e o que não é possível:</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maioria dos exemplos "válidos" acima não é recomendada para uso na prática, pois as pessoas que escanearam rapidamente o seu código-fonte podem não entender corretamente seu significado. </font><font style="vertical-align: inherit;">Mas, em casos simples, isso é permitido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este PEP recomenda que você </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coloque espaços em torno de: =, semelhante à recomendação do PEP 8 para = para tarefas clássicas. </font><font style="vertical-align: inherit;">(A diferença da última recomendação é que ela proíbe espaços em torno de =, que é usado para passar argumentos principais para a função.)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mude a ordem dos cálculos.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ter uma semântica bem definida, este acordo exige que o procedimento de avaliação seja claramente definido. </font><font style="vertical-align: inherit;">Tecnicamente, esse não é um requisito novo. </font><font style="vertical-align: inherit;">O Python já possui uma regra de que subexpressões geralmente são avaliadas da esquerda para a direita. </font><font style="vertical-align: inherit;">No entanto, as expressões de atribuição tornam esses "efeitos colaterais" mais visíveis, e propomos uma alteração na ordem de cálculo atual:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos geradores de dicionário {X: Y para ...}, Y é atualmente avaliado antes de X. Sugerimos alterar isso para que X seja calculado antes de Y. (Em um ditado clássico como {X: Y} e também em dict ((X, Y) para ...) isso já foi implementado. Portanto, os geradores de dicionário devem cumprir esse mecanismo)</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferenças entre expressões de atribuição e instruções de atribuição.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais importante, ": =" é uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressão</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que significa que pode ser usada nos casos em que as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruções</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não </font><b><font style="vertical-align: inherit;">são</font></b><font style="vertical-align: inherit;"> válidas, incluindo funções e geradores lambda. </font><font style="vertical-align: inherit;">Por outro lado, as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressões de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atribuição não suportam a funcionalidade estendida que pode ser usada nas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruções de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atribuição:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A atribuição em cascata não é suportada diretamente</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Destinos" separados, exceto o nome da variável simples NAME, não são suportados:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A funcionalidade e as vírgulas prioritárias diferem:</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os valores de desempacotamento e empacotamento não têm equivalência "pura" ou não são totalmente suportados</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As anotações do tipo embutido não são suportadas:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não há forma abreviada de operações:</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterações nas especificações durante a implementação</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As seguintes alterações foram feitas com base em nossa experiência e análises adicionais após a primeira gravação deste PEP e antes do lançamento do Python 3.8:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantir consistência com outras exceções semelhantes e não introduzir um novo nome que pode não ser conveniente para os usuários finais, a subclasse originalmente proposta de TargetScopeError para SyntaxError foi removida e reduzida ao SyntaxError usual. </font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido a limitações na análise da tabela de caracteres CPython, a implementação de referência da expressão de atribuição gera um SyntaxError para todos os usos nos iteradores. </font><font style="vertical-align: inherit;">Anteriormente, essa exceção ocorria apenas se o nome da variável que estava sendo criada coincidisse com o já usado na expressão iterativa. </font><font style="vertical-align: inherit;">Isso pode ser revisado se houver exemplos suficientemente convincentes, mas a complexidade adicional parece inadequada para casos de uso puramente "hipotéticos".</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos de biblioteca padrão do Python</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base é usado apenas em uma condição, portanto a atribuição pode ser colocada em if, como o "cabeçalho" de um bloco lógico.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código atual:</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código aprimorado:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode evitar ifs aninhados, removendo um nível de recuo.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código atual:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código aprimorado:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código parece mais clássico e também evita o aninhamento múltiplo de instruções condicionais. </font><font style="vertical-align: inherit;">(Consulte o Apêndice A para saber mais sobre a origem deste exemplo.)</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código atual:</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código aprimorado:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz é usado apenas para s + = tz. </font><font style="vertical-align: inherit;">Mover para dentro se ajuda a mostrar sua área lógica de uso.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código atual:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código aprimorado:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chamar fp.readline () como uma “condição” no loop while (assim como chamar o método .match ()) na condição if torna o código mais compacto sem complicar sua compreensão.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código atual:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código aprimorado:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificar geradores de listas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, o gerador de lista pode ser filtrado efetivamente "capturando" a condição:</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois disso, a variável pode ser reutilizada em outra expressão:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe novamente que, nos dois casos, a variável </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está no mesmo escopo que as variáveis ​​resultam e outras coisas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capturar valores em condições</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As expressões de atribuição podem ser efetivamente usadas nas condições de uma instrução if ou while:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em particular, essa abordagem pode eliminar a necessidade de criar um loop infinito, atribuição e verificação de condições. </font><font style="vertical-align: inherit;">Também permite desenhar um paralelo suave entre um ciclo que usa uma chamada de função como sua condição, bem como um ciclo que não apenas verifica a condição, mas também usa o valor real retornado pela função no futuro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garfo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um exemplo do mundo de baixo nível do UNIX: [aprox. </font><font style="vertical-align: inherit;">Fork () é uma chamada de sistema em sistemas operacionais semelhantes ao Unix que cria um novo subprocesso em relação ao pai.]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativas rejeitadas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, sugestões semelhantes são bastante comuns na comunidade python. </font><font style="vertical-align: inherit;">Abaixo estão algumas sintaxes alternativas para expressões de atribuição que são específicas demais para entender e foram rejeitadas em favor do acima.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterando o escopo para geradores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma versão anterior deste PEP, foi proposto fazer alterações sutis nas regras de escopo dos geradores para torná-los mais adequados para uso no escopo das classes. </font><font style="vertical-align: inherit;">No entanto, essas propostas levariam a incompatibilidade com versões anteriores e, portanto, foram rejeitadas. </font><font style="vertical-align: inherit;">Portanto, esse PEP foi capaz de se concentrar totalmente apenas nas expressões de atribuição.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ortografia alternativa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, as expressões de atribuição propostas têm a mesma semântica, mas são escritas de maneira diferente.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPR como NAME:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É mais provável que essa sintaxe entre em conflito com os outros do que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a menos que você conte o aumento de Exc das construções Exc), mas, caso contrário, será comparável a eles. </font><font style="vertical-align: inherit;">Em vez de um paralelo com expr como target: (o que pode ser útil, mas também pode ser confuso), essa opção não tem paralelos com nada, mas é surpreendentemente melhor lembrada.</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casos especiais em declarações condicionais</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dos casos de uso mais comuns para expressões de atribuição são as instruções if e while. </font><font style="vertical-align: inherit;">Em vez de uma solução mais geral, o uso de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melhora a sintaxe dessas duas instruções adicionando um meio de capturar o valor a ser comparado:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso funciona bem, mas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOMENTE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando a condição desejada é baseada na "correção" do valor de retorno. </font><font style="vertical-align: inherit;">Portanto, esse método é eficaz para casos específicos (verificação de expressões regulares, leitura de soquetes, retorno de uma string vazia quando a execução termina) e é completamente inútil em casos mais complexos (por exemplo, quando a condição é f (x) &lt;0 e você deseja salve o valor de f (x)). </font><font style="vertical-align: inherit;">Além disso, isso não faz sentido nos geradores de lista. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vantagens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Sem ambigüidades sintáticas. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desvantagens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : mesmo se você o usar apenas nas declarações if / while, ele só funcionará bem em alguns casos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casos especiais em geradores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro caso de uso comum para expressões de atribuição são geradores (lista / conjunto / dict e genexps). </font><font style="vertical-align: inherit;">Como acima, foram feitas sugestões para soluções específicas.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde, let ou dado:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse método resulta em uma subexpressão entre o loop for e a expressão principal. </font><font style="vertical-align: inherit;">Ele também apresenta uma palavra-chave de idioma adicional, que pode criar conflitos. </font><font style="vertical-align: inherit;">Das três opções, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é a mais limpa e a mais legível, mas ainda existem conflitos em potencial (por exemplo, SQLAlchemy e numpy têm seus métodos where, além de tkinter.dnd.Icon na biblioteca padrão).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com NAME = EXPR:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Independentemente do método escolhido, uma diferença semântica acentuada será introduzida entre geradores e suas versões implementadas por meio de um loop for. </font><font style="vertical-align: inherit;">Seria impossível envolver o ciclo em um gerador sem processar o estágio de criação das variáveis. </font><font style="vertical-align: inherit;">A única palavra-chave que pode ser reorientada para esta tarefa é a palavra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mas isso fornecerá semânticas diferentes em diferentes partes do código, o que significa que você precisa criar uma nova palavra-chave, mas isso envolve muitos custos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menor prioridade do operador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O operador: = tem duas prioridades lógicas. Ou deve ter a menor prioridade possível (a par do operador de atribuição). Ou deve ter precedência maior que os operadores de comparação. Colocar sua prioridade entre operadores de comparação e operações aritméticas (para ser preciso: um pouco menor que o OR bit a bit) permitirá que você fique sem parênteses na maioria dos casos, quando e se você o usar, pois é mais provável que você deseje manter o valor de algo antes como a comparação será realizada:</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim que find () retorna -1, o loop termina. </font><font style="vertical-align: inherit;">Se: = liga os operandos tão livremente quanto =, então o resultado de find () será “capturado” primeiro no operador de comparação e geralmente retornará True ou False, o que é menos útil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora esse comportamento seja conveniente na prática em muitas situações, seria mais difícil de explicar. </font><font style="vertical-align: inherit;">E, portanto, podemos dizer que "o operador: = se comporta da mesma forma que o operador de atribuição usual". </font><font style="vertical-align: inherit;">Ou seja, a prioridade para: = foi escolhida o mais próximo possível do operador = (exceto que: = tem prioridade maior que a vírgula).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você dá vírgulas à direita</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns críticos argumentam que as expressões de atribuição devem reconhecer tuplas sem a adição de colchetes, para que as duas entradas sejam equivalentes:</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Na versão atual do padrão, o último registro será equivalente à expressão ((ponto: = x), y).) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas é lógico que nesse cenário, ao usar a expressão de atribuição na chamada de função, ele também tenha uma prioridade mais baixa que a vírgula, portanto, obtivemos seria a seguinte equivalência confusa:</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E temos a única saída menos confusa: torne o operador: = uma prioridade mais baixa que a vírgula.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sempre exigindo suportes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sempre foi proposto agrupar as expressões de atribuição. </font><font style="vertical-align: inherit;">Isso nos salvaria muitas ambiguidades. </font><font style="vertical-align: inherit;">De fato, muitas vezes serão necessários parênteses para extrair o valor desejado. </font><font style="vertical-align: inherit;">Mas nos seguintes casos, a presença de colchetes nos pareceu claramente supérflua:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeções frequentes</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que não transformar as declarações de atribuição em expressões?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C e linguagens similares definem o operador </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como uma expressão, não uma instrução, como o Python. </font><font style="vertical-align: inherit;">Isso permite a atribuição em muitas situações, incluindo locais onde as variáveis ​​são comparadas. </font><font style="vertical-align: inherit;">As semelhanças sintáticas entre if (x == y) e if (x = y) contradizem sua semântica nitidamente diferente. </font><font style="vertical-align: inherit;">Assim, este PEP apresenta o operador: = para esclarecer suas diferenças.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que se preocupar com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressões de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atribuição </font><font style="vertical-align: inherit;">se existem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruções de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atribuição?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas duas formas têm flexibilidades diferentes. </font><font style="vertical-align: inherit;">O operador: = pode ser usado dentro de uma expressão maior e no operador = pode ser usado pela "família de minioperadores" do tipo "+ =". </font><font style="vertical-align: inherit;">Também = permite atribuir valores por atributos e índices.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que não usar o escopo local e evitar a poluição do espaço para nome?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As versões anteriores deste padrão incluíam um escopo local real (limitado a uma declaração) para expressões de atribuição, impedindo o vazamento e a poluição do espaço para nome. </font><font style="vertical-align: inherit;">Apesar do fato de que em algumas situações isso deu uma certa vantagem, em muitas outras isso complica a tarefa, e os benefícios não são justificados pelas vantagens da abordagem existente. </font><font style="vertical-align: inherit;">Isso é feito no interesse da simplicidade da linguagem. </font><font style="vertical-align: inherit;">Você não precisa mais dessa variável? </font><font style="vertical-align: inherit;">Existe uma solução: exclua a variável usando a palavra-chave del ou adicione um sublinhado menor ao seu nome. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(O autor gostaria de agradecer a Guido van Rossum e Christophe Groth por suas sugestões para avançar o padrão PEP nessa direção. [2])</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomendações de estilo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como as expressões de atribuição às vezes podem ser usadas em pé de igualdade com um operador de atribuição, surge a pergunta: o que ainda é preferido? .. De acordo com outras convenções de estilo (como o PEP 8), há duas recomendações:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você pode usar as duas opções de atribuição, dê preferência aos operadores. </font><font style="vertical-align: inherit;">Eles expressam mais claramente suas intenções.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o uso de expressões de atribuição levar a ambiguidade na ordem de execução, reescreva o código usando o operador clássico.</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obrigado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os autores deste padrão gostariam de agradecer a Nick Coghlan e Steven D'Aprano por suas contribuições significativas a este PEP, bem como aos membros do Python Core Mentorship por sua ajuda na implementação disso.</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apêndice A: Conclusões de Tim Peters</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um pequeno ensaio que Tim Peters escreveu sobre esse tópico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não gosto do código "confuso" e também não gosto de colocar lógica conceitualmente não relacionada em uma linha. </font><font style="vertical-align: inherit;">Então, por exemplo, em vez de:</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu prefiro escrever:</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, acho que vou encontrar vários lugares onde quero usar expressões de atribuição. </font><font style="vertical-align: inherit;">Eu nem quero falar sobre o uso deles em expressões que já estão esticadas para metade da tela. </font><font style="vertical-align: inherit;">Em outros casos, comportamentos como:</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Significativamente melhor que isso:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses dois códigos têm conceitos completamente diferentes e misturá-los seria uma loucura. </font><font style="vertical-align: inherit;">Em outros casos, a combinação de expressões lógicas complica a compreensão do código. </font><font style="vertical-align: inherit;">Por exemplo, reescrevendo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma forma mais curta, perdemos a "lógica". </font><font style="vertical-align: inherit;">Você precisa entender como esse código funciona. </font><font style="vertical-align: inherit;">Meu cérebro não quer fazer isso:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas esses casos são raros. </font><font style="vertical-align: inherit;">A tarefa de preservar o resultado é muito comum e “escasso é melhor que denso” não significa que “quase vazio é melhor que escasso” [aprox. </font><font style="vertical-align: inherit;">uma referência ao Zen Python]. </font><font style="vertical-align: inherit;">Por exemplo, tenho muitas funções que retornam None ou 0 para dizer "Não tenho nada útil, mas como isso acontece com frequência, não quero incomodá-lo com exceções". </font><font style="vertical-align: inherit;">De fato, esse mecanismo também é usado em expressões regulares que retornam None quando não há correspondências. </font><font style="vertical-align: inherit;">Portanto, neste exemplo, muito código:</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acho a seguinte opção mais compreensível e, claro, mais legível:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No começo, não dei muita importância a isso, mas uma construção tão curta apareceu com tanta frequência que logo começou a me irritar que eu não podia usá-la. </font><font style="vertical-align: inherit;">Isso me surpreendeu! </font><font style="vertical-align: inherit;">[Aproximadamente. </font><font style="vertical-align: inherit;">aparentemente, isso foi escrito antes do lançamento oficial do Python 3.8.] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há outros casos em que as expressões de atribuição realmente "disparam". </font><font style="vertical-align: inherit;">Em vez de vasculhar meu código novamente, Kirill Balunov deu um bom exemplo da função copy () da biblioteca copy.py padrão:</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A crescente indentação é enganosa: afinal, a lógica é plana: o primeiro teste bem-sucedido “vence”:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O simples uso de expressões de atribuição permite que a estrutura visual do código enfatize o "plano" da lógica. </font><font style="vertical-align: inherit;">Mas o recuo sempre crescente o torna implícito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está outro pequeno exemplo do meu código, que me deixou muito feliz porque me permitiu colocar a lógica relacionada internamente em uma linha e remover o irritante nível de indentação "artificial". </font><font style="vertical-align: inherit;">É exatamente isso que eu quero da declaração if e facilita a leitura. </font><font style="vertical-align: inherit;">O código a seguir:</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se tornou:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, na maioria das linhas em que a atribuição de variáveis ​​ocorre, eu não usaria expressões de atribuição. </font><font style="vertical-align: inherit;">Mas esse design é tão frequente que ainda há muitos lugares onde eu aproveitaria essa oportunidade. </font><font style="vertical-align: inherit;">Nos casos mais recentes, ganhei um pouco, como costumavam aparecer. </font><font style="vertical-align: inherit;">Na subparte restante, isso levou a melhorias médias ou grandes. </font><font style="vertical-align: inherit;">Assim, eu usaria expressões de atribuição com muito mais frequência do que um triplo se, mas com muito menos frequência do que com a atribuição aumentada [aprox. </font><font style="vertical-align: inherit;">opções curtas: * =, / =, + =, etc.].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo numérico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu tenho outro exemplo que me impressionou mais cedo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se todas as variáveis ​​forem números inteiros positivos e a variável </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maior que a enésima raiz de x, esse algoritmo retornará o arredondamento "inferior" da enésima raiz de x (e aproximadamente dobra aproximadamente o número de bits exatos por iteração):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não está claro por que, mas essa variante do algoritmo é menos óbvia do que um loop infinito com uma quebra de ramificação condicional (loop e meio). Também é difícil provar a correção dessa implementação sem depender de uma afirmação matemática (“média aritmética - desigualdade média geométrica”) e sem saber algumas coisas não triviais sobre como o arredondamento aninhado se comporta de maneira descendente. Mas aqui o problema já está em matemática, e não em programação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E se você sabe tudo isso, a opção que usa expressões de atribuição é lida com muita facilidade, como uma frase simples: “Verifique a“ estimativa ”atual e se ela for muito grande, reduza-a” e a condição permite salvar imediatamente o valor intermediário da condição do loop. Na minha opinião, a forma clássica é mais difícil de entender:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apêndice B: Um Intérprete de Código Bruto para Geradores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este apêndice tenta esclarecer (embora não especifique) as regras pelas quais uma variável deve ser criada nas expressões geradoras. </font><font style="vertical-align: inherit;">Para vários exemplos ilustrativos, mostramos o código-fonte onde o gerador é substituído por uma função equivalente em combinação com alguns “andaimes”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como [x para ...] é equivalente à lista (x para ...), os exemplos não perdem sua generalidade. </font><font style="vertical-align: inherit;">E, como esses exemplos se destinam apenas a esclarecer as regras gerais, eles não afirmam ser realistas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: os geradores agora são implementados através da criação de funções de gerador aninhadas (semelhantes às fornecidas neste apêndice). </font><font style="vertical-align: inherit;">Os exemplos mostram a nova parte, que adiciona a funcionalidade apropriada para trabalhar com o escopo das expressões de atribuição (como se a atribuição tivesse sido executada em um bloco contendo o gerador mais externo). </font><font style="vertical-align: inherit;">Para simplificar a “inferência de tipo”, esses exemplos ilustrativos não levam em consideração que as expressões de atribuição são opcionais (mas levam em consideração o escopo da variável criada dentro do gerador). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos primeiro lembrar qual código é gerado "sob o capô" para geradores sem expressões de atribuição:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código fonte (o EXPR costuma usar a variável VAR):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O código convertido (não vamos nos preocupar com conflitos de nome):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos adicionar uma expressão de atribuição simples.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos adicionar a instrução TARGET global à declaração da função f ().</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou vice-versa, vamos adicionar TARGET não-local à declaração da função f ().</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, vamos colocar dois geradores.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apêndice C: Nenhuma alteração na semântica do escopo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que no Python a semântica do escopo não mudou. </font><font style="vertical-align: inherit;">O escopo das funções locais ainda é determinado no tempo de compilação e tem uma extensão de tempo indefinida no tempo de execução (fechamento). </font><font style="vertical-align: inherit;">Exemplo:</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referências</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prova de implementação de conceito</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussão da semântica das expressões de atribuição</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a VPN é rígida, mas carregada)</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussão do TargetScopeError no PEP 572</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (carregado de forma semelhante à anterior)</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direito autoral</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este documento foi disponibilizado ao público. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fonte: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minha parte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para começar, vamos resumir:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que as </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pessoas não tentem</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> remover a dualidade semântica, em muitos lugares "clássicos", onde se pode usar "=" e ": =", existem restrições; portanto, o operador :: = geralmente deve estar entre colchetes. </font><font style="vertical-align: inherit;">Esses casos deverão ser revistos na seção que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descreve o uso básico.</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prioridade das expressões de atribuição é um pouco maior que a de uma vírgula. </font><font style="vertical-align: inherit;">Devido a isso, as tuplas não são formadas durante a atribuição. </font><font style="vertical-align: inherit;">Também possibilita o uso do operador: = ao passar argumentos para uma função.</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, quero dizer que gostei do novo operador. </font><font style="vertical-align: inherit;">Ele permite que você escreva códigos mais simples em condições, listas de "filtros" e também (finalmente) remova a linha "mesma" e solitária antes de se. </font><font style="vertical-align: inherit;">Se as pessoas usarem expressões de atribuição para a finalidade pretendida, será uma ferramenta muito conveniente que aumentará a legibilidade e a beleza do código (embora isso possa ser dito sobre qualquer linguagem funcional ...)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt499654/index.html">Como implementar o CRM em um site remoto e vencer?</a></li>
<li><a href="../pt499656/index.html">Simulação do controlador de temperatura PID</a></li>
<li><a href="../pt499658/index.html">Um trabalhador em vez de um testador? Vale a pena estudar Selenium em 2020?</a></li>
<li><a href="../pt499662/index.html">Raiz de confiança para IoT e outras tendências de segurança da IoT</a></li>
<li><a href="../pt499664/index.html">Portando APIs para TypeScript como um solucionador de problemas</a></li>
<li><a href="../pt499668/index.html">Dependências do JavaScript do caminho para o inferno</a></li>
<li><a href="../pt499670/index.html">Я перехожу на JavaScript</a></li>
<li><a href="../pt499674/index.html">Outro passo para computadores ópticos</a></li>
<li><a href="../pt499676/index.html">Mais de 90 ferramentas úteis para o Kubernetes: implantação, gerenciamento, monitoramento, segurança e muito mais</a></li>
<li><a href="../pt499680/index.html">Aprendendo Kubernetes: Básico 14 a 16 de maio, Avançado de 18 a 20 de maio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>