<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🌾 👨🏻‍⚖️ 👡 最小のオートメーション。パート1.1。仮想化の基本 👷🏻 🕉️ 👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前の記事では、仮想化ネットワークのアーキテクチャ、アンダーレイオーバーレイ、VM間のパッケージパスなどについて説明しました。
 Roman Gorgeは彼女に触発され、仮想化全般に関するレビューの問題を書くことにしました。
 
 この記事では、ネットワーク機能の仮想化が実際にどのように行われるか、V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>最小のオートメーション。パート1.1。仮想化の基本</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、仮想化ネットワークのアーキテクチャ、アンダーレイオーバーレイ、VM間のパッケージパスなどについて説明しました。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Gorgeは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼女</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">に</font></a><font style="vertical-align: inherit;">触発され、仮想化全般に関するレビューの問題を書くことにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、ネットワーク機能の仮想化が実際にどのように行われるか、VMを起動および管理するための主な製品のバックエンドがどのように実装されるか、および仮想スイッチングがどのように機能するか（OVSおよびLinuxブリッジ）について触れます（または触れようとします）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想化のトピックは幅広く深く、ハイパーバイザーの動作の詳細をすべて説明することは不可能です（そしてそれは必要ではありません）。</font><font style="vertical-align: inherit;">私たちは、必ずしも電話会社ではなく、仮想化ソリューションの運用を理解するために必要な最小限の知識に制限します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h1><br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化の概要と簡単な歴史</font></font></b></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想リソースのタイプ-コンピューティング、ストレージ、ネットワーク</font></font></b></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想スイッチング</font></font></b></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化ツール-libvirt、virshなど</font></font></b></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></b></li>
</ul><br>
<hr><br>
<br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化の概要と簡単な歴史</font></font></h1><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新の仮想化テクノロジーの歴史は、若い会社VMwareがVMware Workstationと呼ばれる製品をリリースした1999年に遡ります。</font><font style="vertical-align: inherit;">これはデスクトップ/クライアントアプリケーション用の仮想化製品でした。</font><font style="vertical-align: inherit;">サーバー側の仮想化は少し後にESX Server製品の形で登場し、それは後でESXi（iは統合を意味する）に進化しました。これは、サーバーアプリケーションハイパーバイザーとしてITおよび電話会社のあらゆる場所で使用されている同じ製品です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オープンソース側では、2つの主要なプロジェクトがLinuxに仮想化をもたらしました。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM（カーネルベースの仮想マシン）は、カーネルがハイパーバイザーとして機能できるようにするLinuxカーネルモジュールです（VMの起動と管理に必要なインフラストラクチャを作成します）。</font><font style="vertical-align: inherit;">これは、2007年にカーネルバージョン2.6.20で追加されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QEMU（Quick Emulator）-仮想マシンのハードウェア（CPU、ディスク、RAM、USBポートを含むあらゆるもの）を直接エミュレートし、KVMと組み合わせて使用​​して、ほぼ「ネイティブ」のパフォーマンスを実現します。</font></font></li>
</ul><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、現時点では、KVMのすべての機能がQEMUで利用できますが、ほとんどのLinux仮想化ユーザーはKVM / QEMUを直接使用せず、少なくとも1つの抽象化レベルでアクセスしますが、後で詳しく説明するため、これは重要ではありません。</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、VMware ESXiとLinux QEMU / KVMは、市場を支配する2つの主要なハイパーバイザーです。</font><font style="vertical-align: inherit;">また、2つの異なるタイプのハイパーバイザーの代表でもあります。</font></font><br>
<ul>
<li>Type 1 —      (bare-metal).   VMware ESXi, Linux KVM, Hyper-V</li>
<li>Type 2 —    Host OS ( ).   VMware Workstation  Oracle VirtualBox.</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が良いか、何が悪いかについての議論は、この記事の範囲を超えています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉄の生産者はまた、許容できるパフォーマンスを確保するために自分たちの役割を果たさなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく最も重要で最も広く使用されているのはIntel VT（仮想化テクノロジー）です。これは、ハイパーバイザーの効果的な動作に使用されるx86プロセッサー用にIntelが開発した一連の拡張機能です（場合によっては、VTがオンになっていないとKVMが機能しないなど） -xとそれなしでは、ハイパーバイザーはハードウェアアクセラレーションなしで純粋にソフトウェアエミュレーションに従事することを強制されます）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの拡張機能のうち2つは、VT-xとVT-dで最もよく知られています。 1つ目は仮想化中のCPUパフォーマンスを改善するために重要です。これは一部の機能にハードウェアサポートを提供するため（VT-x 99.9％のゲストOSコードは物理プロセッサー上で直接実行され、最も必要な場合にのみエミュレーション用の出力を作成します）、2つ目は物理デバイスを直接接続するためです仮想マシンへ（フォワード仮想機能（VF）SRIOVの場合、たとえば、VT-dを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有効にする必要があります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の重要な概念は、完全仮想化と準仮想化の違いです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全仮想化は優れており、どのオペレーティングシステムでも任意のプロセッサで実行できますが、非常に効率が悪く、負荷の高いシステムには絶対に適していません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、準仮想化とは、ゲストOSが仮想環境で実行されていることを認識し、ハイパーバイザーと連携して効率を向上させることです。つまり、ゲストハイパーバイザーインターフェイスが表示されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日使用されているオペレーティングシステムの大部分は、準仮想化をサポートしています。Linuxカーネルでは、これはカーネルバージョン2.6.20以降に登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンが機能するには、仮想プロセッサ（vCPU）と仮想メモリ（RAM）だけでなく、PCIデバイスのエミュレーションも必要です。つまり、実際には、仮想ネットワークインターフェースやディスクなどを管理するためのドライバーセットが必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux KVMハイパーバイザーでは、</font><font style="vertical-align: inherit;">仮想I / Oデバイスを開発および使用するためのフレームワークである</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実装することで、この問題を解決しました</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Virtioは追加レベルの抽象化です。これにより、準仮想化ハイパーバイザーでさまざまなI / Oデバイスをエミュレートして、仮想マシンの側面に統一された標準化されたインターフェイスを提供できます。これにより、さまざまなデバイスにvirtioドライバーコードを再利用できます。 Virtioは以下で構成されます：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> フロントエンドドライバー-仮想マシンの内容</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> バックエンドドライバー-ハイパーバイザーの内容</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> トランスポートドライバー-バックエンドとフロントエンドを接続するもの</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモジュール性により、仮想マシンのドライバーに影響を与えることなく、ハイパーバイザーで使用されるテクノロジーを変更できます（この点は、ネットワークアクセラレーションテクノロジーおよびクラウドソリューション全般に​​とって非常に重要ですが、後で詳しく説明します）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、ゲストOSが仮想環境で実行されていることを「認識」すると、ゲストとハイパーバイザーの接続が確立されます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFPで質問を書いたり、RFPで質問に回答したりした場合、「virtioは製品でサポートされていますか？」</font><font style="vertical-align: inherit;">それはちょうどフロントエンドのvirtioドライバーをサポートすることでした。</font></font><br>
</blockquote><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想リソースのタイプ-コンピューティング、ストレージ、ネットワーク</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンは何で構成されていますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想リソースには主に3つのタイプがあります。</font></font><br>
<br>
<ul>
<li> compute —    </li>
<li> storage —       </li>
<li> network —     /</li>
</ul><br>
<br>
<hr><br>
<br>
<h1>Compute</h1><br>
<br>
<h2>CPU</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には、QEMUはあらゆるタイプのプロセッサとそれに対応するフラグおよび機能をエミュレートできます。実際には、QEMUはホストモデルを使用してフラグを個別にオフにしてからゲストOSに転送するか、名前付きモデルを取得してフラグを個別にオン/オフにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、QEMUはゲストOSがQEMU仮想CPUとして認識するプロセッサーをエミュレートします。これは、特に仮想マシンで実行されているアプリケーションがその作業にCPUフラグを使用する場合、最適なタイプのプロセッサではありません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QEMUのさまざまなCPUモデルの詳細をご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QEMU / KVMでは、プロセッサトポロジ、スレッド数、キャッシュサイズ、vCPUを物理コアにバインドするなどの制御も可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが仮想マシンに必要かどうかは、ゲストOSで実行されているアプリケーションのタイプによって異なります。</font><font style="vertical-align: inherit;">たとえば、高いPPSでパケットを処理するアプリケーション</font><font style="vertical-align: inherit;">では、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUピニング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実行することが重要です</font><font style="vertical-align: inherit;">。つまり、物理プロセッサを他の仮想マシンに転送できないようにする</font><font style="vertical-align: inherit;">ことが重要</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の行はRAMです。</font><font style="vertical-align: inherit;">ホストOSの観点からは、QEMU / KVMを使用して起動された仮想マシンは、オペレーティングシステムのユーザー空間で実行されている他のプロセスと同じです。</font><font style="vertical-align: inherit;">したがって、仮想マシンにメモリを割り当てるプロセスは、たとえばChromeブラウザを起動した場合と同じように、カーネルのホストOSで同じ呼び出しによって実行されます。</font></font><br>
<br>
<blockquote>          ,       <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">NUMA</a></b> — Non-Uniform Memory Access.<br>
          (CPU)       (RAM).    +      (node).    NUMA nodes     — <b>QPI</b> (QuickPath Interconnect)<br>
<br>
  NUMA node —  ,    ,     ,    NUMA node,   NUMA node —  ,    ,     ,    NUMA nodes,            QPI .<br>
</blockquote><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンの観点から見ると、メモリは起動時にすでに割り当てられていますが、実際には割り当てられていません。ゲストOSのアプリケーションが追加のメモリを要求すると、カーネルホストOSはメモリの新しいセクションをQEMU / KVMプロセスに割り当てます（ただし、 QEMU / KVMを直接指定して、起動時にすべてのメモリを仮想マシンに直接割り当てる場合は例外です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリはバイト</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ごと</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではなく、特定のサイズの</font><b><font style="vertical-align: inherit;">ページごとに</font></b><font style="vertical-align: inherit;">割り当てられ</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。ページサイズは設定可能であり、理論的には任意ですが、実際のサイズは4kB（デフォルト）、2MBおよび1GBです。最後の2つのサイズは</font><b><font style="vertical-align: inherit;">HugePages</font></b><font style="vertical-align: inherit;">と呼ばれ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、メモリを集中的に使用する仮想マシンにメモリを割り当てるためによく使用されます。ページの仮想アドレスと</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換ルックアサイドバッファー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLB</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">内の物理メモリとの一致を見つけるプロセスでHugePagesを使用する理由</font><font style="vertical-align: inherit;">。これは順番に制限され、最後に使用されたページに関する情報のみを格納します。 TLBに目的のページに関する情報がない場合</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミスTLB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるプロセスが発生し</font><font style="vertical-align: inherit;">、ホストOSプロセッサを使用して目的のページに対応する物理メモリセルを見つける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスは非効率的で低速であるため、使用されるページのサイズが大きくなります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QEMU / KVMでは、ゲストOSのさまざまなNUMAトポロジをエミュレートしたり、特定のNUMAノードのホストOSからのみ仮想マシンのメモリを取得したりすることもできます。</font><font style="vertical-align: inherit;">最も一般的な方法は、ローカルのNUMAノードから仮想マシンに割り当てられたプロセッサに仮想マシンのメモリを取得することです。</font><font style="vertical-align: inherit;">その理由は、</font><font style="vertical-align: inherit;">物理サーバーのCPUソケットを接続</font><font style="vertical-align: inherit;">する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QPI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バスに</font><font style="vertical-align: inherit;">不必要な負荷をかけたくないということです</font><font style="vertical-align: inherit;">（もちろん、サーバーに2つ以上のソケットがある場合、これは論理的です）。</font></font><br>
<br>
<hr><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、RAMは、電源をオフにするかオペレーティングシステムを再起動すると内容が消えるため、オペレーショナルメモリと呼ばれます。</font><font style="vertical-align: inherit;">情報を保存するには、永続ストレージデバイス（ROM）または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永続ストレージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
永続ストレージには、主に2つのタイプがあります。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックストレージ（ブロックストレージ）-ファイルシステムのインストールとパーティションの作成に使用できるディスク領域のブロック。</font><font style="vertical-align: inherit;">失礼な場合は、通常のディスクとして使用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトストレージ-情報はオブジェクト（ファイル）としてのみ保存でき、HTTP / HTTPS経由でアクセスできます。</font><font style="vertical-align: inherit;">オブジェクトストレージの一般的な例は、AWS S3またはDropboxです。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンには</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永続的なストレージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">ですが、仮想マシンがホストOSのメモリに「存続」している場合はどうすればよいですか？つまり、仮想ディスクコントローラーへのゲストOSの呼び出しはQEMU / KVMによってインターセプトされ、ホストOSの物理ディスク上のレコードに変換されます。この方法は効率が悪いため、ここでもネットワークデバイスでも、IDEまたはiSCSIデバイスを完全にエミュレートする代わりにvirtioドライバーを使用しています。詳しくはこちらを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、仮想マシンはvirtioドライバーを介して仮想ディスクにアクセスし、QEMU / KVMは転送された情報を物理ディスクに書き込みます。ホストOSでは、ディスクバックエンドをCEPH、NFS、またはiSCSIシェルフとして実装できることを理解することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
永続ストレージをエミュレートする最も簡単な方法は、ホストOSのいくつかのディレクトリにあるファイルを仮想マシンのディスクスペースとして使用することです。 QEMU / KVMは、この種のファイルのさまざまな形式（raw、vdi、vmdkなど）をサポートしています。ただし、最も広く使用されている形式は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qcow2です。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（QEMUコピーオンライトバージョン2）。一般に、qcow2は、オペレーティングシステムを使用しない特定の方法で構造化されたファイルです。多数の仮想マシンがqcow2-images（イメージ）の形式で配布され、qcow2-formatでパックされた仮想マシンのシステムディスクのコピーです。これには多くの利点があります。qcow2エンコーディングは、バイトからバイトへのディスクのrawコピーよりもはるかに少ないスペースで済みます。QEMU/ KVMは、qcow2ファイルのサイズを変更できます。つまり、仮想マシンのディスクのサイズを変更でき、AES qcow2暗号化もサポートされます（これは、仮想マシンのイメージに知的財産が含まれている可能性があるため、理にかなっています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、仮想マシンが起動すると、QEMU / KVMはqcow2ファイルをシステムディスクとして使用し（ここでは仮想マシンをロードするプロセスを省略していますが、これも興味深いタスクです）、仮想マシンはvirtioを介してqcow2ファイルにデータを読み書きすることができます-運転者。したがって、qcow2ファイルにはいつでも仮想マシンのシステムディスクの完全なコピーが含まれ、イメージをバックアップ、別のホストへの転送などに使用できるため、仮想マシンのイメージを取得するプロセスは機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、このqcow2ファイルはゲストOSで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / vdaデバイス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として定義され、ゲストOS </font><font style="vertical-align: inherit;">はディスク領域をパーティションに分割してファイルシステムをインストールします。同様に、QEMU / KVMによって次のように接続された次のqcow2ファイル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / vdX</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバイスは</font><font style="vertical-align: inherit;">、情報を格納する仮想マシンの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックストレージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として使用できます</font><font style="vertical-align: inherit;">（これがOpenstack Cinderコンポーネントの動作方法です）。</font></font><br>
<hr><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通信網</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想リソースの最後のリストは、ネットワークカードとI / Oデバイスです。</font><font style="vertical-align: inherit;">物理ホストのような仮想マシンは、</font><font style="vertical-align: inherit;">I / Oデバイスを接続するために</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCI / PCIeバス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">必要とし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">QEMU / KVMは、さまざまなタイプのチップセット-q35またはi440fx（最初はPCIeをサポートし、2つ目はレガシーPCIをサポートします）をエミュレートできます。また、たとえば、NUMAノードのゲストOS用に個別のPCIバス（PCIエクスパンダーバス）を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCI / PCIeバスを作成した後、I / Oデバイスをそれに接続する必要があります。一般に、ネットワークカードから物理GPUまで何でもかまいません。そしてもちろん、完全に仮想化された（たとえば、完全にe1000仮想化されたインターフェイス）と、準仮想化された（たとえば、virtio）または物理NICの両方のネットワークカードです。最後のオプションは、ルーター、ファイアウォールなど、ラインレートのパケット転送レートを取得する必要があるデータプレーン仮想マシンに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIパススルー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SR-IOVの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの主要なアプローチがあります</font><font style="vertical-align: inherit;">。それらの主な違いは、PCI-PTの場合、ドライバーはゲストOS内でのみ使用され、SRIOVの場合は、ホストOSドライバーが使用されることです（</font><b><font style="vertical-align: inherit;">VF-仮想関数</font></b><font style="vertical-align: inherit;">を作成するため）</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）およびSR-IOV VFを制御するためのゲストOSドライバー。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュニパー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークスは、PCI-PTとSRIOVに関する優れた詳細を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">書いてい</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明確にするために、PCIパススルーとSR-IOVが補完的なテクノロジーであることは注目に値します。</font><font style="vertical-align: inherit;">SR-IOVは、物理機能を仮想機能にスライスしたものです。</font><font style="vertical-align: inherit;">これは、ホストOSレベルで行われます。</font><font style="vertical-align: inherit;">同時に、ホストOSは仮想機能を別のPCI / PCIeデバイスとして認識します。</font><font style="vertical-align: inherit;">彼が彼らと次にすることは重要ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCI-PTは、SR-IOVデバイスによって作成された仮想機能を含む、ゲストOSのホストOS PCIデバイスを転送するためのメカニズムです。</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、仮想リソースの主なタイプを検討しました。次のステップは、仮想マシンがネットワークを介して外部とどのように通信するかを理解することです。</font></font><br>
<hr><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想スイッチング</font></font></h1><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンがあり、仮想インターフェースがある場合、明らかに、あるVMから別のVMにパケットを転送するという問題が発生します。</font><font style="vertical-align: inherit;">Linuxベースのハイパーバイザー（KVMなど）では、この問題はLinuxブリッジを使用して解決できますが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open vSwitch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（OVS）</font><font style="vertical-align: inherit;">プロジェクトは広く受け入れられてい</font><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OVSが広く普及し、多くのクラウドコンピューティングプラットフォーム（Openstackなど）および仮想化ソリューションで使用される事実上の基本的なパケットスイッチング方式となったコア機能がいくつかあります。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク状態の転送-ハイパーバイザー間でVMを移行する場合、ACL、QoS、L2 / L3転送テーブルなどを転送するタスクが発生します。</font><font style="vertical-align: inherit;">そしてOVSはそれを行うことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> カーネルとユーザー空間の両方でのパケット転送メカニズム（データパス）の実装</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CUPS（コントロール/ユーザープレーン分離）アーキテクチャ-パケット処理の機能を専用のチップセット（BroadcomやMarvellチップセットなど）に転送し、コントロールプレーンOVSを介して制御できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> リモートトラフィック制御方法のサポート-OpenFlowプロトコル（hi、SDN）。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見OVSアーキテクチャはかなり恐ろしく見えますが、それは一見しただけです。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OVSを使用するには、以下を理解する必要があります。</font></font><br>
<ul>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データパス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -パッケージはここで処理されます。</font><font style="vertical-align: inherit;">たとえは、鉄製のスイッチのスイッチファブリックです。</font><font style="vertical-align: inherit;">データパスには、パケットの受信、ヘッダーの処理、フローテーブル内の一致のマッチングが含まれます。これらは、データパスですでにプログラムされています。</font><font style="vertical-align: inherit;">OVSがカーネルで実行されている場合、カーネルモジュールとして実装されます。</font><font style="vertical-align: inherit;">OVSがユーザースペースで実行されている場合、これはユーザースペースLinuxでのプロセスです。</font></font></li>
<li> <b>vswitchd</b>  <b>ovsdb</b> —   user-space,       ,  ,  flow  datapath   .</li>
<li>       OVS — <b>ovs-vsctl, ovs-dpctl, ovs-ofctl, ovs-appctl</b>.  ,  ,    ovsdb  ,   flow   ,    .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>   .</li>
</ul><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシンのネットワークデバイスはOVSでどのように終了しますか？</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この問題を解決するには、オペレーティングシステムのユーザー空間にある仮想インターフェイスを、カーネルにあるデータパスOVSと何らかの形で相互接続する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxオペレーティングシステムでは、パケットは2つの特別なインターフェイスを介してカーネルプロセスとユーザー空間プロセスの間で転送されます。両方のインターフェイスを使用して、ユーザー空間プロセスからカーネルへ、またはその逆でパケットを転送するために、特殊ファイルからパケットを読み書きするために使用されます-ファイル記述子（FD）（これは、データパスOVSがカーネル内にある場合、仮想スイッチングのパフォーマンスが低下する理由の1つです-各パケットFDを通じて書き込み/読み取りが必要）</font></font><br>
<br>
<ul>
<li><b>TUN</b> (tunnel) — ,   L3    /  IP  / FD.</li>
<li> <b>TAP</b> (network tap) —   ,   tun  +     Ethernet-, ..    L2.</li>
</ul><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、仮想マシンがホストOSで実行されている場合、作成されたTAPインターフェイスを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip link</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドで確認できます。</font><font style="vertical-align: inherit;">これは、virtioの「応答」部分であり、カーネルホストOSで「可視」です。</font><font style="vertical-align: inherit;">また、TAPインターフェースは仮想マシンのvirtioインターフェースと同じMACアドレスを持っていることにも注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TAPインターフェースは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ovs-vsctlコマンド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してOVSに追加できます</font><i><font style="vertical-align: inherit;">。OVS</font></i><font style="vertical-align: inherit;">によってTAPインターフェースに切り替えられたパッケージは、ファイル記述子を介して仮想マシンに転送されます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシンを作成する実際の手順は異なる場合があります。</font><font style="vertical-align: inherit;">最初に、OVSブリッジを作成してから、このOVSに接続されたインターフェースを作成するように仮想マシンに指示することができます。</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、同じハイパーバイザーで実行されている2つ以上の仮想マシン間でパケットを転送できるようにする必要がある場合は、ovs-vsctlコマンドを使用してOVSブリッジを作成し、それにTAPインターフェイスを追加するだけで済みます。これに必要なチームは簡単にグーグル化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハイパーバイザーには複数のOVSブリッジが存在する場合があります。たとえば、これはOpenstack Neutronが機能する方法、または仮想マシンを異なる名前空間に配置してマルチテナンシーを実装できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、仮想マシンが別のOVSブリッジにある場合はどうでしょうか。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この問題を解決するために、別のツールがあります</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-vethペア</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Vethペアは、ケーブルで接続されたネットワークインターフェイスのペアとして表すことができます。1つのインターフェイスに「飛んで」、別のインターフェイスから「飛んで」いくものすべてです。</font><font style="vertical-align: inherit;">Vethペアは、複数のOVSブリッジまたはLinuxブリッジを相互に接続するために使用されます。</font><font style="vertical-align: inherit;">もう1つの重要な点は、vethペアの一部を異なる名前空間Linux OSに配置できることです。つまり、vethペアを使用して、ネットワークレベルで名前空間を互いに通信することもできます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化ツール-libvirt、virshなど</font></font></h1><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の章では、仮想化の理論的基礎を検討しました。この章では、KVMハイパーバイザーで仮想マシンを起動および変更するためにユーザーが直接使用できるツールについて説明します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンでのあらゆる種類の操作の90％をカバーする3つの主要コンポーネントについて詳しく見てみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libvirt</font></font></li>
<li> virsh CLI</li>
<li> virt-install</li>
</ul><br>
<br>
<blockquote>,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt.<br>
</blockquote><br>
<br>
<h2>libvirt</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libvirtは、ハイパーバイザーを管理するためのツールとドライバーのセットを開発する大規模なオープンソースプロジェクトです。 QEMU / KVMだけでなく、ESXi、LXCなどもサポートしています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その人気の主な理由は、XMLファイルのセットを介して対話するための構造化された直感的なインターフェースと、APIを介した自動化の可能性です。 libvirtはハイパーバイザーのすべての可能な機能を説明するのではなく</font><font style="vertical-align: inherit;">、プロジェクト参加者の観点から、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">便利な</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパーバイザー機能を使用するための便利なインターフェースを提供するだけであることに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、はい、libvirtは今日の仮想化の世界における事実上の標準です。ちょうど取る</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのリストを見て</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のlibvirtを使用しています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libvirtの良いニュースは、最も頻繁に使用されるすべてのホストOS（Ubuntu、CentOS、RHEL）に必要なパッケージがすべてプレインストールされているため、必要なパッケージをコンパイルしてlibvirtをコンパイルする必要がない可能性が高いことです。</font><font style="vertical-align: inherit;">最悪の場合、適切なバッチインストーラー（apt、yumなど）を使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期インストールおよび起動時に、libvirtはデフォルトでLinuxブリッジvirbr0とその最小構成を作成します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> たとえば、Ubuntu Serverをインストールすると、ifconfig Linux bridge virbr0コマンドの出力が表示されます-これはlibvirtdデーモンを実行した結果です</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このLinuxブリッジは物理インターフェースに接続されませんが、単一のハイパーバイザー内で仮想マシンを通信するために使用できます。</font><font style="vertical-align: inherit;">Libvirtは確実にOVSで使用できますが、そのためには、ユーザーは適切なOVSコマンドを使用してOVSブリッジを作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシン（コンピューティング、ネットワーク、ストレージ）の作成に必要な仮想リソースは、libvirtでオブジェクトとして表されます。</font><font style="vertical-align: inherit;">一連の異なるXMLファイルは、これらのオブジェクトを記述および作成するプロセスを担当します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプリケーションはlibvirtのドキュメントで詳しく説明されているため、仮想ネットワークと仮想ストレージを作成するプロセスを詳細に説明してもあまり意味がありません。</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーキング</font></font></a></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージ</font></font></a></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのPCIデバイスが接続された仮想マシン自体は、libvirtの用語ではドメインと呼ばれます。これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt内のオブジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">あり</font></a><font style="vertical-align: inherit;">、別のXMLファイルで記述されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このXMLファイルは、厳密には、RAM、プロセッサ、ネットワークデバイス、ディスクなど、すべての仮想リソースを備えた仮想マシンです。多くの場合、このXMLファイルはlibvirt XMLまたはダンプXMLと呼ばれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libvirt XMLのすべてのパラメーターを理解する人がいる可能性は低いですが、ドキュメントがある場合は必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、UbuntuデスクトップゲストOSのlibvirt XMLは非常に単純です（40〜50行）。</font><font style="vertical-align: inherit;">すべてのパフォーマンス最適化はlibvirt XML（NUMAトポロジー、CPUトポロジー、CPUピニングなど）でも記述されるため、ネットワーク機能にとってlibvirt XMLは非常に複雑になり、数百行を含む可能性があります。</font><font style="vertical-align: inherit;">ソフトウェアを仮想マシンとして出荷するネットワークデバイスの製造元は、libvirt XMLの例を推奨しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virsh CLI</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
virshユーティリティは、libvirtを管理するための「ネイティブ」コマンドラインです。</font><font style="vertical-align: inherit;">その主な目的は、XMLファイルとして記述されたlibvirtオブジェクトを管理することです。</font><font style="vertical-align: inherit;">典型的な例は、開始、停止、定義、破棄などです。</font><font style="vertical-align: inherit;">つまり、オブジェクトのライフサイクル-ライフサイクル管理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのvirshコマンドとフラグの説明は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirtの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントにもあります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virt-install</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libvirtとの対話に使用される別のユーティリティ。</font><font style="vertical-align: inherit;">主な利点の1つは、XML形式を処理する必要がなく、virsh-installで使用可能なフラグを使用できることです。</font><font style="vertical-align: inherit;">2番目の重要な点は、ウェブ上の多くの例と情報です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、使用するユーティリティに関係なく、最終的にはハイパーバイザーを制御するのはlibvirtであるため、そのアーキテクチャーとその動作原理を理解することが重要です。</font></font><br>
<hr><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、仮想マシンを操作するために必要な理論的な知識の最小セットを検討しました。</font><font style="vertical-align: inherit;">チームの実際的な例や結論は意図的には示しませんでした。そのような例はWebにいくつでも見つかるからであり、「段階的なガイド」を作成する仕事を自分で設定したわけではありません。</font><font style="vertical-align: inherit;">特定のトピックやテクノロジーに興味がある場合は、コメントを残して質問を書き込んでください。</font></font><br>
<hr><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QEMUのデバイスを理解します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM / SR-IOV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br>
<hr><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありがとう</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の同僚であり、仮想ネットワークの開発の専門家である</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Alexander Shalimov</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コメントと編集用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の同僚であり、仮想化の分野の専門家であるYevgeny Yakovlevからのコメントと修正。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467789/index.html">Java 13が登場しました。ZGCがメモリの共有を開始し、CDS自体がクラスを記憶し、その他の技術的な驚異</a></li>
<li><a href="../ja467791/index.html">Googleデータスタジオでのページスクロール分析</a></li>
<li><a href="../ja467793/index.html">一人のインターネット会社の退屈な技術スタック</a></li>
<li><a href="../ja467795/index.html">暗号通貨と政府規制に関するメモ</a></li>
<li><a href="../ja467797/index.html">「ために笑う」：「戦闘」アプリケーションのないソフトウェアツールが必要になる理由</a></li>
<li><a href="../ja467803/index.html">Python + matplotlibでのカスタム物理相互作用の初歩的なシミュレーション</a></li>
<li><a href="../ja467807/index.html">ロシアでの暗号通貨の売買：方法、合法化、リスク</a></li>
<li><a href="../ja467811/index.html">フェアチャイルドチャネルFのアーキテクチャとプログラミング</a></li>
<li><a href="../ja467813/index.html">FSTECの17次の変更のレビュー</a></li>
<li><a href="../ja467815/index.html">メディアは、「ロシアではIPアドレスが不足している」というパニックを引き起こしました。本当に？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>