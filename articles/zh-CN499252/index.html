<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙁 👨‍🎨 🧑🏼‍🤝‍🧑🏼 创建一个伪三维赛车游戏 🐐 🚏 🚄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="小时候，我很少去街机游戏厅，因为我真的不需要它们，因为我在家里玩过很棒的C64游戏……但是我一直有钱玩的三款街机游戏-《金刚》，《龙穴》和《 Outrun》 ... 
 
 ...我真的很喜欢Outrun-速度，山丘，棕榈树和音乐，甚至在C64的较弱版本上也是如此。
 
 
 因此，我决定尝试以Ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>创建一个伪三维赛车游戏</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499252/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/6e3/cff/d166e3cff9c2a3cefeb68f5c1ddc02d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小时候，我很少去街机游戏厅，因为我真的不需要它们，因为我在家里玩过很棒的C64游戏……但是我一直有钱玩的三款街机游戏-《金刚》，《龙穴》和《 Outrun》 ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...我真的很喜欢Outrun-速度，山丘，棕榈树和音乐，甚至在C64的较弱版本上也是如此。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/aee/56f/48eaee56f43d8a25e840c6ae13268db4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我决定尝试以Outrun，Pitstop或Pole位置的风格编写老式的伪三维赛车游戏。</font><font style="vertical-align: inherit;">我不打算组建一个完整而</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏，但是在我看来，重新审视这些游戏实现其花招的机制将很有趣。</font><font style="vertical-align: inherit;">曲线，山丘，小精灵和速度感…… </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以，这是我的“周末项目”，最终在周末花费了五六周</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/27b/d28/7ec27bd28630dbbaf7b81c87233c28ac.png"></div><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">玩个游戏</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可玩版本更像是技术演示，而不是真实游戏。</font><font style="vertical-align: inherit;">实际上，如果您想创建一个真实的伪三维种族，那么这将是您逐步成为游戏所需要的最小基础。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它没有打磨，有点丑陋，但是功能齐全。</font><font style="vertical-align: inherit;">我将通过四个简单的步骤向您展示如何自行实现它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你也可以玩</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接道路演示中</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线演示中</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">与山丘</font></a><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示中</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成的版本中</font></font></a></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于表现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这款游戏的性能</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖于机器/浏览器。</font><font style="vertical-align: inherit;">在现代浏览器中，它运行良好，尤其是在具有画布GPU加速的浏览器中，但是不良的图形驱动程序可能导致其冻结。</font><font style="vertical-align: inherit;">在游戏中，您可以更改渲染分辨率和渲染距离。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于代码结构</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
碰巧该项目是用Javascript实现的（由于原型设计的简单性），但它并不旨在演示Javascript的技术或推荐的技术。</font><font style="vertical-align: inherit;">实际上，为了便于理解，每个示例的Javascript直接嵌入到HTML页面中（恐怖！）；</font><font style="vertical-align: inherit;">更糟糕的是，它使用全局变量和函数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我要创建一个真实的游戏，那么代码会更加结构化和简化，但是由于这是赛车游戏的技术演示，因此我决定坚持使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1部分。直路。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么，我们如何开始创建伪三维赛车游戏呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，我们需要</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复三角法</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回顾3D投影的基础知识</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建游戏循环</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载精灵图片</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建立道路几何</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染背景</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染路</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染车</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现对机器控制的键盘支持</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在开始之前，让我们阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lou的Pseudo 3d Page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habré]-（我可以找到）有关如何创建psevdotrohmernuyu赛车游戏的唯一信息源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
阅读完娄的文章？</font><font style="vertical-align: inherit;">精细！</font><font style="vertical-align: inherit;">我们将使用3d投影片段技术创建他的逼真的丘陵的变形。</font><font style="vertical-align: inherit;">我们将在接下来的四个部分中逐步进行此操作。</font><font style="vertical-align: inherit;">但是我们将从版本v1开始，通过将其投影到HTML5 canvas元素上来创建非常简单的直线几何。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到</font><font style="vertical-align: inherit;">。</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一点三角学</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始实施之前，让我们使用三角学的基础知识来记住如何将3D世界中的点投影到2D屏幕上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最简单的情况下，如果您不触摸向量和矩阵，则</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相似的三角形</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定律将用于3D投影</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用以下符号：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =相机高度</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =相机到屏幕的距离</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =相机到汽车的距离</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =屏幕</font><strong><font style="vertical-align: inherit;">y</font></strong><font style="vertical-align: inherit;">坐标</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们可以使用相似三角形的定律来计算 </font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = h * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如图所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还可以在顶视图中而不是侧视图中绘制相似的图，并导出相似的公式来计算</font><font style="vertical-align: inherit;">屏幕</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x = w * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =道路宽度的一半（从摄像头到道路边缘）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，对于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们按比例缩放</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d / z</font></font></strong></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标系</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以图表的形式，它看起来很漂亮，很简单，但是当您开始编码时，可能会有点困惑，因为我们选择了任意名称，并且不清楚我们指示3D世界的坐标以及2D屏幕的坐标是什么。</font><font style="vertical-align: inherit;">我们还假设相机位于世界起源的中心，尽管实际上它将跟随机器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您采取更正式的方法，那么我们需要执行：</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从世界坐标到屏幕坐标的</font><strong><font style="vertical-align: inherit;">转换</font></strong></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机坐标</font><strong><font style="vertical-align: inherit;">投影</font></strong><font style="vertical-align: inherit;">到标准化的投影平面上</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影坐标</font><strong><font style="vertical-align: inherit;">缩放为</font></strong><font style="vertical-align: inherit;">物理屏幕的坐标（在我们的例子中是画布）</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/5d2/30f/b595d230f4f45b9b0c9409266d5804d8.png"></div><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：在当前的3d系统中</font><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋转</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阶段是在阶段1和2之间执行的</font><font style="vertical-align: inherit;">，但是由于我们将模拟曲线，因此不需要旋转。</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
形式投影方程可以表示为：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换方程（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平移</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）点是相对于腔室计算的</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影方程（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">project</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）是上述“相似三角形定律”的变体。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缩放方程式（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）考虑到以下两者之间的差异：</font></font><br>
<ul>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中0,0在中心，y轴在上，并且</font></font></li>
<li><em></em>,  0,0     ,   y  :</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/050/aad/11f050aadea0d1c537baefcb06f7c2f0.png"></div><br>
<blockquote><em>:   3d-         <code>Vector</code>  <code>Matrix</code>     3d-,      ,      WebGL (  )…       .           Outrun.</em></blockquote><br>
<h2>  </h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/27b/1bd/3b727b1bdb285d874bd659c29db13522.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
难题的最后一部分将是一种计算</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d的方法</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -相机到投影平面的距离。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与其仅写一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的硬设置值，</font><strong><font style="vertical-align: inherit;">不如</font></strong><font style="vertical-align: inherit;">从所需的垂直视场中计算出来。</font><font style="vertical-align: inherit;">因此，如有必要，我们将能够“缩放”摄像机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们假设要投影到一个规范化的投影平面上，其坐标范围在-1到+1之间，则</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以如下计算：</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 /棕褐色（fov / 2）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将fov定义</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为变量中的一个，我们可以调整范围以微调渲染算法。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript代码结构</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文的开头，我已经说过该代码并不完全符合编写Javascript的准则-它是一个“快速而肮脏的”演示，带有简单的全局变量和函数。</font><font style="vertical-align: inherit;">但是，由于我要创建四个单独的版本（直线，曲线，坡度和子画面），因此我将</font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在以下模块中</font><font style="vertical-align: inherit;">存储一些可重用的方法</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一些次要的DOM帮助器功能。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTIL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -通用工具，主要是辅助数学函数。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -常规游戏支持功能，例如图像下载器和游戏循环。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -画布上的助手渲染功能。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将</font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅从与游戏本身相关的</font><font style="vertical-align: inherit;">方法中详细说明方法</font><font style="vertical-align: inherit;">，而这些方法不仅是辅助数学或DOM函数。</font><font style="vertical-align: inherit;">希望从名称和上下文中可以清楚知道方法应该做什么。</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像往常一样，源代码在最终文档中。</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单的游戏循环</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在渲染之前，我们需要一个游戏循环。</font><font style="vertical-align: inherit;">如果您阅读过我以前有关游戏的任何文章（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乒乓球</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突破</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">俄罗斯方块</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蛇</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巨石</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），那么您已经看到了我最喜欢的具有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固定时间步长的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏周期的示例</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不会深入探讨细节，只是简单地重用以前游戏中的部分代码，以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的固定时间步长创建游戏循环</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原理是我的四个示例中的每个示例都可以调用</font></font><code>Game.run(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用其自己的版本</font></font><br>
<br>
<ul>
<li><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -以固定的时间步更新游戏世界。</font></font></li>
<li><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当浏览器允许时更新游戏世界。</font></font></li>
</ul><br>
<pre><code class="javascript hljs">run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{<font></font>
<font></font>
  Game.loadImages(options.images, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> update = options.update,    <span class="hljs-comment">// method to update game logic is provided by caller</span>
        render = options.render,    <span class="hljs-comment">// method to render the game is provided by caller</span>
        step   = options.step,      <span class="hljs-comment">// fixed frame step (1/fps) is specified by caller</span>
        now    = <span class="hljs-literal">null</span>,<font></font>
        last   = Util.timestamp(),<font></font>
        dt     = <span class="hljs-number">0</span>,<font></font>
        gdt    = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">frame</span>(<span class="hljs-params"></span>) </span>{<font></font>
      now = Util.timestamp();<font></font>
      dt  = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (now - last) / <span class="hljs-number">1000</span>); <span class="hljs-comment">// using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab</span><font></font>
      gdt = gdt + dt;<font></font>
      <span class="hljs-keyword">while</span> (gdt &gt; step) {<font></font>
        gdt = gdt - step;<font></font>
        update(step);<font></font>
      }<font></font>
      render();<font></font>
      last = now;<font></font>
      requestAnimationFrame(frame);<font></font>
    }<font></font>
    frame(); <span class="hljs-comment">// lets get this party started</span><font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，这是我以前的画布游戏的构想的翻版，因此，如果您不了解游戏循环的工作原理，请返回上一篇文章。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图片和精灵</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在游戏周期开始之前，我们加载两个单独的Spritesheets（精灵表）：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -天空，丘陵和树木的三个视差层</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprites-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器Sprites（以及要添加到最终版本中的树木和广告牌）</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用一个小的任务Rake和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruby Gem sprite-factory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成了精灵表</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此任务将生成组合的Sprite表以及坐标x，y，w，h，这些坐标将存储在常量</font></font><code>BACKGROUND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和中</font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：我使用Inkscape创建了背景，大多数精灵是</font><font style="vertical-align: inherit;">从旧的Outrun版本获取的Genesis </font><font style="vertical-align: inherit;">图形</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并用作训练示例。</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏变量</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了背景和精灵的图像外，我们还需要几个游戏变量，即：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> fps           = <span class="hljs-number">60</span>;                      <span class="hljs-comment">// how many 'update' frames per second</span>
<span class="hljs-keyword">var</span> step          = <span class="hljs-number">1</span>/fps;                   <span class="hljs-comment">// how long is each frame (in seconds)</span>
<span class="hljs-keyword">var</span> width         = <span class="hljs-number">1024</span>;                    <span class="hljs-comment">// logical canvas width</span>
<span class="hljs-keyword">var</span> height        = <span class="hljs-number">768</span>;                     <span class="hljs-comment">// logical canvas height</span>
<span class="hljs-keyword">var</span> segments      = [];                      <span class="hljs-comment">// array of road segments</span>
<span class="hljs-keyword">var</span> canvas        = Dom.get(<span class="hljs-string">'canvas'</span>);       <span class="hljs-comment">// our canvas...</span>
<span class="hljs-keyword">var</span> ctx           = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// ...and its drawing context</span>
<span class="hljs-keyword">var</span> background    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our background image (loaded below)</span>
<span class="hljs-keyword">var</span> sprites       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our spritesheet (loaded below)</span>
<span class="hljs-keyword">var</span> resolution    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// scaling factor to provide resolution independence (computed)</span>
<span class="hljs-keyword">var</span> roadWidth     = <span class="hljs-number">2000</span>;                    <span class="hljs-comment">// actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth</span>
<span class="hljs-keyword">var</span> segmentLength = <span class="hljs-number">200</span>;                     <span class="hljs-comment">// length of a single segment</span>
<span class="hljs-keyword">var</span> rumbleLength  = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of segments per red/white rumble strip</span>
<span class="hljs-keyword">var</span> trackLength   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z length of entire track (computed)</span>
<span class="hljs-keyword">var</span> lanes         = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of lanes</span>
<span class="hljs-keyword">var</span> fieldOfView   = <span class="hljs-number">100</span>;                     <span class="hljs-comment">// angle (degrees) for field of view</span>
<span class="hljs-keyword">var</span> cameraHeight  = <span class="hljs-number">1000</span>;                    <span class="hljs-comment">// z height of camera</span>
<span class="hljs-keyword">var</span> cameraDepth   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z distance camera is from screen (computed)</span>
<span class="hljs-keyword">var</span> drawDistance  = <span class="hljs-number">300</span>;                     <span class="hljs-comment">// number of segments to draw</span>
<span class="hljs-keyword">var</span> playerX       = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// player x offset from center of road (-1 to 1 to stay independent of roadWidth)</span>
<span class="hljs-keyword">var</span> playerZ       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// player relative z distance from camera (computed)</span>
<span class="hljs-keyword">var</span> fogDensity    = <span class="hljs-number">5</span>;                       <span class="hljs-comment">// exponential fog density</span>
<span class="hljs-keyword">var</span> position      = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current camera Z position (add playerZ to get player's absolute Z position)</span>
<span class="hljs-keyword">var</span> speed         = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current speed</span>
<span class="hljs-keyword">var</span> maxSpeed      = segmentLength/step;      <span class="hljs-comment">// top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)</span>
<span class="hljs-keyword">var</span> accel         =  maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// acceleration rate - tuned until it 'felt' right</span>
<span class="hljs-keyword">var</span> breaking      = -maxSpeed;               <span class="hljs-comment">// deceleration rate when braking</span>
<span class="hljs-keyword">var</span> decel         = -maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// 'natural' deceleration rate when neither accelerating, nor braking</span>
<span class="hljs-keyword">var</span> offRoadDecel  = -maxSpeed/<span class="hljs-number">2</span>;             <span class="hljs-comment">// off road deceleration is somewhere in between</span>
<span class="hljs-keyword">var</span> offRoadLimit  =  maxSpeed/<span class="hljs-number">4</span>;             <span class="hljs-comment">// limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中一些可以使用UI控件自定义，以在程序执行期间更改关键值，以便您可以看到它们如何影响道路的渲染。</font><font style="vertical-align: inherit;">其他方法是根据该方法从自定义UI值重新计算的</font></font><code>reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们管理法拉利</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们为进行键绑定</font></font><code>Game.run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它提供了简单的键盘输入，可以设置或重置报告玩家当前操作的变量：</font></font><br>
<br>
<pre><code class="javascript hljs">Game.run({<font></font>
  ...<font></font>
  keys: [<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">false</span>; } }<font></font>
  ],<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
玩家的状态由以下变量控制：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当前速度。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轨道上的当前Z位置。</font><font style="vertical-align: inherit;">请注意，这是摄影机位置，而不是法拉利。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerX-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">玩家在道路X上的当前位置。</font><font style="vertical-align: inherit;">标准化为-1到+1，以不依赖于实际值</font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些变量在method内部设置，该方法</font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行以下操作：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据当前</font><font style="vertical-align: inherit;">更新</font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在您按向左或向右键时</font><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果按向上键</font><font style="vertical-align: inherit;">增加</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果按下向下键，则</font><font style="vertical-align: inherit;">减小</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果未按下向上和向下键，则</font><font style="vertical-align: inherit;">减小</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低</font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关闭位于马路边上，并在草地上。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在直路的情况下，该方法</font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常简单明了：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{<font></font>
<font></font>
  position = Util.increase(position, dt * speed, trackLength);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> dx = dt * <span class="hljs-number">2</span> * (speed/maxSpeed); <span class="hljs-comment">// at top speed, should be able to cross from left to right (-1 to 1) in 1 second</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyLeft)<font></font>
    playerX = playerX - dx;<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyRight)<font></font>
    playerX = playerX + dx;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyFaster)<font></font>
    speed = Util.accelerate(speed, accel, dt);<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keySlower)<font></font>
    speed = Util.accelerate(speed, breaking, dt);<font></font>
  <span class="hljs-keyword">else</span><font></font>
    speed = Util.accelerate(speed, decel, dt);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) &amp;&amp; (speed &gt; offRoadLimit))<font></font>
    speed = Util.accelerate(speed, offRoadDecel, dt);<font></font>
<font></font>
  playerX = Util.limit(playerX, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// dont ever let player go too far out of bounds</span>
  speed   = Util.limit(speed, <span class="hljs-number">0</span>, maxSpeed); <span class="hljs-comment">// or exceed maxSpeed</span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不用担心，当在最终版本中添加精灵和碰撞识别时，它将变得更加困难。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路几何</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在渲染游戏世界之前，我们需要</font></font><code>segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在方法中</font><font style="vertical-align: inherit;">构建</font><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">的数组</font></font><code>resetRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终，这些路段中的每个路段都将从其世界坐标投影出来，以使其在屏幕坐标中变为2d多边形。</font><font style="vertical-align: inherit;">对于每个线段，我们存储两个点，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最靠近摄影机</font><font style="vertical-align: inherit;">的边缘的中心，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最远离摄影机的边缘的中心。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53a/fa4/076/53afa40768a00b49833703b1457a6941.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
严格来说，</font><font style="vertical-align: inherit;">每个段的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2与上</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个段的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">，但是在我看来，将它们存储为单独的点并分别转换每个段会更容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们保持分开</font></font><code>rumbleLength</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是因为我们可以拥有美丽的详细曲线和丘陵，但同时具有水平条纹。如果随后的每个片段具有不同的颜色，则将产生不良的频闪效果。因此，我们希望有许多小段，但将它们分组在一起以形成单独的水平条纹。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetRoad</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments = [];<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; <span class="hljs-number">500</span> ; n++) { <span class="hljs-comment">// arbitrary road length</span><font></font>
    segments.push({<font></font>
       <span class="hljs-attr">index</span>: n,
       <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
    });<font></font>
  }<font></font>
<font></font>
  trackLength = segments.length * segmentLength;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们</font><font style="vertical-align: inherit;">仅使用世界坐标</font><strong><font style="vertical-align: inherit;">z</font></strong><font style="vertical-align: inherit;">初始化</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为我们只需要直行道路。</font><strong><font style="vertical-align: inherit;">y</font></strong><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">将始终为0，</font><strong><font style="vertical-align: inherit;">x</font></strong><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">将始终取决于比例值</font><font style="vertical-align: inherit;">。稍后，当我们添加曲线和山丘时，这部分将发生变化。</font><font style="vertical-align: inherit;">
我们还将设置空对象，以将这些点的表示形式存储在相机和屏幕上，以免在每个对象中创建一堆临时对象</font><font style="vertical-align: inherit;">。为了最大程度地减少垃圾回收，我们必须避免在游戏循环内分配对象。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><code>+/- roadWidth</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>render</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当汽车到达路的尽头时，我们只需回到循环的起点即可。</font><font style="vertical-align: inherit;">为了简化此过程，我们将创建一种方法来找到任意Z值的线段，即使它超出了道路的长度：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSegment</span>(<span class="hljs-params">z</span>) </span>{
  <span class="hljs-keyword">return</span> segments[<span class="hljs-built_in">Math</span>.floor(z/segmentLength) % segments.length];<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景渲染</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始于渲染背景图像。</font><font style="vertical-align: inherit;">在下面的部分中，我们将添加曲线和山丘，我们将需要背景来执行视差滚动，因此我们现在将开始朝这个方向移动，将背景渲染为三个单独的层：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<font></font>
<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.SKY);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.HILLS);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.TREES);<font></font>
<font></font>
  ...</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路渲染</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，render函数遍历所有片段，</font><font style="vertical-align: inherit;">并将</font><font style="vertical-align: inherit;">每个片段的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从世界坐标投影到屏幕坐标，并在必要时修剪该片段，否则进行渲染：</font></font><br>
<br>
<pre><code class="javascript hljs">  <span class="hljs-keyword">var</span> baseSegment = findSegment(position);
  <span class="hljs-keyword">var</span> maxy        = height;
  <span class="hljs-keyword">var</span> n, segment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
    segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
    Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
    Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
        (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
      <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    Render.segment(ctx, width, lanes,<font></font>
                   segment.p1.screen.x,<font></font>
                   segment.p1.screen.y,<font></font>
                   segment.p1.screen.w,<font></font>
                   segment.p2.screen.x,<font></font>
                   segment.p2.screen.y,<font></font>
                   segment.p2.screen.w,<font></font>
                   segment.color);<font></font>
<font></font>
    maxy = segment.p2.screen.y;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面，我们已经看到了投影点所需的计算； javascript版本将转换，投影和缩放合并为一种方法：</font></font><br>
<br>
<pre><code class="javascript hljs">project: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth</span>) </span>{<font></font>
  p.camera.x     = (p.world.x || <span class="hljs-number">0</span>) - cameraX;<font></font>
  p.camera.y     = (p.world.y || <span class="hljs-number">0</span>) - cameraY;<font></font>
  p.camera.z     = (p.world.z || <span class="hljs-number">0</span>) - cameraZ;<font></font>
  p.screen.scale = cameraDepth/p.camera.z;<font></font>
  p.screen.x     = <span class="hljs-built_in">Math</span>.round((width/<span class="hljs-number">2</span>)  + (p.screen.scale * p.camera.x  * width/<span class="hljs-number">2</span>));<font></font>
  p.screen.y     = <span class="hljs-built_in">Math</span>.round((height/<span class="hljs-number">2</span>) - (p.screen.scale * p.camera.y  * height/<span class="hljs-number">2</span>));<font></font>
  p.screen.w     = <span class="hljs-built_in">Math</span>.round(             (p.screen.scale * roadWidth   * width/<span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了</font><font style="vertical-align: inherit;">为每个点</font><strong><font style="vertical-align: inherit;">p1</font></strong><font style="vertical-align: inherit;">和</font><strong><font style="vertical-align: inherit;">p2</font></strong><font style="vertical-align: inherit;">计算屏幕</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y之外</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">，</font></strong><font style="vertical-align: inherit;">我们使用相同的投影计算来计算段的投影宽度（</font><strong><font style="vertical-align: inherit;">w</font></strong><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">
有了</font><font style="vertical-align: inherit;">点</font><strong><font style="vertical-align: inherit;">p1</font></strong><font style="vertical-align: inherit;">和</font><strong><font style="vertical-align: inherit;">p2</font></strong><font style="vertical-align: inherit;">的屏幕</font><strong><font style="vertical-align: inherit;">x</font></strong><font style="vertical-align: inherit;">和</font><strong><font style="vertical-align: inherit;">y</font></strong><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">，以及道路</font><strong><font style="vertical-align: inherit;">w</font></strong><font style="vertical-align: inherit;">的投影宽度</font><font style="vertical-align: inherit;">，我们可以使用辅助功能很容易地借助辅助功能来计算</font><font style="vertical-align: inherit;">渲染草地，道路，水平条纹和分界线所需的所有多边形</font><em><font style="vertical-align: inherit;">（请参见。</font></em><em><font style="vertical-align: inherit;">）</font></em><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><code>Render.segment</code><font style="vertical-align: inherit;"></font><code>Render.polygon</code> <em><font style="vertical-align: inherit;"></font><code>common.js</code><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汽车渲染</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，该方法需要的最后一件事</font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Ferrari渲染：</font></font><br>
<br>
<pre><code class="javascript hljs">  Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,<font></font>
                cameraDepth/playerZ,<font></font>
                width/<span class="hljs-number">2</span>,<font></font>
                height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此方法称为</font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是</font></font><code>car</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为在游戏的最终版本中，路上还会有其他赛车，并且我们希望将Ferrari玩家与其他赛车分开。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
helper函数</font></font><code>Render.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用被称为canvas的方法</font></font><code>drawImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来渲染精灵，之前已使用与之前相同的投影比例对其进行了缩放：</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是从机器到摄像机的相对距离，存储在变量</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerZ中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，该函数会高速晃动汽车，从而使比例方程式增加一些随机性，具体取决于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度/ maxSpeed</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我们得到的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/dfd/3e8/845dfd3e88ef0a22b2c9fd021140ff3b.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们仅创建了一条直线道路的系统就做了很多工作。</font><font style="vertical-align: inherit;">我们加了</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用辅助模块</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dom</font></font></strong></li>
<li><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">UTIL</font></strong><font style="vertical-align: inherit;">一般数学模块</font></font><strong><font style="vertical-align: inherit;"></font></strong></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用画布助手模块</font><font style="vertical-align: inherit;">...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">......包括</font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>Render.polygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Render.sprite</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定距游戏周期</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图片下载器</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键盘处理器</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视差背景</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">雪碧板与汽车，树木和广告牌</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路的基本几何形状</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器的控制</font><font style="vertical-align: inherit;">方法</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染背景，道路和用车</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>&lt;audio&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有赛车音乐的</font><font style="vertical-align: inherit;">HTML5标签</font><font style="vertical-align: inherit;">（隐藏奖金！）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
……为我们的进一步发展奠定了良好的基础。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2部分。曲线。</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一部分中，我们将更详细地解释曲线的工作方式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上一部分中，我们以线段数组的形式编译了道路的几何形状，每个线段都具有相对于摄影机进行转换然后投影到屏幕上的世界坐标。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们只需要</font><font style="vertical-align: inherit;">每个点</font><font style="vertical-align: inherit;">的世界坐标</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为在直行道路上</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都等于零。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/551/359/c78551359ef7c11e4af48b4285d61842.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要创建功能齐全的3d系统，则可以通过计算</font><font style="vertical-align: inherit;">上面显示的多边形</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条纹</font><font style="vertical-align: inherit;">来实现曲线</font><font style="vertical-align: inherit;">。但是，这种类型的几何形状将很难计算，因此有必要在投影方程式中添加3d旋转平台</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...如果采用这种方式，最好使用WebGL或其类似物，但是该项目没有其他任务要完成。我们只想使用老式的伪三维技巧来模拟曲线。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，您可能会惊讶地发现，我们根本不会计算</font><font style="vertical-align: inherit;">路段</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lu的建议</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“要弯曲道路，只需更改曲线形状的中心线的位置...从屏幕的底部开始，道路中心向左或向右的偏移量会逐渐增加</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><em><font style="vertical-align: inherit;">”</font></em></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的例子中，中心线是</font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递给投影计算的值。</font><font style="vertical-align: inherit;">这意味着，当我们执行</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路的每个路段时，可以通过将值</font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逐渐增加</font><font style="vertical-align: inherit;">来移动来模拟曲线</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要知道要移动多少，我们需要在每个段中存储一个值</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该值指示应将片段从相机的中心线偏移多少。</font><font style="vertical-align: inherit;">她将会是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左转曲线为负</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线右转时为正</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更少的平滑曲线</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多用于锐利曲线</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自身的价值是任意选择的; </font><font style="vertical-align: inherit;">通过反复试验，我们可以找到曲线似乎是``正确的''的好值：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> }, <span class="hljs-comment">// num segments</span>
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了为曲线选择合适的值外，我们还需要避免在直线变成曲线时（或反之亦然）过渡中的任何间隙。</font><font style="vertical-align: inherit;">这可以通过</font><font style="vertical-align: inherit;">在进入和退出曲线时</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来实现</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将通过</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用传统的平滑函数</font><font style="vertical-align: inherit;">逐渐增加（或减小）</font><font style="vertical-align: inherit;">每个分段</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">，直到达到所需值，</font><font style="vertical-align: inherit;">来做到这一点</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs">easeIn:    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*<span class="hljs-built_in">Math</span>.pow(percent,<span class="hljs-number">2</span>);                           },
<span class="hljs-attr">easeOut</span>:   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span>-percent,<span class="hljs-number">2</span>));                     },
<span class="hljs-attr">easeInOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*((-<span class="hljs-built_in">Math</span>.cos(percent*<span class="hljs-built_in">Math</span>.PI)/<span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>);        },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，现在考虑到向几何图形添加一个线段的功能...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以创建一种用于平滑进入，查找和平滑离开弯道的方法：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve</span>) </span>{
  <span class="hljs-keyword">var</span> n;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve);<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...，然后您可以强加其他几何形状，例如S形曲线：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSCurves</span>(<span class="hljs-params"></span>) </span>{<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对update（）方法的更改</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法唯一需要做的改变就是</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当机器沿曲线移动时施加某种离心力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们设置了一个任意因子，可以根据自己的喜好进行调整。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> centrifugal = <span class="hljs-number">0.3</span>;   <span class="hljs-comment">// centrifugal force multiplier when going around curves</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们将</font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据其当前速度，曲线值和离心力乘数来</font><font style="vertical-align: inherit;">更新位置</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs">playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线渲染</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面我们说过，您可以通过</font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个路段</font><font style="vertical-align: inherit;">执行期间</font><font style="vertical-align: inherit;">移动</font><font style="vertical-align: inherit;">投影计算中使用</font><font style="vertical-align: inherit;">的值来渲染模拟曲线</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我们将存储驱动变量</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（每个分段增加一个值</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）以及变量</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（将</font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用作投影计算中使用</font><font style="vertical-align: inherit;">的值的偏移量）</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要实现曲线，我们需要以下内容：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">每个线段</font><font style="vertical-align: inherit;">的投影</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">每个线段</font><font style="vertical-align: inherit;">的投影</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由下一个段</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DX</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，为了避免在跨越线段边界时出现过渡撕裂，我们必须</font><font style="vertical-align: inherit;">使用当前基本线段曲线的插值</font><font style="vertical-align: inherit;">对</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx进行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更改方法</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如下所示：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> baseSegment = findSegment(position);
<span class="hljs-keyword">var</span> basePercent = Util.percentRemaining(position, segmentLength);
<span class="hljs-keyword">var</span> dx = - (baseSegment.curve * basePercent);
<span class="hljs-keyword">var</span> x  = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  Util.project(segment.p1, (playerX * roadWidth) - x,      cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
  Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
<font></font>
  x  = x + dx;<font></font>
  dx = dx + segment.curve;<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视差滚动背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们需要滚动视差背景图层，存储每个图层的偏移量...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> skySpeed    = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// background sky layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> hillSpeed   = <span class="hljs-number">0.002</span>; <span class="hljs-comment">// background hill layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> treeSpeed   = <span class="hljs-number">0.003</span>; <span class="hljs-comment">// background tree layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> skyOffset   = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current sky scroll offset</span>
<span class="hljs-keyword">var</span> hillOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current hill scroll offset</span>
<span class="hljs-keyword">var</span> treeOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current tree scroll offset</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...并</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据当前播放器片段的曲线值及其速度</font><font style="vertical-align: inherit;">在一段时间内增加它</font><font style="vertical-align: inherit;">...</font></font><br>
<br>
<pre><code class="javascript hljs">skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...，然后在做</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景图层</font><font style="vertical-align: inherit;">时使用此偏移量</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在这里我们得到了伪伪三维曲线：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们添加的代码的主要部分是使用相应的值构建道路的几何形状</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。意识到这一点，在这段时间内增加离心力</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要容易得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
曲线渲染仅需几行代码即可完成，但可能很难理解（并描述）这里到底发生了什么。有许多种模拟曲线的方法，当将它们实施到死胡同时，很容易徘徊。摆脱外部任务并尝试“正确地”做所有事情甚至更容易。在意识到这一点之前，您将开始创建一个具有矩阵，旋转和真实3d几何形状的功能齐全的3d系统……正如我所说，这不是我们的任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我写这篇文章时，我确信在曲线的实现中肯定存在问题。</font><font style="vertical-align: inherit;">为了使算法可视化，我不明白为什么我需要</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驱动器的两个值</font><font style="vertical-align: inherit;">而不是一个...如果我不能完全解释某些内容，那么某处出现了问题</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...但是项目时间</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“周末”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快要到期了，坦白说，曲线对我来说似乎很漂亮，最后，这是最重要的。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499240/index.html">通过刺向星星，或在天上事务中进行数据分析</a></li>
<li><a href="../zh-CN499242/index.html">研究人员通过桌子上的振动从台式PC传输数据</a></li>
<li><a href="../zh-CN499244/index.html">协同组织。第二部分</a></li>
<li><a href="../zh-CN499246/index.html">物流功能作为行业法则的研究</a></li>
<li><a href="../zh-CN499248/index.html">我们如何认识个人防护装备</a></li>
<li><a href="../zh-CN499254/index.html">PyConRu 2020计划委员会成员回答有关Python的问题：最新外观和一些parseltang</a></li>
<li><a href="../zh-CN499262/index.html">个体经营的SMZhack的最终在线黑客马拉松：将吸引人们的项目</a></li>
<li><a href="../zh-CN499268/index.html">空间意识：Hololens眼镜可以做什么？</a></li>
<li><a href="../zh-CN499272/index.html">焊接组件0201。紧张，请移开屏幕</a></li>
<li><a href="../zh-CN499274/index.html">我们拆解了新的胶囊。我们知道有多少个麦克风及其工作原理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>