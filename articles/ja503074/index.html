<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏽 🤚🏽 🐫 Flutterのプロバイダーパッケージの詳細 💆🏾 🧘🏻 👩🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！
 
 中期計画には、Flutterブックのリリースが含まれます。トピックとしてのダートの言語については、まだより慎重な立場を取っているため、この記事の結果に従って関連性を評価していきます。それはプロバイダーパッケージに焦点を当て、したがってFlutterの状態管理に焦点を合わせ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flutterのプロバイダーパッケージの詳細</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/503074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中期計画には、Flutterブックのリリースが含まれます。トピックとしてのダートの言語については、まだより慎重な立場を取っているため、この記事の結果に従って関連性を評価していきます。それは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロバイダー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージに焦点を当て</font><font style="vertical-align: inherit;">、したがってFlutterの状態管理に</font><font style="vertical-align: inherit;">焦点を合わせ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Providerは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remy Rusle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">作成</font></a><font style="vertical-align: inherit;">され、GoogleおよびFlutterコミュニティによって採用され</font><font style="vertical-align: inherit;">た状態管理パッケージです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、状態管理とは何ですか？</font><font style="vertical-align: inherit;">まず、条件とは何ですか？</font><font style="vertical-align: inherit;">状態はアプリケーションのUIを表すための単なるデータであることを思い出させてください。</font><font style="vertical-align: inherit;">状態管理は、このデータの作成、アクセス、処理、および廃棄のアプローチです。</font><font style="vertical-align: inherit;">プロバイダーパッケージをよりよく理解するために、Flutterでの状態管理の履歴の概要を簡単に説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. StatefulWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatelessWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、データがある場合にのみ表示されるシンプルなUIコンポーネントです。</font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「記憶」</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ません。必要に応じて作成および破棄されます。 Flutterには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatefulWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もあります。</font><font style="vertical-align: inherit;">これにはメモリがあり、そのおかげで長命の衛星である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトがあります</font><font style="vertical-align: inherit;">。このクラスにはmethodが</font></font><code>setState()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、呼び出されると、状態を再構築して新しいフォームに表示するウィジェットが起動されます。これは、箱から出して提供されるFlutter状態管理の最も単純な形式です。次に、ボタンが最後に押された時刻を常に表示する例を示します。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyWidget</span>&gt; </span>{
  <span class="hljs-built_in">DateTime</span> _time = <span class="hljs-built_in">DateTime</span>.now();  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(_time.toString()),<font></font>
      onPressed: () {<font></font>
        setState(() =&gt; _time = <span class="hljs-built_in">DateTime</span>.now());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、このアプローチの問題は何ですか？</font><font style="vertical-align: inherit;">アプリケーションのグローバル状態がルートに保存されているとします</font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">UIのさまざまな部分での使用を目的としたデータが含まれています。</font><font style="vertical-align: inherit;">このデータは共有され、パラメーターの形で各子ウィジェットに渡されます。</font><font style="vertical-align: inherit;">このデータを変更する予定のイベントは、コールバックの形式でポップアップします。</font><font style="vertical-align: inherit;">したがって、すべての中間ウィジェットを通じて、多くのパラメーターとコールバックが送信され、すぐに混乱を招く可能性があります。</font><font style="vertical-align: inherit;">さらに悪いことに、前述のルートを更新すると、ウィジェットツリー全体が再構築されることになり、非効率的です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. InheritedWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InheritedWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、子孫が直接リンクなしでウィジェットにアクセスできる特別なウィジェットです。</font><font style="vertical-align: inherit;">をオンにするだけ</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、消費ウィジェットは、先祖ウィジェットの再構築時に発生する自動再構築に登録できます。</font><font style="vertical-align: inherit;">この手法により、UI更新をより効率的に整理できます。</font><font style="vertical-align: inherit;">状態の小さな変化に応じてアプリケーションの巨大な部分を再構築する代わりに、再構築する必要がある特定のウィジェットのみを選択的に選択できます。</font><font style="vertical-align: inherit;">または</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">した</font><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">は、すでに</font><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">してい</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">確かに、状態を保持する独自のInheritedWidgetを実装した可能性は低くなります。</font><font style="vertical-align: inherit;">実際には、それらを正しく実装することは容易ではありません。</font></font><code>MediaQuery.of(context)</code><font style="vertical-align: inherit;"></font><code>Theme.of(context)</code><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ScopedModel</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Brian Eganによって2017年に作成されたパッケージで、</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションの状態を</font><font style="vertical-align: inherit;">簡単</font><font style="vertical-align: inherit;">に格納できます。</font><font style="vertical-align: inherit;">まず、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から継承する状態オブジェクトを作成し、</font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティが変更されたときに</font><font style="vertical-align: inherit;">それを呼び出す</font><font style="vertical-align: inherit;">必要があります。</font><font style="vertical-align: inherit;">この状況は</font><font style="vertical-align: inherit;">、Java </font><font style="vertical-align: inherit;">での</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyChangeListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェースの実装を思い起こさせ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span> </span>{<font></font>
  String _foo;  String get foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> set <span class="hljs-title">foo</span><span class="hljs-params">(String value)</span> </span>{<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態オブジェクトを提供するには、このオブジェクトを</font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのルート</font><font style="vertical-align: inherit;">にあるウィジェット</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">ラップし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="java hljs">ScopedModel&lt;MyModel&gt;(<font></font>
  model: MyModel(),<font></font>
  child: MyApp(...)<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、子孫ウィジェットは</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModelDescendant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットを使用し</font><font style="vertical-align: inherit;">てアクセスできるように</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">なり</font></a><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モデルインスタンスがパラメータに渡されます</font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> ScopedModelDescendant&lt;MyModel&gt;(<font></font>
      builder: (context, child, model) =&gt; Text(model.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子孫ウィジェットもモデルを更新できます。これにより、任意の再構築が自動的に引き起こされます</font></font><code>ScopedModelDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（モデルが正しくを呼び出す場合</font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = ScopedModel.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態管理のツールとしてFlutterで人気を得ましたが、その使用は、クラスを継承し、</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この変更通知パターンを使用</font><font style="vertical-align: inherit;">するオブジェクトのプロビジョニングに限定されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. BLoC</font></font></h4><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '18</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
カンファレンスで、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスロジックコンポーネント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（BLoC）</font><font style="vertical-align: inherit;">パターンが導入されました</font><font style="vertical-align: inherit;">。これは、ウィジェットから状態を取得するためのさらに別のツールとして機能します。 BLoCクラスは、状態を保持し、それをストリームおよびレシーバーとして公開する、長期間有効な非UIコンポーネントです。 UIを超えて状態およびビジネスロジックを取得することで、ウィジェットを単純なものとして実装し、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">StreamBuilder</font></a><font style="vertical-align: inherit;">を</font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">して自動再構築できます。その結果、ウィジェットは「ダム」になり、テストが容易になります。</font><font style="vertical-align: inherit;">
BLoCクラスの例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloc</span> </span>{
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;MyType&gt;();  Stream&lt;MyType&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<font></font>
  StreamSink&lt;MyType&gt; <span class="hljs-keyword">get</span> sink =&gt; _controller.sink;<font></font>
  <font></font>
  myMethod() {<font></font>
    <span class="hljs-comment">//  </span><font></font>
    sink.add(foo);<font></font>
  }  dispose() {<font></font>
    _controller.close();<font></font>
  }<font></font>
}<font></font>
 ,   BLoC:<font></font>
<span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
 <span class="hljs-keyword">return</span> StreamBuilder&lt;MyType&gt;(<font></font>
  stream: myBloc.stream,<font></font>
  builder: (context, asyncSnapshot) {<font></font>
    <span class="hljs-comment">//  </span><font></font>
 });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BLoCパターンの問題は、BLoCオブジェクトを作成および破棄する方法が明確でないことです。</font></font><code>myBloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記の例で</font><font style="vertical-align: inherit;">インスタンスはどのように作成され</font><font style="vertical-align: inherit;">ましたか？</font><font style="vertical-align: inherit;">私たち</font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は彼を取り除くために</font><font style="vertical-align: inherit;">どのように電話</font><font style="vertical-align: inherit;">しますか？</font><font style="vertical-align: inherit;">ストリームにはuse </font><font style="vertical-align: inherit;">が必要です。これは、不要に</font></font><code>StreamController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なった</font></font><code>closed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ときにすぐに行う必要があります。これは、メモリリークを防ぐために行われます。</font><font style="vertical-align: inherit;">（Dartにはクラスデストラクタなどはありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">メソッド</font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持つのはの</font><font style="vertical-align: inherit;">クラスだけです</font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">さらに、このBLoCを複数のウィジェット間で共有する方法は明確ではありません。</font><font style="vertical-align: inherit;">多くの場合、開発者がBLoCを習得することは困難です。</font><font style="vertical-align: inherit;">これを単純化しようとするいくつかのパッケージがあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.プロバイダー</font></font></h4><br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年にRemy Rusleによって書かれた、に似たパッケージです</font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、その機能は限定されず、Modelのサブクラスを提供します。これも終了するラッパーです</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、プロバイダーはBLoC、ストリーム、フューチャーなどを含む任意の状態オブジェクトを提供できます。プロバイダーは非常にシンプルで柔軟性があるため、Googleは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '19会議</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、将来的に</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は状態の管理に適したパッケージになると発表しました。もちろん、他のパッケージも許可されていますが、疑問がある場合は、Googleで停止することをお勧めし</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ウィジェット付き、ウィジェット用」を構築。</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態のあるオブジェクトをウィジェットツリーに配置し、他のウィジェット（子）がそのオブジェクトにアクセスできるようにします。</font><font style="vertical-align: inherit;">また</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データで初期化し、ウィジェットツリーから削除した後にクリーンアップを実行することで、状態オブジェクトの寿命を管理するの</font><font style="vertical-align: inherit;">にも</font><font style="vertical-align: inherit;">役立ちます。</font><font style="vertical-align: inherit;">したがって、それ</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はBLoCコンポーネントの実装にも適しているか、他の状態管理ソリューションの基礎として機能します！</font><font style="vertical-align: inherit;">または、単に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実装する</font></a><font style="vertical-align: inherit;">ために使用さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れ</font></a><font style="vertical-align: inherit;">ます。これは、接続を緩めてコードのテスト容易性を向上させる方法でウィジェットにデータを転送することを意味する豪華な用語です。</font><font style="vertical-align: inherit;">最終的に、</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には一連の特殊なクラスが付属しているため、より便利に使用できます。</font><font style="vertical-align: inherit;">次に、これらの各クラスを詳しく見ていきます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本プロバイダー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未来プロバイダー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチプロバイダー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロキシプロバイダー</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取り付け</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを使用するには</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、まずファイルに依存関係を追加します</font></font><code>pubspec.yaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>provider: ^3.0.0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要な場所に</font><font style="vertical-align: inherit;">パッケージをインポートします</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>import 'package:provider/provider.dart';</code><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースプロバイダー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのルートに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベース</font></font><code>Provide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rを</font><font style="vertical-align: inherit;">作成し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これには、モデルのインスタンスが含まれます。</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータ</font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はインスタンスを作成します</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">既存のインスタンスを渡す場合は、ここでコンストラクタを使用します</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Provider.value</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>MyApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ウィジェットを使用して</font><font style="vertical-align: inherit;">、モデルのこのインスタンスをの任意の場所で</font><font style="vertical-align: inherit;">使用できます</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;MyModel&gt;(<font></font>
      builder: (context, value, child) =&gt; Text(value.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、クラス</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Consumer</font></a></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットを使用して</font><font style="vertical-align: inherit;">インスタンス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">取得します</font><font style="vertical-align: inherit;">。このウィジェットにより</font><font style="vertical-align: inherit;">、オブジェクトをパラメーターに</font><font style="vertical-align: inherit;">含めることができ</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
では、モデルのデータを更新したい場合はどうすればよいでしょうか。ボタンがクリックされたときにプロパティを更新する必要がある別のウィジェットがあるとします</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>builder</code><font style="vertical-align: inherit;"></font><code>value</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>foo</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インスタンスへのアクセスに使用される特定の構文に注意してください</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。機能的には、これはウィジェットにアクセスすることと同じ</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このウィジェット</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コードがリンクを簡単に取得できない場合に役立ち</font></font><code>BuildContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">以前に作成</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
した元のウィジェットはどうなると思います</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？その中に新しい意味が表示されます</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残念ながら、ありません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。古い伝統的なDartオブジェクトの変更をリッスンすることはできません（少なくともFlutterでは提供されないリフレクションなし）。したがって、</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">適切に更新し、</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それに応じ</font><font style="vertical-align: inherit;">てウィジェットを</font><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">するように命令した</font><font style="vertical-align: inherit;">ことを「確認」することはできません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、希望があります！</font><font style="vertical-align: inherit;">クラスに</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不純を実装さ</font><font style="vertical-align: inherit;">せることができます</font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モデルの実装を変更し、</font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティの1つが変更されるたびに</font><font style="vertical-align: inherit;">特別なメソッドを呼び出すには、少し時間がかかり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ほぼ同じように機能します</font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、この場合、モデルの特定のクラスから継承する必要がないのは素晴らしいことです。</font><font style="vertical-align: inherit;">混和を実現するのに十分</font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは次のようになります。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{
  <span class="hljs-built_in">String</span> _foo;  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> foo(<span class="hljs-built_in">String</span> value) {<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり</font><font style="vertical-align: inherit;">、_fooプライベート変数を使用して、</font><font style="vertical-align: inherit;">プロパティ</font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>getter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andに</font><font style="vertical-align: inherit;">置き換えました</font></font><code>setter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようにして、fooプロパティに加えられた変更を「インターセプト」して、オブジェクトが変更されたことをリスナーに通知できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、外側から、次の</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前の異なるクラスを使用するように実装を変更できます</font></font><code> ChangeNotifierProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs">ChangeNotifierProvider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような！</font><font style="vertical-align: inherit;">今、私たちの</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アップデートプロパティ</font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のインスタンスでは</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それは</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動的にこの変更を反映するために更新します。</font><font style="vertical-align: inherit;">かっこいいですよね？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで。</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の構文を使用</font><font style="vertical-align: inherit;">するボタンハンドラに気づいたと思い</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、この構文により</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モデルが変更されるとすぐに</font><font style="vertical-align: inherit;">インスタンスが自動的に再構築さ</font><font style="vertical-align: inherit;">れます</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">おそらくこれは必要ありません。</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結局のところ、値が変化してもまったく変化しないボタンが含まれて</font><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">だけ</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">再構築を回避するには、次の構文を使用して、再構築を登録せずにモデルにアクセスできます。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context, listen: <span class="hljs-keyword">false</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、パッケージに同梱されている別の魅力</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一見、それが必要な理由は明らかではありません</font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後に、</font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutterでストリームを消費する必要がある場合</font><font style="vertical-align: inherit;">は、通常の方法を使用でき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">たとえば、ここで</font></font><code>onAuthStateChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供される</font><font style="vertical-align: inherit;">ストリームをリッスンします</font></font><code>FirebaseAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context {<font></font>
  <span class="hljs-keyword">return</span> StreamBuilder(<font></font>
   stream: FirebaseAuth.instance.onAuthStateChanged, <font></font>
   builder: (BuildContext context, AsyncSnapshot snapshot){ <font></font>
     ...<font></font>
   });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
helpを使用して同じことを行うに</font><font style="vertical-align: inherit;">は、アプリケーションのルートで</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームを提供し</font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="dart hljs">StreamProvider&lt;FirebaseUser&gt;.value(<font></font>
  stream: FirebaseAuth.instance.onAuthStateChanged,<font></font>
  child: MyApp(...),<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、通常は次のようにして、子ウィジェットを使用します</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
  <span class="hljs-keyword">return</span> Consumer&lt;FirebaseUser&gt;(<font></font>
    builder: (context, value, child) =&gt; Text(value.displayName),<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットのコードがすっきりしただけでなく、データがストリームからのものであることを抽象化します。たとえば、基本実装をに変更する場合は</font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ウィジェットコードを変更する必要はありません。ご覧のとおり、これは以下に示す他のすべてのプロバイダーに適用されます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FutureProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記の例と同様に、</font><font style="vertical-align: inherit;">ウィジェットを操作するとき</font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の標準の代替</font></font><code> FutureBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。次に例を示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">FutureProvider&lt;FirebaseUser&gt;.value(<font></font>
  value: FirebaseAuth.instance.currentUser(),<font></font>
  child: MyApp(...),<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子ウィジェットでこの値を使用する</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、</font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記</font><font style="vertical-align: inherit;">の例</font><font style="vertical-align: inherit;">と同じ実装を使用し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueNotifier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスによって実装されるDartインターフェイスであり</font><font style="vertical-align: inherit;">、値を受け取り、別の値に変更されたときにリスナーに通知します。</font><font style="vertical-align: inherit;">たとえば、整数カウンタを単純なモデルクラスでラップすることができます。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> </span>{
  <span class="hljs-keyword">final</span> ValueNotifier&lt;<span class="hljs-built_in">int</span>&gt; counter = ValueNotifier(<span class="hljs-number">0</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複合型を</font></font><code>ValueNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作する</font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ときは、それに格納されて</font><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">の演算子を使用して</font><font style="vertical-align: inherit;">、値が変更されたかどうかを判断します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なものを作成してみましょう</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これにはメインモデルが含まれ、その後に</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされた</font></font><code>ValueListenableProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスニングプロパティ</font><font style="vertical-align: inherit;">が続き</font><font style="vertical-align: inherit;">ます</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: Consumer&lt;MyModel&gt;(builder: (context, value, child) {<font></font>
    <span class="hljs-keyword">return</span> ValueListenableProvider&lt;<span class="hljs-built_in">int</span>&gt;.value(<font></font>
      value: value.counter,<font></font>
      child: MyApp(...)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このネストされたプロバイダーはタイプ</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">他にもあるかもしれません。</font><font style="vertical-align: inherit;">同じタイプの複数のプロバイダーが登録されている場合、プロバイダーは「最も近い」（最も近い祖先）を返します。</font><font style="vertical-align: inherit;">子ウィジェットから</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティをリッスンする方法は</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のとおりです：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<font></font>
      builder: (context, value, child) {<font></font>
        <span class="hljs-keyword">return</span> Text(value.toString());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、別のウィジェットから</font><font style="vertical-align: inherit;">プロパティを更新する方法</font><font style="vertical-align: inherit;">は次のとおりです。</font><font style="vertical-align: inherit;">注：元のコピーにアクセスする必要があります</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.counter.value++;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
多数のウィジェットを使用する場合</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アプリケーションのルートで、多くの添付ファイルから醜い構造を取得します。</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;Foo&gt;.value( <font></font>
  value: foo, <font></font>
  child: Provider&lt;Bar&gt;.value( <font></font>
    value: bar, <font></font>
    child: Provider&lt;Baz&gt;.value( <font></font>
      value: baz , <font></font>
      child: MyApp(...)<font></font>
    ) <font></font>
  ) <font></font>
)</code></pre><br>
<code>MultiProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらをすべて同じレベルで宣言することができます。</font><font style="vertical-align: inherit;">それは単なる構文上の砂糖です。システム内レベルでは、それらはすべて入れ子のままです。</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt;.value(value: foo), <font></font>
    Provider&lt;Bar&gt;.value(value: bar), <font></font>
    Provider&lt;Baz&gt;.value(value: baz), <font></font>
  ], <font></font>
  child: MyApp(...), <font></font>
)<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProxyProvider</font></font></i></a><br>
<br>
<code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、3番目のパッケージリリースで追加された興味深いクラス</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">それはあなた自身が他のプロバイダーに依存するかもしれないプロバイダーを宣言することを可能にします。</font><font style="vertical-align: inherit;">この例では、Barクラスはインスタンス固有</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは、互いに依存し合うサービスのルートセットをコンパイルするときに役立ちます。</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider ( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt; ( <font></font>
      builder: (context) =&gt; Foo(),<font></font>
    ), <font></font>
    ProxyProvider&lt;Foo, Bar&gt;(<font></font>
      builder: (context, value, previous) =&gt; Bar(value),<font></font>
    ), <font></font>
  ], <font></font>
  child: MyApp(...),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のジェネリック型引数は、依存する型</font></font><code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、2番目は返される型です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのプロバイダーを同時に聞く方法</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のウィジェットが多くのプロバイダーをリッスンし、それらのいずれかが変更されたときに再構築する場合はどうなりますか？</font><font style="vertical-align: inherit;">ウィジェットオプションを使用して、最大6つのプロバイダーを同時に聞くことができます</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">追加のメソッドパラメータとしてインスタンスを受け取ります</font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs">Consumer2&lt;MyModel, <span class="hljs-built_in">int</span>&gt;(<font></font>
  builder: (context, value, value2, child) {<font></font>
    <span class="hljs-comment">//value  MyModel</span>
    <span class="hljs-comment">//value2  int</span><font></font>
  },<font></font>
);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用すると、</font></font><code>InheritedWidget</code> <code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutterの通常の方法で状態を管理でき</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、ウィジェットは状態オブジェクトにアクセスし、基礎となる通知メカニズムが抽象化されるような方法でそれらをリッスンできます。</font><font style="vertical-align: inherit;">必要に応じてアンカーポイントを作成してこれらのオブジェクトを作成し、必要に応じてそれらを削除することで、状態オブジェクトの寿命を管理しやすくなります。</font><font style="vertical-align: inherit;">このメカニズムは、依存関係を簡単に実装するために使用でき、さらに高度な状態管理オプションの基礎としても使用できます。</font><font style="vertical-align: inherit;">Googleの恵みとFlutterコミュニティでのサポートの拡大に​​より、これは</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すぐに試す価値のあるパッケージになりました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503062/index.html">開発者にとってシリコンバレーでの生活費</a></li>
<li><a href="../ja503064/index.html">あなたが待っていなかったIoT（パート3）。シミュレーションモデルの構築</a></li>
<li><a href="../ja503068/index.html">テクノロジーとビジネスの岐路に立つ：ITリーダーがスイスに新しい大学を開設</a></li>
<li><a href="../ja503070/index.html">電気マグ。クレイジーな電動スクーター/電動自転車を作る</a></li>
<li><a href="../ja503072/index.html">ちょうど別のツール：望ましい状態の構成でサービス構成を知る </a></li>
<li><a href="../ja503080/index.html">オフィスに設置された映画は、放送をストリーミングしないための実用的な方法です</a></li>
<li><a href="../ja503082/index.html">NAS / FTPとしての電報</a></li>
<li><a href="../ja503084/index.html">ライトベンドアカデミーコースの復習-リアクティブアーキテクチャ</a></li>
<li><a href="../ja503086/index.html">オンライン文字起こしサービスは安全で機密ですか？</a></li>
<li><a href="../ja503088/index.html">運送業者の貨物の選び方</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>