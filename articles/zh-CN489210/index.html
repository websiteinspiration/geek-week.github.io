<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐾 🎍 🤸🏿 带有示例的Linux代码性能测试 👈🏼 🎿 🧕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我开始学习Java时，我尝试解决的第一个任务就是确定偶数/奇数。我知道执行此操作的几种方法，但决定在Internet上寻找“正确”的方法。找到的所有链接上的信息告诉我有关x％2形式的唯一正确解，以便获得除法的余数。如果余数为0，则数字为偶数；如果余数为1，则为奇数。
 
 从ZX Spectrum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>带有示例的Linux代码性能测试</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我开始学习Java时，我尝试解决的第一个任务就是确定偶数/奇数。我知道执行此操作的几种方法，但决定在Internet上寻找“正确”的方法。找到的所有链接上的信息告诉我有关x％2形式的唯一正确解，以便获得除法的余数。如果余数为0，则数字为偶数；如果余数为1，则为奇数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从ZX Spectrum时代起，我就想起了另一种方式，它与二进制系统中数字的表示形式相关。十进制中的任何数字都可以写成2的幂的和。例如，对于一个字节，即8位，十进制系统中的任何数字都可以表示为数字128 + 64 + 32 + 16 + 8 + 4 + 2 + 1的总和。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这只是两个幂的序列。将数字转换为二进制系统时，如果需要考虑数字，则在二进制表示形式中将为1，如果不需要，则为0。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010（8 + 0 + 2 + 0）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101（8 + 4） + 0 + 1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000（128 + 64 + 0 + 0 + 8 + 0 + 0 + 0）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以立即注意到一个事实，即奇数只能给出值为1的2的零次幂，根据定义，所有其他2的幂将为偶数。</font><font style="vertical-align: inherit;">这自动意味着，从二进制数系统的角度来看，如果我们要检查任何数字以进行奇偶校验，则无论它有多大，都不需要检查整数。</font><font style="vertical-align: inherit;">我们只需要检查第一位（最右边）。</font><font style="vertical-align: inherit;">如果为0，则数字为偶数，因为所有其他位都为偶数，反之亦然，如果最右边的位为1，则保证数字为奇数，因为所有其他位仅给出偶数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要仅检查数字中的正确位，可以使用多种方法。</font><font style="vertical-align: inherit;">其中之一是二进制AND。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二进制AND（AND）按照以下规则工作。如果您申请任何数字，我们将其称为原始的逻辑与（与数字0进行逻辑与），那么这种运算的结果始终为0。这样，您就可以将不需要的位清零。如果您申请原件1，那么您将获得原件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在二进制系统中，很容易这样写：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 AND 0 = 0（原始零）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 AND 0 = 0（原始零）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 AND 1 = 0（不改变原始）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 AND 1 = 1（不改变原始）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从这里开始很简单规则。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果将所有单位的AND运算应用于所有数字（所有位均打开），我们将获得相同的初始数字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果将所有零的AND应用于任何数字（所有位均关闭），则得到0。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们将和0至字节13，那么我们将得到0在十进制它看起来像13和0 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们将和0至字节200，我们将得到0，或写下200和0 = 0简要介绍。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样是相反的，应用于13所有包含的位，对于一个字节，它将是8个单位，我们得到了原始的。</font><font style="vertical-align: inherit;">在二进制系统</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00001101和11111111 = 00001101 </font><font style="vertical-align: inherit;">或在十进制系统13 AND 255 = 13中，</font><font style="vertical-align: inherit;">对于200，分别为11001000 AND 11111111 = 11001000，或者在十进制系统200 AND 255 = 200中</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二进制验证</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要检查奇偶校验号，我们只需要检查最右边的位。如果为0，则数字为偶数；如果为1，则数字为偶数。知道使用AND可以使某些位保持原始状态，而有些则可以重置，因此我们可以重置除最右边一位以外的所有位。例如：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二进制系统中的13是1101。让我们对它应用AND 0001（我们重置所有位，最后一位保留原始位）。在1101年，我们将除最后一位之外的所有位都更改为0，得到0001。我们仅从原始数字中获得了最后一位。在十进制系统中，它将看起来像13 AND 1 = 1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与数字200相同的东西，二进制格式为11001000。我们将AND 00000001应用到它，根据相同的方案，将所有位清零，保留最后一位不变，得到00000000，然后用AND重置左7个零，得到最后0从原始号码开始。在十进制系统中，看起来像200 AND 1 =0。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，将AND 1命令应用于任何数字，我们将得到0或1。如果结果为0，则该数字为偶数。为1时，数字为奇数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Java中，二进制AND表示为＆。因此，200＆1 = 0（偶数）和13＆1 = 1（奇数）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着至少有两种确定偶数的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X％2-通过除以两个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X＆1 </font><font style="vertical-align: inherit;">的余数</font><font style="vertical-align: inherit;">-通过二进制AND</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
诸如OR，AND，XOR之类的二进制运算由处理器在最短的时间内处理。</font><font style="vertical-align: inherit;">但是除法运算是一项艰巨的任务，为了执行除法运算，处理器需要处理大量指令，从根本上执行整个程序。</font><font style="vertical-align: inherit;">但是，存在二进制左移和右移运算，例如，可以将数字快速除以2。问题是编译器是否使用此优化，以及这两个比较之间是否存在差异，实际上它们是相同的。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编码</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将编写一个程序，该程序将按周期处理9,000,000,000个数字，并通过确定除法的余数来确定它们属于偶数/奇数。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将编写完全相同的内容，但实际上会更改两个字符，并通过二进制AND来检查同一件事。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们需要以某种方式比较这两个程序。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux上的资源。</font><font style="vertical-align: inherit;">中央处理器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建任何操作系统都花费了大量时间，特别是在程序之间公平分配资源上。</font><font style="vertical-align: inherit;">一方面，这很好，因为可以运行两个程序，因此可以确保它们可以并行工作，但是，另一方面，当您需要检查程序的性能时，非常有必要限制或至少减少其他程序对程序的外部影响。程序和操作系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先要弄清楚的是处理器。</font><font style="vertical-align: inherit;">Linux OS为每个进程存储一个位掩码，该位掩码指示应用程序可以使用哪些内核，哪些不能。</font><font style="vertical-align: inherit;">您可以使用taskset命令查看和更改此掩码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，让我们看看处理器中的内核数量：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的计算机具有4核处理器。</font><font style="vertical-align: inherit;">这很好，因为我将根据自己的需求分配其中之一。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看当前是否所有这些都与top命令一起使用：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按“ 1”可分别查看每个内核的信息：</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们看到所有内核的使用大致相同。</font><font style="vertical-align: inherit;">（每个核心的us和sy和id指示器大致相等）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们尝试使用taskset命令查看相同的内容。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十六进制系统中的位掩码“ F”表示十进制为15，二进制为1111（8 + 4 + 2 +1）。</font><font style="vertical-align: inherit;">所有位均启用，这意味着具有PID 1的进程将使用所有内核。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Linux上，当一个进程通过克隆系统调用生成另一个进程时，将在克隆时从父进程复制位掩码。</font><font style="vertical-align: inherit;">这意味着，如果我们为初始化进程更改此掩码（在我的情况下为systemd），则在通过systemd启动任何新进程时，该新进程将已经使用新掩码启动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用相同的命令更改进程的掩码，列出要保留给进程使用的CPU内核数。</font><font style="vertical-align: inherit;">假设我们要为进程保留内核0.2.3，并且要为systemd进程禁用内核1。</font><font style="vertical-align: inherit;">为此，我们需要运行以下命令：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们检查：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
掩码以十六进制表示法更改为“ D”，即十进制为13，二进制为1101（8 + 4 + 0 + 1）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从现在开始，将由systemd进程克隆的任何进程将自动具有CPU使用率的掩码1101，这意味着将不使用内核号1。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们禁止在所有进程中使用内核</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
阻止主Linux进程使用单个内核只会影响此进程创建的新进程。</font><font style="vertical-align: inherit;">但是在我的系统中，已经不存在一个进程，而是一个完整的进程，例如crond，sshd，bash等。</font><font style="vertical-align: inherit;">如果我需要禁止所有进程使用一个内核，那么必须为每个正在运行的进程运行tasket命令。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了获得所有进程的列表，我们将使用内核提供给我们的API，即/ proc文件系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在循环的更深处，我们查看每个正在运行的进程的PID，并为其和所有线程更改掩码：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于在程序执行期间，某些进程可能有时间生成其他进程，因此最好多次运行此命令。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用top命令检查我们的工作结果：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，情况有所改变，现在对于内核0.2.3，我们的参数us，sy，id平均相同，对于内核1，我们在用户空间和sys中的内核消耗为0，内核处于100％空闲（空闲100） ）</font><font style="vertical-align: inherit;">我们的应用程序不再使用内核1，并且内核当前仅使用很小的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，将性能测试的任务减少到在自由内核上启动我们的过程。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分配给进程的物理内存可以很容易地从任何进程中获取。</font><font style="vertical-align: inherit;">这种机制称为交换。</font><font style="vertical-align: inherit;">如果Linux有交换的地方，它仍然会这样做。</font><font style="vertical-align: inherit;">像其他任何进程一样，阻止操作系统从我们的进程中获取内存的唯一方法是完全禁用交换部分，我们将这样做：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们分配了1个未使用的处理器内核，并且还删除了从Linux内核交换内存的功能。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磁碟</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了减少磁盘对启动过程的影响，请在内存中创建磁盘，然后将所有必需的文件复制到该磁盘上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建目录并挂载文件系统：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们需要弄清楚计划如何以及如何启动它。</font><font style="vertical-align: inherit;">为了运行我们的程序，我们首先需要编译我们的代码：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，您需要运行它：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在我们的例子中，我们希望在处理器内核上运行该进程，而该进程没有被其他进程使用。</font><font style="vertical-align: inherit;">因此，通过任务集运行它：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的测试中，我们需要测量时间，因此我们的发射线变成</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux OS支持多种格式的可执行文件，其中最常见的是ELF格式。此文件格式使您可以告诉操作系统不要运行您的文件，而是运行另一个文件。乍一看，这听起来不是很合逻辑且易于理解。想象一下，我启动了Minesweeper游戏，然后Mario游戏为我启动-它看起来像病毒。但这是逻辑。如果我的程序需要某种动态库，例如libc或任何其他动态库，则这意味着OS必须首先将该库加载到内存中，然后再加载并运行我的程序。在操作系统本身中放置此类功能似乎是合乎逻辑的，但是操作系统在内存的受保护区域中工作，并且应包含尽可能少的必要功能。因此，ELF格式使您有机会告诉OS我们要下载其他程序，此“其他”程序将下载所有必需的库和我们的程序，并开始整个过程​​。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们需要运行3个文件，这是taskset，time，java。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查其中的第一个：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bash将运行文件/ usr / bin / taskset，检查其中的内容：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我上面写过的ELF文件。</font><font style="vertical-align: inherit;">在ELF文件中，除了程序本身之外，还有各种头文件。</font><font style="vertical-align: inherit;">通过启动该文件，操作系统检查其头，如果文件中存在“请求程序解释器”头，则操作系统将从该头启动文件，并将初始启动的文件作为参数传递。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查此标头是否存在于我们的ELF文件中：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标头存在，这意味着通过启动/ usr / bin / taskset文件，我们实际上运行了/lib64/ld-linux-x86-64.so.2。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查此文件是什么：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是指向文件/lib64/ld-2.17.so的Sim链接。</font><font style="vertical-align: inherit;">一探究竟：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，这是操作系统将运行的另一个ELF文件。</font><font style="vertical-align: inherit;">我们看一下标题：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到该ELF文件没有这样的头，因此OS将运行该文件并将控制权转移给它。</font><font style="vertical-align: inherit;">并且此文件已经可以打开我们的文件/ usr / bin / taskset，从那里读取所有必需库的信息。</font><font style="vertical-align: inherit;">所需库的列表也位于ELF文件的标题中。</font><font style="vertical-align: inherit;">我们可以使用ldd或readelf命令查看此列表，这是同一件事：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSO是与库无关的链接的内存，因此ELF文件中缺少它作为必需的库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这清楚地表明程序/lib64/ld-2.17.so负责运行需要它的所有程序，而这些程序都是具有动态链接库的程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果运行/ usr / bin / taskset，则与使用/ usr / bin / taskset参数运行/lib64/ld-2.17.so完全相同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们回到磁盘对测试的影响问题。</font><font style="vertical-align: inherit;">现在我们知道，如果要从内存中加载程序，则不需要复制一个文件，而是复制几个文件：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们所做的时间相同，它们的库要求完全相同（我们已经复制了ld和libc）。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于Java来说，事情要复杂一些，因为Java需要许多可以长时间复制的不同库。</font><font style="vertical-align: inherit;">为了简化我的生活，我将整个目录从java openjdk复制到内存中的磁盘上并创建一个sim链接。</font><font style="vertical-align: inherit;">当然，在这种情况下，将保留磁盘访问权限，但是访问次数会更少。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重命名旧目录，在其末尾添加.default</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并创建一个符号链接：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经知道如何通过/lib64/ld-2.17.so文件的参数运行一个二进制文件，该文件实际上会启动。</font><font style="vertical-align: inherit;">但是，如何使程序/lib64/ld-2.17.so从指定的目录中加载已加载的库？</font><font style="vertical-align: inherit;">帮助我们的ld，我们从中了解到，如果您声明环境变量LD_LIBRARY_PATH，则ld程序将从我们指定的目录中加载库。</font><font style="vertical-align: inherit;">现在，我们拥有所有数据，准备了Java应用程序的启动行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们连续开始几次并检查：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在程序执行过程中，我们可以运行在最顶层，并确保程序在正确的CPU内核上运行。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，大多数情况下的结果是相似的。</font><font style="vertical-align: inherit;">不幸的是，我们无法完全消除操作系统对CPU内核的影响，因此结果仍然取决于启动时Linux内核内部的特定任务。</font><font style="vertical-align: inherit;">因此，最好使用多个开始值的中位数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的例子中，我们看到一个程序在一个CPU内核上以10.65秒的间隔通过剩余部分对Java程序进行了9,000,000,000个奇偶校验处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们对第二个程序进行相同的测试，该程序通过二进制AND进行相同的操作。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以放心地说，通过二进制AND进行奇偶校验的比较需要4.02秒，这意味着与通过除法其余部分进行检查相比，它的工作速度是2.6倍，至少在openjdk版本1.8.0上是如此。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Java与Openjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我下载并从Oracle网站的/mnt/ramdisk/jdk-13.0.2目录解压JAVA JDK。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编译：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们推出：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们编译第二个程序：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们推出：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在除法其余部分和二进制AND中，oracle jdk中相同源的执行时间相同，这看起来很正常，但是这次同样糟糕，这在除法其余部分的openjdk中已显示。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蟒蛇</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试在Python中进行比较。</font><font style="vertical-align: inherit;">首先，该选项除以2：</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们推出：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在使用二进制AND同样的事情：</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们推出：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果表明，AND更快。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Internet上，已经多次编写了Python中的全局变量比较慢的说法。</font><font style="vertical-align: inherit;">我决定将最后一个程序的执行时间与AND进行比较，并将其完全相同，但包装在一个函数中：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在函数中运行：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，在Python中通过二进制AND进行的相同奇偶校验比较在单个CPU内核上约5秒钟内处理了100000000个数字，通过AND不进行函数的相同比较耗时约10秒，而通过除法其余部分进行的不进行函数的比较耗时〜 11秒 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么函数中的Python程序比没有它的情况下运行得更快的原因已经被多次描述，并且与变量的范围有关。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python能够将程序反汇编成Python在解释程序时使用的内部函数。</font><font style="vertical-align: inherit;">让我们看看Python使用odd_and_func.py函数将哪些函数用于变体：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并在不使用代码的情况下检查该函数：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，在带有已声明函数的变体中，Python使用带有FAST后缀的内部函数，例如STORE_FAST，LOAD_FAST，而在未声明函数的变体中，Python使用内部函数STORE_NAME和LOAD_NAME。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文没有什么实际意义，并且旨在更多地了解Linux和编译器的某些功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对所有人都好！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489196/index.html">Magic Smoke：微控制器与线性稳压器</a></li>
<li><a href="../zh-CN489198/index.html">如何不使用Liquibase射脚</a></li>
<li><a href="../zh-CN489200/index.html">哪些初创公司正在寻找2020年的Y Combinator</a></li>
<li><a href="../zh-CN489204/index.html">深入了解Facebook服务的可靠性</a></li>
<li><a href="../zh-CN489206/index.html">用Patroni崩溃的故事，或如何删除PostgreSQL集群</a></li>
<li><a href="../zh-CN489212/index.html">1C-Bitrix通过要求提交其个人数据来防止退订新闻通讯</a></li>
<li><a href="../zh-CN489214/index.html">在iOS上测试本地化的现代方法</a></li>
<li><a href="../zh-CN489218/index.html">天真。超级：简单游戏的代码和架构</a></li>
<li><a href="../zh-CN489226/index.html">在C＃.NET中优化LINQ查询的方法</a></li>
<li><a href="../zh-CN489228/index.html">银行语音机器人-有史以来最糟糕的用户体验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>