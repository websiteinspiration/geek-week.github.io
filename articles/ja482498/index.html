<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 🔹 👓 Javaのインターフェースの進化の歴史 🍢 🧑🏿‍🤝‍🧑🏻 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Javaのインターフェースは、長年にわたって大幅に進化しています。その開発の過程でどのような変化が起こったか見てみましょう。
 
 オリジナルのインターフェース
 Java 1.0のインターフェースは、現在のインターフェースに比べて非常にシンプルでした。これらには、定数とパブリック抽象メソッドの2種...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Javaのインターフェースの進化の歴史</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482498/"><img src="https://habrastorage.org/webt/db/rm/ac/dbrmacgcmj4awxvvosnyra8kmmo.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaのインターフェースは、長年にわたって大幅に進化しています。</font><font style="vertical-align: inherit;">その開発の過程でどのような変化が起こったか見てみましょう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリジナルのインターフェース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 1.0のインターフェースは、現在のインターフェースに比べて非常にシンプルでした。</font><font style="vertical-align: inherit;">これらには、定数とパブリック抽象メソッドの2種類の要素のみを含めることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数フィールド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースには、通常のクラスと同じようにフィールドを含めることができますが、いくつかの違いがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドを初期化する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドはpublic static finalと見なされます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修飾子public、static、finalは明示的に指定する必要はありません（これらはデフォルトで配置されています）</font></font></li>
</ul><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-keyword">int</span> MY_CONSTANT = <span class="hljs-number">9</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは明示的に指定されていませんが、MY_CONSTANTフィールドはパブリックな静的最終定数と見なされます。</font><font style="vertical-align: inherit;">これらの修飾子を追加できますが、これは必須ではありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象メソッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェイスの最も重要な要素は、そのメソッドです。</font><font style="vertical-align: inherit;">インターフェースメソッドも通常のクラスメソッドとは異なります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドには本体がありません </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドは、このインターフェースを実装するクラスによって提供されます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明示的に指定されていなくても、メソッドはパブリックおよび抽象と見なされます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象修飾子と最終修飾子の組み合わせはJavaでは許可されていないため、メソッドをfinalにすることはできません </font></font></li>
</ul><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">String <span class="hljs-title">doSomethingCompletelyDifferent</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネスティング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 1.1では、他のクラス内に配置できるクラスの概念が導入されました。</font><font style="vertical-align: inherit;">このようなクラスには、静的と非静的の2つのタイプがあります。</font><font style="vertical-align: inherit;">インターフェースには、他のインターフェースやクラスを含めることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが明示的に指定されていなくても、そのようなインターフェースとクラスはパブリックで静的と見なされます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
        <span class="hljs-comment">//...</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyOtherInterface</span> </span>{
        <span class="hljs-comment">//...</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙と注釈</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに5つの型がJava 5で導入されました。列挙型と注釈です。</font><font style="vertical-align: inherit;">インターフェースの内側に配置することもできます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-keyword">enum</span> MyEnum {<font></font>
        FOO, BAR;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@interface</span> MyAnnotation {
        <span class="hljs-comment">//...</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリック型</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 5では、ジェネリック、ジェネリック型の概念が導入されました。</font><font style="vertical-align: inherit;">つまり、ジェネリックでは、特定の型を指定する代わりにジェネリック型を使用できます。</font><font style="vertical-align: inherit;">したがって、セキュリティを犠牲にすることなく、また各タイプに個別の実装を提供することなく、異なる数のタイプで機能するコードを記述できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 5以降のインターフェースでは、ジェネリック型を定義し、それをメソッドの戻り値の型として、またはメソッドの引数の型として使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Boxインターフェイスは、String、Integer、List、Shoeなどのオブジェクトを格納するために使用するかどうかに関係なく機能します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T item)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoeBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">Shoe</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Shoe item)</span> </span>{
        <span class="hljs-comment">//...</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的メソッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 8以降では、静的メソッドをインターフェースに含めることができます。</font><font style="vertical-align: inherit;">このアプローチにより、インターフェースの動作が変わりました。</font><font style="vertical-align: inherit;">Java 8より前のバージョンとはまったく異なる動作をするようになりました。当初、インターフェースのすべてのメソッドは抽象的でした。</font><font style="vertical-align: inherit;">つまり、インターフェースは署名のみを提供し、実装は提供しませんでした。</font><font style="vertical-align: inherit;">実装は、インターフェースを実装するクラスに任されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェイスで静的メソッドを使用する場合は、メソッド本体の実装も提供する必要があります。</font><font style="vertical-align: inherit;">このメソッドをインターフェイスで使用するには、staticキーワードを使用します。</font><font style="vertical-align: inherit;">静的メソッドはデフォルトでパブリックと見なされます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{<font></font>
    <font></font>
    <span class="hljs-comment">// This works</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// This does not work, </span>
    <span class="hljs-comment">// static methods in interfaces need body</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的メソッドの継承</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の静的メソッドとは異なり、インターフェースの静的メソッドは継承されません。</font><font style="vertical-align: inherit;">つまり、そのようなメソッドを呼び出す場合は、それを実装するクラスからではなく、インターフェースから直接呼び出す必要があります。</font></font><br>
<br>
<pre><code class="java hljs">MyInterface.staticMethod();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作は、多重継承の問題を回避するのに非常に役立ちます。</font><font style="vertical-align: inherit;">2つのインターフェースを実装するクラスがあるとします。</font><font style="vertical-align: inherit;">各インターフェースには、同じ名前と署名を持つ静的メソッドがあります。</font><font style="vertical-align: inherit;">最初にどちらを使用する必要がありますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそれが役立つのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースと、このインターフェースを実装するクラスで機能するヘルパーメソッドのセット全体があるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来、コンパニオンクラスを使用する方法がありました。</font><font style="vertical-align: inherit;">インターフェイスに加えて、インターフェイスに属する静的メソッドを含む非常に類似した名前でユーティリティクラスが作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法の使用例は、JDKで直接見ることができます。java.util.Collectionインターフェースとそれに付随するユーティリティクラスjava.util.Collectionsです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースに静的メソッドがあると、このアプローチは不要になり、不要になり、推奨されません。</font><font style="vertical-align: inherit;">これで、すべてを1か所にまとめることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのメソッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトのメソッドは静的メソッドに似ていますが、それらの本体も提供する必要があります。</font><font style="vertical-align: inherit;">デフォルトのメソッドを宣言するには、単にdefaultキーワードを使用します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的メソッドとは異なり、メソッドはデフォルトでインターフェースを実装するクラスに継承されます。</font><font style="vertical-align: inherit;">重要なことは、そのようなクラスは必要に応じて動作を再定義できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、例外が1つあります。</font><font style="vertical-align: inherit;">インターフェイスには、ObjectクラスのtoString、equals、およびhashCodeメソッドと同じシグネチャを持つデフォルトのメソッドを含めることはできません。</font><font style="vertical-align: inherit;">そのようなソリューションの有効性を理解するには、ブライアンゲッツの回答を見てください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。デフォルトのメソッドがオブジェクトのメソッドをオーバーライドできるようにします。</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそれが役立つのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースにメソッドを直接実装するという考えは、完全に正しいとは思えません。では、なぜこの機能が最初に導入されたのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェイスには1つの問題があります。 APIを他の人に提供するとすぐに、APIは永久に「石化」します（重大な結果なしに変更することはできません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
伝統的に、Javaは後方互換性を非常に重要視しています。</font><font style="vertical-align: inherit;">デフォルトのメソッドは、既存のインターフェースを新しいメソッドで拡張する方法を提供します。</font><font style="vertical-align: inherit;">最も重要なこととして、デフォルトのメソッドはすでに特定の実装を提供しています。</font><font style="vertical-align: inherit;">これは、インターフェースを実装するクラスが新しいメソッドを実装する必要がないことを意味します。</font><font style="vertical-align: inherit;">ただし、必要に応じて、デフォルトのメソッドは、実装が適切でなくなった場合はいつでもオーバーライドできます。</font><font style="vertical-align: inherit;">つまり、互換性を維持しながら、インターフェイスを実装する既存のクラスに新しい機能を提供できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">紛争</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのインターフェースを実装するクラスがあるとします。</font><font style="vertical-align: inherit;">これらのインターフェースには、同じ名前と署名を持つデフォルトのメソッドがあります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>, <span class="hljs-title">B</span> </span>{<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、同じシグネチャを持つ同じデフォルトのメソッドが2つの異なるインターフェースから継承されます。</font><font style="vertical-align: inherit;">各インターフェイスには、このメソッドの独自の実装があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、クラスはどのようにして2つの異なる実装のどちらを使用するかをどのようにして知るのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は知りません。</font><font style="vertical-align: inherit;">上記のコードはコンパイルエラーになります。</font><font style="vertical-align: inherit;">これを機能させる必要がある場合は、クラス内の競合するメソッドをオーバーライドする必要があります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>, <span class="hljs-title">B</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">// Without this the compilation fails    </span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">256</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベートメソッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 8の登場とデフォルトのメソッドと静的メソッドの導入により、インターフェースにはメソッドシグネチャだけでなく、その実装も含めることができるようになりました。</font><font style="vertical-align: inherit;">このような実装を作成するときは、複雑なメソッドを単純なメソッドに分割することをお勧めします。</font><font style="vertical-align: inherit;">このようなコードは、再利用、保守、および理解が容易です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この目的のために、プライベートメソッドを使用します。外部からは表示および使用してはならないすべての実装の詳細を含めることができるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、Java 8では、インターフェースにプライベートメソッドを含めることはできません。</font><font style="vertical-align: inherit;">これは、以下を使用できることを意味します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長くて複雑で、身体のテクニックを理解するのが難しい。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスの一部であるヘルパーメソッド。</font><font style="vertical-align: inherit;">これはカプセル化の原則に違反し、インターフェースと実装クラスのパブリックAPIを汚染します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さいわい、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 9以降では、インターフェイスでプライベートメソッドを使用できます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次の機能があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベートメソッドには本体があり、抽象的ではありません </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的でも非静的でもかまいません </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらは、インターフェースとインターフェースを実装するクラスによって継承されません </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らは他のインターフェースメソッドを呼び出すことができます </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベートメソッドは、他のプライベート、抽象、静的、またはデフォルトのメソッドを呼び出すことができます </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベート静的メソッドは、他の静的メソッドとプライベート静的メソッドのみを呼び出すことができます </font></font></li>
</ul><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonStaticMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">年代順</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、Javaのバージョンごとの変更の時系列リストです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 1.1</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたクラス</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたインターフェース</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 5</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリック型</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされた列挙</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされた注釈</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 8</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトの</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド静的メソッド</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 9</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プライベートメソッド</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482484/index.html">制約理論を使用して開発効率を上げる方法</a></li>
<li><a href="../ja482490/index.html">MISRAとは何ですか？</a></li>
<li><a href="../ja482492/index.html">永久凍土の融解と温室効果ガスの排出</a></li>
<li><a href="../ja482494/index.html">調査結果の更新</a></li>
<li><a href="../ja482496/index.html">結果：2019年の9つの主要な技術革新</a></li>
<li><a href="../ja482502/index.html">580万IOPS：なぜそれほど多いのか？</a></li>
<li><a href="../ja482504/index.html">投稿付き投稿：2019年の結果</a></li>
<li><a href="../ja482506/index.html">DCMIを介したパラレルADCからのSTM32F4xxへのデータ入力</a></li>
<li><a href="../ja482508/index.html">2019年のハブレに関する図：同じ記事を除いた投稿が増え、より積極的にコメントする</a></li>
<li><a href="../ja482512/index.html">彼らは私たちのようです：中国に入るとき、特別なアジアの精神を忘れてください</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>