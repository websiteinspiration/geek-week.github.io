<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎨 📅 🍨 Paul Graham: Brevity = Strength 🎮 👨🏿‍🍳 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today at HackerNews we raised a discussion of the article of Paul Graham in 2002 and we decided to resurrect its translation from nonexistence.
 
 
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paul Graham: Brevity = Strength</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/502926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today at HackerNews we </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raised a discussion of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article of Paul Graham in 2002 and we decided to resurrect its translation from nonexistence.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/643/390/da8643390d5501c1411a3ba972dbe2ac.jpg" alt="image"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"The quantity of meaning compressed into a small space </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
by algebraic signs, is another circumstance that facilitates </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
the reasonings we are accustomed to carry on by their aid." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Babbage (1791-1871)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In a discussion around the </font><font style="vertical-align: inherit;">LL1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article </font><font style="vertical-align: inherit;">on the LL1 mailing list, Paul Prescod expressed an idea that doesn’t leave my mind.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python's goal is regularity and readability, but not brevity.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first glance, a programming language probably should not claim to be. </font><font style="vertical-align: inherit;">As I understand it, brevity (succinctness, conciseness, compactness) = strength. </font><font style="vertical-align: inherit;">And if so, then making a substitution, we get:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python's goal is regularity and readability, but not power.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
which, in turn, is not a very good compromise (if it is really a compromise), which is worth making. </font><font style="vertical-align: inherit;">It seems like if you say: the goal of the Python language is not to be an effective programming language. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Is brevity = strength? </font><font style="vertical-align: inherit;">This seems like an important question, maybe the most important question for those involved in the development of languages. </font><font style="vertical-align: inherit;">I’m not sure yet that the answer to it is simply “yes”, but for a start this is a good hypothesis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypothesis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My hypothesis is that brevity is power, or they are so close that, with the exception of pathological cases, you can take them for something identical.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brevity, it seems to me, is what programming languages ​​are created for. Computers would be just as happy if they were given instructions directly in machine language. I think the main reason we are going to develop high-level languages ​​is to get the advantage of expressing (and more importantly, thinking) ten lines in a high-level language, which would require 1000 lines of machine code. In other words, the main goal of high-level languages ​​is to make the source code shorter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the shorter source code is the purpose of high-level languages, and the strength of something is a measure of how well the goal is achieved, then the strength of the programming language is how much it reduces your programs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conversely, a language that doesn't make your programs smaller does a poor job of a programming language, just like a knife that cuts poorly, or illegible printing.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metrics</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in what sense is less? </font><font style="vertical-align: inherit;">The most common measure of the size of the source code is the number of lines. </font><font style="vertical-align: inherit;">But this measure is common only because of the simplicity of measurement, and I do not think that anyone believes that it is a good test of program size. </font><font style="vertical-align: inherit;">Languages ​​have different conventions on what can be placed on one line; </font><font style="vertical-align: inherit;">quite a few lines in C may have nothing but one or two separators. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another simple test is the number of characters in the program, but this one is not too good; </font><font style="vertical-align: inherit;">some languages ​​(like Perl) have shorter identifiers than others.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think the best measure of the size of a program can be the number of elements, where the element is something that could become a separate vertex in the source tree. The name of a variable or function is an element; an integer or a real number is an element; a text literal segment is an element; an element of a pattern or format directive is an element. There are boundary cases (is "-5" one element or two?), But I think most of them are the same in all languages, so they will not affect the comparison too much.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This measure should be concretized, and it may require additional interpretation in the case of some specific languages, but it seems to me that it is trying to measure the right thing: the number of parts of the program. </font><font style="vertical-align: inherit;">The source tree is what you draw in your mind to represent the program, and thus the size of this tree is proportional to the amount of work needed to write or read it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This measure would allow us to compare different languages, but this is not, at least for me, its basic value. And the value of the brevity test is a guide to designing languages. The most useful language comparison is comparing two possible variations of the same language. What can I do in the language to make programs shorter? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the conceptual load of a program is proportional to its complexity, and a given programmer can withstand a certain conceptual load, then this is the same as asking: how can help programmers do more? And this, it seems to me, is the same as asking: how to design a good language?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(By the way, the falsity of this already bearded saying “all languages ​​are equivalent” is most clearly seen when designing languages. When you create a new language, you constantly compare two languages ​​- one in which I would make X, and the other in which I would not - so that decide what’s better. If it were a pointless question, you could just as well throw a coin.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having a goal of brevity seems like a good way to find new ideas. </font><font style="vertical-align: inherit;">If you find a way to make programs shorter, then this is no coincidence: you probably found a useful new abstraction. </font><font style="vertical-align: inherit;">You could even write a program that would fetch repeating chunks in the source code. </font><font style="vertical-align: inherit;">New ideas can be found among languages ​​that have a reputation for being concise: Forth, Joy, Icon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first one to write about these things was, as far as I know, Fred Brooks with his book Mythical Man-Month. He wrote that programmers generate the same amount of code regardless of language. When I first read it in my 20s, it was a big surprise, and it seemed to me that this had huge consequences. This meant that (a) the only way to write programs faster is to use a shorter language, and (b) the one who bothered to do this will ask a beat to those competitors who do not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brooks conjecture, if true, may be the very essence of hacking. Since then, over the years, I have paid attention to everything that would be relevant to the issue: from theoretical studies to stories about individual projects. I did not see anything that would contradict this hypothesis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But I have not seen any clear evidence, and I do not expect to see them. Studies such as comparing the Lutz Prekelt programming languages, although they produce the expected results, they tend to use tasks that are too small for a meaningful test. The best test for a language is what happens in programs written in a month. And if you are convinced, like I, that the main purpose of languages ​​is to be a good language that they think in (rather than a language in which they give instructions to the computer after you think about it), then the real test for the language is what new can you write on it. Thus, comparing languages ​​based on a predefined specification is somewhat wrong.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The real test for the language is how well you can find and solve new problems on it, but not the tasks formulated by someone else. These are different criteria. In art, tools such as embroidery and mosaic work well if you know in advance what you want to get, but absolutely indecent if you do not know. If you want to reveal an image in the process of writing a picture (what you should do when revealing such complex things as, for example, the image of a person), then you should use a more flexible tool like pencil, ink or oil paints. Of course, tapestries and mosaics are made just like that: first a picture is created, and then only it is copied.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means that we are unlikely to have a proper comparison of the relative strength of programming languages. We will have exact comparisons, but not correct ones. In particular, studies explicitly aimed at language comparisons are likely to use small tasks and will necessarily use a predefined set of tasks, and therefore will tend to underestimate the most powerful languages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reports in this area, although they will be less accurate than “scientific” studies, are likely to be more meaningful. For example, Ulf Wieger from Ericsson conducted a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">study</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and came to the conclusion that Erlang is 4-10 times shorter than C ++, and the software development speed on it is proportionally higher:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison of internal projects in Ericsson reveals similar productivity in lines of code per hour, including all phases of development, regardless of the language used (Erlang, PLEX, C, C ++ or Java). </font><font style="vertical-align: inherit;">Differences in languages ​​- only in the total amount of source code.</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This study also clearly indicates that it does not appear in Brooks' book (since it measured only lines of debugged code): programs written in more powerful languages ​​tend to contain fewer errors. </font><font style="vertical-align: inherit;">This is already quite enough, and probably in tasks such as network switches, this is more important than the programmer’s performance.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, you can trust your instinct. What is programming in this language? I think that in order to create a better language you should become hypersensitive to how well the language allows you to think in it, and then choose or develop a language that seems most suitable to you. If any property of the language is inconvenient or restrictive - do not worry, you will know about it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But such hypersensitivity will result in clumsy languages ​​becoming unbearable for you. </font><font style="vertical-align: inherit;">I find programming in languages ​​that do not have macros unbearably restrictive, just as if someone accustomed to dynamic typing would consider unbearably restrictive the return to languages, where types should be described for each declared variable and it is impossible to declare a list consisting of elements different types. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And I am not alone. </font><font style="vertical-align: inherit;">I know many Lisp hackers with whom something similar happened. </font><font style="vertical-align: inherit;">In fact, the most accurate measure of the relative strength of a programming language could be the proportion of programmers who know a given language who will undertake any work in which this language should be used, regardless of the subject area.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probably many hackers know what it feels like when the language seems restrictive. </font><font style="vertical-align: inherit;">This is probably the same feeling as when you get stuck in a traffic jam on the street that you want to drive along and you have to make a long detour. </font><font style="vertical-align: inherit;">You want to say something and language does not allow you to do this.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, a limiting language is not a succinct language. </font><font style="vertical-align: inherit;">The problem is not that you cannot express something, but that the detour that this language forces you to make is too long. </font><font style="vertical-align: inherit;">Do this thought experiment: you want to write some kind of program, and the language does not allow you to do it the way you planned, but instead it makes you make it shorter. </font><font style="vertical-align: inherit;">At least for me this would not be too restrictive. </font><font style="vertical-align: inherit;">As if a policeman would direct you from a traffic jam onto a shorter road instead of a long detour. </font><font style="vertical-align: inherit;">Wow!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems to me that the feeling of limitedness basically (by 90 percent?) Stems from the fact that you are forced to make the program longer in the language you are writing in, compared to the language in which you think. </font><font style="vertical-align: inherit;">Boundedness is basically insufficient brevity, so when a language seems to be limiting, it means that it is not short enough.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Readability</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The quote I started with also mentions two other qualities: regularity and readability. </font><font style="vertical-align: inherit;">I don’t really understand what regularity is, and what are the benefits of regular and readable code compared to just readable code. </font><font style="vertical-align: inherit;">But I think I know what is meant by readability, and it also seems to me that this has to do with brevity. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we must be careful with the concepts of readability of a single line of code and the readability of the program as a whole. </font><font style="vertical-align: inherit;">Only the last is important. </font><font style="vertical-align: inherit;">I agree that one line on BASIC is most likely more readable than one line on Lisp, but a program written in BASIC will have more lines than the same program written in Lisp. </font><font style="vertical-align: inherit;">Reading the BASIC program will take more effort.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">total effort = effort to read one line * number of lines</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I'm not so sure that readability is proportional to brevity, but definitely brevity is a factor in readability (see the formula above). So it hardly makes sense to say that the purpose of the language is readability, but not brevity.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a user who sees this language for the first time, line-by-line readability means that this language will seem harmless to him. Thus, line-by-line readability can be a good marketing decision, although it is a bad design decision. It is isomorphic with respect to the method of payment in installments: instead of being intimidated by a large deposit, you offer the buyer a small monthly payment. Payment in parts is ultimately unprofitable for him, as well as line-by-line readability - for the programmer. The buyer must make many small payments, just as the programmer must read many readable lines separately.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This ratio existed even before the advent of programming languages. </font><font style="vertical-align: inherit;">If you read novels and newspaper articles, then your first experience reading an article in mathematics can be frightening: reading one page takes half an hour. </font><font style="vertical-align: inherit;">Nevertheless, I am sure that the problem is not in the notation, as it might seem at first glance. </font><font style="vertical-align: inherit;">An article in mathematics is difficult to read because the ideas themselves are complex. </font><font style="vertical-align: inherit;">If you express the same ideas in prose (as mathematicians did before they thought of a brief notation), then reading them would not be easier, because this single page would turn into a whole book.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In what degree?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some disagreed with the idea of ​​brevity = strength. I think, instead of arguing whether this is so, it would be more useful to ask to what extent brevity is power? Because it is clear that brevity is one of the main purposes of programming languages. And if not, what is their purpose, and how important are those other functions? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I propose this not to make the discussion more civil. I really want to know the answer. When, if this happens at all, does the language become concise enough?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hypothesis with which I began was that, except for some pathological cases, brevity is identical to strength. </font><font style="vertical-align: inherit;">I meant that they will be identical in any language developed by someone, but if someone wants to create a language specifically to refute this hypothesis, then it will probably work out. </font><font style="vertical-align: inherit;">But I'm not really sure about that either.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Languages ​​But Not Programs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be made clear that we are talking about the brevity of languages, not individual programs. Of course, some programs can be written very tightly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I wrote about this in the book “About Lisp”. In order for the macro to justify itself, it must save many times more space in relation to its own length. If some bulky macro saves ten lines of code every time you use it, and the macro itself consists of ten lines, then you will get savings in lines if you use it more than two times. But this is still a bad move, as macro definitions are more difficult to read than regular code. You may need to use the macro 10 or 20 times before the readability improves.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am sure that in any language such compromises are possible (although I suspect that the stakes are raised in strong languages). Every programmer has ever seen code that is extremely shortened due to dubious programming techniques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, it is indisputable - at least for me - that programs can be concise enough. The question is, can the languages ​​themselves be short? Can languages ​​force programmers to write briefly (in elements) at the cost of readability?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One reason it is hard to imagine a too concise language is that if there is an overly compact way of expressing something, then there will probably be a longer way. For example, if it seems to you that using macros or high-level functions in Lisp is too dense, you can write code that is isomorphic to Pascal. If you do not want to express the factorial in the language of Arc as a call to a high-level function, </font></font><br>
<br>
<code>(rec zero 1 * 1-)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
you can also write a recursive definition: </font></font><br>
<br>
<code>(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although I cannot give examples so immediately, I am interested in the question: can the language be too short? Are there any languages ​​that force you to write illegible code? If anyone has any examples, I would be glad to see them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Remember: I’m interested in programs that have a high density according to the measure of “elements” described above, but not programs that are short just because separators can be omitted in them and everything has names that are one character long.) </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was first published </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<hr><br>
<br>
<img src="https://habrastorage.org/webt/nk/j2/oz/nkj2oztxanscb6lhq19l-dfv2z8.jpeg" alt="image" align="left"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Learn the details of how to get a sought-after profession from scratch or Level Up in skills and salary by taking SkillFactory online courses:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Scientist Profession Course (24 months) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profession Data Analyst Course (18 months)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python for Web Development Course (9 months)</font></font></a></li>
</ul> <br>
<br clear="left"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502916/index.html">Unit tests for RxSwift code</a></li>
<li><a href="../en502918/index.html">Error with #line directive in Visual C ++ compiler</a></li>
<li><a href="../en502920/index.html">As we tested the performance of new processors in the cloud for 1C according to the Gilyov test</a></li>
<li><a href="../en502922/index.html">Crowd marketing as a tool for enhancing business vitality</a></li>
<li><a href="../en502924/index.html">Snom D735 IP Phone Review</a></li>
<li><a href="../en502928/index.html">Mini-conference "Safe work with cloud services"</a></li>
<li><a href="../en502930/index.html">Azure DevOps and App Center instead of test farms: simplify and speed up mobile development with cloud services</a></li>
<li><a href="../en502932/index.html">Patrick Mackenzie Law: Software Economics is More Than You Think Even Given Patrick Mackenzie Law</a></li>
<li><a href="../en502934/index.html">How to reduce advertising costs in Yandex.Direct and Google Ads: 9 life hacks</a></li>
<li><a href="../en502940/index.html">How not to turn a newsletter into spam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>