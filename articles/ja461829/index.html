<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍💻 🧖 ✌🏾 TCP対UDPまたは将来のネットワークプロトコル ⛹🏽 💀 🌍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="少なくとも1 Mb /秒のインターネットトラフィックを生成する各サービスの前に、「どのように？ TCPかUDPか？」配信プラットフォームを含むアプリケーション領域では、そのような決定を行うための好みと伝統がすでに発達しています。
 
 理論的には、たとえば、怠惰な開発者が自分のMLをPythonにデ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>TCP対UDPまたは将来のネットワークプロトコル</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461829/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少なくとも1 Mb /秒のインターネットトラフィックを生成する各サービスの前に、「どのように？ TCPかUDPか？」配信プラットフォームを含むアプリケーション領域では、そのような決定を行うための好みと伝統がすでに発達しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には、たとえば、怠惰な開発者が自分のMLをPythonにデプロイしようとしなかった場合（彼はそれを知っていただけだったため）、世界は卑劣な「スーパーJavaエンコーダー」言語へのそのような愛で満たされることはほとんどありません。そして今日、アプリケーションの過去のコンテキストにおけるこの言語の弱点は、無条件に多数のマイニングA / Bの展開と立ち上げにおける優位性を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARMとIntel、iOS、Androidを比較したり、Mortal KombatをInjusticeと比較したりできます。</font><font style="vertical-align: inherit;">そして、宇宙のホリバーに出くわすので、マルチフォーマットのコンテンツを大量に配信するというトピックに戻りましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10年前、誰もがUDPは非保証型配信に関するものだと確信していました。</font><font style="vertical-align: inherit;">信頼できるプロトコルが必要な場合は、TCPです。</font><font style="vertical-align: inherit;">そして、この記事の伝統に反して、TCPとUDPのように一見比類のないものを比較します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p5/tk/9z/p5tk9z_pumv5hmxly_ob3rvdikg.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意、カットの下で99のイラストと図とすべての重要です。</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較は、OK </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Tobolの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオおよびテーププラットフォームの開発責任者が行います</font><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アラトボル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">ソーシャルネットワーク上のビデオおよびニュースフィードサービスは問題ありません。コンテンツと、そのネットワーク状態が悪い場合や優れた場合のすべての既存のクライアントプラットフォームへの配信についてのみです。また、TCPまたはUDPを介して配信する方法に関する問題は非常に重要です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/aXYJlizk3CQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP対UDP。</font><font style="vertical-align: inherit;">最小理論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較のために、少し基本的な理論が必要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fd/2q/ko/fd2qkoeptll1vmmm0ptkscrhu9i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IPネットワークについて何を知っていますか？送信するデータストリームはパケットに分割され、ある種のブラックボックスがこれらのパケットをクライアントに配信します。クライアントはパケットを収集し、データストリームを受信します。通常、これはすべて透過的であり、下位レベルに何があるかを考える必要はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/6r/xm/dj6rxmcr3xayjlmfnblkxet-1le.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図は、TCP / IPおよびUDP / IPスタックを示しています。下部にはイーサネットパケット、IPパケットがあり、さらにOSレベルにはTCPとUDPがあります。このスタックのTCPとUDPは、それほど大きな違いはありません。それらはIPパケットにカプセル化され、アプリケーションはそれらを使用できます。違いを確認するには、TCPパケットとUDPパケットの内部を調べる必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/pr/lt/mzprltftvytepznp_xufo63xb0g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこにもポートもあります。しかし</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPではチェックサムしかありません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-パケット長。このプロトコルは可能な限り単純です。</font><font style="vertical-align: inherit;">TCPには、ウィンドウ、確認応答、シーケンス、パケットなどを明確に示す多くのデータがあります。</font><font style="vertical-align: inherit;">明らかに、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPはより複雑</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大まかに言えば、TCPは信頼できる配信プロトコルであり、UDPは信頼できないものです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、UDPの信頼性が低いとされていますが、TCPを使用するよりも高速で信頼性の高いデータを配信できるかどうかを調べます。</font><font style="vertical-align: inherit;">ネットワークを内側から見て、どのように機能するかを理解してみましょう。</font><font style="vertical-align: inherit;">その過程で、次の質問に触れます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜTCPを比較するのか、または何が問題なのか。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何を、何をTCPと比較すべきか。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Googleが行ったこととGoogleが行った決定</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークプロトコルの未来が私たちを待っているもの。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事には理論はありません。OSIのレベルとモデル、複雑な数学的モデルですが、すべてをそれらを通して数えることができます。</font><font style="vertical-align: inherit;">理論ではなく、自分の手でネットワークに触れる方法を最大限に分析します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜTCPを比較するのか、何が問題なのか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは1974年にTCPを思い付きました、そして、私が学校に行った20年後、私はインターネットカードを購入し、コードを消去して、どこかに電話しました。</font><font style="vertical-align: inherit;">また、2泊から朝7時までは、インターネットは無料でしたが、なかなか通じませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに20年が経過し、モバイルワイヤレスネットワークのユーザーは「有線」ユーザーよりも普及し始めましたが、TCPは概念的には変わりませんでした。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルの世界が勝利し、無線プロトコルが登場し、TCPはまだ変わっていません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、ユーザーの80％がWi-Fiまたは3G-4Gワイヤレスネットワークを使用しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mw/a9/u4/mwa9u4ew7v6e1uevlbgrvf2jlrw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワイヤレスネットワークには、次のものがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケット損失-送信するパケットの約0.6％が途中で失われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替え-実際の生活の中での場所でのパッケージの再配置はかなりまれな現象ですが、0.2％のケースで発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジッタ-パケットが均等に送信され、約50ミリ秒の遅延でキューに到着した場合。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPは、異種ネットワークでのデータ転送のこれらすべての機能をユーザーから隠蔽し、内部に潜る必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下の地図は、ロシアの平均TCPデータレートです。</font><font style="vertical-align: inherit;">西部を削除すると、速度がメガビットよりもキロビットで測定されることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/a4/y5/cka4y5puk4gyorr-uaq2xcdtuom.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、平均して、ユーザー（ロシアの西部を除く）の場合：スループット1.1 Mbps、0.6％のパケット損失、RTT（往復時間）約200ミリ秒。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTの計算方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平均200ミリ秒を見たとき、統計に誤りがあると思い、RIPE Atlasを使用して別の方法でMSC内のサーバーへのRTTを測定することにしました。これは、インターネットの状態に関するデータを収集するためのシステムです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RIPE Atlas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プローブデバイスは</font><font style="vertical-align: inherit;">無料</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">入手できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/za/rj/3g/zarj3gndghr0wnxs4yqt_odm68a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
肝心なのは、それを家庭のインターネットに接続して「カルマ」を集めることです。彼女は何日も働き、何人かの人々は彼女の彼女の要求のいくつかを満たします。次に、さまざまなタスクを自分で設定できます。そのようなタスクの例：誤ってインターネット上で30ポイントを取り、RTTを測定するように依頼します。つまり、Odnoklassniki Webサイトに対してpingコマンドを実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kb/qa/5k/kbqa5k7sgl6wt5modhjfpa2fg00.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙なことに、ランダムポイントの中には、200〜300ミリ秒のpingを実行するポイントが多数あります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
総</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無線ネットワークは人気があり不安定です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （TCPがこれに対処していると考えられているため、通常は後者は無視されます）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの80％以上が無線インターネットを使用しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイヤレスネットワークのパラメータは、たとえば、ユーザーが角を曲がったという事実に応じて動的に変化します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイヤレスネットワークでは、パケット損失、ジッター、並べ替えが頻繁に発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非対称チャネルの修正、IPアドレスの変更。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツの消費はインターネットの速度に依存する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に簡単に確認できます-多くの統計があります。</font><font style="vertical-align: inherit;">私は</font><font style="vertical-align: inherit;">ビデオから</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統計</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取りました</font><font style="vertical-align: inherit;">、それは国のより速いインターネット速度がより多くのユーザーがビデオを見ると言うと言います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/de/6q/_r/de6q_ruks-vpbgoo4yt5vokfkno.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの統計によると、ロシアのインターネットはかなり高速ですが、内部データによると、平均速度はわずかに低くなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体としてインターネット速度が不十分であるという事実を支持して、大規模なアプリケーション、ソーシャルネットワーク、ビデオサービスなどのすべての作成者が、悪いネットワークでの作業のためにサービスを最適化していると述べています。</font><font style="vertical-align: inherit;">10 Kbの受信データの後、テープに最低限の情報が表示され、500 Kbの速度でビデオを見ることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロードをスピードアップする方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオプラットフォームの開発過程で、ワイヤレスネットワークではTCPはあまり効果的ではないことに気付きました。</font><font style="vertical-align: inherit;">どのようにしてこの結論に達しましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはダウンロードを高速化することを決め、次のトリックを行いました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n2/gg/xf/n2ggxfu9tzoskihc7itlm28j7ui.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオをクライアントからサーバーにいくつかのストリームでロードしました。つまり、40 MBは10 MBの4つの部分に分割され、並行してロードされます。</font><font style="vertical-align: inherit;">私たちはそれをAndroidで開始し、1つの接続（</font><font style="vertical-align: inherit;">レポートの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">よりも速く並列にロードされるようになり</font><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">最も興味深いのは、並行ダウンロードを本番環境に展開したときに、一部の地域ではダウンロード速度が3倍に向上したことです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4つのTCP接続を使用すると、サーバーにデータを実際に3倍速くアップロードできます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、ビデオのダウンロード速度を上げ、ダウンロードを並列化する必要があると結論付けました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安定なネットワークでのTCP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列処理による驚くべき効果に触れることができます。</font><font style="vertical-align: inherit;">データの送受信（スピードテストなど）やトラフィックシェーパー（Macの場合はネットワークリンクコンディショナーなど）にスピードメーターを使用するだけで十分です。アップロードとダウンロードのネットワークを1 Mbpsのパラメーターに制限し、パケット損失を増やし始めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lk/ki/j8/lkkij8appdgsvglvlp1rdt3em7s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この表は、RTTと損失を示しています。</font><font style="vertical-align: inherit;">損失が0％の場合、ネットワークは100％使用されていることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の反復では、パケット損失が5％増加し、ネットワークが74％しか使用されていないことがわかります。</font><font style="vertical-align: inherit;">大丈夫そうです-5％のパケット損失で、ネットワークの26％が失われます。</font><font style="vertical-align: inherit;">ただし、pingも増やすと</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、チャネルの半分未満</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が残り</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネルのRTTが高く、パケット損失が大きい場合、1つのTCP接続はネットワークを完全には利用しません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらなるトリックは、並列TCP接続の使用を開始した場合（同時に複数の速度テストを実行できるだけ）、チャネル使用率の逆の増加を確認できることを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/n7/v_/con7v_t-dxmnrsxe6e0kkakbnwm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列TCP接続の数が増えると、ネットワーク使用率はスループットとほぼ同じになり、損失の割合を差し引いたものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、それは判明しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイヤレスモバイルネットワークは成功しており、不安定です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPは、不安定なネットワークではチャネルを完全には利用しません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツの消費量はインターネットの速度に依存します。インターネットの速度が速いほど、より多くのユーザーが視聴します。私たちはユーザーを本当に愛しており、より多くの視聴を求めています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、どこかに移動し、TCPの代替を検討する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP vs TCPではない</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暖かいものを比較する方法は？ 2つのオプションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のオプション-IPレベルではTCPとUDPがあり、上から他のプロトコルを使用できます。明らかに、独自のプロトコルをTCPおよびUDPと並行して開始した場合、ファイアウォール、Brandmauer、ルーター、およびパケット配信に関与するその他の国はそれを認識しません。その結果、すべての機器が更新されて新しいプロトコルで作業を開始するまで、何年も待たなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプションは、信頼性の低いUDPの上に信頼性の高いデータ配信プロトコルを作成することです。明らかに、Linux、Android、iOSがカーネルに新しいプロトコルを追加するまで長時間待つことができるので、プロトコルをユーザースペースにカットする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションは興味深いようです。これを自作のUDPプロトコルと呼びます。</font><font style="vertical-align: inherit;">開発を始めるには、特別なことは必要ありません。UDPソケットを開いてデータを送信するだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zy/zt/sn/zyztsnsutwgufcqwlhxb6qslhpg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークの仕組みを学びながら開発していきます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPと自作UDP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、そして何を比較するのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークは異なります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輻輳がある場合、パケットの数が多く、チャネルや機器の輻輳が原因で一部のパケットがドロップする場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速で大規模な往復（サーバーが比較的遠い場合など）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇妙なこと-ネットワークで何も起こっていないように見えるが、Wi-Fiアクセスポイントが壁の後ろにあるためにパケットがまだ消えている場合。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分でいつでもネットワークプロファイルに触れることができます。スマートフォンで1つまたは別のプロファイルを選択して、速度テストを実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v1/0j/-p/v10j-p8absukvs6s4jn2ntd8qau.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークプロファイルに加えて、トラフィック消費のプロファイルを決定する必要もあります。</font><font style="vertical-align: inherit;">私たちが使用したものは次のとおり</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3k/dc/fb/3kdcfbeyhjpduwbumk1n1iz2-c0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私はビデオとストリームを担当しているため、プロファイルは適切です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のコンテンツを接続してストリーミングするときにビデオをプロファイルします。</font><font style="vertical-align: inherit;">上のグラフのように、接続速度が向上します。</font><font style="vertical-align: inherit;">このプロトコルの要件：低遅延とビットレートの適応。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テープビューオプション：インパルスデータの読み込み、バックグラウンドクエリ、ダウンタイム。</font><font style="vertical-align: inherit;">このプロトコルの要件：受信したデータは多重化され、優先順位が付けられます。ユーザーコンテンツの優先度はバックグラウンドプロセスよりも高く、ダウンロードはキャンセルされます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、最も人気のあるHTTP上のプロトコルを比較する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP 1.1およびHTTP 2.0</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2000年代の標準スタックは、SSLの上ではHTTP 1.1のように見えました。最新のスタックは、HTTP 2.0、TLS 1.3、およびすべてTCPの上にあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k9/yp/ng/k9ypngmth9i_4m8pqzx5n-kipf0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な違いは、HTTP 1.1はブラウザー内の1つのドメインへの接続プールを制限して使用するため、画像やデータなどのために別個のドメインを作成することです。 HTTP 2.0は、このすべてのデータが送信される1つの多重接続を提供します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/aj/uu/uoajuubf2yfz_femlhzhvq6buty.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP 1.1は次のように機能します。要求を作成し、データを取得し、要求を作成し、データを取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1y/nv/xd/1ynvxdxpfkluduputf3szhfi75a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、ブラウザまたはモバイルアプリケーションが競合します。つまり、APIによって画像やデータを受信するための接続であり、同時に画像、API、ビデオなどのリクエストを実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cn/ub/kl/cnubklsdxjrcuwpamcckap5_uu8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な問題は競争です。</font><font style="vertical-align: inherit;">送信したリクエストを制御することはできません。</font><font style="vertical-align: inherit;">あなたは、ユーザーがめくった写真を必要としなくなったが、何もできないことを理解しています。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP 1.1を使用しても、要求したものを取得できます。ダウンロードをキャンセルすることは困難です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソケットソケットの唯一のチャンスは、接続を閉じることです。</font><font style="vertical-align: inherit;">次に、これが悪い理由を確認します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP 2.0の違い</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP 2.0はこれらの問題を解決します：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ、ヘッダー圧縮。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ多重化;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優先順位付け;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードをキャンセルします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバープッシュ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにとってより重要な点を検討してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tb/nl/ur/tbnlurtfdzcqaxpy6_hgcphtye0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像とAPIをリクエストします。</font><font style="vertical-align: inherit;">写真はすぐに与えられ、しばらくしてAPIが準備されます。</font><font style="vertical-align: inherit;">APIが与えられました-画像は最後まで与えられました。</font><font style="vertical-align: inherit;">これはすべて透過的に行われます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優先度の高いコンテンツが先にダウンロードされます。</font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/gw/ws/wp/gwwswpducmtjv2huz9jprbhwpha.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバープッシュ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、APIなどの特定のものを要求した場合にはそういうものですが、クライアントの負荷がかかっていても、たとえばテープを表示するために必ず必要となる画像がキャッシュされました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また</font><font style="vertical-align: inherit;">、ページ間を移動した場合などにブラウザが自動的に実行する</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reset stream</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドもあり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">モバイルクライアントの場合、その助けを借りて、接続を失うことなくデータの受信を拒否できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、異なるTCPを比較します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークプロファイル：Wi-Fi、3G、LTE。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費プロファイル：ストリーミング（ビデオ）、多重化、ダウンロードのキャンセル（HTTP / 2）による優先順位付けにより、テープのコンテンツを受け取ります。&nbsp;</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロスレスモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラウンドトリップ時間と帯域幅の2つのパラメーターしかない単純なネットワークから比較を始めましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はpingです。これは、パケットの到着、確認応答の受信、または応答エコー時間にかかる時間です。</font><b><font style="vertical-align: inherit;">帯域幅</font></b><font style="vertical-align: inherit;"> -ネットワーク帯域</font><b><font style="vertical-align: inherit;">幅</font></b><font style="vertical-align: inherit;"> - </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を測定するに</font><font style="vertical-align: inherit;">は、パケットのパケットを送信し、特定の時間間隔で送信されたパケットの数をカウントします。</font><font style="vertical-align: inherit;">
もちろん、信頼できるプロトコルを使用しているため、確認応答があります。パケットを送信し、受信確認を受け取ります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/du/2l/6rdu2lwrhgztjekbwsfgvtuwdec.jpeg"><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅いインターネットの問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2013年にビデオサービスが開発され始めた頃、友人はカリフォルニアに行き、お気に入りのシリーズの新シリーズをOdnoklassnikiで見ることにしました。彼は、Googleキャンパスで250 msのRTT、完璧なWi-Fi 400 Mbpsを持っていたので、FullHDで新しいシリーズを見てみたかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼はビデオを見ることができたと思いますか？答えは、サーバー上の送信/受信バッファーの構成によって異なります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qf/sk/qj/qfskqjvyygm-klersirdlmfdreo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認応答付きのプロトコルがあるため、配信確認を受け取っていないすべてのデータはバッファに格納されます。送信バッファーが128 Kbに制限されている場合、これらの128 KbはRTTよりも小さいため、送信できません。したがって、400 Mbit / sのネットワークでは、4 Mbit / sが残ります。これは、FullHDでオンラインビデオを視聴するには不十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、バッファーのサイズを引き上げ、バッファーのサイズの変化に応じて1つのビデオセグメントの出力速度が実際にどのように変化するかを調べました。</font><font style="vertical-align: inherit;">すぐに、recvバッファーが自動的に調整された、つまり </font><font style="vertical-align: inherit;">サーバーが送信したもの、クライアントは常に受け入れることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/yi/ef/vjyiefcatf55inm_ka-0b1vpake.jpeg"><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明らかなTCPレシピ：高速データを長距離で送信する場合は、送信バッファーを増やす必要があります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて問題ないようです。</font><font style="vertical-align: inherit;">あなたは、netflixサーバーへのインターネットの速度を測定するfast.comサービスに行くことができます。</font><font style="vertical-align: inherit;">オフィスから210 Mbpsの速度を得た。</font><font style="vertical-align: inherit;">そして、ネットシェイパーを介して、タスク条件を設定し、再度このサイトに行きました。</font><font style="vertical-align: inherit;">マジック-私は4 Mbpsを正確に取得しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xx/sl/nr/xxslnr1m5syfgyludnghfp7d6yw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのように変更しても、Netflixは128 KBを超えるバッファを実現できませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファサイズ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適なバッファサイズを把握するには、オンザフライパケットとは何かを理解する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cl/ym/ws/clymwsmlyixceklwgevvv00izru.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークステータスがあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケット1と2はすでに送信されており、確認が受信されています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケット3、4、5、6が送信されましたが、配信結果は不明です（オンザフライパケット）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のパケットはキューにあります。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/if/oh/m0/ifohm0lal6uotlodse6vrehnoqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オンザフライのパケット数がバッファのサイズと等しい場合、それは十分なサイズではありません。この場合、ネットワークは不足しており、十分に活用されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆の状況が考えられます-バッファが大きすぎます。この場合、バッファーは膨潤します。なぜこれが悪いのですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m1/4y/fk/m14yfka8426esfgz8a8xeglxko4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの多重化について話し、同時に複数の要求を送信する場合（たとえば、同じ接続とAPIの画像）、巨大なメガバイトの画像全体がバッファーに入れられ、優先度の高いAPIもプッシュしようとすると、バッファーが膨らみます。写真が消えてしまうと、非常に長い時間待たなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な解決策は、バッファサイズを自動的に調整することです。現在、多くのクライアントで利用可能であり、このように機能します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pm/dj/rj/pmdjrjtekrknmzgogzn6bzkgplq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、多くのパケットを送信できる場合、バッファが増加し、データ転送が加速し、バッファのサイズが増加し、すべてが素晴らしいようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題があります。バッファが増加している場合、それほど簡単に減らすことはできません。これはより難しい作業です。速度が低下すると、同じバッファー膨潤が発生します。バッファは非常に大きく、いっぱいです。すべてのデータがクライアントに送信されるまで待つ必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
独自のUDPプロトコルを作成する場合、すべてが非常に簡単です。バッファにアクセスできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/lz/5m/owlz5m0em5dqvtz3ni14pgc3khm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような状況でTCPがデータを最後に追加するだけで、何もできない場合は、自作のプロトコルで、オンザフライパケットの直後にデータを転送することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、キャンセルが来て、クライアントがこの画像が不要になったと言った場合、APIデータが必要であり、コンテンツをさらにスクロールしました。これをすべてバッファーから捨て、必要なものを送信できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはどのように行われますか？</font><font style="vertical-align: inherit;">パケットの復元、配信の管理、確認応答の受信を行うには、パケットのsequence_idが必要であることがわかっています。</font><font style="vertical-align: inherit;">Sequence_idは、オンザフライパケットに対してのみ書き込まれます。つまり、パケットを送信するときにのみ発行されます。</font><font style="vertical-align: inherit;">パケットがなくなるまで、バッファー内の他のすべてを必要に応じて移動できます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TCPバッファーは正しく構成する必要があり、ネットワークに接してバッファーを膨らませないようにバランスをとります。</font><font style="vertical-align: inherit;">独自のUDPプロトコルの場合、すべてが単純です-これは制御できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可逆ネットワークモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より高いレベルに移動すると、ネットワークが少し複雑になり、パケット損失が発生します。</font><font style="vertical-align: inherit;">モバイルネットワークの場合、これは一般的な状況です。</font><font style="vertical-align: inherit;">送信されたパケットの一部がクライアントに到達しません。</font><font style="vertical-align: inherit;">標準の再送信回復アルゴリズムは次のように機能し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/z7/tv/tgz7tvr6zchscr49onnqepvjvje.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。パケットを送信し、各パケットの確認応答を受信します。</font><font style="vertical-align: inherit;">RTTにいくつかの定数を加えた値に等しい再送信タイムアウト（RTO）を通じて確認がない場合、パケットが送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットの5％だけが失われ、ネットワーク使用率が50％である場合のTCP非効率曲線に戻りましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ob/vi/qf/obviqfawoiesuiex2yqf_idbvei.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットを送信するだけの再送信では、このような問題は発生しません。</font><font style="vertical-align: inherit;">理由を理解するには、輻輳制御とは何かを理解する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輻輳制御</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロー制御と混同されることが多いので、両方を検討してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bc/3k/g9/bc3kg9sb5k5sppttampxxaeaypu.jpeg"><br>
<br>
<ul>
<li><b>Flow control</b> —      .  ,           ,      .    flow control  recv window,      .  flow control —  back pressure  ,    -    .</li>
<li> <b>congestion control</b>   .  ,   —    .</li>
</ul><br>
<img src="https://habrastorage.org/webt/mf/b5/9d/mfb59d5xp1ph_irk_rhkckjpbew.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークに過負荷をかけると、この状況が発生する可能性が非常に高くなります。データを送信し、一部のパケットが到達せず、さらに多くのデータを送信し、このデータはすべて消えます。</font><font style="vertical-align: inherit;">輻輳制御は、いくつかのチャンクでデータの出力を制限する責任があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆるTCPウィンドウがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/u0/9s/tju09sic8asow88ehlwsuyfjj6q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、フロー制御と輻輳制御の最小値です。つまり、明らかにこれらの値を超えていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPウィンドウ= 1の場合、データは左の図のように送信されます。確認を待ち、次のパケットを送信します。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPウィンドウ= 4の場合、4パケットのパケットをすぐに送信し、確認応答を待ち、引き続き動作します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続を開始するだけで、ウィンドウのサイズが徐々に大きくなります。</font><font style="vertical-align: inherit;">初期ウィンドウサイズはTCP = 10です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ar/jf/ja/arjfjayzxewtfl-iulsna677qa0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークの輻輳が発生すると、パケットが消え、ウィンドウが狭まり、再び加速し始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークはどのように見えますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yj/ck/_t/yjck_tpkuuze0pjmkdb5mhfrlri.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上の図は、すべてが順調なネットワークです。</font><font style="vertical-align: inherit;">パケットは所定の頻度で送信され、確認は同じ頻度で返されます。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2行目では、ネットワークの輻輳が始まります。パケットはより頻繁に送信され、確認応答には遅延が伴います。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データはルーターや他のデバイスのバッファーに蓄積され、ある時点でそれらがパケットを通過し始め、これらのパケットの確認が来ません（下の図）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルータから見ると、このようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jp/6c/di/jp6cdirmtiqosalz9vw-mvkjkei.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルーターは少しスマートで、過負荷を待たずにすぐに落ちます。チケットメカニズムがあります。チャネルが空いている場合などに、送信用のチケットを発行します。このメカニズムの本質は、少し早くパケットをドロップすることです。次に、輻輳制御がトリガーされ、TCPウィンドウが折りたたまれ、ルーターの負荷が低下し、すべてが機能し続けます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/__/w0/zg/__w0zgqdiycta2u7yla0svmhof4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、輻輳制御の古いメカニズムが機能し、ネットワークが上からの図であることが確かでした。実際、パケット損失はネットワークが混雑しているという事実の結果ではありません。下の図のようなネットワークがありますが、パケット損失は何の意味もない、と言われています。ワイヤレスなので、このようなネットワークにすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPが開発、適応され、最初の輻輳制御が損失関数のみで動作することは明らかです。</font><font style="vertical-align: inherit;">その後、損失遅延、つまり損失と遅延に輻輳制御が現れました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/44/no/5k/44no5kuc601zfx2h8dm_kwoqete.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討してください：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キュービック-Linux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.6でのデフォルトの輻輳制御。</font><font style="vertical-align: inherit;">最も頻繁に使用され、基本的に動作するのは彼です。パケットを失った-ウィンドウを非難しました。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BBR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Googleが2016年に</font><b><font style="vertical-align: inherit;">考案し</font></b><font style="vertical-align: inherit;">たより高度な輻輳制御です。</font><font style="vertical-align: inherit;">バッファのサイズを考慮します。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BBR輻輳制御</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィードバックメソッドを使用して、CubicとBBRを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7u/5z/zr/7u5zzrcv5cr3eyywvi0ui75qxr8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図では、通常のルーターとキューが蓄積し始めるルーター-後続の各確認応答は、送信に関して長くなります。</font><font style="vertical-align: inherit;">この場合：</font></font><br>
<br>
<ul>
<li>BBR ,    ,    ,    .&nbsp;</li>
<li>Cubic        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、遅延と接続時間のグラフで、さまざまな輻輳制御で何が起こるかを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xn/l5/c_/xnl5c_gfgpby_vchj-lt5ftptta.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BBRは、最初に往復時間を検知し、より多くのパケットを送信してから、バッファが詰まっていることを認識し、最小限の遅延で動作モードに入ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キュービックは積極的に動作します-バッファー全体をオーバーランし、バッファーがオーバーフローしてパケット損失が発生すると、キュービックはウィンドウを縮小します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BBRを使用するとすべての問題を解決できるようですが、ネットワークに</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジッター</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">ます。パケットが遅延したり、バンドルにグループ化されたりすることがあります。あなたは一定の頻度で彼らを送り、彼らはグループでやって来ます。さらに悪いことに、これらのパッケージへの確認応答を受け取ると、なんらかの理由で「ジッター」が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが手で触れる可能性があることを約束したので、たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイト</font><font style="vertical-align: inherit;">などにpingを実行し、pingを調べて、パッケージ間のジッターを検討します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/be/pu/fj/bepufjz6mtygfhqppfkeyvi3phq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットが不均一に到着することがわかります。平均ジッターは約50 msです。</font><font style="vertical-align: inherit;">当然、BBRは間違っている可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BBRは、実際の輻輳損失、デバイスのバッファオーバーフローによるパケット損失、およびワイヤレスネットワークの不良によるランダムな損失を区別するため、優れています。</font><font style="vertical-align: inherit;">ただし、ジッターが高い場合はうまく機能しません。</font><font style="vertical-align: inherit;">どうすれば彼を助けることができますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輻輳制御を改善する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、TCPは確認応答に情報をほとんど含まず、見たパケットだけを持っています。どのパケットが確認され、まだ到着していないかを示す選択的な確認応答もあります。しかし、この情報は十分ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fs/9j/gm/fs9jgmfd67brdk7wynu6sqjprk8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認応答を膨らませる機会がある場合でも、これらのパケットを送信するだけでなく、クライアントに到着する時間も常に節約できます。つまり、実際には、サーバー上でクライアントのジッターを収集します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
謝辞を膨らませることが一般的に効果的であるのはなぜですか？</font><font style="vertical-align: inherit;">モバイルネットワークは非対称だからです。</font><font style="vertical-align: inherit;">たとえば、通常3GまたはLTEでは、帯域幅の70％がデータのダウンロードに割り当てられ、30％がアップロードに割り当てられます。</font><font style="vertical-align: inherit;">トランスミッターが切り替わります：アップロード-ダウンロード、アップロード-ダウンロード。</font><font style="vertical-align: inherit;">何もアンロードしないと、アイドル状態になります。</font><font style="vertical-align: inherit;">したがって、興味深いアイデアがある場合は、謝辞を増やし、恥ずかしがらないでください。これは問題ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/0t/gd/cv0tgdq9vzirpmrvzx4optqe0ik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認応答を使用してジッターを送信に分割し、ジッターを受信に分割し、それらを個別に追跡する方法の例。</font><font style="vertical-align: inherit;">次に、より柔軟になり、輻輳損失がいつ発生したか、およびランダム損失がいつ発生したかを理解します。</font><font style="vertical-align: inherit;">たとえば、各方向のジッターの量を理解し、より正確にウィンドウを構成で​​きます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ti/qj/zk/tiqjzkihljlcb2pn2oj-wdlbmkq.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択する輻輳制御</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同級生は、ビデオ、API、写真など、さまざまなトラフィックを伴う大規模なネットワークです。また、輻輳制御について選択する方が良い統計があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BBRは遅延を減らすため、常にビデオに効果的です。その他の場合、通常はキュービックが使用されます-写真に適しています。しかし、他のオプションがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9m/ea/gd/9meagdum2m9dvmtn4eeawrmbtay.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数十の異なる輻輳制御オプションがあります。最適なものを選択するために、クライアントで統計を収集し、1つのタイプの負荷プロファイルについて、1つまたは別の輻輳制御を試すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、これはビデオでBBRを開始した場合の影響です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hy/h8/dh/hyh8dhiugrgtyl6vgaozjzitnxq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真剣に表示深度を増やすことができました。 Googleによると、BBRを使用すると、プレーヤーのバッファリングが約10％少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すばらしいですが、お客様はどうですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/np/m1/uy/npm1uywvt78qoudkof3mkebqrj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントは少し遅く、すべてキュービックであり、それに影響を与えることはできません。</font><font style="vertical-align: inherit;">しかし、それでも問題ありません。データを並列化できることもあります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輻輳制御に関する結論：</font></font></strong><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BBRは常にビデオに適しています。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のケースでは、私たちが独自のUDPプロトコルを使用している場合、輻輳制御を行うことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPの観点からは、カーネル内にある輻輳制御のみを使用できます。</font><font style="vertical-align: inherit;">カーネルに輻輳制御を実装する場合は、TCP仕様に準拠する必要があります。</font><font style="vertical-align: inherit;">確認応答を膨らませたり、変更を加えたりすることはできません。これは、クライアント上に存在しないためです。</font></font></li>
</ul><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPプロトコルを作成すると、輻輳制御の点ではるかに自由になります。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多重化と優先順位付け</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは新しいトレンドで、誰もが今やっています。</font><font style="vertical-align: inherit;">どのような問題がありますか？</font><font style="vertical-align: inherit;">私たちがTCPを使用する場合、確実にすべての人（またはほとんどすべての人）が行頭ブロッキングの状況を知っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rt/6t/zvrt6t3igpnzn4vea3lgdw7vb1e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のTCP接続を介して多重化される要求がいくつかあります。</font><font style="vertical-align: inherit;">それらをネットワークに送信しましたが、一部のパッケージがありませんでした。</font><font style="vertical-align: inherit;">TCP接続はこのパケットを再送信し、RTTに近い時間かそれ以上で再送信します。</font><font style="vertical-align: inherit;">現時点では何も取得できませんが、TCPバッファには、完全に取得する準備ができている別のリクエストからのデータが含まれています。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP 2.0を使用する場合、TCPを介した多重化は、悪いネットワークでは必ずしも効果的ではないことがわかりました。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の問題は、バッファーの膨潤です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/zh/rw/fyzhrwlr4mmtdgxwhp-mxfa9k-y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像がクライアントに送信されると、バッファが増加します。長い間送信すると、APIリクエストが表示され、決して優先順位を付けることはできません。このような場合、TCP優先順位付けは機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、パケット損失が発生すると、ヘッドオブラインブロッキングが発生し、クライアントのビットレートが変動すると（これはモバイルクライアントでよく発生します）、バッファブロート効果が現れます。その結果、バッファリングがあるか、クライアントが何かを期待しているため、多重化も優先順位付けもサーバープッシュも他のすべても機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
独自の多重化を行うと、そこにさまざまなデータを配置できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_g/er/5g/_ger5gqpdxllo3-p1eo7ytzupce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは難しくありません。番号の付いたパケットをバッファに追加するだけです。</font><font style="vertical-align: inherit;">オンザフライ-すでに送信されたものには触れないでください。ただし、まだ送信されていないものは再配置できます。</font><font style="vertical-align: inherit;">こんな感じです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9g/_v/xr/9g_vxrrlkavxucnmocy3kggc-f8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは写真を送り、それらをパッケージに分解し、優先APIリクエストを受け取りました：彼らはそれを挿入し、写真を送りました。</font><font style="vertical-align: inherit;">パケットが欠落している場合でも、バッファから既製のAPIリクエストを取得できます。これは優先度が高く、すぐにクライアントに到達します。</font><font style="vertical-align: inherit;">TCPでは、定義により、ストリーミングデータ転送は不可能です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続を確立する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションをプロファイリングすると、ほとんどの場合、アプリケーションの開始時にネットワークがアイドル状態になっていることがわかります。最初に接続がAPIの前に確立され、次にデータを取得してから、画像の前に接続が確立され、このデータがダウンロードされます。これは常に起こります-ネットワークはピークによって利用されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/14/cn/ck/14cnckztbu1v-otwf__j9dqzahu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに対処するために、接続がどのように確立されるかを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/eb/ij/caebijcqzlqj0h5soblnfudqedo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つはDNSの解決です。これでは何もできません。次に、TCP接続を確立し、安全な接続を確立してから、要求を実行して応答を受信します。最も興味深いのは、リクエストに応答するときにサーバーが行う作業の一部は、通常、接続を確立するよりも時間がかかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、メモリ、ディスク、その他のレイテンシ数を測定することは非常にファッショナブルです。</font><font style="vertical-align: inherit;">これらを3G、4Gネットワ​​ークで測定し、最悪の場合にTLSとのTCP接続を確立するのにかかる時間を確認できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qe/ux/1p/qeux1p7brp9mvpxeptinhubywmc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それは数秒になる可能性があります！</font><font style="vertical-align: inherit;">4Gでも最大700 msは重要です。</font><font style="vertical-align: inherit;">しかし、TCPは今までそれほど簡単に生きることができませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続設定では、基本的な</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP 3ウェイハンドシェイク</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">syn、syn + ackを実行し、後で要求を修正します（図の左側）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/mj/-a/tymj-amfsa1c4j8sirtaspnvq1o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP高速オープン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（右）。</font><font style="vertical-align: inherit;">このサーバーで既にハンドフックしている場合は、Cookieがあります。RTTゼロのリクエストをすぐに送信できます。</font><font style="vertical-align: inherit;">これを使用するには、ソケットを作成し、sendto（）を最初のデータにする必要があります。たとえば、FASTOPENが必要だと言ってください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ab/kl/b9/abklb93dq3g__tw2rihxrhagkl8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginxはこれをすべて実行できます-オンにするだけで、すべてが機能します（またはカーネルでオンにします）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLSが悪いことを確認しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットシェーパーを再び200ミリ秒に設定し、google.comにpingを実行したところ、RTT = 220が私のRTT + RTTシェーパーであることがわかりました。</font><font style="vertical-align: inherit;">次に、HTTPとHTTPS経由でリクエストを行いました。</font><font style="vertical-align: inherit;">HTTP経由でRTT中に応答を取得できること、つまりTFOが私のコンピューターからGoogleで機能することがわかりました。</font><font style="vertical-align: inherit;">HTTPSの場合、これにはさらに時間がかかりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/po/hl/kj/pohlkjs39dl7kk3rp5kzbxrwsna.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、セキュアな接続を確立するためにメッセージングを必要とするような一般的なTLSオーバーヘッドです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/j2/qn/zfj2qndcohpiok8cqpc82kiun3s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うために、彼らはTLS 1.3を追加したと考えました。</font><font style="vertical-align: inherit;">nginxに含めるのも簡単です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/eo/i0/m5eoi0z5a2rzb4hthqlbjchxhyi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが機能しているようです。</font><font style="vertical-align: inherit;">しかし、これらすべてを活用するモバイルクライアントの内容を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客の状況</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCP Fast Openはすばらしいものです。統計によると。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pq/yy/l8/pqyyl89jhtoulpwalg61q8pqbnw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続の確立が10％速くなることが保証されていると言う記事はたくさんあります。しかし、Android 8.1.0（私はさまざまなデバイスを見ました）では、誰もTFOを持っていません。 Android 9では、エミュレーターでTFOを見ましたが、実際のデバイスでは見ていません。 IOSは少し優れています。これはあなたがそれを見ることができる方法です：</font></font><br>
<br>
<pre><code class="plaintext hljs">sysctl -a | grep fast<font></font>
<font></font>
net.ipv4.tcp_fastopen = 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそれが起こったのですか？ TCP Fast Openは2014年に提案されましたが、今ではすでに標準となっており、Linuxでサポートされており、すべてが優れています。しかし、一部のネットワークではTFOハンドシェイクが崩れ始めるという問題があります。これは、一部のプロバイダー（または一部のデバイス）がTCPの検査、最適化の実行に使用されており、TFOハンドシェイクが行われることを予期していなかったためです。したがって、その実装には非常に時間がかかり、現在まで、モバイルクライアントにはデフォルトで、少なくともAndroidには含まれていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLS 1.3を使用すると、RTTゼロの接続セットアップがさらに向上します。動作するAndroidデバイスは見つかりませんでした。 Facebookは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Fizz</font></a><font style="vertical-align: inherit;">ライブラリを作成しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">数か月前にオープンソースで利用可能になり、ドラッグしてTLS 1.3を使用できます。</font><font style="vertical-align: inherit;">セキュリティでさえドラッグする必要があることが判明しましたが、その中心には何も現れません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/qm/kf/07qmkfwywo3llz5nrrh04kg3a_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図は、モバイルクライアントによるAndroidのさまざまなバージョンの使用を示しています。</font><font style="vertical-align: inherit;">V 9.xはかなり-TFOが出現する可能性があり、TLS1.3は他のどこにも見つかりません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続の確立に関する結論：</font></font></strong><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFOは、95％のデバイスでは利用できません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS1.3はそれ自体と一緒に持ってくる必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これをUDPで繰り返す必要がある場合は、これをすべてUDPに転送して繰り返します。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/n2/tj/v1/n2tjv1g-04l2jfghy_6--uqaqjc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成された接続の97％が既存のキーを使用していることが判明しました。つまり、97％はゼロRTTに対して作成され、3％が新規であることがわかりました。</font><font style="vertical-align: inherit;">キーはしばらくの間デバイスに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPは自慢できません。</font><font style="vertical-align: inherit;">ケースの最大5％で、すべてを正しく行うと、誰もが今話している本当のゼロRTTを得ることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPアドレスの変更</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、家を出るとき、電話機はWi-Fiから4Gに切り替わります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPは次のよ​​うに機能します。IPアドレスが変更されました-接続に失敗しました。</font></font></blockquote><br>
<img src="https://habrastorage.org/webt/km/nu/u8/kmnuu8dtr8jeipuzx4bhpfezuwm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UDPプロトコルを記述する場合は非常に簡単です。各パケットに接続ID（CUID）を実装することにより、異なるIPアドレスからのものであっても識別できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xu/ga/r_/xugar_l9pbltv6419btnrimfhv8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼が正しいキーを持っていること、すべてが復号化されていることなどを確認する必要があることは明らかです。</font><font style="vertical-align: inherit;">しかし、原則として、あなたはこのアドレスに応答し始めることができます、これで問題はありません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPでは、IP移行は不可能です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UDPを作成し、同じサーバーにアクセスした場合は、少し魔法をかけ、CIDを各パケットに含める必要があります。IPアドレスを変更するときに、確立された接続を使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続の再利用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続は非常に高価なものであるため、接続を再利用する必要があると誰もが言います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8-/lr/ot/8-lrot44ac9mwo6m7ue_ksezk0g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、化合物の再利用には落とし穴があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_n/aa/z3/_naaz3uac-hwdd7uikndioiupry.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、多くの人</font><font style="vertical-align: inherit;">は誰もがパブリックアドレスを持っているわけで</font><font style="vertical-align: inherit;">はないことを覚えています（覚えていない場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">）が、通常はしばらくの間ホームルーターにマッピングを格納するNATがあります。</font><font style="vertical-align: inherit;">TCPの場合、どれだけ格納するかは明確ですが、UDPの場合は明確ではありません。</font><font style="vertical-align: inherit;">NATはタイムアウトで動作します。このタイムアウトを注意深く測定すると、約15〜30秒で接続の50％以上が失敗し始めることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大丈夫です-15秒間ピンポンパッケージを作成します。</font><font style="vertical-align: inherit;">それでも接続が切断される場合のために、IP移行があり、安価にルーターのポートを変更できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7g/mu/bf/7gmubflfj-yenwqvgiqbkc8toa8.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケットペーシング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UDPプロトコルを使用している場合、これは非常に重要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cf/d5/97/cfd597jt4v7uopygyyu-dfsx_8s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に単純な場合、パケットをネットワークに継続的に送信する時間が長くなるほど、パケット損失の可能性が高くなります。パケットをフィルターで除外すると、パケット損失が少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように機能するかについては多くの異なる理論がありますが、私はこれが好きです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/75/79/xl/7579xlvo70vmotoqjjp3zmmplr8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一度に作成される接続は3つあります。いわゆる初期ウィンドウがあり、10個のパッケージが同時に作成されます。もちろん、この時点では帯域幅が十分ではない可能性があります。しかし、それらを注意深く配布し、それらを分離すると、右の図のように、すべてがうまくいきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、パケットを送信するための一定のレートを設定し、それらを間引くと、1回限りのバッファオーバーフローが発生する可能性が低くなります。これは証明されていませんが、理論的には次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/mg/vw/vwmgvw6oyq3v_yaliklp4ilnocm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットをカットする必要がある場合（ペーシングを行う）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウを作成するとき。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、ウィンドウを拡大する場合、RTT / 2に送信できるパケットをできるだけ多く追加することをお勧めします。</font><font style="vertical-align: inherit;">これは配信時間を低下させませんが、パケット損失を減らします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輻輳損失の場合、ウィンドウを減らすには、パケットをさらにスミアする必要があります。</font><font style="vertical-align: inherit;">4/5 RTTは、経験的に選択された数値です。&nbsp;</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UDPプロトコルを作成するときは、MTUについて覚えておいてください。</font><font style="vertical-align: inherit;">MTUは、転送できるデータのサイズです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/7_/ow/c27_ow36h5amg3d4zkskjph_ama.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、サイズが1500のサーバーからクライアントにパケットを送信します。このMTUサイズをサポートしないルーターがパス上にある場合は、ルーターが断片化します。</font><font style="vertical-align: inherit;">フラグメンテーションの唯一の問題は、1つのパケットが失われた場合、両方が失われ、これをすべて再送信する必要があることです。</font><font style="vertical-align: inherit;">したがって、TCPにはMTU-PMTUを決定するアルゴリズムがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/gs/ks/jegskszkwrb3pm2nghgfpplez8o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ルーターは、インターフェイスのMTUを確認し、それを1つのクライアントに送信し、もう1つはクライアントに送信します。誰もがクライアント上にあるMTUの数を知っています。次にフラグメンテーションによってフラグメンテーションが禁止され、サイズMTUのパケットが送信されます。その時点でネットワーク内の誰かがMTUが少ないことに気付いた場合、ICMPを介して「申し訳ありませんが、フラグメント化が必要なため、パケットは失われました」とMTUのサイズを示します。このサイズを変更して発送を継続します。最悪の場合、オーバーヘッドはRTT / 2になります。これはTCPです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/br/fo/vlbrfo8a7p80neysmtjguosakww.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UDPでICMPに煩わされたくない場合は、通常のデータを送信するときに断片化を許可します。</font><font style="vertical-align: inherit;">つまり、断片化されたパケットを送信するには、それらを機能させます。</font><font style="vertical-align: inherit;">また、断片化を禁止するプロセスを開始するのと並行して、二分探索によって最適なMTUが選択されます。</font><font style="vertical-align: inherit;">最初はMTUがウォームアップするように見えるため、これは完全には効果的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よりトリッキーなオプションは、モバイルクライアント間のMTUの分布を確認することです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ie/a5/w8/iea5w8h3msrkprfxpgfhb2nkjyu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのクライアントから、断片化を禁止したさまざまなサイズのパケットを送信しました。</font><font style="vertical-align: inherit;">つまり、パケットが到達しない場合はドロップされ、最小MTUが100％に到達するはずです。</font><font style="vertical-align: inherit;">ただし、小さなパケット損失があるため、グラフには2つのスライドがあります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1350バイト-98％ではなく、95％がすぐに配信されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1500バイト-MTU。その後、クライアントの80％はそのようなパケットを受信しなくなります。</font></font></li>
</ol><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、私達はこれを言うことができます：私達は私達の顧客の1-2％を無視し、彼らに断片化されたパッケージで生きさせます。</font><font style="vertical-align: inherit;">しかし、すぐに必要なものから始めます-これは1350からです。</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラー訂正（SACK、NACK、FEC）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトコルを実行している場合は、エラーを修正する必要があります。</font><font style="vertical-align: inherit;">パケットが欠落している場合（これはワイヤレスネットワークでは正常です）、パケットを復元する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なケース（詳細は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）では、再送信タイムアウト（RTO）によるリレーがあります。</font><font style="vertical-align: inherit;">パケットが欠落している場合は、再送信時間を待って、再度送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のアルゴリズムは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast retransmit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これらはすべてTCPアルゴリズムですが、UDPに簡単に移植できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hm/s1/ee/hms1eey-ntpj2x0piswhxc4e5fa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットがなくなっても、送信を続けます-他のパケットの送信があります。このとき、サーバーは次のパケットを受信したと言いますが、前のパケットはありませんでした。これを行うために、彼はパッケージ番号+ 1と等しい注意深い確認を行い、重複確認フラグを設定します。彼はこれらのdup ackを送信し、3番目に、パケットがなくなったことを私たちは通常理解し、再度送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他に上品にしたいこと、TCPにないもの、UDPで何をすることを提案しているのは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forward Error Correction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ex/_u/gg/ex_uggyt0-4ntdgzy-vn7hvmyzg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージが失われる可能性があることがわかっている場合は、一連のパッケージを取得してXORパッケージを追加し、データを受信したときにクライアントですぐに再送信せずに問題を修正できます。しかし、いくつかのパッケージが消えると問題があります。パリティ保護やリードソロモンなどで解決できるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法で試したところ、実際にはパケットがバンドルで消えていることがわかりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fg/qo/jj/fgqojj1gas9pgutyyyzkla_m5ze.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平均のパケットギャップは6であることが判明しました。これは非常に不便なパケットギャップです。多くのエラー修正コードが必要です。同時に、なんらかのピークが11にあります-理由はわかりませんが、パケットが11パックで消えることがあります。このパケットギャップのため、これは機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グーグルもこれを試しました、誰もがFECの夢を見るが、今のところ誰も働いていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FECが役立つ別のオプションがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/tb/tw/d9tbtwafxbt_t08_j9wvarw5icc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再送信タイムアウト、高速再送信による再送信に加えて、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テールロスプローブ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もあり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。これはあなたがデータを送信するときにそのようなものであり、尾は消えています。つまり、データの一部を送信し、5番目のパケットを送信しました-到着しました。その後、たとえばネットワークに障害が発生したため、パケットが消失し始めました。パケットが消え、消え、5番目のパケットのみの確認が届きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータが到達したかどうかを理解するには、しばらくしてからTLP（テールロスプローブ）を開始し、終了を受信したかどうかを尋ねます。実際には、データ転送が終了し、何も送信していない場合、高速再送信は機能しません。これを修正するには、TLPを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLPにFECを追加できます。到着しなかったすべてのパケットを確認し、それらのパリティをカウントして、いくつかのパリティパケットでTLPを送信できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすべてクールで、うまくいくようです。</font><font style="vertical-align: inherit;">しかし、そのような問題があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pt/y5/qm/pty5qmye2nqwrocxnp3fv5-gll4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統計を収集したところ、エラーの98％が高速再送信によって修復されていることがわかりました。</font><font style="vertical-align: inherit;">残りは、再送信タイムアウトによって修復され、TLPを通じて1％未満です。</font><font style="vertical-align: inherit;">他のFECを修正すると、0.5％未満になります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPはFECをサポートしていません。</font><font style="vertical-align: inherit;">UDPではこれを行うのは難しくありませんが、一般的なケースでは、標準のTCP回復アルゴリズムで十分です。</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPとUDPを比較することで、パフォーマンスを低下させないことが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPは、LSO（ラージセグメントオフロード）やゼロコピーなど、さまざまな最適化を備えた非常に古いプロトコルです。</font><font style="vertical-align: inherit;">UDPでは現在、すべて使用できません。</font><font style="vertical-align: inherit;">したがって、UDPのパフォーマンスは、同じサーバーからのTCPに比べてわずか20％です。</font><font style="vertical-align: inherit;">しかし</font><font style="vertical-align: inherit;">、Linuxがこれをサポートできるようにする</font><font style="vertical-align: inherit;">既製のソリューション（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP GSO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zerocopy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">はすでにあります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
zerocopyおよびLSOの最適化をサポートする主な問題は、ペーシングが失われることです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/6i/th/qu6ith66mowy_jm9iznjsstsadm.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">市場投入までの時間またはTCPを殺したもの</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、モバイルワイヤレスネットワークが普及すると、TLP、TFO、新しい輻輳制御、RACK、BBRなど、さまざまなTCP標準が登場しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nq/lx/5a/nqlx5a_sq5zzvi2au81ulptczew.jpeg"><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、主な問題は、TCPが骨化していると言われているため、それらの多くが実装されていないことです。</font><font style="vertical-align: inherit;">多くの場合、オペレーターはTCPパケットを見て、期待どおりの結果を期待します。</font><font style="vertical-align: inherit;">したがって、変更することは非常に困難です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、モバイルクライアントは長い間更新されており、これらの更新を配信することはできません。</font><font style="vertical-align: inherit;">クライアントで利用できる最新の最新アップデートとサーバーのアップデートを見ると、クライアントにはほとんど何もないことがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/au/57/iw/au57iwnkvrjzkvrpo2osdo7f49e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、少なくともこれらすべての機能を蓄積している限り、ユーザー空間でプロトコルを作成するという決定はそれほど悪くはありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6i/o6/po/6io6poew2qopzofy3vbflm3-5a8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPを使用すると、機能が長年にわたって使用されています。</font><font style="vertical-align: inherit;">UDPプロトコルの場合、クライアントとサーバーの1回の更新で文字通りバージョンをアップグレードできます。</font><font style="vertical-align: inherit;">ただし、バージョンネゴシエーションを追加する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP vs自作UDP。</font><font style="vertical-align: inherit;">最後の戦い</font></font></h2><br>
<img src="https://habrastorage.org/webt/fx/q6/ct/fxq6ctnz94vaf7pfr7jmrcbz7lu.jpeg"><br>
<br>
<ul>
<li>Send/recv buffer:      mutable buffer,  TCP    buffer bloat.</li>
<li>Congestion control    .  UDP  .&nbsp;</li>
<li> Congestion control    TCP,     acknowledgement,       .</li>
<li> —  .  head-of-line blocking,         TCP.  HTTP2.0  TCP     .</li>
<li>,        0-RTT  TCP  ,  5 %,   97 %  self-made UDP.</li>
</ul><br>
<img src="https://habrastorage.org/webt/4f/_f/oe/4f_foen6zvxf5mexl8p6jfu2izm.jpeg"><br>
<br>
<ul>
<li>IP Migration —    ,             ,   TCP   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NATバインド解除はUDPを支持しません。</font><font style="vertical-align: inherit;">この場合、UDPはしばしばピンポンパケットを実行する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPのパケットペーシングは単純ですが、最適化はありませんが、TCPではこのオプションは機能しません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;MTUとエラー訂正はどちらも同等です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もちろん、大量のトラフィックを分散している場合、TCPの速度はUDPより高速です。</font><font style="vertical-align: inherit;">ただし、一部の最適化は、実行に非常に長い時間がかかります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要なものをすべて収集すると、UDPの方が短所よりも長所が多くなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p4/7k/ys/p47kysilkuqtb-x-zc0cwhigeoe.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPを選択してください！</font></font></b><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの自作UDPのテスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストベンチをまとめました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rh/er/ec/rherec8kewip9-ycek5qimdgvuw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPとUDPのクライアントがあります。</font><font style="vertical-align: inherit;">ネットシェイパーを介してトラフィックを正規化し、インターネットとサーバーに送信しました。</font><font style="vertical-align: inherit;">1つはREST APIサービス、もう1つはUDPを使用します。</font><font style="vertical-align: inherit;">また、UDPは同じデータセンター内の同じREST APIにアクセスしてデータをチェックします。</font><font style="vertical-align: inherit;">モバイルクライアントのさまざまなプロファイルを収集し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、テスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">開始しました</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sy/rf/nf/syrfnflhcgpr13bngr1y7cv5fle.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポータル全体の平均を測定すると、APIの呼び出し時間を10％、画像を7％削減できることがわかりました。</font><font style="vertical-align: inherit;">ユーザーアクティビティは1％しか増加しませんでしたが、あきらめません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o9/wr/bj/o9wrbjk45dk58yjji6t8boe9-xw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
負荷に関しては、自作のUDPに約1,000万人のユーザーがいて、最大80 Gb /秒のトラフィック、毎秒600万パケット、そして20台のサーバーすべてがこれに対応しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPチェックリスト</font></font><br>
</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトコルを作成する場合は、チェックリストが必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペーシング。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTUディスカバリー。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグ修正が必要です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロー制御と輻輳制御。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションで、IP移行をサポートできます。TLPは簡単です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャネルは非対称であり、サーバーからデータを受信して​​いる間、アップロードがアイドル状態になる可能性があることに注意してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUIC</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グーグルがそうしなかったと言うのは不誠実だろう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b9/-v/z0b9-v9kmmobln4nv2yado-rble.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GoogleがHTTP 2.0で実装したQUICプロトコルがあり、これはほとんど同じことをサポートしています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUICがそれほど速くない理由</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QUICが発表されたとき、Googleはすべてがより速く機能すると言っており、「自宅でコンピューター上で測定した-動作が遅い」という事実に対する多くの嫌悪がありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/db/5a/vd/db5avdtu1zaito8ntcmg-hdvwy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事には</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさんの写真と測定があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、私たちはこれすべてを無駄にしたことがわかりました、人々は私たちのために測定しましたか？</font><font style="vertical-align: inherit;">コード例を使用しても、実際のホーム測定があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/id/wr/39/idwr39saesks74hbadevlunieua.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、リクエストを並列化して実際のネットワークで作業し、パケット損失が輻輳損失とランダム損失に分かれるまで、改善はありません。</font><font style="vertical-align: inherit;">実際のネットワークの真のエミュレーションが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、QUICは良くも悪くもないというポジティブな点があると彼らは言う。</font><font style="vertical-align: inherit;">したがって、完全なネットワークでは、QUICは適切に機能します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未来</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Googleは最近、混乱しないようにQUIC HTTP 3の上にHTTP 2.0と名前を付けました。これは、HTTP 2.0がTCPおよびQUICの上にある可能性があるためです。</font><font style="vertical-align: inherit;">今では、HTTP 3で</font></font><br>
<br>
<img src="https://habrastorage.org/webt/go/ra/z4/goraz4ktgsje7ankwyipapzeow0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだあった</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グーグルQUIC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準化QUIC -これはChromeで実装されているQUICと、iQUICあります- 。</font><font style="vertical-align: inherit;">標準化されたQUICはどこにも実装されておらず、標準のiQUICサーバーはGoogle QUICとハンドシェイクしませんでした。</font><font style="vertical-align: inherit;">今、彼らはこの問題を解決することを約束し、すぐにそれが利用可能になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUICはどこにでもあります</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでもTCPが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">停止</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">していると思わない場合は、Chrome、Android、そしてまもなくiOSを使用し、google、youtubeなどにアクセスすると、QUICとUDP（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">prooflink</font></a><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用することになります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUIC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全ウェブサイトの1.9％;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全トラフィックの12％;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルネットワークのビデオトラフィックの30％。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信じられない場合にQUICを使用していることを確認するにはどうすればよいですか？</font><font style="vertical-align: inherit;">Chrome Wiresharkで開きます。</font><font style="vertical-align: inherit;">iQUICを探していましたが、どこにも見つかりませんでしたが、GQUICが発生しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t_/8v/9q/t_8v9qsq9jcgbjkf9vqqr67vw7k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラウザでネットワークにアクセスして、GQUICの内容を確認することもできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/av/ko/p5/avkop5nphmxm6ee3rqc2hi23wzu.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう少し未来</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチパスはすぐに私たちを待っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d8/bi/wo/d8biwobqjbdjqdn8g-wb7gegka0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wi-Fiと3Gの両方を備えたモバイルクライアントがある場合は、両方のチャネルを使用できます。</font><font style="vertical-align: inherit;">マルチパスTCPは現在開発中で、まもなくLinuxカーネルで利用可能になります。</font><font style="vertical-align: inherit;">明らかに、それはすぐには顧客に届かないでしょう、それはUDPではるかに速く行うことができると思います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pb/7o/yt/pb7oytnkrhutg6qtqlwq0jf3p4o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはそれぞれ3 TBの大量の翻訳を実行するため、同じコンテンツを世界中の多くのユーザーに配信する必要がある場合、CDNやp2p配布などのテクノロジーを頻繁に使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IPv6には、UDPを使用したマルチキャストがあり、サブスクライブした複数のユーザーに一度にパケットを配信できます。</font><font style="vertical-align: inherit;">したがって、マルチキャストを使用してすべてのコンテンツをIPv6に配信する場合、CDNおよびp2pテクノロジは近い将来必要なくなると思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
御理解いただけることを願います：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークが実際にどのように機能するか、およびそのTCPはUDP上で繰り返すことができ、より適切に実行できます。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのTCPは、正しく構成すればそれほど悪くはありませんが、実際にはあきらめ、ほとんど開発されていません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー空間では機能しないと言うUDP嫌悪者を信用しないでください。</font><font style="vertical-align: inherit;">これらの問題はすべて解決できます。</font><font style="vertical-align: inherit;">試してみてください-これは近い将来です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信じられない場合は、手でネットワークに触れることができます。</font><font style="vertical-align: inherit;">ほとんどすべてを確認できることを示しました。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはすべてを読み、次に何を考え出したのですか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状況（ネットワークプロファイル+負荷プロファイル）に応じてプロトコル（TCP、UDP-重要ではありません）を構成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私が言ったTCPレシピを使用してください：TFO、送信/受信バッファー、TLS1.3、CC ...&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースがあれば、UDPプロトコルを作成します。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPを実行した場合は、必要なすべてを実行したことをUDPチェックリストで確認します。</font><font style="vertical-align: inherit;">ペーシングのようなある種のナンセンスを忘れてください、それはうまくいきません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースがない場合は、QUIC用のインフラストラクチャを準備します。</font><font style="vertical-align: inherit;">遅かれ早かれ彼はあなたのところに来るでしょう。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは未来を決定しています。</font><font style="vertical-align: inherit;">使用するプロトコルを決定します。</font><font style="vertical-align: inherit;">QUICを使用する場合-QUICを使用する場合、UDPを使用する場合、またはTCPを使用する場合-自分で将来を決定します。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1日あたり100万回のビデオ通話、または「ママに電話する」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPの上にプロトコルを作成しています</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク最適化に関するポッドキャスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不良ネットワークでのデータ転送速度を上げます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br>
<blockquote> 7    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">HighLoad++</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>  ,         .     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>      , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>,    ,       .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja461817/index.html">CMakeとC ++-永遠の兄弟</a></li>
<li><a href="../ja461819/index.html">シンプルなウェブサイトのデザインが科学的に優れている理由</a></li>
<li><a href="../ja461821/index.html">新しい免疫療法は転移性乳がんの女性のすべての腫瘍を除去しました</a></li>
<li><a href="../ja461823/index.html">ソフトウェア設計の4つのルールの強化</a></li>
<li><a href="../ja461827/index.html">ハイブリッドPHP / RoadRunnerを使用したGoアプリケーション開発</a></li>
<li><a href="../ja461831/index.html">StealthWatch：展開とカスタマイズ。パート2</a></li>
<li><a href="../ja461833/index.html">3つのマツで迷子にならないでください：環境の自己中心的な表現</a></li>
<li><a href="../ja461845/index.html">財政を維持する方法としての交換への投資：3つの作業方法</a></li>
<li><a href="../ja461849/index.html">﻿PVS-StudioがRed Dead Redemptionエンジンをちらりと見た-Bullet</a></li>
<li><a href="../ja461851/index.html">ブロックチェーンと電気</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>