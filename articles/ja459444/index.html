<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎤 🍿 📲 DBAの観点から見たLinux IOスタックの最近の変更 🤛🏿 👩🏿 🏞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="データベースの操作に関する主な問題は、データベースが動作するオペレーティングシステムのデバイスの機能に関連しています。Linuxは現在、データベースの主要なオペレーティングシステムです。Solaris、Microsoft、さらにはHPUXも企業で使用されていますが、組み合わせたとしても、それらが最初...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DBAの観点から見たLinux IOスタックの最近の変更</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/459444/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースの操作に関する主な問題は、データベースが動作するオペレーティングシステムのデバイスの機能に関連しています。</font><font style="vertical-align: inherit;">Linuxは現在、データベースの主要なオペレーティングシステムです。</font><font style="vertical-align: inherit;">Solaris、Microsoft、さらにはHPUXも企業で使用されていますが、組み合わせたとしても、それらが最初になることは決してありません。</font><font style="vertical-align: inherit;">Linuxは、オープンソースのデータベースがますます増えているため、自信をもって定着しています。</font><font style="vertical-align: inherit;">したがって、OSとのデータベースの相互作用の問題は、明らかにLinuxデータベースに関するものです。</font><font style="vertical-align: inherit;">これは、データベースの永遠の問題であるIOパフォーマンスに重なっています。</font><font style="vertical-align: inherit;">近年のLinuxでは、IOスタックの大幅な見直しが行われており、啓蒙の期待が高まっています。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/0o7uNUOS-Ho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イリヤコスモデヤンスキー（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイドロビオント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）PostgreSQLのコンサルティングとサポートを行っているData Egret会社で働いており、OSとデータベースの相互作用について多くを知っています。</font><font style="vertical-align: inherit;">HighLoad ++のレポートで、IlyaはPostgreSQLの例を使用してIOとデータベースの相互作用について話しましたが、他のデータベースがIOでどのように機能するかも示しました。</font><font style="vertical-align: inherit;">私はLinux IOスタックを見て、そこに新しくて良いものは何だったのか、そしてなぜすべてが数年前のようになっていないのかを見てみました。</font><font style="vertical-align: inherit;">新しいカーネルでのIOサブシステムのパフォーマンスを最大にするためのPostgreSQLおよびLinux設定のチェックリスト。</font></font><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートビデオには多くの英語が含まれており、そのほとんどは記事で翻訳しました。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜIOについて話すのですか？</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速I / Oは、データベース管理者にとって最も重要なものです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">CPUの操作で何が変更できるか、メモリを拡張できることは誰もが知っていますが、I / Oはすべてを台無しにする可能性があります。</font><font style="vertical-align: inherit;">ディスクに問題があり、I / Oが多すぎる場合、データベースはうめき声を上げます。</font><font style="vertical-align: inherit;">IOがボトルネックになります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを適切に機能させるには、すべてを構成する必要があります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースやハードウェアだけでなく、それだけです。それ自体が一部の場所ではオペレーティングシステムである高レベルのOracleでさえ、構成が必要です。 Oracleの「インストールガイド」の説明を読みます。そのようなカーネルパラメータを変更し、他のパラメータを変更します-多くの設定があります。 Unbreakable Kernelでは、デフォルトで多くのものがOracle Linuxに接続されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLとMySQLでは、さらに多くの変更が必要です。これは、これらのテクノロジーがOSメカニズムに依存しているためです。 PostgreSQL、MySQL、または最新のNoSQLを使用するDBAは、Linuxのオペレーションエンジニアであり、さまざまなOSの基本を変更する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネル設定を扱いたい人は誰でも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LWNを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使います</font><font style="vertical-align: inherit;">。リソースは独創的で最小限のものであり、多くの有用な情報が含まれていますが、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネル開発者のためにカーネル開発者によって書かれました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">カーネル開発者は何を上手に書いていますか？</font><font style="vertical-align: inherit;">記事ではなく、コアの使用方法。</font><font style="vertical-align: inherit;">したがって、私は開発者のためにあなたにすべてを説明して、彼らにカーネルを書かせるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初はLinuxカーネルの開発とそのスタックの処理が遅れていたという事実により、すべてが何度も複雑になり、近年では非常に急速に進んでいます。</font><font style="vertical-align: inherit;">彼の後ろに記事があるアイアンも開発者も追いつきません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的なデータベース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLの例から始めましょう—バッファI / Oはこちらです。</font><font style="vertical-align: inherit;">OSの観点から</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー空間に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当てられた共有メモリ</font><font style="vertical-align: inherit;">を持ち、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネル空間の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネルキャッシュに同じキャッシュを持ってい</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jd/dh/d2/jddhd25l97pocaqtqqf6ccygcxi.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のデータベースの主なタスク</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ内のディスクからページを取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更が発生したら、ページをダーティとしてマークします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先行書き込みログへの書き込み。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、メモリを同期して、ディスクとの一貫性を保ちます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLの状況では、これは一定の往復です。ページキャッシュカーネルでPostgreSQLが制御する共有メモリから、Linuxスタック全体を介してディスクへと。</font><font style="vertical-align: inherit;">ファイルシステムでデータベースを使用する場合、UNIXライクなシステムとデータベースでこのアルゴリズムを使用できます。</font><font style="vertical-align: inherit;">違いはありますが、重要ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oracle ASMの使用方法は異なります。Oracle自体がディスクと対話します。</font><font style="vertical-align: inherit;">ただし、原則は同じです。ダイレクトIOでもページキャッシュでも、タスクは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、I / Oスタック全体が</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何であれ、</font><strong><font style="vertical-align: inherit;">ページ全体をすばやく描画</font></strong><font style="vertical-align: inherit;">することです。</font><font style="vertical-align: inherit;">そして、あらゆる段階で問題が発生する可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOの2つの問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取り専用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、問題はありません。読み取り、十分なメモリがある場合は、読み取る必要のあるすべてのデータがRAMに配置されます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファキャッシュ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内のPostgreSQLの場合</font><font style="vertical-align: inherit;">も同じである</font><font style="vertical-align: inherit;">という事実</font><font style="vertical-align: inherit;">は、あまり心配していません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mh/0j/sm/mh0jsmmdrh5bosmamuaiko9l-jw.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOの最初の問題は、キャッシュの同期です。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記録が必要な場合に発生します。この場合、より多くのメモリを前後にドライブする必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/mw/u7/tqmwu7fy-wlwqjx6nxec6jfcyrk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべてが共有メモリからディスクに到達するようにPostgreSQLまたはMySQLを構成する必要があります。 PostgreSQLの場合-Linuxでダーティページのバックグラウンドのチートを微調整して、すべてをディスクに送信する必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の一般的な問題は、ログ先行書き込みの失敗です。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">負荷が非常に高いため、連続して記録されたログでさえディスクに残っている場合に表示されます。</font><font style="vertical-align: inherit;">この状況では、それも迅速に記録する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュの同期</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と大差ありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">PostgreSQLでは、多数の共有バッファを使用しています。データベースには、効率的な先行書き込みログ記録のためのメカニズムがあり、限界に最適化されています。</font><font style="vertical-align: inherit;">ログ自体をより効率的にするために実行できる唯一のことは、Linux設定を変更することです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースでの作業の主な問題</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有メモリセグメントは非常に大きくなる可能性があります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私は2012年の会議でこれについて話し始めました。次に、32 GBのRAMを搭載したサーバーがあっても、メモリの価格が下がったと言いました。 2019年には、ラップトップがすでに増えている可能性があり、128、256などのサーバーが増えている可能性があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当にたくさんのメモリ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。バナルレコーディングには時間とリソースがかかり</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これに使用するテクノロジーは保守的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。データベースは古く、長い間開発されてきており、ゆっくりと進化しています。データベースのメカニズムは、最新のテクノロジーでは完全に正しくありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ内のページをディスクと同期すると、膨大なIO操作が発生し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。キャッシュを同期すると、IOのストリームが大きくなり、別の問題が発生します-</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かをひねって効果を見ることはできません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科学実験では、研究者は1つのパラメーターを変更します-効果を得る、2番目-効果を得る、3番目。私たちは成功しません。 PostgreSQLのいくつかのパラメータをひねり、チェックポイントを設定します-効果は確認できませんでした。次に、少なくとも一部の結果を取得するために、スタック全体を再度構成します。ツイスト1つのパラメーターは機能しません-すべてを一度に構成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのPostgreSQL IOは、ページ同期、つまりチェックポイントやその他の同期メカニズムを生成します。 PostgreSQLを使用していた場合、チャートに「のこぎり」が定期的に表示されるときにチェックポイントが急上昇することがあります。以前は多くの人がこの問題に直面していましたが、今ではそれを修正する方法のマニュアルがあり、簡単になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日のSSDは状況を大幅に節約します。</font><font style="vertical-align: inherit;">PostgreSQLでは、値レコードに直接依存するものはほとんどありません。</font><font style="vertical-align: inherit;">すべては同期に依存します。チェックポイントが発生すると、fsyncが呼び出され、あるチェックポイントが別のチェックポイントに「当たる」ようなものになります。</font><font style="vertical-align: inherit;">IOが多すぎます。</font><font style="vertical-align: inherit;">1つのチェックポイントはまだ終了しておらず、すべてのfsyncを完了していませんが、すでに別のチェックポイントを獲得しており、開始しました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLには独自の機能、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autovacuumがあり</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、データベースアーキテクチャの松葉杖の長い歴史です。</font><font style="vertical-align: inherit;">autovacuumが失敗した場合、通常は積極的に動作し、残りを妨げないように設定されます。autovacuumワーカーは多数あり、頻繁にトリガーして、テーブルをすばやく処理します。</font><font style="vertical-align: inherit;">そうしないと、DDLとロックに問題が発生します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、Autovacuumがアグレッシブである場合、IOを噛み始めます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動バキュームがチェックポイントに重ねられている場合、ほとんどの場合、ディスクはほぼ100％リサイクルされており、これが問題の原因です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙なことに、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュのリフィルの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題があり</font><font style="vertical-align: inherit;">ます。彼女は通常DBAについてあまり知られていない。典型的な例：データベースが起動し、しばらくの間、すべてが悲しく遅くなります。したがって、RAMがたくさんある場合でも、スタックがキャッシュをウォームアップできるように、適切なディスクを購入してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらはすべてパフォーマンスに深刻な影響を与えます。問題は、データベースを再起動した直後ではなく、後で開始します。たとえば、チェックポイントに合格し、データベース全体で多くのページがダーティです。同期する必要があるため、ディスクにコピーされます。次に、クエリはディスクから新しいバージョンのページを要求し、データベースはサグします。グラフは、各チェックポイントが特定の割合でロードに貢献した後のキャッシュの補充方法を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの入出力で最も不愉快なのは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワーカーIOです。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストする各ワーカーがIOの生成を開始すると、 Oracleではそれは簡単ですが、PostgreSQLでは問題です。</font><strong><font style="vertical-align: inherit;">ワーカーIO</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の問題の原因</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさん：ディスクから新しいページを「ポスト」するのに十分なキャッシュがありません。</font><font style="vertical-align: inherit;">たとえば、すべてのバッファが共有されている、それらがすべてダーティである、チェックポイントがまだされていないことが起こります。</font><font style="vertical-align: inherit;">ワーカーが最も単純な選択を実行するためには、どこかからキャッシュを取得する必要があります。</font><font style="vertical-align: inherit;">これを行うには、まずすべてをディスクに保存する必要があります。</font><font style="vertical-align: inherit;">特別なチェックポインタープロセスがないため、ワーカーがfsyncを開始して、解放して新しいものを入力します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、さらに大きな問題が発生します。ワーカーは特殊なものではなく、プロセス全体がまったく最適化されていません。</font><font style="vertical-align: inherit;">Linuxレベルのどこかで最適化することは可能ですが、PostgreSQLではこれは緊急対策です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBの主なIOの問題</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かをセットアップするときにどのような問題を解決しますか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスクとメモリ間のダーティページの移動を最大化したいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらのものがディスクに直接触れないことがよくあります。</font><font style="vertical-align: inherit;">典型的なケース-非常に大きな負荷平均が表示されます。</font><font style="vertical-align: inherit;">何故ですか？</font><font style="vertical-align: inherit;">誰かがディスクを待っているので、他のすべてのプロセスも待っています。</font><font style="vertical-align: inherit;">ディスクの明示的なディスク使用率はなく、何かがディスクをブロックしているようです。問題はとにかく入出力にあります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースI / Oの問題は、常にディスクだけに関係するわけではありません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題には、ディスク、メモリ、CPU、IOスケジューラ、ファイルシステム、データベース設定など、すべてが関係しています。</font><font style="vertical-align: inherit;">次に、スタックを調べて、何をすべきか、そしてすべてがよりよく機能するようにLinuxで発明された優れた点を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長年の間、ディスクはひどく遅く、遷移段階の待ち時間や最適化に誰も関与していませんでした。</font><font style="vertical-align: inherit;">fsyncの最適化は意味がありませんでした。</font><font style="vertical-align: inherit;">ディスクは回転しており、ヘッドは蓄音機のレコードのようにその上を動いており、fsyncは非常に長いため、問題は表面化しませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースを調整せずに上位のクエリを確認しても意味がありません。</font><font style="vertical-align: inherit;">十分な量の共有メモリなどを構成すると、新しい上位クエリが作成されます-再度構成する必要があります。</font><font style="vertical-align: inherit;">これは同じ話です。</font><font style="vertical-align: inherit;">Linuxスタック全体は、この計算から作成されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帯域幅と待ち時間</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スループットを最大化することによってIOパフォーマンスを最大化することは、ある程度まで簡単です。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックポイントをアンロードするヘルパーPageWriterプロセスがPostgreSQLで発明されました。作業は並列化されましたが、並列処理を追加するための基礎がまだあります。そして、レイテンシを最小限に抑えることは、ラストマイルの仕事であり、スーパーテクノロジーが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのスーパーテクノロジーはSSDです。彼らが現れたとき、待ち時間は急激に落ちました。しかし、スタック問題の他のすべての段階で、データベースのメーカー側とLinuxのメーカーの両方から問題が発生しました。問題に対処する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの開発は、Linuxカーネルの開発と同様に、スループットの最大化を中心に行われました。多くのスピンディスクI / O最適化手法は、SSDにはあまり適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その間に、現在のLinuxインフラストラクチャのバックアップを余儀なくされましたが、新しいディスクが必要でした。</font><font style="vertical-align: inherit;">多数の異なるIOPSを使用して製造元からのパフォーマンステストを監視しましたが、データベースはIOPSだけではなく、それほど多くないため、データベースはこれ以上向上しませんでした。</font><font style="vertical-align: inherit;">1秒あたり50,000 IOPSをスキップできることがよくあります。これは良いことです。</font><font style="vertical-align: inherit;">しかし、レイテンシがわからない、その分布がわからない場合、パフォーマンスについては何も言えません。</font><font style="vertical-align: inherit;">ある時点で、データベースのチェックポイントが始まり、レイテンシが劇的に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い間、今のように、これはデータベース仮想マシンの大きなパフォーマンスの問題でした。</font><font style="vertical-align: inherit;">仮想IOは、むらのある待ち時間によって特徴付けられますが、もちろん問題も伴います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOスタック。</font><font style="vertical-align: inherit;">以前と同じように</font></font></h2><br>
<img src="https://habrastorage.org/webt/yl/3v/oz/yl3vozgbt2ltrkqo8lbey-wzdfo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザー空間があります-そのメモリは、データベース自体によって管理されています。すべてが正常に機能するように構成されたDB内。これについては、1つではなく、個別にレポートを作成できます。次に、必然的にすべてがページキャッシュまたはダイレクトIOインターフェイスを経由して</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック入力/出力層に入り</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルシステムインターフェイスを想像してください。バッファキャッシュにあったページは、もともとデータベースにあったので、ブロックです。ブロックIOレイヤーは次のことを行います。カーネル内のブロックを記述するC構造があります。構造体はこれらのブロックを受け取り、それらから入力または出力要求のベクトル（配列）を収集します。 BIOレイヤーの下はリクエスターレイヤーです。ベクトルはこのレイヤーに集まり、続行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い間、Linuxのこれら2つのレイヤーは、磁気ディスクへの効率的な記録のために研ぎ澄まされてきました。</font><font style="vertical-align: inherit;">移行なくしては不可能でした。</font><font style="vertical-align: inherit;">データベースから管理するのに便利なブロックがあります。</font><font style="vertical-align: inherit;">これらのブロックをベクトルに組み立てて、ディスクに書き込めるようにして、近くのどこかに配置されるようにする必要があります。</font><font style="vertical-align: inherit;">これが効果的に機能するために、彼らはエレベーター、またはスケジューラーIOを思い付きました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エレベーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エレベーターは主にベクトルの組み合わせと分類に関与していました。</font><font style="vertical-align: inherit;">SDブロックドライバー-疑似ディスクドライバー-記録ブロックが便利な順序で到着するために必要なすべてのこと。</font><font style="vertical-align: inherit;">ドライバーはブロックからセクターに変換され、ディスクに書き込まれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、いくつかの移行を行う必要があり、それぞれに最適なプロセスの独自のロジックを実装することでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エレベーター：カーネル2.6まで</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネル2.6以前は、Linus Elevatorがありまし</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た。これは、最も原始的なIOスケジューラであり、誰が書いたのかと思います。</font><font style="vertical-align: inherit;">彼らが新しい何かを開発するまで、長い間、彼は絶対に揺るぎなくて良いと考えられていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linus Elevatorには多くの問題がありました。</font><strong><font style="vertical-align: inherit;">より効率的に録音する方法に従って、</font></strong></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼は結合してソートしました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">回転する機械式ディスクの場合、これ</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">「</font><strong><font style="vertical-align: inherit;">飢餓」の</font></strong><font style="vertical-align: inherit;">出現に</font><font style="vertical-align: inherit;">つながりました</font><font style="vertical-align: inherit;">。つまり、記録効率がディスクの回転に依存する状況です。</font><font style="vertical-align: inherit;">突然同時に効率的に読み取る必要があるが、すでに誤って回転している場合、そのようなディスクからの読み取りは不十分です。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
徐々に、これは非効率的な方法であることが明らかになりました。</font><font style="vertical-align: inherit;">そのため、カーネル2.6以降、さまざまなタスクを対象としたスケジューラ全体の動物園が登場し始めました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エレベーター：2.6〜3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのスケジューラーは類似した名前を持っているため、オペレーティングシステムのスケジューラーと混同されます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CFQ-完全に公平なキューイング</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はOSスケジューラーと同じではありません。名前だけが似ています。それは普遍的なスケジューラとして発明されました。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルスケジューラとは</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均的な負荷、または逆にユニークな負荷があると思いますか？データベースの汎用性は非常に貧弱です。ユニバーサルロードは、通常のラップトップと考えることができます。すべてがそこで起こります。音楽を聴いたり、演奏したり、テキストを入力したりします。このため、ユニバーサルスケジューラだけが作成されました。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルスケジューラの主なタスク：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linuxの場合は、仮想端末とプロセスごとにリクエストキューを作成します。オーディオプレーヤーで音楽を聴きたい場合は、プレーヤーのIOがキューに入れられます。 cpコマンドを使用して何かをバックアップしたい場合は、別のものが関係しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの場合、問題が発生します。原則として、データベースは開始されたプロセスであり、操作中に並列プロセスが発生し、常に同じI / Oキューで終了します。これは、これが同じアプリケーション、同じ親プロセスであるためです。非常に小さな負荷の場合、このようなスケジューリングは適切でしたが、それ以外の場合は意味がありませんでした。オフにして、可能であれば使用しない方が簡単でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
徐々に登場する</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドラインスケジューラ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-トリッキーに機能しますが、基本的には回転ディスクのマージとソートです。特定のディスクサブシステムの設計を前提として、ブロックベクトルを収集して最適な方法で書き込みます。彼は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">飢餓の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題が少なかった</font><font style="vertical-align: inherit;">が、彼らはそこにいた。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、3番目のLinuxカーネルに近いほど、</font><strong><font style="vertical-align: inherit;">何も</font></strong><font style="vertical-align: inherit;">動作し</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">、</font><strong><font style="vertical-align: inherit;">まったく</font></strong><font style="vertical-align: inherit;">表示され</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませんでした</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、SSDの普及に伴って非常によく機能しました。スケジューラーのnoopを含めて、実際にはスケジューリングを無効にします。CFQと期限が行ったような並べ替え、マージ、および同様のことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSDは本質的に並列であるため、これはSSDでよりよく機能します。SSDにはメモリセルがあります。 1つのPCIeボードに詰め込むこれらの要素が多いほど、より効率的に機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSDの観点から、異世界のいくつかからのスケジューラー、考慮事項、いくつかのベクトルを収集してどこかに送信します。</font><font style="vertical-align: inherit;">それはすべてじょうごで終わります。</font><font style="vertical-align: inherit;">したがって、SSDの同時実行性を無効にします。SSDを最大限に使用しないでください。</font><font style="vertical-align: inherit;">したがって、単純なシャットダウンは、ベクトルが並べ替えなしでランダムに移動するときに、パフォーマンスの点でよりよく機能しました。</font><font style="vertical-align: inherit;">このため、SSDではランダム読み取り、ランダム書き込みの方が優れていると考えられています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エレベーター：3.13以降</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネル3.13以降、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqが登場しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。少し前にプロトタイプがありましたが、3.13で動作するバージョンが最初に登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mq</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をスケジューラー</font><font style="vertical-align: inherit;">として始めました</font><font style="vertical-align: inherit;">が、それをscheduler'omと呼ぶことはほとんどできません-構造的にそれは独立しています。これは、カーネルの要求層の代替です。ゆっくりと、blk-mqはLinux I / Oスタック全体の大幅な再設計につながりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアはこれです：SSDのネイティブ機能を使用して、I / Oの効率的な同時実行を実行しましょう。使用できる並列I / Oストリームの数に応じて、SSDにそのまま書き込む単純なキューがあります。各CPUには、記録用の独自のキューがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mq</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">積極的に開発し、働いています。</font><font style="vertical-align: inherit;">使用しない理由はありません。</font><font style="vertical-align: inherit;">最近のコアでは、4以上から、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqから、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5-10％ではなく、大幅に向上しています。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqは、SSDを操作するためのおそらく最良のオプションです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の形式では、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqは</font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバーLinuxに</font><font style="vertical-align: inherit;">直接関連付けられてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Linux用のドライバーだけでなく、Microsoft用のドライバーもあります。</font><font style="vertical-align: inherit;">しかし、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mq</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とNVMeドライバー</font><font style="vertical-align: inherit;">を作成するという考えは</font><font style="vertical-align: inherit;">、データベースに大きなメリットをもたらしたLinuxスタックの処理そのものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの企業のコンソーシアムが仕様、つまりまさにこのプロトコルを作成することを決定しました。</font><font style="vertical-align: inherit;">現在、本番バージョンはすでにローカルPCIe SSDで正常に動作しています。</font><font style="vertical-align: inherit;">光学系を介して接続されているディスクアレイのほぼ準備が整ったソリューション。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqドライバーとNVMeは単なるスケジューラーではありません。</font><font style="vertical-align: inherit;">システムは、要求のレベル全体を置き換えることを目的としています。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを理解するために詳しく見てみましょう。</font><font style="vertical-align: inherit;">NVMe仕様は大きいので、すべての詳細を検討するのではなく、詳細を検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エレベーターへの古いアプローチ</font></font></h3><br>
<img src="https://habrastorage.org/webt/ya/82/ou/ya82oun8cusxylg0bsuz5y0e1la.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なケース：CPUがあり、その順番があり、どういうわけかディスクに行きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より高度なエレベーターの動作は異なります。</font><font style="vertical-align: inherit;">いくつかのCPUといくつかのキューがあります。</font><font style="vertical-align: inherit;">どういうわけか、たとえば、データベースワーカーがスピンオフした親プロセスに応じて、IOはディスクのキューに入れられます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エレベーターへの新しいアプローチ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
blk-mqは完全に新しいアプローチです。</font><font style="vertical-align: inherit;">各CPU、各NUMAゾーンは、その入力/出力を順番に追加します。</font><font style="vertical-align: inherit;">さらに、ドライバーは新しいため、接続方法に関係なく、データはディスクに格納されます。</font><font style="vertical-align: inherit;">シリンダー、ブロックの概念で動作するSDドライバーはありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/12/7n/zf127n1eqhli2qioregzrsiftp8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移行期間がありました。</font><font style="vertical-align: inherit;">ある時点で、RAIDアレイのすべてのベンダーが、RAIDキャッシュをバイパスできるアドオンを販売し始めました。</font><font style="vertical-align: inherit;">SSDが接続されている場合は、そこに直接書き込みます。</font><font style="vertical-align: inherit;">彼らは、blq-mqなどの自社製品のSDドライバーの使用をオフにしました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqを使用した新しいスタック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、スタックが新しい形式でどのように見えるかです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/me/ma/3e/mema3e595wllaoub6thn61q8kvu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上からすべても残っています。たとえば、データベースははるかに遅れています。以前と同様にデータベースからの入力/出力は、ブロックIOレイヤーに分類されます。</font><font style="vertical-align: inherit;">スケジューラではなく、クエリレイヤーを置き換える</font><font style="vertical-align: inherit;">非常に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mq</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネル3.13では、ここで全体の最適化が終了しましたが、最新のカーネルは新しいテクノロジーを使用しています。</font><font style="vertical-align: inherit;">より強力な並列処理のために設計さ</font><font style="vertical-align: inherit;">れた</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mqの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なスケジューラーが登場し始めました</font><font style="vertical-align: inherit;">。最近の4番目のLinuxカーネルでは、2つのIOスケジューラが成熟していると見なされます。これらは、KyberとBFQです。これらは、並行性と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blk-mq</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で動作するように設計されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFQ </font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-予算フェアキューイングは-である</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナログ</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FQ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらは完全に異なりますが、一方は他方から成長しました。 BFQは、複雑な計算を行うスケジューラーです。各アプリケーションとプロセスには、IOの特定の割り当てがあります。割り当ては、プロセス/アプリケーションが生成するIOの量によって異なります。この予算によると、私たちは私たちが書くストリップを持っています。これがどれだけうまく機能するかは難しい質問です。 BFQに興味がある場合は、プロセスの数学を扱った記事がたくさんあります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カイバーは代替</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。 BFQに似ていますが、数学はありません。 Kyberには、コードの量の分だけ小さなスケジューラーがあります。その主なタスクは、CPUから受信して送信することです。 Kyberはより軽く、よりよく機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタック全体の重要なポイント</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-blk-mqはSDドライバーを調べません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">別の変換レイヤーはありません。以前にIOスタックがどのように見えるかを示したときに不満を感じました。</font><font style="vertical-align: inherit;">すべてがblk-mqからNVMeドライバーにすぐに送られます。</font><font style="vertical-align: inherit;">シリンダーへのブロックは再計算されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいアプローチでは、いくつかの興味深い点が発生しました。このレイヤーを含めて、レイテンシは大幅に低下しました。</font><font style="vertical-align: inherit;">最初にうまく機能したSSDが登場しました—このレイヤーをリサイクルすることが可能でした。</font><font style="vertical-align: inherit;">前後の変換を停止するとすぐに、NVMeレイヤーとblk-mqの両方にボトルネックがあり、これらも最適化する必要がありました。</font><font style="vertical-align: inherit;">それでは、それらについて話しましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux IOスタック図</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thomas Krennは常に更新された最新の</font><font style="vertical-align: inherit;">Linux I / O </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタック図</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持ってい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ak/05/qb/ak05qbritsgbiaeybq3dmz2mpyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図は、誰が誰の上に立っているか、ドライバー間の関係、どのエレベーター、どのレイヤーの一部であるかを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャートは定期的に更新されます。これにより、データベース管理者やデータベースを扱うその他の専門家のカーネルの進化を監視できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVM Express仕様</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVM ExpressまたはNVMeは仕様であり、SSDをより効果的に使用するための一連の標準です。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様はLinuxに適切に実装されています。</font><font style="vertical-align: inherit;">Linuxは標準の原動力の1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在生産中の3番目のバージョンです。</font><font style="vertical-align: inherit;">仕様によると、このバージョンのドライバーは、1つのSSDブロックあたり約20 GB /秒、および</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大32 GB /秒の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだ利用できないNVMe 5番目のバージョンを渡すことができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">SDドライバーには、そのような帯域幅を提供するための内部インターフェースもメカニズムもありません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この仕様は、以前のものよりも大幅に高速です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースが回転ディスク用に作成され、それらに向けられると、たとえば、Bツリーの形式でインデックスが作成されます。</font><font style="vertical-align: inherit;">問題は発生</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><strong><font style="vertical-align: inherit;">データベースはNVMeの準備ができています</font></strong><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">データベースはそのような負荷をかじることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだですが、順応しています。</font><font style="vertical-align: inherit;">PostgreSQLメーリングリストは最近、いくつかのコミット</font></font><code>pwrite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やそのようなことをしました。</font><font style="vertical-align: inherit;">PostgreSQLおよびMySQL開発者はカーネル開発者と対話します。</font><font style="vertical-align: inherit;">もちろん、もっと交流したいです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近の進展</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過去1年半にわたって、NVMeは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOポーリング</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を追加しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、待ち時間の長い回転ディスクがありました。次に、より高速なSSDが登場しました。しかし、わき柱がありました：fsyncが続行し、記録が開始し、非常に低いレベルで-ドライバーの奥深くで、要求がハードウェアに直接送信されます-書き留めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メカニズムは単純でした-彼らはそれを送信し、割り込みが処理されるまで待機します。回転ディスクへの書き込みと比較して、割り込み処理の待機は問題ではありません。レコーディングが終了するとすぐに割り込みが機能するのを待つのにとても時間がかかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSDは非常に高速に書き込みを行うため、録音に関する鉄片をポーリングするメカニズムが強制的に登場しました。最初のバージョンでは、中断を待っていなかったため、入力/出力速度の増加は50％に達しましたが、積極的にこの問題についてアイアンに質問しています。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このメカニズムはIOポーリングと呼ばれ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近のバージョンで導入されました。バージョン4.12では、</font><strong><font style="vertical-align: inherit;">blk-mq</font></strong><font style="vertical-align: inherit;">とNVMeを操作する</font><font style="vertical-align: inherit;">ために特別に</font><strong><font style="vertical-align: inherit;">強化さ</font></strong><font style="vertical-align: inherit;">れた</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOスケジューラー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が登場し</font><strong><font style="vertical-align: inherit;">ました</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これについては</font><strong><font style="vertical-align: inherit;">、KyberとBFQ</font></strong><font style="vertical-align: inherit;">について述べ</font><strong><font style="vertical-align: inherit;">ました</font></strong><font style="vertical-align: inherit;">。それらはすでに公式にカーネルにあり、使用できます。</font><font style="vertical-align: inherit;">
現在、使用可能な形式で、いわゆる</font><strong><font style="vertical-align: inherit;">IOタギングがあります。</font></strong></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">主にクラウドと仮想マシンのメーカーがこの開発に貢献します。</font><font style="vertical-align: inherit;">大まかに言えば、特定のアプリケーションからの入力は、攻撃され、それに優先順位を付けることができます。</font><font style="vertical-align: inherit;">データベースはまだこの準備ができていませんが、しばらくお待ちください。</font><font style="vertical-align: inherit;">もうすぐ主流になると思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接IOのメモ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLがサポートされていない直接IOを有効に干渉する多くの問題があります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">現在、これは値に対してのみサポートされており、レプリケーションが有効になっていない場合のみです。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS固有のコードをたくさん書く</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要</font><strong><font style="vertical-align: inherit;">が</font></strong><font style="vertical-align: inherit;">あり、今のところ誰もがこれをやめます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LinuxがダイレクトIOのアイデアとその実装方法に強く誓っているという事実にもかかわらず、すべてのデータベースはそこに行きます。</font><font style="vertical-align: inherit;">OracleおよびMySQLでは、Direct IOが頻繁に使用されます。</font><font style="vertical-align: inherit;">PostgreSQLは、Direct IOが許容しない唯一のデータベースです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックリスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLでのfsyncの驚きから身を守る方法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頻度を減らして大きくなるようにチェックポイントを設定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックポイントに役立つようにバックグラウンドライターを設定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovacuumをプルして、不要な偽のI / Oがないようにします。</font></font></li>
</ul><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伝統によれば、11月には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でSkolkovoの高負荷サービスのプロの開発者を待ってい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">レポートの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">申請に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はまだ1か月ありますが</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への最初のレポート</font><font style="vertical-align: inherit;">は既に受け付けています。</font><font style="vertical-align: inherit;">私たちのためにサインアップ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュースレター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と新しいトピック最初に手を学びます。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459430/index.html">自動フォーム生成を備えたモバイルアプリケーション：私たちのケース</a></li>
<li><a href="../ja459432/index.html">RD-180：米国はロケットエンジンを製造できますか？</a></li>
<li><a href="../ja459434/index.html">Reactフックルーター</a></li>
<li><a href="../ja459438/index.html">データはさらに重要です</a></li>
<li><a href="../ja459442/index.html">5つのオープンソースセキュリティイベント管理システム</a></li>
<li><a href="../ja459446/index.html">モダンデザインの5つの恐ろしいトレンド</a></li>
<li><a href="../ja459450/index.html">Zoomテレビ会議ソフトウェアの脆弱性により、Webサイトがユーザーをスパイする</a></li>
<li><a href="../ja459452/index.html">熟成したサラダのみを庭から慎重に収集することを学んだAI付きのアグロロボット</a></li>
<li><a href="../ja459454/index.html">スタンドオフでの最初のハッカソンはどうでしたか</a></li>
<li><a href="../ja459456/index.html">ダガズ：エピソード（パート1）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>