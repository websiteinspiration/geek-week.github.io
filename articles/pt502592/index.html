<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍💻 ⛅️ 🔓 Neomorfismo usando SwiftUI. Parte 1 👩🏽‍🏫 🌿 👪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saudação, Khabrovites! Antecipando o lançamento do curso avançado “IOS Developer”, preparamos outra tradução interessante.
 
 
 
 O design não mórfico...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Neomorfismo usando SwiftUI. Parte 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502592/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saudação, Khabrovites! </font><font style="vertical-align: inherit;">Antecipando o lançamento do curso avançado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“IOS Developer”,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preparamos outra tradução interessante.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/nr/7d/ml/nr7dmlj7ru0rbnazf8ce8wox3ra.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O design não mórfico é talvez a tendência mais interessante dos últimos meses, embora, na verdade, a Apple o tenha usado como motivo de design na WWDC18. </font><font style="vertical-align: inherit;">Neste artigo, veremos como você pode implementar um design não mórfico usando o SwiftUI, por que você pode fazer isso e, o mais importante, como refinar esse design para aumentar sua acessibilidade.</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Importante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : O neomorfismo - também chamado de neuromorfismo - tem sérias conseqüências para a acessibilidade. Portanto, apesar da tentação de ler a primeira parte deste artigo e pular o resto, peço que você leia o artigo até o final e estude as vantagens e desvantagens para que você possa ver toda a imagem. .</font></font><br>
</blockquote><a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z3tJdxwlo_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noções básicas de neomorfismo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de avançarmos para o código, quero descrever brevemente dois princípios básicos dessa direção no design, pois eles serão relevantes à medida que avançamos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O neomorfismo usa brilho e sombra para determinar as formas dos objetos na tela.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O contraste tende a diminuir; </font><font style="vertical-align: inherit;">não são usados ​​branco ou preto completamente, o que permite destacar realces e sombras.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado final é uma aparência que lembra “plástico extrudado” - um design de interface do usuário que certamente parece novo e interessante sem esbarrar nos olhos. </font><font style="vertical-align: inherit;">Não posso deixar de repetir mais uma vez que reduzir o contraste e usar sombras para destacar formas afeta seriamente a acessibilidade, e voltaremos a isso mais tarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, ainda acho que o tempo gasto aprendendo sobre neomorfismo no SwiftUI vale a pena - mesmo que você não o use em seus próprios aplicativos, é como um kata para escrever código para ajudar a aprimorar suas habilidades. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo bem, chega de conversa fiada - vamos para o código.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construindo um mapa não mórfico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ponto de partida mais simples é criar um mapa não mórfico: um retângulo arredondado que conterá algumas informações. A seguir, veremos como podemos transferir esses princípios para outras partes do SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar criando um novo projeto iOS usando o modelo de aplicativo Single View. Certifique-se de usar o SwiftUI para a interface do usuário e depois nomeie o projeto Neumorfismo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dica: se você tiver acesso à pré-visualização do SwiftUI no Xcode, recomendo que você o ative imediatamente - será muito mais fácil experimentar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Começaremos definindo uma cor que represente um tom cremoso. </font><font style="vertical-align: inherit;">Isso não é cinza puro, mas sim uma sombra muito sutil que adiciona um pouco de calor ou frescor à interface. </font><font style="vertical-align: inherit;">Você pode adicioná-lo ao diretório de ativos, se desejar, mas agora é mais fácil fazer isso no código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione isso </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fora da estrutura </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Color</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> offWhite = <span class="hljs-type">Color</span>(red: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, green: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, blue: <span class="hljs-number">235</span> / <span class="hljs-number">255</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, é quase branco, mas é escuro o suficiente para fazer o branco parecer um brilho quando precisamos dele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos preencher o corpo </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornecendo-o </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que ocupa a tela inteira, usando nossa nova cor quase branca para preencher todo o espaço:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">Color</span>.offWhite<font></font>
        }<font></font>
        .edgesIgnoringSafeArea(.all)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para representar nosso mapa, usaremos um retângulo arredondado na resolução de 300x300 para torná-lo bonito e claro na tela. </font><font style="vertical-align: inherit;">Então adicione isso </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sob a cor:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por padrão, será preto, mas, para a implementação do neomorfismo, queremos reduzir drasticamente o contraste, substituindo-o pela mesma cor que usamos no fundo, tornando a forma invisível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então mude assim:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ponto importante:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determinamos a forma usando sombras, uma escura e uma clara, como se a luz emitisse raios do canto superior esquerdo da tela.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O SwiftUI nos permite aplicar modificadores várias vezes, o que facilita a implementação do neomorfismo. </font><font style="vertical-align: inherit;">Adicione os dois modificadores a seguir ao seu retângulo arredondado:</font></font><br>
<br>
<pre><code class="swift hljs">.shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
.shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles representam o deslocamento da sombra escura no canto inferior direito e o deslocamento da sombra clara no canto superior esquerdo. </font><font style="vertical-align: inherit;">A sombra clara é visível porque usamos um fundo quase branco e agora o mapa se torna visível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escrevemos apenas algumas linhas de código, mas já temos um mapa não mórfico - espero que você concorde que o SwiftUI surpreendentemente facilite o processo!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/_z/0h/he_z0hdu4zlhtftzxwsvxo5k9t8.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criando um botão não mórfico simples</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De todos os elementos de uma interface do usuário, o neomorfismo representa um risco bastante baixo para os cartões - se a interface do usuário dentro de seus cartões for clara, o cartão poderá não ter uma borda clara e isso não afetará a acessibilidade. Os botões são outra questão, porque são projetados para interagir, portanto, reduzir o contraste pode fazer mais mal do que bem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos lidar com isso criando nosso próprio estilo de botão, pois é dessa maneira que o SwiftUI permite distribuir as configurações de botões em muitos lugares. Isso é muito mais conveniente do que adicionar muitos modificadores a cada botão que você criar - podemos simplesmente definir o estilo uma vez e usá-lo em muitos lugares.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos definir um estilo de botão que ficará vazio: o SwiftUI nos fornecerá o rótulo do botão, que pode ser texto, imagem ou outra coisa, e o enviaremos de volta sem alterações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione esta estrutura em algum lugar externo </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleButtonStyle</span>: <span class="hljs-title">ButtonStyle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        configuration.label<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este </font></font><code>configuration.label</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é o conteúdo do botão, e em breve adicionaremos outra coisa. </font><font style="vertical-align: inherit;">Primeiro, vamos definir um botão que o utilize para que você possa ver como o design está evoluindo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Button</span>(action: {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Button tapped"</span>)<font></font>
}) {<font></font>
    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart.fill"</span>)<font></font>
        .foregroundColor(.gray)<font></font>
}<font></font>
.buttonStyle(<span class="hljs-type">SimpleButtonStyle</span>())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você não verá nada de especial na tela, mas podemos corrigi-lo adicionando nosso efeito não mórfico ao estilo do botão. Desta vez, não usaremos um retângulo arredondado, porque para ícones simples, o círculo é melhor, mas precisamos adicionar um pouco de recuo para que a área de clique do botão seja grande e bonita. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Altere seu método </font></font><code>makeBody()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicionando um pouco de recuo e, em seguida, colocando nosso efeito não mórfico como pano de fundo para o botão:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
    )</code></pre><br>
<img src="https://habrastorage.org/webt/nm/-x/yp/nm-xyp4klovncqtomhthav-za7y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso nos aproxima o suficiente do efeito desejado, mas se você executar o aplicativo, verá que, na prática, o comportamento ainda não é perfeito - o botão não reage visualmente quando pressionado, o que parece estranho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para corrigir isso, precisamos ler a propriedade </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro do nosso estilo de botão personalizado, que informa se o botão está pressionado ou não. Podemos usar isso para melhorar nosso estilo e fornecer alguma indicação visual de se o botão está pressionado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com um simples: usaremos os </font></font><code>Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">botões como plano de fundo e, em seguida, verificaremos </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e retornaremos um círculo plano se o botão for pressionado, ou nosso atual círculo escuro, caso contrário:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Group</span> {
            <span class="hljs-keyword">if</span> configuration.isPressed {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
            }<font></font>
        }<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como um </font></font><code>isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">círculo com uma cor quase branca é usado </font><font style="vertical-align: inherit;">no estado </font><font style="vertical-align: inherit;">, ele torna nosso efeito invisível quando o botão é pressionado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aviso: devido ao modo como o SwiftUI calcula as áreas tocáveis, involuntariamente tornamos a área de clique do nosso botão muito pequena - agora você precisa tocar na própria imagem e não no design não morfológico ao seu redor. </font><font style="vertical-align: inherit;">Para corrigir isso, adicione um modificador </font></font><code>.contentShape(Circle())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imediatamente depois </font></font><code>.padding(30)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, forçando o SwiftUI a usar todo o espaço disponível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, podemos criar o efeito da concavidade artificial invertendo a sombra - copiando dois modificadores </font></font><code>shadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do efeito base, trocando os valores X e Y por branco e preto, como mostrado aqui:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">if</span> configuration.isPressed {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estime o resultado.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/nz/gv/bknzgvars2r0e4anrdqngo12wr4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie sombras internas para um clique no botão</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso código atual, em princípio, já funciona, mas as pessoas interpretam o efeito de maneira diferente - alguns o veem como um botão côncavo, outros veem que o botão ainda não foi pressionado, apenas a luz vem de um ângulo diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A idéia da melhoria é criar uma sombra interna que simule o efeito de pressionar o botão para dentro. Isso não faz parte do kit SwiftUI padrão, mas podemos implementá-lo facilmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Criar uma sombra interna requer dois gradientes lineares, e eles serão apenas o primeiro de muitos gradientes internos que usaremos neste artigo; portanto, adicionaremos imediatamente uma pequena extensão auxiliar para </font></font><code>LinearGradient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplificar a criação de gradientes padrão:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LinearGradient</span> </span>{
    <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> colors: <span class="hljs-type">Color</span>...) {
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(gradient: <span class="hljs-type">Gradient</span>(colors: colors), startPoint: .topLeading, endPoint: .bottomTrailing)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com isso, podemos simplesmente fornecer uma lista variável de cores para recuperar seu gradiente linear na direção diagonal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, sobre o ponto importante: em vez de adicionar duas sombras invertidas ao círculo pressionado, vamos sobrepor um novo círculo com um borrão (traço) e depois aplicar outro círculo com um gradiente como máscara. </font><font style="vertical-align: inherit;">Isso é um pouco mais complicado, mas deixe-me explicar aos poucos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso círculo base é nosso círculo atual com efeito neomórfico, preenchido com uma cor quase branca.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos um círculo em cima dele, emoldurado por uma moldura cinza, e desfocamos um pouco para suavizar as bordas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, aplicamos uma máscara com outro círculo a esse círculo sobreposto no topo, desta vez preenchido com um gradiente linear.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você aplica uma vista como máscara a outra, o SwiftUI usa o canal alfa da máscara para determinar o que deve ser exibido na vista base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, se desenharmos um traçado cinza embaçado e o mascararmos com um gradiente linear de preto para transparente, o traçado embaçado ficará invisível de um lado e aumentará gradualmente do outro - obteremos um gradiente interno suave. Para tornar o efeito mais pronunciado, podemos mudar ligeiramente os círculos sombreados nas duas direções. Depois de experimentar um pouco, descobri que desenhar uma sombra clara com uma linha mais grossa que uma escura ajuda a maximizar o efeito.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de que duas sombras são usadas para criar uma sensação de profundidade no neomorfismo: uma clara e outra escura; portanto, adicionaremos esse efeito da sombra interna duas vezes com cores diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mude o círculo da </font></font><code>configuration.isPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguinte maneira:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Circle</span>()<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.gray, lineWidth: <span class="hljs-number">4</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.black, <span class="hljs-type">Color</span>.clear)))<font></font>
    )<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.white, lineWidth: <span class="hljs-number">8</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: -<span class="hljs-number">2</span>, y: -<span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.clear, <span class="hljs-type">Color</span>.black)))<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você executar o aplicativo novamente, verá que o efeito de pressionar um botão é muito mais pronunciado e parece melhor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1r/f1/ha/1rf1hanjn-9zhj0xhglha6e4lr0.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com isso, a primeira parte da tradução chegou ao fim. </font><font style="vertical-align: inherit;">Nos próximos dias, publicaremos a continuação e agora convidamos você a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aprender mais sobre o próximo curso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502576/index.html">Apple Watch de baixo custo: como eles queriam me "criar" no Avito e Yulia</a></li>
<li><a href="../pt502578/index.html">Sobre a revolução nos radares, prazos e entrada na quarta dimensão</a></li>
<li><a href="../pt502580/index.html">Confirmar em código aberto como desenvolvedor? Lidamos com os direitos (oi, nginx)</a></li>
<li><a href="../pt502584/index.html">O fabricante Mi Band lançará uma máscara transparente auto-desinfetante para proteção contra COVID-19</a></li>
<li><a href="../pt502588/index.html">A incrível história do PowerPoint</a></li>
<li><a href="../pt502594/index.html">7 razões pelas quais os projetos da web não terminam e como lidar com isso</a></li>
<li><a href="../pt502596/index.html">Cursos educacionais em quarentena gratuitos: design</a></li>
<li><a href="../pt502598/index.html">Semana 21 de Segurança: Vulnerabilidade no Serviço de Impressão do Windows</a></li>
<li><a href="../pt502604/index.html">Uma introdução ao TLS para Patrik Patrick (Parte 1)</a></li>
<li><a href="../pt502608/index.html">Como começamos o mercado de aplicativos no serviço SaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>