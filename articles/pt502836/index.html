<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèΩ üëÇüèø üê† Aventuras do editor de unidade: Matryoshka serializado üõê üïô üéä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Breve introdu√ß√£o
 Como regra, para chegar ao campo de uma propriedade serializada que nos interessa, a terapia manual nos aconselha a usar o m√©todo Fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Aventuras do editor de unidade: Matryoshka serializado</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502836/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breve introdu√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como regra, para chegar ao campo de uma propriedade serializada que nos interessa, a terapia manual nos aconselha a usar o m√©todo FindPropertyRelative (), no qual o nome da vari√°vel √© lan√ßado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por certas raz√µes, essa abordagem nem sempre √© conveniente. As raz√µes podem ser muito diversas. Por exemplo, o nome de uma vari√°vel pode mudar, precisamos de acesso sangrado a uma propriedade n√£o serializada, precisamos ter acesso a getter-setters ou mesmo m√©todos de um objeto serializado. N√£o faremos as perguntas ‚Äúpor que voc√™ precisa disso?‚Äù E ‚Äúpor que voc√™ n√£o poderia ficar sem as formas tradicionais‚Äù. Suponha que precisamos - e √© isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, vamos descobrir como obter o objeto com o qual estamos trabalhando, bem como todos os seus objetos-pai da propriedade serializada, e n√£o sermos pegos na estrada de serializa√ß√£o cheia de armadilhas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aten√ß√£o. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este artigo implica que voc√™ j√° sabe trabalhar com o UnityEditor, pelo menos uma vez escreveu PropertyDrawers personalizados e pelo menos em termos gerais, entende como uma propriedade serializada difere de um objeto serializado.</font></font><br>
<br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminho de serializa√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, coloque todos os pontos sobre O. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso mais primitivo, temos uma certa classe de herdeiros da MonoBehaviour, e ela tem um certo campo pertencente a uma classe serializada, obviamente n√£o √© um herdeiro da vaca sagrada unit√°ria de A.K.A. </font><font style="vertical-align: inherit;">UnityEngine.Object.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExamplePulsar</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
...<font></font>
        [<span class="hljs-meta">Space</span>][Header(<span class="hljs-string">"Example Sandbox Inspector Field"</span>)]
        <span class="hljs-keyword">public</span> SandboxField sandboxField;<font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No c√≥digo acima, SandboxField √© uma classe com o atributo Serializable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obter acesso ao MonoBehaviour do propriet√°rio n√£o √© um problema:</font></font><br>
<br>
<pre><code class="cs hljs">UnityEngine.Object serializationRoot = property.serializedObject.targetObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se desejar, voc√™ pode fazer isso como agora, mas agora n√£o precisamos disso. </font><font style="vertical-align: inherit;">Estamos interessados ‚Äã‚Äãno pr√≥prio campo serializado para desenh√°-lo com todo o blackjack, como na figura abaixo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-w/3n/th/-w3nthkn0gmcdeuvpqlw2zctxhy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos seguir o caminho de serializa√ß√£o da seguinte maneira:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> serializationPath = property.propertyPath;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, o caminho de serializa√ß√£o consistir√° em um de nossos campos e retornar√° ‚ÄúsandboxField‚Äù, do qual n√£o estamos com frio nem calor, pois para o primeiro n√≠vel de aninhamento precisamos saber apenas o nome da vari√°vel (que, ali√°s, foi devolvida a n√≥s). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que n√£o h√° MonoBehaviour principal no caminho. </font><font style="vertical-align: inherit;">Agora isso n√£o importa, mas ser√° importante quando come√ßarmos a desmontar uma boneca russa que se parece com isso:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nestedClassVariable.exampleSandboxesList.Array.data [0] .evenMoreNested.Array.data [0]</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para n√£o ser pego mais tarde, quando as propriedades estiverem aninhadas, faremos o seguinte com anteced√™ncia:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span>[] path = property.propertyPath.Split(<span class="hljs-string">'.'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora temos todos os n√≥s do caminho de serializa√ß√£o. </font><font style="vertical-align: inherit;">Mas, no caso mais primitivo, precisamos apenas do n√≥ zero. </font><font style="vertical-align: inherit;">Pegue:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> pathNode = path[<span class="hljs-number">0</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acenda um pouco de reflex√£o e pegue o campo a partir daqui:</font></font><br>
<br>
<pre><code class="cs hljs">Type objectType = serializationRoot.GetType();<font></font>
FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<span class="hljs-keyword">object</span> field = objectFieldInfo.GetValue(serializationRoot);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixamos nos bastidores a quest√£o da velocidade desse empreendimento. Para um pequeno n√∫mero desses campos e um pequeno aninhamento, os custos de reflex√£o ser√£o significativamente menores do que para tudo o que acontece sob o cap√¥ do UnityEditor durante a renderiza√ß√£o. Se voc√™ deseja provas - em um github, os desenvolvedores do Unity t√™m uma coisa t√£o interessante, o UnityCsReference, veja como voc√™ est√°, como a renderiza√ß√£o do ObjectField √© implementada, por exemplo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, isso </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o √©</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tudo </font><s><font style="vertical-align: inherit;">(ha ha)</font></s><font style="vertical-align: inherit;"> . Temos o campo, estamos felizes, podemos fazer o que quisermos com ele e at√© tentar escrever nosso pr√≥prio UnityEvent com todos os bot√µes e a√ß√µes importantes que afetam apenas o nosso campo, independentemente do objeto em que ele esteja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelo menos, enquanto estiver na raiz desse objeto, tudo ficar√° bem, mas n√£o ser√° mais muito. </font><font style="vertical-align: inherit;">No caminho da serializa√ß√£o, estamos aguardando matrizes e todos os tipos de listas, cujo principal desejo √© nos colocar de t√™nis, alterando oportunamente o n√∫mero de elementos. </font><font style="vertical-align: inherit;">Mas para o inferno com isso, primeiro cavar√≠amos sob o pr√≥prio array.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso objetivo √© a resist√™ncia a essas bonecas</font></font></b>
                        <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/do/h3/l7doh3b9j_da24zsw9rc-7xefjs.png"></div></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se n√£o tiv√©ssemos matrizes no caminho de serializa√ß√£o, o problema seria resolvido trivialmente: percorrer√≠amos os n√≥s de serializa√ß√£o em um loop at√© chegarmos ao final da cadeia. </font><font style="vertical-align: inherit;">Algo como o seguinte c√≥digo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> currentObject = serializationRoot;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; directSearchDepth; i++)<font></font>
{<font></font>
       <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
       Type objectType = currentObject.GetType();<font></font>
       FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
       <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);<font></font>
       currentObject = nextObject;<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui estamos aguardando duas not√≠cias desagrad√°veis ‚Äã‚Äãao mesmo tempo. </font><font style="vertical-align: inherit;">Vou come√ßar com o segundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A etapa de executar nextObject pode repentinamente retornar nulo em vez do objeto esperado. </font><font style="vertical-align: inherit;">Normalmente, isso acontece quando criamos o objeto pai pela primeira vez no inspetor, e o caminho da serializa√ß√£o j√° existe, mas o campo correspondente n√£o existe (isso nos trar√° ainda mais facilidades). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, seria bom adicionar imediatamente a sa√≠da do m√©todo com o retorno nulo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
<span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
currentObject = nextObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Espere um minuto! </font><font style="vertical-align: inherit;">- voc√™ diz. </font><font style="vertical-align: inherit;">"E o que fazer na OnGUI se zero nos foi devolvido?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resposta: nada. </font><font style="vertical-align: inherit;">Nada literalmente. </font><font style="vertical-align: inherit;">Basta fazer um retorno e, assim, pular esta etapa do desenho, aguardando a cria√ß√£o do campo. </font><font style="vertical-align: inherit;">Nada terr√≠vel vai acontecer com isso.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span>)</span><font></font>
{<font></font>
       SandboxField sandboxField = GetTarget&lt;T&gt;(property);<font></font>
       <span class="hljs-keyword">if</span> (sandboxField == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<font></font>
‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aqui GetTarget () √© a fun√ß√£o correspondente, tirando o objeto serializado da propriedade </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, aconselhamo-lo a entrar no campo de seu interesse, n√£o aqui, mas em GetPropertyHeight. Isso ser√° necess√°rio caso escrevamos campos expans√≠veis recolh√≠veis com tamanhos diferentes, dependendo do conte√∫do. GetPropertyHeight () √© chamado antes de OnGUI (), portanto, se pegarmos o campo e o escrevermos no campo de nosso PropertyDrawer, n√£o precisaremos lev√°-lo novamente ao OnGUI.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que uma inst√¢ncia do PropertyDrawer personalizado √© criada sozinha para desenhar todas as propriedades serializadas vis√≠veis no momento, e novas propriedades s√£o lan√ßadas nela de cima para baixo. Isso deve ser levado em considera√ß√£o para n√£o interferir no c√°lculo da altura da pr√≥xima propriedade; caso contr√°rio, voc√™ poder√° ter uma situa√ß√£o desagrad√°vel ao clicar na dobra e o campo que voc√™ espera ser√° expandido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, todo o ouropel respons√°vel por exibir o campo no editor e que voc√™ deseja serializar, voc√™ deve serializar no lado da classe serializ√°vel, n√£o no PropertyDrawer e por uma quest√£o de precis√£o - coloque colchetes de compila√ß√£o condicionais para que toda essa vergonha espanhola n√£o tente ir para a compila√ß√£o :</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SandboxField</span><font></font>
{<font></font>
‚Ä¶<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> editorFoldout;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra armadilha que nos espera aqui: todos os campos criados atrav√©s do editor queriam cuspir no construtor da classe e nos valores padr√£o especificados na classe. </font><font style="vertical-align: inherit;">Se voc√™ faz, por exemplo, o seguinte (exemplo do meu projeto, onde era o valor dos n√≥s da superf√≠cie da √°gua):</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m_nodesPerUnit = <span class="hljs-number">5</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse valor ser√° ignorado na serializa√ß√£o √† queima-roupa assim que voc√™ adicionar um novo item √† lista. </font><font style="vertical-align: inherit;">Pedir ajuda ao construtor n√£o √© menos in√∫til: tudo o que voc√™ escreveu l√° ser√° ignorado. </font><font style="vertical-align: inherit;">O novo objeto √© uma meta como um falc√£o, todos os seus valores s√£o realmente os valores padr√£o, mas n√£o os que voc√™ deseja ver l√°, mas todos os tipos de nulos, falsos, 0, Color.clear e outras coisas obscenas.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muleta em carne</font></font></b>
                        <div class="spoiler_text">  .   NonUnitySerializableClass,       .      , DefaultEditorObject(),    . <br>
<br>
  - :<br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NonUnitySerializableClass</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DefaultEditorObject</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// virtually do nothing</span><font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> validated = <span class="hljs-literal">false</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EditorCreated</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> force = <span class="hljs-literal">false</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (validated &amp;&amp; !force) <span class="hljs-keyword">return</span>;<font></font>
            DefaultEditorObject();<font></font>
            validated = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonUnitySerializableClass</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            EditorCreated(<span class="hljs-literal">true</span>);<font></font>
        }<font></font>
}</code></pre><br>
        DefaultEditorObject(),    ,   EditorCreated     .<br>
<br>
 :       .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/dh/dr/fgdhdrfczfhhcki7dw6plxzj7vi.png"></div><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos voltar √†s nossas ovelhas, ou melhor, √†s matrizes. </font><font style="vertical-align: inherit;">Outro problema que pode surgir em um est√°gio ainda mais precoce est√° nesta linha:</font></font><br>
<br>
<pre><code class="cs hljs">FieldInfo objectFieldInfo = objectType.GetField(pathNode);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O lado direito pode nos retornar zero se encontrar um array no caminho de serializa√ß√£o (e qualquer objeto "IList" ser√° o array "Array"). </font><font style="vertical-align: inherit;">Desagrad√°vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que fazer? </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente n√£o cair nessas situa√ß√µes</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrevendo um manipulador:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pathNode.Length; i++)<font></font>
{<font></font>
        <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
        Type objectType = currentObject.GetType();<font></font>
        FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (objectFieldInfo == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
                <span class="hljs-keyword">if</span> (pathNode == <span class="hljs-string">"Array"</span>)<font></font>
                {<font></font>
                        i++;<font></font>
                        <span class="hljs-keyword">string</span> nextNode = path[i];
                        <span class="hljs-keyword">string</span> idxstr = nextNode.Substring(nextNode.IndexOf(<span class="hljs-string">"["</span>) + <span class="hljs-number">1</span>);<font></font>
                        idxstr = idxstr.Replace(<span class="hljs-string">"]"</span>, <span class="hljs-string">""</span>);
                        <span class="hljs-keyword">int</span> arrayNumber = Convert.ToInt32(idxstr);<font></font>
                        IList collection = currentObject <span class="hljs-keyword">as</span> IList;
                        <span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                        currentObject = collection[arrayNumber];<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(<span class="hljs-string">"   "</span>);<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//  ,     </span><font></font>
        {<font></font>
                <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
                <span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                currentObject = nextObject;<font></font>
        }<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, podemos at√© entrar em uma situa√ß√£o desagrad√°vel aqui, quando o caminho de serializa√ß√£o j√° possui, por exemplo, o elemento data [0] ou data [1], e a matriz ainda n√£o o implementou. </font><font style="vertical-align: inherit;">Por exemplo, criamos uma lista vazia. </font><font style="vertical-align: inherit;">Pedimos-lhe N elementos - e sem essa linha bonita:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... temos um monte de exce√ß√µes em ronronos. </font><font style="vertical-align: inherit;">E tudo o que era necess√°rio era pular a etapa de renderiza√ß√£o, tendo esperado at√© que os campos de interesse para n√≥s fossem criados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainda n√£o me deparei com outros casos em que objectFieldInfo == null, mas ao mesmo tempo o n√≥ de serializa√ß√£o n√£o √© designado como Array, portanto, lan√ßar uma terr√≠vel exce√ß√£o em uma situa√ß√£o excepcional e hipot√©tica √© quebr√°-lo posteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, temos uma fun√ß√£o mais ou menos funcional que nos permite extrair um campo por sua propriedade serializada. </font><font style="vertical-align: inherit;">No futuro, essa fun√ß√£o pode ser modificada for√ßando a extra√ß√£o de todos os objetos no caminho de serializa√ß√£o, bem como a pesquisa do "pai" mais pr√≥ximo, incluindo ou excluindo matrizes ao longo do caminho.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Life hack para desenhar propriedades aninhadas</font></font></b>
                        <div class="spoiler_text">      -  ,   Rect position  Rect indentedPosition = EditorGUI.IndentedRect(position).     ,         EditorGUI,      position ,       GUI ‚Äì    indentedPosition.   EditorGUILayout  OnGUI,       (   ,   ).<br>
<br>
    ,   MonoScript   (     -,   ),     static-,      AssetDatabase,        <i></i>         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obrigado pela aten√ß√£o.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502818/index.html">Y messenger: messenger descentralizado na blockchain *</a></li>
<li><a href="../pt502826/index.html">Vis√£o geral do scanner 3D Creaform MetraSCAN 3D</a></li>
<li><a href="../pt502830/index.html">Hackathon on-line "Nova Realidade" VirusHack. Como foi</a></li>
<li><a href="../pt502832/index.html">Certifica√ß√£o ISTQB disponibilizada online: experi√™ncia pessoal</a></li>
<li><a href="../pt502834/index.html">Como se tornar um engenheiro de DevOps em seis meses ou at√© mais r√°pido. Parte 5. Implanta√ß√£o</a></li>
<li><a href="../pt502838/index.html">Qual √© a diferen√ßa entre TI e profiss√µes digitais: transforma√ß√£o digital e opini√µes de especialistas</a></li>
<li><a href="../pt502840/index.html">Revis√£o do scanner 3D EinScan Pro 2X Plus 3D brilhante</a></li>
<li><a href="../pt502842/index.html">Como proteger os dados biom√©tricos do usu√°rio contra uso criminoso</a></li>
<li><a href="../pt502844/index.html">[Parte 2/2] Guia para FFmpeg e SDL ou Como gravar um player de v√≠deo em menos de 1000 linhas</a></li>
<li><a href="../pt502846/index.html">Zuckerberg lan√ßou Lojas. Instagram e Facebook gradualmente se tornam lojas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>