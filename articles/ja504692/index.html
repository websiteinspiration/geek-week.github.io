<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 ⛪️ 👴 ZFSの基本：ストレージとパフォーマンス 👍🏾 🌌 👩🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この春、すでにディスクの速度をチェックする方法やRAIDとは何かなど、いくつかの導入トピックについて説明しました。それらの2番目では、ZFSのさまざまなマルチディスクトポロジのパフォーマンスを引き続き調査することさえ約束しました。これは、AppleからUbuntuに至るまで、あらゆる場所で実装されて...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZFSの基本：ストレージとパフォーマンス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504692/"><img src="https://habrastorage.org/getpro/habr/post_images/abf/883/e96/abf883e96b01dbc78420e0dc1a158460.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この春、すでに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスクの速度をチェックする方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAIDとは何か</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など、いくつかの導入トピックについて説明しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それらの2番目では、ZFSのさまざまなマルチディスクトポロジのパフォーマンスを引き続き調査することさえ約束しました。</font><font style="vertical-align: inherit;">これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubuntuに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至るまで、あらゆる場所で実装されている次世代のファイルシステムです</font><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、今日はZFS、好奇心旺盛な読者を知るための最高の日です。</font><font style="vertical-align: inherit;">OpenZFS開発者のMatt Arensによる控えめな評価によると、「それは本当に複雑です」ということに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、数値に到達する前に-確かにそうですが-すべてのバリアントvosmidiskovoy ZFS構成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ZFSがデータをディスクに保存する</font><i><font style="vertical-align: inherit;">方法</font></i><font style="vertical-align: inherit;">について</font><i><font style="vertical-align: inherit;">説明する</font></i><font style="vertical-align: inherit;">必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zpool、vdev、デバイス</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/674/1c6/ab3/6741c6ab310f4e0edf2adf7e2ca4c6bb.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このフルプール図は、3つの補助vdevs、各クラスに1つ、およびRAIDZ2ための4つが含まれています。</font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b9f/82c/887/b9f82c88748c44d1f86cc412a053bf94.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そこ不適切のプールを作成する理由は通常ありません</font></font></font></i><font style="vertical-align: inherit;"><i><font color="gray"><font style="vertical-align: inherit;">VDEVの</font></font></i><i><font color="gray"><font style="vertical-align: inherit;">種類とサイズが- 。しかし、あなたがしたい場合は、これをやってから何も防止できます</font></font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
本当にZFSファイルシステムを理解するために、実際の構造を注意深く見る必要があります。</font><font style="vertical-align: inherit;">まず、ZFSは従来のレベルのボリューム管理とファイルシステムを組み合わせます。</font><font style="vertical-align: inherit;">次に、書き込み時にトランザクションコピーメカニズムを使用します。</font><font style="vertical-align: inherit;">これらの機能は、システムが通常のファイルシステムやRAIDアレイと構造的に非常に異なることを意味します。</font><font style="vertical-align: inherit;">理解する必要がある基本的なビルディングブロックの最初のセット：ストレージプール（zpool）、仮想デバイス（vdev）、および実デバイス（デバイス）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zpool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
zpoolストレージプールは、最上位のZFS構造です。各プールには1つ以上の仮想デバイスが含まれています。次に、それぞれに1つ以上の実デバイス（デバイス）が含まれます。仮想プールは自律ブロックです。 1台の物理コンピューターに2つ以上の個別のプールが含まれている場合がありますが、それぞれは他のプールから完全に独立しています。プールは仮想デバイスを共有できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSの冗長性は仮想デバイスのレベルではありますが、プールのレベルではありません。プールレベルでは、冗長性はまったくありません。vdevドライブまたは特別なvdevが失われると、プール全体が失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のストレージプールは、キャッシュまたは仮想デバイスログの損失に耐えることができますが、停電やシステムクラッシュの際にvdevログを失うと、ダーティデータを少量失う可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSの「データバンド」（ストリップ）がプール全体に記録されるという一般的な誤解があります。本当じゃない。 Zpoolは楽しいRAID0ではありません</font><font style="vertical-align: inherit;">。複雑な変更可能な配布メカニズムを備え</font><font style="vertical-align: inherit;">た楽しい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JBOD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、エントリは使用可能なスペースに応じて使用可能な仮想デバイスに分散されるため、理論的にはすべてが同時に満たされます。 ZFSの以降のバージョンでは、vdevの現在の使用（破棄）が考慮されます。一方の仮想デバイスが他方よりも大幅にロードされている場合（たとえば、読み取りロードのため）、最高の空き容量係数が存在するにもかかわらず、一時的に書き込みがスキップされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のZFSレコード配布方法に組み込まれているリサイクル検出メカニズムは、異常に高い負荷の期間中のレイテンシを削減し、スループットを向上させることができますが、これは簡単な</font><i><font style="vertical-align: inherit;">ブランチで</font></i><font style="vertical-align: inherit;">はありません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのプールで低速のHDDと高速のSSDを思わず混在させる。</font><font style="vertical-align: inherit;">そのような等しくないプールは、最も遅いデバイスの速度で、つまりまるで完全にそのようなデバイスで構成されているかのように動作します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vdev</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ストレージプールは、1つ以上の仮想デバイス（仮想デバイス、vdev）で構成されています。</font><font style="vertical-align: inherit;">次に、各vdevには1つ以上の実デバイスが含まれます。</font><font style="vertical-align: inherit;">ほとんどの仮想デバイスはデータを簡単に格納するために使用されますが、CACHE、LOG、SPECIALなど、いくつかのヘルパーvdevクラスがあります。</font><font style="vertical-align: inherit;">これらのvdevタイプはそれぞれ、単一デバイス、RAIDz1、RAIDz2、RAIDz3、またはミラーの5つのトポロジーのいずれかを持つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDz1、RAIDz2、およびRAIDz3は、古いものがRAIDダブル（対角）パリティと呼んでいるものの特別なバリエーションです。 1、2、および3は、各データ帯域に割り当てられるパリティブロックの数を示します。パリティ用に個別のディスクではなく、仮想RAIDzデバイスはこのパリティをディスク間で均等に分散します。 RAIDzアレイは、パリティブロックと同じ数のディスクを失う可能性があります。彼が別のものを失った場合、彼は失敗し、彼と一緒にストレージプールを取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミラーリングされた仮想デバイス（ミラーvdev）では、各ブロックはvdevの各デバイスに格納されます。最も一般的な2ワイドミラーですが、ミラーには任意の数のデバイスを含めることができます。大規模なインストールでは、読み取りパフォーマンスとフォールトトレランスを向上させるために、トリプルミラーがよく使用されます。 vdevミラーは、vdev内の少なくとも1つのデバイスが動作し続けている間、障害に耐えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のvdevは本質的に危険です。このような仮想デバイスは単一の障害に耐えることはできません。ストレージまたは特別なvdevとして使用されている場合、その障害によりプール全体が破壊されます。ここで、非常に注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CACHE、LOG、およびSPECIAL仮想アプライアンスは、上記のトポロジのいずれかを使用して作成できます。ただし、SPECIAL仮想アプライアンスを失うとプールが失われることになるため、過度のトポロジを強くお勧めします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端末</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、おそらくZFSで理解するのに最も簡単な用語です。文字通り、ブロックランダムアクセスデバイスです。仮想デバイスは個々のデバイスで構成され、プールは仮想デバイスで構成されることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスク-磁気またはソリッドステート-は、vdevビルディングブロックとして使用される最も一般的なブロックデバイスです。ただし、/ devにハンドルがある任意のデバイスが適しているため、ハードウェアRAIDアレイ全体を個別のデバイスとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルなrawファイルは、vdevを構築できる最も重要な代替ブロックデバイスの1つです。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">スパースファイル</font></a><font style="vertical-align: inherit;">からプールをテスト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-プールコマンドをチェックし、このトポロジのプールまたは仮想デバイスで使用可能なスペースを確認する非常に便利な方法。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5cf/aa5/62c/5cfaa562cb208b654af113f7535b8f57.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほんの数秒でスパースファイルからテストプールを作成できます。ただし、後でプール全体とそのコンポーネントを削除することを忘れないでください。</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
サーバーを8つのディスクに配置し、10 TBのディスク（約9300 GiB）を使用することを計画しているとします。トポロジは、ニーズに最適です。上記の例では、ほんの数秒でスパースファイルからテストプールを構築します。8つの10 TBドライブからのRAIDz2 vdevが50 TiBの有用な容量を提供することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の特別なクラスのデバイスは、SPARE（スペア）です。ホットスワップ可能なデバイスは、従来のデバイスとは異なり、1つの仮想デバイスだけでなく、プール全体に属します。プール内の一部のvdevに障害が発生し、スペアデバイスがプールに接続されて使用可能な場合、影響を受けるvdevに自動的に参加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
影響を受けるvdevに接続した後、スペアデバイスは、欠落しているデバイスにあるはずのデータのコピーまたは再構築の受信を開始します。従来のRAIDではこれを再構築と呼び、ZFSでは「再構築」と呼びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
交換用デバイスが故障したデバイスを永久に交換するわけではないことに注意することが重要です。</font><font style="vertical-align: inherit;">これは、vdevの低下が観察される時間を短縮するための一時的な置き換えにすぎません。</font><font style="vertical-align: inherit;">管理者が故障したvdevデバイスを交換した後、冗長性はこの永続的なデバイスに復元され、SPAREはvdevから切断され、プール全体のスペアとして機能するように戻ります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセット、ブロック、およびセクター</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSを使用する過程で理解する必要がある次のビルディングブロックのセットは、それほどハードウェアではなく、データがどのように編成および格納されるかです。</font><font style="vertical-align: inherit;">全体的な構造の理解を維持しながら詳細を積み重ねないように、ここではメタスラブなどのいくつかのレベルをスキップします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセット</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd3/c48/d9d/bd3c48d9dff6e0f493a5d90d1dca6d1d.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初にデータセットを作成すると、利用可能なすべてのプール領域が表示されます。次に、クォータを設定し、マウントポイントを変更します。マジック！</font></font></font></i> <br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a18/3de/210/a183de210cdc57cd1421652201cbf2c3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zvolは大部分が単なるデータセットであり、そのファイルシステムレイヤーはありませんが、ここでは完全に通常のext4</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ファイルシステム</font><i><font color="gray"><font style="vertical-align: inherit;">に置き換えます。ZFS</font></font></i><font style="vertical-align: inherit;">データセットは、標準のマウント済みファイルシステムとほぼ同じです。通常のファイルシステムと同じように、一見すると「別のフォルダ」のように見えます。ただし、従来のマウントされたファイルシステムと同様に、各ZFSデータセットには独自の基本プロパティのセットがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、データセットには割り当てが割り当てられている場合があります。インストールされている場合</font></font><code>zfs set quota=100G poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、マウントされたフォルダーに</font></font><code>/poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 GiBを超える</font><font style="vertical-align: inherit;">書き込みはできません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各行の先頭にスラッシュが存在する-存在しないことに注意してください。各データセットには、ZFS階層とシステムマウント階層の両方で独自の場所があります。 ZFS階層の先頭にスラッシュはありません。プールの名前から始め、次に1つのデータセットから次のデータセットへのパスから始めます。たとえば</font><font style="vertical-align: inherit;">、クリエイティブ名を持つプール内</font><font style="vertical-align: inherit;">の親データセットの下に</font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前が付けられたデータセットの</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
デフォルトでは、データセットのマウントポイントは、ZFS階層の名前と同じで、先頭にスラッシュが付いています。名前のプールはとして</font><font style="vertical-align: inherit;">マウントされ</font><font style="vertical-align: inherit;">、データセットはに</font><font style="vertical-align: inherit;">マウントされ</font><font style="vertical-align: inherit;">、子</font><font style="vertical-align: inherit;">データセット</font><font style="vertical-align: inherit;">はにマウントさ</font><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">ます。ただし、データセットのシステムマウントポイントは変更できます。</font><font style="vertical-align: inherit;">
示す場合</font></font><code>child</code><font style="vertical-align: inherit;"></font><code>parent</code><font style="vertical-align: inherit;"></font><code>pool</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>pool</code><font style="vertical-align: inherit;"></font><code>/pool</code><font style="vertical-align: inherit;"></font><code>parent</code><font style="vertical-align: inherit;"></font><code>/pool/parent</code><font style="vertical-align: inherit;"></font><code>child</code><font style="vertical-align: inherit;"></font><code>/pool/parent/child</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>zfs set mountpoint=/lol pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、データセットはと</font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してシステムにマウントされ</font></font><code>/lol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットに加えて、ボリューム（zvols）についても言及する必要があります。</font><font style="vertical-align: inherit;">ボリュームはデータセットとほぼ同じですが、実際にはファイルシステムがなく、単なるブロックデバイスです。</font><font style="vertical-align: inherit;">たとえば、</font></font><code>zvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前</font><font style="vertical-align: inherit;">で作成</font><font style="vertical-align: inherit;">し</font></font><code>mypool/myzvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ext4ファイルシステムでフォーマットしてから、このファイルシステムをマウントすることができます。これでext4ファイルシステムができましたが、すべてのZFSセキュリティ機能がサポートされています。</font><font style="vertical-align: inherit;">これは1台のコンピューターではばかげているように見えるかもしれませんが、iSCSIデバイスをエクスポートするときのバックエンドとしてはるかに意味があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/74b/4dd/d00/74b4ddd009e67db1b1b6c4467bcf6fa3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルは1つ以上のブロックで表されます。各ブロックは1つの仮想デバイスに保存されます。通常、ブロックサイズは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recordsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータと同じですが、</font><font style="vertical-align: inherit;">メタデータまたは小さなファイルが含まれている場合は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">ashift</font></b><font style="vertical-align: inherit;">に減らすことができ</font><font style="vertical-align: inherit;">ます。</font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8d1/7fd/ad2/8d17fdad2eda641c801e5e6a302f6e38.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは本当に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当にしている</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたが小さすぎるashiftをインストールする場合は、巨大なパフォーマンスの被害について冗談を言っていない</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プールZFSでは、メタデータを含むすべてのデータは、ブロックに格納されています。各データセットの最大ブロックサイズは、プロパティ</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（レコードサイズ）で</font><font style="vertical-align: inherit;">定義されます</font><font style="vertical-align: inherit;">。レコードのサイズは異なる場合がありますが、データセットに既に書き込まれているブロックのサイズや場所は変わりません。新しいブロックが書き込まれるときにのみ有効です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に指定がない限り、現在の記録サイズはデフォルトで128 KiBです。これは一種の難しい妥協であり、パフォーマンスは理想的ではありませんが、ほとんどの場合ひどいものではありません。</font></font><code>Recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4Kから1Mまでの任意の値に設定</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます（追加の設定</font><font style="vertical-align: inherit;">を使用して、さらに多くの</font><font style="vertical-align: inherit;">値を設定</font><font style="vertical-align: inherit;">できますが、これはめったに推奨されません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのブロックも1つのファイルのデータのみを参照します。2つの異なるファイルを1つのブロックにまとめることはできません。各ファイルは、サイズに応じて、1つ以上のブロックで構成されます。ファイルサイズがレコードサイズよりも小さい場合、より小さなブロックに保存されます。たとえば、2 KiBファイルのブロックは、ディスク上の4 KiBセクターを1つだけ占有します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルが十分に大きく、いくつかのブロックを必要とする場合、このファイルを含むすべてのレコードはサイズを持ちます</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-最後のレコードを含み、その主要部分が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未使用スペース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であることが判明する場合があり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zvolボリュームにはプロパティがありません</font><font style="vertical-align: inherit;">。</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;代わりに同等のプロパティがあります</font></font><code>volblocksize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の、最も基本的な構成要素はセクターです。これは、基本ユニットに読み書きできる最小の物理ユニットです。数十年間、ほとんどのディスクは512バイトのセクターを使用していました。最近、ほとんどのドライブは4 KiBセクター用に構成され、一部のドライブ（特にSSD）では8 KiBセクター以上に構成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSには、セクターサイズを手動で設定できるプロパティがあります。これはプロパティ</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。シフトが2の累乗であることはやや混乱しています。たとえば</font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2 ^ 9、または512バイトのセクターサイズを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSは、新しいブロックデバイスが新しいvdevに追加されるときに、各ブロックデバイスに関する詳細情報をオペレーティングシステムに要求し、理論的にはこの情報に基づいてシフトを適切に自動的に設定します。残念ながら、多くのディスクはWindows XPとの互換性を維持するためにセクターサイズを偽っています（他のセクターサイズのディスクを理解できませんでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、ZFS管理者はデバイスの実際のセクターサイズを把握し、手動でインストールすることを強くお勧めします。</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。シフトが小さすぎると、読み取り/書き込み操作の数が天文学的に増加します。つまり、512バイトの「セクター」を実際の4 KiBセクターに書き込むとは、最初の「セクター」を書き込んでから4 KiBセクターを読み取り、2番目の512バイトの「セクター」で変更し、新しい4 KiBセクターに書き込むということです。各エントリ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現実の世界では、このようなペナルティはSamsung EVO </font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSDを上回りますが、SSD </font><font style="vertical-align: inherit;">は動作する必要</font><font style="vertical-align: inherit;">がありますが、これらのSSDはセクターサイズに依存しているため、デフォルトで設定されています</font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。経験豊富なシステム管理者がこの設定を変更しない場合、このSSDは</font><font style="vertical-align: inherit;">通常の磁気HDD </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも低速です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較のため、大きすぎるサイズ</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事実上罰則はありません。</font><font style="vertical-align: inherit;">生産性が実際に低下することはなく、未使用スペースの増加は限りなく小さくなります（または圧縮を有効にするとゼロに等しくなります）。</font><font style="vertical-align: inherit;">したがって、512バイトセクターを実際に使用するドライブをインストールする</font></font><code>ashift=12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、将来に自信を持って</font><font style="vertical-align: inherit;">ドライブすることを強くお勧めし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロパティは</font><font style="vertical-align: inherit;">、多くの人が誤って考えているように</font><i><font style="vertical-align: inherit;">、プール</font></i><font style="vertical-align: inherit;">で</font><i><font style="vertical-align: inherit;">はなく</font></i></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各vdev仮想デバイスに設定され</font><font style="vertical-align: inherit;">、インストール後も変更されません。</font><font style="vertical-align: inherit;">新しいvdevをプールに追加するときに</font><font style="vertical-align: inherit;">誤ってノックダウンした</font><font style="vertical-align: inherit;">場合は、このプールを低パフォーマンスのデバイスで取り返しのつかない形で汚染し、原則として、プールを破棄して最初からやり直す以外に方法はありません。</font><font style="vertical-align: inherit;">vdevを削除しても、壊れたセットアップからあなたを救うことはありません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>ashift</code><font style="vertical-align: inherit;"></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<h3>   </h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/38b/a1e/4a8/38ba1e4a8fa0e255081ed8db259a302f.gif"><br>
<i><font color="gray">      &nbsp;—     ,   </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90d/4cb/a35/90d4cba35ffa5a3e44a7ca5f61d4491b.gif"><br>
<i><font color="gray">         ,     </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c8b/2af/ffb/c8b2afffbc46f63f6a7fe1167edf5dcb.gif"><br>
<i><font color="gray">  ,      ,   « »   « »,        </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4c1/e2b/818/4c1e2b818077cb07d651527e214363fe.gif"><br>
<i><font color="gray">     ,       —      ,     ,       </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コピーオンライト（CoW）は、ZFSを非常に優れたものにする基本的な基盤です。基本的な概念は単純です。従来のファイルシステムにファイルの変更を依頼した場合、要求どおりに機能します。録音中にコピーを行うファイルシステムに同じことを依頼すると、「良好」と表示されますが、それはあなたにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、コピー書き込みファイルシステムは、変更されたブロックの新しいバージョンを書き込み、次にファイルメタデータを更新して、古いブロックとのリンクを解除し、書き込んだばかりの新しいブロックを関連付けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いユニットの取り外しと新しいユニットのリンクは1回の操作で行われるため、中断することはできません。この後に電源をリセットすると、新しいバージョンのファイルが作成され、以前に電源をリセットすると、古いバージョンが作成されます。</font><font style="vertical-align: inherit;">いずれの場合も、ファイルシステムに競合はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSへの書き込み時のコピーは、ファイルシステムレベルだけでなく、ディスク管理レベルでも行われます。</font><font style="vertical-align: inherit;">これは、ZFSがレコード内のスペース（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAIDの穴</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">影響を受けないことを意味します。これは</font><font style="vertical-align: inherit;">、システムがクラッシュする前にストリップが部分的にしか記録できず、再起動後にアレイが損傷した現象です。</font><font style="vertical-align: inherit;">ここで、ストリップはアトミックであり、vdevは常に一貫しており、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボブはあなたの叔父</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZIL：ZFSインテントログ</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/567/71c/73f/56771c73f9a28ebaed161e02313deadb.png"><br>
<i><font color="gray"> ZFS     &nbsp;—  ,      ZIL,            </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/cec/7c5/437/cec7c5437087f6816f9cdea5f6829820.png"><br>
<i><font color="gray"> ,   ZIL,    .      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/075/65a/d6b/07565ad6b2f431db3e6bc20cd24a653b.png"><br>
<i><font color="gray">SLOG,   LOG-, —   &nbsp;— , ,  &nbsp;—&nbsp;vdev,  ZIL      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/927/0f7/539/9270f7539b759aa37896d41e04c4ec47.png"><br>
<i><font color="gray">      ZIL &nbsp;—    ZIL   SLOG,      </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書き込み操作には、同期（同期）と非同期（非同期）の2つの主なカテゴリがあります。ほとんどのワークロードでは、書き込み操作の大部分は非同期です。ファイルシステムでは、それらを集約してバッチで配信できるため、断片化が減少し、スループットが大幅に向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期録音はまったく別の問題です。アプリケーションが同期書き込みを要求すると、ファイルシステムに次のように通知します。「これを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今すぐ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不揮発性メモリにコミットする必要があり</font><font style="vertical-align: inherit;">、それまではこれ以上何もできません。」したがって、同期レコーディングはすぐにディスクにコミットする必要があります。これにより、断片化が増加したり、帯域幅が減少したりする場合は、そうする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSは同期レコードを通常のファイルシステムとは異なる方法で処理します。ZFSはそれらを通常のストレージにすぐにアップロードするのではなく、ZFSインテントログ（ZFSインテントログ）と呼ばれる特別なストレージ領域に記録します。トリックは、これらのレコード</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリに残り、通常の非同期書き込み要求とともに集約され、後で完全に通常のTXG（トランザクショングループ、トランザクショングループ）としてストレージにダンプされることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の操作では、ZILは記録され、再度読み取られることはありません。しばらくすると、ZILからの録音がRAMから通常のTXGの主ストレージに固定されると、ZILから切断されます。 ZILから何かが読み取られるときの唯一のことは、プールをインポートするときです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSがクラッシュした場合-オペレーティングシステムがクラッシュしたり停電したりした場合-ZILにデータがあると、次のプールのインポート中にこのデータが読み込まれます（緊急システムの再起動時など）。 ZILにあるものはすべて読み取られ、TXGグループに結合されて主ストレージにコミットされ、インポートプロセス中にZILから切断されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vdevヘルパークラスの1つは、LOGまたはSLOG（セカンダリLOGデバイス）と呼ばれます。彼は1つのタスクを持っています-メインのvdevストレージにZILを格納する代わりに、ZILを格納するための非常に高い書き込み耐性を持つvdevデバイスを、できればはるかに高速にプールに提供することです。 ZIL自体はストレージの場所に関係なく同じように動作しますが、LOGを使用するvdevの書き込みパフォーマンスが非常に高い場合、同期書き込みはより高速になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOGを含むvdevをプールに追加し</font><font style="vertical-align: inherit;">ても、非同期書き込みのパフォーマンス</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向上し</font><b><font style="vertical-align: inherit;">ません</font></b><font style="vertical-align: inherit;"> -を使用してZILへのすべての書き込みを強制</font></font><code>zfs set sync=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したとしても、ログがない場合と同じ方法で同じ速度でTXGのメインリポジトリに関連付けられます。</font><font style="vertical-align: inherit;">直接的なパフォーマンスの改善は、同期記録の遅延のみです（ログ速度が高いほど操作が高速化されるため</font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、すでに多数の同期書き込みが必要な環境では、vdev LOGは間接的に非同期書き込みと非キャッシュ読み取りを高速化できます。</font><font style="vertical-align: inherit;">ZILレコードを別のvdev LOGにアップロードすると、プライマリストレージでのIOPSの競合が少なくなり、すべての読み取りおよび書き込み操作のパフォーマンスがある程度向上します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書き込みコピーメカニズムは、アトミックZFSスナップショットおよび増分非同期レプリケーションの不可欠な基盤でもあります。</font><font style="vertical-align: inherit;">アクティブファイルシステムには、すべてのレコードを現在のデータでマークするポインターツリーがあります。スナップショットを作成するときは、このポインターツリーのコピーを作成するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクティブなファイルシステムでレコードが上書きされると、ZFSは最初にブロックの新しいバージョンを未使用のスペースに書き込みます。</font><font style="vertical-align: inherit;">次に、古いバージョンのブロックを現在のファイルシステムから切り離します。</font><font style="vertical-align: inherit;">ただし、一部のスナップショットが古いブロックを参照している場合でも、変更されません。</font><font style="vertical-align: inherit;">古いブロックは、このブロックにリンクしているすべてのスナップショットが破棄されるまで、実際には空き領域として復元されません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レプリケーション</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e69/167/01d/e6916701d4aa3ff27bb42efc43be60da.png"><br>
<i><font color="gray">  Steam  2015   158&nbsp;   126&nbsp;927 .        rsync&nbsp;—  ZFS    « »  750% .</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/25f/376/0ab/25f3760ab64d6647571b9c02804b39f0.png"><br>
<i><font color="gray">      40-     Windows 7&nbsp;—   .  ZFS   289  ,  rsync&nbsp;—  «»  161  ,    ,   rsync   --inplace.</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/776/46b/a3a/77646ba3ac20eeb0933d7dc7d644296c.png"><br>
<i><font color="gray">    ,  rsync    .  1,9         &nbsp;—    ,   ZFS   1148  ,  rsync,    rsync --inplace</font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スナップショットの仕組みを理解したら、レプリケーションの本質を簡単に把握できます。スナップショットはレコードへのポインタのツリーにすぎないため、スナップショットを作成すると、</font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このツリーとそれに関連付けられているすべてのレコードが送信されます。我々はこれを渡す場合</font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には</font></font><code>zfs receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、対象物への、それはブロックの実際の内容とターゲット・データ・セットにブロックを参照するポインタの木の両方を書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが2番目にさらに面白くなり</font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これで2つのシステムがあり、それぞれにが含まれていて</font></font><code>poolname/datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、新しいスナップショットを撮影します</font></font><code>poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、ソースプールにはとが</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font></font><code>datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ターゲットプールにはこれまでのところ最初のスナップショットしかありません</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースとターゲットの間で共通のスナップショットがあるので</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私たちはそれに加えて</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インクリメンタル</font></font></i> <code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">行うことができ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。システム</font></font><code>zfs send -i poolname/datasetname@1 poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">通知する</font><font style="vertical-align: inherit;">と、2つのポインタツリーが比較されます。にのみ存在するポインタは</font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、明らかに、新しいブロックを参照しているため、これらのブロックの内容が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リモートシステムでは、増分処理も</font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じくらい簡単です。まず、ストリーム</font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">含まれるすべての新しいエントリを記録し、</font><font style="vertical-align: inherit;">次にこれらのブロックへのポインターを追加します。ほら、</font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいシステムで！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS非同期インクリメンタルレプリケーションは、rsyncのような以前の非スナップショット方式よりも大幅に改善されています。どちらの場合も、変更されたデータのみが送信されますが、rsyncは最初に</font><i><font style="vertical-align: inherit;">読み取る</font></i><font style="vertical-align: inherit;">必要があり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスクからすべてのデータを両側からチェックして、量を比較します。</font><font style="vertical-align: inherit;">これとは対照的に、ZFSレプリケーションは、ポインタツリーと、一般的なスナップショットで表されていないブロックのみを読み取ります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インライン圧縮</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コピーオンライトメカニズムは、組み込みの圧縮システムも簡素化します。従来のファイルシステムでは、圧縮に問題があります。変更されたデータの古いバージョンと新しいバージョンの両方が同じスペースにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルの真ん中にあるデータの一部を、0x00000000から始まるゼロのメガバイトとして開始すると考えると、ディスク上の1つのセクターに圧縮するのは非常に簡単です。しかし、このメガバイトのゼロを、JPEGや疑似ランダムノイズなどの非圧縮データのメガバイトで置き換えるとどうなりますか？突然、このメガバイトのデータは1つではなく、4 KiBの256セクターを必要とし、ディスク上のこの場所には1つのセクターのみが予約されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更されたレコードは常に未使用スペースに書き込まれるため、ZFSにはそのような問題はありません。元のブロックは4 KiBセクターを1つだけ占有し、新しいレコードは256になりますが、これは問題ではありません。ファイルの「中央」から最近変更されたフラグメントが未使用スペースに書き込まれます。サイズが変更されたかどうかに関係なく、ZFSの場合、これは通常の状況です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組み込みのZFS圧縮はデフォルトで無効になっており、システムはプラグインアルゴリズムを提供します。現在、LZ4、gzip（1-9）、LZJB、ZLEなどがあります。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、かなり遅いCPUでも、ほとんどのユースケースで非常に高速な圧縮と解凍およびパフォーマンスの向上を提供するストリーミングアルゴリズムです。</font></font><br>
</li>
<li><b>GZIP</b> —  ,       Unix-.        1-9,       CPU      9.       (   )  ,    &nbsp;   c CPU&nbsp;—    ,     .<br>
</li>
<li><b>LZJB</b> —    ZFS.       , LZ4     .<br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLE-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロレベルエンコーディング、ゼロレベルエンコーディング。</font><font style="vertical-align: inherit;">通常のデータにはまったく触れませんが、一連の大きなゼロを圧縮します。</font><font style="vertical-align: inherit;">完全に非圧縮性のデータセット（JPEG、MP4、または他の既に圧縮された形式など）に役立ちます。これは、非圧縮性のデータを無視しますが、結果のレコードの未使用領域を圧縮するためです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどすべてのユースケースでLZ4圧縮をお勧めします。</font><font style="vertical-align: inherit;">非圧縮データに遭遇するための性能ペナルティは非常に小さく、</font><font style="vertical-align: inherit;">性能</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利得</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の典型的なデータのためには重要です。</font><font style="vertical-align: inherit;">Windowsオペレーティングシステム（新たにインストールされているOS、まだ内部のデータなし）の新規インストール用の仮想マシンイメージをコピーする</font></font><code>compression=lz4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27％高速化とより渡された</font></font><code>compression=none</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中で、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この2015年のテスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC-適応置換キャッシュ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSは、独自の読み取りキャッシュメカニズムを使用する唯一の最新のファイルシステムであり、オペレーティングシステムのページキャッシュに依存せずに最近読み取ったブロックのコピーをRAMに格納します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
独自のキャッシュに問題がないわけではありませんが、ZFSはカーネルと同じ速さで新しいメモリ割り当て要求に応答できないため、</font></font><code>malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARCが現在占有しているRAMが必要な場合</font><font style="vertical-align: inherit;">、新しい</font><font style="vertical-align: inherit;">メモリ割り当て</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">は失敗する可能性があります。</font><font style="vertical-align: inherit;">ただし、少なくとも現時点では、独自のキャッシュを使用する十分な理由があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MacOS、Windows、Linux、BSDなど、よく知られている最新のオペレーティングシステムはすべて、LRUアルゴリズム（Least Recently Used）を使用してページキャッシュを実装しています。これはプリミティブアルゴリズムであり、読み取りのたびにキャッシュブロックを「キューの上に」上げ、必要に応じて「ダウンキュー」ブロックをプッシュして、新しいキャッシュミス（キャッシュからではなくディスクから読み取られるはずのブロック）を上に押します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、アルゴリズムは問題なく機能しますが、作業データセットが大きいシステムでは、LRUは簡単にスラッシングを引き起こし、頻繁に必要なブロックを混雑させて、キャッシュから再度読み込まれないブロックのためのスペースを作ります。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-「重み付けされた」キャッシュと見なすことができる、それほど単純ではないアルゴリズム。キャッシュされたブロックを読み取るたびに、それは少し「重く」なり、クラウドアウトが難しくなります。さらに、ブロックアウトした後も</font><font style="vertical-align: inherit;">、一定期間</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追跡さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れます。絞り出された後、キャッシュに読み戻す必要があるブロックも「重く」なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての結果、はるかに大きなヒット率を持つキャッシュが作成されます。キャッシュ内のヒット（キャッシュからの読み取り）とミス（ディスクからの読み取り）の間の比率です。</font><font style="vertical-align: inherit;">これは非常に重要な統計です-キャッシュヒット自体が桁違いに速く処理されるだけでなく、キャッシュミスもより速く処理できます。これは、キャッシュヒットが多いほど、同時ディスク要求が少なくなり、処理する必要のある残りのミスの遅延が少なくなるためです。ドライブ。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFSの基本的なセマンティクス（書き込み時のコピーのしくみ、およびストレージプール、仮想デバイス、ブロック、セクター、ファイル間の関係）を調査した後、実際のパフォーマンスと実際の数値について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパートでは、ミラーリングされたvdevとRAIDzを使用したプールの実際のパフォーマンスを、相互に比較し、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に調べ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">従来のLinuxカーネルRAIDトポロジと比較し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は基本（ZFSトポロジ自体）のみを検討したかったのですが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後</font><font style="vertical-align: inherit;">は、L2ARC、SLOG、特別割り当てなどの補助vdevタイプの使用を含む、より高度なZFSチューニングとチューニングについて説明する準備が整います。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504680/index.html">SpaLのNLPライブラリの概要</a></li>
<li><a href="../ja504682/index.html">ノスタルジアポスト：j2me、Gravity Defied、64kb</a></li>
<li><a href="../ja504686/index.html">猫の描き方</a></li>
<li><a href="../ja504688/index.html">マスクは役に立たない：KOVID-19での社会政策の科学的批判</a></li>
<li><a href="../ja504690/index.html">ReactおよびReact Nativeパート3でAzure AD B2Cを構成した方法の物語（チュートリアル）</a></li>
<li><a href="../ja504694/index.html">デコレータのコンパイル方法-C ++、Python、および独自の実装。パート1</a></li>
<li><a href="../ja504696/index.html">OpenStreetMap No. 513の世界からのニュース（2020年5月12日〜2020年5月18日）</a></li>
<li><a href="../ja504698/index.html">リモートサイトでのオンボーディング</a></li>
<li><a href="../ja504700/index.html">ソビエトグラフィックタブレット「スケッチ」</a></li>
<li><a href="../ja504702/index.html">人々は英語を知りたくない</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>