<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤧 👲🏼 👉🏾 文本字段识别结果的后处理算法 🎄 👉🏼 🏺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（图像取自此处）
 
 今天，我们想告诉您有关基于字段先验知识对文本字段识别结果进行后处理的任务。之前，我们已经写过有关基于三字组的字段校正方法的文章，该方法使您可以校正用自然语言编写的单词的某些识别错误。但是，重要文件（包括身份证明文件）中的很大一部分是性质不同的字段-日期，数字，汽车的VIN码，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>文本字段识别结果的后处理算法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/smartengines/blog/498520/"><img src="https://habrastorage.org/webt/we/b4/48/web4484wjnlsdgvcvav8khbyirq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（图像取自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
今天，我们想告诉您有关基于字段先验知识对文本字段识别结果进行后处理的任务。之前，我们已经写过有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三字</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">组的字段校正方法的</font></a><font style="vertical-align: inherit;">文章，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">方法</font></a><font style="vertical-align: inherit;">使您可以校正用自然语言编写的单词的某些识别错误。但是，重要文件（包括身份证明文件）中的很大一部分是性质不同的字段-日期，数字，汽车的VIN码，TIN和SNILS号码，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器可读区域</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与他们的校验和等等。</font><font style="vertical-align: inherit;">尽管不能将它们归因于自然语言的字段，但是，这些字段通常具有某些（有时是隐式的）语言模型，这意味着某些校正算法也可以应用于它们。</font><font style="vertical-align: inherit;">在本文中，我们将讨论两种用于后处理识别结果的机制，这些机制可用于大量文档和字段类型。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该领域的语言模型可以有条件地分为三个部分：</font></font><br>
<ol>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：规则，用于控制文本字段表示的结构。</font><font style="vertical-align: inherit;">示例：机器可读区域中的“文档到期日期”字段表示为七个数字“ DDDDDDD”。</font></font><br>
</li>
<li><em> </em>: ,         . :   “    ” -     –     , 3-  4-  –  , 5-  6- –  ,  7-  –  .<br>
</li>
<li><em> </em>: ,           . :  “    ”    ,     ,   “ ”.<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有了有关文档和已识别字段的语义和句法结构的信息，您可以构建用于对识别结果进行后处理的专用算法。但是，考虑到支持和开发识别系统的需求以及其开发的复杂性，有趣的是考虑“通用”的方法和工具，这些方法和工具将允许（开发人员）以最小的努力来构建一个相当好的后处理算法，该算法可以与广泛的类一起工作。文档和字段。建立和支持这种算法的方法将统一起来，只有语言模型将成为算法结构的可变组成部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得注意的是，文本字段识别结果的后处理并不总是有用的，有时甚至是有害的：如果您有一个很好的行识别模块，并且在具有标识文档的关键系统中工作，那么某种后处理最好尽量减少并“按原样”产生结果，或者清楚地监视任何更改并将其报告给客户。但是，在许多情况下，当已知文档有效且该领域的语言模型可靠时，使用后处理算法可以显着提高最终识别质量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，本文将讨论两种声称具有通用性的后处理方法。</font><font style="vertical-align: inherit;">第一种是基于加权的有限转换器，需要以有限状态机的形式描述语言模型，不是很容易使用，但是更通用。</font><font style="vertical-align: inherit;">第二种方法更易于使用，效率更高，只需要编写一个用于检查字段值有效性的函数，还具有许多缺点。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加权末端发送器方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个美丽而相当普遍的模式，让您能够建立后处理识别结果的通用算法描述</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了这项工作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该模型依赖于加权有限状态传感器（WFST）的数据结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFSTs是加权有限状态机的一般化-如果加权有限状态机编码一些加权语言</font></font><img src="https://habrastorage.org/getpro/habr/post_images/899/a67/551/899a675510d28419769a9b42281f0c65.svg" alt="大号"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（即，在一定的字母表的加权组线</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4e1/b49/a1f/4e1b49a1f827737c3c2fec7b6eeef35b.svg" alt="一个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后WFST编码语言的加权地图</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a2a/b58/822/a2ab5882273242f94981925836a91ec8.svg" alt="L_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字母表上述</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a6/b12/09b/2a6b1209bdf752a5f991cb012b5b791a.svg" alt="A_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成语言</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3c4/611/0c4/3c46110c45a2c9d8d3c279cad331920b.svg" alt="L_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字母表以上</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c45/bcf/e9fc45bcff4c99d6b42a83b8da01eabd.svg" alt="A2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。加权有限状态机，</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="小号"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在字母上</font><font style="vertical-align: inherit;">取一个字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4e1/b49/a1f/4e1b49a1f827737c3c2fec7b6eeef35b.svg" alt="一个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，为其分配一些权重</font></font><img src="https://habrastorage.org/getpro/habr/post_images/02b/27e/089/02b27e089139bd8efdfe985192ec9336.svg" alt="w"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而WFST，取一个字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/325/913/78f/32591378f1f3c477755274a1269b0f49.svg" alt="S_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在字母表上</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a6/b12/09b/2a6b1209bdf752a5f991cb012b5b791a.svg" alt="A_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，与之相关联的是一组（可能是无限的）对</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d13/6d6/65d/d136d665d0c512df23a1eae1000eb95f.svg" alt="\ {＆lt; S_2 ^ 1，w_1＆gt ;, \ ldots，＆lt; S_2 ^ k，w_k＆gt ;, \ ldots \}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中</font></font><img src="https://habrastorage.org/getpro/habr/post_images/917/beb/0cc/917beb0cc43863c39e8041595dc6f95c.svg" alt="S_2 ^ i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字母表上方</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c45/bcf/e9fc45bcff4c99d6b42a83b8da01eabd.svg" alt="A2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的线是要转换为的线</font></font><img src="https://habrastorage.org/getpro/habr/post_images/325/913/78f/32591378f1f3c477755274a1269b0f49.svg" alt="S_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg" alt="w_i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是该</font><font style="vertical-align: inherit;">转换</font><font style="vertical-align: inherit;">的权重。转换器的每个转换都有两个状态（在两个状态之间进行转换），输入字符（来自字母</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a6/b12/09b/2a6b1209bdf752a5f991cb012b5b791a.svg" alt="A_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），输出字符（来自字母</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c45/bcf/e9fc45bcff4c99d6b42a83b8da01eabd.svg" alt="A2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和转换权重。空字符（空字符串）被视为两个字母的元素。字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fb1/4b2/485/fb14b2485daa4b8f13252981a33df4e5.svg" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到字符串</font><font style="vertical-align: inherit;">转换</font></font><img src="https://habrastorage.org/getpro/habr/post_images/92f/e45/5fc/92fe455fc98f988c4d76f3d76b36d7ef.svg" alt="ÿ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的权重是沿所有路径的过渡权重乘积的总和，在这些路径上输入字符的串联构成字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fb1/4b2/485/fb14b2485daa4b8f13252981a33df4e5.svg" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而输出字符的串联构成字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/92f/e45/5fc/92fe455fc98f988c4d76f3d76b36d7ef.svg" alt="ÿ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并将转换器从初始状态转移到终端状态之一。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合成操作是在WFST上确定的，后处理方法基于WFST。让两个变压器被赋予</font></font><img src="https://habrastorage.org/getpro/habr/post_images/173/a12/2f7/173a122f7849b9134ce2718c6e02ab46.svg" alt="T_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><img src="https://habrastorage.org/getpro/habr/post_images/052/301/117/052301117e72c384454188c12ba6ec0b.svg" alt="T_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><img src="https://habrastorage.org/getpro/habr/post_images/173/a12/2f7/173a122f7849b9134ce2718c6e02ab46.svg" alt="T_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换线</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fb1/4b2/485/fb14b2485daa4b8f13252981a33df4e5.svg" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bf4/953/6ff/bf49536ff21c20c8dd6a6c30fa00884f.svg" alt="斧头"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的线</font></font><img src="https://habrastorage.org/getpro/habr/post_images/92f/e45/5fc/92fe455fc98f988c4d76f3d76b36d7ef.svg" alt="ÿ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ea9/1a9/a75/ea91a9a754c501c4e117285194fc1d8c.svg" alt="A_y"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有重量</font></font><img src="https://habrastorage.org/getpro/habr/post_images/f8d/841/546/f8d84154605b3652f439d036c0ae04ca.svg" alt="w_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><img src="https://habrastorage.org/getpro/habr/post_images/052/301/117/052301117e72c384454188c12ba6ec0b.svg" alt="T_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换</font></font><img src="https://habrastorage.org/getpro/habr/post_images/92f/e45/5fc/92fe455fc98f988c4d76f3d76b36d7ef.svg" alt="ÿ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ea9/1a9/a75/ea91a9a754c501c4e117285194fc1d8c.svg" alt="A_y"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的线</font></font><img src="https://habrastorage.org/getpro/habr/post_images/be9/efa/777/be9efa77761b1343076071d07add5798.svg" alt="ž"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b04/afc/54f/b04afc54f564b1e7dc5ff1c3a8ec48cf.svg" alt="A_z"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与重量</font></font><img src="https://habrastorage.org/getpro/habr/post_images/1ad/f05/4f5/1adf054f58e7620e4f853f436b39fcaa.svg" alt="w_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，转换器</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d0f/ef7/45a/d0fef745aef55c9cccf5c3b3999dbdb3.svg" alt="T_1 \大约T_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（称为</font><font style="vertical-align: inherit;">转换器</font><font style="vertical-align: inherit;">的组成部分）将字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fb1/4b2/485/fb14b2485daa4b8f13252981a33df4e5.svg" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换为</font></font><img src="https://habrastorage.org/getpro/habr/post_images/be9/efa/777/be9efa77761b1343076071d07add5798.svg" alt="ž"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有权重</font><font style="vertical-align: inherit;">的字符串</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6b6/267/867/6b6267867aed215a641ef6b00fdbf382.svg" alt="w_1 \ cdot w_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。换能器的组成在计算上是昂贵的操作，但是它可以延迟计算-可以在需要访问换能器的时刻构造最终换能器的状态和转换。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于WFST的识别结果的后处理算法基于三个主要的信息源-假设</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c25/cdf/6f3/c25cdf6f30745730e0ef76706327c970.svg" alt="m"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型，错误模型</font></font><img src="https://habrastorage.org/getpro/habr/post_images/efb/79e/7df/efb79e7df0792cea483c6ed41efea702.svg" alt="电磁"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和语言模型</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b8f/002/734/b8f002734a17c86c9be6e9e3aa8cdfb0.svg" alt="LM"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这三种模型均以加权最终换能器的形式表示：</font></font><br>
<br>
<ol>
<li><em> </em> <img src="https://habrastorage.org/getpro/habr/post_images/c25/cdf/6f3/c25cdf6f30745730e0ef76706327c970.svg" alt="m">       (  WFST –      ,       ),  ,    .  ,         <img src="https://habrastorage.org/getpro/habr/post_images/2b4/73f/d75/2b473fd75c118eae403e73e06abc0cfc.svg" alt="C_1, C_2, \ldots, C_N">,                 (): <img src="https://habrastorage.org/getpro/habr/post_images/efd/145/e4a/efd145e4a2defc2ed71b4e24bf8e9bd1.svg" alt="C_i = \{&amp;lt;a_{i1}, q_{i1}&amp;gt;, \ldots, &amp;lt;a_{ik}, q_{ik}&amp;gt;\}">,  <img src="https://habrastorage.org/getpro/habr/post_images/af8/a1c/f66/af8a1cf667abc5982ba8b1008ab1d698.svg" alt="a_{ij}"> – <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">-  , <img src="https://habrastorage.org/getpro/habr/post_images/8c6/26b/064/8c626b0640801ca8b783dd4d27187a9e.svg" alt="q_{ij}"> –  ()  .           <img src="https://habrastorage.org/getpro/habr/post_images/c3c/523/a87/c3c523a878065a0846fa7e92f7e5293c.svg" alt="(N+1)">- ,   : <img src="https://habrastorage.org/getpro/habr/post_images/5f8/55a/b76/5f855ab76444c11e5dff28e478ebe06a.svg" alt="0">-   , <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N">- – ,    <img src="https://habrastorage.org/getpro/habr/post_images/afd/e82/597/afde825977cf3ca73a2f1952aa66c2cd.svg" alt="(i-1)">-  <img src="https://habrastorage.org/getpro/habr/post_images/75c/b01/aa8/75cb01aa8d9f97db4343ac0c5ef11b2d.svg" alt="i">-     <img src="https://habrastorage.org/getpro/habr/post_images/0c5/724/5db/0c57245dbd3c18e987498491056a7911.svg" alt="C_i">.  <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">-        <img src="https://habrastorage.org/getpro/habr/post_images/af8/a1c/f66/af8a1cf667abc5982ba8b1008ab1d698.svg" alt="a_{ij}">,       .       ,       .<br>
<img src="https://habrastorage.org/webt/7k/jo/13/7kjo13f-3_8ydvxj2ub421zhzyq.png"><br>
. 1.   ,    WFST (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>).     .<br>
</li>
</ol><br>
<ol>
<li><em> </em> <img src="https://habrastorage.org/getpro/habr/post_images/efb/79e/7df/efb79e7df0792cea483c6ed41efea702.svg" alt="EM">    ,    ,          .           WFST    (     ).         .  ,            .<br>
</li>
<li><em> </em> <img src="https://habrastorage.org/getpro/habr/post_images/b8f/002/734/b8f002734a17c86c9be6e9e3aa8cdfb0.svg" alt="LM">            . ..    ,       (      ).<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在定义了假设，错误和语言模型之后，现在可以提出如下处理后识别结果的任务：考虑所有三个模型的组成</font></font><img src="https://habrastorage.org/getpro/habr/post_images/258/b21/786/258b217865a28732f7efea99f27844a5.svg" alt="T=HM\circ EM\circ LM"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（就WFST组成而言）。转换器</font></font><img src="https://habrastorage.org/getpro/habr/post_images/365/0cb/4e8/3650cb4e8670eeb97ce55a835259374a.svg" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fb1/4b2/485/fb14b2485daa4b8f13252981a33df4e5.svg" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设模型</font><font style="vertical-align: inherit;">中字符串的所有可能转换编码</font><font style="vertical-align: inherit;">为语言模型中的</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c25/cdf/6f3/c25cdf6f30745730e0ef76706327c970.svg" alt="HM"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font><font style="vertical-align: inherit;">，并将</font><font style="vertical-align: inherit;">错误模型中编码的转换</font><font style="vertical-align: inherit;">应用于字符串</font><font style="vertical-align: inherit;">。此外，这种转换的权重包括原始假设的权重，转换的权重和所得字符串的权重（在加权语言模型的情况下）。因此，在这种模型中，识别结果的最佳后处理将对应于转换器中的最佳（就重量而言）路径</font></font><img src="https://habrastorage.org/getpro/habr/post_images/be9/efa/777/be9efa77761b1343076071d07add5798.svg" alt="Z"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/b8f/002/734/b8f002734a17c86c9be6e9e3aa8cdfb0.svg" alt="LM"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/fb1/4b2/485/fb14b2485daa4b8f13252981a33df4e5.svg" alt="X"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/efb/79e/7df/efb79e7df0792cea483c6ed41efea702.svg" alt="EM"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/365/0cb/4e8/3650cb4e8670eeb97ce55a835259374a.svg" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其从初始状态转换为终端状态之一。沿着该路径的输入线将对应于所选的初始假设，而输出线将对应于校正后的识别结果。可以使用用于在有向图中找到最短路径的算法来寻找最佳路径。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法的优点是它的通用性和灵活性。例如，可以以考虑到字符的删除和添加的方式轻松扩展错误模型（为此，仅应将错误输出或输入符号分别为空的过渡添加到错误模型中）。但是，该模型具有明显的缺点。首先，这里的语言模型应该表示为有限加权的有限变换器。对于复杂的语言，这种自动机可能非常麻烦，并且在更改或完善语言模型的情况下，有必要对其进行重建。还应注意的是，这三个换能器的组成通常会带来更大的换能器，每次开始对一个识别结果进行后处理时，都会计算此组成。由于组合物的体积大，实际上必须使用启发式方法（例如A * -search）执行对最佳路径的搜索。</font></font><br>
<br>
<h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用验证语法模型，可以构造一个更简单的后处理识别结果任务模型，该模型不会像基于WFST的模型那样通用，但是易于扩展和易于实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查语法是一对</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fd3/47b/00c/fd347b00c55ac4ec6540b463ad680c1b.svg" alt="G=&amp;lt;A,P&amp;gt;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在哪里</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4e1/b49/a1f/4e1b49a1f827737c3c2fec7b6eeef35b.svg" alt="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字母，并且</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字符串在字母上的可容许性的谓词</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4e1/b49/a1f/4e1b49a1f827737c3c2fec7b6eeef35b.svg" alt="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即</font></font><img src="https://habrastorage.org/getpro/habr/post_images/282/f7a/5f2/282f7a5f2b4b8217fcb3e2f19c580e65.svg" alt="P:A^*\rightarrow\{0,1\}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。检查语法在字母表上编码某种语言</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4e1/b49/a1f/4e1b49a1f827737c3c2fec7b6eeef35b.svg" alt="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如下所示：</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cbd/a7d/cf3/cbda7dcf37fe5ffdfb068437f1a9639d.svg" alt="S\in A^*"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果谓词</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在该行上取真值，</font><font style="vertical-align: inherit;">则该</font><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">属于该语言</font><font style="vertical-align: inherit;">。值得注意的是，检查语法是一种比状态机更通用的语言模型表示方式。实际上，任何表示为有限状态机的语言</font></font><img src="https://habrastorage.org/getpro/habr/post_images/365/0cb/4e8/3650cb4e8670eeb97ce55a835259374a.svg" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以用检查语法的形式表示（带有谓词</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3de/a6c/104/3dea6c104ca5878cea71b4e0f6a431df.svg" alt="P(S)\Leftrightarrow S\in \mathrm{acc}(T)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ee2/9d3/119/ee29d3119304322fc8ff23735ff9c8bd.svg" alt="\mathrm{acc}(T)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是自动机接受的行的集合</font></font><img src="https://habrastorage.org/getpro/habr/post_images/365/0cb/4e8/3650cb4e8670eeb97ce55a835259374a.svg" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，在一般情况下，并不是所有可以表示为检查文法的语言都可以表示为有限自动机（例如，长度不受限制的单词语言）字母</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a98/43f/42d/a9843f42dac088912b353acfdcb9a4d1.svg" alt="A=\{a,b\}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中字符数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/77a/3eb/b47/77a3ebb4782888583e97885d3053b554.svg" alt="a"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大于</font><font style="vertical-align: inherit;">字符</font><font style="vertical-align: inherit;">数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/428/1f5/336/4281f5336579f64aa8eac86ca1503e43.svg" alt="b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让识别结果（假设模型）作为单元格序列给出</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2b4/73f/d75/2b473fd75c118eae403e73e06abc0cfc.svg" alt="C_1, C_2, \ldots, C_N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（与上一节相同）。为方便起见，我们假设每个单元格包含K个替代项，并且所有替代项估计值都为正值。字符串的评估值（权重）将被视为该字符串每个字符的等级的乘积。如果在一个检查文法的形式指定的语言模型</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fd3/47b/00c/fd347b00c55ac4ec6540b463ad680c1b.svg" alt="G=&amp;lt;A,P&amp;gt;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则后处理问题可以被配制为在一组控件的离散优化（最大化）问题</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6ef/02b/580/6ef02b58077800a2b22a5e71ecc6eeec.svg" alt="A^N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（设定长度的所有行的</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在字母表</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4e1/b49/a1f/4e1b49a1f827737c3c2fec7b6eeef35b.svg" alt="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与受理谓词）</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和功能性</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8d9/20b/0e8/8d920b0e847b392accd0e0d75498c7ed.svg" alt="F(S)=\prod_{i=1}^{N}q_i(S_i)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中，</font></font><img src="https://habrastorage.org/getpro/habr/post_images/1d3/735/3a3/1d37353a3480e6c9e24bf62a3fc10f3b.svg" alt="q_i(S_i)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是所述符号估计</font></font><img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg" alt="S_i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的</font></font><img src="https://habrastorage.org/getpro/habr/post_images/75c/b01/aa8/75cb01aa8d9f97db4343ac0c5ef11b2d.svg" alt="i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第i个小区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用控件的完整枚举来解决任何离散的优化问题（即使用一组有限的控件）。所描述的算法以功能值的降序有效地遍历控件（行），直到有效性谓词接受真实值为止。我们将</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">最大迭代次数</font><font style="vertical-align: inherit;">设置为</font><font style="vertical-align: inherit;">具有谓词的最大估计值的最大行数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们按降序估计秩序的替代品，而我们进一步假设，对于任何细胞的</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0c5/724/5db/0c57245dbd3c18e987498491056a7911.svg" alt="C_i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不平等</font></font><img src="https://habrastorage.org/getpro/habr/post_images/200/613/c3d/200613c3daed32c6a4e077ebbef7b2d0.svg" alt="q_{ij}\ge q_{ik}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">是真实的</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e18/bc0/ef5/e18bc0ef500bf2eacf31394cbb669379.svg" alt="j&amp;lt;k"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该位置将是</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6c8/161/6fd/6c81616fd0777598b5f72bb00fd1d82f.svg" alt="j_1,\ldots,j_N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与该行对应</font><font style="vertical-align: inherit;">的索引序列</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bff/a11/709/bffa1170928103888512e8f4abdf6e06.svg" alt="a_{1j_1},\ldots,a_{Nj_N}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。职位评估，即该职位的功能价值，请考虑与该职位中包含的指数相对应的产品替代评估</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d10/5a5/397/d105a539751b437b9b41c67ac7ed1c5b.svg" alt="\prod_{i=1}^N q_i{j_i}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。要存储位置，您需要</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据结构</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">允许您添加新位置（获取其地址），获取该地址处的位置并检查是否将指定位置添加到数据库中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在列出职位的过程中，我们将选择一个未评级最高的职位，然后</font><font style="vertical-align: inherit;">通过将一个当前位置所包含的索引之一</font><font style="vertical-align: inherit;">添加到当前队列中，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有可以从当前职位获得的</font><em><font style="vertical-align: inherit;">职位</font></em><font style="vertical-align: inherit;">添加到队列中以供考虑</font><font style="vertical-align: inherit;">。考虑队列</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将包含三元组</font></font><img src="https://habrastorage.org/getpro/habr/post_images/959/6c2/843/9596c2843676ec22e1ca35c324669dbd.svg" alt="&amp;lt;Q,R,I&amp;gt;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中</font></font><img src="https://habrastorage.org/getpro/habr/post_images/859/cfd/804/859cfd804dfe88b1fdb1b431d440de8e.svg" alt="Q"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-对未</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc2/e13/169/bc2e1316980f83eed49a82ca5dd0f525.svg" alt="R"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复查</font><font style="vertical-align: inherit;">位置的估计，</font><font style="vertical-align: inherit;">-在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中获得该位置</font></font><img src="https://habrastorage.org/getpro/habr/post_images/fdf/d51/092/fdfd51092bb8d23740bdaae45950aa8f.svg" alt="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的位置的地址</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">-位置元素的索引，其地址</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc2/e13/169/bc2e1316980f83eed49a82ca5dd0f525.svg" alt="R"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加了一个以获得该位置。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定位PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列</font><font style="vertical-align: inherit;">将需要一个数据结构，该数据结构允许您添加另一个三元组</font></font><img src="https://habrastorage.org/getpro/habr/post_images/959/6c2/843/9596c2843676ec22e1ca35c324669dbd.svg" alt="&amp;lt;Q,R,I&amp;gt;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及检索具有最大评级的三元组</font></font><img src="https://habrastorage.org/getpro/habr/post_images/859/cfd/804/859cfd804dfe88b1fdb1b431d440de8e.svg" alt="Q"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在算法的第一次迭代中，必须考虑</font></font><img src="https://habrastorage.org/getpro/habr/post_images/050/6aa/323/0506aa3230e4366f656c45913cf57b70.svg" alt="S_1=\{1,1,\ldots,1\}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有最大估计值</font><font style="vertical-align: inherit;">的位置</font><font style="vertical-align: inherit;">。如果谓词</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在与该位置对应的线上取真值，则算法结束。否则，将位置</font></font><img src="https://habrastorage.org/getpro/habr/post_images/325/913/78f/32591378f1f3c477755274a1269b0f49.svg" alt="S_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全部添加视图的所有三元组</font><font style="vertical-align: inherit;">，其中</font></font><img src="https://habrastorage.org/getpro/habr/post_images/72e/309/388/72e309388903ac3376e98d8e64316b3f.svg" alt="&amp;lt;Q\cdot q_{i2}/q_{i1},R(S_1),i&amp;gt;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，所有</font><font style="vertical-align: inherit;">位置都是</font><em><font style="vertical-align: inherit;">PositionBase中</font></em><font style="vertical-align: inherit;">起始位置的地址</font><font style="vertical-align: inherit;">。在算法的每个后续迭代中，从</font><em><font style="vertical-align: inherit;">PositionQueue中</font></em><font style="vertical-align: inherit;">提取</font><font style="vertical-align: inherit;">具有估计最大值</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">三元组</font><font style="vertical-align: inherit;">，将所讨论的位置</font><font style="vertical-align: inherit;">恢复</font><font style="vertical-align: inherit;">到初始位置</font><font style="vertical-align: inherit;">和索引</font><font style="vertical-align: inherit;">的地址</font><font style="vertical-align: inherit;">。如果该位置</font><font style="vertical-align: inherit;">已经被添加到考虑的</font><em><font style="vertical-align: inherit;">PositionBase</font></em><font style="vertical-align: inherit;">位置的数据库中</font><font style="vertical-align: inherit;">，则将其跳过，并从</font><em><font style="vertical-align: inherit;">PositionQueue中</font></em><font style="vertical-align: inherit;">提取具有估计最大值</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">下三个</font><em><font style="vertical-align: inherit;">位置</font></em><font style="vertical-align: inherit;">。否则，在与position对应的行上</font><font style="vertical-align: inherit;">检查谓词值</font><font style="vertical-align: inherit;">。如果谓词</font></font><img src="https://habrastorage.org/getpro/habr/post_images/f10/c62/9c6/f10c629c68a8bd9faeb57dbc4b293b4e.svg" alt="i\in\{1,\ldots,N\}"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/42e/06f/198/42e06f19806b7f405c5c29221d5331ee.svg" alt="R(S_1)"><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/959/6c2/843/9596c2843676ec22e1ca35c324669dbd.svg" alt="&amp;lt;Q,R,I&amp;gt;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/859/cfd/804/859cfd804dfe88b1fdb1b431d440de8e.svg" alt="Q"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/bc2/e13/169/bc2e1316980f83eed49a82ca5dd0f525.svg" alt="R"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/fdf/d51/092/fdfd51092bb8d23740bdaae45950aa8f.svg" alt="I"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S"><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/859/cfd/804/859cfd804dfe88b1fdb1b431d440de8e.svg" alt="Q"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这条线上取真值，然后算法结束。如果谓词</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此行上不接受真实值，则将该行</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（地址分配为</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3a1/668/281/3a1668281daf18680a259de22f952e27.svg" alt="R(S)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font><font style="vertical-align: inherit;">所有派生的位置都添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列</font><font style="vertical-align: inherit;">，然后进行下一次迭代。</font></font><br>
<br>
<pre><code class="plaintext hljs">FindSuitableString(M, N, K, P, C[1], ..., C[N]):<font></font>
      i : 1 ... N:<font></font>
         C[i]    <font></font>
    ( )<font></font>
     PositionBase  PositionQueue<font></font>
    S_1 = {1, 1, 1, ..., 1}<font></font>
     P(S_1): <font></font>
        : S_1,  <font></font>
    ( )<font></font>
     S_1  PositionBase   R(S_1)<font></font>
      i : 1 ... N:<font></font>
         K &gt; 1, :<font></font>
              &lt;Q * q[i][2] / q[i][1], R(S_1), i&gt;  PositionQueue<font></font>
        ( )<font></font>
    ( )<font></font>
        PositionBase  M:<font></font>
           PositionQueue:<font></font>
              PositionQueue  &lt;Q, R, I&gt;   Q<font></font>
            S_from =   PositionBase   R<font></font>
            S_curr = {S_from[1], S_from[2], ..., S_from[I] + 1, ..., S_from[N]}<font></font>
             S_curr   PositionBase:<font></font>
                 <font></font>
            :<font></font>
                 S_curr  PositionBase   R(S_curr)<font></font>
            ( )<font></font>
             P(S_curr):<font></font>
                : S_curr,  <font></font>
            ( )<font></font>
              i : 1 ... N:<font></font>
                 K &gt; S_curr[i]:<font></font>
                      &lt;Q * q[i][S_curr[i] + 1] / q[i][S_curr[i]], <font></font>
                                     R(S_curr),<font></font>
                                     i&gt;  PositionQueue<font></font>
                ( )<font></font>
            ( )<font></font>
               <font></font>
        ( )<font></font>
    ( )<font></font>
        M <font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，在</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迭代谓词将不超过检查</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一次，不会再有更多的</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且除了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从提取</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及在搜索</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不超过发生</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d3c/ea0/60e/d3cea060e08931d2d2ae58bc4c90f712.svg" alt="M\cdot N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一次。如果实现</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionQueue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用数据结构的“束”，并且对于组织</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PositionBase</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用数据结构“ Bor”，则算法的复杂度为</font><font style="vertical-align: inherit;">- </font></font><img src="https://habrastorage.org/getpro/habr/post_images/8f6/6c0/ef2/8f66c0ef2fb6320ab87d5f1e728d4586.svg" alt="O\left(M \cdot \left(p(N) +N^2+N \log(M\cdot N)\right)\right)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3bd/ae2/7e6/3bdae27e65ac0c352379343b50b3a1b0.svg" alt="p(N)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，最重要的测试取决于</font></font><img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行的长度</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于检查语法的算法最重要的缺点可能是它无法处理不同长度的假设（这可能是由于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分割</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误而引起的</font><font style="vertical-align: inherit;">：丢失或出现多余字符，粘连和剪切字符等），而可以在基于WFST的算法的错误模型中对假设的更改（例如“删除字符”，“添加字符”甚至“用一对替换字符”）进行编码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，速度和易用性（当使用新型字段时，您只需要使算法能够访问值验证功能），使得基于语法检查的方法成为文档识别系统开发人员中非常强大的工具。</font><font style="vertical-align: inherit;">我们将这种方法用于大量的各个字段，例如各个日期，银行卡号（谓词-检查</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">月球代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），带有校验和的机器可读文档区域的字段，以及许多其他字段。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该出版物是根据以下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备的</font><font style="vertical-align: inherit;">：基于验证语法的用于后处理识别结果的通用算法。</font><font style="vertical-align: inherit;">K.B. </font><font style="vertical-align: inherit;">布拉托夫（D.P.）</font><font style="vertical-align: inherit;">尼古拉耶夫（V.V. </font><font style="vertical-align: inherit;">Postnikov。</font><font style="vertical-align: inherit;">ISA RAS会议论文集，第65卷，第4期，2015年，第68-73页。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498504/index.html">新年问候和COVID-19：黑客如何使用新闻</a></li>
<li><a href="../zh-CN498510/index.html">X。盒装电话概述和连接到远程站点</a></li>
<li><a href="../zh-CN498512/index.html">用一个小预算在一个小镇中消除交通拥堵：该项目6个月的结果</a></li>
<li><a href="../zh-CN498516/index.html">邮递员-AppMetrica中的AutoMetrica指标</a></li>
<li><a href="../zh-CN498518/index.html">计算定制生产的可用日期的简化方法</a></li>
<li><a href="../zh-CN498524/index.html">AppCode 2020.1：性能改进，自动完成到索引结束，文档生成等</a></li>
<li><a href="../zh-CN498526/index.html">Ubuntu 20.04的新增功能</a></li>
<li><a href="../zh-CN498528/index.html">在家庭和办公室之间。如何组织分布式团队的工作</a></li>
<li><a href="../zh-CN498534/index.html">识别文件和人员：以自由的名义联合还是迈向数字独裁？</a></li>
<li><a href="../zh-CN498536/index.html">如何在symfony 5 bundle中重用代码？第2部分。我们取出捆绑包中的代码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>