<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèΩ üë®‚Äçüëß‚Äçüë¶ üñïüèø Flutter. BlOC, Provider, async - Shelf Architecture üíÆ ‚ûï ‚òÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction
 When you try to write an application, the first thing you come across is how to organize the architecture of the application. And when i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flutter. BlOC, Provider, async - Shelf Architecture</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you try to write an application, the first thing you come across is how to organize the architecture of the application. </font><font style="vertical-align: inherit;">And when it comes to Flutter, the head can completely go round what Google gives out - Vanilla, Scoped Model, BLoC, MVP, MVC, MVVM, MVI, etc. </font><font style="vertical-align: inherit;">Suppose you decide to go in the most fashionable way (the one that Google advised in 2018) and use BLOC. </font><font style="vertical-align: inherit;">What is it? </font><font style="vertical-align: inherit;">How to use it? </font><font style="vertical-align: inherit;">Or maybe Redux or RxDart? </font><font style="vertical-align: inherit;">- although the stop is about the ‚Äúother‚Äù ... But still, what's next? </font><font style="vertical-align: inherit;">What libraries to connect? </font><font style="vertical-align: inherit;">Bloc, Flutter_bloc, bloc_pattern, etc.? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Such a number of architecture options and tools for their implementation can really delay the selection stage for a long time.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For whom the article</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The article will be primarily useful to those who are just starting to learn Flutter and do not know where to start. </font><font style="vertical-align: inherit;">I will show one of the options for implementing the application on Flutter. </font><font style="vertical-align: inherit;">This will allow you to ‚Äúfeel‚Äù Flutter, and then decide for yourself how and using which you will write your applications.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns and tools. </font><font style="vertical-align: inherit;">Brief and simple</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, let's begin. The first thing worth noting is that there is an application architecture (pattern, template, some construction concept) - this is exactly the same: BLoC, MVP, MVC, MVVM, MVI, etc. Many of these architectures are used not only in Flutter, but also in other programming languages. Question - what to choose from? In my opinion, you need to choose what you yourself know well, but only if this implies reactivity and a strict separation of business logic from the interface (yes, yes - ‚Äúa car can be any color if it is black‚Äù). As for the separation of interface and business logic, I think there is no need to explain, but as for reactivity - try, if you haven‚Äôt tried - in the end it is really very convenient and ‚Äúbeautiful‚Äù. If you can‚Äôt choose it yourself, then let us allow it to be done for us by not the most stupid guys from Google - BLOC. We figured out the architecture.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the tools - there are ready-made libraries - Bloc, Flutter_bloc, bloc_pattern - which is better? I don‚Äôt know - everyone is good. You can choose and compare for a long time, but here again, as in the army - it‚Äôs better to make a wrong decision for now than not to make any. And for now, I propose to go back in the wake of the fashion and use the Provider (what the same guys recommend using in 2019).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this will allow us to make both global bloc and local bloc, as needed. </font><font style="vertical-align: inherit;">A lot has been written about the architecture of BLoC (namely, a pattern, not libraries), I think you should not dwell on it again in detail. </font><font style="vertical-align: inherit;">I note only one point in this article, not classic BLoC will be used, but slightly modified - in BLoC actions (events) will not be transmitted through Sinks, but BLoC functions will be called. </font><font style="vertical-align: inherit;">Simply, at the moment, I do not see the benefits of using Sinks - and since they are not there, then why complicate your life?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrony and Parallel Computing in Dart</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's also worth a little clarification of the concept of asynchrony in Dart, since we're talking about reactivity. Very often, at the first stages of acquaintance with Dart, the meaning of asynchronous functions (async) is not correctly understood. You should always remember that ‚Äúby default‚Äù the program runs in one thread, and asynchrony only allows you to change the sequence of commands, rather than execute them in parallel. That is, if you simply run the function with large calculations just by marking it async, then the interface will be blocked. Async does NOT start a new thread. How async and await work there is a lot of information on the Internet, so I will not dwell on this either.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you need to make some big calculations and at the same time not block the interface, you need to use the compute function (for special hardcore you can use isolates). </font><font style="vertical-align: inherit;">This will really start a separate thread of execution, which will also have its own separate memory area (which is very sad and sad). </font><font style="vertical-align: inherit;">You can communicate with such streams only through messages that can contain simple data types, their lists.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's get down to practice</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulation of the problem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try to write the simplest application - let it be some kind of telephone directory. </font><font style="vertical-align: inherit;">We will use Firebase as storage - this will allow us to make a "cloud" application. </font><font style="vertical-align: inherit;">I‚Äôll skip how to connect Firebase to the project (more than one article has been written on this topic and I don‚Äôt see the point of repeating. Note: Cloud Firestore is used in this project.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be like this:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application description</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our application will externally contain:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firebase authorization window (the logic of this window will be contained in MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Information window - will display information about the user under whom the program is authorized (the logic of this window will also be contained in MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directory window in the form of a list of telephones (the logic of this window will be contained in a separate PhonebookBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application menu that will switch screens.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The internal application will be constructed as follows: each screen will contain a file with screen widgets, a bloc file (with the corresponding bloc class), an actions file (contains simple classes describing events that affect the bloc state), a states file (contains simple classes that reflect bloc status ), the data_model file containing the repository class (responsible for receiving data) and the data class (stores bloc business logic data).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The application will function like this - when the screen is opened, the corresponding bloc is initialized with the initial state value and, if necessary, some initial action is called in the bloc constructor. </font><font style="vertical-align: inherit;">The screen is built / rebuilt based on state, which returns bloc. </font><font style="vertical-align: inherit;">The user performs some actions in the application that have corresponding actions. </font><font style="vertical-align: inherit;">Actions are passed to the bloc class, where they are processed in the mapEventToState function and bloc returns the new state back to the screen, based on which the screen is rebuilt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, we create an empty Flutter project and make the project structure of this kind (I note that in the demo project some files will eventually remain empty):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authorization window. </font><font style="vertical-align: inherit;">Mainbloc</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you need to implement authorization in Firebase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start by creating event classes (it‚Äôs convenient to transfer data through events in bloc) and states for Main bloc: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
file MainBloc \ actions</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
file MainBloc \ states</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The busy flag in the state class is used to display progress_hud in the interface and exclude unnecessary data reads from the database when scrolling through the list. </font><font style="vertical-align: inherit;">Before all operations in the block begin, a new state of the old type with the busy flag set is issued to the output stream - this way the interface receives a notification that the operation has begun. </font><font style="vertical-align: inherit;">At the end of the operation, a new state is sent to the stream with the busy flag cleared. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The heirs of the MainBlocState class describe the state of the main application Bloc. </font><font style="vertical-align: inherit;">The heirs of MainBlocAction describe the events that occur in it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The MainBloc class contains 4 main elements - the function of "converting" events to states (Future mapEventToState), the Bloc state is _blocState, the bloc state repository is the repo, and the "output" state stream (which interface elements track) is blocStream. Basically, these are all elements that provide bloc-a functionality. Sometimes it is advisable to use 2 output streams in one bloc - such an example will be lower. I will not list it here - you can see it by downloading the project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bloc repository class contains the logic for working with Firebase and an object (data) that stores the data necessary for the business logic that this bloc implements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The MainData class also stores state, but the authorization state in Firebase, and not the Bloc state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We wrote the logic for the main bloc, now we can begin to implement the authorization / registration screen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc is initialized in the main file: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main file</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's time to make a small digression about StreamBuilder, Provider, StreamProvider, Consumer and Selector.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retreat about Providers</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - only transfers the stored value down the tree. And you can access it only after the child build, i.e. you need to build a sub widget. Not responsible for updating widgets. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a widget that monitors the stream and is completely rebuilt when it </font><b><font style="vertical-align: inherit;">receives a</font></b><font style="vertical-align: inherit;"> new object from the stream. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a widget that monitors the stream and upon receipt of a new object, signals that the child widgets (those that are declared as a separate class with the build method) should be rebuilt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are ‚Äúsyntactic sugar‚Äù, i.e. this is actually a ‚Äúwrapper‚Äù that contains build and hides the widget underneath. In Selector-e, you can do additional filtering of updates.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, when you need to rebuild most of the screen at each event, you can use the option with Provider and StreamBuilder. </font><font style="vertical-align: inherit;">When it is necessary to rebuild parts of the widget tree close to the leaves, it is advisable to use StreamProvider in combination with Consumer and Selector to exclude unnecessary rebuilds of the tree.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authorization </font><font style="vertical-align: inherit;">Continuation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When entering the application, the user must get to the authorization / registration window, and at that moment the application menu should not be available to him yet. The second point - to partially refresh this screen does not make much sense, so we can use StreamBuilder to build the interface. And the third point in the project is using Navigator to navigate between screens. Upon receipt of an event of successful authorization, it is necessary to call the transition to the information screen. But just inside build StreamBuilder, this will not work - there will be an error. To get around this, you can use the auxiliary wrapper class StreamBuilderWithListener (Eugene Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the listing of this screen is auth_screen itself (I will give here in part): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, a StreamBuilderWithListener is created to listen to the stream from bloc. </font><font style="vertical-align: inherit;">And based on the current state, either the LoggedWidget widget (if the user is already authorized) or SignInAndSignUpWidget (if the user is not authorized yet) is called. </font><font style="vertical-align: inherit;">If bloc returns the IsLogged state, switching to a new screen using the Navigator does not occur in the builder (which would lead to an error), but in the listener. </font><font style="vertical-align: inherit;">In the underlying widgets, the interface is built based on the data returned here. </font><font style="vertical-align: inherit;">Here, the Provider + StreamBuilder bundle is actually used, because </font><font style="vertical-align: inherit;">when the state of the block changes, virtually the entire interface changes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To transfer data to bloc, TextEditingController and action parameters are used: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auth_screen file</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PhoneBookScreen Window</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now let's talk a little about our PhoneBookScreen window. This is the most interesting window - here the interface is built on the basis of 2 streams from bloc, and there is also a list with scroll and pagination (pagination). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen File</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first StreamProvider is needed to switch between different screens of the directory - list, contact card, contact card for editing, etc. The widget for the screen is selected in the caseWidget function (but in this example only the view for the list is implemented - you can try to implement the view for the contact card - this is very simple and will not be a bad start.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On this screen, a bunch of StreamProvider + Selector / Consumer is already used, because there is a scroll of the list and it is not advisable to rebuild the entire screen with it (i.e. rebuilding widgets comes from the corresponding Selector / Consumer and lower in the tree). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here is the implementation of the list itself: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen file</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we see the second StreamProvider, which monitors the second stream of bloc, which is responsible for the scroll. Pagination is organized as standard via _scrollListener (controller: _scrollController). Although the window is interesting, but given the detailed description of the first window, there is nothing more to say here. Therefore, that‚Äôs all today.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The objective of this article was not to show the perfect code, that is, here you can find many points for optimization - correctly ‚Äúsplit‚Äù into files, use instance, mixins and the like somewhere. </font><font style="vertical-align: inherit;">Also, what "begs" the next step - you can make a contact card. </font><font style="vertical-align: inherit;">The main task was to structure knowledge, set a certain vector for constructing the application, give explanations on some of the moments of designing an application on Flutter that were not very obvious at the first stages of acquaintance. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project can be downloaded at</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (for registration you can use any mail with a password of at least 6 characters. When re-authorizing, the password must be the same as that used during registration).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489496/index.html">Search for employees and job search: my view from inside and outside</a></li>
<li><a href="../en489500/index.html">Assessing Tasks at Story Points</a></li>
<li><a href="../en489502/index.html">Selenium + AutoIT. Windows Test Automation Windows</a></li>
<li><a href="../en489504/index.html">How to start creating a map in UE4</a></li>
<li><a href="../en489510/index.html">Trying to solve the problem of choosing tickets before vacation # 2</a></li>
<li><a href="../en489514/index.html">Download and store files of any size on Google Drive for free. Bug or feature?</a></li>
<li><a href="../en489516/index.html">Friends React Native and Fastlane</a></li>
<li><a href="../en489518/index.html">Members Exchange Low-Cost Exchange Appears In US</a></li>
<li><a href="../en489526/index.html">Zero-sum games and Karush-Kun-Takker conditions</a></li>
<li><a href="../en489528/index.html">You do not watch ads during development? Disorder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>