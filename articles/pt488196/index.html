<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 🧔🏾 🏂🏻 Inserções do Android: lidando com medos e se preparando para o Android Q 📦 👴🏽 🔯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Android Q é a décima versão do Android com API nível 29. Uma das principais idéias da nova versão é o conceito de ponta a ponta, quando os aplicativ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Inserções do Android: lidando com medos e se preparando para o Android Q</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488196/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Android Q é a décima versão do Android com API nível 29. </font><font style="vertical-align: inherit;">Uma das principais idéias da nova versão é o conceito de ponta a ponta, quando os aplicativos ocupam a tela inteira, de baixo para cima. </font><font style="vertical-align: inherit;">Isso significa que a barra de status e a barra de navegação devem ser transparentes. </font><font style="vertical-align: inherit;">Mas, se forem transparentes, não haverá interface do usuário do sistema - ela se sobrepõe aos componentes interativos do aplicativo. </font><font style="vertical-align: inherit;">Este problema é resolvido com inserções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os desenvolvedores de dispositivos móveis evitam inserções, pois causam medo neles. </font><font style="vertical-align: inherit;">Mas no Android Q, não será possível contornar as inserções - você precisará estudá-las e aplicá-las. </font><font style="vertical-align: inherit;">De fato, não há nada complicado nas inserções: elas mostram quais elementos da tela se cruzam com a interface do sistema e sugerem como mover o elemento para que não entre em conflito com a interface do usuário do sistema. </font><strong><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></strong><font style="vertical-align: inherit;"> falará sobre como as inserções funcionam e como são úteis</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Djql74drwk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrakok</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) trabalha em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redmadrobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Está envolvido no Android há 10 anos e acumulou muita experiência em vários projetos nos quais não havia lugar para inserções, eles sempre conseguiam se locomover de alguma forma. </font><font style="vertical-align: inherit;">Konstantin vai contar sobre uma longa história de evitar o problema das inserções, sobre estudar e combater o Android. </font><font style="vertical-align: inherit;">Ele considerará tarefas típicas de sua experiência nas quais as inserções poderiam ser aplicadas e mostrará como parar de ter medo do teclado, reconhecer seu tamanho e responder à aparência. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. </font><font style="vertical-align: inherit;">O artigo foi escrito com base em um relatório de Konstantin no </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saint AppsConf 2019</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O relatório usou materiais de vários artigos sobre inserções. </font><font style="vertical-align: inherit;">Link para esses materiais no final.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarefas típicas</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de status de cores. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em muitos projetos, o designer desenha uma barra de status colorida. </font><font style="vertical-align: inherit;">Tornou-se moda quando o Android 5 veio junto com o novo Material Design. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/ii/76/9lii76jdfrbb5i0vq8-ecv2ikby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como pintar a barra de status? </font><font style="vertical-align: inherit;">Elementar - adicione </font></font><code>colorPrimaryDark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a cor é substituída.</font></font><br>
<br>
<pre><code class="kotlin hljs"> &lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"colorPrimaryDark"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para Android acima da quinta versão (API de 21 e superior), você pode definir parâmetros especiais no tópico:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:statusBarColor"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de status multicolorida</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Às vezes, designers em telas diferentes desenham a barra de status em cores diferentes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/ev/nl/uoevnldknz2rtfq5lcqpn1mpj4g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo bem, a maneira mais fácil de trabalhar é com </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferentes tópicos em diferentes atividades</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira mais interessante é mudar as cores </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diretamente no tempo de execução</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span>: View {<font></font>
    requireActivity().window.statusBarColor = requireContext().getColor(R.color.colorPrimary)<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O parâmetro é alterado através de um sinalizador especial. </font><font style="vertical-align: inherit;">Mas o principal é não esquecer de mudar a cor novamente quando o usuário sair da tela novamente. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de status transparente. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso é mais difícil. </font><font style="vertical-align: inherit;">Na maioria das vezes, a transparência está associada aos mapas, porque é nos mapas que a transparência é melhor visualizada. </font><font style="vertical-align: inherit;">Nesse caso, como antes, definimos um parâmetro especial:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;    <font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, é claro, existe um truque bem conhecido - recuar mais alto, caso contrário, a Barra de Status será sobreposta ao ícone e será feia.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/49/8f/c8/498fc8wuip6i-o4eutfnviumuio.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas em outras telas tudo quebra. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/-0/0q/if-00qq6b7zidoz-_nfyehlev7s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resolver o problema? O primeiro método que vem à mente são atividades diferentes: temos tópicos diferentes, parâmetros diferentes, eles funcionam de maneira diferente. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhe com o teclado.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitamos inserções não apenas com a barra de status, mas também ao trabalhar com o teclado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/jk/mz/s-jkmzxzi-5xqr1ei0ku6pfubpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ninguém gosta da opção à esquerda, mas para transformá-la em uma opção à direita, existe uma solução simples.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;activity<font></font>
    ...<font></font>
    android:windowSoftInputMode=<span class="hljs-string">"adjustResize"</span>&gt;<font></font>
    ...<font></font>
&lt;/activity&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A atividade agora pode ser redimensionada quando o teclado aparecer. Funciona de forma simples e severa. Mas não se esqueça de outro truque - envolva tudo </font></font><code>ScrollView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De repente, o teclado ocupará a tela inteira e haverá uma pequena faixa no topo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há momentos mais difíceis quando queremos alterar o layout quando o teclado aparece. Por exemplo, organize os botões ou oculte o logotipo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q3/ia/zl/q3iazltlnajt-cpvdzc0u2i8zcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Treinamos tantas muletas com um teclado e uma barra de status transparente, agora é difícil nos impedir. Vá para StackOverflow e copie o código bonito.</font></font><br>
<br>
<pre><code class="kotlin hljs">boolean isOpened = <span class="hljs-literal">false</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> void setListenerToRootView() {
    <span class="hljs-keyword">final</span> View activityRootView = getWindow().getDecorView().findViewById(android.R.id.content);<font></font>
    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {<font></font>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> void onGlobalLayout() {<font></font>
    <font></font>
            int heightDiff = activityRootView.getRootView().getHeight() - activityRootView.getHeight();      <font></font>
            <span class="hljs-keyword">if</span> (heightDiff &gt; <span class="hljs-number">100</span>) { <span class="hljs-comment">// 99% of the time the height diff will be due to a keyboard.       </span>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"Gotcha!!! softKeyboardup"</span>, <span class="hljs-number">0</span>).show();<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">false</span>) {
                   <span class="hljs-comment">//Do two things, make the view top visible and the editText smaller</span><font></font>
                }<font></font>
                isOpened = <span class="hljs-literal">true</span>;<font></font>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">true</span>) {<font></font>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"softkeyborad Down!!!"</span>, <span class="hljs-number">0</span>).show();<font></font>
                isOpened = <span class="hljs-literal">false</span>;<font></font>
            }    <font></font>
        }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele até calculou a probabilidade de um teclado aparecer. </font><font style="vertical-align: inherit;">O código funciona, em um dos projetos que até o usamos, mas por um longo tempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas muletas nos exemplos estão associadas ao uso de diferentes atividades. </font><font style="vertical-align: inherit;">Mas são ruins não apenas porque são muletas, mas também por outras razões: o problema do “arranque a frio”, assincronia. </font><font style="vertical-align: inherit;">Descrevi os problemas com mais detalhes no artigo " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Licença para dirigir um carro, ou por que os aplicativos devem ser de atividade única</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Além disso, a documentação do Google indica que a abordagem recomendada é um aplicativo de atividade única.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que fizemos antes do Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós (da Redmadrobot) estamos desenvolvendo aplicativos de alta qualidade, mas há muito que evitamos inserções. Como conseguimos evitá-los sem muletas grandes e em uma atividade? </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. Capturas de tela e código retirados do meu projeto de estimação, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Imagine a tela do aplicativo. Quando desenvolvemos nossos aplicativos, nunca pensamos que poderia haver uma barra de navegação transparente abaixo. Existe uma barra preta abaixo? Então, o que os usuários estão acostumados? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/ab/6v/ceab6v6m5dqnbl9zpotdi1vqmre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No topo, inicialmente definimos o parâmetro de que a barra de status é preta com transparência. Como fica em termos de layout e código?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/tu/of/0gtuoffisoeudtgxlnmqd-jicnk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na figura, abstração: o bloco vermelho é a atividade do aplicativo, o azul é um fragmento com um bot de navegação (com guias) e dentro dele são trocados fragmentos verdes com conteúdo. Pode ser visto que a barra de ferramentas não está na barra de status. Como conseguimos isso? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Android tem uma bandeira complicada </font></font><code>fitSystemWindow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se você configurá-lo como verdadeiro, o contêiner adicionará preenchimento a si mesmo, para que nada dentro dele caia na barra de status. Acredito que esta bandeira é a muleta oficial do Google para quem tem medo de inserir. Usar tudo funcionará relativamente bem sem inserções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sinalizador </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adiciona preenchimento ao contêiner que você especificou. Mas a hierarquia é importante: se um dos pais definir esse sinalizador como "verdadeiro", sua distribuição não será levada em consideração, porque o contêiner já aplicou o recuo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A bandeira funciona, mas outro problema aparece. </font><font style="vertical-align: inherit;">Imagine uma tela com duas guias. </font><font style="vertical-align: inherit;">Ao alternar, uma transação é iniciada, o que causa um </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragmento um no outro e tudo quebra. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/02/_u/lv02_ui9sepxlvi7djz_xpem2sy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo fragmento também possui um sinalizador definido </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e isso não deve acontecer. </font><font style="vertical-align: inherit;">Mas o que aconteceu, por que? </font><font style="vertical-align: inherit;">A resposta é que isso é uma muleta e, às vezes, não funciona. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas encontramos uma solução no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : use root para não fragmentos </font></font><code>FrameLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Foi criado para outros fins, mas funciona aqui.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que isso funciona?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver na fonte o que está acontecendo </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> void onAttachedToWindow() {   
    <span class="hljs-keyword">super</span>.onAttachedToWindow();<font></font>
    ...    <font></font>
    <span class="hljs-keyword">if</span> (mLastInsets == <span class="hljs-literal">null</span> &amp;&amp; ViewCompat.getFitsSystemWindows(<span class="hljs-keyword">this</span>)) {         
        <span class="hljs-comment">// We're set to fitSystemWindows but we haven't had any insets yet...</span>
        <span class="hljs-comment">// We should request a new dispatch of window insets</span>
        ViewCompat.requestApplyInsets(<span class="hljs-keyword">this</span>);<font></font>
    }     <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos um belo comentário de que inserções são necessárias aqui, mas não são. </font><font style="vertical-align: inherit;">Precisamos pedir novamente quando solicitamos uma janela. </font><font style="vertical-align: inherit;">Descobrimos que as inserções funcionam de alguma forma por dentro, mas não queremos trabalhar com elas e sair </font></font><code>Coordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na primavera de 2019, desenvolvemos o aplicativo, momento em que o Google I / O acabou de passar. </font><font style="vertical-align: inherit;">Ainda não descobrimos tudo, então continuamos com o preconceito. </font><font style="vertical-align: inherit;">Mas percebemos que alternar as guias na parte inferior é de alguma forma lenta, porque temos um layout complexo, carregado com a interface do usuário. </font><font style="vertical-align: inherit;">Encontramos uma maneira simples de resolver isso - mude </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>show/hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que cada vez que você não recrie o layout.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/7l/vz/hx7lvzsl8-kfv3qqac2pbvllt8q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mudamos e, novamente, nada funciona - tudo quebrou! </font><font style="vertical-align: inherit;">Aparentemente, não é possível espalhar muletas, é preciso entender por que elas funcionaram. </font><font style="vertical-align: inherit;">Estudamos o código e verifica-se que qualquer ViewGroup também pode trabalhar com inserções.</font></font><br>
<br>
<pre><code class="kotlin hljs">
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {    <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {         
        <span class="hljs-keyword">final</span> int count = getChildCount();        
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);             <font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {          
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe uma lógica interna: se pelo menos alguém já processou inserções, todas as Views subseqüentes dentro do ViewGroup não as receberão. </font><font style="vertical-align: inherit;">O que isso significa para nós? </font><font style="vertical-align: inherit;">Deixe-me mostrar um exemplo do nosso FrameLayout, que alterna as guias. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/fo/nn/h1fonnc4qrqpmj_x-fc8m47ptci.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro, há o primeiro fragmento que tem o sinalizador definido </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso significa que o primeiro fragmento processa inserções. </font><font style="vertical-align: inherit;">Depois disso, chamamos o </font></font><code>HIDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro fragmento e o </font></font><code>SHOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo. </font><font style="vertical-align: inherit;">Mas o primeiro permanece no layout - sua visualização é deixada, apenas oculta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O contêiner passa por sua Visualização: pega o primeiro fragmento, fornece inserções e a partir dele </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ele os pegou e processou. </font><font style="vertical-align: inherit;">Perfeitamente, o FrameLayout parecia que as inserções foram processadas e não a deram para o segundo fragmento. </font><font style="vertical-align: inherit;">Tudo funciona como deveria. </font><font style="vertical-align: inherit;">Mas isso não nos convém, o que devemos fazer?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós escrevemos nosso próprio ViewGroup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós viemos de Java, e lá OOP em toda a sua glória, então decidimos herdar. </font><font style="vertical-align: inherit;">Nós escrevemos nosso próprio ViewGroup, a partir do qual redefinimos o método </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Funciona da maneira que precisamos: sempre devolve às crianças as inserções que vieram, independentemente de processá-las ou não.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInsetFrameLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,      <font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,     <font></font>
    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><font></font>
) : FrameLayout(context, attrs, defStyleRes) {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchApplyWindowInsets</span><span class="hljs-params">(insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets { 
        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> until childCount)) {<font></font>
            getChildAt(child).dispatchApplyWindowInsets(insets)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> insets.consumeSystemWindowInsets()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ViewGroup personalizado funciona, o projeto também é tudo o que precisamos. </font><font style="vertical-align: inherit;">Mas ele ainda não chega a uma solução geral. </font><font style="vertical-align: inherit;">Quando descobrimos o que eles nos disseram no Google IO, percebemos que não poderíamos mais agir assim.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Android 10 nos mostrou dois conceitos importantes da interface do usuário que são estritamente recomendados: borda a borda e navegação gestual. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borda a borda.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esse </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conceito</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sugere que o conteúdo do aplicativo deve ocupar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo o espaço possível</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na tela. Para nós, como desenvolvedores, isso significa que os aplicativos devem ser colocados </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos painéis do sistema Barra de status e Barra de navegação.</font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/cr/gl/nh/crglnh9iw__fu4lct0gavaibqey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Anteriormente, poderíamos ignorar isso ou ser colocados apenas sob a barra de status. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto às listas, elas devem rolar não apenas para o último elemento, mas também </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para não permanecer embaixo da Barra de Navegação.</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/pl/it/tlplit1o65rn55edkixuuojxtha.png" width="350"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navegação Gestual. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este segundo conceito importante é a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navegação por gestos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Permite controlar o aplicativo com os dedos a partir da borda da tela. </font><font style="vertical-align: inherit;">O modo de gesto não é padrão, tudo parece diferente, mas agora você não pode alternar entre duas barras de navegação diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse momento, percebemos que nem tudo é tão simples. </font><font style="vertical-align: inherit;">Não será possível evitar ainda mais as inserções se quisermos desenvolver aplicativos de qualidade. </font><font style="vertical-align: inherit;">É hora de estudar a documentação e entender o que são inserções.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insets </font><font style="vertical-align: inherit;">O que você precisa saber sobre eles?</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insets foram criados para assustar os desenvolvedores.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eles estão fazendo isso perfeitamente desde o momento em que apareceu no Android 5. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, nem tudo é tão assustador. O conceito de inserções é simples - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eles relatam uma sobreposição da interface do usuário do sistema na tela do aplicativo.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pode ser uma barra de navegação, barra de status ou um teclado. O teclado também é uma interface do usuário regular do sistema, sobreposta à parte superior do aplicativo. Não é necessário tentar processá-lo com muletas, apenas inserções. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objetivo das inserções é resolver conflitos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por exemplo, se houver outro elemento acima do nosso botão, podemos movê-lo para que o usuário possa continuar usando o aplicativo. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para manipular a inserção,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use </font></font><code>Windowlnsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o Android 10 e </font></font><code>WindowInsetsCompat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para outras versões. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem </font><strong><font style="vertical-align: inherit;">5 tipos diferentes de inserções</font></strong><font style="vertical-align: inherit;"> no Android 10</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um "bônus", que é chamado não inserido, mas de outra forma. </font><font style="vertical-align: inherit;">Lidamos com todos os tipos, porque a maioria sabe apenas uma coisa - Inserções na janela do sistema.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserções da janela do sistema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduzido no Android 5.0 (API 21). </font><font style="vertical-align: inherit;">Obteve-se pelo método </font></font><code>getSystemWindowInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse é o principal tipo de inserção com o qual você precisa aprender a trabalhar, porque o restante funciona da mesma maneira. </font><font style="vertical-align: inherit;">Eles são necessários para processar a barra de status, primeiro e depois a barra de navegação e o teclado. </font><font style="vertical-align: inherit;">Por exemplo, eles resolvem um problema quando a barra de navegação está acima do aplicativo. </font><font style="vertical-align: inherit;">Como na imagem: o botão permaneceu sob a barra de navegação, o usuário não pode clicar nele e está muito infeliz.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/yj/tt/nxyjttdppbkrnrnqkspovzp4hko.png" width="350"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserções de elementos ajustáveis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apareceu apenas no Android 10. Obtido pelo método </font></font><code>getTappableElementInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas inserções são úteis </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas para lidar com vários modos da barra de navegação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como o próprio </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Bane</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diz </font><font style="vertical-align: inherit;">, você pode esquecer esse tipo de inserção e contornar apenas as inserções da janela do sistema. Mas se você deseja que o aplicativo seja 100% legal, não 99,9% legal, você deve usá-lo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olha a foto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/yd/fk/rlydfkwy39pfrc7jfhizhqdkg0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No topo, a cor vermelha indica Inserções da janela do sistema, que serão exibidas em diferentes modos da barra de navegação. Pode-se observar que, à direita e à esquerda, são iguais à barra de navegação.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de como a navegação por gestos funciona: no modo certo, nunca clicamos em um novo painel, mas sempre arrastamos os dedos de baixo para cima. </font><font style="vertical-align: inherit;">Isso significa que os botões não podem ser removidos. </font><font style="vertical-align: inherit;">Podemos continuar pressionando o botão FAB (botão de ação flutuante), ninguém irá interferir. </font><font style="vertical-align: inherit;">Portanto, ele </font></font><code>TappableElementInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ficará vazio porque o FAB não é necessário para se mover. </font><font style="vertical-align: inherit;">Mas se subirmos um pouco mais, tudo bem. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferença aparece apenas na navegação por gestos e na barra de navegação transparente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (adaptação de cores). </font><font style="vertical-align: inherit;">Esta não é uma situação muito agradável. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/ei/qz/zveiqz33n9dc290ib9yhrrjl09u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo vai funcionar, mas parece desagradável. </font><font style="vertical-align: inherit;">O usuário pode ficar confuso com a proximidade dos elementos. </font><font style="vertical-align: inherit;">Pode-se explicar que um é para gestos e o outro é para pressionar, mas ainda não é bonito. </font><font style="vertical-align: inherit;">Portanto, levante o FAB mais alto ou deixe-o à direita.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserções de gesto do sistema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apareceu apenas no Android 10. Obtido pelo método </font></font><code>getSystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas inserções estão relacionadas à navegação por gestos. Inicialmente, assumiu-se que a interface do usuário do sistema é desenhada no topo do aplicativo, mas as Inserções de gestos do sistema dizem que não é a interface do usuário que é desenhada, mas o próprio sistema lida com os gestos. Eles descrevem onde o sistema manipulará os gestos por padrão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As áreas dessas inserções são aproximadamente as marcadas em amarelo no diagrama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/8d/jl/vv8djlgxe4cnjchozbllrysagd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas quero avisar você - eles nem sempre serão assim. Nunca saberemos quais novas telas a Samsung e outros fabricantes criarão. Já existem dispositivos nos quais a tela está em todos os lados. Talvez as inserções não estejam onde esperamos. Portanto, você precisa trabalhar com eles como em alguma abstração: existem inserções no System Gesture Insets nas quais o próprio sistema processa gestos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas inserções podem ser substituídas. </font><font style="vertical-align: inherit;">Por exemplo, você está desenvolvendo um editor de fotos. </font><font style="vertical-align: inherit;">Em alguns lugares, você mesmo deseja lidar com gestos, mesmo que eles estejam próximos à borda da tela. </font><font style="vertical-align: inherit;">Indique ao sistema que você processará o ponto na tela no canto da foto. </font><font style="vertical-align: inherit;">Isso pode ser redefinido dizendo ao sistema: "Eu sempre processarei o quadrado em torno do ponto."</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserções obrigatórias de gestos no sistema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apareceu apenas no Android 10. Este é um subtipo de Inserções de gestos do sistema, mas elas não podem ser substituídas pelo aplicativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usamos o método </font></font><code>getMandatorySystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar a área em que eles não funcionarão. </font><font style="vertical-align: inherit;">Isso foi feito intencionalmente, para que fosse impossível desenvolver um aplicativo “sem esperança”: redefina o gesto de navegação de baixo para cima, o que permite sair do aplicativo na tela principal. </font><font style="vertical-align: inherit;">Aqui, o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema sempre processa os próprios gestos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/89/gl/df/89gldfknoq8z9dje_naytwp0pti.png" width="450"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não necessariamente estará na parte inferior do dispositivo e não necessariamente desse tamanho. </font><font style="vertical-align: inherit;">Trabalhe com isso como uma abstração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses eram tipos relativamente novos de inserções. </font><font style="vertical-align: inherit;">Mas existem aqueles que apareceram antes do Android 5 e foram chamados de forma diferente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inserções estáveis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduzido com o Android 5.0 (API 21). Obteve-se pelo método </font></font><code>getStableInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesmo desenvolvedores experientes nem sempre podem dizer por que são necessários. Vou lhe contar um segredo: essas inserções são úteis apenas para aplicativos em tela cheia: reprodutores de vídeo, jogos. Por exemplo, no modo de reprodução, qualquer interface do usuário do sistema está oculta, incluindo a Barra de Status, que se move para além da borda da tela. Mas vale a pena tocar na tela quando a barra de status aparecer na parte superior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você colocar qualquer botão VOLTAR na parte superior da tela e ele processar as Inserções da janela do sistema corretamente, a cada guia uma UI aparecerá na tela de cima e o botão pulará. Se você não tocar na tela por um tempo, a barra de status desaparecerá, o botão saltará porque os botões da janela do sistema desapareceram.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esses casos, os insertos estáveis ​​estão certos. </font><font style="vertical-align: inherit;">Eles dizem que agora nenhum elemento é desenhado no seu aplicativo, mas pode fazê-lo. </font><font style="vertical-align: inherit;">Com essas inserções, você pode conhecer antecipadamente o valor da barra de status nesse modo, por exemplo, e posicionar o botão onde desejar. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. </font><font style="vertical-align: inherit;">O método </font></font></em><code><em>getStableInsets()</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apareceu apenas com a API 21. Anteriormente, havia vários métodos para cada lado da tela.&nbsp;</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinamos 5 tipos de inserções, mas há mais uma que não se aplica diretamente às inserções. </font><font style="vertical-align: inherit;">Ajuda a lidar com franja e recortes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Franjas e decotes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As telas não são mais quadradas. </font><font style="vertical-align: inherit;">Eles são oblongos, com um ou mais recortes para a câmera e franja por todos os lados. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/kv/sc/lskvscp_j-hy2gesyynicb346cq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Até 28 APIs, não conseguimos processá-las. </font><font style="vertical-align: inherit;">Eu tive que adivinhar através do interior o que estava acontecendo lá. </font><font style="vertical-align: inherit;">Mas com a API 28 e além (do Android anterior), a classe apareceu oficialmente </font></font><code>DisplayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Está nas mesmas inserções das quais você pode obter todos os outros tipos. </font><font style="vertical-align: inherit;">A classe permite que você descubra a localização e o tamanho dos artefatos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além das informações de localização, um conjunto de sinalizadores y é fornecido para o desenvolvedor </font></font><code>WindowManager.LayoutParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles permitem incluir comportamentos diferentes em torno dos recortes. </font><font style="vertical-align: inherit;">Seu conteúdo pode ser exibido ao redor deles ou não: nos modos paisagem e retrato de maneiras diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bandeiras</font></font><code>window.attributes.layoutInDisplayCutoutMode =</code><br>
<br>
<ul>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No retrato - existe e na paisagem - uma barra preta por padrão.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nem um pouco - uma faixa preta.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sempre é.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tela pode ser controlada, mas trabalhamos com eles da mesma maneira que com outros Insets.</font></font><br>
<br>
<pre><code class="kotlin hljs">insets.displayCutout<font></font>
    .boundingRects<font></font>
    .forEach { rect -&gt; ... }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A chamada de retorno com inserções com uma matriz chega até nós </font></font><code>displayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Então podemos executá-lo, processar todos os recortes e franjas que estão no aplicativo. </font><font style="vertical-align: inherit;">Você pode aprender mais sobre como trabalhar com eles </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entendido com 6 tipos de inserções. </font><font style="vertical-align: inherit;">Agora vamos falar sobre como isso funciona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como funciona</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As inserções são necessárias, antes de tudo, quando algo é desenhado no topo do aplicativo, por exemplo, a Barra de Navegação. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ft/ct/_w/ftct_wh_dc64t9rw6ir_7zpqg8m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sem inserções, o aplicativo não terá uma barra de navegação e uma barra de status transparentes. </font><font style="vertical-align: inherit;">Não se surpreenda que você não vem </font></font><code>SystemWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isso acontece.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spread insets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda a hierarquia da interface do usuário se parece com uma árvore com uma visualização nas extremidades. </font><font style="vertical-align: inherit;">Os nós geralmente são um grupo de exibição. </font><font style="vertical-align: inherit;">Eles também herdam do View, de modo que os insets chegam a eles de uma maneira especial </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A partir da visualização raiz, o sistema envia inserções por toda a árvore. </font><font style="vertical-align: inherit;">Vamos ver como o View funciona neste caso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/rw/hk/jyrwhkavrimytpqs4je0ltfn7-w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sistema chama o método </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pelo qual as inserções entram. </font><font style="vertical-align: inherit;">Voltar a este modo de exibição deve retornar algo </font><font style="vertical-align: inherit;">O que fazer para lidar com esse comportamento? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar, consideramos apenas o WindowInsets.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manipulação de inserções</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de tudo, a redefinição do método </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implementação dentro de sua própria lógica </font><font style="vertical-align: inherit;">parece lógica </font><font style="vertical-align: inherit;">: inserções vieram, implementamos tudo dentro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você abrir a classe View e observar o Javadoc escrito sobre esse método, poderá ver: “Não substitua esse método!”</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lidamos com Insets por meio de delegação ou herança.</font></font></blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use delegação</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O Google ofereceu a oportunidade de expor seu próprio delegado, responsável por lidar com inserções. </font><font style="vertical-align: inherit;">Você pode instalá-lo através do método </font></font><code>setOnApplyWindowInsetsListener(listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Definimos um retorno de chamada que lida com essas inserções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se, por algum motivo, isso não nos convém, você pode </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herdar do View e substituir outro método</font></font></strong> <code>onApplyWindowInsets(WindowInsets insets)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nós substituímos nossas próprias inserções nele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Google não escolheu entre delegação e herança, mas permitiu fazer tudo juntos. </font><font style="vertical-align: inherit;">Isso é ótimo porque não precisamos redefinir toda a barra de ferramentas ou o ListView para lidar com inserções. </font><font style="vertical-align: inherit;">Podemos pegar qualquer Visualização pronta, mesmo uma biblioteca, e definir o delegado lá, que manipulará inserções sem redefinição. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que devemos retornar?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que devolver alguma coisa?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, você precisa entender como a distribuição de inserções, ou seja, ViewGroup, funciona. </font><font style="vertical-align: inherit;">O que ela está fazendo dentro de si mesma. </font><font style="vertical-align: inherit;">Vamos dar uma olhada no comportamento padrão usando o exemplo que mostrei anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As inserções do sistema vieram na parte superior e inferior, por exemplo, 100 pixels cada. </font><font style="vertical-align: inherit;">O ViewGroup os envia para a primeira visualização que possui. </font><font style="vertical-align: inherit;">Este modo de exibição os manipulou de algum modo e retorna inserções: no topo ele diminui para 0, mas no fundo ele sai. </font><font style="vertical-align: inherit;">No topo, ela acrescentou preenchimento ou margem, mas no fundo ela não tocou e relatou isso. </font><font style="vertical-align: inherit;">Em seguida, o ViewGroup passa inserções para a segunda View. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/-a/rw/tj-arwxjkus-n6xnvl099lqbqqg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A próxima exibição processa e renderiza inserções. </font><font style="vertical-align: inherit;">Agora o ViewGroup vê que as inserções são processadas acima e abaixo - não resta mais nada, todos os parâmetros são zero. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A terceira visão nem sabe que havia algumas inserções e algo estava acontecendo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O ViewGroup retornará inserções de volta para quem as expôs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando começamos a lidar com esse tópico, escrevemos a idéia para nós mesmos - sempre retornamos os mesmos detalhes que vieram. </font><font style="vertical-align: inherit;">Queríamos evitar essa situação quando algum View nem reconhecia que havia inserções. </font><font style="vertical-align: inherit;">A ideia parecia lógica. </font><font style="vertical-align: inherit;">Mas acabou que não. </font><font style="vertical-align: inherit;">O Google não adicionou em vão nenhum comportamento às inserções, como no exemplo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é necessário para que as inserções sempre atinjam toda a hierarquia da Visualização e você sempre possa trabalhar com elas. </font><font style="vertical-align: inherit;">Nesse caso, não haverá situação quando trocarmos dois fragmentos, um foi processado e o segundo ainda não recebido. </font><font style="vertical-align: inherit;">Na seção prática, retornaremos a esse ponto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prática</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teoria é feita. </font><font style="vertical-align: inherit;">Vamos ver como fica o código, porque, em teoria, tudo é sempre tranquilo. </font><font style="vertical-align: inherit;">Vamos usar o AndroidX. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota. </font><font style="vertical-align: inherit;">No </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox,</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tudo já está implementado no código, suporte completo para todos os presentes do novo Android. </font><font style="vertical-align: inherit;">Para não verificar as versões do Android e não procurar o tipo de Insets necessário, sempre use a </font></font></em><code><em>view.setOnApplyWindowInsetsListener { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versão do AndroidX </font></font></em><code><em>ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma tela com uma barra de navegação escura. </font><font style="vertical-align: inherit;">Não sobrepõe nenhum elemento na parte superior. </font><font style="vertical-align: inherit;">Tudo é do jeito que estamos acostumados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3r/wq/sp/3rwqspgcdlgie2m00lmedkwzgi8.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas acontece que agora precisamos torná-lo transparente. </font><font style="vertical-align: inherit;">Quão?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ativar transparência</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mais simples é indicar no assunto que a barra de status e a barra de navegação são transparentes.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentNavigation"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse momento, tudo começa a se sobrepor, tanto de cima como de baixo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curiosamente, existem dois sinalizadores e sempre há três opções: se você especificar transparência para a barra de navegação, a barra de status ficará transparente por si só - uma limitação. </font><font style="vertical-align: inherit;">Você não pode escrever a primeira linha, mas eu sempre adoro a clareza, por isso escrevo duas linhas para que os seguidores possam entender o que está acontecendo e não cavar por dentro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você escolher esse método, a barra de navegação e a barra de status ficarão pretas com transparência. </font><font style="vertical-align: inherit;">Se o aplicativo for branco, você poderá adicionar cores apenas a partir do código. </font><font style="vertical-align: inherit;">Como fazer isso?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ative a transparência com cores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É bom termos um aplicativo de atividade única, por isso colocamos dois sinalizadores em uma atividade.</font></font><br>
<br>
<pre><code class="kotlin hljs">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or  <font></font>
    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<font></font>
<font></font>
&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;!-- Set the navigation bar to <span class="hljs-number">50</span>% translucent white --&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:navigationBarColor"</span>&gt;#<span class="hljs-number">80F</span>FFFFF&lt;/item&gt; <font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem muitos sinalizadores lá, mas são esses dois que ajudarão a tornar a transparência na barra de navegação e na barra de status. </font><font style="vertical-align: inherit;">A cor pode ser especificada através do tema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse é o comportamento estranho do Android: algo através do tema e algo através das bandeiras. </font><font style="vertical-align: inherit;">Mas podemos especificar parâmetros no código e no assunto. </font><font style="vertical-align: inherit;">Esse Android não é tão ruim assim, apenas nas versões mais antigas do Android o sinalizador especificado no tópico será ignorado. </font></font><code>navigationBarColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele destacará que no Android 5 isso não é verdade, mas tudo vai se unir. </font><font style="vertical-align: inherit;">No GitFox, foi a partir do código que defini a cor da barra de navegação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fizemos fraudes - indicamos que a barra de navegação é branca com transparência. </font><font style="vertical-align: inherit;">Agora, o aplicativo fica assim.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/vs/mz/eovsmz1tczlc9vl_kg2yihxs0u0.png" width="350"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que poderia ser mais fácil do que lidar com inserções?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, elementar.</font></font><br>
<br>
<pre><code class="kotlin hljs">ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;  <font></font>
        view.updatePadding(bottom = insets.systemWindowInsetBottom) <font></font>
        insets<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pegamos o método </font></font><code>setOnApplyWindowInsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o passamos para ele </font></font><code>bottomNav</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dizemos que, quando as inserções chegarem, instale o preenchimento inferior que entrou </font></font><code>systemWindowInsetBottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Queremos isso por baixo, mas todos os nossos elementos clicáveis ​​estão no topo. </font><font style="vertical-align: inherit;">Retornamos totalmente inserções para que todas as outras visualizações em nossa hierarquia também as recebam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo parece ótimo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zl/8e/ku/zl8ekuc_pvpc2wrmeop-khxmomg.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas há um porém. </font><font style="vertical-align: inherit;">Se no layout indicamos algum tipo de preenchimento na barra de navegação abaixo, então aqui foi excluído - definir </font></font><code>updatePadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inserções iguais. </font><font style="vertical-align: inherit;">Nosso layout não parece como gostaríamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para salvar os valores do layout, você deve primeiro salvar o que está no preenchimento inferior. </font><font style="vertical-align: inherit;">Mais tarde, quando inserções chegarem, adicione e defina os valores resultantes.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> bottomNavBottomPadding = bottomNav.paddingBottom<font></font>
ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;                 <font></font>
        view.updatePadding(<font></font>
        bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    Insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É inconveniente escrever desta maneira: em todo o código em que você usa inserções, é necessário salvar o valor do layout e adicioná-lo à interface do usuário. </font><font style="vertical-align: inherit;">Mas existe o Kotlin, e isso é maravilhoso - você pode escrever sua própria extensão, o que fará tudo isso por nós.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione Kotlin!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembramos </font></font><code>initialPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e entregamos ao manipulador quando novas inserções vêm (junto com elas). </font><font style="vertical-align: inherit;">Isso os ajudará de alguma forma a se juntar ou a construir algum tipo de lógica de cima.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {    <font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
<font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
    <font></font>
    requestApplyInsetsWhenAttached()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
   Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)<font></font>
<font></font>
  .<font></font>
<font></font>
bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;   <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    ) <font></font>
    insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos que redefinir a lambda. </font><font style="vertical-align: inherit;">Possui não apenas inserções, mas também almofadas. </font><font style="vertical-align: inherit;">Podemos adicioná-los não apenas de baixo, mas também de cima, se for uma barra de ferramentas que processa a barra de status.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo esquecido!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma chamada para um método incompreensível.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
     <font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
      <font></font>
    requestApplyInsetsWhenAttached() <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
      Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso se deve ao fato de que você não pode apenas esperar que o sistema lhe envie inserções. </font><font style="vertical-align: inherit;">Se criarmos uma View a partir do código ou instalarmos um </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouco mais tarde, o próprio sistema poderá não passar o último valor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devemos verificar se, quando a tela está na tela, informamos ao sistema: "Chegaram as inserções, queremos processá-las". </font><font style="vertical-align: inherit;">Definimos o ouvinte e devemos fazer uma solicitação </font></font><code>requestsApplyInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">".</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">requestApplyInsetsWhenAttached</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">if</span> (isAttachedToWindow) {        <font></font>
        requestApplyInsets()<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : View.OnAttachStateChangeListener {            
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {<font></font>
                v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>)<font></font>
                v.requestApplyInsets()           <font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> = <span class="hljs-built_in">Unit</span><font></font>
        })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se criamos um código de exibição e ainda não o anexamos ao nosso layout, devemos assinar o horário em que o fazemos. </font><font style="vertical-align: inherit;">Somente então solicitamos inserções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, novamente, há Kotlin: eles escreveram uma extensão simples e não precisamos mais pensar nisso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refinando o RecyclerView</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos falar sobre a finalização do RecyclerView. O último elemento cai sob a barra de navegação e permanece abaixo - feio. Também é inconveniente clicar nele. Se este não é um painel novo, mas o antigo, um grande, geralmente o elemento inteiro pode desaparecer sob ele. O que fazer? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/qa/f7/jcqaf7okahkrhrrnols54exqhdu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira idéia é adicionar um elemento abaixo e definir a altura para ajustar as inserções. Mas se tivermos um aplicativo com centenas de listas, de alguma forma teremos que assinar cada lista para inserir, adicionar um novo elemento lá e definir a altura. Além disso, o RecyclerView é assíncrono, não se sabe quando funcionará. Existem muitos problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas há outro truque oficial. Surpreendentemente, ele funciona com eficiência.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;androidx.recyclerview.widget.RecyclerView <font></font>
        android:id=<span class="hljs-string">"@+id/recyclerView"</span>        
    android:layout_width=<span class="hljs-string">"match_parent"</span>    
    android:layout_height=<span class="hljs-string">"match_parent"</span>             
    android:clipToPadding=<span class="hljs-string">"false"</span> /&gt;<font></font>
<font></font>
recyclerView.doOnApplyWindowInsets { view, insets, padding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe uma bandeira no layout </font></font><code>clipToPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por padrão, é sempre verdade. Isso sugere que você não precisa desenhar elementos que apareçam onde o preenchimento está exposto. Mas se definido </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, você pode desenhar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, se você definir o preenchimento na parte inferior, no RecyclerView funcionará assim: o preenchimento será definido na parte inferior e o elemento será desenhado em cima dele até rolar. Quando chegar ao fim, o RecyclerView rolará os elementos para a posição que precisamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao definir um desses sinalizadores, podemos trabalhar com o RecyclerView como em um modo de exibição normal. Não pense que existem elementos que rolam - basta definir o preenchimento abaixo, como, por exemplo, na barra de navegação inferior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora sempre retornamos inserções como se não fossem processadas. </font><font style="vertical-align: inherit;">As inserções inteiras chegaram até nós, fizemos algo com elas, ajustamos os forros e devolvemos todas as inserções inteiras novamente. </font><font style="vertical-align: inherit;">Isso é necessário para que qualquer ViewGroup sempre passe essas inserções para todas as View. </font><font style="vertical-align: inherit;">Funciona.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bug do aplicativo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em muitos aplicativos no Google Play que já processaram inserções, notei um pequeno bug. Agora vou falar sobre ele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma tela com navegação no porão. À direita está a mesma tela que mostra a hierarquia. O fragmento verde exibe o conteúdo na tela, dentro dele tem um RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/e6/jo/hle6jod0ws19fydq734lqnuaixu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quem lidou com as inserções aqui? Barra de ferramentas: ele aplicou o preenchimento na parte superior para que seu conteúdo se mova sob a barra de status. Consequentemente, a barra de navegação inferior aplicava inserções de baixo e subia acima da barra de navegação. Mas o RecyclerView não manipula inserções de forma alguma, não se enquadra nelas, não precisa processar inserções - tudo é feito corretamente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r3/xc/qi/r3xcqipovgqu-zbbxruxsy-wqvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas aqui acontece que queremos usar o fragmento verde RecyclerView em outro local onde a barra de navegação inferior não está mais lá. Neste ponto, o RecyclerView já está começando a lidar com inserções a partir de baixo. Precisamos aplicar preenchimento a ele para rolar adequadamente sob a barra de navegação. Portanto, no RecyclerView, também adicionamos processamento de inserções. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ws/m-/vewsm-_o80cw7mbn9tyk0bu_mfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voltamos à nossa tela, onde todos processam inserções. Lembre-se, ninguém relata que ele os processou? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/vd/x8/umvdx8faxxk48r-inx-cxhkjqdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos esta situação: O RecyclerView processou inserções a partir de baixo, embora não atinja a barra de navegação - um espaço apareceu na parte inferior. Notei isso em aplicativos, e bastante grande e popular.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i9/3_/ar/i93_arxauyvbitayfpyonkxnudy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se for esse o caso, lembramos que retornamos todas as inserções para processar. Então (acontece!) É necessário relatar que as inserções são processadas: A Barra de Navegação deve relatar que as inserções foram processadas. Eles não devem acessar o RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jf/r2/vi/jfr2vi8jpsas_ptxjjqh_qhg1vk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, instale a barra de navegação inferior </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Subtraia dentro </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que eles não são processados, retorne 0.</font></font><br>
<br>
<pre><code class="kotlin hljs">doOnApplyWindowInsets { view, insets, initialPadding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    insets.replaceSystemWindowInsets(<font></font>
        Rect(<font></font>
            insets.systemWindowInsetLeft,            <font></font>
            insets.systemWindowInsetTop,            <font></font>
            insets.systemWindowInsetRight,<font></font>
            <span class="hljs-number">0</span><font></font>
        )<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retornamos novas inserções, nas quais todos os parâmetros antigos são iguais, mas </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iguais a 0. Parece que está tudo bem. </font><font style="vertical-align: inherit;">Começamos repetidamente sem sentido - o RecyclerView ainda lida com inserções por algum motivo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lp/yw/ut/lpywut3fvlk5w-nwbd3-wnrceaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não entendi imediatamente que o problema é que o contêiner para esses três modos de exibição é LinearLayout. </font><font style="vertical-align: inherit;">Dentro deles, há uma barra de ferramentas, um trecho com um RecyclerView e na parte inferior da barra de navegação inferior. </font><font style="vertical-align: inherit;">O LinearLayout coloca seus filhos em ordem e aplica inserções neles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece que a barra de navegação inferior será a última. </font><font style="vertical-align: inherit;">Ele disse a alguém que processou todas as inserções, mas era tarde demais. </font><font style="vertical-align: inherit;">Todas as inserções foram processadas de cima para baixo, o RecyclerView já as recebeu e isso não nos salva. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/mm/jd/ujmmjdgumv0bl6e0ewydx7ueq5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que fazer? </font><font style="vertical-align: inherit;">O LinearLayout não funciona da maneira que eu quero, ele os transfere de cima para baixo e preciso obter o primeiro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redefinir tudo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O desenvolvedor Java jogou em mim - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tudo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precisa ser </font><strong><font style="vertical-align: inherit;">redefinido</font></strong><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Bem, agora </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redefina, defina </font></font><code>yLinearLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que sempre passará de baixo para cima. </font><font style="vertical-align: inherit;">Ele primeiro envia inserções da barra de navegação inferior e depois para todos os outros.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {     <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {        
        <span class="hljs-keyword">final</span> int count = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);<font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas parei a tempo, lembrando do comentário de que não havia necessidade de redefinir esse método. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, um pouco maior é a salvação: o ViewGroup verifica se há um delegado que processa as inserções, depois chama o super método no View e ativa seu próprio processamento. </font><font style="vertical-align: inherit;">Nesse código, obtemos inserções e, se ainda não foram processadas, iniciamos a lógica padrão para nossos filhos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escrevi uma extensão simples. </font><font style="vertical-align: inherit;">Permite, aplicando </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a uma Visualização, dizer a quem essas inserções passam.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">addSystemBottomPadding</span><span class="hljs-params">(    
    targetView: <span class="hljs-type">View</span> = this
)</span></span> {<font></font>
    doOnApplyWindowInsets { _, insets, initialPadding -&gt;           <font></font>
        targetView.updatePadding(<font></font>
            bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
        )<font></font>
        insets.replaceSystemWindowInsets(<font></font>
            Rect(<font></font>
                insets.systemWindowInsetLeft,<font></font>
                insets.systemWindowInsetTop,     <font></font>
                insets.systemWindowInsetRight,<font></font>
                <span class="hljs-number">0</span><font></font>
            )<font></font>
        )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por padrão </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">é igual à mesma visualização na qual aplicamos </font></font><code>addSystemBottomPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nós podemos redefinir isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No meu LinearLayout, pendurei um manipulador, passando como </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- esta é minha barra de navegação inferior.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro ele dará inserções na barra de navegação inferior.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso processará inserções, retornará zero ao fundo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, por padrão, eles vão de cima para baixo: Barra de ferramentas, fragmenta com o RecyclerView.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, talvez, ele volte a enviar inserções na barra de navegação inferior. </font><font style="vertical-align: inherit;">Mas isso não é mais importante, tudo funcionará tão bem.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consegui exatamente o que queria: todas as inserções são processadas na ordem em que são necessárias.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/b0/nc/s3b0nc07bayude3nvrvevkxnwyc.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Importante</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algumas coisas importantes a ter em mente. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O teclado é a interface do usuário do sistema na parte superior do seu aplicativo.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Não há necessidade de tratá-la de uma maneira especial. Se você olhar para o teclado do Google, não é apenas um Layout com botões nos quais você pode clicar. Existem centenas de modos para este teclado: pesquisando gifs e memes, entrada de voz, redimensionando de 10 pixels de altura para tamanhos de tela. Não pense no teclado, mas assine inserções. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A gaveta de navegação ainda não suporta a navegação por gestos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No Google IO, eles prometeram que tudo daria certo. </font><font style="vertical-align: inherit;">Mas no Android 10, o Navigation Drawer ainda não suporta isso. </font><font style="vertical-align: inherit;">Se você atualizar para o Android 10 e ativar a navegação com gestos, o Navigation Drawer cairá. </font><font style="vertical-align: inherit;">Agora você precisa clicar no menu do hambúrguer para que ele apareça, ou uma combinação de circunstâncias aleatórias permite esticá-lo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na versão pré-alfa do Android, o Navigation Drawer funciona, mas não me atrevi a atualizar - isso é pré-alfa. </font><font style="vertical-align: inherit;">Portanto, mesmo se você instalar a versão mais recente do GitFox a partir do repositório, existe uma Gaveta de Navegação, mas ela não pode ser extraída. </font><font style="vertical-align: inherit;">Assim que o suporte oficial for lançado, eu atualizarei e tudo funcionará bem.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de verificação de preparação do Android 10</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina a transparência da barra de navegação e da barra de status desde o início do projeto</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O Google recomenda enfaticamente a manutenção de uma barra de navegação transparente. Para nós, essa é uma parte prática importante. Se o projeto funcionar, mas você não o ativou, escolha a hora de oferecer suporte ao Android 10. Ligue-o primeiro no assunto, como translúcido, e corrija o layout onde ele quebrou. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione extensões ao Kotlin</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - é mais fácil com elas. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione a toda a barra de ferramentas em cima do preenchimento.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As barras de ferramentas estão sempre no topo, e é isso que você precisa fazer. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para todos os RecyclerViews, adicione preenchimento na parte inferior</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e a capacidade de rolar </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pense em todos os botões nas bordas da tela </font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(FAB)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Os FABs provavelmente não estarão onde você espera.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não substitua ou faça suas próprias implementações para todos os LinearLayout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e outros casos semelhantes. Faça o truque, como no GitFox, ou use minha extensão pronta para ajudar. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifique os gestos nas bordas da tela para ver a exibição personalizada</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A Gaveta de Navegação não suporta isso. Mas não é tão difícil apoiá-lo com as mãos, redefinir inserções para gestos na tela com a Gaveta de Navegação. Talvez você tenha editores de imagens em que os gestos funcionam. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A rolagem no ViewPager não funciona a partir da borda, mas apenas do centro para a direita e esquerda</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O Google diz que isso é normal. Se você puxar o ViewPager pela borda, ele será percebido como pressionando o botão "Voltar". </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em um novo projeto, inclua imediatamente toda a transparência</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Você pode dizer aos designers que não possui uma barra de navegação e uma barra de status. </font><font style="vertical-align: inherit;">O quadrado inteiro é o conteúdo do seu aplicativo. </font><font style="vertical-align: inherit;">E os desenvolvedores já descobrirão onde e o que criar. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links Úteis:</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@rmr_spb em um telegrama - registros de mitaps internos do Redmadrobot SPb.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo o código-fonte deste artigo e ainda mais no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Há um ramo separado do Android 10, onde você pode ver por confirmar como cheguei a tudo isso e como apoiei o novo Android.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biblioteca Insetter de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chris Bane. </font><font style="vertical-align: inherit;">Ele contém 5-6 extensões que mostrei. </font><font style="vertical-align: inherit;">Para usar no seu projeto, entre em contato com a biblioteca, provavelmente ela será movida para o Android Jetpack. </font><font style="vertical-align: inherit;">Eu os desenvolvi no meu projeto e, ao que me parece, eles melhoraram.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artigo de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chris Bane.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>   FunCorn,    ,      .</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Why would I want to fitsSystemWindows?</a>»  .</li>
</ul><br>
<blockquote>    AppConf,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">youtube-</a>      .            ,     - .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a>     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>, stay tuned!</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt488160/index.html">Windows Server 2019 vs. Instantâneos VMware com desativação: uma solução elegante para o problema</a></li>
<li><a href="../pt488162/index.html">Quanto maior a classificação, mais dinheiro e vice-versa</a></li>
<li><a href="../pt488164/index.html">Batalha da SEC contra o Telegram</a></li>
<li><a href="../pt488190/index.html">Mais uma vez sobre esgotamento emocional</a></li>
<li><a href="../pt488194/index.html">Por que estamos escrevendo programas de tão baixa qualidade?</a></li>
<li><a href="../pt488198/index.html">Do que os Timlids têm medo e por que deveriam parar de fazer isso</a></li>
<li><a href="../pt488200/index.html">O debate sobre a primeira linguagem de programação: a decisão final</a></li>
<li><a href="../pt488202/index.html">Agora, o PVS-Studio está no Chocolatey: verificando o Chocolatey no Azure DevOps</a></li>
<li><a href="../pt488208/index.html">Aniversário DUMP2020 - 4 dias que você não esquecerá</a></li>
<li><a href="../pt488210/index.html">Reconhecendo objetos no Android usando o TensorFlow: da preparação de dados ao lançamento no dispositivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>