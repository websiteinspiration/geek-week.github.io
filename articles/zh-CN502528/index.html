<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱🏿 ✊🏿 ♻️ 在ESP32上为嵌入式设备编程游戏 🤛🏿 👩🏿‍🎨 🥒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第0部分：动机
 介绍
 我一直在寻找一个业余爱好项目，我可以在主要任务之外进行工作，以便摆脱世界局势。我对游戏编程最感兴趣，但我也喜欢嵌入式系统。现在，我在一家游戏公司工作，但是在我主要从事微控制器之前。尽管最终我决定改变自己的道路，进入游戏行业，但我仍然喜欢尝试使用它们。那么，为什么不将两个爱好...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在ESP32上为嵌入式设备编程游戏</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502528/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第0部分：动机</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我一直在寻找一个业余爱好项目，我可以在主要任务之外进行工作，以便摆脱世界局势。</font><font style="vertical-align: inherit;">我对游戏编程最感兴趣，但我也喜欢嵌入式系统。</font><font style="vertical-align: inherit;">现在，我在一家游戏公司工作，但是在我主要从事微控制器之前。</font><font style="vertical-align: inherit;">尽管最终我决定改变自己的道路，进入游戏行业，但我仍然喜欢尝试使用它们。</font><font style="vertical-align: inherit;">那么，为什么不将两个爱好结合起来呢？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid去</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我让</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go闲逛</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这很有趣。</font><font style="vertical-align: inherit;">它的核心是ESP32-一种非常流行的微控制器，具有标准的MK功能（SPI，I2C，GPIO，计时器等），还具有WiFi和蓝牙功能，因此对于创建IoT设备非常有吸引力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go通过一系列外围设备对ESP32进行了补充，使其变成了类似Gameboy Color的便携式游戏机：一个LCD显示屏，一个扬声器，一个控制叉，两个主按钮和四个辅助按钮，一个电池和一个SD卡读卡器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，人们购买Odroid Go来</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旧的8位系统的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">仿真器</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果这个东西能够模仿旧游戏，那么它也可以应付专门为其设计的本地游戏的发布。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg"></div><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局限性</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分辨率320x240</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
显示器的尺寸仅为320x240，因此同时显示在屏幕上的信息量非常有限。我们需要仔细考虑我们将制作哪种游戏以及使用哪些资源。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16位彩色</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
显示器支持每个像素16位彩色：红色5位，绿色6位和蓝色5位。由于明显的原因，这种电路通常称为RGB565。绿色的红色和蓝色要多一些，因为人眼比蓝色或红色更好地区分了绿色的渐变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16位颜色表示我们只能使用65,000种颜色。与此相比，标准的24位颜色（每种颜色8位）可提供1600 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">万种</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺乏GPU</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有GPU，我们将无法使用OpenGL之类的API。如今，用于渲染2D游戏的GPU通常与3D游戏相同。只是代替对象，而是绘制四边形，在其上叠加位纹理。如果没有GPU，我们必须使用CPU光栅化每个像素，这虽然速度较慢，但​​更为简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
屏幕分辨率为320x240和16位彩色时，帧缓冲区的总大小为153,600字节。这意味着每秒至少需要三十次传输153,600字节到显示器。这最终会导致问题，因此渲染屏幕时我们需要变得更聪明。例如，您可以将索引颜色转换为调色板，这样对于每个像素，您需要存储一个字节，该字节将用作256色调色板的索引。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 MB</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ESP32具有520 KB内部RAM，而Odroid Go添加了另外4 MB外部RAM。但是我们无法使用所有这些内存，因为一部分由ESP32 SDK使用（稍后会详细介绍）。禁用所有可能的无关功能并输入我的主要功能后，ESP32报告我们可以使用4,494,848字节。如果将来我们需要更多的内存，那么以后我们可以返回以修剪不必要的功能。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80-240 MHz处理器</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以三种可能的速度配置CPU：80 MHz，160 MHz和240 MHz。甚至最大240 MHz也远远不能满足我们过去使用的超过3 GHz的现代计算机的能力。我们将从80 MHz开始，看看能走多远。如果我们希望游戏依靠电池供电，则功耗应较低。为此，最好降低频率。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误的调试</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有多种方法可将调试器与嵌入式设备（JTAG）结合使用，但是不幸的是，Odroid Go无法为我们提供必要的联系，因此我们无法像通常情况那样逐步调试调试器中的代码。</font><font style="vertical-align: inherit;">这意味着调试可能是一个困难的过程，我们将必须积极使用屏幕上的调试（使用颜色和文本），并将信息输出到调试控制台（幸运的是，可以通过USB UART轻松访问该信息）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么所有麻烦？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么还要尝试为具有上述所有限制的这种性能较弱的设备创建游戏，而又不为台式机编写任何内容？造成这种情况的原因有两个：</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制会激发创造力</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当您使用具有特定设备集的系统工作时，每种设备都有其自身的局限性，因此您需要考虑如何最好地利用这些局限性的优势。因此，我们与旧系统的游戏开发者（例如Super Nintendo）的关系更加紧密（但对我们而言，这比对他们而言要容易得多）。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低级开发很有趣</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要从头开始为常规的台式机系统编写游戏，我们必须使用标准的低级引擎概念：渲染，物理，碰撞识别。</font><font style="vertical-align: inherit;">但是，当在嵌入式设备上实现所有这些功能时，我们还必须处理低级计算机概念，例如，编写LCD驱动程序。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发展将有多低？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当涉及到低级和创建自己的代码时，您必须在某处绘制边框。如果我们试图为桌面编写不带库的游戏，那么边界很可能是操作系统或诸如SDL之类的跨平台API。在我的项目中，我将编写SPI驱动程序和引导加载程序之类的内容。与他们在一起的折磨不仅仅是乐趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们将使用ESP-IDF，它实际上是ESP32的SDK。我们可以假定它为我们提供了操作系统通常提供的一些实用程序，但是该</font><font style="vertical-align: inherit;">操作系统</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在ESP32中运行</font><font style="vertical-align: inherit;">。严格来说，该MK使用FreeRTOS，这是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个实时操作系统</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但这不是真正的操作系统。</font><font style="vertical-align: inherit;">这只是一个计划者。</font><font style="vertical-align: inherit;">最有可能的是，我们不会与之交互，但在其核心ESP-IDF中会使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF为我们提供了适用于ESP32外设的API（例如SPI，I2C和UART）以及C运行时库，因此当我们调用诸如printf之类的东西时，它实际上是通过UART传输字节以显示在串行接口监视器上的。</font><font style="vertical-align: inherit;">它还会在调用我们的游戏启动点之前处理准备机器所需的所有启动代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这篇文章中，我将保留一份发展杂志，其中我将谈论我看来有趣的观点并解释最困难的方面。</font><font style="vertical-align: inherit;">我没有计划，很可能会犯很多错误。</font><font style="vertical-align: inherit;">我创建的所有这些都是出于兴趣。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1部分：构建系统</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始为Odroid Go编写代码之前，我们需要配置ESP32 SDK。</font><font style="vertical-align: inherit;">它包含启动ESP32并调用我们的主要功能的代码，以及编写LCD驱动程序时所需的外围代码（例如SPI）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乐鑫对其</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SDK进行了调用</font><font style="vertical-align: inherit;">；</font><font style="vertical-align: inherit;">我们使用最新的稳定版本</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v4.0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以根据存储库的说明（带有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">克隆存储库</font><font style="vertical-align: inherit;">，或者直接从发行版页面下载zip。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的首要目标是在Odroid Go上安装最小的Hello World风格的应用程序，以证明构建环境的正确设置。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C或C ++</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF使用C99，因此我们也将选择它。</font><font style="vertical-align: inherit;">如果需要的话，我们可以使用C ++（在ESP32工具链中有一个C ++编译器），但是现在我们仍然坚持使用C。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，我喜欢C及其简单性。</font><font style="vertical-align: inherit;">不管我用C ++编写多少代码，我都无法设法享受它。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个人很好地总结了我的想法。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，如有必要，我们可以随时切换到C ++。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小的项目</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF使用CMake来管理构建系统。它还支持Makefile，但v4.0中已弃用它们，因此我们仅使用CMake。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至少，我们需要一个</font><font style="vertical-align: inherit;">带有项目描述的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">，一个</font><font style="vertical-align: inherit;">包含游戏入口点源文件的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件夹</font><font style="vertical-align: inherit;">以及</font><strong><font style="vertical-align: inherit;">main</font></strong><font style="vertical-align: inherit;">内的</font><font style="vertical-align: inherit;">另一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">，其中列出了源文件。</font><font style="vertical-align: inherit;">
CMake需要引用环境变量，这些变量告诉它在哪里寻找IDF和工具链。我很生气，每次启动新的终端会话时都必须重新安装它们，所以我写了</font><strong><font style="vertical-align: inherit;">export.sh</font></strong><font style="vertical-align: inherit;">脚本</font><font style="vertical-align: inherit;">。它设置</font><strong><font style="vertical-align: inherit;">IDF_PATH</font></strong><font style="vertical-align: inherit;">和</font><strong><font style="vertical-align: inherit;">IDF_TOOLS_PATH</font></strong></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它还是设置其他环境变量的IDF导出源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
脚本用户</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只要</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置</font><strong><font style="vertical-align: inherit;">IDF_PATH</font></strong><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_TOOLS_PATH变量</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就足够了</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="powershell hljs">IDF_PATH=<font></font>
IDF_TOOLS_PATH=<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_TOOLS_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_TOOLS_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<font></font>
export IDF_PATH<font></font>
export IDF_TOOLS_PATH<font></font>
<font></font>
source <span class="hljs-variable">$IDF_PATH</span>/export.sh</code></pre><br>
<strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根目录中的</font><strong><font style="vertical-align: inherit;">CMakeLists.txt</font></strong><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<font></font>
<font></font>
<span class="hljs-keyword">set</span>(COMPONENTS <span class="hljs-string">"esptool_py main"</span>)<font></font>
<font></font>
<span class="hljs-keyword">include</span>($ENV{IDF_PATH}/tools/cmake/<span class="hljs-keyword">project</span>.cmake)<font></font>
<font></font>
<span class="hljs-keyword">project</span>(game)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，构建系统将在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ ESP_IDF / components中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">构建所有可能的</font><strong><font style="vertical-align: inherit;">组件</font></strong><font style="vertical-align: inherit;">，这将导致更多的编译时间。</font><font style="vertical-align: inherit;">我们希望编译一组最小的组件以调用我们的主函数，并在必要时稍后连接其他组件。</font><font style="vertical-align: inherit;">这就是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPONENTS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量的作用</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cmake hljs">idf_component_register(<font></font>
	SRCS <span class="hljs-string">"main.c"</span>
    INCLUDE_DIRS <span class="hljs-string">""</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他所做的一切-无限次地在监视器上显示串行接口“ Hello World”。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VTaskDelay</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用FreeRTOS </font><font style="vertical-align: inherit;">进行延迟</font><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">main.c</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
文件</font><font style="vertical-align: inherit;">非常简单：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/FreeRTOS.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/task.h&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!\n"</span>);<font></font>
		vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，我们的函数称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font></em> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">IDF使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">进行必要的准备，然后</font><font style="vertical-align: inherit;">使用</font><strong><font style="vertical-align: inherit;">app_main</font></strong><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">作为入口点</font><font style="vertical-align: inherit;">创建</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
任务只是FreeRTOS可以管理的可执行块。尽管我们不必为此担心（或根本不用担心），但这里需要特别注意的是，我们的游戏运行在一个内核中（ESP32有两个内核），并且每次for循环迭代时，任务都会将执行延迟一秒钟。在此延迟期间，FreeRTOS调度程序可能会执行其他正在排队等待执行的代码（如果有）。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以同时使用两个内核，但是现在让我们将其限制为一个。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使</font><font style="vertical-align: inherit;">由于依赖链的配置，</font><font style="vertical-align: inherit;">即使我们将组件列表减少到Hello World应用程序所需的最少数量（即</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esptool_py</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），它仍会收集一些我们不需要的其他组件。</font><font style="vertical-align: inherit;">它收集所有这些组件：</font></font><br>
<br>
<pre><code class="cmake hljs">app_trace app_update bootloader bootloader_support cxx driver efuse esp32 esp_common esp_eth esp_event esp_ringbuf<font></font>
esp_rom esp_wifi espcoredump esptool_py freertos heap log lwip main mbedtls newlib nvs_flash partition_table pthread<font></font>
soc spi_flash tcpip_adapter vfs wpa_supplicant xtensa</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中许多都是相当合乎逻辑的（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bootloader</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freertos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但是它们后面是不必要的组件，因为我们不使用网络功能：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_eth，esp_wifi，lwip，mbedtls，tcpip_adapter，wpa_supplicant</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不幸的是，我们仍然被迫组装这些组件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，链接器足够聪明，不会将未使用的组件放入游戏的现成二进制文件中。</font><font style="vertical-align: inherit;">我们可以使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make size-components进行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code><pre>Total sizes:
 DRAM .data size:    8476 bytes
 DRAM .bss  size:    4144 bytes
Used static DRAM:   12620 bytes ( 168116 available, 7.0% used)
Used static IRAM:   56345 bytes (  74727 available, 43.0% used)
      Flash code:   95710 bytes
    Flash rodata:   40732 bytes
Total image size:~ 201263 bytes (.bin may be padded larger)
Per-archive contributions to ELF file:
            Archive File DRAM .data &amp; .bss   IRAM Flash code &amp; rodata   Total
                  libc.a        364      8   5975      63037     3833   73217
              libesp32.a       2110    151  15236      15415    21485   54397
           libfreertos.a       4148    776  14269          0     1972   21165
                libsoc.a        184      4   7909        875     4144   13116
          libspi_flash.a        714    294   5069       1320     1386    8783
                libvfs.a        308     48      0       5860      973    7189
         libesp_common.a         16   2240    521       1199     3060    7036
             libdriver.a         87     32      0       4335     2200    6654
               libheap.a        317      8   3150       1218      748    5441
             libnewlib.a        152    272    869        908       99    2300
        libesp_ringbuf.a          0      0    906          0      163    1069
                liblog.a          8    268    488         98        0     862
         libapp_update.a          0      4    127        159      486     776
 libbootloader_support.a          0      0      0        634        0     634
                libhal.a          0      0    519          0       32     551
            libpthread.a          8     12      0        288        0     308
             libxtensa.a          0      0    220          0        0     220
                libgcc.a          0      0      0          0      160     160
               libmain.a          0      0      0         22       13      35
                libcxx.a          0      0      0         11        0      11
                   (exe)          0      0      0          0        0       0
              libefuse.a          0      0      0          0        0       0
         libmbedcrypto.a          0      0      0          0        0       0
     libwpa_supplicant.a          0      0      0          0        0       0</pre></code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最重要的是，libc影响二进制文件的大小，这很好。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目配置</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF允许您指定在汇编过程中使用的编译时配置参数，以启用或禁用各种功能。</font><font style="vertical-align: inherit;">我们需要设置参数，使我们能够利用Odroid Go的其他方面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，您需要运行</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的源脚本，</font><font style="vertical-align: inherit;">以便CMake可以访问必要的环境变量。</font><font style="vertical-align: inherit;">此外，对于所有CMake项目，我们需要创建一个程序集文件夹并从中调用CMake。</font></font><br>
<br>
<pre><code class="cmake hljs">source <span class="hljs-keyword">export</span>.sh<font></font>
mkdir build<font></font>
cd build<font></font>
cmake ..</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果运行</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make menuconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则会打开一个窗口，您可以在其中配置项目设置。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将闪存扩展到16 MB</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go将标准闪存驱动器容量扩展到16 MB。</font><font style="vertical-align: inherit;">您可以通过转至</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">串行闪存配置-&gt;闪存大小-&gt; 16MB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来启用此功能</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开外部SPI RAM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还可以访问通过SPI连接的额外4 MB外部RAM。</font><font style="vertical-align: inherit;">您可以通过以下方法启用它：转到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component config-&gt; ESP32-specific-&gt;支持外部，SPI连接的RAM，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后按空格键将其启用。</font><font style="vertical-align: inherit;">我们还希望能够从SPI RAM中显式分配内存。</font><font style="vertical-align: inherit;">可以通过转到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI RAM配置-&gt; SPI RAM访问方法-&gt;使用heap_caps_malloc使RAM可分配来启用此功能</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低频率</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32默认以160 MHz的频率工作，但让我们将其降低到80 MHz以查看最低时钟频率能走多远。我们希望游戏靠电池供电，降低频率可以节省功率。您可以通过转到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component config-&gt; ESP32-specific-&gt; CPU frequency-&gt; 80MHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来更改它</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果选择</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件将保存到项目文件夹的根目录</font><font style="vertical-align: inherit;">。我们可以用git编写这个文件，但是它有很多参数对我们来说并不重要。到目前为止，我们对标准参数感到满意，除了刚刚更改的那些参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以</font><strong><font style="vertical-align: inherit;">改为</font></strong><font style="vertical-align: inherit;">创建</font><strong><font style="vertical-align: inherit;">sdkconfig.defaults</font></strong><font style="vertical-align: inherit;">文件</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中将包含上面更改的值。</font><font style="vertical-align: inherit;">默认情况下将配置其他所有内容。</font><font style="vertical-align: inherit;">在构建期间，IDF将读取</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，覆盖我们设置的值，并将标准用于所有其他参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来像这样：</font></font><br>
<br>
<pre><code class="cpp hljs"># Set flash size to <span class="hljs-number">16</span>MB<font></font>
CONFIG_ESPTOOLPY_FLASHSIZE_16MB=y<font></font>
<font></font>
# Set CPU frequency to <span class="hljs-number">80</span>MHz<font></font>
CONFIG_ESP32_DEFAULT_CPU_FREQ_80=y<font></font>
<font></font>
# Enable SPI RAM <span class="hljs-keyword">and</span> allocate with heap_caps_malloc()<font></font>
CONFIG_ESP32_SPIRAM_SUPPORT=y<font></font>
CONFIG_SPIRAM_USE_CAPS_ALLOC=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，游戏的原始结构如下所示：</font></font><br>
<br>
<code><pre>game
├── CMakeLists.txt
├── export.sh
├── main
│   ├── CMakeLists.txt
│   └── main.c
└── sdkconfig.defaults</pre></code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成并刷新</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
组装和固件过程本身非常简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们运行</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行编译（对于并行构建</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">添加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j8</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使make flash</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将图像写入Odroid Go，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使Monitor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句的输出</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cmake hljs">make<font></font>
make flash<font></font>
make monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们也可以一行执行它们。</font></font><br>
<br>
<pre><code class="cmake hljs">make flash monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果并不是特别令人印象深刻，但是它将成为该项目其余部分的基础。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c2/329/62f/3c232962f8e782c9220b25b7e3c0df5e.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：构建系统</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FreeRTOS文档：vTaskDelay</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2部分：输入</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要能够读取玩家所按下的按钮以及Odroid Go上的叉号。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纽扣</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/142/ca2/106142ca2250eb9301215015b6f0bbad.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用输入输出</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go具有六个按钮：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">菜单</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音量</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个按钮都连接到单独的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用IO（GPIO）引脚</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">GPIO引脚可以用作输入（用于读取）或用作输出（我们对其进行写入）。</font><font style="vertical-align: inherit;">对于按钮，我们需要阅读。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，您需要将联系人配置为输入，然后我们可以读取其状态。</font><font style="vertical-align: inherit;">内部触点具有两个电压（3.3V或0V）之一，但是当使用IDF功能读取它们时，它们将转换为整数值。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图</font><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">标记为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素</font><font style="vertical-align: inherit;">是物理按钮本身。未按下时，ESP32触点（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）连接到3.3 V；即3.3 V表示</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未按下</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">。这里的逻辑与预期的相反。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的板上有物理电阻。如果未按下按钮，则电阻器</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会将</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">触点</font><strong><font style="vertical-align: inherit;">拉</font></strong><font style="vertical-align: inherit;">至高电压。如果按下该按钮，则</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过触点的电流将</font><strong><font style="vertical-align: inherit;">流向</font></strong><font style="vertical-align: inherit;">地面，因此将从触点读取电压0 </font><strong><font style="vertical-align: inherit;">IO13</font></strong><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有电阻，因为ESP32上的触点具有内部电阻，我们将其配置为上拉模式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道了这一点，我们可以使用GPIO API配置六个按钮。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_A = GPIO_NUM_32;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_B = GPIO_NUM_33;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_START = GPIO_NUM_39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_SELECT = GPIO_NUM_27;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_VOLUME = GPIO_NUM_0;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_MENU = GPIO_NUM_13;<font></font>
<font></font>
<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
gpioConfig.mode = GPIO_MODE_INPUT;<font></font>
gpioConfig.pull_up_en = GPIO_PULLUP_ENABLE;<font></font>
gpioConfig.pin_bit_mask =<font></font>
	  (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_A)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_B)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_START)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_SELECT)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_VOLUME)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_MENU);<font></font>
<font></font>
ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在代码开头指定的常数对应于每个电路触点。我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">将六个按钮中的每个按钮配置为上拉输入。在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的情况下</font><strong><font style="vertical-align: inherit;">，</font></strong><font style="vertical-align: inherit;">我们需要让IDF打开这些触点的上拉电阻。对于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不需要这样做，因为它们具有物理电阻，但是无论如何我们都会这样做，以使配置美观。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_ERROR_CHECK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是IDF的帮助程序宏，它自动检查所有返回</font><strong><font style="vertical-align: inherit;">esp_err_t的</font></strong><font style="vertical-align: inherit;">函数的结果</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大多数IDF），并断言结果不等于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_OK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果该宏的错误很严重，并且在继续执行之后没有任何意义，则可以将该宏方便地用于函数。</font><font style="vertical-align: inherit;">在此游戏中，没有输入的游戏不是游戏，因此该说法正确。</font><font style="vertical-align: inherit;">我们将经常使用此宏。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读按钮</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们配置了所有联系人，并最终可以读取值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数字按钮由</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_get_level</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数读取</font><font style="vertical-align: inherit;">，但是我们需要反转接收到的值，因为触点被拉高，也就是说，高电平信号实际上表示“未按下”，而低电平信号表示“按下”。</font><font style="vertical-align: inherit;">反相保留通常的逻辑：1表示“按下”，0表示“未按下”。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a = !gpio_get_level(BUTTON_PIN_A);
<span class="hljs-keyword">int</span> b = !gpio_get_level(BUTTON_PIN_B);
<span class="hljs-keyword">int</span> select = !gpio_get_level(BUTTON_PIN_SELECT);
<span class="hljs-keyword">int</span> start = !gpio_get_level(BUTTON_PIN_START);
<span class="hljs-keyword">int</span> menu = !gpio_get_level(BUTTON_PIN_MENU);
<span class="hljs-keyword">int</span> volume = !gpio_get_level(BUTTON_PIN_VOLUME);</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">横梁（D-垫）</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d9e/a73/1e8d9ea7303257afd45846771726a275.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接十字架不同于连接按钮。</font><font style="vertical-align: inherit;">向上和向下按钮连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模数转换器（ADC）的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个引脚，</font><font style="vertical-align: inherit;">向左和向右按钮</font><font style="vertical-align: inherit;">连接</font><font style="vertical-align: inherit;">到另一ADC引脚。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与GPIO数字触点不同，我们可以从其中读取两种状态（高或低）之一，ADC将连续的模拟电压（例如，从0 V到3.3 V）转换为离散的数值（例如，从0到4095） ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想Odroid Go的设计人员这样做是为了节省GPIO引脚（您只需要两个模拟引脚，而不是四个数字引脚）。</font><font style="vertical-align: inherit;">不管怎样，这会使配置和从这些触点读取的内容稍微复杂化。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组态</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
触点</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到</font><strong><font style="vertical-align: inherit;">星形轮</font></strong><font style="vertical-align: inherit;">的Y轴，触点</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34连接</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font><strong><font style="vertical-align: inherit;">星形轮</font></strong><font style="vertical-align: inherit;">的X轴。我们看到十字架的关节比数字按钮稍微复杂一些。每个轴都有两个开关（</font><font style="vertical-align: inherit;">Y轴为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">X轴为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），每个</font><font style="vertical-align: inherit;">开关</font><font style="vertical-align: inherit;">都连接到一组电阻（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果未按下“上”或“下”，则</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35引脚</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下拉至地</font><font style="vertical-align: inherit;">，我们将其值视为0V。如果未按下“左”或“右”，请与</font><strong><font style="vertical-align: inherit;">IO34</font></strong><font style="vertical-align: inherit;">联系</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下拉到地面</font><font style="vertical-align: inherit;">，我们将值计数为0V。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果按下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1（“向上”）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数为3.3V。如果按下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2（“向下”）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数为1， 65 V，因为一半的电压将降到电阻</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2上</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果按下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3（“左”）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将计数为3.3V。如果按下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4（“右”）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还将计数为1.65 V，因为一半的电压将下降到电阻</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4上</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
两种情况都是</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">分压器的</font></a><font style="vertical-align: inherit;">示例</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当分压器中的两个电阻具有相同的电阻（在我们的示例中为100K）时，压降将为输入电压的一半。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道了这一点，我们可以配置横档：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_X_AXIS = ADC1_GPIO34_CHANNEL;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_Y_AXIS = ADC1_GPIO35_CHANNEL;<font></font>
<font></font>
ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_12));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_X_AXIS,ADC_ATTEN_DB_11));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_Y_AXIS,ADC_ATTEN_DB_11));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将ADC设置为12位宽，以便将0 V读取为0，将3.3 V读取为4095（2 ^ 12）。</font><font style="vertical-align: inherit;">衰减报告显示，我们无需衰减信号即可获得0 V至3.3 V的整个电压范围。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在12位时，我们可以预期，如果不进行任何操作，则在向左和向左按下时将读取0，即4096，以及向下和向右按下将读取大约2048（因为电阻将电压降低一半）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交叉阅读</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读取十字架比按钮更困难，因为我们需要读取原始值（从0到4095）并解释它们。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_POSITIVE_LEVEL = <span class="hljs-number">3072</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_NEGATIVE_LEVEL = <span class="hljs-number">1024</span>;<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadX = adc1_get_raw(DPAD_PIN_X_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadX &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Left pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadX &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Right pressed</span><font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadY = adc1_get_raw(DPAD_PIN_Y_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadY &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Up pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadY &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Down pressed</span>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_POSITIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_NEGATIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是带有边距的值，确保我们始终读取正确的值。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮询</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
获取按钮值有两个选项：轮询或中断。我们可以创建输入处理功能，并在按下按钮时要求IDF调用这些功能，或者在需要时手动轮询按钮的状态。中断驱动的行为使事情变得更加复杂和难以理解。此外，我一直在努力使一切变得尽可能简单。如有必要，我们可以稍后添加中断。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将创建一个结构，该结构将存储六个按钮和十字的四个方向的状态。我们可以创建一个包含10个布尔值，10个int或10个unsigned int的结构。但是，相反，我们将使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit field</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建结构</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">uint16_t</span> a : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> b : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> volume : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> menu : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> select : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> start : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> left : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> right : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> up : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> down : <span class="hljs-number">1</span>;<font></font>
} Odroid_Input;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在为台式机系统编程时，通常会避免位字段，因为它们无法很好地移植到不同的计算机上，但是我们为特定的计算机编程，因此不必为此担心。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代替字段，可以使用具有10个布尔值且总大小为10个字节的结构。</font><font style="vertical-align: inherit;">另一种选择是一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint16_t，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它具有可以设置，</font><strong><font style="vertical-align: inherit;">清除</font></strong><font style="vertical-align: inherit;">和检查单个位的移位和位掩码宏。</font><font style="vertical-align: inherit;">它可以工作，但是不会很漂亮。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个简单的位字段使我们可以利用两种方法：两个字节的数据和命名字段。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示版</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以轮询主循环内的输入状态并显示结果。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-built_in">printf</span>(
			<span class="hljs-string">"\ra: %d  b: %d  start: %d  select: %d  vol: %d  menu: %d  up: %d  down: %d  left: %d  right: %d"</span>,<font></font>
			input.a, input.b, input.start, input.select, input.volume, input.menu,<font></font>
			input.up, input.down, input.left, input.right);<font></font>
<font></font>
		fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">250</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
函数</font><font style="vertical-align: inherit;">使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ r</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覆盖前一行而不是添加新行。</font><font style="vertical-align: inherit;">需要</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fflush</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">才能显示一行，因为在正常状态下，它会由换行符</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重置</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_2/media/input.mp4" type="video/mp4"></video></div></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid走示意图</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：GPIO</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3部分：展示</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要能够在Odroid Go LCD上渲染像素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于LCD有大脑，因此在屏幕上显示颜色比读取输入状态要困难。</font><font style="vertical-align: inherit;">屏幕由</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILI9341</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">控制</font><strong><font style="vertical-align: inherit;">-ILI9341</font></strong><font style="vertical-align: inherit;">是一种非常流行的TFT LCD驱动器，位于单个芯片上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
换句话说，我们正在与ILI9341对话，后者通过控制LCD上的像素来响应我们的命令。</font><font style="vertical-align: inherit;">当我在这一部分中说“屏幕”或“显示”时，实际上是指ILI9341。</font><font style="vertical-align: inherit;">我们正在处理ILI9341。</font><font style="vertical-align: inherit;">它控制LCD。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LCD通过</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI（串行外设接口）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到ESP32 </font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SPI是一种标准协议，用于在印刷电路板上的设备之间交换数据。它具有四个信号：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI（主机输出从机输入）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO（主机输入从机输出）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK（时钟）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS（芯片选择）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总线上的单个主设备通过控制SCK和CS协调数据传输。一条总线上可以有多个设备，每个设备都有自己的CS信号。激活此设备的CS信号后，它可以发送和接收数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32将是SPI主机（主机），而LCD将是SPI从机。</font><font style="vertical-align: inherit;">我们需要使用所需的参数配置SPI总线，并通过配置相应的触点将LCD显示添加到总线。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/60e/18c/7bc60e18c1b066ba7c22756464f92512.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/463/615/f124636158029efeab3259f299a2af36.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名称</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是该图中触点的标签，但是我们可以通过查看LCD和ESP32图的各个部分来遍历触点本身。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - &gt; VSPI.MOSI - &gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO23</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - &gt; VSPI.MISO - &gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO19</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - &gt; VSPI.SCK - &gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO18</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - &gt; VSPI.CS0 - &gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110 5</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO14和IO21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><strong><font style="vertical-align: inherit;">IO14</font></strong><font style="vertical-align: inherit;">是用于打开背光灯的GPIO引脚，而</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">LCD </font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引脚连接</font><font style="vertical-align: inherit;">。此联系人控制我们传输到显示器的信息的类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，配置SPI总线。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MISO = GPIO_NUM_19;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MOSI = GPIO_NUM_23;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_SCLK = GPIO_NUM_18;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_CS = GPIO_NUM_5;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_DC = GPIO_NUM_21;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_BACKLIGHT = GPIO_NUM_14;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_WIDTH = <span class="hljs-number">320</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_HEIGHT = <span class="hljs-number">240</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_DEPTH = <span class="hljs-number">2</span>;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">spi_bus_config_t</span> spiBusConfig = {};<font></font>
spiBusConfig.miso_io_num = LCD_PIN_MISO;<font></font>
spiBusConfig.mosi_io_num = LCD_PIN_MOSI;<font></font>
spiBusConfig.sclk_io_num = LCD_PIN_SCLK;<font></font>
spiBusConfig.quadwp_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span>
spiBusConfig.quadhd_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span><font></font>
spiBusConfig.max_transfer_sz = LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;spiBusConfig, <span class="hljs-number">1</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_bus_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置总线</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有必要传达我们使用的联系人和一次数据传输的最大大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将对所有帧缓冲区数据执行一次SPI传输，该传输等于LCD的宽度（以像素为单位）乘以其高度（以像素为单位）乘以每个像素的字节数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宽度为320，高度为240，颜色深度为2字节（显示器期望像素颜色为16位深）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">spi_handle_t</span> gSpiHandle;<font></font>
<font></font>
<span class="hljs-keyword">spi_device_interface_config_t</span> spiDeviceConfig = {};<font></font>
spiDeviceConfig.clock_speed_hz = SPI_MASTER_FREQ_40M;<font></font>
spiDeviceConfig.spics_io_num = LCD_PIN_CS;<font></font>
spiDeviceConfig.queue_size = <span class="hljs-number">1</span>;<font></font>
spiDeviceConfig.flags = SPI_DEVICE_NO_DUMMY;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_add_device(VSPI_HOST, &amp;spiDeviceConfig, &amp;gSpiHandle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初始化总线后，我们需要在总线上添加一个LCD设备，以便我们可以开始与之对话。</font></font><br>
<br>
<ul>
<li><strong>clock_speed_hz</strong> —   - ,      SPI   40 ,     .        80 ,         .</li>
<li><strong>spics_io_num</strong> —    CS,  IDF     CS,        ( SD-     SPI).</li>
<li><strong>queue_size</strong> —     1,           (  ).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -IDF SPI驱动程序通常在传输中插入空位，以避免在从SPI器件读取过程中出现时序问题，但是我们执行单向传输（不会从显示器读取）。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_DEVICE_NO_DUMMY</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告我们确认了这种单向传输，并且不需要插入空位。</font></font></li>
</ul><br>
<br>
<pre><code class="cpp hljs">gpio_set_direction(LCD_PIN_DC, GPIO_MODE_OUTPUT);<font></font>
gpio_set_direction(LCD_PIN_BACKLIGHT, GPIO_MODE_OUTPUT);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还需要将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和背光引脚设置为GPIO引脚。</font><font style="vertical-align: inherit;">切换</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC后，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背光将一直亮着。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队伍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与LCD的通信采用命令形式。</font><font style="vertical-align: inherit;">首先，我们传递一个字节来表示要发送的命令，然后传递命令参数（如果有）。</font><font style="vertical-align: inherit;">如果</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信号为低电平</font><font style="vertical-align: inherit;">，则显示屏将理解该字节为命令</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直流</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信号为高电平，则接收到的数据将被视为先前发送命令的参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，流看起来像这样：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们给</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直流</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低信号</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们发送命令的一个字节</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们给</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高信号</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送零个或多个字节，具体取决于命令的要求</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复步骤1-4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们最好的朋友是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILI9341规范</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它列出了所有可能的命令，它们的参数以及如何使用它们。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68d/8d8/09c/68d8d809ceb9446142cd5c77bb78d0e2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有参数的命令示例是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display ON</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">命令字节为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x29</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但未为其指定参数。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/4e0/446/35a4e04466c22aa6746fe441f345c02f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带参数的命令示例是“ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列地址集”</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">命令字节为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但为此指定了四个必需的参数。</font><font style="vertical-align: inherit;">要使用此命令，您需要向</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送一个</font><font style="vertical-align: inherit;">低信号，</font><font style="vertical-align: inherit;">向</font><strong><font style="vertical-align: inherit;">DC</font></strong><font style="vertical-align: inherit;">发送一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，向</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送一个</font><font style="vertical-align: inherit;">高信号，然后传输四个参数的字节。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令代码本身在枚举中指定。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><font></font>
{<font></font>
	SOFTWARE_RESET = <span class="hljs-number">0x01</span>u,<font></font>
	SLEEP_OUT = <span class="hljs-number">0x11</span>u,<font></font>
	DISPLAY_ON = <span class="hljs-number">0x29</span>u,<font></font>
	COLUMN_ADDRESS_SET = <span class="hljs-number">0x2A</span>u,<font></font>
	PAGE_ADDRESS_SET = <span class="hljs-number">0x2B</span>u,<font></font>
	MEMORY_WRITE = <span class="hljs-number">0x2C</span>u,<font></font>
	MEMORY_ACCESS_CONTROL = <span class="hljs-number">0x36</span>u,<font></font>
	PIXEL_FORMAT_SET = <span class="hljs-number">0x3A</span>u,<font></font>
} CommandCode;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相反，我们可以使用宏（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#define SOFTWARE_RESET（0x01u）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但是它们在调试器中没有符号，也没有作用域。</font><font style="vertical-align: inherit;">就像我们使用GPIO触点一样，也可以使用整数静态常数，但是由于有了枚举，我们一眼就能了解将哪些数据传递给函数或结构的成员：它们是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommandCode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">否则，可能是原始的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会</font><strong><font style="vertical-align: inherit;">告诉</font></strong><font style="vertical-align: inherit;">程序员阅读代码的任何信息。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发射</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在初始化期间，我们可以传递不同的命令以绘制一些东西。</font><font style="vertical-align: inherit;">每个命令都有一个命令字节，我们将其称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令代码</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将定义用于存储启动命令的结构，以便您可以指定其数组。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span><font></font>
	CommandCode code;<font></font>
	<span class="hljs-keyword">uint8_t</span> parameters[<span class="hljs-number">15</span>];
	<span class="hljs-keyword">uint8_t</span> length;<font></font>
} StartupCommand;</code></pre><br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是命令代码。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是命令参数（如果有）的数组。</font><font style="vertical-align: inherit;">这是一个大小为15的静态数组，因为这是我们需要的最大参数数量。</font><font style="vertical-align: inherit;">由于数组是静态的，因此我们不必担心每次都为每个命令分配动态数组。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">length</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组中参数的数量</font><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此结构，我们可以指定启动命令列表。</font></font><br>
<br>
<pre><code class="cpp hljs">StartupCommand gStartupCommands[] =<font></font>
{<font></font>
	<span class="hljs-comment">// Reset to defaults</span><font></font>
	{<font></font>
		SOFTWARE_RESET,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Landscape Mode</span>
	<span class="hljs-comment">// Top-Left Origin</span>
	<span class="hljs-comment">// BGR Panel</span><font></font>
	{<font></font>
		MEMORY_ACCESS_CONTROL,<font></font>
		{<span class="hljs-number">0x20</span> | <span class="hljs-number">0xC0</span> | <span class="hljs-number">0x08</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// 16 bits per pixel</span><font></font>
	{<font></font>
		PIXEL_FORMAT_SET,<font></font>
		{<span class="hljs-number">0x55</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Exit sleep mode</span><font></font>
	{<font></font>
		SLEEP_OUT,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Turn on the display</span><font></font>
	{<font></font>
		DISPLAY_ON,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有参数的命令，例如</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOFTWARE_RESET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将初始化程序列表设置为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为空（即，带有一个零），并将长度设置为0。带参数的命令填充参数并指定长度。</font><font style="vertical-align: inherit;">如果我们可以自动设置长度而不写数字（如果我们输入错误或参数更改），那将是很好的选择，但是我认为这样做不值得。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了两个，大多数团队的目的很明确。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_ACCESS_CONTROL</font></font></strong><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">横向模式：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，显示器使用纵向（240x320），但我们要使用横向（320x240）。</font></font></li>
<li><strong>Top-Left Origin:</strong>      (0,0)     ,    ( )         .</li>
<li><strong>BGR Panel:</strong>  ,        BGR.   ,    , ,   ,     .</li>
</ul><br>
<strong>PIXEL_FORMAT_SET</strong><br>
<br>
<ul>
<li><strong>16 bits per pixel:</strong>   16- .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在启动时还可以发送许多其他命令来控制各个方面，例如gamma。 LCD本身（而非ILI9341控制器）的规范中描述了必要的参数，我们无法访问这些参数。如果我们不传输这些命令，那么将使用默认显示设置，这非常适合我们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备好一系列启动命令后，我们就可以开始将它们传输到显示器了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们需要一个向显示器发送一个字节命令的函数。不要忘记发送命令与发送参数不同，因为我们需要向</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送</font><font style="vertical-align: inherit;">低信号。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTES_TO_BITS(value) ( (value) * 8 )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandCode</span><span class="hljs-params">(CommandCode code)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(<span class="hljs-number">1</span>);<font></font>
	transaction.tx_data[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)code;<font></font>
	transaction.flags = SPI_TRANS_USE_TXDATA;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">0</span>);<font></font>
	spi_device_transmit(gSpiHandle, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF具有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_transaction_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">，当我们想通过SPI总线传输某些内容时，我们将其填充。我们知道有效负载是多少位，并转移负载本身。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们既可以传递指向有效负载的指针，也可以使用内部结构</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构，该结构只有4个字节，但是可以节省驱动程序访问外部存储器的时间。如果使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则必须设置标志</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在传输数据之前，我们向</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送一个</font><font style="vertical-align: inherit;">低电平信号，表明这是命令代码。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandParameters</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">int</span> length)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(length);<font></font>
	transaction.tx_buffer = data;<font></font>
	transaction.flags = <span class="hljs-number">0</span>;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">1</span>);<font></font>
	spi_device_transmit(SPIHANDLE, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传递参数类似于发送命令，只是这一次我们使用自己的缓冲区（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）并向</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送</font><font style="vertical-align: inherit;">高电平信号</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">以通知显示器正在传输参数。</font><font style="vertical-align: inherit;">另外，</font><font style="vertical-align: inherit;">由于我们正在传递自己的缓冲区</font><font style="vertical-align: inherit;">，因此未设置</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，您可以发送所有启动命令。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARRAY_COUNT(value) ( sizeof(value) / sizeof(value[0]) )</span><font></font>
<font></font>
<span class="hljs-keyword">int</span> commandCount = ARRAY_COUNT(gStartupCommands);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> commandIndex = <span class="hljs-number">0</span>; commandIndex &lt; commandCount; ++commandIndex)<font></font>
{<font></font>
	StartupCommand* command = &amp;gStartupCommands[commandIndex];<font></font>
<font></font>
	SendCommandCode(command-&gt;code);<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (command-&gt;length &gt; <span class="hljs-number">0</span>)<font></font>
	{<font></font>
		SendCommandData(command-&gt;parameters, command-&gt;length);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们迭代遍历启动命令的数组，首先传递命令代码，然后传递参数（如果有）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初始化显示后，您可以在其上开始绘图。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UPPER_BYTE_16(value) ( (value) &gt;&gt; 8u )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOWER_BYTE_16(value) ( (value) &amp; 0xFFu )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DrawFrame</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* buffer)</span>
</span>{
	<span class="hljs-comment">// Set drawing window width to (0, LCD_WIDTH)</span>
    <span class="hljs-keyword">uint8_t</span> drawWidth[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_WIDTH), LOWER_BYTE_16(LCD_WIDTH) };<font></font>
	SendCommandCode(COLUMN_ADDRESS_SET);<font></font>
	SendCommandParameters(drawWidth, ARRAY_COUNT(drawWidth));<font></font>
<font></font>
	<span class="hljs-comment">// Set drawing window height to (0, LCD_HEIGHT)</span>
    <span class="hljs-keyword">uint8_t</span> drawHeight[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_HEIGHT), LOWER_BYTE_16(LCD_HEIGHT) };<font></font>
	SendCommandCode(PAGE_ADDRESS_SET);<font></font>
	SendCommandParameters(drawHeight, ARRAY_COUNT(drawHeight));<font></font>
<font></font>
	<span class="hljs-comment">// Send the buffer to the display</span><font></font>
	SendCommandCode(MEMORY_WRITE);<font></font>
	SendCommandParameters(buffer, LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341能够重绘屏幕的各个部分。如果我们注意到帧速率下降，则将来可能会派上用场。在这种情况下，将可能仅更新屏幕的已更改部分，但是现在我们只需要重新绘制整个屏幕即可。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要渲染框架，需要设置渲染窗口。要做到这一点，发送</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COLUMN_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">与窗口宽度和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAGE_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">与窗口的高度。每个命令占用参数的四个字节，这些字节描述了将在其中执行渲染的窗口。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPPER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LOWER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这些是辅助宏，用于从16位值中提取高字节和低字节。</font><font style="vertical-align: inherit;">这些命令的参数要求我们将16位值分成两个8位值，这就是我们这样做的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
渲染由</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_WRITE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令启动，</font><font style="vertical-align: inherit;">并一次将所有</font><strong><font style="vertical-align: inherit;">153,600</font></strong><font style="vertical-align: inherit;">字节的帧缓冲区发送到显示器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有其他将帧缓冲区传输到显示器的方法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以创建另一个FreeRTOS任务（任务），该任务负责协调SPI事务。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以不以一个为单位传送帧，而是以多个事务传送。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用非阻塞传输，在该传输中我们将启动发送，然后继续执行其他操作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用上述方法的任意组合。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将使用最简单的方法：唯一的阻塞事务。</font><font style="vertical-align: inherit;">调用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawFrame时</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将</font><font style="vertical-align: inherit;">启动到显示</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">传输，并且我们的任务将暂停直到传输完成。</font><font style="vertical-align: inherit;">如果以后发现使用此方法无法获得良好的帧速率，那么我们将回到这个问题。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565和字节顺序</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的显示器（例如计算机的显示器）的位深度为24位（160万色）：红色，绿色和蓝色为8位。像素作为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRRRGGGGGGGGGGBBBBBBBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入内存</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid LCD的位深度为16位（65,000种颜色）：5位红色，6位绿色和5位蓝色。该像素将作为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRRGGGGGGGBBBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入内存</font><font style="vertical-align: inherit;">。此格式称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP_ENDIAN_16(value) ( (((value) &amp; 0xFFu) <span class="hljs-meta-string">&lt;&lt; 8u) | ((value) &gt;&gt; 8u)  )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB565(red, green, blue) ( SWAP_ENDIAN_16( ((red) &lt;&lt; 11u) | ((green) &lt;&lt; 5u) | (blue) ) )</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定义一个以RGB565格式创建颜色的宏。我们将通过他一个红色的字节，一个绿色的字节和一个蓝色的字节。他将采用红色的五个最高有效位，绿色的六个最高有效位和蓝色的五个最高有效位。我们选择高位，因为它们比低位包含更多的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，ESP32以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little Endian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺序存储数据</font><font style="vertical-align: inherit;">，即最低有效字节存储在低位存储地址中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，32位值</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xDE 0xAD 0xBE 0xEF]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xEF 0xBE 0xAD 0xDE]的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式存储在内存中</font><font style="vertical-align: inherit;">。当将数据传输到显示器时，这将成为一个问题，因为最低有效字节将首先发送，并且LCD希望首先接收最高有效字节。</font><strong><font style="vertical-align: inherit;">设置</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
宏</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWAP_ENDIAN_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换字节并在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宏中使用它</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是RGB565中描述三种原色的方式，以及如果不更改字节顺序将它们存储在ESP32存储器中的方式。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
11111 | 000000 | 00000？-&gt; 11111000 00000000-&gt; 00000000 11111000 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿色</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 111111 | 00000？-&gt; 00000111 11100000-&gt; 11100000 00000111 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蓝色</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 000000 | 11111？-&gt; 00000000 00011111-&gt; 00011111 00000000</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示版</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以创建一个简单的演示来观看正在运行的LCD。</font><font style="vertical-align: inherit;">在帧的开头，它将帧缓冲区刷新为黑色，并绘制一个50x50的正方形。</font><font style="vertical-align: inherit;">我们可以使用十字移动正方形并使用按钮</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改其颜色</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
	Odroid_InitializeDisplay();<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Odroid initialization complete - entering main loop"</span>);<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span>* framebuffer = (<span class="hljs-keyword">uint16_t</span>*)heap_caps_malloc(<span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>, MALLOC_CAP_DMA);<font></font>
	assert(framebuffer);<font></font>
<font></font>
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span> color = <span class="hljs-number">0xffff</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">memset</span>(framebuffer, <span class="hljs-number">0</span>, <span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>);<font></font>
<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.left) { x -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.right) { x += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.up) { y -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.down) { y += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.a) { color = RGB565(<span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.b) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.start) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>); }<font></font>
<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">50</span>; ++row)<font></font>
		{<font></font>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">50</span>; ++col)<font></font>
			{<font></font>
				framebuffer[<span class="hljs-number">320</span> * row + col] = color;<font></font>
			}<font></font>
		}<font></font>
<font></font>
		Odroid_DrawFrame(framebuffer);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们根据显示器的整个尺寸分配帧缓冲区：320 x 240，每个像素两个字节（16位颜色）。</font><font style="vertical-align: inherit;">我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap_caps_malloc，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便在内存中分配内存，该内存可用于具有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接内存访问（DMA）的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SPI事务</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">DMA允许SPI外设访问帧缓冲区，而无需占用CPU。</font><font style="vertical-align: inherit;">如果没有DMA，SPI事务将花费更长的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们不会执行检查以确保不会在屏幕边界之外进行渲染。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_3/media/demo.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
强烈的撕裂感很明显。在桌面应用程序中，消除撕裂的标准方法是使用多个缓冲区。例如，在双缓冲时，有两个缓冲区：前缓冲区和后缓冲区。显示前缓冲区时，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在后方</font><font style="vertical-align: inherit;">进行记录</font><font style="vertical-align: inherit;">。然后他们改变位置，然后重复该过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32没有足够的RAM具有DMA功能来存储两个帧缓冲区（不幸的是，4 MB的外部SPI RAM没有DMA功能），因此此选项不适合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341具有一个信号（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font><font style="vertical-align: inherit;">该信号</font><font style="vertical-align: inherit;">可告诉您何时发生</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBLANK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><strong><font style="vertical-align: inherit;">以便</font></strong><font style="vertical-align: inherit;">我们可以在显示之前进行写入。但是使用Odroid（或显示模块）时，该信号未连接，因此我们无法访问它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许我们可以找到一个不错的值，但是现在我们不会这样做，因为现在我们的任务是简单地在屏幕上显示像素。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有源代码都可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid走示意图</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">去玩</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：SPI Master</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LCD驱动器数据表</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN502518/index.html">如何爬树</a></li>
<li><a href="../zh-CN502520/index.html">有关产品分析的mitap报告的视频报告</a></li>
<li><a href="../zh-CN502522/index.html">我们打开内部带有微小变压器的电流隔离芯片</a></li>
<li><a href="../zh-CN502524/index.html">Psychos创造文明</a></li>
<li><a href="../zh-CN502526/index.html">JUG Ru组＃2在线流周</a></li>
<li><a href="../zh-CN502532/index.html">IT部门（部门）的革命。有必要吗？</a></li>
<li><a href="../zh-CN502536/index.html">MIUI 12的第一印象和主要功能</a></li>
<li><a href="../zh-CN502538/index.html">如何构建旧版本的NGINX Ingress Controller并对其进行修补</a></li>
<li><a href="../zh-CN502540/index.html">Alpine.js-继续约会</a></li>
<li><a href="../zh-CN502542/index.html">我们如何教Yandex回答问题并每天为用户节省2万小时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>