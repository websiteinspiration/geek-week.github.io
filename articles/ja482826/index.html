<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏻 😾 💙 1997年のアーカイブから128バイトのデモを解析する 👨🏼‍🤝‍👨🏻 🏷️ 🔒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="特に遠い過去からの私の欲求を満たすことはとても楽しいです。あまりに遠くて、私は一度それが一度は欲しかったのを忘れていました。私はデモシーンについてはほとんど知りませんし、作者や彼らの作品をフォローしたことはありません。時々それを理解したかったのですが、知識と経験が足りず、後で忍耐力が足りなくなり、そ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>1997年のアーカイブから128バイトのデモを解析する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特に遠い過去からの私の欲求を満たすことはとても楽しいです。あまりに遠くて、私は一度それが一度は欲しかったのを忘れていました。私はデモシーンについてはほとんど知りませんし、作者や彼らの作品をフォローしたことはありません。時々それを理解したかったのですが、知識と経験が足りず、後で忍耐力が足りなくなり、それに対する興味が完全に失われました。しかし、最近、BBSとFidonetを使ってデモを含むすべての新製品を提供してくれた私の友人は、ほとんどすべての人に電話とモデムとコンピューターの両方を同時に持っていたため</font><font style="vertical-align: inherit;">、彼の作品</font><font style="vertical-align: inherit;">を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAFePARTY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に訪問</font><font style="vertical-align: inherit;">しました最初のコンピューターのアーカイブを開き、デモを選択してそれを理解しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の強みを客観的に評価し、視覚的に気に入った128バイトのイントロを取りました。</font><b><font style="vertical-align: inherit;">Mcm</font></b></font><code>pentagra.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって署名された</font><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">、128バイト、最終変更日1996年9月24日18：10：14、16進ダンプ：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42<br>
000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40<br>
000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03<br>
000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7<br>
000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab<br>
000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88<br>
000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c<br>
000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d<br>
</code><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じアーカイブから私は引き出しました：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hiew 6.11</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.50</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はサイトにあります</font><font style="vertical-align: inherit;">）-逆アセンブラーとして使用しました</font></font></li>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TASM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ</font><font style="vertical-align: inherit;">-受け取ったコードを収集して、何もごちゃごちゃにしていないことを確認しました</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flambeaux SoftwareのTECH Help！</font><font style="vertical-align: inherit;">6.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -DOS API、BIOS機能、ハードウェア、およびアセンブラについての適度に詳細で包括的なオンラインリファレンス</font></font></li>
<li><b> ..   IBM PC</b> —         Intel 8086     .       ,    .     ,          </li>
<li>   <b> .. Assembler.  DOS, Windows  Unix</b> —      DOS</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に最小限の実装から、トリックと非標準的なアプローチの使用を期待する必要がありますが、初期条件でのいくつかの仮定を除いて、技術的なトリックは見ませんでしたが、アルゴリズムのトリックを見ました。そして、ここでいくつかの言葉が経験について言われるべきです。何が難しいのでしょうか？実装またはアルゴリズムのいずれかで。たとえば、チーム</font></font><code>mov di, 099d1h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、魔法の定数が怖い場合があります。しかし、これを使用している場合は、これが画面座標XおよびYでのアクセス用のアドレスであることは明らかです。X= 17、Y = 123、320は、画面の水平解像度（ピクセル単位）です。これらを合わせると、17 + 123 * 320、つまり2次元座標から1次元への変換が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面で何が起こっているのかを見てみると、128バイトではありませんが、100％似ていなくても、これをどのように実装できるかは簡単に想像できますが、可能です。</font><font style="vertical-align: inherit;">そして、20年前はできませんでしたが、使用したすべてのツールをほこりっぽい棚から引き出し、インターネットを閲覧してその仕組みを理解する必要はありませんでした。</font><font style="vertical-align: inherit;">したがって、まず第一に、これはコンテキストであり、何が起こっているかについての理解であり、トリックの方法とこれを行う方法は2番目です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が見えますか：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">五芒星の5行。</font><font style="vertical-align: inherit;">すべてのカノンによると、これらは必ずしも直接不可分な線ではありません。</font><font style="vertical-align: inherit;">詳細はなく、一般的な図のみが表示されます</font></font></li>
<li> ,      :              ,        . ,            ,       «» ,     ,    ,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    DOOM</a>.          ,       </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように行われたかを理解する必要があります。</font><font style="vertical-align: inherit;">詳細な説明は、コンピュータアーキテクチャおよびDOSまたはアセンブラ機能に関する知識を置き換えるものではありませんが、この知識があれば、何が起こっているのかを理解し、その本質に集中することができます。</font><font style="vertical-align: inherit;">書き始めて、細かいところまで同じだと気づきましたが、話の意味で負けないように断りきれませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOSおよび.COMプログラムのロード</font></font></h3><br><font style="vertical-align: inherit;"></font><code>.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">
内のプログラム</font><font style="vertical-align: inherit;">はクリーンなコードで、ヘッダーはありません。適切な場所に配置するだけです。</font><font style="vertical-align: inherit;">これは、DOSまたはむしろ4Bhシステムコールによって行われます。</font><font style="vertical-align: inherit;">非常に多くのアクションがあります。結果について詳しく見てみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一の値がロードされたすべてのセグメントレジスタCS、DS、ES、SS</font></font></li>
<li>    65536 ,          .  256     — PSP (  ).   CS:0,   PSP,   INT 20h —        .      CS:100h    128 </li>
<li>    0000h,  SP  FFFEh.  ,          SS:FFFEh .       ,         CS:0</li>
<li> AL  AH              .       0,    FFh</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、レジスタのステータスは定義されていないと私は心から信じています。</font><font style="vertical-align: inherit;">しかし、分析したコードでは、私の意見では、特にCX、SIレジスタ、およびDF方向フラグについて、それらの初期状態について非常に大胆な仮定が行われています。</font><font style="vertical-align: inherit;">上記のソースのリストでこれを確認できなかったので、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS-DOS 2.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースを調べました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFについては、コマンドによってリセットされたと見なすことができます。</font></font><code>cld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後者は、制御を改行に移す前に順方向を使用するため、DFがリセットされるためです。</font></font><code>cld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場所での</font><font style="vertical-align: inherit;">明示的な使用はありません</font><font style="vertical-align: inherit;">が、方向フラグをクリアするコマンドは、他の多くの転送の前に頻繁に発生します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPコマンドカウンターによってレジスタに読み込まれるオフセットを決定するために使用されるため、SIには100hが含まれています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CXはFFhと同じです。これは、コマンドライン全体の内容を転送するための初期値80hのカウンターとして使用されるため、転送後は0になります。その後、一時変数としてのCLはFFhをロードし、ALおよびAHのドライブ文字のエラーフラグを設定するために使用されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいバージョンのソースはありませんが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOSBoxソース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number">0</span>;reg_cx=<span class="hljs-number">0xff</span>;<font></font>
reg_dx=pspseg;<font></font>
reg_si=RealOff(csip);<font></font>
reg_di=RealOff(sssp);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、MS-DOSソースコード（2番目のバージョン！）で見たものと一致します。他のレジスタの初期値も表示されます。ここでは、明示的な特別な初期化です。 MS-DOSの場合、AX、セグメント、スタック以外のレジスターの値は、他の目的での使用の基本であり、ドグマまたは標準ではないため、どこにも言及されていません。しかしその一方で、プログラマーが非常に慣れているために、形成されたエコシステムと古いバージョンとの互換性をサポートするMicrosoftの全体的な苦痛は少し理解できなくなり、ランダムに生成されたすべての値に沿ってドラッグすることを強いられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私たちにはこの知識で十分です。ヘッダーからプログラムを復元し始めます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">.186</span><font></font>
.model tiny<font></font>
.code<font></font>
.startup<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><code>outsb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このモデルでのみ表示される</font><font style="vertical-align: inherit;">
コマンドを使用しているため、プロセッサー80186のタイプを判別し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">1つのコードセグメントとプログラムへのエントリポイントは、メモリモデルの定義と共に</font></font><code>tiny</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイラが変数と遷移のすべてのオフセットを正しく計算できるようにします。</font><font style="vertical-align: inherit;">組み立てるとき</font></font><code>tlink</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、キーが使用さ</font></font><code>/t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ、出力では</font></font><code>.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">を提供し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフィックとパレット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフィックモードに切り替えるには、BIOS機能に切り替える必要があります。この場合、10h、AH = 0の割り込みが呼び出されます。ALには、目的のモードの識別子-13hを入れます。</font></font><br>
<br>
<pre><code class="cpp hljs">mov al, <span class="hljs-number">13</span>h ;b0 <span class="hljs-number">13</span>
<span class="hljs-keyword">int</span> <span class="hljs-number">10</span>h     ;cd <span class="hljs-number">10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのダウンロード条件により、ゼロがあると仮定して、AHには触れませんのでご注意ください。選択したモードは、256カラーパレットで320 x 200ピクセルのグラフィック解像度に対応します。画面にポイントを表示するには、メモリ領域に書き込む必要があります。メモリ領域は、色に対応するバイトであるアドレスA000h：0で始まります。セグメントデータレジスタに次の値を入力します。</font></font><br>
<br>
<pre><code class="cpp hljs">push <span class="hljs-number">0</span>a000h ;<span class="hljs-number">68</span> <span class="hljs-number">00</span> a0<font></font>
pop es      ;<span class="hljs-number">07</span>
push es     ;<span class="hljs-number">06</span>
pop ds      ;<span class="hljs-number">1f</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理的には、メモリは、画面座標が表示される2次元配列として編成されます。0：0は左上隅に対応します。モードを切り替えた後、デフォルトのパレットでは、ゼロ（黒）で塗りつぶされます。線形変位に変換するための式は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X + Y * Lです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここで、Lは水平解像度であり、この場合は320です。この形式では、定数が使用される場所に書き込みます。プログラムテキストを変換するとき、それらは自動的に計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パレットを変更するには、入力/出力ポートを使用して機器に直接アクセスします。</font></font><br>
<br>
<pre><code class="cpp hljs">lodsb         ;ac<font></font>
mov dx, <span class="hljs-number">03</span>c8h ;ba c8 <span class="hljs-number">03</span><font></font>
out dx, al    ;ee<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のコマンドは、DS：SIにあるデータバイトをALにロードします。 DSでは、ビデオメモリのセグメントアドレスをロードしており、SIでゼロで埋められていることがわかっています。一般的には、少なくとも0であることは不明です。SIが示す場所に関係なく、ほとんどの場合、占有するビデオメモリにアクセスします。この解像度では、320 * 200 = 64000バイト、ほぼセグメント全体です。したがって、このコマンドの後でAL = 0になると予想されます。単位はSIに加算または減算されます。これは、DF方向フラグの設定に依存します。これは私たちにとって特に重要ではありませんが、SIがどこに移動しても、ゼロで埋められたビデオメモリ領域に残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ポート番号03C8hのDXをロードします。この出力は、オーバーライドする256の色を決定します。この例では、ALから0です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
色はRGBパレットでエンコードされます。これを行うには、ポート03C9h（3C8hを1つ以上）に3回続けて、各コンポーネントに対して1回ずつ書き込む必要があります。コンポーネントの最大輝度は63、最小値は0です。</font></font><br>
<br>
<pre><code class="cpp hljs">inc dx         ;<span class="hljs-number">42</span>
mov cl, <span class="hljs-number">64</span>     ;b1 <span class="hljs-number">40</span><font></font>
<font></font>
PALETTE:<font></font>
    out dx, al ;ee<font></font>
    inc ax     ;<span class="hljs-number">40</span><font></font>
<font></font>
    outsb      ;<span class="hljs-number">6</span>e<font></font>
    outsb      ;<span class="hljs-number">6</span>e<font></font>
loop PALETTE   ;<span class="hljs-function">e2 <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-number">-6</span>)</span>,    6  
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DXを1増やして、目的のポート番号を持つようにします。 CLは64に等しいサイクルカウンターであり、初期負荷条件に基づいて前述したように、CH = 0であると想定しています。次に、最初のコンポーネントをポートに出力します。赤のコンポーネントは明るさにALに格納され、最初のステップ0で変化します。次に、その明るさを1増やして、次の反復で表示します。次に、</font></font><code>outsb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポートに書き込む</font><font style="vertical-align: inherit;">2つのコマンドを実行します。その</font><font style="vertical-align: inherit;">数はDX、つまりDS：SIメモリ領域からのバイトに含まれています。そこにゼロがあることに注意してください。毎回SIが1ずつ変化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのコンポーネントを推定するとすぐに、色番号に単位が自動的に追加されます。したがって、必要に応じて色が連続している場合、ポート3C8hに出力して色を再定義する必要はありません。チーム</font></font><code>loop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロ以外の値が取得された場合は、CXを1だけ減らし、サイクルの最初に進みます。0の場合は、サイクルの後の次のコマンドに進みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計64回の繰り返し。</font><font style="vertical-align: inherit;">繰り返しのたびに、0から63までの色について、現在の色番号と一致する明るさの赤い成分を決定します。</font><font style="vertical-align: inherit;">緑と青のコンポーネントをリセットして、そのようなパレットを赤の最小輝度から最大輝度まで取得します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="パレット"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期の色と座標値を設定します。</font></font><br>
<br>
<pre><code class="cpp hljs">LINES:<font></font>
mov ax, <span class="hljs-number">03f</span>3fh   ;b8 <span class="hljs-number">3f</span> <span class="hljs-number">3f</span><font></font>
<font></font>
mov bx, <span class="hljs-number">0</span>+<span class="hljs-number">1</span>*<span class="hljs-number">320</span>  ;bb <span class="hljs-number">40</span> <span class="hljs-number">01</span>
mov di, <span class="hljs-number">64</span>+<span class="hljs-number">4</span>*<span class="hljs-number">320</span> ;bf <span class="hljs-number">40</span> <span class="hljs-number">05</span>
push di          ;<span class="hljs-number">57</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ALおよびAHでは、可能な最大（明るい）色63（3Fh）をそれぞれロードします。AXは一度に2つのポイントを定義します。 BX-最大水平解像度。将来的には、これを使用して現在の座標から1行を加算または減算します。 DI-座標64：4、それらをスタックに保存します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左上隅から右端まで最初の線を引き</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs">mov cl, <span class="hljs-number">120</span>    ;b1 <span class="hljs-number">78</span><font></font>
LINE1:<font></font>
    stosw      ;ab<font></font>
    add di, bx ;<span class="hljs-number">03</span> fb<font></font>
loop LINE1     ;<span class="hljs-function">e2 <span class="hljs-title">fb</span><span class="hljs-params">(<span class="hljs-number">-5</span>)</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターを構成します-これは行数になります。次に、ワード（2バイト）をAXからアドレスES：DIに保存します。 ESはビデオメモリ用に構成されており、特定の座標はDIに設定されているため、このアクションにより、パレットの最大色で2つのドットが画面に表示されます。このアクションの後、2バイトが書き込まれたため、DIに2が追加されます。私たちは明らかにDF方向フラグを設定せず、それがリセットされているという事実に依存しています。ここでも、プログラムをロードするための初期条件を思い出します。そうしないと、2つが削除され、目的の線を描画できなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、DI = DI + BXです。これは、Y座標を1増やすことと同じです。したがって、サイクルの本体では、2つのポイントが1つの線で描画され、X座標が2増加し、Y座標が1増加し、このアクションが120回繰り返されます。結果の画像はわずかに低くなります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2行目は左上から上</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cpp hljs">pop di               ;<span class="hljs-number">5f</span>
mov cl, <span class="hljs-number">96</span>           ;b1 <span class="hljs-number">60</span><font></font>
LINE2:<font></font>
    mov [bx+di], al ;<span class="hljs-number">88</span> <span class="hljs-number">01</span><font></font>
    stosb            ;aa<font></font>
    add di, bx       ;<span class="hljs-number">03</span> fb<font></font>
    add di, bx       ;<span class="hljs-number">03</span> fb<font></font>
loop LINE2           ;<span class="hljs-function">e2 <span class="hljs-title">f7</span><span class="hljs-params">(<span class="hljs-number">-9</span>)</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期座標64：4を復元し、カウンターを96回の繰り返しに設定します。 1ポイントを印刷しますが、現在の座標の下に1行を印刷します。以前と同様に、これは、新しい座標を保存せずに、BXから値を追加することによって実現されます。</font><font style="vertical-align: inherit;">アドレッシングベースのインデックス作成を</font><font style="vertical-align: inherit;">設計</font></font><code>[bx+di]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font></font><code>[bx][di]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、トランスレータではなくプロセッサレベルで実行するように求めました。 BXのデフォルトのセグメントレジスタはDSです。その後、2番目の点を表示しますが、すでに現在の座標にあります。 1つのバイト転送コマンドのみが使用されるため、DI、したがってXは1ずつ増加し</font></font><code>stosb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。サイクル本体の最後の2つのコマンドは、Yの2の増加です。この場合も、BXを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2本の線を描いた後、左上隅近くに次の画像が表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="1、2行目"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオメモリのラインオフセットアドレスの右と左の座標。</font><font style="vertical-align: inherit;">ポイント64：4が2回描画されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3行目は、上から右上隅まで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cpp hljs">mov cl, <span class="hljs-number">97</span>          ;b1 <span class="hljs-number">61</span><font></font>
LINE3:<font></font>
    mov [bx+di], al ;<span class="hljs-number">88</span> <span class="hljs-number">01</span><font></font>
    stosb           ;aa<font></font>
    sub di, bx      ;<span class="hljs-number">2b</span> fb<font></font>
    sub di, bx      ;<span class="hljs-number">2b</span> fb<font></font>
loop LINE3          ;<span class="hljs-function">e2 <span class="hljs-title">f7</span><span class="hljs-params">(<span class="hljs-number">-9</span>)</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DIにはすでに必要な座標値160：196が含まれています。前の線が終了したところから上に線を引き、同じ角度を維持しながら画面を上に移動する必要があります。</font><font style="vertical-align: inherit;">したがって、サイクルはほぼ同じです。</font><font style="vertical-align: inherit;">現在のY座標は前のラインが終了した場所より2つ多い（低い）ため、CXは1だけ増加し、次の反復のためにすでに計算されています。</font><font style="vertical-align: inherit;">したがって、上隅に到達するには、追加の手順を実行する必要があります。</font><font style="vertical-align: inherit;">Xに沿った動きは同じ方向に続き、各反復の後に1つずつ、Yに沿って2つを追加するのではなく、それに沿って動きます。</font><font style="vertical-align: inherit;">ポイントは同じ順序で表示され、最初は下、次に上です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="3行目"></div><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4行目は、左端から右上隅です。</font></font></b><br>
<br>
<pre><code class="cpp hljs">mov di, <span class="hljs-number">17</span>+<span class="hljs-number">123</span>*<span class="hljs-number">320</span> ;bf d1 <span class="hljs-number">99</span>
push di            ;<span class="hljs-number">57</span><font></font>
<font></font>
mov cl, <span class="hljs-number">120</span>        ;b1 <span class="hljs-number">78</span><font></font>
LINE4:<font></font>
    stosw          ;ab<font></font>
    sub di, bx     ;<span class="hljs-number">2b</span> fb(<span class="hljs-number">-5</span>)<font></font>
loop LINE4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも必要な座標にいますが、DF方向フラグを変更しないために、これは使用されていません。</font><font style="vertical-align: inherit;">したがって、新しい座標がDIに配置され、スタックに格納されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、すべてが最初の線と同じで、Y座標のみが増加せず、減少し、上昇します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5行目は水平です。</font></font></b><br>
<br>
<pre><code class="cpp hljs">pop di      ;<span class="hljs-number">5f</span>
mov cl, <span class="hljs-number">143</span> ;b1 <span class="hljs-number">8f</span><font></font>
rep stosw   ;f3 ab<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてが単純です。水平線が次の各ポイントのアドレスの単純な増加に対応するため、マイクロプロセッサの再送信のメカニズムが使用されます。</font><font style="vertical-align: inherit;">DIでは、前の手順で保存された左端のコーナーの座標に対応するアドレスが復元されます。</font><font style="vertical-align: inherit;">CXの繰り返し数が設定され、繰り返し転送プレフィックスがword forwardingコマンドで適用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアクションの後、明るい色で完全に描かれた五芒星ができました。</font><font style="vertical-align: inherit;">80バイトが使用され、48バイトが予約されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">火の魔法</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算の境界条件を設定します。</font></font></b><br>
<br>
<pre><code class="cpp hljs">FLAME:<font></font>
cmp si, <span class="hljs-number">320</span>*<span class="hljs-number">200</span> ;<span class="hljs-number">81</span> fe <span class="hljs-number">00</span> fa<font></font>
jae NEXT_PIXEL  ;<span class="hljs-number">73</span> <span class="hljs-number">12</span><font></font>
<font></font>
lodsb           ;ac<font></font>
<span class="hljs-keyword">or</span> al,al        ;<span class="hljs-number">0</span>a c0<font></font>
jz NEXT_PIXEL   ;<span class="hljs-number">74</span> <span class="hljs-number">0</span>d
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIでは、計算の現在のポイントの座標が存在します。画面の境界を超えた場合、このポイントで計算を実行せず、次の計算に進みます。</font></font><br>
<br>
<code>lodsb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DS：SI領域からALにバイトをロードします。つまり、現在の座標のポイントの色です。 0の場合は、何もせずに次のポイントに進みます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい色の計算</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、画面上の色値を変更するための主要なアルゴリズムであり、まだ炎ではありません。それは、その基礎です。隣接する点を計算し、色の連続性を実現します。</font></font><br>
<br>
<pre><code class="cpp hljs">dec ax               ;<span class="hljs-number">48</span>
mov [si<span class="hljs-number">-2</span>], al       ;<span class="hljs-number">88</span> <span class="hljs-number">44</span> fe<font></font>
mov [si], al         ;<span class="hljs-number">88</span> <span class="hljs-number">04</span>
mov [bx+si<span class="hljs-number">-1</span>], al    ;<span class="hljs-number">88</span> <span class="hljs-number">40</span> ff<font></font>
mov [si<span class="hljs-number">-1</span><span class="hljs-number">-1</span>*<span class="hljs-number">320</span>], al ;<span class="hljs-number">88</span> <span class="hljs-number">84</span> bf fe
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の座標から取得されたゼロ以外の色値を含む単位であるAX、実際にはALから減算します。</font><font style="vertical-align: inherit;">次に、取得した値を、パレットに基づいて、現在の座標、つまりそれらの少しを基準にして、すべての隣接ポイントに書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後</font></font><code>lodsb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SI値が1増加し、ALで読み取った色のポイントに対応しなくなったため、これを調整する必要があります。</font><font style="vertical-align: inherit;">バイト転送コマンドは使用されなくなりましたが</font></font><code>stosb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、代わり</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、値が配置されるアドレスを特定するために</font><font style="vertical-align: inherit;">使用さ</font><font style="vertical-align: inherit;">れます。</font><font style="vertical-align: inherit;">現在の座標がX：Yであることを受け入れると、SI-1の場合：</font></font><br>
<br>
<ul>
<li><code>mov [si-2], al</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-現在の色の左側にあるポイントX-1：Yで新しい色を記録します。</font><font style="vertical-align: inherit;">上記の理由により、SIから2が差し引かれます。これは、余分なユニットがすでに追加されているためです。</font></font></li>
<li><code>mov [si], al</code> —      X+1:Y,   .  SI  X+1</li>
<li><code>mov [bx+si-1], al</code> —      X:Y+1,   .   BX  Y+1</li>
<li><code>mov [si-1-1*320], al</code> —      X:Y-1,   . BX    ,      ,         ,         </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セグメントレジスタはDSで、SIおよびBXでデフォルトで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイントが画面の端にぶつかったときにチェックされる状況はどこにもありません。私たちは常にビデオセグメントの境界内にいるため、これが失敗につながることはありません。隣接するポイントは、64,000を超えるアドレスを持つ未報告の領域または隣接するラインに該当する可能性があります。これは、詳細な説明からわかるように、害を及ぼすことはなく、少しでも役立ちます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ魔法、次の点の座標の計算</font></font></b><br>
<br>
<pre><code class="cpp hljs">NEXT_PIXEL:<font></font>
add si, dx ;<span class="hljs-number">03</span> f2<font></font>
inc dx     ;<span class="hljs-number">42</span>
jnz FLAME  ;<span class="hljs-number">75</span> e3(<span class="hljs-number">-29</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し前に戻りましょう。最初のSI値は特にどこにも設定していません。DXでは、パレットに使用した出力入力ポートの番号が残っています。私たちは3つの単純なアクションSI = SI + DXだけを実行します。明らかに、これは新しい座標を設定します。 DX = DX + 1で、DXが0に等しくない場合、隣接するポイントを取得および計算するための基本的なアルゴリズムに戻ります。つまり、DXはある種のカウンターですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのポイントを移動して、隣接するポイントの明るさの変化を計算する必要があることはわかっています。これを続けて行うと、おそらく静的な勾配が得られますが、均一ではないかもしれませんが、線の周りは変化しません。画面のサイズと移動に必要なポイントの数はわかっていますが、ここではほとんど無視しています。正確には、正確な64000ではなく、近い値65536を選択します。DXは実際にはカウンターであり、65536です。しかし、初期値が重要ではない理由と、最終的な値は画面上の合計ポイントよりも大きいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイントが一列に並んでいるわけではなく、すべてではないからです。後続の各線形座標は、前の座標よりもDXの値だけ大きくなります。つまり、SIでは、単純な算術的な進行のDX要素の合計：0、1、2、3、4、5、6、...、362、363、...、65535。これにより、すでに非線形性が得られます。SI= 0およびDX = 0で開始すると、SIでは次のようになります：0,1,3,4,6,10,15,21、...、65341,65703、...、 2147450880。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それだけではありません。SIの次元が16ビットであるため、65535より大きい値を取得できず、オーバーフローが発生し、SIの剰余は65536を法として残ります。線形座標計算式は、SI =（SI + DX）MOD 65536の形式になります。これは連続的な順序を完全に破ります：0、1、3、4、6、10、15、21、...、65341、167、530、894、...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、SIは初期化されていないことを思い出してください。つまり、次回このサイクルに戻るときは、0や特定の座標からではなく、中断した座標から開始します。これにより、シーケンスにカオスが追加されます-繰り返されない要素の数が長くなります。それ以外の場合、ポイントのトラバーサルは、非線形ではありますが、常に同じです。炎の効果は存在しますが、それほど明確ではありません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリックについて話すなら、これだけです。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DXは、最初の使用を除いて、常に、オーバーフローの結果として暗黙的に0から始まり</font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、SI&gt; = 64000の場合、ポイントが描画されず、出力シーケンスが少し混乱するため、境界値によって少しカオスが追加されます。ゼロの値を持つすべてのポイントをスキップすると、プログラムの最初の数秒で点火の効果が生じます。これは、ほとんどのポイントが処理されないため、完全なサイクルがより速く終了するためです。しかし最も重要なのは、ほとんどのポイントの明るさが増加するだけなので、それらは隣接する調光器セクションによって不明瞭になることはありません-それらはまだ存在せず、ゼロ値は計算されません。完全に黒い領域が消えた後、バランスが確立され、一部の領域は明るさが増加し、一部は減少します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、順序や勾配について話すことはできなくなり、ポイントは新しいシーケンスで毎回バイパスされます。これには、数回繰り返すか、完全にスキップすることが含まれます。</font><font style="vertical-align: inherit;">これにより、明るさが異なる領域が形成され、新しい反復ごとに変化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それだけではありません。新しい明るい点を追加しないと、最終的にはすべて消えます。</font><font style="vertical-align: inherit;">したがって、DXがその最大値に達した後、再び5つの明るい線を描き、画面上のすべてのポイントを数えます。</font></font><br>
<br>
<pre><code class="cpp hljs">in al, <span class="hljs-number">60</span>h  ;e4 <span class="hljs-number">60</span>
cmp al, <span class="hljs-number">01</span>h ;<span class="hljs-number">3</span>c <span class="hljs-number">01</span><font></font>
<font></font>
jne LINES   ;<span class="hljs-number">75</span> a5(<span class="hljs-number">-91</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかしその前に、ポート60hから読み取ります。これはキーボードであり、最後に押されたキーのスキャンコードです。</font><font style="vertical-align: inherit;">ESCの場合は1になります。もしそうであれば、ESCキーが押された場合、出口に向かって移動します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらく時間がかかる現在の画面の更新中は、プログラムを終了できません。つまり、ESCへの反応が遅くなることに注意してください。待機中およびESCの後に何らかのキーが押された場合、プログラムに残り、最後のスキャンコードのみをポートから読み取ることができます。さらに、DOSやBIOSシステムの機能を置き換えたり使用したりすることはありません。ポートから読み取った内容に関係なく、押されたキーは循環バッファーに配置され、イントロが完了した後、次のプログラムによっておそらくそこから読み取られます。マネージャーまたは</font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは処理につながります。たとえば、ESCのVolkov Commanderはパネルを非表示にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テキストモード3に戻ります。</font></font><br>
<br>
<pre><code class="cpp hljs">mov ax, <span class="hljs-number">03</span>h ;b8 <span class="hljs-number">03</span> <span class="hljs-number">00</span>
<span class="hljs-keyword">int</span> <span class="hljs-number">10</span>h     ;cd <span class="hljs-number">10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの起動前はこのモードであったと想定されていますが、一般的にはそうではない場合があります。</font><font style="vertical-align: inherit;">ここでは、AHに0が含まれていないことが確実であるため、AX全体を更新し</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。これで終了できます。</font></font><br>
<br>
<pre><code class="cpp hljs">retn ;c3
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、そこに置かれたワードの値（2バイト）をスタックから取得し、それをIPコマンドカウンターにロードするプロシージャからのニアエグジットコマンドです。</font><font style="vertical-align: inherit;">初期状態によると、スタックにはゼロがあります。これにより、CS：0アドレスに移動します。ここには、コマンドコードが配置されていることがわかっています</font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-シャットダウン。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして著作権のための7バイト：</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-number">0</span>h    ;<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
db <span class="hljs-string">'Mcm'</span> ;<span class="hljs-number">4</span>d <span class="hljs-number">63</span> <span class="hljs-number">6</span>d<font></font>
end<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はまだより厳密な初期化に費やす場所があると言えますが、すべてが最新のDOSBoxで機能するので、作者はおそらくすべてを正しく行いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度見てみましょう：</font></font><br>
<br>
<ol>
<li>   ,       </li>
<li> 4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,         </li>
<li>      SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         — <code>add si, dx</code>  <code>inc dx</code>,            ,      </li>
<li>    ESC  ,          </li>
</ol><br>
<div class="spoiler"><b class="spoiler_title">  .</b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-number">.186</span><font></font>
.model tiny<font></font>
.code<font></font>
.startup<font></font>
<font></font>
        mov al, <span class="hljs-number">13</span>h
        <span class="hljs-keyword">int</span> <span class="hljs-number">10</span>h<font></font>
<font></font>
        push <span class="hljs-number">0</span>a000h<font></font>
        pop es<font></font>
        push es<font></font>
        pop ds<font></font>
<font></font>
        lodsb<font></font>
        mov dx, <span class="hljs-number">03</span>c8h<font></font>
        out dx, al<font></font>
<font></font>
        inc dx<font></font>
        mov cl, <span class="hljs-number">040</span>h<font></font>
<font></font>
PALETTE:<font></font>
        out dx, al<font></font>
        inc ax<font></font>
<font></font>
        outsb<font></font>
        outsb<font></font>
        loop PALETTE<font></font>
<font></font>
LINES:<font></font>
        mov ax, <span class="hljs-number">03f</span>3fh<font></font>
<font></font>
        mov bx, <span class="hljs-number">0</span>+<span class="hljs-number">1</span>*<span class="hljs-number">320</span>
        mov di, <span class="hljs-number">64</span>+<span class="hljs-number">4</span>*<span class="hljs-number">320</span><font></font>
        push di<font></font>
<font></font>
        mov cl, <span class="hljs-number">120</span><font></font>
LINE1:<font></font>
        stosw<font></font>
        add di, bx<font></font>
        loop LINE1<font></font>
<font></font>
        pop di<font></font>
        mov cl, <span class="hljs-number">96</span><font></font>
LINE2:<font></font>
        mov [bx+di], al<font></font>
        stosb<font></font>
        add di, bx<font></font>
        add di, bx<font></font>
        loop LINE2<font></font>
<font></font>
        mov cl, <span class="hljs-number">97</span><font></font>
LINE3:<font></font>
        mov [bx+di], al<font></font>
        stosb<font></font>
        sub di, bx<font></font>
        sub di, bx<font></font>
        loop LINE3<font></font>
<font></font>
        mov di, <span class="hljs-number">17</span>+<span class="hljs-number">123</span>*<span class="hljs-number">320</span><font></font>
        push di<font></font>
<font></font>
        mov cl, <span class="hljs-number">120</span><font></font>
LINE4:<font></font>
        stosw<font></font>
        sub di, bx<font></font>
        loop LINE4<font></font>
<font></font>
        pop di<font></font>
        mov cl, <span class="hljs-number">143</span><font></font>
        rep stosw<font></font>
<font></font>
FLAME:<font></font>
        cmp si, <span class="hljs-number">320</span>*<span class="hljs-number">200</span><font></font>
        jae NEXT_PIXEL<font></font>
<font></font>
        lodsb<font></font>
        <span class="hljs-keyword">or</span> al,al<font></font>
        jz NEXT_PIXEL<font></font>
<font></font>
        dec ax<font></font>
        mov [si<span class="hljs-number">-2</span>], al<font></font>
        mov [si], al<font></font>
        mov [bx+si<span class="hljs-number">-1</span>], al<font></font>
        mov [si<span class="hljs-number">-1</span><span class="hljs-number">-1</span>*<span class="hljs-number">320</span>], al<font></font>
<font></font>
NEXT_PIXEL:<font></font>
        add si, dx<font></font>
        inc dx<font></font>
        jnz FLAME<font></font>
<font></font>
        in al, <span class="hljs-number">60</span>h<font></font>
        cmp al, <span class="hljs-number">01</span>h<font></font>
        jne LINES<font></font>
<font></font>
        mov ax, <span class="hljs-number">03</span>h
        <span class="hljs-keyword">int</span> <span class="hljs-number">10</span>h<font></font>
<font></font>
        retn<font></font>
<font></font>
        dd <span class="hljs-number">0</span>h<font></font>
        db <span class="hljs-string">'Mcm'</span>
end</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルするには、以下を実行する必要が</font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのように、どのように実装されたのかが明確になったかどうかはわかりませんが、炎のエフェクトを作成するために美しくて珍しいアプローチが使用されたようです。</font><font style="vertical-align: inherit;">私は比較するものは何もありませんが、多分誰もがそれをしました、そして今、あなたは同じことをすることができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482814/index.html">ツリーの一般的なビュー、実装だけでなく</a></li>
<li><a href="../ja482816/index.html">アーサー・カチュヤン：マーケティングにおける人工知能</a></li>
<li><a href="../ja482818/index.html">Infostart 2019の1C DSSに関するレポートを読んだ簡単な結果</a></li>
<li><a href="../ja482820/index.html">画像アップロードの最適化</a></li>
<li><a href="../ja482822/index.html">ゲームのアートテストはどのように行われますか</a></li>
<li><a href="../ja482832/index.html">物理学者のための将来の経済学</a></li>
<li><a href="../ja482834/index.html">静的型付けは必ずしも式を必要としない</a></li>
<li><a href="../ja482838/index.html">ONYX BOOX Note 2のレビュー-最大の機能を備えた大画面リーダー</a></li>
<li><a href="../ja482840/index.html">2クリックでUTorrentの順次ダウンロード</a></li>
<li><a href="../ja482842/index.html">マッシュはそれ自体をコンパイルするプログラミング言語です</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>