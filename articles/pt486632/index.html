<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎋 ™️ 🗿 Modelos de programação reativa mental para supervisores 🎠 🚾 🏂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo é destinado a uma ampla gama de leitores que desejam saber o que é Programação Reativa. O objetivo deste artigo é formar seus modelos ment...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Modelos de programação reativa mental para supervisores</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo é destinado a uma ampla gama de leitores que desejam saber o que é Programação Reativa. </font><font style="vertical-align: inherit;">O objetivo deste artigo é formar seus modelos mentais básicos de programação reativa (MM RP) sem precisar de detalhes técnicos.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aviso Legal</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas primeiro, vamos explicar o que os modelos mentais e superiores mencionados no cabeçalho do artigo têm a ver com isso ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre modelos mentais</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E aqui estão os chefes ...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a Programação Reativa precisa do seu projeto?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas pessoas que não estão familiarizadas com RP são inicialmente céticas em relação a ele, suspeitando que essa seja apenas outra moda vazia, coberta por algumas palavras bonitas. </font><font style="vertical-align: inherit;">Especialmente quando eles aprendem que você pode avaliar o PR apenas tentando. </font><font style="vertical-align: inherit;">E tentar é caro, por causa do alto limite de entrada. </font><font style="vertical-align: inherit;">Vivemos e vivemos com OOP, o que está faltando? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me apresentar meu ponto de vista sobre esse assunto.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No início da programação, quando a maioria dos programas era escrita diretamente em linguagem assembly, o principal conceito de trabalho (um elemento do modelo mental) dos programadores era uma instrução ou comando de linguagem. Alguns dados (primitivos) são alimentados na entrada de um comando ou instrução. A instrução processa e emite alguns dados de saída. O surgimento das primeiras linguagens de programação procedurais, como Fortran, não mudou a essência da questão. Apenas os dados e as operações executadas (como uma sequência de comandos elementares) se tornaram mais complicados. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o tempo, ficou claro que esse conceito não é muito consistente com as realidades do mundo. Pode haver muitos dados, eles podem ser difíceis de estruturar. Seria bom dividir os dados e a funcionalidade em torno deles, dividir em partes, desenvolver e manter separadamente e usar juntos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP resolveu esses problemas de várias maneiras. A unidade do Modelo Mental de um programador típico de POO é um objeto com dados ocultos (encapsulados) e uma interface de acesso a esses dados como um conjunto de funções. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP teve um papel enorme na automação e informatização de muitos processos de fabricação e outros. E junto com isso, suas fraquezas foram expostas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, no POO não existe um conceito de processo como tal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles tentaram melhorar a situação de maneiras diferentes, concentrando-se em vários aspectos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, nasceram a programação orientada a eventos [3], a programação de fluxo de dados [4], o processamento de fluxo [5] e vários outros paradigmas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atrevo-me a suscitar uma série de críticas dos adeptos e especialistas sobre esses paradigmas, tentando transmitir em palavras simples sua essência geral.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De uma forma ou de outra, esses paradigmas operam com fluxos de informação. Ao mesmo tempo, a Programação Orientada a Eventos, como o nome sugere, concentra-se no processo de emergência de elementos de fluxo de informações, programação de Fluxo de Dados - no controle de fluxo (divisão, fusão, transformação de fluxos) e processamento de Fluxo no uso ideal de recursos ao processar fluxos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A programação reativa é praticamente a mesma coisa, mas com foco nas operações elementares específicas de criação, gerenciamento e uso de threads. Essa. O RP descreve como o sistema reage (inglês reage) a elementos do fluxo de informações. Nesse sentido, seria mais correto em russo usar o termo "Programação de reagentes" (da palavra "reagir") ou "Programação de reação" (da palavra "reação a alguma coisa") se não fosse para o ouvido cortar, e o segundo não causou associações incorretas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atrevo-me a expressar outro pensamento sedicioso. O que chamamos hoje em inglês de Programação Reativa (Programação Reativa). apelou por razões históricas e inclinou-se a favor deste termo a opinião da maioria.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse paradigma poderia ter sido chamado de maneira diferente. </font><font style="vertical-align: inherit;">Portanto, não se concentre em seu nome atual, mas tente entender sua essência. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, embora eu fale sobre RP em um nível bastante abstrato, citarei as APIs da biblioteca RxJS como exemplos concretos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O acrônimo RxJS significa Extensão Reativa para JavaScript, uma extensão JavaScript para os recursos de Programação Reativa. </font><font style="vertical-align: inherit;">Existem extensões similares para muitas outras linguagens de programação, como pode ser visto na figura abaixo, tirada de [6].</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Extensões de programação reativa"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que os modelos mentais de RP precisam do seu projeto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grandes projetos não são feitos sozinhos. Muitas vezes, você pode ler ou ouvir que os participantes do projeto devem falar o mesmo idioma. Minha experiência mostra que isso é quase necessário e possível. Mas o que é necessário é que os conceitos mais básicos do projeto sejam declarados e entendidos pelos participantes do projeto da maneira mais igual possível. Em termos de modelos mentais (MM), podemos dizer que os MMs de nível superior devem ser o mais semelhante possível. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas como eles podem ser semelhantes se os analistas pensam em termos de fluxo de trabalho e casos de uso, arquitetos em padrões, desenvolvedores em funções e estruturas de dados e testadores em cenários de teste?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não exorto todos esses especialistas a começarem a pensar ao mesmo tempo com as categorias de Programação Reativa, mas posso prometer a eles que o conhecimento dessas categorias simplificará e aumentará a eficácia de sua comunicação profissional com os colegas. </font><font style="vertical-align: inherit;">Isso deve acontecer porque, por um lado, os MM RPs têm o poder necessário para descrever fluxos de trabalho complexos e, por outro lado, os MM RPs podem ser convertidos diretamente em código em muitas linguagens de programação.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surpresas, perigos ou que em RP não é o modo como estamos acostumados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas antes de entrarmos na descrição do que consistem os Modelos Mentais de Programação Reativa, com base em nossa própria experiência, gostaria de alertar o leitor sobre o que não existe neles. </font><font style="vertical-align: inherit;">Além disso, não apenas não, mas a própria expectativa de um comportamento POO simples e compreensível no mundo leva a tristes conseqüências. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estou fazendo isso não para intimidar, mas para intrigar o leitor.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferença 1: em vez de um modelo de cursor, um gráfico computacional</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atrevo-me a sugerir que muitos leitores, ao pensarem na próxima tarefa a ser realizada, tenham um modelo mental na cabeça, que chamo de modelo de cursor. </font><font style="vertical-align: inherit;">Ele pressupõe que um algoritmo passo a passo na forma de uma lista linear de instruções será inventado para resolver o problema. </font><font style="vertical-align: inherit;">A execução do algoritmo é reduzida à execução passo a passo das instruções, uma após a outra. </font><font style="vertical-align: inherit;">Você pode imaginar algo como um ponteiro para a instrução em execução no momento. </font><font style="vertical-align: inherit;">Depois que a instrução é executada, o ponteiro (cursor) passa para a próxima instrução na lista e começa a executar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse modelo, uma sequência de comandos escritos em uma linguagem de programação condicional orientada a objetos</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vai dar o resultado</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso modelo mental do cursor prediz e explica perfeitamente esse resultado. </font><font style="vertical-align: inherit;">Após o processamento da terceira linha, o valor X3 é definido e o novo valor para X1 especificado na linha 5 não pode alterá-lo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No mundo do RP, dependendo da interpretação da operação “+”, o resultado provavelmente será esse</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste mundo, a maioria das operações conecta parâmetros de entrada entre si, criando gráficos computacionais através dos quais os cálculos são "enviados" quando um ou mais parâmetros são alterados.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferença 2: Operações assíncronas</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na estrutura do modelo mental de cálculos do cursor, a próxima operação não pode começar mais cedo que a anterior. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere o seguinte exemplo. </font><font style="vertical-align: inherit;">Suponha que a função f1 calcule o salário base pelo valor do identificador de usuário userId, e a função f2 calcule o bônus com base no userId e no valor do salário. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, o cálculo do salário total pode ficar assim</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que um membro da equipe tenha um salário base de 10.000. </font><font style="vertical-align: inherit;">e um bônus de 1000 unidades. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso modelo mental do cursor indica o que imprimir.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, no mundo da RP assíncrona, o resultado pode, dependendo da duração das operações, ser</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ainda não considero exceções). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O fato é que, no mundo reativo assíncrono, a próxima operação não espera o fim da anterior, se for a anterior) assíncrona. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ilustrar isso, vejamos alguns detalhes importantes usando o exemplo realista mostrado na figura abaixo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A imagem mostra o tempo de execução de quatro instruções L1, L2, L3 e L4 que são independentes uma da outra (seus números são importantes para nós, não a ortografia) nos modos síncrono (parte superior da imagem) e assíncrono (parte inferior da imagem).</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vemos, no primeiro caso, cada instrução subsequente "espera" pelo final da instrução anterior. </font><font style="vertical-align: inherit;">No caso assíncrono, todas as instruções começam a ser executadas simultaneamente. </font><font style="vertical-align: inherit;">Devido à execução paralela e ao uso de recursos, a maioria das instruções é executada no modo assíncrono por mais tempo que no modo síncrono. </font><font style="vertical-align: inherit;">No entanto, juntos eles deixarão seu trabalho mais cedo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ordem de conclusão das instruções nos dois modos também é muito diferente. </font><font style="vertical-align: inherit;">Em sincronia:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mas em assíncrono: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferença 3: cadeias incompletas (sem consumidor) nem funcionam</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em muitas linguagens de programação tradicionais, é comum associar chamadas de função ou propriedades de objetos a pontos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, a seguinte cadeia de chamadas de função JavaScript transforma a palavra "good" em "dog":</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sequências (cadeias) podem ser longas. </font><font style="vertical-align: inherit;">Por motivos de reutilização ou conveniência, eles podem ser cortados em pedaços e parcialmente executados. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividir uma cadeia no RP em duas partes e chamar apenas uma delas geralmente leva a uma falta de resultado, uma vez que apenas a cadeia completa (com o consumidor no final) é executada.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que tudo isso?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provavelmente, muitos leitores já estão se perguntando: “Eles não enlouqueceram coletivamente, esses programadores reativos? Por que é necessário, essa programação? ” </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não presumo prever o que os criadores e especialistas da República da Polônia responderiam a essa pergunta, mas minha resposta é a seguinte: essa programação é necessária, porque muitos objetos do mundo real se comportam exatamente assim. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gráficos de computação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - é nisso que o Excel se baseia, do qual não apenas os contadores, mas também os gerentes de projeto estão satisfeitos. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operações assíncronas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Quando você faz café ou faz chá na sua cozinha, fica na cozinha todo esse tempo e olha para a sua cafeteira ou bule de chá? Não. O dispositivo ferve a água e faz seu trabalho, enquanto você está fazendo outra coisa por enquanto. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cadeia completa de operações.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente desconectar a lâmpada da mesa da tomada e pressionar o interruptor. </font><font style="vertical-align: inherit;">A lâmpada não acende com isso. </font><font style="vertical-align: inherit;">Esse objeto funciona apenas se houver uma cadeia completa - da fonte ao consumidor de eletricidade. </font><font style="vertical-align: inherit;">E existem muitos, se não a maioria, desses objetos no mundo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero garantir, que seu conhecimento da programação tradicional e do cursor MM não deve ser jogado no lixo devido ao surgimento do RP. </font><font style="vertical-align: inherit;">A programação reativa os deixou em paz e os expandiu com novas operações em novos tipos de objetos. </font><font style="vertical-align: inherit;">Como - falaremos sobre isso mais tarde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O espaço da programação de modelos mentais e o lugar do MM RP nele</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Falando sobre o lugar da RP no cenário geral da programação, os autores costumam mencionar duas dimensões - a complexidade dos objetos processados ​​e o sincronismo / assincronia das operações. </font><font style="vertical-align: inherit;">Um exemplo dessa classificação pode ser encontrado no livro “RxJS in Action” [7], no capítulo “Quando e onde usar o RxJS”. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta classificação, a dimensão dos objetos é dividida em objetos únicos e multi-objetos: matrizes, listas, etc. </font><font style="vertical-align: inherit;">As operações são divididas em síncronas e assíncronas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, essa classificação divide o mundo da programação em quatro áreas. </font><font style="vertical-align: inherit;">O RP é uma dessas áreas responsáveis ​​pelo processamento de vários objetos com operações assíncronas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acho essa classificação muito interessante, mas gostaria de analisá-la do ponto de vista dos modelos mentais. </font><font style="vertical-align: inherit;">A tabela abaixo os apresenta.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos e valores únicos</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supomos que os modelos mentais de instruções e o cursor não exijam mais explicações. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ciclo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma extensão das instruções MM e do cursor devido às instruções adicionais do ciclo ou retorna a algum ponto. Isso permite que um conjunto de instruções de processamento para um único objeto seja "encapsulado" em um loop e, assim, processe muitos desses objetos. Nesse caso, o cursor se move dentro do ciclo como no modelo anterior e, atingindo o ponto de transição, salta para o início ou o processamento do ciclo para se todos os objetos forem processados. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jato.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A diferença entre esse modelo mental e o anterior é que o cursor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
apontando para o objeto processado permanece no lugar e os próprios objetos o "atropelam".</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos isso com dois exemplos. Se você pintar uma cerca de madeira, por analogia com o modelo do cursor, vá de placa em placa. Mas o trabalhador no transportador permanece no local e, por analogia com o modelo de jato, as peças a serem processadas se aproximam dele. Esses objetos são frequentemente referidos pelo termo English Stream, por exemplo, na linguagem Java. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semáforo.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este MM é mais fácil de associar a um semáforo em um cruzamento. Objetos assíncronos pesquisam periodicamente o estado de uma variável pública e executam determinadas ações após alterar seu estado. (como motoristas na frente de um semáforo) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aguardando.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma metáfora adequada para esse Modelo de Expectativa Mental é a carta em papel ou Emall que você esperava na última vez que conseguiu seu emprego. Pode haver uma resposta positiva ou negativa. Seu comportamento depois de receber a carta depende muito do conteúdo. O termo em inglês Promise é frequentemente usado para descrever esses tipos de objetos. Que, do ponto de vista do usuário, é uma expectativa, para o contratado que presta os serviços, é uma promessa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vemos na descrição, o movimento ao longo de cada dimensão (de cima para baixo ou da direita para a esquerda na tabela) significa uma mudança qualitativa no Modelo Mental.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como pode ser visto na tabela, os jatos e as expectativas são vizinhos à esquerda e no topo da célula do sudeste que nos interessa. </font><font style="vertical-align: inherit;">O que há de novo nos modelos mentais de fluxos que habitam a célula de interesse para nós em comparação a eles?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual é a extensão?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A expansão do Streams em comparação com as Expectativas é que as informações esperadas podem chegar não uma vez, mas em muitas partes. Nesse caso, o processo pode terminar sem terminar. Essa. após uma série de porções bem-sucedidas, receberemos uma notificação de erro. Além disso, outra versão das informações é adicionada - uma notificação do final do processo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa, por exemplo, que é possível receber várias (mas não todas) partes das informações esperadas e (sem uma mensagem de erro) uma mensagem sobre o final do processamento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se novamente, com Aguardando, temos apenas duas opções alternativas para as informações resultantes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Mental Jet Model é adequado para compreender, discutir e implementar o processo de transformação de uma sequência de objetos do mesmo tipo. O MM Stream o expande com os seguintes aspectos:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode haver muitos jatos e podemos fundi-los</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os jatos podem ser heterogêneos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos dividir os jatos em novos de acordo com diferentes critérios</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos "fechar" e / ou transformá-los em novos dentro da estrutura de um fluxo. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, determinamos o lugar do MM RP (Streams) no espaço ou paisagem dos objetos de Programação. </font><font style="vertical-align: inherit;">Vamos agora abaixar a vista aérea e dar uma olhada em Streams e seus modelos mentais.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluxos e fases do seu ciclo de vida</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como primeira aproximação, os fluxos de RP podem ser imaginados como fluxos de água em tubulações de água ou fluxos de eletricidade. </font><font style="vertical-align: inherit;">Deve-se lembrar que, como qualquer outra analogia, essa analogia tem seus limites e nem sempre é aplicável. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Falando sobre o fluxo, podemos destacar os seguintes aspectos importantes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada segmento de alguma forma surge</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele está de alguma forma se movendo em direção ao consumidor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo acontece no caminho com ele (ele se transforma)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode ser dividido em vários fluxos ou mesclado com outros fluxos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O consumidor de alguma forma usa o fluxo, deixando de existir.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os aspectos listados são simultaneamente fases do ciclo de vida de elementos individuais do fluxo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos considerá-los com mais detalhes usando o exemplo de funções RxJS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criação de thread</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os fluxos podem ser criados a partir de elementos passivos, como uma matriz ou uma lista de objetos em seu programa, bytes, linhas de arquivo etc. Esse tipo de fonte de fluxo é chamado frio (embora tecnicamente exista uma definição mais precisa de fontes de fluxo frio). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As chamadas fontes termais "vivem suas próprias vidas" e, se você não se conectar a elas a tempo, as informações serão perdidas. Esta categoria inclui informações sobre ações do usuário em um computador, tablet, smartphone, por exemplo, informações sobre pressionamentos de teclas, movimentos do mouse ou toque na tela. Também nesta categoria estão os dados solicitados por vários protocolos, como HTTP, dados de vários sensores.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note-se que existem as chamadas fontes “quentes”. </font><font style="vertical-align: inherit;">Além disso, algumas fontes “quentes” podem ser “resfriadas” e “frias” podem ser “aquecidas”. </font><font style="vertical-align: inherit;">Mas você deve ler sobre isso na literatura especial, por exemplo, no livro [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É importante que saibamos que todas as operações de criação de fluxos criam objetos do mesmo tipo, que podem ser processados ​​pelas mesmas operações, independentemente do conteúdo. </font><font style="vertical-align: inherit;">Neste artigo, chamamos esses objetos de fluxos. </font><font style="vertical-align: inherit;">O nome em inglês correspondente é Observável.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimento do consumidor e transformação de fluxo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As operações de transformação de fluxo podem ser realizadas tanto no caminho para o consumidor quanto por ele mesmo. </font><font style="vertical-align: inherit;">Em ambos os casos, as operações de processamento dos elementos de fluxo são estritamente sequenciais, isto é, </font><font style="vertical-align: inherit;">a próxima operação é lançada estritamente somente depois que a anterior foi concluída e passou seu resultado para ela. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diferentemente do Stream, que em algumas linguagens de programação são construções de linguagem com sintaxe e semântica próprias, extensões reativas como RxJS em JavaScript são forçadas a usar a sintaxe e a semântica básica de uma linguagem extensível. </font><font style="vertical-align: inherit;">Portanto, o RxJs implementa a função pipe (), na qual você pode fazer chamadas para funções - manipuladores do próprio fluxo e de seus elementos individuais. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É importante observar que apenas funções especiais, canalizáveis, podem ser manipuladoras de fluxo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Fluxo trifásico"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se continuarmos a analogia com a eletricidade, os fluxos que estamos considerando podem ser chamados de trifásicos. Juntamente com o "fio normal" que transmite as informações básicas, há também um "fio de erro" e um "fio de terminação de fluxo". As operações de transformação permitem não apenas alterar o objeto, mas também redirecioná-lo para outro "fio". Essa técnica é usada, por exemplo, ao processar erros alegados ao trabalhar com servidores usando o protocolo HTTP. Por exemplo, se um servidor não responder, você pode tentar solicitar outro sem informar o usuário sobre a falha ao solicitar o primeiro servidor.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este é outro elemento muito importante do seu modelo de fluxo mental. </font><font style="vertical-align: inherit;">Se nos paradigmas de programação tradicionais o erro é retornado da função de processamento como um código de erro ou deve ser interceptado como uma interrupção (exceção), nos fluxos o erro "flui" independentemente do canal principal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lá pode ser processado. </font><font style="vertical-align: inherit;">Por exemplo, se um usuário digitou uma senha incorreta, ele pode ter uma oportunidade adicional de tentar digitá-la uma ou mais vezes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dividindo e mesclando fluxos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A divisão dos fluxos é realizada em duas etapas. No primeiro estágio, os threads vazios são iniciados. Em seguida, no segundo estágio (estágio de processamento do fluxo), em uma das funções de processamento, os elementos serão analisados ​​e redirecionados para o fluxo desejado. Tecnicamente, existem muitas opções de como fazer isso. Por exemplo, removendo-o do encadeamento atual ou clonando-o antes de iniciá-lo em um novo encadeamento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode mesclar vários fluxos em um em um número surpreendentemente grande de maneiras. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As maneiras mais simples que vêm à mente são mesclá-las na ordem de recebimento, ou primeiro todas do primeiro fluxo e depois todas do segundo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O método mostrado abaixo na figura permite que um dos dois fluxos forme um contendo pares ordenados de objetos dos primeiro e segundo fluxos. </font><font style="vertical-align: inherit;">Nesse caso, um novo par é formado se um novo elemento aparecer em um dos fluxos. </font><font style="vertical-align: inherit;">A contém um par estritamente dos últimos elementos de cada fluxo. </font><font style="vertical-align: inherit;">Isso leva ao fato de que o mesmo elemento pode ser incluído em vários pares. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A notação gráfica usada neste exemplo é chamada de diagramas de mármore e é muito eficaz para explicar a semântica da divisão e mesclagem de fluxos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se este tópico lhe interessar, recomendo que você estude as operações e seus diagramas de Marble no recurso [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando fluxos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar os elementos do fluxo, o usuário ou cliente deve primeiro se inscrever nele. Como regra, no final do processamento, ele deve cancelar sua inscrição, pois os coletores de lixo nem sempre podem desativar automaticamente uma assinatura quando tentam utilizar um assinante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitos clientes podem se inscrever em um thread. Nos RxJs, a função de assinatura é chamada subscribe (). Nele, na maioria dos casos, é aconselhável fazer chamadas de processamento dos elementos "normais" do fluxo, um manipulador de erros e (relativamente raramente) um manipulador de terminação de fluxo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada um dos assinantes do fluxo recebe sua cópia do elemento ou um clone do elemento original. </font><font style="vertical-align: inherit;">Para não causar problemas, o fluxo é implementado de forma que os elementos recebidos para processamento se tornem imutáveis. </font><font style="vertical-align: inherit;">Em algumas situações, essa limitação ainda pode ser contornada, mas é melhor não.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encanto perigoso dos córregos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os fluxos são objetos muito complicados, um pouco parecidos com as integrais da matemática. Uma coisa é saber que elas existem e até mesmo imaginar o que é, e outra é poder usá-las. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compreender a lógica interna de seu funcionamento, necessária para aplicá-las bem na prática, requer considerável esforço intelectual. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os fluxos estão intimamente relacionados à programação funcional. Para o uso competente de fluxos, é útil entender como é possível criar e aplicar funções de segunda ordem - funções para as quais outras funções servem como argumentos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então a beleza e a elegância dos fluxos serão totalmente reveladas a você. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os fluxos são contagiosos. Depois de compreender a beleza deles, quero usá-los em todas as tarefas, o que obviamente não é necessário.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em que tarefas é aconselhável usar fluxos e onde os métodos tradicionais devem ser usados, todos decidem por si mesmos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, tentei falar sobre os Modelos Mentais de Programação Reativa (MM RP) e até mesmo colocá-los parcialmente em sua Consciência. </font><font style="vertical-align: inherit;">Vamos repetir os pontos principais novamente.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os MM RP são especiais, não semelhantes aos modelos mentais da programação tradicional. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao iniciar a Programação Reativa, devemos lembrar que alguns bem estabelecidos em outras áreas do MM, como o cursor, cadeias de chamadas ou loops, não funcionam, ou não funcionam assim.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O principal modelo mental de RP é um "fluxo de três canais" com um canal para elementos "normais", erros e informações sobre o final do fluxo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os fluxos podem ser finitos e infinitos.</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você está interessado neste tópico, pode "brincar" com fluxos usando os simuladores disponíveis no site [8]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você quiser entender melhor os conceitos de RP, recomendo que você trabalhe no livro [7] e, é claro, se familiarize com o Manifesto Reativo [11]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você alcançará o próximo nível na formação de seu próprio MM RP trabalhando nos livros [9] e [10] sobre o design e modelagem de sistemas reativos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatura e referências</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programação é a materialização de idéias. </font><font style="vertical-align: inherit;">(Artigo sobre Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: Reificação como Paradigma de Engenharia de Software. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programação orientada a eventos. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt486614/index.html">Por que o eSIM é necessário. Como funciona e por que eles falam tanto sobre isso</a></li>
<li><a href="../pt486622/index.html">Modelo de computação paralela</a></li>
<li><a href="../pt486626/index.html">Svelte: conhecendo ações</a></li>
<li><a href="../pt486628/index.html">Distância fixa entre carrapatos em um eixo no gnuplot</a></li>
<li><a href="../pt486630/index.html">“Não pisque nos olhos”: como é organizada a tecnologia de iluminação da tela dos leitores eletrônicos</a></li>
<li><a href="../pt486634/index.html">Atualizações de back-end do MSVC no Visual Studio 2019 versão 16.3 e 16.4</a></li>
<li><a href="../pt486638/index.html">O Blazor WebAssembly 3.2.0 Preview 1 já está disponível</a></li>
<li><a href="../pt486640/index.html">Resumo de materiais interessantes para o desenvolvedor móvel # 331 (27 de janeiro a 2 de fevereiro)</a></li>
<li><a href="../pt486644/index.html">Antena DIY em 5 minutos</a></li>
<li><a href="../pt486646/index.html">Afaste-se do jQuery para Svelte, sem dor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>