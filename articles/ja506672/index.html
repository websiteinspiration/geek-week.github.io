<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏩ 😗 🚲 棚のSwiftUI：アニメーション、パート2 🦍 ⚡️ 👌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="これは、SwiftUIのアニメーションストーリーのパート2です。最初の記事では、SwiftUIでアニメーションがどのように機能するかの基本について、簡単な例を検討しました。このパートでは、さらに進んで、発表されたレインボーアニメーションの例を詳細に分析します。
 
 
 
 カットの下では、アニメー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>棚のSwiftUI：アニメーション、パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、SwiftUIのアニメーションストーリーのパート2です。最初の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、SwiftUIでアニメーションがどのように機能するかの基本について、簡単な例を検討しました。このパートでは、さらに進んで、発表されたレインボーアニメーションの例を詳細に分析します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットの下では、アニメーションのタイミングの分析、ループ線形アニメーションで作業するための独自のタイミングカーブメカニズムの作成、さまざまなグラデーションの実装の例、およびフード内のアニメーションの理解に役立ついくつかの興味深いテクニックを見つけることができます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
そのようなアニメーションを実装するアイデアをスパイしたことを思い出させてください</font><font style="vertical-align: inherit;">。そこで、著者たちは最も抵抗の少ない経路をとり、形状をアニメーション化することによってこの概念を実装する最も明白な方法を実装しました。原理は単純です。各波はベジェ曲線で輪郭が描かれた輪郭であり、「時間」パラメータはこの波の右境界の位置に影響します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが完成したアニメーションの外観です</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。わかりやすくするために、波を少し垂直に広げます。これは簡単です。アニメーションの現在のフェーズに従って、輪郭全体を波の高さまで移動するようにNotchWaveの最後に追加しました。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、また.drowingGroup（）は、切断を忘れないようにする必要があります。これは、画像が固定フレームの境界を超えていることを意味するものではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプローチはシンプルで、望ましい結果を生み出します...しかし、それは私には退屈すぎるように思えました。</font><font style="vertical-align: inherit;">私の道のりはずっと長くなり、最終結果が少なくともいくらか良くなるとは言いませんが、それは途中で興味深いでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIでのアニメーション作業の原則をまだよく理解していない場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読むことを強くお勧めし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githubの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコードを掘り下げたいです</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラデーションを操作する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、私は別のアプローチを選択しました。オブジェクトの変位のアニメーションを処理する方が、フォームのアニメーションを処理するよりもはるかに便利です（まだフォームの形状構造と呼んでいます）。オフセットは、さまざまな形状、画像、その他のビューなど、何でも機能します。教育的な課題として、ある波から別の波へのスムーズな色の変化を実装したいと思いました。元々のコンセプトではそういう感じでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、SwiftIUIは、グラデーションの3つの可能な使用法を提供します-線形、円形、および角度です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは、これはある種のブロックコンストラクターのように見えます。波全体がどのようにセグメント化されているかに注目してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形グラデーションは、グラデーションの開始点と終了点で特徴付けられます。</font><font style="vertical-align: inherit;">これらは絶対座標（x：y :)のCGPointポイントではなく、UnitPointポイント、つまり </font><font style="vertical-align: inherit;">相対座標。x：y：は、このビューで選択された領域の幅と高さの割合で指定されます。</font><font style="vertical-align: inherit;">コーナー（.topLeading、.bottomTrailingなど）と側面の中点（.top、.trailingなど）に対応する定義済みのポイントもあります。</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形グラデーションセグメントは「ゴム」です。</font><font style="vertical-align: inherit;">幅は固定されていますが、高さは指定されていません。</font><font style="vertical-align: inherit;">したがって、提供された金額全体を満たします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
円形のグラデーションを備えた、もう少し複雑なストーリー。</font><font style="vertical-align: inherit;">点-円の中心、グラデーションの始点の半径、およびグラデーションの終点の半径-を示します。</font><font style="vertical-align: inherit;">半径はすでに絶対的な用語です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
円の中心は引き続きUnitPointとして設定されています。</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上部の円のある部分は高さが固定されていますが、水平方向に伸びています。結局のところ、特定の固定半径をポイントで設定しているため、線形グラデーションの場合のように、ベースカラーの追加のストレッチ長方形を接着する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適用が最も難しいのは、角度勾配です。これは、開始角度と終了角度、および方向によって指定されます。コードリストからわかるように、コーナーの操作はあまり便利ではありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある時点で角度勾配を開始し、別の時点で終了する必要がある場合は、必要な角度を計算するために三角法の学校のコースを覚えておく必要があります。</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
波の尾である角度のグラデーションもゴムですが、すでに幅が広がっています。残りの半分のサイズを占めています。実際、三角測量が多いのはそのためです。画面の境界線上の特定の色のある特定の点の位置を知っています（角のグラデーションで円形のグラデーションを接着しているため）。さらに、角度の値は、下の勾配の半径だけでなく、勾配のあるブロック自体の幅にも依存します。学校以来初めて、鉛筆を手に取り、代数を思い出しました:)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのオプションはすべて、グラデーション内の色の単一の説明を使用します。</font><font style="vertical-align: inherit;">これは、配列内の色の簡単なリストです。</font><font style="vertical-align: inherit;">それらの分布は、特定のセグメントにわたって均一になります。</font><font style="vertical-align: inherit;">停止要素の配列を使用して分布を調整できます。</font><font style="vertical-align: inherit;">実際、これは同じ色の列挙であり、それらのそれぞれについてのみ、それが配置される単一のセグメント上の座標も示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、元のコンセプトとほぼ同じ形の波を作りました。</font><font style="vertical-align: inherit;">ただし、ある色から別の色への移行は、シャープではなくスムーズになり、アニメーションがよりスムーズになる可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色は見た目と違う</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
色に関連するポイントが1つあります。</font><font style="vertical-align: inherit;">ローリングウェーブの効果を作成するために、色間の遷移を完全に線形ではないようにすることにしました。</font><font style="vertical-align: inherit;">よく見ると、グラデーション自体はエッジ自体がよりシャープであり、エッジから離れるほどメインカラーにスムーズに流れることに気づくでしょう。</font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中間色を計算し、この分布でグラデーションを作成することで、これを実現しました。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期色-0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中間色-0.3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終色-1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2色の平均を計算するときに問題が発生しました。 SwiftUIはグラデーションにColorオブジェクトを使用することを意味し、私は魅了されました。実際、RGBオブジェクトと同じように色を操作したい場合は、最初にモデルでUIColorを使用します。Colorは色に直接アクセスできないためです。また、簡単にUIColorに戻すこともできません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ここ</font></a><font style="vertical-align: inherit;">で私が見つけ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">唯一の</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切で</font><s><font style="vertical-align: inherit;">はない）</font></s><font style="vertical-align: inherit;">解決策</font><font style="vertical-align: inherit;">は、その文字列表現の分析でミラー反射を取得することです。そのようなボイラープレートですが、他のオプションはまだありません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは間違いではなく、省略ではありません。</font><font style="vertical-align: inherit;">ポイントは、ColorオブジェクトのSwiftUIがUIColorの機能を複製しないことです。</font><font style="vertical-align: inherit;">RGBチャネルで作業する必要がある場合は、それを使用してください。</font><font style="vertical-align: inherit;">SwiftUIの色は、いくつかの基本的な色を持つビューであり、その特定の値は、空の星の位置によってわずかに異なる場合があります。特定のRGBカラーは、画面に描画するときにのみ決定されます。</font><font style="vertical-align: inherit;">ドキュメントは言う</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUIは、特定の環境で使用する直前に、それを具体的な値に解決します。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、しかし環境が意味すること：ユーザーの背中の後ろの壁の色、またはiOSのデザインテーマは明確ではありません。</font><font style="vertical-align: inherit;">これが適切でない場合は、UIColorをネイティブで使用してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限のアニメーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションは.animation（）修飾子によって指定され</font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数を</font><font style="vertical-align: inherit;">変更</font><font style="vertical-align: inherit;">して修飾子でビューが初期化された後に開始</font><font style="vertical-align: inherit;">され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">その結果、修飾子は</font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライブして、「あった」から「となった」までの間隔でanimatableDataを受信します。これは、システムタイマーと一致しています。</font><font style="vertical-align: inherit;">これについては前の部分で話しました。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにエンドレスアニメーションを実行することで、アニメーションモディファイヤへのその後の変更がそれを「壊す」ことを理解する必要があります。</font><font style="vertical-align: inherit;">たとえば、起動後に何らかの理由で角度の値を0に変更すると、次のような効果が得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうして？答えは、あるアニメーションから別のアニメーションへの移行のアニメーションメカニズムにあります。この例では、画面にビューが最初に表示されたときに、0から90へのアニメーション遷移を開始しました。ビューは実際には最終値90のみを保存し、元の値0はどこにも保存されません。アニメーションエンジンは、アニメーションの現在の時間位置とAnimatableDataの現在の値を認識しています。時点0.5で45になります。この時点でユーザーが値を0に変更するとどうなりますか？回答：値を45から0に変更するアニメーションが開始されます。しかし、視覚的にのみ、サイクルは閉じていませんが、壊れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ビューが@ObservedObject、またはビューを再度レンダリングする原因となるその他のパラメーターを使用している場合、アニメーションも「壊れる」場合があります。この問題を解決するために、.animation修飾子には.animation（：value :)パラメーターがあります。そこで値を渡して、この値が変更されたときにのみアニメーションの再起動が必要であることをレンダラーに示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、必要なくなった場合にアニメーションを停止する方法を考えてみましょう。これを行うには、2つのことを提供する必要があります。明らかに、エンドレスアニメーションが不要になったことをSwiftUIに通知し、通常のfinalアニメーションに置き換える必要があります。しかし、これでは十分ではありません。 .animation（）修飾子は使用するタイミングの指示ですが、回転自体は.rotationEffect（）修飾子内に記述されており、タイマーによって回転角度の新しい値を受け取るためにすでにサブスクライブされています。回転を停止するには、その値も変更する必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前と同じように、角度の値を変更すると、新しいアニメーション（壊れているように見えました）が開始されましたが、この変更もアニメーション化されますが、通常のアニメーションのタイミングで行われます。そのため、四角形はすぐに回転を停止しませんが、減速のように停止します。</font><font style="vertical-align: inherit;">on / offタイプの</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数で</font><font style="vertical-align: inherit;">すべての機能を一時停止すると、同じことがもう少し簡潔に書くことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点まで、すべてが比較的簡単でした。ただし、ここでのすべてのイベントはビュー内で生成されることに注意してください。</font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはシステムによって、そして</font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もちろん、ユーザーによって</font><font style="vertical-align: inherit;">呼び出され</font><font style="vertical-align: inherit;">ます。ただし、アニメーション全体を1つのビュー内にカプセル化して、オン/オフのみを渡す場合はどうなりますか？ SwiftUIは、親ビューからの親メソッドの可能性を意味しません。理論的には、子ビューを構造として保存し、その変更メソッドを呼び出す</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができますが、子ビューの変数はこのように変更できないため、試してみました-機能しません。このようなことを行う唯一の方法は、記事で行ったようにCombineのPassthroughSubjectを使用することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、すべてがはるかに簡単です。頭の棚にはっきりと置いておくと、</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> これはビューの内部状態であり、外部から操作しようとはしていません。正しい解決策は非常に簡単です。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子ビュー内のビューを更新</font><font style="vertical-align: inherit;">するための</font><font style="vertical-align: inherit;">サブスクリプション</font><font style="vertical-align: inherit;">は必要ありません</font><font style="vertical-align: inherit;">。外部のパラメーターが変更されたときに、全体として既に更新されています。</font><font style="vertical-align: inherit;">時にはそれは便利ではありません。</font><font style="vertical-align: inherit;">子ビューをもう一度初期化したくない場合もあります。たとえば、アニメーションを壊さないようにしたり、init（）で、複雑でリソースを大量に消費する計算（クエリなど）が発生したりします。</font><font style="vertical-align: inherit;">このような場合は、オブジェクトエンティティを使用することをお勧めします。オブジェクトエンティティの変更は、onReceive修飾子を使用して監視できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューの更新中の状態の変更</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カバレッジに値するもう1つのことがあります。 0度と90度の2つの値のみで操作しました。アニメーションをオフにすると、角度が0にリセットされます。ただし、ボタンをクリックした瞬間にアニメーションを一時停止し、再開時に同じ場所からもう一度続行することはできますか？これを可能にするコードを見てみましょう：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なアイデアは、アニメーションの開始時に時間を追跡することです。しばらくして、アニメーションを停止するかどうかは私たち次第です。経過した完全なアニメーションサイクルの数をチェックし、現在表示されている正方形の回転角度を推測することができます。その後、</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この値を回転角度変数</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">正確に</font><font style="vertical-align: inherit;">割り当てることができ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチを機能させるには、アニメーションの開始と終了を追跡する必要があります。 Init（）は機能しません。既存の</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーターに</font><font style="vertical-align: inherit;">アクセスして</font><font style="vertical-align: inherit;">、アニメーションの前回の開始時間を取得</font><font style="vertical-align: inherit;">することはできません</font><font style="vertical-align: inherit;">。これは</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数の</font><font style="vertical-align: inherit;">トークン</font><font style="vertical-align: inherit;">です。 init内では、この変数の初期状態のみを設定できますが、初期化の最後に、Viewがinit（）の前にすでに存在していた場合、</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font><font style="vertical-align: inherit;">の値</font><font style="vertical-align: inherit;">が復元されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ここでlet externalStartedパラメーターが実装され（外部から制御します）、内部パラメーター</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var internalStartedを使用して、アニメーションを直接制御します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欠けているのは1つだけでした-.onRecieve（）のように、コンプライアンスをチェックし、必要に応じて更新して、各レンダリングでのみ機能するいくつかの修飾子。</font><font style="vertical-align: inherit;">そして、私は思った-結局のところ、すべての描画でボディが呼び出されるので、これを直接チェックしてみませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIは非常に誓うことが判明しました、レンダリングプロセス中にビューが</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font><font style="vertical-align: inherit;">の値を変更すると、</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューの更新中に状態を変更すると、未定義の動作が発生します。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような変更をブロックします。それから私は汚いハックに行き、DispatchQueue.main.asyncを使用しました。しかし、なぜこれが汚いハックであり、なぜこれが行われるべきではないのかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは実際に問題です。体内にi + = 1のような明らかな愚かさを書いた場合、iはある種の</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数の場合、無限ループが発生します。レンダリング時に、メモリ内のビューを関係のないものにします。これは、レンダリングの初期データを変更したためです。つまり、レンダリングが完了するとすぐに、ビューは再レンダリングのためにキューに入れられますが、それでもすぐに再び関係のないものにします。私たちは自分の手で無限のサイクルを作ります。この場合の非同期呼び出しは何も変更しません。次のラウンドの開始を「レンダリング直後」の瞬間に少しだけシフトします。したがって、非同期呼び出しは問題を解決しませんが、それを偽装するだけで、SwiftUIが鼻で突っ込むのを防ぎます。車の中で「チェックエンジン」の電球が切れているようなものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方で、それの何が問題になっていますか？どのプログラミング言語でも、自分が何をしているのかわからない場合に、自分の足で自分を撃つ方法はたくさんあります。しかし一方で、このアプローチはSwiftUIが機能する方法とはまったく異なります。ランタイムでビューを操作するのはよくありません。はい、あなたは胸を痛めつけることができ、無限ループに陥ることのない正しいコードを常に書くことを保証します...しかし、それはオプションの安全でない取得のようなものです-それは単なる悪い習慣です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既に述べたように、このような場合は、PassthroughSubjectを使用して新しい値を渡すCombineを使用する必要があります。ただし、willChangeイベントをサブスクライブすることで、通常のObservableObjectで問題を解決できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで問題になるのは、オブジェクトのみが変更されるという通知へのサブスクリプションでのオブジェクト自体の値の使用です。</font><font style="vertical-align: inherit;">これまでのところ、私の例では、すでに変更されたオブジェクトがあります。</font><font style="vertical-align: inherit;">どうやら、通知は少し遅れて来ます。</font><font style="vertical-align: inherit;">ただし、これが常に当てはまるとは保証できません。そのため、自分で作成したdidChange通知を使用するか、PassthroughSubjectを使用して新しい値を渡すことをお勧めします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションアニメーションの変更</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gifで確認できるように、アニメーションはすぐには止まりません。</font><font style="vertical-align: inherit;">彼女には時間が必要です。</font><font style="vertical-align: inherit;">これは、角度に中間値を割り当てるときに、特定のアニメーション（デフォルト）も使用するためです。</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは異常な動作につながります。</font><font style="vertical-align: inherit;">私が説明するすべての比較的単純なにもかかわらず、不注意なプログラマが何かを示さなかったとしても、絵は常に滑らかに見えるように相互作用の微妙なニュアンスがフードの下に残ります。</font><font style="vertical-align: inherit;">したがって、デフォルトのアニメーションは春です。</font><font style="vertical-align: inherit;">物理法則のシミュレーションに最適です。</font><font style="vertical-align: inherit;">そして、これは約0.2秒というかなり短いアニメーションです。</font><font style="vertical-align: inherit;">新しい状態への遷移のアニメーション（角度は私たちが計算して示したもの）がデフォルトの0.2秒に美しく収まる時間がなく、現在のアニメーション速度から美しいスローダウンで完全に停止するように切り替える場合、SwiftUI自体が、加速バージョンで再生される無限のアニメーションの別のループを追加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを回避するには、デフォルトのアニメーションを使用しないことで十分です。</font><font style="vertical-align: inherit;">一番下の正方形では、次のように回転停止アニメーションをオフにしました。</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、停止時にパラメーターの必要な値をより正確に計算できますが、そのためには、アニメーションの現在の瞬間を概算するだけでなく、正確に把握する必要があります。</font><font style="vertical-align: inherit;">以下にその方法を示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのアニメーションでの複数の波の動き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レインボーアニメーションに戻ります。</font><font style="vertical-align: inherit;">それで、私たちは波そのものを持っています、彼らに動くように教えましょう。</font><font style="vertical-align: inherit;">最初にやりたいことは、無限のアニメーションを実行することです。</font><font style="vertical-align: inherit;">この方法で行うことにしました</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アニメーションの現在の位置を制御する変数を</font><font style="vertical-align: inherit;">1つ</font><font style="vertical-align: inherit;">用意します。</font><font style="vertical-align: inherit;">状態0では、最初の波が最初になり、最後が最後になります。</font><font style="vertical-align: inherit;">波自体が重なります。</font><font style="vertical-align: inherit;">したがって、各波の可視部分の長さは波の数に依存します。</font><font style="vertical-align: inherit;">これは、すべての波をリストするZStackと、独自の.wavePosition修飾子を使用して実装しました。その中で、アニメーションの瞬間における各波の現在の位置と、それらが重なり合う順序を計算します。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさんのコード</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初めてビューが画面に表示されたときに、状態を0から1に変更します。これにより、宣言された線形アニメーションを考慮して、波が無限に画面の周りを走ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
波の端が右端に達すると、その次の位置は画面の端を超えた非常に最初になります。波の終わりから消えるように見え、背景の基板が露出します。これは避けたいものです。このために、修飾子のbody（）関数にif {...}ブロックが表示され、画面から失われた最初の波のコピーが描画されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各波の幾何学的特性をモディファイアパラメータの形式で転送する必要があることに注意してください。</font><font style="vertical-align: inherit;">問題は、現在のアニメーションフェーズに基づいて各波のZインデックスを再定義する必要があることでした。</font><font style="vertical-align: inherit;">内部のGeometryReader {}修飾子を使用して可視領域の幅を抽出することはできましたが、波の重ね合わせの順序の変更がブロックされるという事実に直面しました。</font><font style="vertical-align: inherit;">.zIndex（）修飾子は、ビュー階層の上にある最初のZStack {}コンテナのコンテキストでのみ機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReaderがこの接続を切断し、zIndex（）が機能しなくなります。</font><font style="vertical-align: inherit;">この時点までに、GeometryReaderが現在のビューのサイズに関するデータを取得する無害な方法であると考えていた場合、これは完全に真実ではありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フローアニメーション</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの重要なポイントは、独自のモディファイヤ内の組み込みモディファイヤのアニメーションを理解することです。ある時点で、各波は画面の端に近づき、最大の水平オフセットを取得してから、開始位置に移動し、最小のオフセットを取得します。これは他の変更と同じで、アニメーション内でもアニメーション化されます。結局のところ、アニメーションはモディファイアへの非常に頻繁な値の転送であり、それがどれほど奇妙に聞こえても、アニメーションとともに実行されます。アニメーション内で、このモディファイア内に新しい値を渡すと、現在のモーションアニメーションの終点のみが変更されることがわかります。画面の端に到達する各波は、向きを変えて浮かぶことがわかります。しかし、それも最初に到達していませんが、遅かれ早かれ、必要な位置に追いついています。そして再び左から右へ動き始めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、.animation（nil）修飾子を挿入することで解決できます。したがって、私は上記でテキストに適用されたすべての修飾子のアニメーションをオフにします。これは、すべての修飾子の作業の一般的なロジックです。入力の内容を変更し、入力には以前のすべての修飾子の結果が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に言えば、さまざまなアニメーションの階層全体がここで機能します。デフォルトは、ビューで特に指定しない限り、すべてのモディファイヤへの変更を表示するために使用されるものです。実行のスレッド（これがメインであるとしましょう）があり、その中で本体が呼び出されます。修飾子が新しい値を受け取るたびにチェックされる.animationパラメータがあると仮定します。モディファイアがアニメーションをサポートし（AnimatableModifierプロトコルに準拠）、ストリームでアニメーションが有効になっている場合（.noneやnilではなく、特定のアニメーションが使用されます）、変更はアニメーション化されます。これは</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、withAnimation {}ブロックでパラメーター</font><font style="vertical-align: inherit;">を変更</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ためのいくつかのコードを囲ん</font><font style="vertical-align: inherit;">で、現在のスレッドで特定のアニメーションを指定してから、何らかの変更を行います。</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数。この場合、withAnimation {}、これは同等のトランザクションの一種であり、このトランザクションに加えられたすべての変更はアニメーション化されます。その結果、同じストリーム内で、これらの変更をすべての依存するビューに変換するサイクルが開始され、これらのビューの修飾子が新しい値を受け取り、サブスクライブして、AnimatableDataの中間値を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、アニメーションに影響を与えられない要素があります。たとえば、スライダーの位置は、内部メカニズムによって、それ自体によってアニメーション化され、何もする必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、withAnimation（）は、実行されているアクションのデフォルトのアニメーションを開始する方法です。ただし、特定のビューでは、.animation（）修飾子を使用して、独自のアニメーションを明示的に指定できます。この場合、.animation（）に渡されるコンテンツ（.animation（）を適用する前にコードにリストされているものすべて）を構成する修飾子とフォームは、ユーザーが記述したタイミングを受け取り、ストリームアニメーションを無視します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のWavePositionモディファイヤでは、.animation（nil）を使用して組み込みのオフセットアニメーションを削除し、現在のストリームアニメーションを無視するように指示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドキャップと同じ話。前回の記事からの結論を思い出させてください。実際、N個のWavePositionモディファイヤ構造がメモリにあり、各波に1つずつあります。そして、それらはすべて、システムタイマーから新しい位置値を取得し、特定の時点での各波の位置を計算します。これは、各波にN個のエンドキャップがあることを意味します。 if {}ブロックのおかげで、一度に表示されるのはそのうちの1つだけです。しかし、同じブロックでブタが産まれます。ビューの非表示と外観も、ストリームのアニメーションで実行されます。これは、.transition修飾子を使用して、条件を変更した後のビューの外観と非表示をアニメーション化することを意味します。通常、デフォルトでは.opacityが使用されますが、何らかの理由で.slideが代わりに使用されました。どちらも私には似合わないので、このアニメーションをキャンセルしました、.transition（.identity）を使用します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd。</font><font style="vertical-align: inherit;">私が記事を準備している間に、Xcode 11.4が出ました。その中で、トランジションはデフォルトで作り直されたようです。</font><font style="vertical-align: inherit;">少なくとも今、私は問題なく.transition（.identity）をコメントアウトしましたが、追加する原因となった問題を受け取りませんでした。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションのタイミング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、私たちはついに最も興味深い質問に行きます：波を加速させる方法は？</font><font style="vertical-align: inherit;">いつものように、遠くから来ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、アニメーションは、特定のアニメーションの速度の説明です。モディファイア自体の内部でポイントAからポイントBへのルートを決定できますが、SwiftUIはそれに渡すAnimatableData値の種類と時期を決定します。彼はこれをタイミングカーブで行います。点Aを原点とし、点Bを座標（1; 1）の点としてマークするとします。水平方向に経過時間をマークします（A点からB点への移動には正確に1単位の時間がかかります）。垂直-ユニットの端数で移動した距離。線形アニメーションを使用する場合、直接取得します。現在と少し似た動きにしたい場合は、まず加速に少し時間をかけ、最後にブレーキにかける必要があります。右</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の曲線を描き、そのモーションアニメーションを標準のアニメーションと比較することで、さまざまなオプションを試してみることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIでは、ベジェ曲線はさまざまなタイプのアニメーションに使用されます。</font><font style="vertical-align: inherit;">いずれの場合も、（0; 0）で始まり、（1; 1）で終わる必要があります。</font><font style="vertical-align: inherit;">線の曲率は、制御点によって決定されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形エンドレスアニメーション内のネストされたタイミングカーブ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、線形ループアニメーション内で各波（easeIn）の加速された動きを実現するために何をする必要がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が思いつくことができる最も細かいオプションは、独自のタイミングカーブを実装し、それを使用して線形の時間の流れを一種の.easeInに変換することでした。</font><font style="vertical-align: inherit;">この例では、これがどのように機能するかを非常によく理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは簡単です。パスに基づいて独自のクラスを作成します。これは、ポイントAからポイントBまでの距離を決定するベジェ曲線であり、特定の時点で表示する必要があります。実際、これはSwiftUIや、同様の機能を持つ他のフレームワークでアニメーションが機能する方法とまったく同じです。タイミングカーブの助けを借りて、実際の秒とミリ秒（ほとんどの場合、直線的に流れます）が距離の分数（より正確には、アニメーションセグメントの分数-加えられた変更を表すAnimatableDataベクトル）に変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが私の最初の実装です：</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやら、私は少し愚かでした。定義により、Xの指定された値に対応する曲線上の点を見つけて、Yに返す必要があります。この問題を解決するための標準の組み込み方法、または一般的なパターンが見つからなかったため、既存のトリム方法をこれらの目的に適合させることにしました（ ）私はアプローチを十分に再考し、移動距離の一部に対応するパスの一部を取得することで目的のポイントを取得できると判断しました。ゼロの場合、このメソッドは0を返し、1の場合は1を返します。まあ、途中で、おそらくすべてがほぼ正しくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチではあまり正確な結果が得られないことを認識していましたが、後で同じ方法で標準的な方法でまったく同じアニメーションを再現しようとしたときに、問題の深刻さが表面化しました。その違いに驚いて、こうして得られたポイントが元の曲線からどれだけ離れているかをグラフで確認することにしました。結果は私を満足させませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイントが目的のカーブから離れているだけでなく、カーブの性質自体が歪んでいます。余計なキンクがあり、私にはまったく必要ありません。結果として、ベジェ曲線上の点を見つけるために比較的正確な方法を考え出す必要があり、1つの座標しか知りませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのセグメントをメモリに保存する必要があり、その両端は特定の曲線上にあります。このアプローチでの特定のXによるYの検索は、対応するセグメントの検索であり、必要に応じて、そのセグメントの境界の1つが目的のポイントに十分近くなるまで、半分に分割します。この場合、必要なX座標がこのセグメント上にあるポイントを見つけてYを返します。任意のベジェ曲線上にあるポイントを見つける簡単な方法がわかっている場合は、特定の座標を使用して、コメントを書き込みます。多くの人に役立つと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ポイントはチャートにかなり近づきます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルポイントオブジェクトを作成して、コントロールポイントのタイミングカーブを作成し、Yを検索するセグメントの配列をキャッシュしました。したがって、カーブ上の特定のポイントを見つけるために必要なことは、このポイントが存在するセグメントを見つけ、半分に分割することだけです。セグメントの端の1つがこの点に十分近くなり、指定されたエラーに該当するまで、次に、指定されたXに沿ってYの値を線形補間し、曲線の一部をこのセグメントで置き換えます。これが最良の方法であり、すべてのケースで機能することを主張しません。繰り返しますが、より良い方法を知っている場合はコメントに書き込んでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなツールを使用すると、線形アニメーションの非線形への変換が簡単になります。</font><font style="vertical-align: inherit;">必要なのは、2つの制御点で曲線を記述し、この曲線に従ってセグメント上の位置を再計算することだけです。</font><font style="vertical-align: inherit;">さまざまな期間のアニメーションが必要な場合でも、X座標に適切な係数を使用した単位曲線を使用します。</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがアニメーションの様子とタイミングカーブ</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード全体については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へようこそ</font><font style="vertical-align: inherit;">。TimingCurveViewファイルをご覧ください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例を理解すると、アニメーションのタイミングがどのように配置されるかを100％理解できます。</font><font style="vertical-align: inherit;">ちなみに、SwiftUIでは、timingCurve（）関数を使用してコントロールポイントの独自のタイミングカーブを作成し、他のアニメーションと同じように使用できるため、この知識を利用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遷移</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、我慢できるエンドレスアニメーションが完成しました。オンとオフを切り替える方法を理解するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外観をアニメーション化するアイデアは、アニメーションブロックをすでにオンになっている場所に表示することですが、カーテンは劇場のカーテンのようにそこから引き戻されます。カーテンの速度をアニメーション内の波の速度と同期させ、カーテン自体で背景色から現在の入射波の色にグラデーションを作成すると、このカーテンが最初のローリングウェーブであるかのように視覚効果が得られます。動きの速度を同期させるには、波の動きをアニメートする場合と同じタイミングカーブを使用します。幸いなことに、これを行う方法がわかりました。</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve（x：y :)を使用すると、ベジェ曲線の制御点に基づいて独自のアニメーションタイミングを設定できます。</font><font style="vertical-align: inherit;">出力では、使い慣れた.linear（期間：1）など、制限なしで使用できる本格的なAnimationオブジェクトが得られます。</font><font style="vertical-align: inherit;">ウェーブアニメーションにまったく同じコントロールポイントを使用することを考えると、アニメーションは同期になります。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを整理する方が便利です...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          …     ,     ,     .  -  ,        —    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションの無効化は同じ方法で行うことができます。カーテンのみがアニメーションブロックに這い上がり、徐々に閉じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の問題は、カーテンの色を選択するためにアニメーションの現在の状態を取得する必要があるときに発生しました。</font><font style="vertical-align: inherit;">これを行うために、モディファイア内で渡し、AnimatableDataセッター内で変更するObservableObjectを作成しました。</font><font style="vertical-align: inherit;">ここで、@ Publishedプロパティを毎秒60回変更することは、必ずしも必要なことではないことを理解することが重要です。</font><font style="vertical-align: inherit;">これは</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ボディブロック内の変数</font><font style="vertical-align: inherit;">を変更</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">アニメーションの状態が変化しても、何も開始する必要はありません。</font><font style="vertical-align: inherit;">ただし、必要に応じて、いつでもアニメーションの状態を確認できます。</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが、AnimationHendlerの変更を追跡するためにSharpRainbowViewにサインアップしなかった理由です。 </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのカーテンの操作を説明するために、.clipped（）をコメント化して、ビューの外側で何が起こっているかを表示します。さらに、わかりやすくするために、アニメーションの少し上にカーテンを移動します。はっきりしているよね？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各波とカーテンが移動するパスが一致するようにカーテンを短くする必要があります（そうしないと非同期のアニメーションになります）が、同時に彼女はなんとか画面から完全に消えました。同時に、カーテンは3色のグラデーションで配置されています。これは閉じるカーテンではっきりと見えます。これは、最初はとても好きだったロングテールが原因です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事は最初の波が送信されたアレイの最後と最初の色のグラデーションであることです。それらのどれも背景色と一致しない場合があります。したがって、一般的にカーテンが必要でした。カーテンをツートーンにするために、背景色から最初の波のベースカラーまで、カーテンの長さが妨げになりました。これは、最初の波の長い尾とは重なりません。ある色の境界線と、別の色の尾線が得られます。したがって、私はカーテンを3色まで作成する必要がありました。最初に背景から最後の波の色まで、次に最後の波の色から最初の波までです。次に、最初の波の尾がカーテンの境界にぴったり合います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほぼ同じ理由で、彼らはクロージングカーテンもトリコロールにしました。そうでなければ、境界線は不自然に見えました。しかしその結果、最初の「波」（そしてこれが実際にはTransition.truncateで説明されているカーテンであることがわかります）は短いことがわかりました。そして、それは最初の波と完全に同期して動きますが、加速され、線形ではありません。その幅は時間とともに変化しませんが、後続の波の幅は視覚的に増加します。これは、カーテンの幅を動的に変更することで解決できますが、率直に言って怠惰でした。これを、これらのメカニズムに飛び込んでコードを喫煙したい人のための宿題として考えてみましょう（そのような人には事前に謝罪します。あなたを混乱させる可能性がある私の実験の痕跡がたくさんあります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が1つあります。</font><font style="vertical-align: inherit;">失敗したときにボタンを押すと、クロージングカーテンが次の波をかろうじてカバーします。</font><font style="vertical-align: inherit;">見栄えがよくありません。</font><font style="vertical-align: inherit;">アニメーション付きのビューの非表示にわずかな遅延を導入することで問題を解決できます。</font><font style="vertical-align: inherit;">アニメーションの現在の位置を確認する方法があり、トランジションの開始を少し延期するだけで、最後の波が常に完全に表示されます。</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、カーテンの幅を可変にして、背景とカーテンの境界線、およびカーテンと最初の波の速度が異なるような錯覚を作成することもできますが、最初の波は少し不自然に見えますが、私はすでに面倒すぎて気になりません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランジションは豚の裏地が大好き</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概して、私にとって、出現と消滅のアニメーションは非常にクールなツールです。しかし、この概念は新しいものであり、すべてのツールが通常それを処理するわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、.rotation3DEffect（）修飾子は、内部にいくつかの複雑なアニメーションを含むビューを正常に反転しますが、.transitionを反転する方法はわかりません。簡潔なコードを記述し、波が画面の中心からどのように散乱するかを確認してから、左側でカーテンが左から右に走っているのを確認するのは非常に残念です。トランジション修飾子が両方向で機能できるように、ボイラープレートの束を作成する必要がありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Metalを接続して、多数のネストされたビュー、特にグラデーションのあるビューを持つZStackレンダリングをGPUに転送するためのdrowingGroup（）修飾子では、遷移方法がわかりません。</font><font style="vertical-align: inherit;">彼はあなたが描写した出現と消滅のアニメーションを理解せず、それを彼自身のものに置き換えます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、ステータスバーを非表示にするにはどうすればよいでしょうか。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とても簡単です。 SwiftUIには.statisBar（非表示:)修飾子があります。 SwiftUIが提供しないステータスバーの遷移を制御するためのAPIを次に示します。これを行うには、UIKitの機能を利用する必要があります。 SceneDelegateファイルは、UIHostingControllerを使用してSwiftUIビューをUIKit ViewControllerに変換します。ステータスバーの操作や、画面の端に関連付けられたシステムジェスチャの無効化（preferredScreenEdgesDeferringSystemGestures）など、一部のグローバルUIKit関数を使用するのが最も便利なのは、この段階です。一部のシステムプロパティの値をオーバーライドしてUIHostingControllerを継承し、この子孫を使用してビューをrootViewControllerに渡すことができます。残念ながら、ステータスバーを受け入れることができるトランジションの数は限られています：.fade、.slide、および.none。デフォルトはフェードです。ここに最もよくフィットするので、そのままにしておきましょう。この機能が引き続き拡張されることを期待しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステータスバーの非表示と外観を波の動きと同期させるために、別のビューを作成しました。その中で、このパラメーターの値を一時停止して変更しました。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ここでは単純なSpacer（）が作成されていますが、これはすでに必要ですが、その上にstatusBarモディファイアが作成されています。もちろん、一般に、Appleがこの機能を修飾子に出力することは、次のように非論理的でした。これは、変更している特定のビューには適用されませんが、どうすればそれをより適切に実行できるかがわかりませんでした。さらに興味深いのは別のものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、前に考えたのと同じダーティーハックを使用し</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">本体の内部で、</font><font style="vertical-align: inherit;">変数の</font><font style="vertical-align: inherit;">値を変更しながら、実行時にいくつかのアクションを実行し</font><font style="vertical-align: inherit;">ます。全体としてのロジックは同じで、外部から送信される構造パラメーターと、</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しばらくすると変更さ</font><font style="vertical-align: inherit;">れる</font><font style="vertical-align: inherit;">変数があり、ステータスバーが消えたり表示されたりします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ステータスバーアニメーションの制御はSwiftUIでまだ十分に開発されていないUIKit機能であるため、このハックが必要でした。</font><font style="vertical-align: inherit;">理論的には、遅延開始アニメーションを.statusBar（非表示:)修飾子にねじ込みますが、これは機能しません。</font><font style="vertical-align: inherit;">ステータスバーの非表示と外観のアニメーションは修正されており、SwiftUIでは変更できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ユーザーがボタンをクリックしたときでも、このビュー内ではなく親で、希望の遅延で非同期に同じ変更を行うことを妨げるものはありませんでしたが、何が何であるかを理解しようとする私の試みのモニュメントとして残しておきましょう（そしてもう1つの理由これを行うべきではありません）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、ステータスバーのサイズと位置はどのようにして@Environmentに詰め込まれましたか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment（@EnvironmentObjectと混同しないでください）は、アプリケーションの環境を反映する変数の固定リストへのアクセスを提供するラッパーです。たとえば、画面の向き、OSのカラーテーマなどです。同じラッパーにより、ビューをサブスクライブしてこれらのパラメーターを変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリストは拡張できます。 @Environmentがステータスバーのサイズと位置にアクセスできることは正しいと思いました。ここに私がそれをした方法があります：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的なデフォルト値で構造を作成しました。</font><font style="vertical-align: inherit;">次に、独自の計算されたプロパティを追加することにより、SystemValuesシステム構造を拡張しました。そのゲッターとセッターは、作成したタイプを参照しています。</font><font style="vertical-align: inherit;">ここで使用されているのは、EnvironmentValuesがタイプを渡す添え字を実装し、このタイプに対応する格納された値を取得するためです。</font><font style="vertical-align: inherit;">このタイプの値ではなく、タイプ自体がキーである条件付きディクショナリに格納されている値。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environmentの値には、keyPath \ .statusBarFrameを使用してアクセスします。</font><font style="vertical-align: inherit;">たとえば、階層の下のすべてのビューに環境値を渡すには：</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ビューから、ストアから値を取得します。</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、IOS 13のUIWindowSceneオブジェクトのステータスバーを操作するために、statusBarManager属性が表示されています。</font><font style="vertical-align: inherit;">そこからいくつかのパラメータを引き出すことができます。</font><font style="vertical-align: inherit;">しかし、今はそれらを管理できません。</font><font style="vertical-align: inherit;">私が理解しているように、以前はViewControllerステータスバーにアクセスしてそれにサブビューを追加することが可能でした。</font><font style="vertical-align: inherit;">どうやら、彼らはベンチを閉じた。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に言って、私は.statusBar（hidden :)修飾子の機能をここに正確に転送します。ここでは、私にとってより適切です。</font><font style="vertical-align: inherit;">遅かれ早かれ、開発者はこの時点に到達すると思います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、この魅力的な例では、SwiftUIツールを使用したアニメーションへのエクスカーションは完全であると考えることができます。簡単な例を使用して、メインのアニメーションツールについて説明し、それらが内部でどのように正確に機能するか、どのように使用する必要があるか、なぜ正確に説明しました。より複雑な例を使用して、遭遇する可能性のある典型的な困難とそれらを克服する方法を示しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のコードは、上記の記事の例と比較して、よりクリーンで、より明確で、より短いものでしたか、それともメンテナンスがより簡単でしたか？おそらくそうではありません。それはより少ないリソースを消費しますか？ああ、違う。おそらく私のアプローチはより普遍的ですが、これは正確ではありません。しかし、彼が間違いなくより上手に実行する1つのタスクがあります。これは、内部でのSwiftUIの操作をより深く示しています。これを使うと、頭の中で棚にアニメーションを配置して、アプリケーションに自由に適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIは積極的に利用されています。</font><font style="vertical-align: inherit;">最初の記事のコードを書いてから2週間後の今でも、現在のバージョンのXcodeでコードを確認すると、回避しなければならないいくつかのバグが既に修正されていることがわかります。</font><font style="vertical-align: inherit;">したがって、私は記事に少し滞在しました。</font><font style="vertical-align: inherit;">何かを無関係に切り取らなければならず、それ以外はすべて再確認する必要がありました。</font><font style="vertical-align: inherit;">そして喜ばれます。</font><font style="vertical-align: inherit;">SwiftUIは間違いなくネイティブiOS開発の未来であり、その起源に立ち、どのように開発されるかを観察することは非常に有益です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あとがき</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の資料を作成する過程で、頭の中にたくさんのことも頭に入れました。</font><font style="vertical-align: inherit;">いつ書き始めたのかわからないニュアンスがたくさんありました。</font><font style="vertical-align: inherit;">したがって、SwiftUI開発の経験をすでに持っているすべての人に強くお勧めします。恥ずかしがらずに、あなたの経験と知識を共有してください。</font><font style="vertical-align: inherit;">これはコミュニティにとってもあなた自身の知識の完全性にとっても非常に役立ちます。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アヒルの方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりもクールで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">あり</font></a><font style="vertical-align: inherit;">、答えを定式化する必要もあります。</font><font style="vertical-align: inherit;">主なことは、そのような答えを探すのを怠惰にすることではなく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少年たちが示すのが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恥ずかしくないことです</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja506648/index.html">Laravelダイジェスト（2020年6月8-14日）</a></li>
<li><a href="../ja506658/index.html">GitLab 13.0がGitalyクラスター、ロードマップ上の壮大な階層、ECSの自動展開とともにリリースされました</a></li>
<li><a href="../ja506662/index.html">2次および3次のベジェ曲線の適応分割</a></li>
<li><a href="../ja506664/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo. 419（2020年6月8日〜14日）</a></li>
<li><a href="../ja506666/index.html">ORMテクスチャですが、それだけの価値はありますか？</a></li>
<li><a href="../ja506676/index.html">カタール：移植と夜の街の世界センター</a></li>
<li><a href="../ja506680/index.html">.NET CoreとNode.js。議論と事実</a></li>
<li><a href="../ja506684/index.html">dedic.ruをgithubページに転送して満足した方法</a></li>
<li><a href="../ja506686/index.html">6月15日から21日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja506688/index.html">6月15〜21日のサンクトペテルブルクでのデジタルイベント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>