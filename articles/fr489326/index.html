<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✔️ 👩🏿‍🏫 🍆 Réflexions sur des tests d'entreprise efficaces 🚶 🤵🏻 🤷🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 
 
 Récemment, nous sommes revenus à une étude approfondie du sujet des tests, et dans les plans prévisibles, nous avons même un excell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Réflexions sur des tests d'entreprise efficaces</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Récemment, nous sommes revenus à une étude approfondie du sujet des tests, et dans les plans prévisibles, nous avons même un excellent livre sur les tests unitaires. </font><font style="vertical-align: inherit;">Dans le même temps, nous pensons que le contexte est important dans ce sujet comme nulle part ailleurs, c'est pourquoi nous proposons aujourd'hui une traduction de deux publications (combinées en une seule) publiées sur le blog d'un éminent spécialiste de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebastian Dashner - à savoir, 1/6 et 2/6 de la série " Réflexions sur des tests d'entreprise efficaces. "</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les tests en entreprise sont un sujet qui n'a pas encore été examiné avec autant de détails que nous le souhaiterions. </font><font style="vertical-align: inherit;">Il faut beaucoup de temps et d'efforts pour écrire et surtout pour supporter les tests, cependant, essayer de gagner du temps en abandonnant les tests n'est pas une option. </font><font style="vertical-align: inherit;">Quels volumes de tâches, d'approches et de technologies de tests méritent d'être explorés afin d'augmenter l'efficacité des tests?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quels que soient les différents types de tests et leur portée, le but de la préparation d'un ensemble de tests est de s'assurer sur ce matériel qu'en production notre application fonctionnera exactement comme prévu. </font><font style="vertical-align: inherit;">Une telle motivation devrait être la principale pour vérifier si le système remplit la tâche, si nous considérons ce système du point de vue de l'utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que la durée d'attention et le changement de contexte sont des éléments dont il faut tenir compte, nous devons nous assurer que nos tests ne sont pas exécutés et testés depuis longtemps et que les résultats des tests sont prévisibles. </font><font style="vertical-align: inherit;">Lors de l'écriture de code, une vérification rapide du code (réalisable en une seconde) est cruciale - cela garantit une productivité et une concentration élevées pendant le travail.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'autre part, nous devons assurer un support de test. Le logiciel change très souvent, et avec une couverture substantielle du code avec des tests fonctionnels, chaque changement fonctionnel dans le code de production nécessitera un changement au niveau du test. Idéalement, le code de test ne devrait changer que lorsque la fonctionnalité, c'est-à-dire la logique métier, change, et non lors du nettoyage du code inutile et de la refactorisation. En général, les scénarios de test devraient inclure la possibilité de changements structurels non fonctionnels.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous considérons les différents domaines d'application des tests, la question se pose: lesquels de ces domaines valent le temps et les efforts? </font><font style="vertical-align: inherit;">Par exemple, dans les applications de microservices, ainsi que dans tout système qui fournit un travail important sur la distribution et l'intégration de code, les tests d'intégration sont particulièrement importants, aidant à repousser les limites du système. </font><font style="vertical-align: inherit;">Par conséquent, nous avons besoin d'un moyen efficace pour tester l'ensemble de l'application dans son ensemble pendant le développement local, tout en maintenant l'environnement et la structure de cette application sous la forme la plus proche possible de la production.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Principes et limites</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelles que soient les solutions qui seront sélectionnées, définissons les principes et limitations suivants pour notre suite de tests:</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : «     HTTP-  gRPC,   JSON  -      enterprise-, ..?”.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    « »,  ,    ,          , , ,  “dev”  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">watch-and-deploy</a> («  »)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le test unitaire vérifie le comportement d'un seul module, généralement une classe, tandis que tous les facteurs externes qui ne sont pas liés à la structure du module sont ignorés ou simulés. Les tests unitaires doivent vérifier la logique métier des modules individuels, sans vérifier leur intégration ou configuration supplémentaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'après mon expérience, la plupart des développeurs d'entreprise ont une assez bonne idée de la façon dont les tests unitaires sont compilés. Pour vous faire une idée, vous pouvez voir cet exemple dans mon projet de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">test de café</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans la plupart des projets, JUnit est utilisé en combinaison avec Mockito pour simuler des dépendances, et idéalement avec AssertJ pour définir efficacement des instructions lisibles. J'insiste toujours sur le fait que les tests unitaires peuvent être effectués sans extensions ou démarreurs spéciaux, c'est-à-dire avec le JUnit habituel. L'explication est simple: tout est question d'exécution, car nous avons besoin de pouvoir exécuter des centaines de tests en quelques millisecondes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En règle générale, les tests unitaires s'exécutent très rapidement et il est facile d'en assembler des suites de tests complexes ou des workflows spéciaux, car ils sont simples à exécuter et n'imposent aucune restriction au cycle de vie du test.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, lorsque vous avez beaucoup de tests unitaires simulant les dépendances de la classe testée, il y a un inconvénient: ils sont étroitement liés à l'implémentation (cela s'applique particulièrement aux classes et aux méthodes), c'est pourquoi notre code est difficile à refactoriser. En d'autres termes, pour chaque acte de refactoring dans le code de production, il nécessite également des modifications du code de test. Dans le pire des cas, les développeurs commencent même à refuser partiellement le refactoring, simplement parce que c'est trop lourd et que la qualité du code dans le projet diminue rapidement. Idéalement, le développeur devrait être en mesure de refactoriser et de réorganiser les éléments, à condition que, pour cette raison, aucune modification de l'application ne soit visible par l'utilisateur. Les tests unitaires ne simplifient en aucun cas toujours la refactorisation du code de production.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais l'expérience suggère que les tests unitaires sont très efficaces pour vérifier le code qui est densément rempli de logique concise ou décrit la mise en œuvre d'une fonction spécifique, par exemple, un algorithme, et, en même temps, n'interagit pas très activement avec d'autres composants. Moins le code est complexe ou dense dans une classe particulière, moins sa complexité cyclomatique ou interagit activement avec d'autres composants, moins les tests unitaires seront efficaces lors du test de cette classe. Surtout dans les cas de microservices, dans lesquels la logique métier est relativement peu contenue, mais où une intégration étendue avec des systèmes externes est fournie, il n'est probablement pas nécessaire d'utiliser des tests unitaires dans de nombreux cas. Dans de tels systèmes, les modules individuels (à de rares exceptions près) contiennent généralement peu de logique spécialisée. Cela doit être pris en compte lors de la décisionce qui est plus approprié pour passer du temps et des efforts.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tester des situations d'application</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour faire face au problème de la liaison étroite des tests avec l'implémentation, vous pouvez essayer une approche légèrement différente pour étendre la portée des tests. </font><font style="vertical-align: inherit;">Dans mon livre, j'ai écrit sur les tests de composants, car je ne pouvais pas trouver un meilleur terme; </font><font style="vertical-align: inherit;">mais, en substance, dans ce cas, nous parlons de tester des situations appliquées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les tests de situation d'application sont des tests d'intégration qui fonctionnent au niveau du code, qui n'utilisent pas de conteneurs intégrés - ils sont abandonnés pour accélérer le lancement. </font><font style="vertical-align: inherit;">Ils testent la logique métier de composants bien coordonnés, qui sont généralement utilisés dans un cas pratique spécifique, depuis la méthode des limites, puis jusqu'à tous les composants qui leur sont associés. </font><font style="vertical-align: inherit;">L'intégration avec des systèmes externes, par exemple avec des bases de données, est imitée à l'aide de simulacres.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La construction de tels scénarios sans l'utilisation de technologies plus avancées qui connecteraient automatiquement les composants semble être un gros travail. Cependant, nous définissons des composants de test réutilisables, ce sont également des homologues de test qui étendent les composants en simulant, en connectant et en ajoutant également des configurations de test; tout cela est fait pour minimiser l'effort total requis pour le refactoring. L'objectif est de créer les seules responsabilités limitant le degré d'influence des changements sur une seule classe (ou plusieurs classes) dans le domaine des tests. En effectuant de tels travaux en vue de les réutiliser, nous réduisons la quantité totale de travail nécessaire, et une telle stratégie est justifiée lorsque le projet se développe, mais chaque composant ne nécessite que des réparations mineures, et ce travail est rapidement amorti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour mieux imaginer tout cela, supposons que nous testons une classe qui décrit l'ordre du café. Cette classe comprend deux autres classes: </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les classes de tests doubles, </font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ils </font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont situés dans la zone de test du projet, où ils héritent des composants </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situés dans la zone principale du programme. Les homologues de test peuvent définir la logique de simulation et de connexion nécessaire et potentiellement étendre l'interface publique de la classe à l'aide des méthodes de simulation nécessaires dans cette application ou des méthodes de vérification. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui suit montre la classe double de test pour le composant </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe double test peut accéder aux champs et aux constructeurs de la classe de base CoffeeShop pour établir les dépendances. Ici, sous la forme de jumeaux de test, des variantes d'autres composants sont également utilisées, en particulier, </font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elles sont nécessaires pour appeler des méthodes de simulation ou de vérification supplémentaires, qui font partie du cas pratique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les classes de doubles de test sont des composants réutilisables, chacun étant écrit une fois par portée de chaque projet, et est ensuite utilisé dans de nombreux cas pratiques:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le test de composant vérifie le cas spécifique de la logique métier invoquée au point d'entrée, dans ce cas </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ces tests sont obtenus de manière concise et lisible, car toutes les connexions et simulations sont effectuées dans des jumeaux de test séparés, et plus tard, ils peuvent utiliser des techniques de dépistage hautement spécialisées, telles que </font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, la classe de test étend la portée de la classe de production, vous permettant d'installer mokee et d'utiliser des méthodes qui vérifient le comportement. Bien qu'il semble que la mise en place d'un tel système demande beaucoup d'efforts, ces coûts sont rapidement amortis si, dans le cadre de l'ensemble du projet, nous avons de nombreux cas pratiques où les composants peuvent être réutilisés. Plus notre projet se développe, plus cette approche devient utile - surtout si vous faites attention au temps nécessaire pour terminer les tests. Tous nos cas de test sont toujours exécutés à l'aide de JUnit, et dans les plus brefs délais, ils sont exécutés par centaines.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est le principal avantage de cette approche: les tests de composants s'exécutent aussi rapidement que les tests unitaires réguliers, mais ils stimulent le refactoring du code de production, car des modifications doivent être apportées à un seul composant ou à quelques composants seulement. </font><font style="vertical-align: inherit;">De plus, en améliorant les doublons de test avec un réglage expressif et des méthodes de test spécifiques à notre domaine, nous augmentons la lisibilité de notre code, facilitons son utilisation et éliminons le code stéréotypé dans les scripts de test.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489298/index.html">Entretien informel avec Maria Dolgusheva (RH de la Silicon Valley)</a></li>
<li><a href="../fr489302/index.html">Numéro 31: Formation informatique - problèmes et défis actuels des grandes entreprises</a></li>
<li><a href="../fr489304/index.html">Analyse des données ChIP-seq: des histones aux tâches informatiques</a></li>
<li><a href="../fr489306/index.html">[Habr]: Beignets</a></li>
<li><a href="../fr489310/index.html">Top 10: les meilleurs reportages de Heisenbug 2019 Moscou</a></li>
<li><a href="../fr489328/index.html">Null sneaked up: Breaking Scala Option using Java</a></li>
<li><a href="../fr489332/index.html">Assistants essentiels à l'intelligence du service de renseignement le plus efficace au monde (partie 3)</a></li>
<li><a href="../fr489336/index.html">Interface Vélos Toxic Grandfather. «Apprendre, étudier et étudier à nouveau» (s1 e3)</a></li>
<li><a href="../fr489340/index.html">Comme l'unité maximale pour la transmission d'informations sur Internet est devenue 1500 octets</a></li>
<li><a href="../fr489342/index.html">Création d'une infrastructure informatique tolérante aux pannes. Partie 4. Déploiement de commutateurs Cisco 3850 pour le routage de passerelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>