<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 ❎ 🕝 Goでジェネリックが必要なのはなぜですか？ 👩🏽‍🎤 👏 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、Goにジェネリックを追加することの意味と、これを行う必要がある理由について説明します。また、ジェネリックを追加するために、言語のアーキテクチャーの変更の可能性についても触れます。
 
 Goは2009年11月10日にリリースされました。1日も経たないうちに、ジェネリックスに関する最初の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Goでジェネリックが必要なのはなぜですか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/462811/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/tx/-f/rltx-f5fgboibhjrrvpfkoayvp8.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Goにジェネリックを追加することの意味と、これを行う必要がある理由について説明します。</font><font style="vertical-align: inherit;">また、ジェネリックを追加するために、言語のアーキテクチャーの変更の可能性についても触れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goは2009年11月10日にリリースされました。</font><font style="vertical-align: inherit;">1日も経たないうちに、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリックスに関する最初のコメントが表示されました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、2010年の初めにパニックの形で言語に追加した例外についても言及しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3年間の観察の間、ジェネリックの欠如は常に、言語で修正する必要がある3つの主要な問題のリストでした。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリック医薬品が必要なのはなぜですか？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリックを追加するとはどういう意味ですか？なぜそれが必要なのですか？</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ジャザイエリなど</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を言い換える</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ジェネリックスを使用したプログラミングでは、型を除いて、関数とデータ構造をジェネリックスとして表すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは何を意味するのでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スライスの要素を逆の順序で表す必要があるとします。</font><font style="vertical-align: inherit;">これはあまり一般的な作業ではありませんが、それほど珍しいことでもありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整数のスライスがあるとします。</font></font><br>
<br>
<pre><code class="go">func ReverseInts(s []int) {<font></font>
    first := 0<font></font>
    last := len(s)<font></font>
    for first &lt; last {<font></font>
        s[first], s[last] = s[last], s[first]<font></font>
        first++<font></font>
        last--<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルに見えます。</font><font style="vertical-align: inherit;">しかし、このような単純な関数であっても、いくつかのテストを書く必要があるかもしれません。</font><font style="vertical-align: inherit;">そしてこれを行ったとき、私はバグを発見しました。</font><font style="vertical-align: inherit;">多くの人がすでにそれに気づいていると思います。</font></font><br>
<br>
<pre><code class="go">func ReverseInts(s []int) {<font></font>
    first := 0<font></font>
    last := len(s) - 1<font></font>
    for first &lt; last {<font></font>
        s[first], s[last] = s[last], s[first]<font></font>
        first++<font></font>
        last--<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数を代入しながら、1を減算します</font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、文字列値のスライスの順序を変更します。</font></font><br>
<br>
<pre><code class="go">func ReverseStrings(s []string) {<font></font>
    first := 0<font></font>
    last := len(s) - 1<font></font>
    for first &lt; last {<font></font>
        s[first], s[last] = s[last], s[first]<font></font>
        first++<font></font>
        last--<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とを比較する</font></font><code>ReverseInts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ReverseStrings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パラメーターのタイプを除いて、関数はまったく同じであることがわかります。</font><font style="vertical-align: inherit;">私はこれであなたをほとんど驚かせませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、Goの新規参入者を驚かせるのは、</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あらゆるタイプのスライスで</font><font style="vertical-align: inherit;">機能する単純な関数を書く方法がないことです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のほとんどの言語では、そのような関数を書くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PythonやJavaScriptのような動的に型付けされた言語では、要素の型を指定せずに関数を簡単に記述できます。</font><font style="vertical-align: inherit;">これは静的に型付けされた言語であるため、Goでは不可能です。特定のタイプのスライスとその要素のタイプを登録する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++、Java、Rust、Swiftなど、他のほとんどの静的型付き言語は、このような状況に対応するジェネリックをサポートしています。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリックを使用した最新のGoプログラミング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、Goで同様のコードをどのように書くのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この言語では、転送するスライスのタイプのインターフェイスタイプとメソッド定義を使用して、さまざまなタイプのスライスで機能する関数を記述できます。これが</font></font><code>sort.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ライブラリの</font><font style="vertical-align: inherit;">関数の動作方法</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、Goのインターフェース型は、ジェネリックを使用したプログラミングの一種です。これにより、さまざまなタイプの一般的な側面を識別し、それらをメソッドの形式で表現できます。次に、これらのインターフェイス型を使用して関数を記述できます。関数は、これらのメソッドに実装されているすべての型で機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このアプローチは私たちの欲求を満たしていません。インターフェイスでメソッドを自分で作成する必要があります。名前付きの型をいくつかのメソッドで定義して、スライス内の要素の順序を変更するのは奇妙です。また、記述するメソッドはすべてのタイプのスライスでまったく同じであるため、コードを除外しませんでしたが、ある意味では、コードを転送して圧縮しました。インターフェイスはジェネリックを表す方法ですが、ジェネリックから必要なすべてを提供するわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドを記述する必要がない汎用インターフェースを使用するもう1つの方法は、一部の型のメソッドを定義する義務を言語に移すことです。現在Goはこれをサポートしていませんが、たとえば、言語はスライスの各タイプにメソッドがあると判断できます</font></font><code>Index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素を返します。ただし、このメソッドを実際に使用するには、空のインターフェース型を返す必要があります。そうすると、静的型付けの利点がすべて失われます。同じタイプの要素を持つ2つの異なるスライスを取る、または同じタイプの要素を持つマップを受け取り、同じタイプの要素を持つスライスを返す汎用関数を定義する方法はありません。 Goは、大きなプログラムを簡単に作成できるようにするため、静的に型付けされています。ジェネリックの利点のために静的型付けの利点を失いたくない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のアプローチは</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、reflectパッケージを使用</font><font style="vertical-align: inherit;">する汎用関数を作成する</font><font style="vertical-align: inherit;">ことですが、これは奇妙すぎて動作が遅すぎます。さらに、型の明示的な表明と型チェックの放棄を行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、型を受け取り、</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この型のスライスの</font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">生成するコードジェネレーターを作成することもできます</font><font style="vertical-align: inherit;">。いくつかのジェネレータがこれに適しています。ただし、このようなソリューションでは</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">必要なすべてのパッケージに1つのステップが追加</font><font style="vertical-align: inherit;">され、すべてのコピーをコンパイル</font><font style="vertical-align: inherit;">する必要</font><font style="vertical-align: inherit;">があるため、アセンブリが複雑になり、ソースコードのバグを修正するには、すべてのインスタンスを再生成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されているすべてのアプローチはかなり奇妙であり、Goでスライスを並べ替える必要があるほとんどのプログラマは、特定のタイプのスライスの関数を記述するだけだと思います。次に、関数のテストを作成して、最初に行ったような単純なミスを犯していないことを確認する必要があります。そして、これらのテストを定期的に実行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うと、要素のタイプを除いて、まったく同じに見える関数のために、多くの追加作業を行うことになります。これが不可能ではありません。これは間違いなく可能であり、Goプログラマーが行います。より良い方法が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goのような静的に型付けされた言語の場合、このメソッドはジェネリックと呼ばれる方が適切です。</font><font style="vertical-align: inherit;">上で書いたように、ジェネリックスを使用したプログラミングでは、型を除くジェネリックスの形式で関数とデータ構造を表すことができます。</font><font style="vertical-align: inherit;">それが必要です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリックがGoに与えること</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goのジェネリックスで最初に必要となる最も重要なこと</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、スライス内の要素のタイプを気にせずに</font><font style="vertical-align: inherit;">関数を記述できること</font><font style="vertical-align: inherit;">です。要素のタイプを除外します。また、関数とテストを一度記述し、それらをGoで使用可能なパッケージに入れて、必要に応じて呼び出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、オープンソースについて話しているので、誰かが</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一度</font><font style="vertical-align: inherit;">書くことができればさらに良くなるでしょう</font><font style="vertical-align: inherit;">、そして我々はすべてこの実装を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私は、「ジェネリック」という用語が多くの異なることを意味する可能性があることを言わなければなりません。この記事では、私が上記で説明した「ジェネリック」を意味します。特に、C ++のように、私がリストしたものよりもはるかに多くの機能をサポートするテンプレートを意味するのではありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
について詳しく話しました</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、しかしジェネリックとして書くことができる他の多くの関数があります。例えば：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライス内の最小または最大の要素を検索します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライスの平均または標準偏差を検索します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マップ内のモジュールまたは交差の計算。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードまたはエッジのあるグラフで最短経路を検索します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいスライスまたはマップを返すスライスまたはマップに変換関数を適用する。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの例は、他のほとんどの言語で使用できます。</font><font style="vertical-align: inherit;">実際、このリストはC ++標準ライブラリのテンプレートを見ただけで書きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳格な同時実行サポートを備えたGoに固有の例があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムアウトなしのチャネルからの読み取り。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのチャネルを1つに結合する。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果のスライスを返す関数のリストへの並列呼び出し。</font></font><br>
</li>
<li>     <code>Context</code>,     ,     .<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれらのすべての機能をさまざまなタイプで何度も見ました。 Goで書くのは難しくありません。ただし、すべてのタイプで機能するデバッグされた効率的な実装を再利用する方が良いでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誤解がないことは、これらは単なる例です。ジェネリックを使用して記述する方が簡単で安全な汎用関数は他にもたくさんあります。さらに、上で書いたように、これらは関数だけでなくデータ構造でもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goには、スライスとマップという2つの一般的な汎用データ構造が組み込まれています。これらには、格納および取得される値のタイプの静的な性質をチェックすることで、任意のタイプの値を含めることができます。値は、インターフェースタイプとしてではなく、それ自体によって保存されます。つまり、私がそれを持っている</font></font><code>[]int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、スライスには、インターフェースタイプに変換された数値ではなく、数値自体が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スライスとマップは最も有用な汎用データ構造ですが、それだけではありません。</font><font style="vertical-align: inherit;">その他は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キット。 </font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効率的な挿入とソート順でのトラバーサルを備えた自己バランスツリー。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーのコピーが多数あるマルチカード。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックなしの並列挿入と検索をサポートする競合ハッシュマップ。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリック型を記述できる場合は、スライスやマップと同じ型チェックの利点を持つデータ構造など、新しいデータ構造を定義できます。コンパイラーは、それらに含まれる値の型を静的にチェックでき、値自体を格納できます。 、しかしインターフェース型としてではない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上で述べたようなアルゴリズムを取り、それらを一般的なデータ構造に適用することが可能であるべきです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの例はすべて、</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリック関数と構造が一度記述され、パッケージに配置され、必要に応じて再利用される</font><font style="vertical-align: inherit;">場合と同じ</font><font style="vertical-align: inherit;">です。空のインターフェースタイプの値ではなく、コンパイル時にチェックされる特定のタイプの値を格納する必要がないという意味で、これらはスライスとマップのように機能する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがGoがジェネリックスでできることです。</font><font style="vertical-align: inherit;">ジェネリックスは、コードを共有し、プログラムを簡単にするための効果的な構成要素となります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらを研究することが理にかなっている理由を説明できればと思います。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メリットと価格</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ジェネリック医薬品は</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">レモネードスプリングに</font></a><font style="vertical-align: inherit;">太陽が毎日当たる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビッグロックキャンディマウンテンに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由来するものではありません</font><font style="vertical-align: inherit;">。言語の変更ごとに独自の価格があります。 Goにジェネリックを追加すると、言語が複雑になることは間違いありません。他の変更と同様に、利益を最大化し、価格を最小化することについて話し合う必要があります。</font><font style="vertical-align: inherit;">
囲碁では、互いに自由に組み合わせることができる独立した独立した機能を利用して、複雑さを軽減しようとしました。これらの機能をシンプルにすることで複雑さを軽減し、これらのプロパティの利点を高めながら、自由な組み合わせを提供します。ジェネリックスについても同じようにしたいと思います。</font><font style="vertical-align: inherit;">
具体的には、従わなければならないいくつかの推奨事項を紹介します。</font><b><font style="vertical-align: inherit;">新しい概念を最小限に抑える</font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語に新しい概念をできるだけ少なく追加する必要があります。これは、最小限の量の新しい構文、キーワード、およびその他の項目を意味します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">難易度は、ユーザーではなく、一般的なコードの作成者にあります。</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
難易度は、一般的なパッケージを作成するプログラマーに可能な限り転送する必要があります。私たちは、パッケージのユーザーがジェネリックについて心配することを望んでいません。したがって、ジェネリック関数を自然に呼び出すことができるはずです。つまり、ジェネリックパッケージを使用する際のすべてのエラーを報告して、簡単に理解して修正できるようにする必要があります。一般的なコードで呼び出しをデバッグする簡単な方法もあるはずです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード作成者とユーザーは独立して作業できます</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
汎用コードの作成者とそのユーザーのタスクを簡単に分離できるため、コードを個別に開発できます。少なくとも、他のパッケージの通常の関数の作者とユーザーが心配することはないでしょう。明白なように見えますが、すべての言語ではありませんが、ジェネリックに関してこの条件が満たされています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリと実行の高速化</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
今日のGoパフォーマンスと比較して、アセンブリと実行時間を可能な限り短縮したいと考えています。ジェネリックには、迅速なアセンブリと実行の間でトレードオフがあります。両方のプロセスを可能な限り高速化する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかりやすく簡単に</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要なことは、今Goは単純な言語であることです。</font><font style="vertical-align: inherit;">囲碁プログラムは通常、理解しやすいものです。</font><font style="vertical-align: inherit;">私たちは長い研究の過程で、明快さと単純さを維持しながらジェネリックを追加する可能性を見つけることに大きな注意を払っています。</font><font style="vertical-align: inherit;">私たちは、現在の言語に完全に適合するメカニズムを見つける必要があります。これは、それを完全に別のものに変えることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのガイドラインは、Goでの一般的な実装に従う必要があります。</font><font style="vertical-align: inherit;">これが今日の私の最も重要なメッセージです。ジェネリックスは言語に大きなメリットをもたらすことができますが、Go自体である場合にのみ実装する必要があります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドラフトアーキテクチャ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能だと思います。この記事を締めくくるには、ジェネリックスを実装する必要性とその要件を説明することから、Goでジェネリックスを実装できるアーキテクチャについて説明することに進みたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今年のGopherconで、Robert Griesemerと私</font><font style="vertical-align: inherit;">はGo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汎用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">アーキテクチャのドラフト</font></a><font style="vertical-align: inherit;">を公​​開しました</font><font style="vertical-align: inherit;">。ここではすべての詳細を確認できますが、ここでは要点のみに触れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、関数が実装され</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="go">func Reverse (type Element) (s []Element) {<font></font>
    first := 0<font></font>
    last := len(s) - 1<font></font>
    for first &lt; last {<font></font>
        s[first], s[last] = s[last], s[first]<font></font>
        first++<font></font>
        last--<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の本体はまったく同じですが、署名のみが変更されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スライスアイテムタイプは除外されています。</font><font style="vertical-align: inherit;">これが呼び出さ</font></font><code>Element</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ、いわゆる型パラメーターに変わります。</font><font style="vertical-align: inherit;">スライス型パラメーターの一部ではなく、別のオプションの型パラメーターになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、型パラメーターを指定して関数を呼び出すには、型であることを除いて、他の引数と同じように見える型引数を渡す必要があります。</font></font><br>
<br>
<pre><code class="go">func ReverseAndPrint(s []int) {<font></font>
    Reverse(int)(s)<font></font>
    fmt.Println(s)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font></font><code>(int)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、後の例で示されてい</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いにも、これを含め、ほとんどの場合、コンパイラーは通常の引数の型から型引数を推測できます。型引数について言及する必要はまったくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリック関数の呼び出しは、他の関数の呼び出しと同じように見えます。</font></font><br>
<br>
<pre><code class="go">func ReverseAndPrint(s []int) {<font></font>
    Reverse(s)<font></font>
    fmt.Println(s)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリック関数は</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font></font><code>ReverseInts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ReverseStrings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">比べて少し複雑ですが</font><font style="vertical-align: inherit;">、この複雑さは呼び出し元ではなくコードの作成者にあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">契約</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goは静的に型付けされているため、型パラメーターの型について説明する必要があります。</font><font style="vertical-align: inherit;">この</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタタイプ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ジェネリック関数を呼び出すときに許可される型引数の種類と、型パラメーター値を持つジェネリック関数が実行できる操作の種類をコンパイラーに指示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数</font></font><code>Reverse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、どのタイプのスライスでも</font><font style="vertical-align: inherit;">機能し</font><font style="vertical-align: inherit;">ます。</font></font><code>Element</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goの任意のタイプで機能</font><font style="vertical-align: inherit;">するタイプにのみ値を割り当てることができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この種のジェネリック関数は非常に一般的ですが、型パラメーターについて特別なことを言う必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、別の関数を見てみましょう。</font></font><br>
<br>
<pre><code class="go">func IndexByte (type T Sequence) (s T, b byte) int {<font></font>
    for i := 0; i &lt; len(s); i++ {<font></font>
        if s[i] == b {<font></font>
            return i<font></font>
        }<font></font>
    }<font></font>
    return -1<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、標準ライブラリのバイトと文字列のパッケージに関数が含まれています</font></font><code>IndexByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この関数は、インデックスを返す</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順序で</font><font style="vertical-align: inherit;">文字列またはです</font><font style="vertical-align: inherit;">。この2つの汎用関数を、bytesおよびstringsパッケージの2つの関数に置き換えることができます。実際にはこれはできませんが、これは簡単で便利な例です。</font><font style="vertical-align: inherit;">
次に、パラメータが</font><font style="vertical-align: inherit;">文字列またはとして</font><font style="vertical-align: inherit;">機能する方法を見つける必要があります</font><font style="vertical-align: inherit;">。これ</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">適用して</font><font style="vertical-align: inherit;">、インデックスを付け、インデックス操作の結果を値バイトと比較</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
型パラメーター自体をコンパイルするには</font></font><code>s</code><font style="vertical-align: inherit;"></font><code>s</code><font style="vertical-align: inherit;"></font><code>[]byte</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>T</code><font style="vertical-align: inherit;"></font><code>[]byte</code><font style="vertical-align: inherit;"></font><code>len</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプも必要です。これはメタタイプになりますが、相互に関連するさまざまなタイプを記述する必要がある場合や、メタタイプがジェネリック関数の実装と呼び出し元の間の関係を記述するため、</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コントラクト</font><font style="vertical-align: inherit;">のタイプを呼び出します</font><font style="vertical-align: inherit;">。この場合、契約はと呼ばれ</font></font><code>Sequence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、型パラメーターのリストの後にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><code>Sequence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この例で</font><font style="vertical-align: inherit;">コントラクト</font><font style="vertical-align: inherit;">を定義する方法です。</font></font><br>
<br>
<pre><code class="go">contract Sequence(T) {<font></font>
    T string, []byte<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例は単純なので、すべてが単純</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">型パラメーター</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は文字列またはに</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことができます</font></font><code>[]byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">契約は、パッケージの範囲で認識される新しいキーワードまたは特別な識別子である場合があります。</font><font style="vertical-align: inherit;">ドラフトアーキテクチャのドキュメントから詳細を学ぶことができます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Gophercon 2018で提示し</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えている人は、</font><font style="vertical-align: inherit;">この契約の書き方がはるかに簡単であることに気付くでしょう。</font><font style="vertical-align: inherit;">以前のバージョンについては多くのフィードバックがあり、契約ははるかに複雑であり、要望を考慮に入れようとしました。</font><font style="vertical-align: inherit;">新しい契約は、作成、読み取り、理解がはるかに簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントラクトを使用すると、型パラメーターの型や型パラメーターのメソッドのリストを指定できます。</font><font style="vertical-align: inherit;">コントラクトを使用すると、異なる型パラメーター間の関係を記述することもできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドとの契約</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font></font><code>[]string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のすべての要素の文字列表現</font><font style="vertical-align: inherit;">を返す</font><font style="vertical-align: inherit;">関数のもう1つの簡単な例を次に示し</font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="go">func ToStrings (type E Stringer) (s []E) []string {<font></font>
    r := make([]string, len(s))<font></font>
    for i, v := range s {<font></font>
        r[i] = v.String()<font></font>
    }<font></font>
    return r<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純です。スライスを調べ、</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各要素</font><font style="vertical-align: inherit;">のメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">、結果の文字列値を含むスライスを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数には、メソッドを実装するための要素タイプが必要</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">そして契約</font></font><code>Stringer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれを保証します。</font></font><br>
<br>
<pre><code class="go">contract Stringer(T) {<font></font>
    T String() string<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
契約には</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メソッドを実装する必要が</font><font style="vertical-align: inherit;">あると記載されてい</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコントラクトがインターフェイスのように見えることに気付いたかもしれ</font><font style="vertical-align: inherit;">ません</font><font style="vertical-align: inherit;">。</font></font><code>fmt.Stringer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の引数が</font></font><code>ToStrings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライスで</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">ことを指摘する必要があり</font><font style="vertical-align: inherit;">ます</font></font><code>fmt.Stringer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはあるタイプの要素のスライスであり、要素のタイプはimplements </font></font><code>fmt.Stringer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">要素とスライスのタイプのスライスメモリ表現</font></font><code>fmt.Stringer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は通常異なり、Goはそれらの間の直接変換をサポートしていません。</font><font style="vertical-align: inherit;">したがって、たとえ</font></font><code>fmt.Stringer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在し</font><font style="vertical-align: inherit;">ていても、怠惰で執筆しない方が良いでしょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数タイプの契約</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、いくつかの型パラメーターを持つコントラクトの例です。</font></font><br>
<br>
<pre><code class="go">type Graph (type Node, Edge G) struct { ... }<font></font>
<font></font>
contract G(Node, Edge) {<font></font>
    Node Edges() []Edge<font></font>
    Edge Nodes() (from Node, to Node)<font></font>
}<font></font>
<font></font>
func New (type Node, Edge G) (nodes []Node) *Graph(Node, Edge) {<font></font>
    ...<font></font>
}<font></font>
<font></font>
func (g *Graph(Node, Edge)) ShortestPath(from, to Node) []Edge {<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ノードとエッジから構成されるグラフについて説明します。</font><font style="vertical-align: inherit;">特定のデータ構造は必要ありません。</font><font style="vertical-align: inherit;">代わりに、型に</font></font><code>Node</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、に</font></font><code>Edges</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続されて</font></font><code>Node</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">エッジのリストを返す</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">含まれている必要がある</font><font style="vertical-align: inherit;">と言い</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、型に</font><font style="vertical-align: inherit;">は2つの</font><font style="vertical-align: inherit;">接続されたもの</font><font style="vertical-align: inherit;">を返す</font></font><code>Edge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font></font><code>Nodes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">
私は実装を省略し、ここでは関数の署名である</font><font style="vertical-align: inherit;">こと戻り</font><font style="vertical-align: inherit;">、およびメソッドのシグネチャ</font><font style="vertical-align: inherit;">における</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
重要な結論は、契約が必ずしも1つのタイプを参照しているわけではないということです。</font><font style="vertical-align: inherit;">2つ以上のタイプ間の関係を記述できます。</font></font><code>Nodes</code><font style="vertical-align: inherit;"></font><code>Edge</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>New</code><font style="vertical-align: inherit;"></font><code>Graph</code><font style="vertical-align: inherit;"></font><code>ShortestPath</code><font style="vertical-align: inherit;"></font><code>Graph</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注文したタイプ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意外とよく機能の欠如について文句を言います</font></font><code>Min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さて、または</font></font><code>Max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その理由は、便利な関数</font></font><code>Min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は順序付けされた型でのみ</font><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">する必要がある、つまり、ジェネリックである必要があるためです。</font><font style="vertical-align: inherit;">自分で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書く</font></font><code>Min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のは非常に簡単なので、有用な一般的な実装があれば、この関数を標準ライブラリに追加できるはずです。</font><font style="vertical-align: inherit;">これが私たちのアーキテクチャでどのように見えるかです：</font></font><br>
<br>
<pre><code class="go">func Min (type T Ordered) (a, b T) T {<font></font>
    if a &lt; b {<font></font>
        return a<font></font>
    }<font></font>
    return b<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
契約</font></font><code>Ordered</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、型を</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注文する必要があることを</font><font style="vertical-align: inherit;">示しています。つまり、</font><font style="vertical-align: inherit;">契約</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">「より小」、「より大」などの演算子をサポートしています。</font></font><br>
<br>
<pre><code class="go">contract Ordered(T) {<font></font>
    T int, int8, int16, int32, int64,<font></font>
        uint, uint8, uint16, uint32, uint64, uintptr,<font></font>
        float32, float64,<font></font>
        string<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントラクト</font></font><code>Ordered</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、言語によって定義されたすべての順序付けされたタイプのリストです。コントラクトは、リストからの任意のタイプ、またはリストからのいくつかのタイプに基づく名前付きタイプを受け入れます。実際、どのタイプも「より小」演算子で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての演算子で機能する新しい表記法を考案するよりも、小なり演算子をサポートするタイプをリストする方がはるかに簡単です。最後に、Goでは、ステートメントは組み込み型でのみサポートされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じアプローチを任意の演算子に適用できます。より一般的には、組み込み型で機能する汎用関数のコントラクトを作成することもできます。</font><font style="vertical-align: inherit;">これにより、ジェネリック関数を作成する人は誰でも、関数を使用する必要があるタイプのセットを明示的に指定できます。</font><font style="vertical-align: inherit;">これにより、ジェネリック関数の呼び出し元は、関数が使用される型に適用できるかどうかを明確に確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、この契約は標準ライブラリに該当する可能性があります。</font><font style="vertical-align: inherit;">そのため、関数</font></font><code>Min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（おそらく標準ライブラリにも含まれる）は次のようになります。</font><font style="vertical-align: inherit;">ここでは、単に</font></font><code>Ordered</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージコントラクトで定義された</font><font style="vertical-align: inherit;">コントラクトを参照し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="go">func Min (type T contracts.Ordered) (a, b T) T {<font></font>
    if a &lt; b {<font></font>
        return a<font></font>
    }<font></font>
    return b<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なデータ構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、単純な汎用データ構造であるバイナリツリーを見てみましょう。</font><font style="vertical-align: inherit;">この例では、ツリーに比較関数が含まれているため、要素タイプの要件はありません。</font></font><br>
<br>
<pre><code class="go">type Tree (type E) struct {<font></font>
    root    *node(E)<font></font>
    compare func(E, E) int<font></font>
}<font></font>
<font></font>
type node (type E) struct {<font></font>
    val         E<font></font>
    left, right *node(E)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、新しいバイナリツリーが作成されます。</font><font style="vertical-align: inherit;">比較関数が関数に渡されます</font></font><code>New</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="go">func New (type E) (cmp func(E, E) int) *Tree(E) {<font></font>
    return &amp;Tree(E){compare: cmp}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エクスポートされていないメソッド</font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、それ</font><font style="vertical-align: inherit;">を含むスロット</font><font style="vertical-align: inherit;">またはツリー内の移動先の場所</font><font style="vertical-align: inherit;">へのポインターを返します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="go">func (t *Tree(E)) find(v E) **node(E) {<font></font>
    pn := &amp;t.root<font></font>
    for *pn != nil {<font></font>
        switch cmp := t.compare(v, (*pn).val); {<font></font>
        case cmp &lt; 0:<font></font>
            pn = &amp;(*pn).left<font></font>
        case cmp &gt; 0:<font></font>
            pn = &amp;(*pn).right<font></font>
        default:<font></font>
            return pn<font></font>
        }<font></font>
    }<font></font>
    return pn<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にこのコードをテストしていないという事実を踏まえると、この場合の詳細は重要ではありません。</font><font style="vertical-align: inherit;">私は単純な一般的なデータ構造の記述がどのように見えるかを示しているだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、ツリーに値が含まれているかどうかをテストします。</font></font><br>
<br>
<pre><code class="go">func (t *Tree(E)) Contains(v E) bool {<font></font>
    return *t.find(e) != nil<font></font>
}<font></font>
This is the code for inserting a new value.<font></font>
func (t *Tree(E)) Insert(v E) bool {<font></font>
    pn := t.find(v)<font></font>
    if *pn != nil {<font></font>
        return false<font></font>
    }<font></font>
    *pn = &amp;node(E){val: v}<font></font>
    return true<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードタイプの</font><font style="vertical-align: inherit;">
タイプ引数</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが、一般的なデータ構造の記述方法です。</font><font style="vertical-align: inherit;">型引数が散在していることを除いて、通常のGoコードと同じように記述されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーの使用は簡単です。</font></font><br>
<br>
<pre><code class="go">var intTree = tree.New(func(a, b int) int { return a - b })<font></font>
<font></font>
func InsertAndCheck(v int) {<font></font>
    intTree.Insert(v)<font></font>
    if !intTree.Contains(v) {<font></font>
        log.Fatalf("%d not found after insertion", v)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そうなるはずです。</font><font style="vertical-align: inherit;">サポートされている型の型引数を明示的に指定する必要があることが多いため、一般的なデータ構造の記述は少し複雑です。</font><font style="vertical-align: inherit;">しかし、そのような構造の可能な最大の使用は、通常の非ジェネリックデータ構造の使用と違いはありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のステップ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアーキテクチャを試すことができる実際の実装に取り​​組んでいます。実際にテストして、私たちが望むようにそのようなプログラムを作成できることを確認することが重要です。作業は期待したほど速く進んでいませんが、これらの実装に関する新しい情報が届き次第、詳細をお知らせします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Robert Grismerが</font><font style="vertical-align: inherit;">、go / typesパッケージを変更</font><font style="vertical-align: inherit;">する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備用CL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">作成しました</font></a><font style="vertical-align: inherit;">。これにより、ジェネリックスとコントラクトを使用するコードが型チェックを実行できるかどうかをテストできます。作業はまだ完了していませんが、1つのパッケージでこの機能はほとんどの場合機能します。開発を継続します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装とその後の実装の助けを借りて、人々は汎用コードを記述して使用しようとし、何が起こるかを確認したいと思います。私たちは、人々が必要なコードを記述できること、そして期待どおりにそれを使用できることを確認したいと考えています。もちろん、最初はすべてがうまくいくわけではなく、私たちが働いているときに何かを変えます。また、構文の詳細よりもセマンティクスのフィードバックに非常に関心があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のアーキテクチャーについてコメントしてくれた皆さん、およびGoでジェネリックが出現する可能性について話し合った皆さんに感謝します。私たちはすべてのコメントを読み、あなたの仕事にとても感謝しています。彼がいなかったら、私たちは私たちが来たものに到達しなかっただろう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの目標は、言語を複雑にしすぎて使用するのが複雑になったり、Goのように感じられなくなったりすることなく、上記で検討したさまざまな汎用コードを記述できるアーキテクチャを作成することです。</font><font style="vertical-align: inherit;">このアーキテクチャが目標に向けた一歩であることを願っており、私たちとあなたの経験に基づいて、機能するものと機能しないものに基づいて改善を続けます。</font><font style="vertical-align: inherit;">この目標を達成すれば、Goの将来のバージョンに何かを提供することができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462797/index.html">雲についても、プロだけでなく</a></li>
<li><a href="../ja462799/index.html">開始時のRAVISとDAB。DRMは気分を害しました。ロシア連邦のデジタルラジオの奇妙な未来</a></li>
<li><a href="../ja462803/index.html">あるERPシステムから別のシステムへの移行</a></li>
<li><a href="../ja462805/index.html">分析：取引所での取引時に実際にお金が保護される方法</a></li>
<li><a href="../ja462807/index.html">WinForms：エラー、ホームズ</a></li>
<li><a href="../ja462813/index.html">エカテリンブルク、8月14日-アトラシアンユーザーグループのミタップ</a></li>
<li><a href="../ja462815/index.html">私の俳句3日目：全体像が形になり始めます</a></li>
<li><a href="../ja462817/index.html">Kotlin / Everywhere Report-ショーケースプラクティス：7月31日</a></li>
<li><a href="../ja462819/index.html">CISにおける言語教育の欠陥：ポリグロットビュー</a></li>
<li><a href="../ja462821/index.html">まだ存在しないコンピューターを評価する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>