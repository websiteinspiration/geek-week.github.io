<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌀 ↔️ 🚣🏿 写真のOOP 👨🏽‍🎨 🧓🏼 🤳🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OOP（オブジェクト指向プログラミング）は、多くの近代的なプロジェクトの開発に不可欠な要素になっていますが、その人気にもかかわらず、このパラダイムは唯一のものではありません。他のパラダイムとの連携方法をすでに知っていて、OOPオカルティズムに慣れたい場合は、少し前に2メガバイトの写真とアニメーション...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>写真のOOP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463125/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP（オブジェクト指向プログラミング）は、多くの近代的なプロジェクトの開発に不可欠な要素になっていますが、その人気にもかかわらず、このパラダイムは唯一のものではありません。</font><font style="vertical-align: inherit;">他のパラダイムとの連携方法をすでに知っていて、OOPオカルティズムに慣れたい場合は、少し前に2メガバイトの写真とアニメーションを用意してください。</font><font style="vertical-align: inherit;">変圧器は例として役立ちます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/6p/vj/uz6pvjyue0ifmhkhy-h6bpflgwk.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に答えることはなぜですか？オブジェクト指向のイデオロギーは、エンティティの動作をそのデータに関連付け、実際のオブジェクトとビジネスプロセスをプログラムコードに投影する試みとして開発されました。このようなコードは、周囲の世界を相互に作用する多数のオブジェクトとして認識し、特定の分類に従うことが一般的であるため、人にとって読みやすく理解しやすいと考えられていました。イデオロギーが目標を達成することは可能ですか、明確に答えることは困難ですが、実際にはプログラマーがOOPを必要とする多くのプロジェクトがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPがプログラムの作成を奇跡的にスピードアップするとは考えないでください。また、Villariboの居住者がOOPプロジェクトをすでに機能させており、Villabaggioの住民がまだ大胆なスパゲッティコードを洗濯している状況を予期してはなりません。ほとんどの場合、これはそうではなく、時間は開発段階ではなく、サポート段階（拡張、変更、デバッグ、およびテスト）、つまり長期的に節約されます。後続のサポートを必要としない1回限りのスクリプトを作成する必要がある場合、このタスクのOOPはおそらく役に立たないでしょう。ただし、最新のプロジェクトのライフサイクルの重要な部分は、正確にサポートと拡張です。 OOPが存在するだけでアーキテクチャが完璧になるわけではなく、逆に不必要な複雑化につながる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPプログラムのパフォーマンスに関する批判に遭遇する場合があります。確かに、わずかなオーバーヘッドが存在しますが、ほとんどの場合それは無視できるため、利点のために無視できます。それでも、1秒あたり数百万のオブジェクトが1つのスレッドで作成または処理されるボトルネックでは、少なくともOOPの必要性を修正する価値があります。そのような量の最小限のオーバーヘッドでもパフォーマンスに大きな影響を与える可能性があるためです。プロファイリングは、違いを捉えて決定を下すのに役立ちます。他の場合、たとえば、速度の大きな部分がIOにかかっている場合、オブジェクトの破棄は時期尚早の最適化になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクト指向プログラミングは、その性質上、例を使用して説明するのが最適です。</font><font style="vertical-align: inherit;">約束どおり、患者は変圧器になります。</font><font style="vertical-align: inherit;">私はトランスフォーマーではなく、漫画も読んだことがないので、例ではウィキペディアとファンタジーに案内されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスとオブジェクト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに叙情的な余談：オブジェクト指向のアプローチはクラスがなくても可能ですが、私たちは、クラスが私たちのすべてである古典的なスキームである駄洒落をお詫びします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単な説明：クラスはトランスフォーマーの描画であり、このクラスのインスタンスはOptimus PrimeやOlegなどの特定のトランスフォーマーです。そして、それらは1つの図面に従って組み立てられていますが、同じように歩いたり、変形したり、撮影したりできますが、どちらも独自の状態を持っています。状態は一連の変化するプロパティです。したがって、同じクラスの2つの異なるオブジェクトで、異なる名前、年齢、場所、充電レベル、弾薬の量などを観察できます。これらのプロパティとそのタイプの存在そのものがクラスで説明されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、クラスは、オブジェクトが持つプロパティと動作の記述です。そしてオブジェクトは、これらのプロパティの独自の状態を持つインスタンスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは「特性と振る舞い」と言いますが、それはどういうわけか抽象的で理解不能に聞こえます。プログラマにとっては、「変数と関数」のように聞こえる方が身近になります。実際、「プロパティ」は同じ通常の変数であり、単にいくつかのオブジェクトの属性です（オブジェクトフィールドと呼ばれます）。同様に、「動作」はオブジェクトの機能（メソッドと呼ばれます）であり、オブジェクトの属性でもあります。オブジェクトのメソッドと通常の関数の違いは、メソッドがフィールドを介して独自の状態にアクセスできることだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、属性であるメソッドとプロパティがあります。属性の操作方法は？ほとんどのPLでは、属性参照演算子がポイントです（PHPおよびPerlを除く）。それは次のようになります（疑似コード）：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//       class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Transformer</span>(){
    <span class="hljs-comment">//   x</span>
    <span class="hljs-keyword">int</span> x<font></font>
<font></font>
    <span class="hljs-comment">//    (     0)</span>
    <span class="hljs-function">function <span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x</span>)</span>{
        <span class="hljs-comment">//   x </span>
        <span class="hljs-comment">// (  0    )</span>
        <span class="hljs-keyword">this</span>.x = x<font></font>
    }<font></font>
	<font></font>
    <span class="hljs-comment">//   run</span>
    <span class="hljs-function">function <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//      this</span>
        <span class="hljs-keyword">this</span>.x += <span class="hljs-number">1</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//    :</span><font></font>
<font></font>
<span class="hljs-comment">//        0</span>
optimus = <span class="hljs-keyword">new</span> Transformer(<span class="hljs-number">0</span>)<font></font>
<font></font>
optimus.run() <span class="hljs-comment">//   </span>
print optimus.x <span class="hljs-comment">//  1</span>
optimus.run() <span class="hljs-comment">//     </span>
print optimus.x <span class="hljs-comment">//  2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写真では、次の表記法を使用します</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/hf/qk/wihfqkqpsbaalsirv7f_a3qyig0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。UML図は使用しませんでした。ただし、柔軟性は高くなりますが、視覚的には不十分であるためです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vi/uy/h2/viuyh29qu7ln_eq4eqyn5slkk0a.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションNo. 1</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コードから何が見えるか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オブジェクトがメソッドから独自の属性にアクセスできるようにする特別なローカル変数（メソッド内）です。トランスフォーマーが独自のメソッドを呼び出したり、独自の状態を変更したりするときだけに注意を向けます。呼び出しがこのように見える場合：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimus.x</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に内側から、オプティマスが自分のフィールドxに自分でアクセスする場合、彼のメソッドでは呼び出しは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this.xの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようになります</font><font style="vertical-align: inherit;">。つまり、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私（Optimus）は属性xを参照します。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"。ほとんどの言語では、この変数はthisと呼ばれますが、例外があります（たとえば、self）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンストラクター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オブジェクトの作成時に自動的に呼び出される特別なメソッドです</font><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">コンストラクター</font></b><font style="vertical-align: inherit;">は、他のメソッドと同様に任意の引数を取ることができます。すべての言語で、コンストラクター種類や__init__ __construct名前を予約しますが、デザイナーの名前でどこかには、クラスのコンストラクタ目的の名前と一致する必要があり、どこか、具体的にその名が示す- 。必要なフィールドに記入し、元のオブジェクトの初期化を生成するために... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの新しいインスタンスを作成するために使用する必要があるキーワードです。</font><font style="vertical-align: inherit;">この時点で、オブジェクトが作成され、コンストラクターが呼び出されます。</font><font style="vertical-align: inherit;">この例では、トランスフォーマーの開始位置として0がコンストラクターに渡されます（これは前述の初期化です）。</font><font style="vertical-align: inherit;">一部の言語では新しいキーワードが欠落しており、クラスを関数として呼び出そうとすると、コンストラクターが自動的に呼び出されます（例：Transformer（））。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. </font><font style="vertical-align: inherit;">コンストラクターと実行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は内部状態で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作し</font><b><font style="vertical-align: inherit;">ます</font></b><b><font style="vertical-align: inherit;">が、他のすべての点で通常の関数と違いはありません</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">宣言の構文も一致します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.クラスは、状態を必要としないメソッドを所有している可能性があり、その結果、オブジェクトを作成します。</font><font style="vertical-align: inherit;">この場合、メソッドは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">staticに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なり</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Srp</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（単一責任原則/ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLIDの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一原則</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">あなたはおそらく他のパラダイムからすでにそれに精通しています：「1つの関数は1つの完了したアクションのみを実行するべきです」。</font><font style="vertical-align: inherit;">この原則はクラスにも当てはまります。「1つのクラスが1つのタスクに責任を持つ必要があります。」</font><font style="vertical-align: inherit;">残念ながら、クラスでは、原則に違反するために交差する必要がある線を定義することはより困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニオンなしの1文でクラスの目的を説明することにより、この原則を形式化しようとする試みがありますが、これは非常に物議を醸す手法なので、直感を信頼し、極端に急いではいけません。</font><font style="vertical-align: inherit;">クラスからスイスナイフを作る必要はありませんが、1つのメソッドで100万のクラスを作成するのも愚かです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">協会</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来、オブジェクトのフィールドには、標準タイプの通常の変数だけでなく、他のオブジェクトも格納できます。そして、これらのオブジェクトは他のオブジェクトなどを格納し、オブジェクトのツリー（時にはグラフ）を形成します。この関係を関連付けと呼びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの変圧器に銃が装備されているとします。いいえ、ただし2門の銃の方が適しています。それぞれの手で。銃は同じです（同じクラスに属しているか、必要に応じて1つの図面に従って作成されています）。どちらも同じように射撃と装填が可能ですが、それぞれに独自の弾薬保管庫（独自の状態）があります。 OOPでそれをどのように説明しますか？関連付けによって：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Gun</span>(){ <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">int</span> ammo_count <span class="hljs-comment">//   </span><font></font>
<font></font>
    <span class="hljs-function">function <span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">// </span>
        <span class="hljs-keyword">this</span>.reload() <span class="hljs-comment">//    ""</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">function <span class="hljs-title">fire</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">//    ""</span>
        <span class="hljs-keyword">this</span>.ammo_count -= <span class="hljs-number">1</span> <span class="hljs-comment">//     </span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">function <span class="hljs-title">reload</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">//   ""</span>
        <span class="hljs-keyword">this</span>.ammo_count = <span class="hljs-number">10</span> <span class="hljs-comment">//    </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Transformer</span>(){ <span class="hljs-comment">//   </span>
    Gun gun_left <span class="hljs-comment">//   " "  </span>
    Gun gun_right <span class="hljs-comment">//   " "   </span><font></font>
    <font></font>
    <span class="hljs-comment">/*
       
           ,
      
    */</span>
    <span class="hljs-function">function <span class="hljs-title">constructor</span>(<span class="hljs-params">Gun gun_left, Gun gun_right</span>)</span>{
        <span class="hljs-keyword">this</span>.gun_left = gun_left <span class="hljs-comment">//     </span>
        <span class="hljs-keyword">this</span>.gun_right = gun_right <span class="hljs-comment">//     </span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">//    "",   ...</span>
    <span class="hljs-function">function <span class="hljs-title">fire</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//  ,    ""</span>
        <span class="hljs-keyword">this</span>.gun_left.fire()
        <span class="hljs-comment">//    ,     ""</span>
        <span class="hljs-keyword">this</span>.gun_right.fire()<font></font>
    }<font></font>
}<font></font>
<font></font>
gun1 = <span class="hljs-keyword">new</span> Gun() <span class="hljs-comment">//   </span>
gun2 = <span class="hljs-keyword">new</span> Gun() <span class="hljs-comment">//   </span>
optimus = <span class="hljs-keyword">new</span> Transformer(gun1, gun2) <span class="hljs-comment">//  ,    </span>
</code></pre><br>
<img src="https://habrastorage.org/webt/-t/cv/aa/-tcvaa8gtnipg_ridjunpf9b1tu.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーション＃2</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
this.gun_left.fire（）とthis.gun_right.fire（）は、ドットでも発生する子オブジェクトの呼び出しです。最初のポイントでは、自分自身の属性（this.gun_right）に切り替え、gunオブジェクトを取得します。2番目のポイントでは、gunオブジェクトのメソッド（this.gun_right.fire（））に切り替えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論：ロボットが作成され、サービス兵器が発行されました。ここで何が起こっているかを理解します。このコードでは、1つのオブジェクトが別のオブジェクトの不可欠な部分になっています。これが協会です。次に、2つのタイプがあります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-変圧器工場でオプティマスを収集しているときに、両方の銃が釘で手にしっかりと固定されており、オプティマスの死後、銃は彼とともに死にました。</font><font style="vertical-align: inherit;">つまり、子供のライフサイクルは親のライフサイクルと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アグリゲーション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -銃が彼の手にある銃として発行され、オプティマスの死後、同志のオレグがこの銃を手に取って手に取るか、質屋に変える場合。</font><font style="vertical-align: inherit;">つまり、子オブジェクトのライフサイクルは親のライフサイクルに依存せず、他のオブジェクトで使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正教会のOOP教会は私たちに基本的な三位一体を教えてい</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カプセル化、多態性、継承</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト指向のアプローチ全体が基づいています。</font><font style="vertical-align: inherit;">順番に並べましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9s/gq/ch/9sgqchcuzrso9iesrjn7vkw9opw.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承は、逆説的に聞こえるかもしれませんが、他のクラスのプロパティと動作をクラスによって継承して、さらに拡張または変更できるようにするシステムメカニズムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じトランスフォーマーにスタンプを付けたくないが、共通のフレームを作成したいが、ボディキットが異なる場合はどうなるでしょうか。 OOPを使用すると、ロジックを類似点と相違点に分割し、親クラスの類似点と子孫クラスの相違点を削除することで、そのようないたずらが可能になります。それはどのように見えますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimus PrimeとMegatronはどちらも変圧器ですが、1つはオートボットで、もう1つはデストロンです。</font><font style="vertical-align: inherit;">サイバトロンとデストロンの違いは、サイバトロンが自動車に、そしてデストロンが航空に変換されるという事実だけにあると仮定します。</font><font style="vertical-align: inherit;">他のすべてのプロパティと動作は何の違いもありません。</font><font style="vertical-align: inherit;">この場合、継承システムを次のように設計できます。共通の機能（実行、射撃）は基本クラスのトランスフォーマーで記述され、違い（変換）は2つの子クラスオートボットとディセプティコンで記述されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Transformer</span>(){ <span class="hljs-comment">//  </span>
    <span class="hljs-function">function <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// ,   </span><font></font>
    }<font></font>
    <span class="hljs-function">function <span class="hljs-title">fire</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// ,   </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Autobot</span>(<span class="hljs-title">Transformer</span>){ <span class="hljs-comment">//  ,   Transformer</span>
    <span class="hljs-function">function <span class="hljs-title">transform</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// ,     </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Decepticon</span>(<span class="hljs-title">Transformer</span>){ <span class="hljs-comment">//  ,   Transformer</span>
    <span class="hljs-function">function <span class="hljs-title">transform</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// ,     </span><font></font>
    }<font></font>
}<font></font>
<font></font>
optimus = <span class="hljs-keyword">new</span> Autobot()<font></font>
megatron = <span class="hljs-keyword">new</span> Decepticon()<font></font>
<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/qj/jo/mg/qjjomgocinjckd5kxjmubl1gzqc.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーション№3</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この例は、継承が</font><font style="vertical-align: inherit;">親クラスを使用して</font><font style="vertical-align: inherit;">コード（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRY原則</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">重複排除する方法の1つになると</font><font style="vertical-align: inherit;">同時に、子孫クラスでミュー</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;">テーションの</font></i></a><font style="vertical-align: inherit;">機会を提供する方法を示しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過負荷</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
親クラスの親クラスの既存のメソッドをオーバーライドすると、オーバーロードが機能します。</font><font style="vertical-align: inherit;">これにより、親クラスの動作を補足するのではなく、変更することができます。</font><font style="vertical-align: inherit;">メソッドの呼び出し時またはオブジェクトのフィールドへのアクセス時に、属性の検索は、子孫からルートそのもの（親）まで行われます。</font><font style="vertical-align: inherit;">つまり、オートボットでfire（）メソッドが呼び出されると、そのメソッドは最初に子孫クラスであるオートボットで検索され、そこにないため、検索が1つ上に移動し、Transformerクラスで検出されて呼び出されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不適切な使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承の階層が過度に深いと、逆の効果につながる可能性があることに興味があります。誰から誰が継承され、どの場合にどのメソッドが呼び出されるかを理解しようとすると、複雑になります。さらに、継承を使用してすべてのアーキテクチャ要件を実装できるわけではありません。したがって、継承は狂信なしに適用されるべきです。必要に応じて、継承よりも好ましい構成を要求する推奨事項があります。私が出会った継承への批判は、継承が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴールデンハンマー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として使用された場合の失敗例によって強化され</font><font style="vertical-align: inherit;">ます。しかし、これは継承が原則として常に有害であることをまったく意味しません。私の麻酔科医は、最初のステップはあなたが相続に依存していることを認めることであると述べました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのエンティティの関係を説明するとき、継承が適切な場合と構成が適切な場合 </font><font style="vertical-align: inherit;">あなたは人気のチートシートを使うことができます：自問してください、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティAはBの本質</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font><font style="vertical-align: inherit;">そうであれば、おそらく継承が適切です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティAがエンティティBの一部である</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、選択するのは構成です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの状況に関連して、それはこのように聞こえるでしょう：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オートボットは変圧器ですか？</font><font style="vertical-align: inherit;">はい、私たちは継承を選択します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">銃はトランスフォーマーの一部ですか？</font><font style="vertical-align: inherit;">はい、それは構成を意味します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルフテストの場合は、逆の組み合わせを試してみてください。ゴミが表示されます。</font><font style="vertical-align: inherit;">このチートシートはほとんどの場合に役立ちますが、構成と継承のどちらを選択するかを決定する際に信頼すべき他の要素があります。</font><font style="vertical-align: inherit;">さらに、これらの方法を組み合わせて、さまざまなタイプの問題を解決できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承は静的です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承と構成のもう1つの重要な違いは、継承は本質的に静的であり、解釈/コンパイル段階でのみクラスの関係を確立することです。</font><font style="vertical-align: inherit;">例で見たように、コンポジションは実行時にエンティティの関係を即座に変更できるようにします-これは非常に重要な場合があるため、関係を選択するときにこれを覚えておく必要があります（もちろん、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタプログラミング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用したい場合は除きます</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多重継承</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのクラスが共通の子孫から継承される状況を調べました。</font><font style="vertical-align: inherit;">しかし、一部の言語では、逆のことができます。2つ以上の親から1つのクラスを継承し、それらのプロパティと動作を組み合わせます。</font><font style="vertical-align: inherit;">1つではなく複数のクラスから継承する機能は、多重継承です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aq/xd/5e/aqxd5e1n1bauunzhp0necdbsws4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、イルミナティのサークルでは、多重継承は罪であり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダイヤモンドのような問題</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とデザイナーとの混乱を伴う</font><font style="vertical-align: inherit;">という見解があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">さらに、多重継承によって解決できるタスクは、インターフェイスメカニズム（これについても説明します）などの他のメカニズムによって解決できます。</font><font style="vertical-align: inherit;">しかし、公平に言うと、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不純物</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の実装には多重継承が便利</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象クラス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のクラスに加えて、いくつかの言語では抽象言語が存在します。</font><font style="vertical-align: inherit;">通常のクラスとは異なり、そのようなクラスのオブジェクトを作成することはできません。</font><font style="vertical-align: inherit;">なぜ私たちはそのようなクラスが必要なのですか、読者は尋ねますか？</font><font style="vertical-align: inherit;">子孫がそこから継承できるようにするために必要です-オブジェクトが既に作成されている通常のクラス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象クラスには、通常のメソッドとともに、実装のない（署名あり、コードなしの）抽象メソッドが含まれ、子孫クラスを作成することを計画しているプログラマーが実装する必要があります。</font><font style="vertical-align: inherit;">抽象クラスは必須ではありませんが、メモリ不足のプログラマを実装エラーから保護するために、特定のメソッドセットの実装を必要とするコントラクトを確立するのに役立ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポリモーフィズム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポリモーフィズムは、1つのインターフェースの多くの実装を可能にするシステムプロパティです。はっきりしない。トランスフォーマーを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプティマス、メガトロン、オレグの3つのトランスがあるとします。トランスフォーマーは戦闘なので、攻撃（）メソッドがあります。プレーヤーがジョイスティックの「ファイト」ボタンを押すと、プレーヤーがプレイしているトランスフォーマーのattack（）メソッドを呼び出すようにゲームに指示します。しかし、トランスフォーマーは異なり、ゲームが面白いので、トランスフォーマーはそれぞれ何らかの方法で攻撃します。 OptimusがAutobotクラスのオブジェクトであり、Autobotがプルトニウム弾頭を備えた大砲を備えているとしましょう（そうです、変圧器のファンは怒っていません）。メガトロンはデストロンであり、プラズマ銃から発砲します。オレグはベースプレイヤーで、彼は彼を名前と呼んでいます。そして、用途は何ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例でのポリモーフィズムの使用は、ゲームコードがそのリクエストの実装について何も知らないということです。どのように攻撃するかは、そのタスクは単にすべてのキャラクタークラスで同じシグネチャを持つattack（）メソッドを呼び出すことです。</font><font style="vertical-align: inherit;">これにより、ゲームのコードを変更せずに、新しいキャラクタークラスを追加したり、既存のメソッドを変更したりできます。</font><font style="vertical-align: inherit;">快適です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カプセル化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カプセル化とは、オブジェクトのフィールドとメソッドへのアクセスを制御することです。</font><font style="vertical-align: inherit;">アクセス制御は、可能な/重要でないだけでなく、さまざまな検証、読み込み、計算、およびその他の動的な動作も意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの言語では、データの非表示はカプセル化の一部です。</font><font style="vertical-align: inherit;">これには、アクセス修飾子があります（ほとんどすべてのOOP言語の修飾子について説明します）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publi-誰でも属性にアクセスできます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">private-このクラスのメソッドのみが属性にアクセスできます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保護-プライベートと同じ、クラスの相続人だけがアクセスできます。</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Transformer</span>(){
    <span class="hljs-function"><span class="hljs-keyword">public</span> function <span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> function <span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> function <span class="hljs-title">dance</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクセス修飾子の選択方法は？</font><font style="vertical-align: inherit;">このような最も単純なケースでは、メソッドが外部コードにアクセスできる必要がある場合は、publicを選択します。</font><font style="vertical-align: inherit;">それ以外の場合は、プライベートです。</font><font style="vertical-align: inherit;">継承がある場合、メソッドを外部から呼び出さないで、子孫から呼び出す必要がある場合は、protectedが必要になることがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクセサー（ゲッターとセッター）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲッターとセッターは、フィールドへのアクセスを制御することをタスクとするメソッドです。ゲッターはフィールドの値を読み取って返し、逆にセッターはその値を引数として取り、フィールドに書き込みます。これは、そのような方法に追加の治療を提供することを可能にする。たとえば、セッターは、オブジェクトフィールドに値を書き込むときに、タイプまたは値が有効な値の範囲内にあるかどうかを確認できます（検証）。ゲッターでは、実際の値が実際にデータベース内にある場合は、遅延初期化またはキャッシュを追加できます。多くのアプリケーションを発明できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の言語には、そのようなアクセサーをプロパティとしてマスクできる構文シュガーがあり、外部コードに対してアクセスを透過的にします。これにより、フィールドではなくSQLクエリを実行したり、内部のファイルからファイルを読み込んだりする方法で動作することは疑いません。</font><font style="vertical-align: inherit;">これが抽象化と透明性を実現する方法です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェイスのタスクは、エンティティの相互依存性のレベルを下げて、抽象化を追加することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての言語がこのメカニズムを備えているわけではありませんが、静的型付けのないOOP言語では、それらは実際には悪いでしょう。上記では、いくつかの抽象メソッドの実装が義務付けられているコントラクトのトピックに触れながら、抽象クラスを調べました。そのため、インターフェースは抽象クラスに非常によく似ていますが、それはクラスではなく、抽象メソッドの列挙を持つダミーです（実装なし）。言い換えれば、インターフェースは本質的に宣言型です。つまり、少しのコードなしでクリーンなコントラクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、インターフェースを持つ言語には複数のクラス継承はありませんが、複数のインターフェース継承があります。これにより、クラスは、実装がコミットされているインターフェースをリストできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェイスを持つクラスは、多対多の関係で構成されます。単一のクラスが複数のインターフェイスを実装でき、各インターフェイスは、多くのクラスによって実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースには両面使用があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェースの片側には、このインターフェースを実装するクラスがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一方、このインターフェースを使用するコンシューマーは、自分（コンシューマー）が使用するデータのタイプの説明として使用します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、基本動作以外のオブジェクトをシリアル化できる場合は、Serializableインターフェイスを実装します。そして、オブジェクトを複製できる場合は、別のインターフェース「Cloned」を実装させます。また、ネットワークを介してオブジェクトを送信するある種のトランスポートモジュールがある場合は、Serializableインターフェースを実装するすべてのオブジェクトを受け入れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変圧器フレームに3つのスロットが装備されていると想像してください。武器用スロット、エネルギージェネレーター用スロット、およびスキャナーの一種です。これらのスロットには特定のインターフェースがあります。各スロットには適切な機器のみをインストールできます。武器のスロットには、ロケットランチャーまたはレーザーガン、発電機のスロット-原子炉またはRTG（ラジオアイソトープ熱電発電機）、およびスキャナーのスロット-レーダーまたはライダーに取り付けることができます。つまり、各スロットにはユニバーサル接続インターフェースがあり、すでに特定のデバイスがこのインターフェースに準拠している必要があります。たとえば、マザーボードではいくつかのタイプのスロットが使用されています。プロセッサスロットを使用すると、このソケットに適したさまざまなプロセッサを接続できます。SATAスロットを使用すると、SSDまたはHDDドライブ、さらにはCD / DVDも接続できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として得られる変圧器用スロットのシステムは、構成の使用例であるという事実に注目します。スロットの機器が変圧器の寿命中に交換可能になる場合、これはすでに集約されています。わかりやすくするために、一部の言語では通例のように、名前の前に大文字の「And」を追加してインターフェイスを呼び出します：IWeapon、IEnergyGenerator、IScanner。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//  :</span><font></font>
<font></font>
<span class="hljs-keyword">interface</span> <span class="hljs-title">IWeapon</span>{
    <span class="hljs-function">function <span class="hljs-title">fire</span>(<span class="hljs-params"></span>)</span> {} <span class="hljs-comment">//    .  </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">interface</span> <span class="hljs-title">IEnergyGenerator</span>{
    <span class="hljs-comment">//    ,     :</span>
    <span class="hljs-function">function <span class="hljs-title">generate_energy</span>(<span class="hljs-params"></span>)</span> {} <span class="hljs-comment">// </span>
    <span class="hljs-function">function <span class="hljs-title">load_fuel</span>(<span class="hljs-params"></span>)</span> {}       <span class="hljs-comment">// </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">interface</span> <span class="hljs-title">IScanner</span>{
    <span class="hljs-function">function <span class="hljs-title">scan</span>(<span class="hljs-params"></span>)</span> {}<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// ,  :</span><font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">RocketLauncher</span>() : <span class="hljs-title">IWeapon</span><font></font>
{<font></font>
    <span class="hljs-function">function <span class="hljs-title">fire</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">LaserGun</span>() : <span class="hljs-title">IWeapon</span><font></font>
{<font></font>
    <span class="hljs-function">function <span class="hljs-title">fire</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">NuclearReactor</span>() : <span class="hljs-title">IEnergyGenerator</span><font></font>
{<font></font>
    <span class="hljs-function">function <span class="hljs-title">generate_energy</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
	<font></font>
    <span class="hljs-function">function <span class="hljs-title">load_fuel</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//    </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">RITEG</span>() : <span class="hljs-title">IEnergyGenerator</span><font></font>
{<font></font>
    <span class="hljs-function">function <span class="hljs-title">generate_energy</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//    </span><font></font>
    }<font></font>
	<font></font>
    <span class="hljs-function">function <span class="hljs-title">load_fuel</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//   -</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Radar</span>() : <span class="hljs-title">IScanner</span><font></font>
{<font></font>
    <span class="hljs-function">function <span class="hljs-title">scan</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//   </span><font></font>
    }	<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Lidar</span>() : <span class="hljs-title">IScanner</span><font></font>
{<font></font>
    <span class="hljs-function">function <span class="hljs-title">scan</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//    </span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  - :</span><font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Transformer</span>() {
    <span class="hljs-comment">// , :</span>
    IWeapon slot_weapon   <span class="hljs-comment">//      .</span>
    IEnergyGenerator slot_energy_generator <span class="hljs-comment">//     ,</span>
    IScanner slot_scanner <span class="hljs-comment">//    </span><font></font>
	<font></font>
    <span class="hljs-comment">/*
            ,
         ,
      :
    */</span>
    <span class="hljs-function">function <span class="hljs-title">install_weapon</span>(<span class="hljs-params">IWeapon weapon</span>)</span>{ 
        <span class="hljs-keyword">this</span>.slot_weapon = weapon<font></font>
    }<font></font>
	<font></font>
    <span class="hljs-function">function <span class="hljs-title">install_energy_generator</span>(<span class="hljs-params">IEnergyGenerator energy_generator</span>)</span>{
        <span class="hljs-keyword">this</span>.slot_energy_generator = energy_generator<font></font>
    }<font></font>
	<font></font>
    <span class="hljs-function">function <span class="hljs-title">install_scanner</span>(<span class="hljs-params">IScanner scanner</span>)</span>{
        <span class="hljs-keyword">this</span>.slot_scanner = scanner<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">TransformerFactory</span>(){
    <span class="hljs-function">function <span class="hljs-title">build_some_transformer</span>(<span class="hljs-params"></span>)</span> {<font></font>
       	transformer = <span class="hljs-keyword">new</span> Transformer()<font></font>
       	laser_gun = <span class="hljs-keyword">new</span> LaserGun()<font></font>
       	nuclear_reactor = <span class="hljs-keyword">new</span> NuclearReactor()<font></font>
       	radar = <span class="hljs-keyword">new</span> Radar()<font></font>
       	<font></font>
       	transformer.install_weapon(laser_gun)<font></font>
       	transformer.install_energy_generator(nuclear_reactor)<font></font>
       	transformer.install_scanner(radar)<font></font>
        	<font></font>
        <span class="hljs-keyword">return</span> transformer<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
transformer_factory = <span class="hljs-keyword">new</span> TransformerFactory()<font></font>
oleg = transformer_factory.build_some_transformer()<font></font>
<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/0a/q0/lw/0aq0lwydujaw7eofdnbgi5e52ka.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションNo. 4</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
残念ながら、工場は写真に収まりませんでしたが、それはオプションであり、変圧器は庭に組み立てることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装層とコンシューマ層の間のインターフェースの形で図に示されている抽象化層により、一方を他方から抽象化することができます。</font><font style="vertical-align: inherit;">これは、各レイヤーを個別に確認することで確認できます。実装レイヤー（左）にはTransformerクラスについての言葉がなく、コンシューマーレイヤー（右）には特定の実装についての言葉がありません（Radar、RocketLauncher、NuclearReactorなどの言葉はありません）。 。d。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードでは、トランス自体の図面に影響を与えることなく、トランスの新しいコンポーネントを作成できます。</font><font style="vertical-align: inherit;">同時に、またはその逆で、既存のコンポーネントを組み合わせて新しいトランスを作成したり、既存のコンポーネントを変更せずに新しいコンポーネントを追加したりできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アヒルのタイピング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として得られるアーキテクチャで観察される現象は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アヒルのタイピング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">アヒルの</font></b></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなものをクワガタ動かしたり、アヒルのように泳いだり、アヒルのように見える場合は、おそらくアヒル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをトランスフォーマーの言語に翻訳すると、次のように聞こえます。何かが大砲のように発砲し、大砲のようにリロードする場合、それはおそらく大砲です。</font><font style="vertical-align: inherit;">デバイスがエネルギーを生成する場合、それはおそらく発電機です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承の階層的な類型化とは異なり、ダックタイピングでは、トランスフォーマーは、銃が彼に与えられたクラス、およびそれが銃であるかどうかをまったく気にしません。</font><font style="vertical-align: inherit;">主なことは、これが撃つことができるということです！</font><font style="vertical-align: inherit;">これはダックタイピングの美徳ではなく、妥協です。</font><font style="vertical-align: inherit;">以下の図のように、逆の状況になる可能性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5_/lx/fd/5_lxfdoifgzwg4oy1rurh3bmc-m.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（インターフェース分離原理/第4 SOLID原理）は、大胆で普遍的なインターフェースを作成しないことを推奨しています。</font><font style="vertical-align: inherit;">代わりに、インターフェースをより小さく特化したインターフェースに分割する必要があります。これにより、不要なメソッドを実装せずに、クラスを実装する際にインターフェースをより柔軟に組み合わせることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPでは、すべてが抽象化を中心に展開します。</font><font style="vertical-align: inherit;">抽象化はOOPの三位一体（カプセル化、ポリモーフィズム、継承）の一部であるべきだと主張する狂信者がいます。</font><font style="vertical-align: inherit;">そして私の仮釈放査察官は反対を言った：抽象化はどんなプログラミングにも固有であり、OOPだけではないので、それは分離されるべきです。</font><font style="vertical-align: inherit;">一方、残りの原則についても同じことが言えますが、曲から単語を消去することはできません。</font><font style="vertical-align: inherit;">何らかの方法で、特にOOPでは抽象化が必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化のレベル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、よく知られたジョークを1つ引用することに失敗することはありません。- </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャの問題は、多数の抽象化の問題を除いて、抽象化の層を追加することで解決できます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースの例では、トランスフォーマーとコンポーネントの間に抽象化レイヤーを導入し、アーキテクチャーをより柔軟にしました。しかし、どのようなコストで？アーキテクチャを複雑にする必要がありました。私の心理療法士は、アーキテクチャの単純さとアプリケーションの柔軟性の間でバランスを取る能力は芸術であると述べました。中立的な立場を選択するときは、自分の経験と直感だけでなく、現在のプロジェクトのコンテキストにも依存する必要があります。この人はまだ未来を見ることを学んでいないので、このプロジェクトでどの程度の抽象化レベルとどの程度の確率が役立つか、柔軟なアーキテクチャを開発するのにどれだけの時間が必要か、そして費やした時間が将来に見返りを得るかどうかを分析的に見積もる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象化レベルの選択を誤ると、次の2つの問題のいずれかが発生します。</font></font><br>
<br>
<ol>
<li>  ,        ,        ,     (         )</li>
<li>    ,         ,   ,   ,       .                 (        )</li>
</ol><br>
<img src="https://habrastorage.org/webt/2t/on/h4/2tonh4egj4xfp4gcovpyb2xa6dq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、抽象化のレベルはプロジェクト全体に対してではなく、さまざまなコンポーネントに対して個別に決定されることを理解することも重要です。場所によっては、抽象化システムでは不十分な場合がありますが、逆にバストする場所もあります。ただし、抽象化レベルの誤った選択は、タイムリーなリファクタリングによって修正できます。キーワードは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムリー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。この抽象化レベルで多くのメカニズムがすでに実装されている場合、遅延リファクタリングは問題を引き起こします。実行中のシステムでリファクタリングの儀式を実行することは、プログラマーの手の届きにくい場所で激しい痛みを伴う可能性があります。家の基礎を変える方法についてです。隣から家を一から建てる方が安上がりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
架空のゲーム「transformers-online」の例で可能なオプションからの抽象化レベルの定義を見てみましょう。この場合、抽象化レベルはレイヤーとして機能し、検討中の後続の各レイヤーは前のレイヤーの上に配置され、機能の一部をそれ自体に組み込みます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の層。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームには1つのクラスのトランスフォーマーがあり、すべてのプロパティと動作が記述されています。これは完全に木製の抽象レベルであり、特別な柔軟性を意味しないカジュアルゲームに適しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セカンドレベル。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームには、基本的な能力を備えた基本的なトランスフォーマーと、独自の専門分野を持つトランスフォーマーのクラス（偵察機、攻撃機、サポートなど）があり、これらは追加のメソッドで記述されます。したがって、プレーヤーには選択する機会が与えられ、開発者は新しいクラスを追加するのが簡単になります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3レベル。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランスフォーマーの分類に加えて、スロットとコンポーネントのシステムを使用して集約が導入されます（リアクター、ガン、レーダーの例のように）。これで動作の一部は、プレーヤーがトランスフォーマーに取り付けたスタッフによって決まります。これにより、プレーヤーはゲームのキャラクターのメカニズムをカスタマイズする機会がさらに増え、開発者はこれらの同じ拡張モジュールを追加できるようになり、ゲームデザイナーの作業を簡素化して新しいコンテンツをリリースすることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4レベル。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、コンポーネントに独自の集約を含めることもできます。これにより、これらのコンポーネントを組み立てる材料と部品を選択できます。このアプローチにより、プレーヤーはトランスフォーマーに必要なコンポーネントを詰め込むだけでなく、さまざまなパーツからこれらのコンポーネントを独立して作成する機会が与えられます。率直に言って、私はゲームでこのようなレベルの抽象化に出会ったことはありません。結局、これにはアーキテクチャのかなりの複雑化が伴い、そのようなゲームのバランスを調整することは地獄に変わります。しかし、私はそのようなゲームが存在することを除外しません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/7d/vs/2y7dvslc6nx6_yki11hngnuzu5k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが見ることができるように、記述された各層は、原則として、生きる権利を持っています。</font><font style="vertical-align: inherit;">それはすべて、プロジェクトにどのような柔軟性を持たせたいかによって異なります。</font><font style="vertical-align: inherit;">参照条件がこれについて何も述べていない場合、またはプロジェクトの作成者自身がビジネスに必要なものを知らない場合は、この領域で同様のプロジェクトを調べて、それらに集中できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デザインパターン</font></font></h2><br>
<img src="https://habrastorage.org/webt/gl/gq/3d/glgq3d_bze334go7ml8ffxmvvvc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数十年に渡る開発により、最も一般的に使用されているアーキテクチャソリューションのリストが作成されました。これは、時間の経過とともにコミュニティによって分類され、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デザインパターン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">います</font></a><font style="vertical-align: inherit;">。そのため、パターンについて初めて読んだとき、実際にそれらの多くを既に使用していることがわかり、これらのソリューションに名前があることを知りませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象化のようなデザインパターンは、OOP開発だけでなく、他のパラダイムにも特徴的です。一般に、パターンのトピックはこの記事の範囲を超えていますが、パターンに精通することのみを意図している若い開発者に警告したいと思います。それはトラップだ！その理由を説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パターンの目的は、すでに発見されているか、プロジェクトの開発中に発見される可能性が最も高いアーキテクチャの問題を解決するのに役立つことです。</font><font style="vertical-align: inherit;">したがって、パターンについて読んだ後、初心者は、パターンを使用して問題を解決するのではなく生成するという魅力的な誘惑を感じるかもしれません。</font><font style="vertical-align: inherit;">また、開発者は自分の欲望にとらわれないので、パターンの助けを借りて問題を解決し始めることはできませんが、パターンの助けを借りてソリューションにタスクを調整できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パターンのもう1つの価値は、用語の形式化です。</font><font style="vertical-align: inherit;">同僚がこの場所で「職務の連鎖」を使用していると言うのは、オブジェクトの動作と関係を1枚の紙に30分描画するよりもはるかに簡単です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代の状況では、コードにワードクラスが存在しても、OOPプログラマーにはなりません。記事で説明されているメカニズム（ポリモーフィズム、構成、継承など）を使用せず、代わりにクラスを使用して関数とデータをグループ化する場合、これはOOPではありません。同じことは、いくつかの名前空間とデータ構造によって解決できます。混同しないでください。そうしないと、インタビューで恥ずかしくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大切な言葉で歌を仕上げたい。記述されたメカニズム、原則、パターン、およびOOP全体は、それが無意味であるか有害である可能性がある場合は適用しないでください。これは、「遺伝が早期老化の原因である」または「シングルトンが癌につながる可能性がある」などの奇妙な見出しの記事につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は真剣です。</font><font style="vertical-align: inherit;">シングルトンの場合を考えると、シングルトンのケースの知識なしでの広範囲な使用は、多くのプロジェクトで深刻なアーキテクチャ上の問題を引き起こしています。</font><font style="vertical-align: inherit;">そして、顕微鏡で釘を打つことを愛する人たちは、彼をアンチパターンと呼びました。</font><font style="vertical-align: inherit;">慎重になる。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、設計において、何が適切でどこが不適切であるかを問わず、明確なレシピはありません。</font><font style="vertical-align: inherit;">これは、経験を積んで次第に頭にフィットします。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463113/index.html">Computer Vision Meetupのデータとモデルのバージョン管理</a></li>
<li><a href="../ja463115/index.html">シューティングゲームデザインのドアの問題</a></li>
<li><a href="../ja463117/index.html">PHP 7.4でのプリロード</a></li>
<li><a href="../ja463121/index.html">象を分けて食べます。アプリケーションヘルスモニタリング戦略の例</a></li>
<li><a href="../ja463123/index.html">AVRマイクロコントローラー用のアセンブラーコードジェネレーターライブラリ。パート3</a></li>
<li><a href="../ja463127/index.html">UPSモニタリング。パート2-分析の自動化</a></li>
<li><a href="../ja463135/index.html">2019年にIT企業を登録することが収益を上げているのはどの国ですか？</a></li>
<li><a href="../ja463137/index.html">あなたがゲームデザイナーになりたいとしても、誰もあなたに方法を教えることはありません</a></li>
<li><a href="../ja463141/index.html">Habr Weekly＃13 /出会い系サービスのユーザー150万人の脅威、メデューサの調査、ロシア人の大任</a></li>
<li><a href="../ja463143/index.html">Googleアナリティクス入門：アプリ+ウェブ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>