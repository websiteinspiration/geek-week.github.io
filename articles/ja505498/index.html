<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌆 👩🏻‍🚀 ✍🏽 Windowsの初期化されていないスタックメモリの問題を解決する方法 🎞️ 👩🏿‍🤝‍👨🏻 🍯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このノートでは、初期化されていないスタックメモリに関連する脆弱性をマイクロソフトがどのように排除するのか、なぜこれを行うのかを概説します。
 
 ナビゲーションを簡単にするために、メモはセクションに分かれています。
 
 

1. 初期化されていないメモリの操作：問題の履歴
2. 初期化されていない...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Windowsの初期化されていないスタックメモリの問題を解決する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このノートでは、初期化されていないスタックメモリに関連する脆弱性をマイクロソフトがどのように排除するのか、なぜこれを行うのかを概説します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ナビゲーションを簡単にするために、メモはセクションに分かれています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリの操作：問題の履歴</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリの脆弱性の対策</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll-自動初期化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllの使用に関連する興味深い観察</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスの最適化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー価値</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今後の計画</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業は、Visual Studio、Windows、およびMSRCの間の密接な協力なしには不可能でした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリの操作：問題の履歴</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミング言語CおよびC ++を作成する場合、開発者による高速で柔軟な制御に重点が置かれました。</font><font style="vertical-align: inherit;">このため、これらの言語は変数の初期化を強制しません。</font><font style="vertical-align: inherit;">初期化されていない変数を使用すると、未定義の動作が発生するため、使用する前に初期化する必要があり、このルールを守る責任は完全に開発者にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化されていないメモリに関連する脆弱性は、次の2つのタイプに減少します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツの開示：メモリの初期化されていないセクションに保存されているデータは、信頼できる領域の外にコピーされ、適切な権限を持たない人に知られるようになります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリを直接使用します。</font><font style="vertical-align: inherit;">例：初期化されていないポインタによる書き込み。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリがスタックに割り当てられているか、ヒープに割り当てられているかに関係なく、問題が発生する可能性があることを理解することが重要です。</font><font style="vertical-align: inherit;">この投稿はスタックメモリに関するもので、次にヒープについて説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリの使用例</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> size;  <font></font>
GetSize(&amp;size); <span class="hljs-comment">//       ?</span>
<span class="hljs-built_in">memcpy</span>(dest, src, size); <span class="hljs-comment">//  memcpy </span>
                         <span class="hljs-comment">//  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの問題は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">プログラムのすべてのブランチで変数 'size'に値を割り当てない場合、</font><font style="vertical-align: inherit;">初期化され</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">いないサイズが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しに</font><font style="vertical-align: inherit;">渡されることです。</font><font style="vertical-align: inherit;">このため、「size」の値がバッファの「src」または「dest」のサイズより大きい場合、バッファの外部で読み取りまたは書き込みエラーが発生する可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリ拡張の例</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
      <span class="hljs-keyword">uint8_t</span> field1;
      <span class="hljs-keyword">uint64_t</span> field2;<font></font>
};<font></font>
mystruct s {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">memcpy</span>(dest, &amp;s, <span class="hljs-keyword">sizeof</span>(s));</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数</font><font style="vertical-align: inherit;">がトラステッドエリアの外部に構造をコピーするとします（つまり、カーネルモードからユーザーモードに）。一見すると、構造は完全に初期化されているようですが、 'field1'と 'field2'の間に、コンパイラーは明示的に初期化されていないプレースホルダーバイトを挿入しました。</font><i><font style="vertical-align: inherit;">memcpy</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を呼び出した結果</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレースホルダバイトは、これらの仮想アドレスに以前に書き込まれた初期化されていないコンテンツとともに、信頼できる領域の外にコピーされます。</font><font style="vertical-align: inherit;">たとえば、秘密の暗号化キー（ユーザーモードで表示されます）、ポインター（ASLRを壊す）、またはその他の何かです。</font><font style="vertical-align: inherit;">特に重要なデータが送信されないことが簡単に証明できる場合もあれば、非常に難しい場合もあります。</font><font style="vertical-align: inherit;">しかし、いずれにせよ、初期化されていないメモリの問題がどれほど深刻であるかを理解することは恩知らずの仕事であり、私たちは喜んで何か他のことをします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリエラー統計</font></font></h3><br>
<p><img src="https://habrastorage.org/webt/hb/la/gn/hblagnxiqxpsgewdennaq6tx8o8.png" alt="写真8"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：この図では、初期化されていないメモリの使用は、直接使用とコンテンツの開示の両方のタイプの問題を指します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近年、そのようなエラーの数は増加しています。</font><font style="vertical-align: inherit;">これはおそらく研究者からの関心の高まりと、その結果、彼らの検索のための効果的なツールの出現によるものと思われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのエラーをより詳細に分類すると、さらに興味深い傾向が明らかになります。</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/od/bg/sq/odbgsqun-kof4vx6j8ws_v9d9f8.png" alt="写真6"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：この図では、初期化されていないメモリの使用には、その内容の開示は含まれていません。</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/rl/ql/ee/rlqleezbmgk3oeo-bxztqaaphry.png" alt="写真5"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの図を見て、次の結論を導き出すことができます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2017年から2018年の間に、初期化されていないメモリの脆弱性がMicrosoftレポートのすべての脆弱性の約5〜10％を占めました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックでのメモリ割り当てに関連する脆弱性と、ヒープ/プールでのメモリ割り当てに関連する脆弱性は、ほぼ同じであることが判明しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリの内容を開示するケースは、初期化されていないメモリを使用するケースよりも多くあります。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加の文献</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックのより完全な概要については、次のリソースを参照してください。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリの脆弱性の対策</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはいくつかの方法で記述された問題を解決しようとしました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的分析（コンパイル中とコンパイル後の両方）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファジング</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードレビュー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動初期化</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的分析</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロソフトは、初期化されていない変数（C4700、C4701、C4703、C6001、C26494、およびC26495を含む）をキャッチするために、多数の静的アナライザー警告を使用します。</font><font style="vertical-align: inherit;">これらの診断は保守的です。</font><font style="vertical-align: inherit;">ノイズを減らすために、初期化されていないメモリにつながる可能性があるいくつかのパターンを無視します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Semmle</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
静的アナライザー用のいくつかの厳格なルールも作成されており</font><font style="vertical-align: inherit;">、一部のWindowsコードベースで実行されます。</font><font style="vertical-align: inherit;">しかし、これらの診断は多くのノイズを与え、大量のコードをチェックすることは困難です。</font><font style="vertical-align: inherit;">さらに、これらのルールの遵守とエラーの修正には非常に時間がかかります。</font><font style="vertical-align: inherit;">その結果、それらを使用することは困難で費用がかかることが判明しました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファジング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存じのように、ファジングはスケーリングが困難です。</font><font style="vertical-align: inherit;">優れたファザーは維持にコストがかかり、特定のタスクのカスタマイズが必要です。</font><font style="vertical-align: inherit;">Microsoftのようなサイズのコードベースでは、完全なファジングカバレッジを確保することは非常に困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのコードを完全にカバーすることができたとしても、初期化されていないメモリの内容の開示をファザーで検出することはできません。プログラムがクラッシュすることはないからです。</font><font style="vertical-align: inherit;">ファジングを使用してこのような欠陥を検出するには、2つの解決策のいずれかが必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazzer。プロトコルを理解し、初期化されていないメモリ（または、予期しないデータ）がプロトコルに返されたことを検出できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていないメモリへのアクセスを検出できるダイナミックアナライザ。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードレビュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの概要はスケーラブルではなく、エラーが発生しやすくなっています。</font><font style="vertical-align: inherit;">脆弱性のあるコードはレビューされますが、それらは非常によく偽装されているため、プログラマはそれらに気づきません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化されていないメモリの内容の開示に遭遇したコードの一部は、32ビットWindowsの時代に書き戻され、そのようなエラーはありませんでした。</font><font style="vertical-align: inherit;">64ビットアーキテクチャへの移行が発生すると、ポインタのサイズが32ビットから64ビットに増加したため、一部の構造に初期化されていないプレースホルダフィールドがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll-自動初期化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のアプローチに加えて、Microsoftは以前から</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるメカニズムを使用してき</font><font style="vertical-align: inherit;">ました。これは、コンパイル段階でスタック変数を自動的に初期化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、このテクノロジーがWindowsでどのように使用され、なぜこのように使用されるかについて説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のWindows設定：</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のタイプは自動的に初期化されます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スカラー（配列、ポインター、浮動小数点数）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインター配列</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造（単純なデータ構造-POD）</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のタイプは自動的に初期化されません。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">揮発性変数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインター以外の型の配列（整数の配列、構造体の配列など）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PODではないクラス</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化された小売アセンブリでは、変数は値0で初期化されます。浮動小数点数の場合、値0.0が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバッグ（CHK）アセンブリまたは開発者（つまり、最適化されていない小売業者）向けのアセンブリは、値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xE2を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">浮動小数点数は1.0に初期化されます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のコンポーネントに適用されます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネルモードで実行されているWindowsリポジトリのすべてのコード（つまり、/ KERNELスイッチを使用してコンパイルされるすべてのコード） </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのHyper-V関連コード（ハイパーバイザー、カーネルモードコンポーネント、ユーザーモードコンポーネント）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーモードネットワークサービスなど、他の多くのプロジェクト</font></font></li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイラのフロントエンドに実装されています。</font><font style="vertical-align: inherit;">上記の基準を満たし、プログラマーによって初期化されないすべての変数は、宣言時にフロントエンドによって初期化されます。</font><font style="vertical-align: inherit;">このアプローチの利点の1つは、オプティマイザの観点からは、自動初期化は開発者による初期化と同じことです。</font><font style="vertical-align: inherit;">このことから、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllでの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作業を高速化するために追加する最適化は、</font><font style="vertical-align: inherit;">この関数にのみ</font><i><font style="vertical-align: inherit;">関連付けられて</font></i><font style="vertical-align: inherit;">いるわけではなく、宣言時に（または使用する前に）変数を初期化する場合に機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語フォークの問題を回避する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動ゼロ初期化には1つの注意点があります。ゼロは、プログラミング言語では特にポインターにとって特別な意味があります。そして、これはおそらく個々の変数を初期化する最も一般的な値です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロに初期化されると、プログラマーによって正しく初期化されなかったポインターが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULLポインター</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチに分類される可能性があり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。その結果、クラッシュしないプログラムを取得できますが、目的の結果は生成されません。ポインターをガベージ値で初期化した場合、ポインターは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULLポインター</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチに分類されず</font><font style="vertical-align: inherit;">、使用しようとするとプログラムがクラッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、CHKビルドおよびいわゆる最適化されていないリリースビルドであることが多い開発者向けのビルドで、ゼロ以外の初期化値（0xE2）を使用することで解決します。これにより、一方では、顧客に提供されるコードの高いパフォーマンスを維持し、他方では、テストされているアセンブリで、初期化の失敗に気づきやすい動作を取得することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、すべての静的メンバーの自動ゼロ初期化がすでに必要であることに注意します。</font><font style="vertical-align: inherit;">このセマンティクスは開発者を支援します。</font><font style="vertical-align: inherit;">たとえば、値がゼロの静的変数が表示された場合、これが最初に使用されるため、初期化する必要があることがわかります。</font><font style="vertical-align: inherit;">InitAllは、自動（スタック）変数に対して同様のセマンティクスを導入しますが、重要な警告が1つあります。開発者を特定の初期値にバインドしないようにすることです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllを使用するコンポーネントの選択方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2つのコンポーネントで使用する予定でした。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネルモードコード-主に、初期化されていないカーネルメモリに関連する観察された多数の脆弱性が原因です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyper-Vコードの主な理由は、Azureにとってのその重要性と、初期化されていないスタックメモリの内容が開示された場合の最近の統計に失望したためです。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoftの何人かは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について</font><i><font style="vertical-align: inherit;">知り</font></i><font style="vertical-align: inherit;">、コンポーネントで積極的に使用し始めました。</font><font style="vertical-align: inherit;">コード全体で</font><i><font style="vertical-align: inherit;">InitAllを</font></i><font style="vertical-align: inherit;">すぐに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
展開しないの</font><font style="vertical-align: inherit;">は、少なくとも何かを最初に適切に実行し、失敗しないようにして、一度にすべてを実行しようとするためです。</font><i><font style="vertical-align: inherit;">一度にInitAll</font></i><font style="vertical-align: inherit;">を処理するコード</font><font style="vertical-align: inherit;">が多いほど、パフォーマンス低下のデバッグ、互換性の問題の解決などが難しくなります。</font><font style="vertical-align: inherit;">最も重要なコンポーネントへのテクノロジーの導入に成功したので、残りのコードを実行できます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllは静的分析を中断しますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的分析は、使用前に初期化するのを忘れた変数を開発者に思い出させるという点で非常に便利です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、追加された初期化について</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREfast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナライザ</font><font style="vertical-align: inherit;">とコンパイラバックエンドの</font><font style="vertical-align: inherit;">両方に通知し</font><font style="vertical-align: inherit;">ます（どちらも初期化されていない変数に関する警告を出します）。</font><font style="vertical-align: inherit;">このおかげで、静的アナライザーはそのような場所を無視し、警告を出すことができます。</font><font style="vertical-align: inherit;">とき</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllが有効になっている、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合でも-あなたはまだ初期化されていない変数に関する静的アナライザのメッセージを受信します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたのためにそれらを初期化します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのタイプを初期化しない理由</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予備テスト中に、スタックに割り当てられたすべてのタイプのデータを強制的に初期化し、いくつかの重要なシナリオで10％以上のパフォーマンスの低下を観察しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
POD構造のみが初期化された場合、パフォーマンスはそれほど低下せず、不要な書き込み操作（ベースユニット内とその間の両方）の数を減らすことを目的としたコンパイラーの最適化により、スローダウンを目立ったレベルからエラーレベルにさらに減らすことができましたほとんどのテスト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのタイプを初期化するという考えに戻る予定です（特に、より強力な最適化があるため）、この時点ではまだ到達していません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数をゼロで初期化する理由</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロで初期化すると、パフォーマンスの点（速度とバイナリサイズの両方）とセキュリティの点で最良の結果が得られます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セキュリティの観点から</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロ初期化には次の利点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windowsで逆参照すると、nullポインターはSEH例外をスローします（つまり、最悪の場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス拒否</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラー</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">発生します</font><font style="vertical-align: inherit;">が、リモートコードの実行は不可能になります）。これは通常、プログラムのクラッシュで終了します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズまたはインデックスを指定する変数はnull値を受け取ります。</font><font style="vertical-align: inherit;">これにより、初期化されていないサイズを</font><font style="vertical-align: inherit;">、渡された変数の値によってサイズが指定されるバッファーを処理する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの関数に渡すリスクが最小限に抑え</font><font style="vertical-align: inherit;">られます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullポインターをチェックした後、プログラムは対応するブランチを実行し、それを使用しようとしません。</font><font style="vertical-align: inherit;">したがって、少なくとも、開発者が初期化するのを忘れたポインタを正しく処理することは可能です（自動的に初期化されたポインタを使用してメモリにアクセスしようとすると、常にクラッシュが発生するため）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が0のブール型の変数は「false」を意味し、テストではエラー状態を示す可能性があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロによる初期化には、いくつかの欠点もあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NTSTATUS変数の値はSTATUS_SUCCESS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HRESULTはS_OKになります </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、戻り値は大きく異なる可能性があり、特にサイズ、インデックス、ポインターなどにも使用する必要があることを考えると、戻り値をすべて初期化するための単一のユニバーサル値はありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスの観点から</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの速度とコードサイズは、選択した初期化値にも依存します。</font><font style="vertical-align: inherit;">初期化によってゼロが得られるというセキュリティ上の利点に主に関心があったため、ゼロ以外の値を使用した場合の結果がどれほど悪化するかは測定しませんでした。同時に、パフォーマンスにプラスの影響があることもわかっていました（速度とコードサイズの両方）。</font><font style="vertical-align: inherit;">Googleの同僚が測定を行ったところ、Clangでは、現時点でゼロを使用した初期化の方が、ゼロ以外の値を使用した初期化よりも著しく収益性が高いことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下では、ゼロで初期化した場合に取得されるコードが少なくなる理由を例で示します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例1：汎用レジスターを使用した初期化</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロによる初期化：</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">31</span> c0                            <span class="hljs-keyword">xor</span>    eax,eax
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロ以外の値での初期化：</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> b8 e2 e2 e2 e2 e2 e2 e2 e2    movabs rax,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、2つの点に注目します。1つ目</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
は、RAXレジスタをゼロに設定すると、2バイトのコードが必要になるのに対し、0以外の値に設定すると10バイトになることです。コードサイズと速度の両方で利益が得られます。多くのプロセッサは一度に16バイトの命令を読み取るため、10バイトの命令を使用してレジスタに固定定数を書き込むと、並列実行できる次の命令が発行されなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、RCXレジスタに値を書き込むことが可能になる前に、RAXへの書き込みが完了するまで待機する必要があります。これにより、プロセッサがアイドル状態になる可能性があります。</font><font style="vertical-align: inherit;">「xor eax、eax」のようなシーケンスはパイプラインの最初の部分で認識され、XORコマンドの実際の実行は必要ありません。プロセッサーは単にRAXレジスターをリセットするだけです。</font><font style="vertical-align: inherit;">その結果、パイプラインのアイドル時間が短くなり、プログラムの実行が速くなります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例2：XMMレジスターを使用した初期化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より大きな値を書き込むために、コンパイラは通常、XMMレジスタを使用します（AVXまたはAVX512命令セットのサポートが有効かどうかに応じて、YMMまたはZMMも同様）。</font><font style="vertical-align: inherit;">原則として、プロセッサは1クロックサイクルで書き込みコマンドを1つしか完了できないため、できるだけ多くのバイトを設定するコマンドを使用するのが賢明です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロによる初期化：</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">0f</span> <span class="hljs-number">57</span> c0                         xorps  xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非ゼロ値での初期化（グローバル変数からロードされ、通常コンパイラーが行います）：</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">66</span> <span class="hljs-number">0f</span> <span class="hljs-number">6f</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movdqa xmm0,XMMWORD PTR ds:<span class="hljs-number">0x0</span>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非ゼロ値での初期化（コードの固定定数から読み込まれ、コンパイラーは行わない）：</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> ba e2 e2 e2 e2 e2 e2 e2 e2    movabs rdx,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">66</span> <span class="hljs-number">48</span> <span class="hljs-number">0f</span> <span class="hljs-number">6</span>e c2                   movq   xmm0,rdx
<span class="hljs-number">0f</span> <span class="hljs-number">16</span> c0                         movlhps xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、XMMレジスターの場合、同じ画像が観察されます。ゼロに初期化すると、コードは非常に小さくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
固定定数をXMMレジスタに直接書き込むことはできません。まず、それを汎用レジスターに保存し、そこからXMMレジスターに移動してから、XMMレジスターの下位64ビットを上位64ビットにコピーする必要があります。その結果、長いコードと3つのコマンドを取得します。各コマンドは、前のコマンドが完了するまで待機する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを回避するために、コンパイラーは、原則として、固定定数をグローバル変数の形式で保存し、そこから値を読み取ることができます。これにより、コードが大幅に削減されます。残念ながら、XMMレジスタが使用可能になる前に、XMMレジスタへの書き込みが終了するまで待つ必要があります。グローバル変数がメモリからアンロードされると、操作には数千クロックサイクルかかる場合があります。データがL1キャッシュに格納されている場合、最良のシナリオでも、読み取り操作には数クロックサイクルかかります。そして、この場合でも、レジスタをリセットした場合よりもコードははるかに長くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、ゼロ初期化のもう1つの利点、より確定的な結果が明らかになります。初期化時間は、グローバル変数がL1、L2、またはL3キャッシュにあるかどうか、メモリからアンロードされるかどうかなどに依存しません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllの使用に関連する興味深い観察</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows 10 1903（2019年春にリリースされた）は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がデフォルトで有効にされ</font><font style="vertical-align: inherit;">た最初のバージョンでした</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これまでのところ、それによるパフォーマンスの低下についての苦情はありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互換性</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンチチート</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windowsで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">
オンにした直後に</font><font style="vertical-align: inherit;">、一部のアンチチートプログラムが原因のカーネルクラッシュに関する苦情を受け始めました。</font><font style="vertical-align: inherit;">問題を調査した結果、これらのプログラムには、メモリ内のNTカーネルイメージをスキャンし、文書化されていない関数の始まりを示す特定のバイトシーケンスを探すカーネルモードドライバーが含まれていることがわかりました。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、これらの関数の最初に追加の初期化（冗長性を証明できなかった）を追加しました。これは、そのシグネチャが変更されたためです。</font><font style="vertical-align: inherit;">これらのアンチチートの開発者に連絡し、私たちの要請に応じて、カーネルクラッシュを引き起こさないようにドライバーを更新しました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAT32で解放されたメモリを使用する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スカラーデータタイプ（整数、浮動小数点数など）に対して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">
有効にした直後</font><font style="vertical-align: inherit;">に、FATファイルシステムドライバーで興味深い問題が発生しました。これにより、起動可能なUSBフラッシュドライブから内部Windowsアセンブリを更新できませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生したコードは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
{<font></font>
      <span class="hljs-keyword">int</span> tmp;<font></font>
      DoStuff(&amp;tmp, i);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数が宣言されているループがあります。ループの最初の反復で、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoStuff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は変数「tmp」を初期化します。そのアドレスは引数として渡されます。後続の各反復で、変数「tmp」が入力/出力パラメーターとして使用されます。つまり、その値が最初に読み取られてから更新されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、ループの各反復の開始時に問題の変数がスコープに入り、反復の終了時にそれを残すことです。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllは、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各反復の前にこの変数をゼロに初期化します。実際、</font><i><font style="vertical-align: inherit;">解放後使用の</font></i><font style="vertical-align: inherit;">脆弱性が発生します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">コードの通常の操作では、変数 'tmp'は、反復の最後にスコープ外になった場合でも、反復ごとにその値を保持する必要があります。</font><font style="vertical-align: inherit;">残念ながら、この問題はドライバーのクラッシュを引き起こしませんでしたが、その操作の誤ったロジックを引き起こし、その結果、ファイルシステムの予期しない動作を引き起こしました。</font><font style="vertical-align: inherit;">デバッグ中に、カーネルチームは問題の原因を特定し、変数をループから外して修正しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このケースは、セキュリティの改善により、何年も調査されていないコードがどのように破壊されるかを示す良い例です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスの最適化</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
パフォーマンス最適化には</font><font style="vertical-align: inherit;">3つの目標があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要なコードに対して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を無効にする機能を開発者に提供し</font><font style="vertical-align: inherit;">ます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能であれば、不要な書き込み操作を削除します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りの書き込み操作を可能な限り高速化する</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要なコードのInitAllを無効にする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も明らかな最適化は、コードを次のようにすることです。</font></font><ol>
<li><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">InitAllを完全に</font></i><font style="vertical-align: inherit;">無効に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のタイプの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">無効</font><font style="vertical-align: inherit;">にする（typedef構造など）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数のすべてのメモリ割り当て操作で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">無効に</font><font style="vertical-align: inherit;">する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の特定の変数宣言に対して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">無効に</font><font style="vertical-align: inherit;">する</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
現在</font><font style="vertical-align: inherit;">、単一のタイプ（すべてのレジスターの値を格納する_CONTEXT構造）に対して（パフォーマンス</font><i><font style="vertical-align: inherit;">上の理由で</font></i><font style="vertical-align: inherit;">）無効になっています。強制的に初期化すると、テストのパフォーマンスが低下しました。</font><i><font style="vertical-align: inherit;">_CONTEXT</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
構造体</font><font style="vertical-align: inherit;">のサイズは1000バイトを超えており、これはすべてのレジスターの値を格納するのに十分です。コンテキスト切り替えを追跡するためにETWログをオンにすると、コンテキストが変更されるたびに、すべてのレジスターの値がログに記録されます。</font><font style="vertical-align: inherit;">この場合</font><font style="vertical-align: inherit;">の</font><i><font style="vertical-align: inherit;">_CONTEXT</font></i><font style="vertical-align: inherit;">構造体</font><font style="vertical-align: inherit;">はスタックに割り当てられ、アセンブラー関数が入力されてから、ETWに渡されます。構造体がアセンブラー関数によって初期化されているため、コンパイラーは初期化を削除できません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この構造には既に重要なデータ（各レジスタの状態）が含まれており、サイズが大きく、パフォーマンスを非常に要求するブランチで使用されるため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を適用しないことにしました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のすべてのタイプ、変数、関数では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllは無効になり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要な書き込み操作を削除する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要な書き込み操作の削除は、Visual Studioコンパイラーによって実行される最適化であり、冗長であることが証明できる書き込み操作が削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studioで使用されるさまざまな種類の最適化の例を次に示します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のメモリセットを削除する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Godboltへのリンク：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ://msvc.godbolt.org/z/Ldu7AP </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードパターン（バリエーションが異なる）は非常に一般的です。初期のNTプログラミングルールでは、すべての変数を関数の先頭で宣言し、できるだけ遅く初期化する必要があります。その結果、変数が関数の最初に宣言され、使用の直前のいずれかの分岐でのみ初期化される場合があります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、関数の先頭に変数の初期化を追加します。コンパイラーは重複を削除できますが、これは必ずしも簡単ではありません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
  <font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/hq/dl/ee/hqdleeuo4icifkr9_ijrp0rt_ps.png" alt="写真4"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純な例は簡単に最適化できるようですが、GCC 9.3とClang 10.0.0（Godboltで入手可能な最新バージョン）では、この場合、余分な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しを削除できません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらのコンパイラを批判するためにこれについて話しているわけではありません。どちらもコードを非常に最適化しています。</font><font style="vertical-align: inherit;">最も強力なコンパイラであっても、いくつかのパターンが問題を引き起こす可能性があることを示したいと思います。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および関連する最適化</font><font style="vertical-align: inherit;">が登場する前は</font><font style="vertical-align: inherit;">、Visual Studioは余分な呼び出しを削除できませんでした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに単純な例：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2つの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しの間に</font><font style="vertical-align: inherit;">、引数のない関数呼び出しが1つだけあります。</font><font style="vertical-align: inherit;">このパターンは、前のパターンと同様に、Microsoftコードでは非常に一般的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゴッドボルトへのリンク：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/HqFMx_</font></font></a><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    Dummy();<font></font>
<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    DoStuff(&amp;s);<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fe/qo/7e/feqo7evdydknbjjwx9wwlvxt61a.png" alt="写真3"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この例で</font><font style="vertical-align: inherit;">
は、MSVCは余分な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットを削除し</font><font style="vertical-align: inherit;">ます。 Clang 10.0.0-あまりにも、GCC 9.3はまだ失敗します。このコードは簡単に最適化できるように思えますが、そのためにはコンパイラーは重要な分析を行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここ（MSVCで）の問題は、コンパイラーが、分岐やスレッドの実行とは関係なく、オブジェクト到達可能性分析を使用することです。コンパイラーの観点からは、変数「s」は現在の関数から「エスケープ」します（つまり、そのアドレスは関数「DoStuff」に渡されるため、そのアドレスはこの関数の外のどこかに渡されます）。コンパイラーは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's'への呼び出し、次に 'Dummy'への呼び出し、続いて</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's' </font><font style="vertical-align: inherit;">への別の呼び出し</font><font style="vertical-align: inherit;">も認識します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーの観点から見ると、 's'変数は関数から「エスケープ」されているため、 'Dummy'関数は理論的には 'DoStuff'関数を呼び出す前に 's'の内容を読み取るか変更できます。</font><font style="vertical-align: inherit;">つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memsetの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しは、</font><font style="vertical-align: inherit;">「ダミー」の前でも後でも削除できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数 's'と現在の関数からの「エスケープ」が、関数 'DoStuff'が呼び出される前に発生しないことがわかります。</font><font style="vertical-align: inherit;">MSVCコンパイラはこれも（ある程度）理解し、最初の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しを削除できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memsetサイズの縮小</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Godboltへのリンク：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ://msvc.godbolt.org/z/fyLVUF </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパターンも珍しくありません。</font><font style="vertical-align: inherit;">構造は部分的に初期化され、別の関数に転送されます。</font><font style="vertical-align: inherit;">この2番目の関数は、構造データの残りの部分を初期化する（または少なくともそれらを読み取らない）可能性がありますが、コンパイラーはこれを証明できません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">320</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s)<span class="hljs-number">-0x160</span>);<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/qv/zv/ix/qvzvix4pxzqvazgvfzafdg_zraa.png" alt="写真2"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVCは、最初の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memsetの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズをトリミングし</font><font style="vertical-align: inherit;">て、2番目の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が初期化しない構造内の要素のみを初期化できるようになりました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合も、GCC 9.3とClang 10.0.0は、この例でこの最適化を行う方法をまだ認識していません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より効率的なmemsetスイープ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Godboltへのリンク</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次の例では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">を削除できません。</font><font style="vertical-align: inherit;">したがって、可能な限り効率的に実行する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">12</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
    DoStuff(&amp;s);<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fm/yf/7v/fmyf7vxnqesyecgskxvarcbgyc4.png" alt="写真1"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC（ほとんどのコンパイラと同様）は</font><font style="vertical-align: inherit;">、静的に定義されたサイズとパディング値を持つ</font><font style="vertical-align: inherit;">小さな</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">「展開」でき</font><font style="vertical-align: inherit;">ます。つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">は、直接メモリへの一連の書き込みコマンドに置き換えられます。この最適化のおかげで、小さな</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">（最大128バイト）</font><font style="vertical-align: inherit;">の実行時間は</font><font style="vertical-align: inherit;">、より少ないコード量で通常の4分の1に短縮されます（スタックのレジスターの値を保存し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memsetを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出して</font><font style="vertical-align: inherit;">、レジスターの状態を復元する</font><font style="vertical-align: inherit;">必要はありません</font><font style="vertical-align: inherit;">）。</font><i><font style="vertical-align: inherit;">memsetの</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
展開に使用されるMSVC</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD64では、汎用レジスターを使用します。</font><font style="vertical-align: inherit;">現在はベクトルレジスタを使用しているため、呼び出しを2倍のサイズで展開できます。</font><font style="vertical-align: inherit;">その結果、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が高速になり</font><font style="vertical-align: inherit;">、コードが大きくなりません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より生産的なmemsetの実装</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。この項目については、</font><b><font style="vertical-align: inherit;">後で</font></b><font style="vertical-align: inherit;">詳しく</font><b><font style="vertical-align: inherit;">分析</font></b><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー価値</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
リリース以降</font><font style="vertical-align: inherit;">、ユーザーがMSRCに報告した脆弱性の多くは、最新バージョンのWindowsでの再生を停止しています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おかげで</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">これらの脆弱性は「セキュリティの問題」から「現在のところ悪影響がないコードの欠陥」へと</font><i><font style="vertical-align: inherit;">進化</font></i><font style="vertical-align: inherit;">しています。つまり、すでにリリースされた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールされたオペレーティングシステムのセキュリティ更新プログラムを提供する必要がなくなりました</font><font style="vertical-align: inherit;">。これにより、パッチのインストールに伴う頭痛からユーザーを節約し、開発に伴う頭痛からMicrosoftを節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリのアクティブなブランチでは、コードを改善してエラーを修正し、</font><i><font style="vertical-align: inherit;">InitAllが</font></i><font style="vertical-align: inherit;">すでにリリースされているオペレーティングシステムに変更を加えます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欠落しているため、まだ脆弱です。</font><font style="vertical-align: inherit;">今後、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAllの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">バージョンは</font><i><font style="vertical-align: inherit;">サポート</font></i><font style="vertical-align: inherit;">されなくなります。</font><font style="vertical-align: inherit;">これが発生すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><i><font style="vertical-align: inherit;">取り消された</font></i><font style="vertical-align: inherit;">エラー</font><font style="vertical-align: inherit;">はアクティブな開発ブランチでのみ修正され、現在のシステムではこのタイプの欠陥を修正する必要はなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今後の計画</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、初期化されていないスタック変数の問題に関連して、2つの主要なタスクを処理する予定です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を割り当てられたすべてのタイプのデータ（つまり、PODだけでなく、すべてのタイプとすべてのクラスの配列）に</font><font style="vertical-align: inherit;">適用する可能性を調査して使用するには</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのWindowsコードに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">デプロイし</font><font style="vertical-align: inherit;">ます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、CおよびC ++で説明されているタイプの問題を排除するプロセスを標準化できるかどうかを調べる予定です。デフォルトでは、パフォーマンス上の理由から変数を初期化しないままにする必要はありません（特に、コンパイラーが冗長な書き込み操作を適切に最適化できる場合）。代わりに、「そのような必要性が証明されている場合」、開発者に使用前に変数の初期化を要求し、初期化されていない変数に特別なキーワードが使用されている場合にのみこのルールに違反できるようにする方が良いでしょう。このようなソリューションは、高いパフォーマンスを維持すると同時に、不要なエラーからプログラマーを救います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windowsカーネルでメモリプールを割り当てるメカニズムの初期化されていないメモリの脆弱性を中和するための進行中の作業に関する別のメモを公開する予定です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳者コメント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、静的コード分析の私のネイティブトピックとはほとんど関係ありませんが、私にとっては興味深く思われ、ロシア語を話す視聴者と翻訳を共有したいと思いました。</font><font style="vertical-align: inherit;">私自身から、個人データの「漏洩」に関連するセキュリティ問題は通常2つのコンポーネントで構成されていることを付け加えておきます。</font><font style="vertical-align: inherit;">まず、個人データを消去する場所がありますが、これは起こりません（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">2つ目：初期化されていないメモリの一部であるクリーンアップされていないプライベートデータはどこかに転送できます（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505476/index.html">DenoとPostegreSQLのCRUD API：恐竜の操作</a></li>
<li><a href="../ja505478/index.html">CRMシステムをCRMシステムに置き換える</a></li>
<li><a href="../ja505488/index.html">TypeScriptをReactアプリケーションに実装するための12のヒント</a></li>
<li><a href="../ja505494/index.html">開発者のフレーミング</a></li>
<li><a href="../ja505496/index.html">CTO Meduza Boris GoryachevによるFlutter Devポッドキャスト：Meduzアプリケーションとメディア開発の主なもの</a></li>
<li><a href="../ja505502/index.html">カスタマーサービスのオムニチャネル：何を探し、すべてを正しく行うには？</a></li>
<li><a href="../ja505506/index.html">彼は噛まない：産業用ロボットを労働者にとって安全にする方法</a></li>
<li><a href="../ja505508/index.html">無人技術だけでなく、自動車産業の未来</a></li>
<li><a href="../ja505510/index.html">Python SDKによるCheck Point APIの合理化</a></li>
<li><a href="../ja505516/index.html">機械学習：どこから始めればよいか、どのように最初のモデルを構築するか</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>