<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚖️ 💂🏼 🥧 10 linhas de código para reduzir a dor do seu projeto Vue 🔚 👩🏾‍🔬 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... ou familiaridade com os plugins Vue JS como um exemplo de um barramento de eventos integrado
 Algumas palavras sobre ...
 Olá a todos! Farei uma r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>10 linhas de código para reduzir a dor do seu projeto Vue</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odin_ingram_micro/blog/488422/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... ou familiaridade com os plugins Vue JS como um exemplo de um barramento de eventos integrado</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algumas palavras sobre ...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olá a todos! </font><font style="vertical-align: inherit;">Farei uma reserva imediatamente. </font><font style="vertical-align: inherit;">Eu realmente amo o VueJS, escrevo ativamente há mais de 2 anos e não acho que o desenvolvimento possa prejudicar pelo menos em um grau significativo :)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por outro lado, estamos sempre tentando encontrar soluções universais que ajudem a gastar menos tempo em trabalhos mecânicos e mais no que é realmente interessante. Às vezes, a solução é particularmente bem-sucedida. Um deles eu quero compartilhar com você. As 10 linhas que serão discutidas (spoiler: no final, haverá um pouco mais) nasceram no processo de trabalho no projeto Cloud Blue - Connect, que é um aplicativo bastante grande com mais de 400 componentes. A solução que encontramos já está integrada em vários pontos do sistema e, por mais de meio ano, nunca exige correções, portanto pode ser considerada com segurança testada com sucesso quanto à estabilidade.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o último. </font><font style="vertical-align: inherit;">Antes de prosseguir diretamente para a solução, gostaria de me aprofundar um pouco mais na descrição dos três tipos de interação entre os componentes do Vue: os princípios do fluxo unidirecional, o padrão da loja e o barramento de eventos. </font><font style="vertical-align: inherit;">Se essa explicação for desnecessária (ou chata) para você, vá diretamente para a seção com a solução - tudo é o mais breve e técnico possível.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco sobre como os componentes do Vue se comunicam</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez a primeira pergunta que surja para a pessoa que escreveu seu primeiro componente seja como ele receberá dados para o trabalho e como, por sua vez, ele transferirá os dados recebidos por ele "fora". </font><font style="vertical-align: inherit;">O princípio de interação adotado no framework Vue JS é chamado ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluxo de dados unidirecional</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em resumo, esse princípio soa como "propriedades - desativadas, eventos - ativadas". Ou seja, para receber dados de fora (“de cima”), registramos uma propriedade especial dentro do componente no qual a estrutura, se necessário, grava nossos dados recebidos “de fora”. Para transferir dados "para cima", dentro do componente no lugar certo, chamamos o método especial de estrutura $ emit, que passa nossos dados para o manipulador do componente pai. Ao mesmo tempo, no Vue JS, não podemos apenas "transmitir" o evento até uma profundidade ilimitada (como por exemplo no Angular 1.x). Ele "aparece" apenas um nível, para o pai imediato. O mesmo vale para eventos. Para transferi-los para o próximo nível, para cada um deles, você também precisa registrar uma interface especial - propriedades e eventos que transmitirão nossa "mensagem" ainda mais.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso pode ser descrito como um prédio de escritórios no qual os trabalhadores só podem passar dos andares para os vizinhos - um para cima e outro para baixo. Portanto, para transferir o “documento para assinatura” do quinto andar para o segundo, será necessária uma cadeia de três trabalhadores que o entregarão do quinto andar para o segundo e mais três que o devolverão ao quinto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Mas isso é inconveniente!" Obviamente, isso nem sempre é conveniente do ponto de vista do desenvolvimento, mas, olhando o código de cada componente, podemos ver o que e para quem ele passa. Não precisamos ter em mente toda a estrutura do aplicativo para entender se nosso componente está "a caminho" do evento ou não. Podemos ver isso no componente pai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora as vantagens dessa abordagem sejam compreensíveis, ela também apresenta desvantagens óbvias, a saber, a alta coesão dos componentes. </font><font style="vertical-align: inherit;">Simplificando, para colocarmos algum componente na estrutura, precisamos cobri-lo com as interfaces necessárias para gerenciar seu estado. </font><font style="vertical-align: inherit;">Para reduzir essa conectividade, eles costumam usar "ferramentas de gerenciamento de estado". </font><font style="vertical-align: inherit;">Talvez a ferramenta mais popular para o Vue seja ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vuex (lateral)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuando nossa analogia com um prédio de escritórios, o Vuex Stor é um serviço postal interno. Imagine que em cada andar do escritório haja uma janela para emissão e recebimento de encomendas. No quinto andar, transmitem o documento nº 11 para assinatura e, no segundo, perguntam periodicamente: “Existem documentos para assinatura?”, Assinam os documentos existentes e os devolvem. No quinto, eles também perguntam: "Existem signatários?" Ao mesmo tempo, os funcionários podem mudar para outros andares ou para outras salas - o princípio do trabalho não será alterado enquanto o correio estiver funcionando. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aproximadamente por esse princípio, o padrão chamado Store também funciona. Usando a interface Vuex, um armazém de dados global é registrado e configurado, e os componentes se inscrevem nele. E não importa em que nível de estrutura a apelação ocorreu, a loja sempre fornecerá as informações corretas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que com isso todos os problemas já foram resolvidos. Mas em algum momento do nosso edifício metafórico, um funcionário quer ligar para outro para almoçar ... ou relatar algum tipo de erro. E aqui começa o estranho. A mensagem em si não requer transmissão como tal. Mas, para usar o e-mail, você precisa transferir alguma coisa. Em seguida, nossos funcionários criam um código. Uma bola verde - vá almoçar, dois cubos vermelhos - ocorreu um erro de aplicação E-981273, três moedas amarelas - verifique seu e-mail e assim por diante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É fácil adivinhar que, com a ajuda dessa metáfora incômoda, descrevo situações em que precisamos garantir a resposta do nosso componente a um evento que ocorreu em outro componente, que por si só não está conectado de nenhuma maneira ao fluxo de dados. </font><font style="vertical-align: inherit;">A gravação de um novo item está concluída - você precisa refazer a coleção. </font><font style="vertical-align: inherit;">Ocorreu um erro 403 não autorizado - você precisa iniciar um logout do usuário e assim por diante. </font><font style="vertical-align: inherit;">A prática usual (e longe da melhor) nesse caso é criar sinalizadores dentro da loja ou interpretar indiretamente os dados armazenados e suas alterações. </font><font style="vertical-align: inherit;">Isso leva rapidamente à poluição da própria loja e à lógica dos componentes ao seu redor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse estágio, começamos a pensar em como transmitir eventos diretamente, ignorando toda a cadeia de componentes. </font><font style="vertical-align: inherit;">E, um pouco do google ou vasculhando a documentação, encontramos um padrão ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barramento de evento</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do ponto de vista técnico, o barramento de eventos é um objeto que permite o uso de um método especial para iniciar um "evento" e se inscrever usando outro. Em outras palavras, ao se inscrever no evento eventA, esse objeto armazena a função de manipulador de passagem dentro de sua estrutura, que será chamada quando o método de inicialização com a chave eventA for chamado em algum lugar do aplicativo. Para assinar ou executar, basta acessá-lo por importação ou por referência, e pronto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metaforicamente, em nosso “prédio”, um ônibus é um bate-papo comum no messenger. Componentes assinam um "bate-papo geral" para o qual outros componentes enviam mensagens. Assim que uma "mensagem" aparecer no "bate-papo", ao qual o componente se inscreveu, o manipulador será iniciado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem muitas maneiras diferentes de criar um barramento de eventos. </font><font style="vertical-align: inherit;">Você pode escrever por conta própria ou pode usar soluções prontas - o mesmo RxJS, que fornece enorme funcionalidade para trabalhar com fluxos inteiros de eventos. </font><font style="vertical-align: inherit;">Mas, na maioria das vezes, ao trabalhar com o VueJS, eles usam, curiosamente, o próprio VueJS. </font><font style="vertical-align: inherit;">A instância do Vue criada por meio do construtor (new Vue ()) fornece uma interface de evento bonita e concisa, descrita na documentação oficial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui chegamos perto da próxima pergunta ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que nós queremos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E queremos construir um barramento de eventos em nosso aplicativo. </font><font style="vertical-align: inherit;">Mas temos dois requisitos adicionais:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve ser facilmente acessível em todos os componentes. </font><font style="vertical-align: inherit;">As importações separadas para cada uma das dezenas de componentes nos parecem redundantes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve ser modular. </font><font style="vertical-align: inherit;">Não queremos manter todos os nomes de eventos em mente para evitar a situação em que o evento "criado por item" aciona manipuladores de todo o aplicativo. </font><font style="vertical-align: inherit;">Portanto, queremos poder separar facilmente um pequeno fragmento da árvore de componentes em um módulo separado e transmitir seus eventos dentro e não fora.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar essa funcionalidade impressionante, usamos a poderosa interface de plug-in fornecida pelo VueJS. </font><font style="vertical-align: inherit;">Você pode se familiarizar com isso com mais detalhes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na página com documentação oficial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos registrar nosso plugin primeiro. </font><font style="vertical-align: inherit;">Para fazer isso, logo antes do ponto de inicialização do aplicativo Vue (antes de chamar Vue. $ Mount ()), colocamos o seguinte bloco:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { }, <font></font>
});<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, os plugins do Vue são uma maneira de estender a funcionalidade da estrutura em todo o nível do aplicativo. A interface do plug-in fornece várias maneiras de se integrar ao componente, mas hoje apresentaremos a interface mixin. Este método aceita um objeto que estende o descritor de cada componente antes de iniciar o ciclo de vida no aplicativo.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(O código do componente que escrevemos provavelmente não é o componente em si, mas uma descrição de seu comportamento e encapsulamento de uma certa parte da lógica que a estrutura usa em vários estágios do seu ciclo de vida. A inicialização do plug-in está fora do ciclo de vida do componente, precedendo-o, portanto, nós dizemos "descritor", não um componente, para enfatizar que exatamente o código que está escrito em nosso arquivo, e não alguma entidade que é um produto do trabalho da estrutura, será transferido para a seção mixin do plug-in)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) {     <font></font>
    vue.mixin({}); <span class="hljs-comment">// &lt;--</span><font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É esse objeto vazio que conterá as extensões para nossos componentes. Mas, para começar, outra parada. No nosso caso, queremos criar uma interface para acessar o barramento no nível de cada componente. Vamos adicionar o campo '$ broadcast' ao nosso descritor, ele armazenará um link para o nosso barramento. Para fazer isso, use Vue.prototype:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <span class="hljs-comment">// &lt;--</span><font></font>
    vue.mixin({}); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos criar o próprio barramento, mas primeiro, vamos relembrar o requisito da modularidade e assumir que no descritor de componentes declararemos um novo módulo com o campo "$ module" com algum valor de texto (precisaremos um pouco mais tarde). </font><font style="vertical-align: inherit;">Se o campo $ module for especificado no próprio componente, criaremos um novo barramento para ele; caso contrário, passaremos o link para o pai através do campo $ parent. </font><font style="vertical-align: inherit;">Observe que os campos do descritor estarão disponíveis para nós através do campo $ options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Colocaremos a criação de nosso ônibus o mais cedo possível - no gancho beforeCreate.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() {  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
 	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, vamos preencher os ramos lógicos. </font><font style="vertical-align: inherit;">Se o descritor contiver uma nova declaração de módulo, crie uma nova instância de barramento, caso contrário, pegue o link em $ parent.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue();  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast;  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descartamos o anúncio do plugin, consideramos ... 1, 2, 3, 4 ... 10 linhas, como prometi! </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos fazer melhor?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro que podemos. </font><font style="vertical-align: inherit;">Este código é facilmente extensível. </font><font style="vertical-align: inherit;">Por exemplo, no nosso caso, além de $ broadcast, decidimos adicionar a interface $ rootBroadcast, que dá acesso a um único barramento para todo o aplicativo. </font><font style="vertical-align: inherit;">Os eventos que o usuário executa no barramento $ broadcast são duplicados no barramento $ rootBroadcast, para que você possa se inscrever em todos os eventos de um módulo específico (nesse caso, o nome do evento será passado para o manipulador como o primeiro argumento) ou para todos os eventos de aplicativos em geral (depois o nome do módulo será passado para o manipulador com o primeiro argumento, o nome do evento com o segundo e os dados transmitidos com o evento serão transmitidos com os seguintes argumentos). </font><font style="vertical-align: inherit;">Esse design nos permitirá estabelecer interação entre os módulos, além de travar um único manipulador nos eventos de diferentes módulos.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// This one emits event  </span>
<span class="hljs-keyword">this</span>.$broadcast.$emit(‘my-event’, ‘PARAM_A’); 
<span class="hljs-comment">// This is standard subscription inside module </span>
<span class="hljs-keyword">this</span>.$broadcast.$on(‘my-event’, (paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘my-event’, (<span class="hljs-built_in">module</span>, paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will also work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘*’, (event, <span class="hljs-built_in">module</span>, paramA) =&gt; {…});
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como podemos conseguir isso: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, crie um único barramento, que será organizado através de $ rootBroadcast, e o próprio campo com um link:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue(); <span class="hljs-comment">// &lt;--</span><font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus; <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos da associação do módulo em cada componente, então vamos expandir a definição de modularidade como esta:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, precisamos fazer com que o evento no barramento local modular reflita da maneira que precisamos para a raiz. </font><font style="vertical-align: inherit;">Para fazer isso, primeiro precisamos criar uma interface proxy simples e colocar o próprio barramento na propriedade condicionalmente privada de $ bus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, finalmente, adicione métodos de proxy ao objeto - porque agora o campo $ broadcast não fornece acesso direto ao barramento:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
        <span class="hljs-comment">// &gt;&gt;&gt;</span>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
        <span class="hljs-comment">// &lt;&lt;&lt;</span><font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, como toque final, lembremos que obtemos acesso ao barramento fechando, o que significa que os manipuladores adicionados uma vez não serão limpos com o componente, mas permanecerão durante todo o tempo trabalhando com o aplicativo. Isso pode causar efeitos colaterais desagradáveis, então vamos adicionar uma função de limpeza de ouvinte ao nosso barramento no final do ciclo de vida do componente:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeDestroy() {                               <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">this</span>.$broadcast.$off(<span class="hljs-keyword">this</span>.$broadcastEvents);  <span class="hljs-comment">// &lt;--</span><font></font>
      },<font></font>
<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">this</span>.$broadcastEvents = [];  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcastEvents.push(attrs[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$off =: <span class="hljs-function">(<span class="hljs-params">...attrs</span>) =&gt;</span> {  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$off(...attrs);   <span class="hljs-comment">// &lt;--</span><font></font>
        };<font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, essa opção fornece uma funcionalidade mais interessante, embora menos concisa. </font><font style="vertical-align: inherit;">Com ele, você pode implementar um sistema completo de comunicação alternativa entre componentes. </font><font style="vertical-align: inherit;">Além disso, ele está completamente sob nosso controle e não traz dependências externas ao nosso projeto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que, depois de ler, você tenha adquirido ou atualizado seus conhecimentos sobre os plug-ins do Vue e, talvez, da próxima vez que precisar adicionar alguma funcionalidade genérica ao seu aplicativo, possa implementá-lo com mais eficiência - sem adicionar dependências externas.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt488408/index.html">Gateway IoT Ethernet-RS485 STM32</a></li>
<li><a href="../pt488410/index.html">7 lições que aprendi em dez anos em desenvolvimento</a></li>
<li><a href="../pt488412/index.html">Criando um bot do Discord com base no discord.js</a></li>
<li><a href="../pt488416/index.html">SLAE - Exame de especialista em montagem do Security Linux</a></li>
<li><a href="../pt488418/index.html">Autenticação da API REST com Spring Security e MongoDB</a></li>
<li><a href="../pt488424/index.html">O que acontecerá com o ITSM em 2020?</a></li>
<li><a href="../pt488426/index.html">Como fazer uma revisão de código? Parte 2: revisão da navegação, velocidade, comentários, conflitos</a></li>
<li><a href="../pt488428/index.html">Como prever o futuro na pesquisa Yandex: de correções de erros a consultas de descoberta</a></li>
<li><a href="../pt488432/index.html">Snoop Project, uma ferramenta incrível para inteligência na Internet, que os usuários do RuNet estão esperando há tanto tempo - está disponível</a></li>
<li><a href="../pt488436/index.html">Crie rapidamente músicas de chiptune de código aberto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>