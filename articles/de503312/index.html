<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💄 🆓 🙏🏻 Wie kann ein Speicherverlust in einer Angular-Anwendung verursacht werden? 📌 🏴 💙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Leistung ist der Schlüssel zum Erfolg einer Webanwendung. Daher müssen Entwickler wissen, wie Speicherlecks auftreten und wie sie damit umgehen sollen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie kann ein Speicherverlust in einer Angular-Anwendung verursacht werden?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503312/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung ist der Schlüssel zum Erfolg einer Webanwendung. Daher müssen Entwickler wissen, wie Speicherlecks auftreten und wie sie damit umgehen sollen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Wissen ist besonders wichtig, wenn die Anwendung, mit der sich der Entwickler befasst, eine bestimmte Größe erreicht. Wenn Sie Speicherlecks nicht genügend Aufmerksamkeit schenken, kann es sein, dass der Entwickler in das „Team zur Beseitigung von Speicherlecks“ aufgenommen wird (ich musste Teil eines solchen Teams sein). </font><font style="vertical-align: inherit;">
Speicherlecks können aus verschiedenen Gründen auftreten. Ich glaube jedoch, dass bei der Verwendung von Angular möglicherweise ein Muster auftritt, das der häufigsten Ursache für Speicherverluste entspricht. Es gibt eine Möglichkeit, mit solchen Speicherlecks umzugehen. Und das Beste ist natürlich, Probleme nicht zu bekämpfen, sondern zu vermeiden.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/bg/op/jz/bgopjzk2msaiedpikpoa1qcv2cm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist Speicherverwaltung?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript verwendet ein automatisches Speicherverwaltungssystem. </font><font style="vertical-align: inherit;">Der Speicherlebenszyklus besteht normalerweise aus drei Schritten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisung des erforderlichen Speichers.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit zugewiesenem Speicher und führen Sie Lese- und Schreibvorgänge aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher freigeben, nachdem er nicht mehr benötigt wird.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sagt , </font><font style="vertical-align: inherit;">dass die </font><font style="vertical-align: inherit;">automatische Speicherverwaltung - ist es eine potentielle Quelle der Verwirrung. </font><font style="vertical-align: inherit;">Dies kann Entwicklern das falsche Gefühl geben, dass sie sich nicht um die Speicherverwaltung kümmern müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich überhaupt nicht um die Speicherverwaltung kümmern, bedeutet dies, dass nach dem Wachstum Ihrer Anwendung auf eine bestimmte Größe möglicherweise ein Speicherverlust auftritt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen können Speicherverluste als der der Anwendung zugewiesener Speicher betrachtet werden, den sie nicht mehr benötigt, der jedoch nicht freigegeben wird. </font><font style="vertical-align: inherit;">Mit anderen Worten, dies sind Objekte, bei denen keine Speicherbereinigungsvorgänge durchgeführt wurden.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert die Speicherbereinigung?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Garbage Collection-Prozedur, die ziemlich logisch ist, wird alles, was als "Garbage" betrachtet werden kann, gereinigt. </font><font style="vertical-align: inherit;">Der Garbage Collector bereinigt den Speicher, den die Anwendung nicht mehr benötigt. </font><font style="vertical-align: inherit;">Um herauszufinden, welche Speicherbereiche die Anwendung noch benötigt, verwendet der Garbage Collector den Algorithmus „Mark and Sweep“ (Tagging-Algorithmus). </font><font style="vertical-align: inherit;">Wie der Name schon sagt, besteht dieser Algorithmus aus zwei Phasen - der Markierungsphase und der Sweep-Phase.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Flaggenphase</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objekte und Links zu ihnen werden in Form eines Baumes dargestellt. </font><font style="vertical-align: inherit;">Die Wurzel des Baums ist in der folgenden Abbildung ein Knoten </font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In JavaScript ist dies ein Objekt </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jedes Objekt hat eine spezielle Flagge. </font><font style="vertical-align: inherit;">Nennen wir diese Flagge </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der Flagging-Phase werden zunächst alle Flags </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einen Wert gesetzt </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/436/b8a/433436b8a72bc7a207bd66c5b76788f5.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu Beginn werden die Flags markierter Objekte auf false gesetzt.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Anschließend wird der Objektbaum durchlaufen. </font><font style="vertical-align: inherit;">Alle Flags von</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekten, die vom Knoten aus erreichbar sind,</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden auf gesetzt</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und die Flags der Objekte, die nicht erreicht werden können, bleiben im Wert</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Objekt gilt als nicht erreichbar, wenn es vom Stammobjekt aus nicht erreicht werden kann.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/d14/a50/1cfd14a50f9be4e7aa402052982eb253.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erreichbare Objekte werden als markiert = wahr, nicht erreichbare Objekte als markiert = falsch markiert.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Daher</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleiben</font><font style="vertical-align: inherit;">alle Flags</font><font style="vertical-align: inherit;">nicht erreichbarer Objekte im Wert</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Speicher wurde noch nicht freigegeben, aber nach Abschluss der Markierungsphase ist alles für die Reinigungsphase bereit.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Reinigungsphase</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Speicher wird genau in dieser Phase des Algorithmus gelöscht. Hier werden alle nicht erreichbaren Objekte (deren Flag </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Wert verbleibt </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) vom Garbage Collector zerstört.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/75f/f16/8a075ff162428195665afe583a85151f.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektbaum nach Speicherbereinigung. </font><font style="vertical-align: inherit;">Alle Objekte, deren markiertes Flag auf false gesetzt ist, werden vom Garbage Collector zerstört. Die</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Garbage Collection wird regelmäßig ausgeführt, während das JavaScript-Programm ausgeführt wird. </font><font style="vertical-align: inherit;">Während dieses Vorgangs wird Speicher freigegeben, der freigegeben werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise stellt sich hier die folgende Frage: "Wenn der Garbage Collector alle als nicht erreichbar gekennzeichneten Objekte entfernt - wie kann ein Speicherverlust verursacht werden?". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Punkt hier ist, dass das Objekt nicht vom Garbage Collector verarbeitet wird, wenn die Anwendung es nicht benötigt, Sie es aber dennoch vom Stammknoten des Objektbaums aus erreichen können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus kann nicht wissen, ob die Anwendung einen Speicher verwendet, auf den sie zugreifen kann oder nicht. </font><font style="vertical-align: inherit;">Nur ein Programmierer hat solche Kenntnisse.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkelspeicherlecks</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen treten Speicherverluste im Laufe der Zeit auf, wenn eine Komponente wiederholt neu gerendert wird. </font><font style="vertical-align: inherit;">Zum Beispiel - durch Routing oder als Ergebnis der Verwendung der Direktive </font></font><code>*ngIf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Angenommen, in einer Situation, in der ein fortgeschrittener Benutzer den ganzen Tag mit der Anwendung arbeitet, ohne die Anwendungsseite im Browser zu aktualisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Szenario zu reproduzieren, erstellen wir eine Konstruktion aus zwei Komponenten. </font><font style="vertical-align: inherit;">Dies werden die Komponenten </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sein </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-sub *ngIf="hide"&gt;&lt;/app-sub&gt;`</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
&nbsp;&nbsp;hide = <span class="hljs-literal">false</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.hide = !<span class="hljs-keyword">this</span>.hide, <span class="hljs-number">50</span>);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Komponentenvorlage </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet die Komponente </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das Interessanteste dabei ist, dass unsere Komponente eine Funktion verwendet </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die </font></font><code>hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle 50 ms </font><font style="vertical-align: inherit;">das Flag wechselt </font><font style="vertical-align: inherit;">. Dies führt dazu, dass eine Komponente alle 50 ms neu gerendert wird </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das heißt, die Erstellung neuer Instanzen der Klasse wird durchgeführt </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dieser Code ahmt das Verhalten eines Benutzers nach, der den ganzen Tag mit einer Webanwendung arbeitet, ohne eine Seite in einem Browser zu aktualisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben verschiedene Szenarien implementiert, bei deren Verwendung im Laufe der Zeit Änderungen in der von der Anwendung verwendeten Speichermenge auftreten. Beachten Sie, dass die Komponente</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleibt immer gleich </font><font style="vertical-align: inherit;">In jedem Szenario werden wir herausfinden, ob es sich um einen Speicherverlust handelt, indem wir den Speicherverbrauch des Browserprozesses analysieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Speicherverbrauch des Prozesses mit der Zeit zunimmt, bedeutet dies, dass wir mit einem Speicherverlust konfrontiert sind. </font><font style="vertical-align: inherit;">Wenn ein Prozess eine mehr oder weniger konstante Speichermenge verwendet, bedeutet dies entweder, dass kein Speicherverlust vorliegt oder dass sich der Verlust, obwohl vorhanden, nicht auf ziemlich offensichtliche Weise manifestiert.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Szenario 1: große for-Schleife</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser erstes Szenario wird durch eine Schleife dargestellt, die 100.000 Mal ausgeführt wird. </font><font style="vertical-align: inherit;">In der Schleife werden dem Array zufällige Werte hinzugefügt. </font><font style="vertical-align: inherit;">Vergessen wir nicht, dass die Komponente alle 50 ms neu gerendert wird. </font><font style="vertical-align: inherit;">Schauen Sie sich den Code an und überlegen Sie, ob wir einen Speicherverlust verursacht haben oder nicht.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;arr = [];<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.arr.push(<span class="hljs-built_in">Math</span>.random());<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl ein solcher Code nicht an die Produktion gesendet werden sollte, entsteht kein Speicherverlust. </font><font style="vertical-align: inherit;">Der Speicherverbrauch überschreitet nämlich nicht den auf einen Wert von 15 MB begrenzten Bereich. </font><font style="vertical-align: inherit;">Infolgedessen tritt kein Speicherverlust auf. </font><font style="vertical-align: inherit;">Im Folgenden werden wir darüber sprechen, warum dies so ist.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Szenario 2: BehaviorSubject-Abonnement</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Szenario abonnieren wir </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Konstante und weisen ihr einen Wert zu. </font><font style="vertical-align: inherit;">Gibt es einen Speicherverlust in diesem Code? </font><font style="vertical-align: inherit;">Vergessen Sie nach wie vor nicht, dass die Komponente alle 50 ms gerendert wird.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es wie im vorherigen Beispiel keinen Speicherverlust.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Szenario 3: Zuweisen eines Werts zu einem Klassenfeld innerhalb eines Abonnements</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird fast derselbe Code wie im vorherigen Beispiel dargestellt. </font><font style="vertical-align: inherit;">Der Hauptunterschied besteht darin, dass der Wert nicht einer Konstanten, sondern einem Klassenfeld zugewiesen wird. </font><font style="vertical-align: inherit;">Und denken Sie jetzt, dass der Code undicht ist?</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie glauben, dass hier kein Leck vorhanden ist, haben Sie absolut Recht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Szenario 1 gibt es kein Abonnement. </font><font style="vertical-align: inherit;">In den Szenarien Nr. 2 und 3 haben wir den Stream des beobachteten Objekts abonniert, der in unserer Komponente initialisiert wurde. </font><font style="vertical-align: inherit;">Es fühlt sich so an, als wären wir sicher, wenn wir Komponentenflüsse abonnieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist, wenn wir unserem Programm Service hinzufügen?</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenarien, die den Dienst verwenden</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den folgenden Szenarien werden wir die obigen Beispiele überarbeiten, aber dieses Mal werden wir den vom Dienst bereitgestellten Stream abonnieren </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier ist der Servicecode.</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({
&nbsp;&nbsp;<span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyService</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;some$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="hljs-number">42</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor uns liegt ein einfacher Service. </font><font style="vertical-align: inherit;">Dies ist nur ein Dienst, der stream ( </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) in Form eines öffentlichen Klassenfelds </font><font style="vertical-align: inherit;">bereitstellt </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Szenario 4: Abonnieren eines Streams und Zuweisen eines Werts zu einer lokalen Konstante</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden hier das gleiche Schema neu erstellen, das bereits zuvor beschrieben wurde. </font><font style="vertical-align: inherit;">Diesmal abonnieren wir jedoch den Stream </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht das Feld der Komponente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt es ein Speicherleck? </font><font style="vertical-align: inherit;">Denken Sie bei der Beantwortung dieser Frage erneut daran, dass die Komponente häufig verwendet </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gerendert wird.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt haben wir endlich ein Speicherleck erzeugt. </font><font style="vertical-align: inherit;">Aber das ist ein kleines Leck. </font><font style="vertical-align: inherit;">Mit "kleines Leck" meine ich eines, das im Laufe der Zeit zu einem langsamen Anstieg des verbrauchten Speichers führt. </font><font style="vertical-align: inherit;">Dieser Anstieg ist kaum spürbar, aber eine flüchtige Überprüfung des Heap-Snapshots ergab, dass viele nicht gelöschte Instanzen vorhanden sind </font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Szenario 5: Abonnieren eines Dienstes und Zuweisen eines Werts zu einem Klassenfeld</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier abonnieren wir noch einmal </font></font><code>dummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diesmal weisen wir den resultierenden Wert dem Klassenfeld zu und nicht einer lokalen Konstante.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier haben wir endlich einen signifikanten Speicherverlust verursacht. </font><font style="vertical-align: inherit;">Der Speicherverbrauch überschritt innerhalb einer Minute schnell 1 GB. </font><font style="vertical-align: inherit;">Sprechen wir darüber, warum das so ist.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Wann ist ein Speicherverlust aufgetreten?</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise haben Sie bemerkt, dass wir in den ersten drei Szenarien keinen Speicherverlust verursachen konnten. </font><font style="vertical-align: inherit;">Diese drei Szenarien haben etwas gemeinsam: Alle Links sind lokal für die Komponente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein beobachtbares Objekt abonnieren, wird eine Liste von Abonnenten gespeichert. </font><font style="vertical-align: inherit;">Unser Rückruf befindet sich ebenfalls in dieser Liste, und der Rückruf kann sich auf unsere Komponente beziehen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/49f/92e/bda49f92eb184ad1eb78231a4144b71c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kein Speicherverlust</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn eine Komponente zerstört wird, dh wenn Angular keine Verbindung mehr zu ihr hat, was bedeutet, dass die Komponente nicht vom Wurzelknoten aus erreichbar ist, können das beobachtete Objekt und seine Liste der Abonnenten auch nicht vom Wurzelknoten aus erreicht werden. Infolgedessen wird das gesamte Komponentenobjekt durch Müll gesammelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solange wir ein beobachtbares Objekt abonniert haben, zu dem nur Links innerhalb der Komponente gehören, treten keine Probleme auf. Aber wenn der Dienst ins Spiel kommt, ändert sich die Situation.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/6f7/b5b/4546f7b5b2ab2d2858f550740243189e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverlust</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sobald wir ein beobachtbares Objekt abonniert haben, das von einem Dienst oder einer anderen Klasse bereitgestellt wurde, haben wir einen Speicherverlust erstellt. </font><font style="vertical-align: inherit;">Dies liegt an dem beobachteten Objekt aufgrund seiner Abonnentenliste. </font><font style="vertical-align: inherit;">Aus diesem Grund kann auf den Rückruf und damit auf die Komponente vom Stammknoten aus zugegriffen werden, obwohl Angular keinen direkten Verweis auf die Komponente hat. </font><font style="vertical-align: inherit;">Infolgedessen berührt der Garbage Collector das entsprechende Objekt nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde klarstellen: Sie können solche Konstruktionen verwenden, aber Sie müssen korrekt damit arbeiten und nicht wie wir.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordnungsgemäße Abonnementarbeiten</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Speicherverluste zu vermeiden, ist es wichtig, das beobachtete Objekt korrekt abzubestellen, wenn das Abonnement nicht mehr benötigt wird. Zum Beispiel, wenn eine Komponente zerstört wird. Es gibt viele Möglichkeiten, sich von einem beobachteten Objekt abzumelden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erfahrung mit der Beratung von Eigentümern großer Unternehmensprojekte zeigt, dass es in dieser Situation am besten ist, die </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vom Team erstellte </font><font style="vertical-align: inherit;">Entität </font></font><code>new Subject&lt;void&gt;()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Kombination mit dem Betreiber zu verwenden </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;private destroy$: Subject&lt;<span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-keyword">void</span>&gt;();<font></font>
&nbsp;&nbsp;randomNumber = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummyService.some$.pipe(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;takeUntil(<span class="hljs-keyword">this</span>.destroy$)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-keyword">this</span>.randomNumber = value);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;ngOnDestroy(): <span class="hljs-keyword">void</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.complete();<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier kündigen wir das Abonnement mit dem </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator und </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach der Zerstörung der Komponente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben einen Lifecycle-Hook in die Komponente implementiert </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jedes Mal, wenn eine Komponente zerstört wird, rufen wir </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methoden </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und auf </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Anruf ist </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr wichtig, da durch diesen Anruf das Abonnement gelöscht wird </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann benutzen wir den Operator </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und übergeben ihm unseren Stream </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch wird sichergestellt, dass das Abonnement gelöscht wird (dh dass wir das Abonnement abbestellt haben), nachdem die Komponente zerstört wurde.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man daran denken, Abonnements zu löschen?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist leicht zu vergessen, die Komponente hinzuzufügen </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Aufruf </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sowie den </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hook-Lebenszyklus zu </font><font style="vertical-align: inherit;">vergessen </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obwohl ich dies Teams beigebracht habe, die an Projekten arbeiten, habe ich es selbst oft vergessen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise gibt es eine wunderbare Linter-Regel, die Teil einer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von Regeln ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit denen Sie sicherstellen können, dass Abonnements ordnungsgemäß abgemeldet werden. </font><font style="vertical-align: inherit;">Sie können einen Regelsatz wie folgt festlegen:</font></font><br>
<br>
<pre><code class="javascript hljs">npm install @angular-extensions/lint-rules --save-dev
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann muss es verbunden sein mit </font></font><code>tslint.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-string">"extends"</span>: [
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"tslint:recommended"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"@angular-extensions/lint-rules"</span><font></font>
&nbsp;&nbsp;]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich empfehle Ihnen dringend, diese Regeln in Ihren Projekten zu verwenden. </font><font style="vertical-align: inherit;">Dies erspart Ihnen viele Stunden beim Debuggen beim Auffinden von Speicherleckquellen.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Angular ist es sehr einfach, eine Situation zu erstellen, die zu Speicherverlusten führt. </font><font style="vertical-align: inherit;">Selbst kleine Codeänderungen an Stellen, die anscheinend nicht mit Speicherlecks zusammenhängen sollten, können schwerwiegende nachteilige Folgen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der beste Weg, um Speicherlecks zu vermeiden, besteht darin, Ihre Abonnements korrekt zu verwalten. </font><font style="vertical-align: inherit;">Leider erfordert der Betrieb von Reinigungsabonnements vom Entwickler eine hohe Genauigkeit. </font><font style="vertical-align: inherit;">Das ist leicht zu vergessen. </font><font style="vertical-align: inherit;">Daher wird empfohlen, Regeln anzuwenden, mit </font></font><code>@angular-extensions/lint-rules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denen Sie die richtige Arbeit mit Ihren Abonnements organisieren können. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist das</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repository mit dem Code, der diesem Material zugrunde liegt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind in Angular-Anwendungen Speicherlecks aufgetreten?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503288/index.html">Wie wir mit maschinellem Lernen nach Kandidaten gesucht haben</a></li>
<li><a href="../de503290/index.html">DJI Matrice 300 RTK Industrie Quadrocopter Bewertung</a></li>
<li><a href="../de503300/index.html">Das Buch „Rick und Morty. Anleitung zum brillantesten Cartoon aller Galaxien »</a></li>
<li><a href="../de503302/index.html">Beschleunigung eines auf CMake + GCC basierenden Projekts: Vorkompilierung von Header-Dateien</a></li>
<li><a href="../de503310/index.html">Was denken ältere Programmierer?</a></li>
<li><a href="../de503318/index.html">Beruf: Programmierer. Nicht alles ist klar</a></li>
<li><a href="../de503322/index.html">Firmware-Entwicklung: Einführung</a></li>
<li><a href="../de503324/index.html">"Auf dem Höhepunkt" von Brad Stalberg und Steve Magness: Verhinderung der Selbstentzündung (Teil 1)</a></li>
<li><a href="../de503328/index.html">Wir kompilieren die Spring Boot-Anwendung mit GraalVM in native</a></li>
<li><a href="../de503330/index.html">Wie man von einem Datenwissenschaftler lernt: Die meistgesuchten technischen Fähigkeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>