<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛴 🚎 🤦🏽 ブラウザのセルオートマトン 👌🏾 🎻 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="セルオートマトンは、グリッド内の数値を持つセルと、これらのセルの動作を決定するルールで構成されるシステムです。グリッドの視覚化と並行してルールを各グリッドセルに繰り返し適用すると、ルールが比較的単純であっても、複雑で複雑な動作を伴う特定の進化する生物の効果を得ることができます。
 
 セルオートマト...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ブラウザのセルオートマトン</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481672/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルオートマトンは、グリッド内の数値を持つセルと、これらのセルの動作を決定するルールで構成されるシステムです。グリッドの視覚化と並行してルールを各グリッドセルに繰り返し適用すると、ルールが比較的単純であっても、複雑で複雑な動作を伴う特定の進化する生物の効果を得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルオートマトンには、さまざまな形、種類、寸法があります。おそらく最も有名なセルオートマトンは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">コンウェイゲーム「ライフ」</font></a><font style="vertical-align: inherit;">でしょう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（コンウェイの人生ゲーム、GOL）。これは、各セルにバイナリ値（ライブまたはデッド）が含まれる2次元グリッドで構成されます。付随するルールは、隣接セルの状態に基づいて、セルが死んでいるか生きているかを決定します。ルールによれば、周囲に2つ未満の生細胞があると、生細胞は孤独で死ぬという。 3つ以上の隣接する細胞が生存している場合、彼女は過密状態で死亡します。言い換えると、セルの周囲にちょうど2つまたは3つの生きている隣接セルがある場合、そのセルは「存続」します。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死んだ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">細胞が生き返る</font><font style="vertical-align: inherit;">ためには、</font><font style="vertical-align: inherit;">ちょうど3つの生きている隣接細胞がなければなりません。そうでなければ、死んだままです。いくつかの状態を繰り返すGoLマシンの例を以下に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/8d3/d06/5628d3d06c87bcf93b7949f8ea5eec7a.gif" alt="人生のゲーム"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルオートマトンのもう1つの有名なバージョンは1次元です。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、基本的なセルラーオートマトン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Elementary Cellular Automaton、ECA）</font><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、この投稿で実装するものです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオートマトンの各状態はブール値の1次元配列として格納されます。GOL状態を視覚化するには2次元が必要ですが、このオートマトンには1つの値のオートマトンで十分です。</font><font style="vertical-align: inherit;">これにより、アニメーションではなく2つの次元を使用して、このオートマトンの状態の履歴全体を視覚化できます。</font><font style="vertical-align: inherit;">GOLの場合と同様に、このマシンのセルの状態は0または1ですが、8つのネイバーに応じて更新されるGOLセルとは異なり、ECAセルは左のネイバー、右のネイバー、およびそれ自体の状態に基づいて更新されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルールの例を以下に示します。上部の3つのセルはルールの入力で、下部のセルは出力です。ここで、黒は1、白は0です。また、初期状態が1以外のすべて0の場合、各セルによって生成されたパターンを確認できます。真ん中のセルに。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/c6d/69a/7adc6d69a6e6f302850bc9227ea8bdb1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは疑問に思うかもしれません：なぜ上に提示されたルールは数字で示されているのですか？</font><font style="vertical-align: inherit;">0から255の範囲の各数値はECAルールに直接対応するため、これらの数値はルールの名前として使用されます。</font><font style="vertical-align: inherit;">この対応を以下に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a41/65e/13b/a4165e13bf83463bbf66a155ba8441fd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値からルールへ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
0から255の範囲の数値は、8桁のみを使用してバイナリ形式で表すことができます（上記の最初の矢印）。</font><font style="vertical-align: inherit;">さらに、これらの番号のそれぞれに、その位置に基づいてインデックスを付けることができます（2番目の矢印）。</font><font style="vertical-align: inherit;">当然、これらのインデックスの範囲は0〜7です。つまり、3桁（3番目の矢印）だけを使用して、バイナリ形式で表すことができます。</font><font style="vertical-align: inherit;">これらの3桁を入力として解釈し、元の数値の対応する桁を出力として解釈すると、必要な3項関数が得られます（4番目の矢印）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール生成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の解釈を、</font></font><code>get_rule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0〜255の数値を入力として受け取り、その数値に対応するECAルールを返す</font><font style="vertical-align: inherit;">高次関数として実装してみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようなものを作成する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> rule30 = get_rule(<span class="hljs-number">30</span>);
<span class="hljs-keyword">const</span> output110 = rule30(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、起動は</font></font><code>rule30(1,1,0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つのバイナリ値すべてを1つの数値（110 = 6）に結合し、30のバイナリ表現でその位置（6）のビットを返します。バイナリ表現の数値30は00011110なので、関数は0を返します（右側を数えますカウントダウンを0から開始します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのバイナリ入力変数が1つの数値に結合されることがわかっているので、そのような関数を実装することから始めましょう</font></font><code>combine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">b1, b2, b3</span>) =&gt;</span> (b1 &lt;&lt; <span class="hljs-number">2</span>) + (b2 &lt;&lt; <span class="hljs-number">1</span>) + (b3 &lt;&lt; <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数を対応する位置に左シフトし、シフトされた3つの数値を合計すると、目的の組み合わせが得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の2番目の重要な部分は、</font></font><code>get_rule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値の特定の位置でビット値を決定することです。</font><font style="vertical-align: inherit;">したがって、指定さ</font></font><code>get_bit(num, pos)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れた数値の指定された位置</font></font><code>pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">ビット値を返すことができる</font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成してみましょう</font></font><code>num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、バイナリ形式の数値141は10001101なので、</font></font><code>get_bit(2, 141)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を返す</font><font style="vertical-align: inherit;">必要</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がありますが、</font></font><code>get_bit(5, 141)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を返す必要があり</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数</font></font><code>get_bit(num,pos)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、最初に数値の</font></font><code>pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">右</font><font style="vertical-align: inherit;">へのビットシフトを</font><font style="vertical-align: inherit;">実行し、次に数値1とのビット演算「AND」を</font><font style="vertical-align: inherit;">実行することで実装できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> get_bit = <span class="hljs-function">(<span class="hljs-params">num, pos</span>) =&gt;</span> (num &gt;&gt; pos) &amp; <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、これら2つの関数を組み合わせる必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> get_rule = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">b1, b2, b3</span>) =&gt;</span> get_bit(num, combine(b1, b2, b3));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいね！</font><font style="vertical-align: inherit;">したがって、間隔内の数値ごとに、何でも実行できる一意のECAルールを提供する関数があります。</font><font style="vertical-align: inherit;">次のステップは、ブラウザでそれらをレンダリングすることです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルールの視覚化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素を使用して、ブラウザでオートマトンをレンダリングします</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のように、</font><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">を作成してhtml本文に追加できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);<font></font>
  canvas.width = <span class="hljs-number">800</span>;<font></font>
  canvas.height = <span class="hljs-number">800</span>;<font></font>
<font></font>
  <span class="hljs-built_in">document</span>.body.appendChild(canvas);<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と対話する</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキスト</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">コンテキストを使用すると、図形や線を描画したり、オブジェクトに色を付けたり、一般的に移動したりでき</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">それは私</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><code>getContext</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たちの</font><font style="vertical-align: inherit;">方法を通じて</font><font style="vertical-align: inherit;">私</font><font style="vertical-align: inherit;">たちに提供され</font><font style="vertical-align: inherit;">ます</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータ</font></font><code>'2d'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、この例で使用するコンテキストのタイプを指し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、コンテキスト、ECAルール、およびセルのスケールと数に関するいくつかの情報を使用して、ルールをに描画する関数を作成します</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アイデアは、グリッドを1行ずつ生成して描画することです。コードの主要部分は次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw_rule</span>(<span class="hljs-params">ctx, rule, scale, width, height</span>) </span>{
  <span class="hljs-keyword">let</span> row = initial_row(width);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) {<font></font>
    draw_row(ctx, row, scale);<font></font>
    row = next_row(row, rule);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の行である、ある種のセルの初期セットから始めます。上記の例のように、この行には通常、中央のセルの1つの単位を除いてすべてゼロが含まれていますが、1と0の完全にランダムな行を含めることもできます。このセルの行を描画し、ルールを使用して次の値の行を計算します。現在の行。次に、描画を繰り返し、グリッドが十分に高くなるまで新しいステップを計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードのために、我々は3つの機能を実現する必要がある</font></font><code>initial_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>draw_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>next_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>initial_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンプルな機能です。ゼロの配列を作成し、配列の中央の要素を1つ変更します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initial_row</span>(<span class="hljs-params">length</span>) </span>{
  <span class="hljs-keyword">const</span> initial_row = <span class="hljs-built_in">Array</span>(length).fill(<span class="hljs-number">0</span>);<font></font>
  initial_row[<span class="hljs-built_in">Math</span>.floor(length / <span class="hljs-number">2</span>)] = <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-keyword">return</span> initial_row;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにルール関数があるため、関数</font></font><code>next_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は1行で構成できます。新しい行の各セルの値は、最も近いセルの値を使用してルールを適用した結果であり、古い行が入力として使用されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> next_row = <span class="hljs-function">(<span class="hljs-params">row, rule</span>) =&gt;</span> row.map(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> rule(row[i - <span class="hljs-number">1</span>], row[i], row[i + <span class="hljs-number">1</span>]));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちがこの行をだましていることに気づきましたか？新しい行の各セルには他の3つのセルからの入力が必要ですが、行の端にある2つのセルは2つだけからデータを受信します。たとえば、</font></font><code>next_row[0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から入力値を取得しようとしています</font></font><code>row[-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。配列にないインデックスで値にアクセスしようとすると、JavaScriptはを返し</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、偶然にも</font></font><code>(undefined &gt;&gt; [ ])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（関数から</font></font><code>combine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）常に0を返す</font><font style="vertical-align: inherit;">ため、これは引き続き</font><font style="vertical-align: inherit;">機能し</font><font style="vertical-align: inherit;">ます。これは、実際には、配列外の各値を処理することを意味します0として</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、私は、これは醜いであることを知っているが、すぐに私たちは赦されることができるようにすることを、画面上の美しいものを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次は関数</font></font><code>draw_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。レンダリングは彼女が担当！</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw_row</span>(<span class="hljs-params">ctx, row, scale</span>) </span>{<font></font>
  ctx.save();<font></font>
  row.forEach(<span class="hljs-function"><span class="hljs-params">cell</span> =&gt;</span> {<font></font>
    ctx.fillStyle = cell === <span class="hljs-number">1</span> ? <span class="hljs-string">'#000'</span> : <span class="hljs-string">'#fff'</span>;<font></font>
    ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, scale, scale);<font></font>
    ctx.translate(scale, <span class="hljs-number">0</span>);<font></font>
  });<font></font>
  ctx.restore();<font></font>
  ctx.translate(<span class="hljs-number">0</span>, scale);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここから、少なくとも5つの異なるメソッドを使用して、コンテキストオブジェクトに大きく依存しています。</font><font style="vertical-align: inherit;">ここに簡単なリストとそれらを使用する方法があります。</font></font><br>
<br>
<ul>
<li><code>fillStyle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形状をどのように塗りつぶすかを示します。</font><font style="vertical-align: inherit;">たとえば、色や</font></font><code>"#f55"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラデーション、パターンを使用できます。</font><font style="vertical-align: inherit;">この方法を使用して、セル0とセル1を視覚的に分離します。</font></font></li>
<li><code>fillRect(x, y, w, h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント（x、y）から幅wと高さhの長方形を描画し、に従って塗りつぶし</font></font><code>fillStyle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私たちの長方形は単純な正方形ですが、それらすべての始点が原点にあることに驚くかもしれません。</font><font style="vertical-align: inherit;">この方法をと組み合わせて使用​​したために発生しました</font></font><code>translate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><code>translate(x, y)</code>     .  ,         . ,            ,  ,   ,   .</li>
<li><code>save()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">他の座標変換方法</font></font><code>restore()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と組み合わせて使用​​され</font></font><code>translate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">それらを使用して</font><font style="vertical-align: inherit;">、特定のポイントで現在の座標系</font><font style="vertical-align: inherit;">を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存し、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後で（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><em><font style="vertical-align: inherit;">して</font></em><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">そこに戻ることができるようにし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この場合、ラインをレンダリングする前に座標系を保存し、右に移動します。</font><font style="vertical-align: inherit;">そして、線を引いて右端まで行くと、座標が復元されて元の状態に戻ります。</font><font style="vertical-align: inherit;">次に下に移動して、次の線を引く準備をします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、関数に必要なすべてのパーツが揃いました</font></font><code>draw_rule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この機能は</font></font><code>window.onload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備後に</font><font style="vertical-align: inherit;">使用します</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、必要なパラメータも決定します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> width = <span class="hljs-number">1000</span>; <span class="hljs-comment">// Width of the canvas</span>
  <span class="hljs-keyword">const</span> height = <span class="hljs-number">500</span>; <span class="hljs-comment">// Height of the canvas</span><font></font>
<font></font>
  <span class="hljs-keyword">const</span> cells_across = <span class="hljs-number">200</span>; <span class="hljs-comment">// Number of cells horizontally in the grid</span>
  <span class="hljs-keyword">const</span> cell_scale = width / cells_across; <span class="hljs-comment">// Size of each cell</span>
  <span class="hljs-keyword">const</span> cells_down = height / cell_scale; <span class="hljs-comment">// Number of cells vertically in the grid</span><font></font>
<font></font>
  <span class="hljs-keyword">const</span> rule = get_rule(<span class="hljs-number">30</span>); <span class="hljs-comment">// The rule to display</span><font></font>
<font></font>
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);<font></font>
  canvas.width = width;<font></font>
  canvas.height = height;<font></font>
<font></font>
  <span class="hljs-built_in">document</span>.body.appendChild(canvas);<font></font>
<font></font>
  <span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);<font></font>
  draw_rule(context, rule, cell_scale, cells_across, cells_down);<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディメンション</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を個別の変数として、水平方向のセル数とともに</font><font style="vertical-align: inherit;">抽出し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に</font></font><code>cell_scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、グリッドが全体を埋めるように 'cells_down' </font><font style="vertical-align: inherit;">を計算しますが</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、セルは正方形のままです。</font><font style="vertical-align: inherit;">これにより、グリッド内の「解像度」を簡単に変更できます</font></font><code>canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/566/33e/d9856633e69f731e69a8ae40a79591c2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です！</font><font style="vertical-align: inherit;">完全なコード例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codepenにあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先へ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシステムのおかげで、256のすべてのルールを繰り返し、コードを変更するか、ページの読み込みごとにランダムにルール番号を選択して、次々に調べることができます。</font><font style="vertical-align: inherit;">とにかく、私たちの制御された環境でこれらすべての予測不可能な結果を​​研究することは非常にエキサイティングです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、オートマトンのセルの初期状態を、静的な「固体のゼロと1単位」の代わりにランダムにすることもできます。</font><font style="vertical-align: inherit;">したがって、さらに予測できない結果が得られます。</font><font style="vertical-align: inherit;">このバージョンの関数</font></font><code>initial_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、次のように書くことができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random_initial_row</span>(<span class="hljs-params">width</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">Array</span>(width), _ =&gt; <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、この出力行の変更が出力に大きな影響を与える度合いを示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/023/75e/6a602375ecbe522ad75829547ee92b5f.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムなソース文字列</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、変更可能な側面の1つにすぎません。</font><font style="vertical-align: inherit;">なぜ2つの条件のみに制限するのですか？</font><font style="vertical-align: inherit;">（2状態から3状態への移行により、ルールの数が256から7に増加します625 597 484 987！）なぜ正方形に制限されるのですか？</font><font style="vertical-align: inherit;">なぜ2次元しかないのですか？</font><font style="vertical-align: inherit;">なぜ一度に1つのルールだけですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECAに基づく視覚化の例を以下に示しますが、</font></font><code>draw_rule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正方形ではなく等角パターンで線を描画し、これらの線で定義された領域を色で塗りつぶす</font><font style="vertical-align: inherit;">代替関数</font><font style="vertical-align: inherit;">を使用しています。</font><font style="vertical-align: inherit;">分割線を表示する必要はなく、色のみを表示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに進んだ場合は、アキシャル（中央の行）とミラー（下の行）の両方で対称性を追加できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/cad/adc/f71cadadc23b156366f5bb93669d8b06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの視覚化が面白そうだったが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このインタラクティブなサンドボックス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはそれ以上のことを</font><font style="vertical-align: inherit;">研究する場合は、</font><font style="vertical-align: inherit;">作成したコードから始めて、独自のセルオートマトンを考えてみてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸運を</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481658/index.html">ZabbixでPortSecurity Cisco Switchイベントを監視する</a></li>
<li><a href="../ja481662/index.html">Kubernetesでデプロイを構築および自動化するための新しいツールを試す</a></li>
<li><a href="../ja481664/index.html">サーバーレスの価格とコスト：AWS Lambda</a></li>
<li><a href="../ja481666/index.html">カスタムSwiftLintルール</a></li>
<li><a href="../ja481670/index.html">AWSクラウド導入フレームワークを使用してアクションプランを作成する</a></li>
<li><a href="../ja481674/index.html">自動車販売の目標到達プロセス、またはどのようにして顧客を統合し、サービスを拒否した人と協力しないようにするか？</a></li>
<li><a href="../ja481676/index.html">セキュリティウィーク52：スマートスピーカーとIPカメラのセキュリティ</a></li>
<li><a href="../ja481678/index.html">ホリデー前のレビュー：N6IIT01プレーヤーとYB04補強ヘッドフォン-中国南部のHi-Fi</a></li>
<li><a href="../ja481680/index.html">TodoMVCはdapで書いています。パート2</a></li>
<li><a href="../ja481684/index.html">Powerbankのラップトップ？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>