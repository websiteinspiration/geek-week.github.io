<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐿️ ✍🏼 ♊️ Mehrfarbige Fenster: virtueller Konstruktor, CRTP und komplizierte Vorlagen 🕯️ 👨🏾‍🤝‍👨🏼 🚞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit geraumer Zeit ist ein nicht triviales Entwurfsmuster bekannt, wenn eine abgeleitete Klasse im Basisparameter übergeben wird:
 

template<class T>...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mehrfarbige Fenster: virtueller Konstruktor, CRTP und komplizierte Vorlagen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seit geraumer Zeit ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht triviales Entwurfsmuster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekannt, </font><font style="vertical-align: inherit;">wenn eine abgeleitete Klasse im Basisparameter übergeben wird:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Vorlage hat ihren eigenen Namen - CRTP: Curiously Recurring Template Pattern, was übersetzt "seltsam wiederholtes Muster" bedeutet. Ich habe dieser ohnehin schon seltsamen Konstruktion noch mehr Kuriositäten hinzugefügt: Ich habe sie auf eine ganze Kette von Erbschaften verallgemeinert. Ja, es kann wirklich getan werden, aber dafür muss man </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Seele geben</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um einen hohen Preis zu zahlen. Um herauszufinden, wie ich es gemacht habe und welchen Preis ich zahlen muss, lade ich Sie ein, diesen Artikel für weitere Details zu lesen.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier werden wir </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit schrecklichen Perversionen durch</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verschiedene seltsame Methoden und andere schlechte Dinge </font><font style="vertical-align: inherit;">umgehen </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte Sie sofort warnen: Nehmen Sie das hier beschriebene Material nicht als etwas Ernstes. Ich bin sicher, dass in 95-99% der Fälle all dies für Sie in der Praxis niemals nützlich sein wird. Dies ist eine Art unterhaltsame Mathematik, ein Training für den Geist. In der Praxis ist es unwahrscheinlich, dass es nützlich ist, aber es ist interessant, Zeit dafür aufzuwenden. Nur in diesem Fall fungieren die C ++ - Sprache und ihre Funktionen als Mathematik. Ich warne Sie im Voraus, weil Wenn Sie hier etwas Ernstes und Praktisches suchen, werden Sie möglicherweise enttäuscht sein.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich sofort auf das Exotische ein, als ob Sie sich plötzlich in einem Land befänden, in dem zwei Monde, drei Sonnen, Blätter von Pflanzen blau oder lila sind, und tatsächlich sind viele übliche Dinge hier irgendwie ... seltsam und ungewöhnlich ... Wenn Sie im grauen Alltag versunken sind und vor nicht allzu langer Zeit Lesen Sie so etwas, dann kamen Sie zu der Adresse ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrfarbige Fenster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war vor langer Zeit. </font><font style="vertical-align: inherit;">Vor fast drei Jahren. </font><font style="vertical-align: inherit;">Ich </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saß</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann </font><s><font style="vertical-align: inherit;">auf schwerem Gras und verstand</font></s><font style="vertical-align: inherit;"> nur die </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen-</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basis von C ++ 11/14 aus dem Buch Meyers S. - "Effektives und modernes C ++". </font><font style="vertical-align: inherit;">Es erwähnt auch dieses Muster. </font><font style="vertical-align: inherit;">Nachdem ich das Gefühl hatte, </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Erleuchtung erreicht zu haben</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">die Grundlagen des neuen Standards beherrscht zu haben und bereit war, alte Dinge auf eine neue Art und Weise zu betrachten, begann ich, ein Buch über die Windows-API zu aktualisieren: Schupak Y. - „Win32-API. </font><font style="vertical-align: inherit;">Effektive Anwendungsentwicklung. “ </font><font style="vertical-align: inherit;">Ganz am Anfang wird ein minimales C-Sprachprogramm zum Erstellen und Anzeigen eines Fensters beschrieben:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe dies bereits viele Male getan und verschiedene Fenster auf dem Modell dieses Buches angezeigt. </font><font style="vertical-align: inherit;">Und plötzlich dachte ich: Ich habe erst gestern über C ++ gelesen! </font><font style="vertical-align: inherit;">Ich kann meine eigene Klasse schreiben, um dieses Fenster anzuzeigen! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gesagt, getan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur der Klasse ist trivial: Es werden mehrere Konstruktoren deklariert (mit der Übertragung sowohl der Hauptparameter als auch der Links zur detaillierteren WNDCLASSEX-Struktur), der CreateWnd-Funktion der Fensterklassenregistrierung und der Fenstererstellung selbst, die von den Konstruktoren aufgerufen wird, sowie einer Reihe virtueller Elementfunktionen, die Aktionen ausführen Verarbeiten jeder Windows-Nachricht innerhalb der Fenster-Rückrufprozedur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mitglieder der Klassendaten sind ebenfalls minimal: Fensterhandle hWnd; WNDCLASSEX-Struktur zum Erstellen der Klasse; und die Titelleiste des Fensters.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fensterrückrufprozedur wird als statisch deklariert, um zu vermeiden, dass dieser Zeiger implizit an das Klassenobjekt übergeben wird, und damit die Vereinbarung über den Typ (die Signatur) der Funktion der in Windows akzeptierten Fensterprozedur zu verletzen (denken Sie daran, dass wir diese Funktion nicht selbst aufrufen, sondern Windows, weil Die Parameter und der Rückgabetyp dieser Funktion sind genau angegeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fensterprozedur und dieser Zeiger</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus C ++ ist bekannt: Wenn eine Member-Funktion als statisch definiert ist, muss explizit ein Zeiger auf ein Klassenobjekt an dieses übergeben werden. Wir können jedoch keinen Zeiger auf ein Klassenobjekt an eine statische Fensterprozedur übergeben, da das Format dieser Funktion diese Übertragung nicht zulässt. In diesem Zusammenhang tritt ein grundlegendes Problem auf: Wenn es mehrere Objekte der WindowClass-Klasse gibt, woher weiß dann die einzige statische Fensterprozedur, welches bestimmte Klassenobjekt die Nachricht empfangen hat? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nur einen Ausweg: Sie müssen diese Verbindung auf die eine oder andere Weise herstellen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows identifiziert ein Fenster anhand seines HWND hWnd-Handles. Das diesem Fenster entsprechende Klassenobjekt kann durch einen Zeiger auf dieses Objekt identifiziert werden. Daher muss der Verbindungszeiger hWnd &lt;-&gt; zum WindowClass-Objekt hergestellt werden. Beispielsweise könnte eine Fensterprozedur, die gleichzeitig Mitglied einer Klasse ist, einen Link oder einen Zeiger auf eine ebenfalls statische Datenstruktur haben, die für jedes Fenster eine Verbindung zwischen hWnd und einem Zeiger auf ein Objekt herstellt und jedes Mal aktualisiert wird, wenn ein Objekt der Klasse erstellt wird. Die Datenstruktur muss statisch sein, damit erstens innerhalb einer statischen Fensterprozedur ohne Zeiger auf ein Klassenobjekt auf sie zugegriffen werden kann, und zweitens sollte sie für alle Objekte der Klasse eindeutig sein (was logischerweise aus ihrem Zweck folgt ) und drittensDamit ist es immer noch an eine Klasse mit der entsprechenden Zugriffsebene gebunden und keine externe globale Variable.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir nun herausgefunden haben, wie diese Struktur zu beschreiben ist und warum sie benötigt wird, müssen wir erst noch herausfinden, wie diese Struktur aussehen sollte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es können zwei dynamische Arrays deklariert werden: eines für HWND-Fensterhandles und das zweite für Zeiger auf WindowClass-Objekte. Dies ist jedoch nicht die beste Lösung: Es ist nicht klar, wie die Größe des Arrays ausgewählt werden soll, wie die Szenarien für die Verwendung von Fenstern aussehen sollen und ob die Arrays bei falscher Auswahl fast leer sind, was zu einem Speicherüberlauf führt. Im Gegenteil, wenn beim Erstellen von Fenstern das Volumen erschöpft ist, muss die Größe usw. erhöht werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine bessere (und sogar ich würde sagen - ideale) Lösung in dieser Situation ist eine Liste ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Eine Liste ist eine dynamische Datenstruktur, die aus einer Reihe von Knoten besteht, die paarweise verbunden sind. Jeder Knoten (im Fall einer doppelt verknüpften Liste) verfügt über Zeiger auf den vorherigen und nächsten Knoten der Liste sowie über zusätzliche gespeicherte Daten. In unserer Situation entspricht jeder Fensterknoten jedem der Fenster, und die nützlichen Daten sind ein Fensterhandle und ein Zeiger auf ein Objekt der WindowClass-Klasse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Mal, wenn ein neues Fenster erstellt wird, wird ein neuer Listenknoten erstellt und an dessen Ende hinzugefügt (wird der letzte). Beim Schließen wird der Knoten gelöscht und die Zeiger des vorherigen und nächsten Knotens werden aufeinander abgestimmt, um den Remote-Knoten zu ersetzen. Gleichzeitig gibt es keine Speicherüberschreitung - genau so viele Knoten werden erstellt wie Fenster erstellt, und sie werden auch gelöscht, wenn das Fenster geschlossen wird.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher sollte der WindowClass-Klasse auch ein neues statisches Element hinzugefügt werden:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und deklarieren Sie es als privilegiert, damit es auf WindowClass-Mitglieder zugreifen kann:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ich werde hier jetzt keine Definition der Listenklasse und der Knotenklasse, ihrer Funktionen, geben, da dies nicht direkt für die WindowClass-Klasse gilt und die Implementierungslogik dieser Klasse bekannt und ziemlich trivial ist.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist die Fensterprozedur, wenn eine neue Nachricht für den Fall eintrifft gehört zu der Nummer, die es verarbeitet, gemäß dem von Windows an Windows übergebenen Fensterdeskriptor hWnd, greift auf die Liste zu, sucht nach einem Knoten darin gemäß dem angegebenen hWnd und erhält beim Auffinden den erforderlichen Zeiger auf ein Objekt der WindowClass-Klasse. Anschließend ruft er per Zeiger eine virtuelle Funktion auf, die der zu verarbeitenden Nachricht entspricht: Für eine überschriebene Klasse kann eine virtuelle Funktion mit demselben Namen andere Aktionen ausführen.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es einen subtilen Punkt. Es betrifft die Initialisierung der Klasse und die Verarbeitung der WM_CREATE-Nachricht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines Fensters mit der CreateWindow-Funktion ist zum Zeitpunkt des Aufrufs das hWnd-Fensterhandle noch nicht bekannt: Das Fenster wurde noch nicht erstellt! Um virtuelles OnCreate aufrufen zu können, müssen Sie daher den Zeiger auf das Klassenobjekt kennen. Dies geschieht durch ziemlich riskantes Übergeben des Zeigers this von der WindowClass :: CreateWnd-Funktion an die CreateWindow-Funktion über den lParam-Zeiger. Bei der Verarbeitung von WM_CREATE empfängt die Fensterprozedur diesen Zeiger vom Parameter, initialisiert mit ihrer Hilfe das hWnd-Element im Objekt und erstellt dann mit dem Zeiger auf das Klassenobjekt einen neuen Listenknoten für dieses Fenster. Anschließend wird das virtuelle OnCreate per Zeiger aufgerufen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die verbleibenden Nachrichten wird die oben beschriebene Logik ausgeführt: Suchen Sie nach dem Listenknoten mit dem aktuellen Fensterhandle hWnd, das von Windows übertragen wurde, und rufen Sie dann die gewünschte virtuelle Funktion mit dem Zeiger auf das Klassenobjekt vom Listenknoten auf. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich das Programm zusammengestellt und sichergestellt hatte, dass alles richtig </font><font style="vertical-align: inherit;">funktioniert, begann ich weiter zu lesen </font><font style="vertical-align: inherit;">, wobei ich mir die Hände </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über das Gefühl meiner eigenen Größe</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der geleisteten Arbeit rieb. </font><font style="vertical-align: inherit;">Und dort auf der nächsten Seite wird die Funktion zum Ändern der Fenstereigenschaften angezeigt:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich entschied mich sofort vor Ort, ein neues Fenster basierend auf dem alten zu erstellen:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die abgeleitete Klasse unterscheidet sich von der Basisklasse durch Hinzufügen eines statischen Fensterzählers sowie durch Ändern von OnCreate, OnPaint und OnDestroy: Die OnCreate-Funktion ändert die Hintergrundfarbe des Fensters, OnPaint zeigt eine andere Meldung an und OnDestroy verringert den statischen Fensterzähler. </font><font style="vertical-align: inherit;">Alles ist sehr einfach und klar. </font><font style="vertical-align: inherit;">Zusammengebaut und gestartet. </font><font style="vertical-align: inherit;">Der Nachrichtentext ist anders geworden, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aber die Farbe des Fensters hat sich nicht geändert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtueller Konstruktor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wurde mir klar, dass ich bereits dünnes Eis betreten hatte. </font><font style="vertical-align: inherit;">Nicht alle Nuancen sind im Grundmaterial der Hauptbücher beschrieben. </font><font style="vertical-align: inherit;">Einer von ihnen ist ein virtueller Konstruktor. </font><font style="vertical-align: inherit;">Ich dachte, dass das Aufrufen der virtuellen Funktion der abgeleiteten Klasse vom Konstruktor genau das gleiche ist wie überall im Programm. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies nicht möglich war.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem besteht darin, dass die vom Konstruktor aufgerufene virtuelle Funktion als nicht virtuell aufgerufen wird: Nur das Objekt der Basisklasse wird erstellt, und zwar erst am Ende, und das abgeleitete Objekt wurde noch nicht erstellt, und die Tabelle der virtuellen Funktionen wurde nicht generiert. In unserem Fall erhalten wir die Kette: Derivatkonstruktor -&gt; Basiskonstruktor -&gt; CreateWnd -&gt; CreateWindow -&gt; Fensterprozedur -&gt; OnCreate, dh OnCreate wird tatsächlich vom Konstruktor aufgerufen. Das abgeleitete Objekt wurde noch nicht erstellt, daher wird OnCreate für die Basisklasse aufgerufen! Es stellt sich heraus, dass seine Neudefinition in der Ableitung keinen Sinn ergibt! Was ist zu tun?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus C ++ ist bekannt, dass jede überschriebene Funktion unter ihrem vollständigen Namen aufgerufen werden kann: Klassenname :: Funktionsname. Ein Klassenname ist nicht nur ein Name: Er identifiziert sich selbst als Objekttyp. Aus C ++ ist auch bekannt, dass eine Klasse (und Funktion) als Vorlage (Vorlage) erstellt werden kann, indem der Typ (ihr) als Parameter übergeben wird. Wenn Sie daher die Funktionsvorlage für Fensterprozeduren erstellen und den Typ der abgeleiteten Klasse auf irgendeine Weise übergeben, können Sie die gewünschte überschriebene Funktion direkt im Konstruktor der </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisklasse</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Halt halt halt !!! Das kannst du nicht machen !!! Eine abgeleitete Klasse wurde noch nicht erstellt, ihre Daten wurden nicht initialisiert: Welche Funktionen werden Sie hier aufrufen? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie nicht können, aber wirklich wollen, können Sie.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich wollte ich die abgeleitete Klasse nicht voll ansprechen. </font><font style="vertical-align: inherit;">Ich wollte eine </font><font style="vertical-align: inherit;">WinAPI-Funktion </font><font style="vertical-align: inherit;">eines </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drittanbieters</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">, die nichts mit der Klasse zu tun hat. </font><font style="vertical-align: inherit;">"Aber das kann auf ganz andere Weise und viel einfacher gemacht werden!" </font><font style="vertical-align: inherit;">- du sagst. </font><font style="vertical-align: inherit;">Ja. </font><font style="vertical-align: inherit;">Kann. </font><font style="vertical-align: inherit;">Und ich werde am Ende des Artikels darüber schreiben. </font><font style="vertical-align: inherit;">Aber in diesem Moment warf ich das alles beiseite und konzentrierte mich auf die rein technische Seite der Frage: Aber ist es dennoch möglich, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktor der Basisklasse </font><b><font style="vertical-align: inherit;">im Prinzip</font></b><font style="vertical-align: inherit;"> etwas aus der Ableitung aufzurufen? </font><font style="vertical-align: inherit;">Es war ein rein sportliches Interesse, wenn Sie möchten. </font><font style="vertical-align: inherit;">Ich habe in diesem Moment an keine praktische Seite gedacht. </font><font style="vertical-align: inherit;">Es war eine nicht triviale Aufgabe, und ich fragte mich, ob ich sie lösen könnte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenstervorlagenklasse - Methode 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schwierigkeit besteht also darin, wie der Typ der abgeleiteten Klasse an die Fensterprozedur übergeben wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wollte nicht die gesamte Basisklasse von WindowClass auf einmal zu einer Vorlagenklasse machen: Für jede abgeleitete Klasse wird eine eigene Basisklasse generiert. Da WindowClass zur Vorlage wird, müssen außerdem sowohl die Listenknoten als auch die Liste selbst als Vorlage erstellt werden: Sie verfügen über Zeiger auf Klassenobjekte. Um diese Zeiger verwenden zu können, müssen sie ihren Typ kennen, dh WindowClass, und wissen, wie sie parametrisiert werden . Zum Zeitpunkt der Definition der Listenklasse und der Knotenklasse ist dies nicht bekannt. Daher muss dieser Typ auch als Parameter (von WindowClass) übergeben werden. Daraus folgt, dass für jede abgeleitete Klasse eine eigene Liste erstellt wird, die </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser abgeleiteten Klasse entspricht</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(und nur er)! Und jetzt können Sie keine Zeiger auf die Basisklassen, die verschiedenen Ableitungen entsprechen, in ein Array setzen: Sie haben verschiedene Typen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also suchte ich nach einer Möglichkeit, den Typ der abgeleiteten Klasse zu übergeben, ohne die gesamte Klasse zu parametrisieren. Ein Typ kann nur über den Konstruktor an die Basisklasse übergeben werden: Dies ist die einzige Funktion, auf die beim Erstellen des Objekts zugegriffen wird. Daher sollte es Boilerplate sein. Es stellte sich jedoch heraus, dass sie die Vorlagenparameter offensichtlich nicht angeben konnte: Es würde so aussehen, als würde sie Parameter an die Vorlagenklasse selbst und nicht an ihren Konstruktor übergeben. Daher kann der Typ nur aus den an den Konstruktor übergebenen Parametern abgeleitet werden. Ich wollte jedoch keinen speziellen Konstruktorparameter hinzufügen, der nur zur Typinferenz dient: die Liste der Argumente mit einem reinen Hilfsparameter überladen. Und wenn der Benutzer zum Beispiel vergisst, es zu übertragen, z.durch mindestens die triviale (DerivedClass *) nullptr? Dies ist noch nicht beängstigend - der Compiler zeigt eine Fehlermeldung an, dass die Klasse nicht instanziiert werden kann. Schlimmer noch, wenn der Benutzer eine Klassenhierarchie erstellt und einen Zeiger auf die falsch abgeleitete Klasse übergibt: Unter dem Gesichtspunkt der Kompilierung ist alles korrekt, aber wir erhalten ein falsch funktionierendes Programm mit einem unverständlichen Fehler.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, diese Konstruktionsfehlkalkulation ist eine solche Lösung. </font><font style="vertical-align: inherit;">Somit wird die Verantwortung für die korrekte Instanziierung nicht einmal auf den Schöpfer der abgeleiteten Klasse übertragen, sondern auf denjenigen, der sie verwenden wird! </font><font style="vertical-align: inherit;">Und er kann weder ein Traum noch ein Geist in Bezug auf solche Nuancen sein und versteht aufrichtig nicht, wo der Fehler liegt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich aufgegeben hatte, entschied ich mich dennoch, ohne die Konstruktorparameter zu ändern, WindowClass selbst und gleichzeitig die zugehörigen Listen- und Listenknotenklassen zu parametrisieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClass-Vorlagenklasse:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abgeleitete Klasse:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Fensterprozedur, die ein Vorlagenmitglied einer Vorlagenklasse ist und Zugriff auf den übergebenen Typ der abgeleiteten Klasse hat, ruft OnCreate der abgeleiteten Klasse auf. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kommen also natürlich zur CRTP-Vorlage. Hier stellte sich heraus, von selbst. Erst viel später stellte ich fest, dass es sich bei diesem Design um eine bekannte Vorlage mit dem entsprechenden Namen handelt. Aber dann wusste ich das nicht und es schien mir, dass ich es zum ersten Mal erhielt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir wurde sofort klar, dass dies nur die halbe Lösung ist. </font><font style="vertical-align: inherit;">Ich kann leicht eine andere Klasse basierend auf dieser Ableitung erstellen wollen. </font><font style="vertical-align: inherit;">Und das war's: Es ist kein Boilerplate und akzeptiert keine Parameter mehr. </font><font style="vertical-align: inherit;">Also kam mir die Idee, die zweite abgeleitete Klasse durch die erste Ableitung an die Basisklasse zu übergeben. </font><font style="vertical-align: inherit;">(Das dünne Eis unter meinen Füßen begann zu knacken ... Ich ging bereits dorthin, wo es keine Rückkehr gab.) Aber wenn ich es einmal mache, kann ich es so oft machen, wie ich möchte: Selbst wenn ich zehn abgeleitete Klassen habe, kann ich die zehnte in Folge nehmen ( die letzte), um entlang der Kette zur Basis zu gelangen, und sie nennt dort die Funktion dieser letzten Ableitung, die ich brauche (und im Allgemeinen - jede Zwischenableitung, falls gewünscht). </font><font style="vertical-align: inherit;">Die Aufgabe war klar. </font><font style="vertical-align: inherit;">Alles was übrig blieb war es zu tun.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parametrisierte Fensterklasse - Methode 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim zweiten Lauf habe ich mir drei Aufgaben gestellt:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Anforderungen zu erfüllen, müssen Sie natürlich noch eine Vorlage für den Designer erstellen und einen speziellen Parameter hinzufügen. Dies bedeutet jedoch einen Verstoß gegen eine andere Anforderung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist hier die Lösung? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die ursprüngliche Basisklasse WindowClass in zwei Komponenten unterteilen: die WindowClass selbst (nennen wir sie jetzt WindowClassBase), die eine einzige unerschütterliche Grundlage darstellt und die abgeleitete Klasse ergänzt (die immer noch den gleichen ursprünglichen Namen WindowClass haben kann). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die komplementäre Klasse ist für die Implementierung von OnCreate verantwortlich und kann außerdem als Ganzes parametrisiert werden. Und er in seinem Konstruktor übergibt den an ihn übergebenen Typ über einen speziellen Parameter an den Konstruktor der WindowClassBase-Klasse.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Fall müssen Sie in WindowClassBase relativ zur Quelle jetzt einige Änderungen vornehmen. Zusätzlich zum tatsächlichen Entfernen von OnCreate müssen Sie der Klasse, die es ergänzt (und in Zukunft Ableitungen davon), ein Zeigerelement sowie eine Aufruffunktion hinzufügen, die OnCreate über diesen Zeiger aufruft: Wir können den Zeiger nicht auf den Basiszeiger aufrufen. Da OnCreate nicht mehr darin enthalten ist und OnCreate der Klassen, die komplementär sind und daraus abgeleitet werden, ist es besser, es mit dem richtigen Zeiger auf die gewünschte Klasse aufzurufen, als mit diesem Zeiger der Basis etwas zu versuchen. Letztendlich wird der spezielle Parameter des WindowClassBase-Konstruktors nicht nur für die Typinferenz benötigt, sondern auch zum Speichern und anschließenden Aufrufen der erforderlichen Klasse über OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider musste der Typ dieses Zeigers ungültig gemacht werden:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klasse ist keine Vorlage, und Sie können den Compiler nicht anweisen, einen Zeiger mit einem unbekannten Typ zu erstellen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Ableitungen werden von der Basisklasse geerbt. Sie haben alle unterschiedliche Typen. Welchen Zeigertyp sollte ich verwenden?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende habe ich es nur im C-Stil deklariert: Verwenden Sie in jeder seltsamen Situation einen Zeiger, um ungültig zu werden. </font><font style="vertical-align: inherit;">Der Zeiger wird physisch als typenlos gespeichert, aber zum Zeitpunkt des Aufrufs wird OnCreate in den Typ der aufgerufenen Klasse umgewandelt. </font><font style="vertical-align: inherit;">Dies erfolgt in einer speziellen Vorlagenaufruffunktion, die zu WindowClassBase gehört und deren Parametertyp zum Zeitpunkt des Aufrufs bekannt ist:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Anfangs wurde std :: true_type oder std :: false_type als zweiter Parameter verwendet, um die gewünschte Option zum Überschreiben der Funktion auszuwählen. Mit der SFINAE-Methode wurde in der Kompilierungsphase festgestellt, ob die WndCls-Klasse über eine OnCreate-Memberfunktion verfügt. Wenn dies der Fall ist, wird die obige Version der Funktion aufgerufen. Ist dies nicht der Fall, wurde der Aufruf von OnCreate in folgender Form durchgeführt:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Später stellte sich heraus, dass SFINAE nicht erforderlich war: Eine Klasse, die WindowClassBase ergänzt, verfügt in jedem Fall über eine OnCreate-Memberfunktion. Selbst wenn in der übergebenen WndCls-Parameterklasse OnCreate nicht definiert ist, befindet sie sich in einer der Basisklassen und Überprüfung wird in allen Fällen wahr geben. Wenn durch ein Wunder die ergänzende Klasse so geändert wird, dass OnCreate daraus entfernt wird, und in allen davon abgeleiteten Klassen auch nicht, dann macht es keinen Sinn, sie gemäß der zweiten Option aufzurufen: Ein solcher Code wird einfach nicht kompiliert. Daher wird am Ende hier die obige Option angegeben.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Logik zum Akzeptieren und Verwenden des Basisklassentyps in WindowClassBase ist recht einfach: Der Typ wird vom Zeiger auf das Objekt der abgeleiteten Klasse abgeleitet, die an den WindowClassBase-Konstruktor übergeben wird, dieser Zeiger wird in diesem Konstruktor gespeichert und der Zeiger auf die Vorlagenfensterprozedur wird durch den übergebenen Typ instanziiert, und auf die obige LaunchOnCreate wird zugegriffen . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher sieht die WindowClassBase-Klasse jetzt folgendermaßen aus:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Code für den kürzesten Konstruktor:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb der Fensterprozedur lautet der Aufruf von LaunchOnCreate wie folgt:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er beschloss, die Fensterprozedur selbst aus der Klasse außerhalb zu entfernen und sie in der WindowClassBase-Klasse für privilegiert zu erklären. Vielleicht ergab das nicht viel Sinn: Welchen Unterschied macht es, wo seine Instanziierungen erzeugt werden - außerhalb oder innerhalb der Klasse? Das Codesegment ist eins! Obwohl ich zugeben muss, dass Sie es unter dem Gesichtspunkt der gleichen Kapselung vielleicht immer noch statisch in der Klasse lassen sollten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt die komplementäre Klasse zu definieren:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Klasse verfügt über einen Konstruktor, der vor dem Teilen genauso aussieht wie die ursprüngliche WindowClass, dh ohne einen speziellen Parameter. Dieser spezielle Parameter wird intern generiert, wenn auf den WindowClassBase-Konstruktor zugegriffen wird, indem der Zeiger übergeben wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese WindowClass in dieser Form entspricht fast der ursprünglichen WindowClass. </font><font style="vertical-align: inherit;">Daher wird die Vererbung mit OnCreate-Überschreibungen nicht unterstützt. </font><font style="vertical-align: inherit;">Dies ist jedoch der Ausgangspunkt für die Unterstützung der Vererbung (wie unten gezeigt wird). </font><font style="vertical-align: inherit;">In dieser Form:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basisklasse WindowClassBase ist an sich nicht generisch, was bedeutet, dass sie die einzige für alle abgeleiteten Klassen ist, unabhängig davon, um welche es sich handelt. </font><font style="vertical-align: inherit;">Die Liste, die sicherstellt, dass alle anderen Windows-Nachrichten korrekt verarbeitet werden, ist ebenfalls die einzige.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der WindowClass-Konstruktor verfügt über keinen speziellen Parameter.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen, sind zwei der drei Anforderungen erfüllt. </font><font style="vertical-align: inherit;">Es bleibt mit letzterem zu tun: mit der Vererbung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeleitete Verkettung von Klassentypen in WindowClassBase, Steuerelementtyp</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst werden wir eine einmalige Vererbung in Betracht ziehen, wenn die Initialisierungslogik von WindowClass nicht zu uns passt und wir sie ändern möchten, indem wir (zumindest vorerst) eine abgeleitete Klasse erstellen. </font><font style="vertical-align: inherit;">Was muss in WindowClass geändert werden, um dies sicherzustellen? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine neue Variante der Komplementärklasse wird Boilerplate. </font><font style="vertical-align: inherit;">Dies ist nicht beängstigend, da es tatsächlich keine Daten enthält, sondern nur die OnCreate-Funktion und die Konstruktoren:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse nimmt einen Parameter vom Typ DerWndCls und übergibt ihn beim Konvertieren dieses Zeigers an WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie auf static_cast. Dies ist wichtig, da meine Konvertierung ursprünglich wie folgt im C-Stil geschrieben wurde:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich es überall in static_cast übersetzt hatte, wurde die Hälfte des Codes (siehe unten) nicht kompiliert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist auch ein subtiler Punkt: Die Konvertierung wird in der Kompilierungsphase durchgeführt, aber diese Klasse selbst verfügt über die OnCreate-Funktion, und nach der Konvertierung kann DerWndCls verwendet werden, um OnCreate der DerWndCls-Klasse aufzurufen. </font><font style="vertical-align: inherit;">Dies ist der Unterschied zu dem oben in WindowClassBase beschriebenen Konvertierungsfall. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können Sie eine bestimmte Klasse WindowClassDerived erstellen, OnCreate darin überschreiben und mit der oben beschriebenen WindowClassTemplate instanziieren, wobei Sie erneut dieselbe seltsame, sich wiederholende Vorlage implementieren, die am Anfang des Artikels angegeben ist:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und OnCreate von diesem WindowClassDerived wird nach Bedarf in der WindowClassBase aufgerufen!</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist jedoch eine einmalige Vererbung. </font><font style="vertical-align: inherit;">Bei Mehrfachvererbung sollten Sie anstelle von WindowClassDerived eine neue Vorlage deklarieren, wobei die Klasse möglicherweise eine höhere Ebene in der Hierarchie einnimmt und an WindowClassTemplate übergeben wird. </font><font style="vertical-align: inherit;">Ich möchte speziell zwei wichtige Punkte hervorheben:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potenziell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Host-Klasse in der Hierarchie. </font><font style="vertical-align: inherit;">Dies bedeutet, dass es möglicherweise keine Klasse akzeptiert, dh selbst die oberste Klasse der Hierarchie ist, sodass daraus ein Objekt erstellt werden kann.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übertragungsparameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WindowClassTemplate. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das akzeptierte Vorlagenargument von Klasse zu Klasse über die gesamte Vererbungskette bis ganz nach unten in WindowClassTemplate und von dort an WindowClassBase übergeben werden muss.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, einerseits muss die Klasse eine Vorlage sein und eine bestimmte Klasse als Parameter verwenden. Andererseits muss es die Situation überwachen, dass es sich selbst um eine endliche Klasse (zum Zeitpunkt der Instanziierung) handelt, und die Basisklasse selbst und nicht nach dem übergebenen Typ instanziieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei alledem möchte ich, dass dies automatisch vom Compiler durchgeführt wird: Das Definieren einer neuen Klasse basierend auf einer bereits erstellten Klasse erfordert keine Modifikation der letzteren - dann geht das gesamte Wesen des Vererbungspolymorphismus verloren. Das heißt: Ich erstelle eine Klasse, die derzeit ganz oben in der Hierarchie steht, aber dann wird </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">möglicherweise</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine neue Klasse basierend darauf erstellt, die die aktuelle ersetzt, ohne ihre Definition zu ändern. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie implementiere ich diese Funktionalität?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem der Automatisierung und intelligenten Entscheidungsfindung zu lösen, bietet sich das Standardargument für die Vorlage an: Wenn die aktuell erstellte Klasse die oberste ist und der Vorlagenparameter nicht an sie übergeben wird, müssen wir diesen Parameter ihr zuweisen. Dies wird mit dem Standardargument erreicht. Dann stellen sich folgende Fragen: Wie wählt man es aus und wie bezieht man es auf die Situation des explizit übergebenen Parameters und überträgt sich selbst, wenn der Parameter nicht übergeben wird? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider können Sie keine eigene definierte Klasse als Standardparameter schreiben. Der Compiler wird den Code des Formulars einfach nicht verpassen:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er berichtet, dass eine rekursive Typabhängigkeit zu komplex ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen wir auf die andere Seite. </font><font style="vertical-align: inherit;">Lassen Sie uns eine fiktive Klasse vorstellen, die nichts funktional tut und nichts speichert, die Rolle von nur Dummy-Plugs spielt und dem Compiler signalisiert, dass im Falle seines Auftretens nichts „von oben“ übertragen wird:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und im Standardargument ersetzen Sie uns durch diesen Knebel:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Option wird diese Klasse in der Situation mit dem Standardargument an WindowClassTemplate übergeben. </font><font style="vertical-align: inherit;">Die thisclass-Klasse verfügt nicht über eine OnCreate-Memberfunktion, daher wird diese Option einfach nicht kompiliert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir dann, einen zweiten Hilfssteuerungsparameter einzuführen, auf dessen Grundlage wir entscheiden, welcher Typ weitergegeben werden soll. </font><font style="vertical-align: inherit;">Dazu müssen Sie natürlich die WindowClassTemplate wie folgt ändern:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird nicht ein Typ übertragen, sondern zwei. Basierend auf der Kombination dieser beiden Typen wird der endgültige Typ mit den Tools &lt;type_traits&gt; bestimmt: std :: conditional_t ​​und std :: is_same. Dieser Typ wird an WindowClassBase übergeben. Die Auswahllogik wird in den Kommentaren beschrieben: Wenn diese Klasse an ControlType übergeben wird, wählen wir DerWndCls aus, andernfalls wird ControlType selbst ausgewählt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen wir nun eine Vorlage, die sie beim Erben verwendet:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Parameter wird standardmäßig über diese Klasse initialisiert, und ControlType wird basierend auf DerWndCls selbst berechnet: Wenn DerWndCls = thisclass, dann ControlType: = thisclass, andernfalls ControlType: = DerWndCls (speziell angegebene Pascal-Zuweisung zur Unterscheidung vom Vergleich). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes wird die von DerWndCls parametrisierte WndClsDerivedTemplateClass-Klasse selbst zusammen mit dem berechneten Steuerelementtyp (in der Kompilierungsphase) übergeben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein Objekt dieser Klasse erstellen, dh WndClsDerivedTemplateClass selbst steht an der Spitze der Hierarchie, dann wird DerWndCls = ControlType = thisclass und dann &lt;WndClsDerivedTemplateClass, thisclass&gt; übergeben. Die Tatsache, dass WndClsDerivedTemplateClass von einem Dummy parametrisiert wird, spielt keine Rolle - dieser Typ und tatsächlich alle an Ort und Stelle übergebenen DerWndCls werden in der Klasse in keiner Weise verwendet: Es wird kein Objekt daraus erstellt und keine Funktion wird durch sie aufgerufen. Daher kann WndClsDerivedTemplateClass formal buchstäblich mit allem instanziiert werden - der Parametertyp dient nur dazu, weiter entlang der Vererbungslinie zu gehen. Anstelle von DerWndCls wurde jedoch WndClsDerivedTemplateClass &lt;diese Klasse oder ein anderer Typ&gt; weitergegeben: WndClsDerivedTemplateClass verfügt über eine OnCreate-Funktion.Dies wird in WindowClassBase aufgerufen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Option wird diese Klasse anstelle des ControlType in die WindowClassControlBaseTemplate aufgenommen, und der endgültige Typ wird als DerWndCls = WndClsDerivedTemplateClass angezeigt, für den die erforderliche OnCreate-Funktion erforderlich ist. Welches ist was wir brauchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun die Option, wenn eine neue Klasse basierend auf WindowClassControlBaseTemplate erstellt wird (weitere Vererbung):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ersetzt in WndClsDerivedTemplateClass etwas anderes als diese Klasse DerWndCls, und ControlType übernimmt angesichts dieses Unterschieds den an DerWndCls übergebenen Wert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der WindowClassControlBaseTemplate lautet die folgende Parametrierungsoption: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In WindowClassControlBaseTemplate verwendet ControlType! = Thisclass wiederum den ControlType selbst, der WindowClassDerivedTemplateNext entspricht. Dies ist die richtige Klasse für die Auswahl von OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick scheint bei einem solchen Schema alles gut zu sein. Aber das ist nicht so. Wir bauen eine weitere Klasse auf der Grundlage der letzteren:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In WindowClassDerivedTemplateNext ersetzt WindowClassDerivedTemplateNext2 DerWndCls. ControlType wird auch als WindowClassDerivedTemplateNext2 ausgegeben. Anschließend wird WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass übergeben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und </font><b><font style="vertical-align: inherit;">ControlType</font></b><font style="vertical-align: inherit;"> zeigt denselben WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt; an. Als nächstes werden die gleichen Werte an WindowClassControlBaseTemplate übergeben, und dort wird anstelle der korrekten WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNext2erDerminalDiveTer WindowText</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erinnere Sie daran, dass bei diesem Schema des Erbens und Übergebens von Parametern der Typ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><b><font style="vertical-align: inherit;">selbst</font></b><font style="vertical-align: inherit;"> , der als Ergebnis zu WindowClassControlBaseTemplate kam, wichtig ist und nicht das, womit sie parametrisiert wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher müssen Sie die Definition der WindowClassDerivedTemplateNext-Klasse ändern, damit der Typ, für den OnCreate aufgerufen wird, korrekt angezeigt wird:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall wird dann in WndClsDerivedTemplateClass der richtige Wert, der WindowClassDerivedTemplateNext2 entspricht, an den ControlType übergeben, anstatt dort im falschen Wert angezeigt zu werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher sollte die letzte Klasse, die wir erstellen, ControlType nicht übergeben, damit die nächstgelegene Basisklasse sie unabhängig ausgeben kann. Diese Basisklasse und alle zugrunde liegenden Klassen müssen ControlType explizit übergeben, um die automatische Ausgabe auf den falschen Wert zu verhindern. Dieser Ansatz impliziert eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderung der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definition der nächsten Basisklasse, die nur möglich ist, wenn der Quellcode verfügbar ist oder wir ihn zuvor selbst erstellt haben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir dies vergessen und gegen diese Regel verstoßen haben, wird bei Verwendung von static_cast ein Kompilierungsfehler angezeigt. Wenn wir Zeiger im C-Stil in WindowClassControlBaseTemplate konvertieren, erhalten wir ein </font><font style="vertical-align: inherit;">Programm, </font><font style="vertical-align: inherit;">das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht ordnungsgemäß</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert. Zum Beispiel, wenn wir versuchen, ein Objekt für eine Klasse zu erstellen</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann gibt der Compiler einen Fehler aus: Er kann die Zeigertypen in der WindowClassControlBaseTemplate nicht konvertieren, da der Typ falsch war und nicht konvertiert werden kann (da wir ein Objekt der WindowClassDerivedTemplateNext-Klasse erstellen, gehen wir davon aus, dass sich die WindowClassDerivedTemplateNext-Klasse selbst oben befindet Hierarchie, und in diesem Fall sollte ControlType, wie oben gezeigt, nicht übergeben werden. Ohne static_cast wird der Code kompiliert und ruft einfach OnCreate der falschen Klasse auf. Durch Entfernen der ControlType-Übertragung wird das Programm jedoch erneut kompiliert.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich ist dies alles zu kompliziert, unzuverlässig und erfordert die Verfügbarkeit von Quellcodes aller Klassen. </font><font style="vertical-align: inherit;">Außerdem können wir nur Objekte der zuletzt abgeleiteten Klasse erstellen, und eine ihrer Basisklassen kann aufgrund der ControlType-Übertragung nicht erstellt werden (oder wenn der Zeiger im C-Stil übergeben wird, diese Objekte jedoch falsch initialisiert werden). </font><font style="vertical-align: inherit;">Wir brauchen eine andere Lösung, einfacher und zuverlässiger.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Vorlage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obige Variante der Vorlagenvererbung und die Übergabe des Typs des erstellten Objekts an die WindowClassBase-Klasse, in der das Fenster erstellt und OnCreate aufgerufen wird, weist jedoch schwerwiegende Nachteile auf. Wir brauchen eine andere, zuverlässigere und effizientere Option. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C ++ 11 wird ein neuer Vorlagentyp eingeführt: eine Vorlage mit einer variablen Anzahl von Argumenten oder eine variable Vorlage. Seine Parameter sind eine Folge von Typen bisher unbekannter Länge. Anstelle riskanter Manipulationen mit dem Steuerelementtyp im vorherigen Beispiel habe ich mich für den anderen Weg entschieden: Um Situationen zu vermeiden, in denen die Zwischenklasse in der Hierarchie die übergeordnete Klasse in der Hierarchie durch falsche Parametrisierung ersetzt (im obigen Beispiel war es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;) können Sie diese Art der Parametrisierung im Allgemeinen entfernen, indem Sie diese Klassen einfach nebeneinander platzieren. Beispielsweise wird mit drei aufeinanderfolgenden Vererbungen in den Vorlagenparametern schließlich die folgende Liste gebildet: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Liste genauer verarbeiten, eines ihrer letzten Elemente (abhängig davon, wie Sie sie zusammengestellt haben) Sie können die gewünschte Klasse in der Hierarchie extrahieren und damit arbeiten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall sollten Sie anstelle der zuvor beschriebenen Vorlagen WindowClassTemplate und WindowClassControlBaseTemplate, die der Stamm-WindowClassBase am nächsten liegen und die Grundlage für alle anderen Vererbungen bilden, eine neue variable Vorlagenklasse schreiben. In seiner einfachsten Version wird es so sein:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst wird eine allgemeine Beschreibung der Klassenvorlage ohne den Body deklariert. Dann wird seine Spezialisierung festgelegt, bei der der erste Typ vom Rest getrennt wird. Er ist für uns von Interesse. Dies gilt für den Fall, dass sich jede nachfolgende Klasse beim Verschieben der Hierarchiekette zu WindowClassBase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Parameterliste </font><font style="vertical-align: inherit;">befindet </font><font style="vertical-align: inherit;">. Dann wird die Klasse, die wir brauchen, am Anfang sein, und es ist sehr einfach, sie vom Rest zu trennen. Sie können es anders machen: Jede neue Klasse stellt sich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an den Anfang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der Vorlagenoptionen. Dann ist die Klasse oben in der Hierarchie die letzte in der Liste, und das Extrahieren von dort ist viel schwieriger. In diesem speziellen Fall sind diese beiden Ansätze völlig identisch, aber der erste ist viel einfacher zu implementieren (auch während der Kompilierung - Sie müssen nicht die gesamte Liste verarbeiten, indem Sie das letzte Element daraus extrahieren), und er ist es, der oben angegeben ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Element, das die höchste Klasse in der Hierarchie darstellt, wird aus der Liste abgerufen und an WindowClassBase übergeben. Wenn OnCreate dafür definiert ist, wird es aufgerufen. Andernfalls wird das OnCreate der nächsten Basisklasse in Bezug darauf aufgerufen. Wenn die Variablenparameterliste leer ist (wir versuchen, ein Objekt aus WindowClassVariadicTemplate zu erstellen), schlägt die Kompilierung fehl und erfordert mindestens einen Typ in der Parameterliste.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Klasse, die auf WindowClassVariadicTemplate basiert, sieht folgendermaßen aus:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse, die eine undefinierte Liste von PrevWndClasses-Parametern akzeptiert hat, übergibt sie weiter an die Basisklasse und fügt sich als erstes Element mit einer leeren Liste von Parametern davor ein. </font><font style="vertical-align: inherit;">Da diese Klasse WindowClassVariadic1 selbst variabel ist, ist WindowClassVariadic1 &lt;&gt; ebenfalls variabel, allerdings ohne Parameter, und diese gesamte Folge von Klassen ist tatsächlich eine variable Vorlage, von der jedes Element auch eine variable Vorlage ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende abgeleitete Klasse ist:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Ausnahme der Änderung des Namens der Ableitung und der Basis hat die Klasse genau die gleiche Form wie die vorherige. </font><font style="vertical-align: inherit;">Die nächste Klasse ist ähnlich:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Bedeutung der polymorphen Mehrfachvererbung: Indem wir eine Klasse auf diese Weise deklarieren, garantieren wir nicht nur die Erstellung von Objekten dieses Typs, sondern auch alle Objekte aller anderen daraus abgeleiteten Klassen, egal wie viel und was auch immer sie in Zukunft sind. In diesem Fall wird in WindowClassBase immer das richtige OnCreate aufgerufen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist diese Variablenvorlage die erste Möglichkeit, das Problem des Aufrufs von OnCreate beim Erstellen eines Fensters zu lösen, das alle zuvor festgelegten Anforderungen vollständig erfüllt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Blick auf die Zukunft, in der letztendlich die beste Methode in der gegebenen Situation gefunden wurde, können Sie mit der Implementierung der Vererbung über eine Variablenvorlage eine komplexere Kompilierungslogik in WindowClassBase implementieren: Wenn Sie auf alle Typen zugreifen können, bei denen die Vererbung stattgefunden hat, können Sie flexibel zwischen den erforderlichen auswählen oder Kriterien und rufen Sie die darin definierte Elementfunktion auf. </font><font style="vertical-align: inherit;">Dies ist jedoch immer noch ein etwas anderer Fall.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierungsklasse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ich die Reaktion von static_cast auf abgeleitete Typen nicht kannte, suchte ich weiter nach anderen Möglichkeiten, um die Übertragung der Vertex-Klasse der Hierarchie an WindowClassBase zu implementieren. </font><font style="vertical-align: inherit;">Irgendwann dachte ich darüber nach, die OnCreate-Implementierung in eine separate Klasse zu bringen, die speziell dafür erstellt wurde:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse parametrisiert eine andere Klasse, die alle anderen Überschreibungen für virtuelle Funktionen implementiert. </font><font style="vertical-align: inherit;">Es leitet sich aus der bereits beschriebenen WindowClassTemplate ab:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klassenvererbung erfolgt wie gewohnt für virtuelle Funktionen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur die speziell für die Implementierung von OnCreate definierte Initialisierungsklasse wird gemäß der Vererbungskette von Klasse zu Klasse übertragen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Befindet sich diese Klasse am oberen Rand der Hierarchie, entspricht der Parameter WndClsInit WindowClassInit1 - der für diese Klasse definierten Initialisierungsklasse - und wird weiter entlang der Hierarchiekette übertragen. Wenn diese Klasse in der Kette zwischengeschaltet ist, akzeptiert sie einfach die an sie übergebene Klasse und gibt sie weiter. Dann ist diese Option im Vergleich zu den vorherigen insofern günstig, als die Vorlagen sich nicht selbst übertragen, sondern eine Klasse von Drittanbietern übertragen, was viel einfacher implementiert ist (und aussieht). Eine Vorlage in dieser Form eignet sich auch ohne Änderungen für die Implementierung der gesamten Vererbungskette: Es erfolgt nur die Änderung von Klassennamen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zur Konvertierung im C-Stil wird in WindowClassTemplate diese Form der Vererbung in static_cast jedoch nicht übersehen: Sie kann einfach nicht konvertiert werden, wenn diese von (WindowClassTemplate *) nach (WindowClassInit1 *) übergeben wird. </font><font style="vertical-align: inherit;">Und das ist logisch: WindowClassInit1 ist eigentlich eine fremde Klasse, die nur als Typ an diesen Punkt übergeben wurde. Sie ist in keiner Weise mit WindowClassTemplate und der gesamten Kette von Ableitungen davon verbunden, daher ist eine Zeigerkonvertierung in diese Klasse nicht akzeptabel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeleitete Verkettung von Klassentypen in WindowClassBase, bedingte Übertragung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schließlich wurde für diese Situation der beste Weg gefunden, den Typ der abgeleiteten Klasse über die gesamte Vererbungskette auf die Stammbasis WindowClassBase zu übertragen, ohne die Nachteile der vorherigen und gleichzeitig einfacher als die variable Vorlage. </font><font style="vertical-align: inherit;">Definieren Sie die folgende Vorlagenklasse basierend auf WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse akzeptiert DerWndCls als Parameter, der standardmäßig dieser Klasse entspricht. </font><font style="vertical-align: inherit;">Während der Übertragung wird DerWndCls mit dieser Klasse verglichen: Bei Gleichheit (der Standardwert, dh die angegebene Klasse befindet sich oben in der Hierarchie) übergibt sie sich selbst mit einer leeren Liste von Parametern. </font><font style="vertical-align: inherit;">Andernfalls werden die empfangenen DerWndCls weitergeleitet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich halte diese Lösung in jeder Hinsicht für die beste in dieser Situation:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine einzige Form der Klassendefinition für die gesamte Vererbungskette;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfache und transparente Logik der Klassenübertragung entlang der gesamten Vererbungskette;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kein Overhead aufgrund der variablen Vorlage (in diesen Fällen, wie in diesem Fall, wenn dies nicht erforderlich ist).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreckliche Vergeltung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeutet das alles? </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie, wenn Sie eine solche unkonventionelle Form der Vererbung verwenden möchten, alle Ihre Klassen streng definiert formalisieren müssen, damit sie die Übertragung einer möglichen neuen Ableitung durch sich selbst ermöglichen. </font><font style="vertical-align: inherit;">Dies ist eine sehr einfache Anforderung, und wenn Sie es wünschen, ist es einfach zu befolgen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt noch eine andere, viel weniger triviale Frage: die Beziehung zwischen Typen und Zeigern. </font><font style="vertical-align: inherit;">Kluge Leute haben geschrieben: Spielen Sie nicht mit solchen Dingen im Konstruktor und verstoßen Sie gegen die Prinzipien der Sprache und die Logik des Compilers. </font><font style="vertical-align: inherit;">Aber ich habe nicht gehorcht und es trotzdem getan. </font><font style="vertical-align: inherit;">Jetzt kommt natürliche Vergeltung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also 4 Klassen:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich oben geschrieben habe, sind ihr spezifischer Inhalt und ihre Arbeitslogik völlig unwichtig. </font><font style="vertical-align: inherit;">Das einzig Wichtige ist, dass im Titel der Klassendefinition. </font><font style="vertical-align: inherit;">Basierend auf diesen Klassen erstellen wir 4 Objekte:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erweitern die Definitionen ihrer Typen, die hinter leeren Klammern versteckt sind, mit den Standardargumenten. Typ w1 ist WindowClassDerivedAlternative1. Der Typ w2 ist WindowClassDerivedAlternative2 und seine Basisklasse ist WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. Der Typ w3 ist WindowClassDerivedAlternative3, seine Basisklasse ist WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt; und seine Basisklasse ist WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. Ähnliches gilt für das vierte Objekt. Schauen Sie sich das folgende Diagramm an:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem Sie jede neue abgeleitete Klasse auf der Grundlage einer bestimmten Basisklasse erstellen, die auf diese Weise definiert ist, definieren Sie nicht nur eine neue Klasse, sondern gleichzeitig die gesamte Kette ihrer Basisklassen erneut. Es wird parallel zur Kette seiner eigenen Basisklasse sein. Ihre Klasse wird ihre eigenen Basisklassen haben, und keine von ihnen kann zu einer der ursprünglichen Basisklassen führen, obwohl der Generierungscode für alle diese Klassen der gleiche ist! Es scheint echte Fantasie, aber es ist wirklich! Dies bedeutet, dass alle üblichen Methoden zum Manipulieren geerbter Klassen und Zeiger nicht funktionieren! In dieser speziellen Architektur speichert nur die Basis-WindowClassBase die Situation, andernfalls wäre es auch unmöglich, ein Array aus den Basisklassen zu erstellen (z. B. basierend auf der WindowClassTemplate).weil alle diese Klassen unterschiedliche Typen haben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So ist die bekannte und verständliche Definition der Form:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... wird die Kompilierung beenden, da Sie versuchen, einen Typzeiger zu erstellen, der nicht mit dem Typ des w2-Objekts kompatibel ist, obwohl Sie vor einer halben Stunde selbst eine Klasse geschrieben haben, die von der WindowClassDerivedAlternative1 &lt;&gt; -Klasse abgeleitet ist und auf der das w2-Objekt erstellt wurde.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Gewohnheitsgesetze aufhören zu wirken, kann dies einen Schock verursachen. </font><font style="vertical-align: inherit;">Und bei alledem gibt es tatsächlich keine schmutzigen Compiler-Hacks, erzwungenen Typkonvertierungen und andere wirklich schlechte Dinge. </font><font style="vertical-align: inherit;">Alles ist äußerst sauber und legal: Vorlagen, Standardparameter und Tools für die Typbibliothek. </font><font style="vertical-align: inherit;">Nur bekannte Methoden zum Schreiben von Code funktionieren nicht mehr. </font><font style="vertical-align: inherit;">Dies in einem realen Projekt zu verwenden bedeutet, dort eine Gefahrenzone zu deklarieren, die nur von qualifiziertem Fachpersonal mit geeigneten Schutzmaßnahmen betreten werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code-Experimente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um es allen zu erleichtern, die experimentieren möchten, und Zeit beim Tippen zu sparen, habe ich auf GitHub alle Projekte veröffentlicht, die als Grundlage für diesen Artikel dienten: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wählen Sie einfach ein Projekt als Startprojekt aus, da Sie sonst in einem Meer bunter Fenster ertrinken.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
„Wenn das alles so ein Witz ist, dann sieht es angesichts der Anstrengungen zu ernst und natürlich aus. </font><font style="vertical-align: inherit;">Und wenn es kein Scherz ist, dann wird kein normaler Entwickler, der bei klarem Verstand ist, so etwas wirklich verwenden. </font><font style="vertical-align: inherit;">Und überhaupt, Alter, würdest du nicht am Ende Unsinn leiden und nicht etwas tun </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Geld bringt, es ist</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nützlich. " </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben Recht, wenn Sie so denken. </font><font style="vertical-align: inherit;">In diesem Artikel habe ich nur gezeigt, dass C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Frage der praktischen Anwendung dieser Strukturen bleibt offen. Im Allgemeinen gilt dies eher für generalisierte und Metaprogrammierung. Möglicherweise müssen Sie überhaupt keine Objekte dieser Klassen erstellen, aber die Klassen selbst werden möglicherweise aus irgendeinem Grund benötigt. Ja, und Sie wissen nie, welche nützlichen Lösungen Sie auf dieser Basis finden können ... Das ursprüngliche CRTP wird verwendet! Und es wird nicht einmal irgendwo verwendet, sondern direkt in der Standardbibliothek! Wer nicht glaubt oder sich nicht erinnert, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zurück zur ursprünglichen Aufgabe mit Fenstern ... Besonders jetzt, nüchtern </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ohne Gras im</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rückblick auf all diese drei Jahre später ... Auch wenn wir die Tatsache verwerfen, dass ich ein banales Thema angesprochen habe, das bereits millionenfach bereist wurde, und das für niemanden seit langem von Interesse war, denn im </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ernst Jungen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normale Leute haben </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt, ich würde nur sicherstellen, dass ein funktionales Objekt an die Fensterklasse übergeben wird. </font><font style="vertical-align: inherit;">Es ist nicht schwierig, die Übertragung durch die Vererbungskette sicherzustellen, aber es wird alles einfach, klar und ohne Verzerrung erledigt, und Sie erhalten eine völlig normale vorhersehbare Klasse ohne Nebenwirkungen, die Sie begleiten und für absolut jeden entwickeln können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was in diesem Artikel passiert ist, ist nur eine interessante, nicht triviale Aufgabe, die ich immer noch lösen konnte. </font><font style="vertical-align: inherit;">Ich hoffe das war auch für dich interessant.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507114/index.html">Ode Excel: 34 Jahre Magie</a></li>
<li><a href="../de507116/index.html">"Udalenka". Notizen vom gestrigen Büroentwickler. Teil 2</a></li>
<li><a href="../de507124/index.html">PDB ist nicht nur wertvolles Fell</a></li>
<li><a href="../de507132/index.html">Vladimir Kitov: „Es ist unmöglich zu verstehen, wie wegweisende Wissenschaftler in den 1950er Jahren die universelle Computerisierung vorausgesehen haben!“</a></li>
<li><a href="../de507138/index.html">Geologie des 21. Jahrhunderts als Geodatenwissenschaft</a></li>
<li><a href="../de507148/index.html">Senden Sie magische Links mit Node.js.</a></li>
<li><a href="../de507150/index.html">Wir zeichnen ein Interferenzbild in JavaScript</a></li>
<li><a href="../en486014/index.html">SLAC Tour: US Department of Energy National Accelerator Laboratory at Stanford</a></li>
<li><a href="../en486018/index.html">Session Survey Results</a></li>
<li><a href="../en486024/index.html">Really simple graphics in R for science and journalism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>