<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêøÔ∏è ‚úçüèº ‚ôäÔ∏è Mehrfarbige Fenster: virtueller Konstruktor, CRTP und komplizierte Vorlagen üïØÔ∏è üë®üèæ‚Äçü§ù‚Äçüë®üèº üöû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit geraumer Zeit ist ein nicht triviales Entwurfsmuster bekannt, wenn eine abgeleitete Klasse im Basisparameter √ºbergeben wird:
 

template<class T>...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mehrfarbige Fenster: virtueller Konstruktor, CRTP und komplizierte Vorlagen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seit geraumer Zeit ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht triviales Entwurfsmuster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekannt, </font><font style="vertical-align: inherit;">wenn eine abgeleitete Klasse im Basisparameter √ºbergeben wird:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Vorlage hat ihren eigenen Namen - CRTP: Curiously Recurring Template Pattern, was √ºbersetzt "seltsam wiederholtes Muster" bedeutet. Ich habe dieser ohnehin schon seltsamen Konstruktion noch mehr Kuriosit√§ten hinzugef√ºgt: Ich habe sie auf eine ganze Kette von Erbschaften verallgemeinert. Ja, es kann wirklich getan werden, aber daf√ºr muss man </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Seele geben</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um einen hohen Preis zu zahlen. Um herauszufinden, wie ich es gemacht habe und welchen Preis ich zahlen muss, lade ich Sie ein, diesen Artikel f√ºr weitere Details zu lesen.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier werden wir </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit schrecklichen Perversionen durch</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verschiedene seltsame Methoden und andere schlechte Dinge </font><font style="vertical-align: inherit;">umgehen </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte Sie sofort warnen: Nehmen Sie das hier beschriebene Material nicht als etwas Ernstes. Ich bin sicher, dass in 95-99% der F√§lle all dies f√ºr Sie in der Praxis niemals n√ºtzlich sein wird. Dies ist eine Art unterhaltsame Mathematik, ein Training f√ºr den Geist. In der Praxis ist es unwahrscheinlich, dass es n√ºtzlich ist, aber es ist interessant, Zeit daf√ºr aufzuwenden. Nur in diesem Fall fungieren die C ++ - Sprache und ihre Funktionen als Mathematik. Ich warne Sie im Voraus, weil Wenn Sie hier etwas Ernstes und Praktisches suchen, werden Sie m√∂glicherweise entt√§uscht sein.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich sofort auf das Exotische ein, als ob Sie sich pl√∂tzlich in einem Land bef√§nden, in dem zwei Monde, drei Sonnen, Bl√§tter von Pflanzen blau oder lila sind, und tats√§chlich sind viele √ºbliche Dinge hier irgendwie ... seltsam und ungew√∂hnlich ... Wenn Sie im grauen Alltag versunken sind und vor nicht allzu langer Zeit Lesen Sie so etwas, dann kamen Sie zu der Adresse ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrfarbige Fenster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war vor langer Zeit. </font><font style="vertical-align: inherit;">Vor fast drei Jahren. </font><font style="vertical-align: inherit;">Ich </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sa√ü</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann </font><s><font style="vertical-align: inherit;">auf schwerem Gras und verstand</font></s><font style="vertical-align: inherit;"> nur die </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen-</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basis von C ++ 11/14 aus dem Buch Meyers S. - "Effektives und modernes C ++". </font><font style="vertical-align: inherit;">Es erw√§hnt auch dieses Muster. </font><font style="vertical-align: inherit;">Nachdem ich das Gef√ºhl hatte, </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Erleuchtung erreicht zu haben</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">die Grundlagen des neuen Standards beherrscht zu haben und bereit war, alte Dinge auf eine neue Art und Weise zu betrachten, begann ich, ein Buch √ºber die Windows-API zu aktualisieren: Schupak Y. - ‚ÄûWin32-API. </font><font style="vertical-align: inherit;">Effektive Anwendungsentwicklung. ‚Äú </font><font style="vertical-align: inherit;">Ganz am Anfang wird ein minimales C-Sprachprogramm zum Erstellen und Anzeigen eines Fensters beschrieben:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe dies bereits viele Male getan und verschiedene Fenster auf dem Modell dieses Buches angezeigt. </font><font style="vertical-align: inherit;">Und pl√∂tzlich dachte ich: Ich habe erst gestern √ºber C ++ gelesen! </font><font style="vertical-align: inherit;">Ich kann meine eigene Klasse schreiben, um dieses Fenster anzuzeigen! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gesagt, getan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur der Klasse ist trivial: Es werden mehrere Konstruktoren deklariert (mit der √úbertragung sowohl der Hauptparameter als auch der Links zur detaillierteren WNDCLASSEX-Struktur), der CreateWnd-Funktion der Fensterklassenregistrierung und der Fenstererstellung selbst, die von den Konstruktoren aufgerufen wird, sowie einer Reihe virtueller Elementfunktionen, die Aktionen ausf√ºhren Verarbeiten jeder Windows-Nachricht innerhalb der Fenster-R√ºckrufprozedur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mitglieder der Klassendaten sind ebenfalls minimal: Fensterhandle hWnd; WNDCLASSEX-Struktur zum Erstellen der Klasse; und die Titelleiste des Fensters.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fensterr√ºckrufprozedur wird als statisch deklariert, um zu vermeiden, dass dieser Zeiger implizit an das Klassenobjekt √ºbergeben wird, und damit die Vereinbarung √ºber den Typ (die Signatur) der Funktion der in Windows akzeptierten Fensterprozedur zu verletzen (denken Sie daran, dass wir diese Funktion nicht selbst aufrufen, sondern Windows, weil Die Parameter und der R√ºckgabetyp dieser Funktion sind genau angegeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fensterprozedur und dieser Zeiger</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus C ++ ist bekannt: Wenn eine Member-Funktion als statisch definiert ist, muss explizit ein Zeiger auf ein Klassenobjekt an dieses √ºbergeben werden. Wir k√∂nnen jedoch keinen Zeiger auf ein Klassenobjekt an eine statische Fensterprozedur √ºbergeben, da das Format dieser Funktion diese √úbertragung nicht zul√§sst. In diesem Zusammenhang tritt ein grundlegendes Problem auf: Wenn es mehrere Objekte der WindowClass-Klasse gibt, woher wei√ü dann die einzige statische Fensterprozedur, welches bestimmte Klassenobjekt die Nachricht empfangen hat? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nur einen Ausweg: Sie m√ºssen diese Verbindung auf die eine oder andere Weise herstellen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows identifiziert ein Fenster anhand seines HWND hWnd-Handles. Das diesem Fenster entsprechende Klassenobjekt kann durch einen Zeiger auf dieses Objekt identifiziert werden. Daher muss der Verbindungszeiger hWnd &lt;-&gt; zum WindowClass-Objekt hergestellt werden. Beispielsweise k√∂nnte eine Fensterprozedur, die gleichzeitig Mitglied einer Klasse ist, einen Link oder einen Zeiger auf eine ebenfalls statische Datenstruktur haben, die f√ºr jedes Fenster eine Verbindung zwischen hWnd und einem Zeiger auf ein Objekt herstellt und jedes Mal aktualisiert wird, wenn ein Objekt der Klasse erstellt wird. Die Datenstruktur muss statisch sein, damit erstens innerhalb einer statischen Fensterprozedur ohne Zeiger auf ein Klassenobjekt auf sie zugegriffen werden kann, und zweitens sollte sie f√ºr alle Objekte der Klasse eindeutig sein (was logischerweise aus ihrem Zweck folgt ) und drittensDamit ist es immer noch an eine Klasse mit der entsprechenden Zugriffsebene gebunden und keine externe globale Variable.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir nun herausgefunden haben, wie diese Struktur zu beschreiben ist und warum sie ben√∂tigt wird, m√ºssen wir erst noch herausfinden, wie diese Struktur aussehen sollte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es k√∂nnen zwei dynamische Arrays deklariert werden: eines f√ºr HWND-Fensterhandles und das zweite f√ºr Zeiger auf WindowClass-Objekte. Dies ist jedoch nicht die beste L√∂sung: Es ist nicht klar, wie die Gr√∂√üe des Arrays ausgew√§hlt werden soll, wie die Szenarien f√ºr die Verwendung von Fenstern aussehen sollen und ob die Arrays bei falscher Auswahl fast leer sind, was zu einem Speicher√ºberlauf f√ºhrt. Im Gegenteil, wenn beim Erstellen von Fenstern das Volumen ersch√∂pft ist, muss die Gr√∂√üe usw. erh√∂ht werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine bessere (und sogar ich w√ºrde sagen - ideale) L√∂sung in dieser Situation ist eine Liste ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Eine Liste ist eine dynamische Datenstruktur, die aus einer Reihe von Knoten besteht, die paarweise verbunden sind. Jeder Knoten (im Fall einer doppelt verkn√ºpften Liste) verf√ºgt √ºber Zeiger auf den vorherigen und n√§chsten Knoten der Liste sowie √ºber zus√§tzliche gespeicherte Daten. In unserer Situation entspricht jeder Fensterknoten jedem der Fenster, und die n√ºtzlichen Daten sind ein Fensterhandle und ein Zeiger auf ein Objekt der WindowClass-Klasse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Mal, wenn ein neues Fenster erstellt wird, wird ein neuer Listenknoten erstellt und an dessen Ende hinzugef√ºgt (wird der letzte). Beim Schlie√üen wird der Knoten gel√∂scht und die Zeiger des vorherigen und n√§chsten Knotens werden aufeinander abgestimmt, um den Remote-Knoten zu ersetzen. Gleichzeitig gibt es keine Speicher√ºberschreitung - genau so viele Knoten werden erstellt wie Fenster erstellt, und sie werden auch gel√∂scht, wenn das Fenster geschlossen wird.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher sollte der WindowClass-Klasse auch ein neues statisches Element hinzugef√ºgt werden:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und deklarieren Sie es als privilegiert, damit es auf WindowClass-Mitglieder zugreifen kann:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ich werde hier jetzt keine Definition der Listenklasse und der Knotenklasse, ihrer Funktionen, geben, da dies nicht direkt f√ºr die WindowClass-Klasse gilt und die Implementierungslogik dieser Klasse bekannt und ziemlich trivial ist.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist die Fensterprozedur, wenn eine neue Nachricht f√ºr den Fall eintrifft geh√∂rt zu der Nummer, die es verarbeitet, gem√§√ü dem von Windows an Windows √ºbergebenen Fensterdeskriptor hWnd, greift auf die Liste zu, sucht nach einem Knoten darin gem√§√ü dem angegebenen hWnd und erh√§lt beim Auffinden den erforderlichen Zeiger auf ein Objekt der WindowClass-Klasse. Anschlie√üend ruft er per Zeiger eine virtuelle Funktion auf, die der zu verarbeitenden Nachricht entspricht: F√ºr eine √ºberschriebene Klasse kann eine virtuelle Funktion mit demselben Namen andere Aktionen ausf√ºhren.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es einen subtilen Punkt. Es betrifft die Initialisierung der Klasse und die Verarbeitung der WM_CREATE-Nachricht. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines Fensters mit der CreateWindow-Funktion ist zum Zeitpunkt des Aufrufs das hWnd-Fensterhandle noch nicht bekannt: Das Fenster wurde noch nicht erstellt! Um virtuelles OnCreate aufrufen zu k√∂nnen, m√ºssen Sie daher den Zeiger auf das Klassenobjekt kennen. Dies geschieht durch ziemlich riskantes √úbergeben des Zeigers this von der WindowClass :: CreateWnd-Funktion an die CreateWindow-Funktion √ºber den lParam-Zeiger. Bei der Verarbeitung von WM_CREATE empf√§ngt die Fensterprozedur diesen Zeiger vom Parameter, initialisiert mit ihrer Hilfe das hWnd-Element im Objekt und erstellt dann mit dem Zeiger auf das Klassenobjekt einen neuen Listenknoten f√ºr dieses Fenster. Anschlie√üend wird das virtuelle OnCreate per Zeiger aufgerufen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die verbleibenden Nachrichten wird die oben beschriebene Logik ausgef√ºhrt: Suchen Sie nach dem Listenknoten mit dem aktuellen Fensterhandle hWnd, das von Windows √ºbertragen wurde, und rufen Sie dann die gew√ºnschte virtuelle Funktion mit dem Zeiger auf das Klassenobjekt vom Listenknoten auf. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich das Programm zusammengestellt und sichergestellt hatte, dass alles richtig </font><font style="vertical-align: inherit;">funktioniert, begann ich weiter zu lesen </font><font style="vertical-align: inherit;">, wobei ich mir die H√§nde </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber das Gef√ºhl meiner eigenen Gr√∂√üe</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der geleisteten Arbeit rieb. </font><font style="vertical-align: inherit;">Und dort auf der n√§chsten Seite wird die Funktion zum √Ñndern der Fenstereigenschaften angezeigt:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich entschied mich sofort vor Ort, ein neues Fenster basierend auf dem alten zu erstellen:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die abgeleitete Klasse unterscheidet sich von der Basisklasse durch Hinzuf√ºgen eines statischen Fensterz√§hlers sowie durch √Ñndern von OnCreate, OnPaint und OnDestroy: Die OnCreate-Funktion √§ndert die Hintergrundfarbe des Fensters, OnPaint zeigt eine andere Meldung an und OnDestroy verringert den statischen Fensterz√§hler. </font><font style="vertical-align: inherit;">Alles ist sehr einfach und klar. </font><font style="vertical-align: inherit;">Zusammengebaut und gestartet. </font><font style="vertical-align: inherit;">Der Nachrichtentext ist anders geworden, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aber die Farbe des Fensters hat sich nicht ge√§ndert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtueller Konstruktor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wurde mir klar, dass ich bereits d√ºnnes Eis betreten hatte. </font><font style="vertical-align: inherit;">Nicht alle Nuancen sind im Grundmaterial der Hauptb√ºcher beschrieben. </font><font style="vertical-align: inherit;">Einer von ihnen ist ein virtueller Konstruktor. </font><font style="vertical-align: inherit;">Ich dachte, dass das Aufrufen der virtuellen Funktion der abgeleiteten Klasse vom Konstruktor genau das gleiche ist wie √ºberall im Programm. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies nicht m√∂glich war.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem besteht darin, dass die vom Konstruktor aufgerufene virtuelle Funktion als nicht virtuell aufgerufen wird: Nur das Objekt der Basisklasse wird erstellt, und zwar erst am Ende, und das abgeleitete Objekt wurde noch nicht erstellt, und die Tabelle der virtuellen Funktionen wurde nicht generiert. In unserem Fall erhalten wir die Kette: Derivatkonstruktor -&gt; Basiskonstruktor -&gt; CreateWnd -&gt; CreateWindow -&gt; Fensterprozedur -&gt; OnCreate, dh OnCreate wird tats√§chlich vom Konstruktor aufgerufen. Das abgeleitete Objekt wurde noch nicht erstellt, daher wird OnCreate f√ºr die Basisklasse aufgerufen! Es stellt sich heraus, dass seine Neudefinition in der Ableitung keinen Sinn ergibt! Was ist zu tun?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus C ++ ist bekannt, dass jede √ºberschriebene Funktion unter ihrem vollst√§ndigen Namen aufgerufen werden kann: Klassenname :: Funktionsname. Ein Klassenname ist nicht nur ein Name: Er identifiziert sich selbst als Objekttyp. Aus C ++ ist auch bekannt, dass eine Klasse (und Funktion) als Vorlage (Vorlage) erstellt werden kann, indem der Typ (ihr) als Parameter √ºbergeben wird. Wenn Sie daher die Funktionsvorlage f√ºr Fensterprozeduren erstellen und den Typ der abgeleiteten Klasse auf irgendeine Weise √ºbergeben, k√∂nnen Sie die gew√ºnschte √ºberschriebene Funktion direkt im Konstruktor der </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisklasse</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Halt halt halt !!! Das kannst du nicht machen !!! Eine abgeleitete Klasse wurde noch nicht erstellt, ihre Daten wurden nicht initialisiert: Welche Funktionen werden Sie hier aufrufen? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie nicht k√∂nnen, aber wirklich wollen, k√∂nnen Sie.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich wollte ich die abgeleitete Klasse nicht voll ansprechen. </font><font style="vertical-align: inherit;">Ich wollte eine </font><font style="vertical-align: inherit;">WinAPI-Funktion </font><font style="vertical-align: inherit;">eines </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drittanbieters</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">, die nichts mit der Klasse zu tun hat. </font><font style="vertical-align: inherit;">"Aber das kann auf ganz andere Weise und viel einfacher gemacht werden!" </font><font style="vertical-align: inherit;">- du sagst. </font><font style="vertical-align: inherit;">Ja. </font><font style="vertical-align: inherit;">Kann. </font><font style="vertical-align: inherit;">Und ich werde am Ende des Artikels dar√ºber schreiben. </font><font style="vertical-align: inherit;">Aber in diesem Moment warf ich das alles beiseite und konzentrierte mich auf die rein technische Seite der Frage: Aber ist es dennoch m√∂glich, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktor der Basisklasse </font><b><font style="vertical-align: inherit;">im Prinzip</font></b><font style="vertical-align: inherit;"> etwas aus der Ableitung aufzurufen? </font><font style="vertical-align: inherit;">Es war ein rein sportliches Interesse, wenn Sie m√∂chten. </font><font style="vertical-align: inherit;">Ich habe in diesem Moment an keine praktische Seite gedacht. </font><font style="vertical-align: inherit;">Es war eine nicht triviale Aufgabe, und ich fragte mich, ob ich sie l√∂sen k√∂nnte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenstervorlagenklasse - Methode 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schwierigkeit besteht also darin, wie der Typ der abgeleiteten Klasse an die Fensterprozedur √ºbergeben wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wollte nicht die gesamte Basisklasse von WindowClass auf einmal zu einer Vorlagenklasse machen: F√ºr jede abgeleitete Klasse wird eine eigene Basisklasse generiert. Da WindowClass zur Vorlage wird, m√ºssen au√üerdem sowohl die Listenknoten als auch die Liste selbst als Vorlage erstellt werden: Sie verf√ºgen √ºber Zeiger auf Klassenobjekte. Um diese Zeiger verwenden zu k√∂nnen, m√ºssen sie ihren Typ kennen, dh WindowClass, und wissen, wie sie parametrisiert werden . Zum Zeitpunkt der Definition der Listenklasse und der Knotenklasse ist dies nicht bekannt. Daher muss dieser Typ auch als Parameter (von WindowClass) √ºbergeben werden. Daraus folgt, dass f√ºr jede abgeleitete Klasse eine eigene Liste erstellt wird, die </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser abgeleiteten Klasse entspricht</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(und nur er)! Und jetzt k√∂nnen Sie keine Zeiger auf die Basisklassen, die verschiedenen Ableitungen entsprechen, in ein Array setzen: Sie haben verschiedene Typen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also suchte ich nach einer M√∂glichkeit, den Typ der abgeleiteten Klasse zu √ºbergeben, ohne die gesamte Klasse zu parametrisieren. Ein Typ kann nur √ºber den Konstruktor an die Basisklasse √ºbergeben werden: Dies ist die einzige Funktion, auf die beim Erstellen des Objekts zugegriffen wird. Daher sollte es Boilerplate sein. Es stellte sich jedoch heraus, dass sie die Vorlagenparameter offensichtlich nicht angeben konnte: Es w√ºrde so aussehen, als w√ºrde sie Parameter an die Vorlagenklasse selbst und nicht an ihren Konstruktor √ºbergeben. Daher kann der Typ nur aus den an den Konstruktor √ºbergebenen Parametern abgeleitet werden. Ich wollte jedoch keinen speziellen Konstruktorparameter hinzuf√ºgen, der nur zur Typinferenz dient: die Liste der Argumente mit einem reinen Hilfsparameter √ºberladen. Und wenn der Benutzer zum Beispiel vergisst, es zu √ºbertragen, z.durch mindestens die triviale (DerivedClass *) nullptr? Dies ist noch nicht be√§ngstigend - der Compiler zeigt eine Fehlermeldung an, dass die Klasse nicht instanziiert werden kann. Schlimmer noch, wenn der Benutzer eine Klassenhierarchie erstellt und einen Zeiger auf die falsch abgeleitete Klasse √ºbergibt: Unter dem Gesichtspunkt der Kompilierung ist alles korrekt, aber wir erhalten ein falsch funktionierendes Programm mit einem unverst√§ndlichen Fehler.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, diese Konstruktionsfehlkalkulation ist eine solche L√∂sung. </font><font style="vertical-align: inherit;">Somit wird die Verantwortung f√ºr die korrekte Instanziierung nicht einmal auf den Sch√∂pfer der abgeleiteten Klasse √ºbertragen, sondern auf denjenigen, der sie verwenden wird! </font><font style="vertical-align: inherit;">Und er kann weder ein Traum noch ein Geist in Bezug auf solche Nuancen sein und versteht aufrichtig nicht, wo der Fehler liegt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich aufgegeben hatte, entschied ich mich dennoch, ohne die Konstruktorparameter zu √§ndern, WindowClass selbst und gleichzeitig die zugeh√∂rigen Listen- und Listenknotenklassen zu parametrisieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClass-Vorlagenklasse:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abgeleitete Klasse:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Fensterprozedur, die ein Vorlagenmitglied einer Vorlagenklasse ist und Zugriff auf den √ºbergebenen Typ der abgeleiteten Klasse hat, ruft OnCreate der abgeleiteten Klasse auf. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kommen also nat√ºrlich zur CRTP-Vorlage. Hier stellte sich heraus, von selbst. Erst viel sp√§ter stellte ich fest, dass es sich bei diesem Design um eine bekannte Vorlage mit dem entsprechenden Namen handelt. Aber dann wusste ich das nicht und es schien mir, dass ich es zum ersten Mal erhielt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir wurde sofort klar, dass dies nur die halbe L√∂sung ist. </font><font style="vertical-align: inherit;">Ich kann leicht eine andere Klasse basierend auf dieser Ableitung erstellen wollen. </font><font style="vertical-align: inherit;">Und das war's: Es ist kein Boilerplate und akzeptiert keine Parameter mehr. </font><font style="vertical-align: inherit;">Also kam mir die Idee, die zweite abgeleitete Klasse durch die erste Ableitung an die Basisklasse zu √ºbergeben. </font><font style="vertical-align: inherit;">(Das d√ºnne Eis unter meinen F√º√üen begann zu knacken ... Ich ging bereits dorthin, wo es keine R√ºckkehr gab.) Aber wenn ich es einmal mache, kann ich es so oft machen, wie ich m√∂chte: Selbst wenn ich zehn abgeleitete Klassen habe, kann ich die zehnte in Folge nehmen ( die letzte), um entlang der Kette zur Basis zu gelangen, und sie nennt dort die Funktion dieser letzten Ableitung, die ich brauche (und im Allgemeinen - jede Zwischenableitung, falls gew√ºnscht). </font><font style="vertical-align: inherit;">Die Aufgabe war klar. </font><font style="vertical-align: inherit;">Alles was √ºbrig blieb war es zu tun.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parametrisierte Fensterklasse - Methode 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim zweiten Lauf habe ich mir drei Aufgaben gestellt:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Anforderungen zu erf√ºllen, m√ºssen Sie nat√ºrlich noch eine Vorlage f√ºr den Designer erstellen und einen speziellen Parameter hinzuf√ºgen. Dies bedeutet jedoch einen Versto√ü gegen eine andere Anforderung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist hier die L√∂sung? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die urspr√ºngliche Basisklasse WindowClass in zwei Komponenten unterteilen: die WindowClass selbst (nennen wir sie jetzt WindowClassBase), die eine einzige unersch√ºtterliche Grundlage darstellt und die abgeleitete Klasse erg√§nzt (die immer noch den gleichen urspr√ºnglichen Namen WindowClass haben kann). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die komplement√§re Klasse ist f√ºr die Implementierung von OnCreate verantwortlich und kann au√üerdem als Ganzes parametrisiert werden. Und er in seinem Konstruktor √ºbergibt den an ihn √ºbergebenen Typ √ºber einen speziellen Parameter an den Konstruktor der WindowClassBase-Klasse.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Fall m√ºssen Sie in WindowClassBase relativ zur Quelle jetzt einige √Ñnderungen vornehmen. Zus√§tzlich zum tats√§chlichen Entfernen von OnCreate m√ºssen Sie der Klasse, die es erg√§nzt (und in Zukunft Ableitungen davon), ein Zeigerelement sowie eine Aufruffunktion hinzuf√ºgen, die OnCreate √ºber diesen Zeiger aufruft: Wir k√∂nnen den Zeiger nicht auf den Basiszeiger aufrufen. Da OnCreate nicht mehr darin enthalten ist und OnCreate der Klassen, die komplement√§r sind und daraus abgeleitet werden, ist es besser, es mit dem richtigen Zeiger auf die gew√ºnschte Klasse aufzurufen, als mit diesem Zeiger der Basis etwas zu versuchen. Letztendlich wird der spezielle Parameter des WindowClassBase-Konstruktors nicht nur f√ºr die Typinferenz ben√∂tigt, sondern auch zum Speichern und anschlie√üenden Aufrufen der erforderlichen Klasse √ºber OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider musste der Typ dieses Zeigers ung√ºltig gemacht werden:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klasse ist keine Vorlage, und Sie k√∂nnen den Compiler nicht anweisen, einen Zeiger mit einem unbekannten Typ zu erstellen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Ableitungen werden von der Basisklasse geerbt. Sie haben alle unterschiedliche Typen. Welchen Zeigertyp sollte ich verwenden?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende habe ich es nur im C-Stil deklariert: Verwenden Sie in jeder seltsamen Situation einen Zeiger, um ung√ºltig zu werden. </font><font style="vertical-align: inherit;">Der Zeiger wird physisch als typenlos gespeichert, aber zum Zeitpunkt des Aufrufs wird OnCreate in den Typ der aufgerufenen Klasse umgewandelt. </font><font style="vertical-align: inherit;">Dies erfolgt in einer speziellen Vorlagenaufruffunktion, die zu WindowClassBase geh√∂rt und deren Parametertyp zum Zeitpunkt des Aufrufs bekannt ist:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Anfangs wurde std :: true_type oder std :: false_type als zweiter Parameter verwendet, um die gew√ºnschte Option zum √úberschreiben der Funktion auszuw√§hlen. Mit der SFINAE-Methode wurde in der Kompilierungsphase festgestellt, ob die WndCls-Klasse √ºber eine OnCreate-Memberfunktion verf√ºgt. Wenn dies der Fall ist, wird die obige Version der Funktion aufgerufen. Ist dies nicht der Fall, wurde der Aufruf von OnCreate in folgender Form durchgef√ºhrt:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sp√§ter stellte sich heraus, dass SFINAE nicht erforderlich war: Eine Klasse, die WindowClassBase erg√§nzt, verf√ºgt in jedem Fall √ºber eine OnCreate-Memberfunktion. Selbst wenn in der √ºbergebenen WndCls-Parameterklasse OnCreate nicht definiert ist, befindet sie sich in einer der Basisklassen und √úberpr√ºfung wird in allen F√§llen wahr geben. Wenn durch ein Wunder die erg√§nzende Klasse so ge√§ndert wird, dass OnCreate daraus entfernt wird, und in allen davon abgeleiteten Klassen auch nicht, dann macht es keinen Sinn, sie gem√§√ü der zweiten Option aufzurufen: Ein solcher Code wird einfach nicht kompiliert. Daher wird am Ende hier die obige Option angegeben.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Logik zum Akzeptieren und Verwenden des Basisklassentyps in WindowClassBase ist recht einfach: Der Typ wird vom Zeiger auf das Objekt der abgeleiteten Klasse abgeleitet, die an den WindowClassBase-Konstruktor √ºbergeben wird, dieser Zeiger wird in diesem Konstruktor gespeichert und der Zeiger auf die Vorlagenfensterprozedur wird durch den √ºbergebenen Typ instanziiert, und auf die obige LaunchOnCreate wird zugegriffen . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher sieht die WindowClassBase-Klasse jetzt folgenderma√üen aus:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Code f√ºr den k√ºrzesten Konstruktor:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb der Fensterprozedur lautet der Aufruf von LaunchOnCreate wie folgt:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er beschloss, die Fensterprozedur selbst aus der Klasse au√üerhalb zu entfernen und sie in der WindowClassBase-Klasse f√ºr privilegiert zu erkl√§ren. Vielleicht ergab das nicht viel Sinn: Welchen Unterschied macht es, wo seine Instanziierungen erzeugt werden - au√üerhalb oder innerhalb der Klasse? Das Codesegment ist eins! Obwohl ich zugeben muss, dass Sie es unter dem Gesichtspunkt der gleichen Kapselung vielleicht immer noch statisch in der Klasse lassen sollten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt die komplement√§re Klasse zu definieren:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Klasse verf√ºgt √ºber einen Konstruktor, der vor dem Teilen genauso aussieht wie die urspr√ºngliche WindowClass, dh ohne einen speziellen Parameter. Dieser spezielle Parameter wird intern generiert, wenn auf den WindowClassBase-Konstruktor zugegriffen wird, indem der Zeiger √ºbergeben wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese WindowClass in dieser Form entspricht fast der urspr√ºnglichen WindowClass. </font><font style="vertical-align: inherit;">Daher wird die Vererbung mit OnCreate-√úberschreibungen nicht unterst√ºtzt. </font><font style="vertical-align: inherit;">Dies ist jedoch der Ausgangspunkt f√ºr die Unterst√ºtzung der Vererbung (wie unten gezeigt wird). </font><font style="vertical-align: inherit;">In dieser Form:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basisklasse WindowClassBase ist an sich nicht generisch, was bedeutet, dass sie die einzige f√ºr alle abgeleiteten Klassen ist, unabh√§ngig davon, um welche es sich handelt. </font><font style="vertical-align: inherit;">Die Liste, die sicherstellt, dass alle anderen Windows-Nachrichten korrekt verarbeitet werden, ist ebenfalls die einzige.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der WindowClass-Konstruktor verf√ºgt √ºber keinen speziellen Parameter.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen, sind zwei der drei Anforderungen erf√ºllt. </font><font style="vertical-align: inherit;">Es bleibt mit letzterem zu tun: mit der Vererbung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeleitete Verkettung von Klassentypen in WindowClassBase, Steuerelementtyp</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst werden wir eine einmalige Vererbung in Betracht ziehen, wenn die Initialisierungslogik von WindowClass nicht zu uns passt und wir sie √§ndern m√∂chten, indem wir (zumindest vorerst) eine abgeleitete Klasse erstellen. </font><font style="vertical-align: inherit;">Was muss in WindowClass ge√§ndert werden, um dies sicherzustellen? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine neue Variante der Komplement√§rklasse wird Boilerplate. </font><font style="vertical-align: inherit;">Dies ist nicht be√§ngstigend, da es tats√§chlich keine Daten enth√§lt, sondern nur die OnCreate-Funktion und die Konstruktoren:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse nimmt einen Parameter vom Typ DerWndCls und √ºbergibt ihn beim Konvertieren dieses Zeigers an WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie auf static_cast. Dies ist wichtig, da meine Konvertierung urspr√ºnglich wie folgt im C-Stil geschrieben wurde:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich es √ºberall in static_cast √ºbersetzt hatte, wurde die H√§lfte des Codes (siehe unten) nicht kompiliert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist auch ein subtiler Punkt: Die Konvertierung wird in der Kompilierungsphase durchgef√ºhrt, aber diese Klasse selbst verf√ºgt √ºber die OnCreate-Funktion, und nach der Konvertierung kann DerWndCls verwendet werden, um OnCreate der DerWndCls-Klasse aufzurufen. </font><font style="vertical-align: inherit;">Dies ist der Unterschied zu dem oben in WindowClassBase beschriebenen Konvertierungsfall. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise k√∂nnen Sie eine bestimmte Klasse WindowClassDerived erstellen, OnCreate darin √ºberschreiben und mit der oben beschriebenen WindowClassTemplate instanziieren, wobei Sie erneut dieselbe seltsame, sich wiederholende Vorlage implementieren, die am Anfang des Artikels angegeben ist:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und OnCreate von diesem WindowClassDerived wird nach Bedarf in der WindowClassBase aufgerufen!</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist jedoch eine einmalige Vererbung. </font><font style="vertical-align: inherit;">Bei Mehrfachvererbung sollten Sie anstelle von WindowClassDerived eine neue Vorlage deklarieren, wobei die Klasse m√∂glicherweise eine h√∂here Ebene in der Hierarchie einnimmt und an WindowClassTemplate √ºbergeben wird. </font><font style="vertical-align: inherit;">Ich m√∂chte speziell zwei wichtige Punkte hervorheben:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potenziell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Host-Klasse in der Hierarchie. </font><font style="vertical-align: inherit;">Dies bedeutet, dass es m√∂glicherweise keine Klasse akzeptiert, dh selbst die oberste Klasse der Hierarchie ist, sodass daraus ein Objekt erstellt werden kann.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbertragungsparameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WindowClassTemplate. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das akzeptierte Vorlagenargument von Klasse zu Klasse √ºber die gesamte Vererbungskette bis ganz nach unten in WindowClassTemplate und von dort an WindowClassBase √ºbergeben werden muss.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, einerseits muss die Klasse eine Vorlage sein und eine bestimmte Klasse als Parameter verwenden. Andererseits muss es die Situation √ºberwachen, dass es sich selbst um eine endliche Klasse (zum Zeitpunkt der Instanziierung) handelt, und die Basisklasse selbst und nicht nach dem √ºbergebenen Typ instanziieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei alledem m√∂chte ich, dass dies automatisch vom Compiler durchgef√ºhrt wird: Das Definieren einer neuen Klasse basierend auf einer bereits erstellten Klasse erfordert keine Modifikation der letzteren - dann geht das gesamte Wesen des Vererbungspolymorphismus verloren. Das hei√üt: Ich erstelle eine Klasse, die derzeit ganz oben in der Hierarchie steht, aber dann wird </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√∂glicherweise</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine neue Klasse basierend darauf erstellt, die die aktuelle ersetzt, ohne ihre Definition zu √§ndern. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie implementiere ich diese Funktionalit√§t?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem der Automatisierung und intelligenten Entscheidungsfindung zu l√∂sen, bietet sich das Standardargument f√ºr die Vorlage an: Wenn die aktuell erstellte Klasse die oberste ist und der Vorlagenparameter nicht an sie √ºbergeben wird, m√ºssen wir diesen Parameter ihr zuweisen. Dies wird mit dem Standardargument erreicht. Dann stellen sich folgende Fragen: Wie w√§hlt man es aus und wie bezieht man es auf die Situation des explizit √ºbergebenen Parameters und √ºbertr√§gt sich selbst, wenn der Parameter nicht √ºbergeben wird? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider k√∂nnen Sie keine eigene definierte Klasse als Standardparameter schreiben. Der Compiler wird den Code des Formulars einfach nicht verpassen:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er berichtet, dass eine rekursive Typabh√§ngigkeit zu komplex ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen wir auf die andere Seite. </font><font style="vertical-align: inherit;">Lassen Sie uns eine fiktive Klasse vorstellen, die nichts funktional tut und nichts speichert, die Rolle von nur Dummy-Plugs spielt und dem Compiler signalisiert, dass im Falle seines Auftretens nichts ‚Äûvon oben‚Äú √ºbertragen wird:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und im Standardargument ersetzen Sie uns durch diesen Knebel:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Option wird diese Klasse in der Situation mit dem Standardargument an WindowClassTemplate √ºbergeben. </font><font style="vertical-align: inherit;">Die thisclass-Klasse verf√ºgt nicht √ºber eine OnCreate-Memberfunktion, daher wird diese Option einfach nicht kompiliert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir dann, einen zweiten Hilfssteuerungsparameter einzuf√ºhren, auf dessen Grundlage wir entscheiden, welcher Typ weitergegeben werden soll. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie nat√ºrlich die WindowClassTemplate wie folgt √§ndern:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird nicht ein Typ √ºbertragen, sondern zwei. Basierend auf der Kombination dieser beiden Typen wird der endg√ºltige Typ mit den Tools &lt;type_traits&gt; bestimmt: std :: conditional_t ‚Äã‚Äãund std :: is_same. Dieser Typ wird an WindowClassBase √ºbergeben. Die Auswahllogik wird in den Kommentaren beschrieben: Wenn diese Klasse an ControlType √ºbergeben wird, w√§hlen wir DerWndCls aus, andernfalls wird ControlType selbst ausgew√§hlt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen wir nun eine Vorlage, die sie beim Erben verwendet:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Parameter wird standardm√§√üig √ºber diese Klasse initialisiert, und ControlType wird basierend auf DerWndCls selbst berechnet: Wenn DerWndCls = thisclass, dann ControlType: = thisclass, andernfalls ControlType: = DerWndCls (speziell angegebene Pascal-Zuweisung zur Unterscheidung vom Vergleich). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes wird die von DerWndCls parametrisierte WndClsDerivedTemplateClass-Klasse selbst zusammen mit dem berechneten Steuerelementtyp (in der Kompilierungsphase) √ºbergeben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein Objekt dieser Klasse erstellen, dh WndClsDerivedTemplateClass selbst steht an der Spitze der Hierarchie, dann wird DerWndCls = ControlType = thisclass und dann &lt;WndClsDerivedTemplateClass, thisclass&gt; √ºbergeben. Die Tatsache, dass WndClsDerivedTemplateClass von einem Dummy parametrisiert wird, spielt keine Rolle - dieser Typ und tats√§chlich alle an Ort und Stelle √ºbergebenen DerWndCls werden in der Klasse in keiner Weise verwendet: Es wird kein Objekt daraus erstellt und keine Funktion wird durch sie aufgerufen. Daher kann WndClsDerivedTemplateClass formal buchst√§blich mit allem instanziiert werden - der Parametertyp dient nur dazu, weiter entlang der Vererbungslinie zu gehen. Anstelle von DerWndCls wurde jedoch WndClsDerivedTemplateClass &lt;diese Klasse oder ein anderer Typ&gt; weitergegeben: WndClsDerivedTemplateClass verf√ºgt √ºber eine OnCreate-Funktion.Dies wird in WindowClassBase aufgerufen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Option wird diese Klasse anstelle des ControlType in die WindowClassControlBaseTemplate aufgenommen, und der endg√ºltige Typ wird als DerWndCls = WndClsDerivedTemplateClass angezeigt, f√ºr den die erforderliche OnCreate-Funktion erforderlich ist. Welches ist was wir brauchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun die Option, wenn eine neue Klasse basierend auf WindowClassControlBaseTemplate erstellt wird (weitere Vererbung):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ersetzt in WndClsDerivedTemplateClass etwas anderes als diese Klasse DerWndCls, und ControlType √ºbernimmt angesichts dieses Unterschieds den an DerWndCls √ºbergebenen Wert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der WindowClassControlBaseTemplate lautet die folgende Parametrierungsoption: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In WindowClassControlBaseTemplate verwendet ControlType! = Thisclass wiederum den ControlType selbst, der WindowClassDerivedTemplateNext entspricht. Dies ist die richtige Klasse f√ºr die Auswahl von OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick scheint bei einem solchen Schema alles gut zu sein. Aber das ist nicht so. Wir bauen eine weitere Klasse auf der Grundlage der letzteren:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In WindowClassDerivedTemplateNext ersetzt WindowClassDerivedTemplateNext2 DerWndCls. ControlType wird auch als WindowClassDerivedTemplateNext2 ausgegeben. Anschlie√üend wird WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass √ºbergeben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und </font><b><font style="vertical-align: inherit;">ControlType</font></b><font style="vertical-align: inherit;"> zeigt denselben WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt; an. Als n√§chstes werden die gleichen Werte an WindowClassControlBaseTemplate √ºbergeben, und dort wird anstelle der korrekten WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNext2erDerminalDiveTer WindowText</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erinnere Sie daran, dass bei diesem Schema des Erbens und √úbergebens von Parametern der Typ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><b><font style="vertical-align: inherit;">selbst</font></b><font style="vertical-align: inherit;"> , der als Ergebnis zu WindowClassControlBaseTemplate kam, wichtig ist und nicht das, womit sie parametrisiert wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher m√ºssen Sie die Definition der WindowClassDerivedTemplateNext-Klasse √§ndern, damit der Typ, f√ºr den OnCreate aufgerufen wird, korrekt angezeigt wird:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall wird dann in WndClsDerivedTemplateClass der richtige Wert, der WindowClassDerivedTemplateNext2 entspricht, an den ControlType √ºbergeben, anstatt dort im falschen Wert angezeigt zu werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher sollte die letzte Klasse, die wir erstellen, ControlType nicht √ºbergeben, damit die n√§chstgelegene Basisklasse sie unabh√§ngig ausgeben kann. Diese Basisklasse und alle zugrunde liegenden Klassen m√ºssen ControlType explizit √ºbergeben, um die automatische Ausgabe auf den falschen Wert zu verhindern. Dieser Ansatz impliziert eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñnderung der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definition der n√§chsten Basisklasse, die nur m√∂glich ist, wenn der Quellcode verf√ºgbar ist oder wir ihn zuvor selbst erstellt haben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir dies vergessen und gegen diese Regel versto√üen haben, wird bei Verwendung von static_cast ein Kompilierungsfehler angezeigt. Wenn wir Zeiger im C-Stil in WindowClassControlBaseTemplate konvertieren, erhalten wir ein </font><font style="vertical-align: inherit;">Programm, </font><font style="vertical-align: inherit;">das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht ordnungsgem√§√ü</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert. Zum Beispiel, wenn wir versuchen, ein Objekt f√ºr eine Klasse zu erstellen</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann gibt der Compiler einen Fehler aus: Er kann die Zeigertypen in der WindowClassControlBaseTemplate nicht konvertieren, da der Typ falsch war und nicht konvertiert werden kann (da wir ein Objekt der WindowClassDerivedTemplateNext-Klasse erstellen, gehen wir davon aus, dass sich die WindowClassDerivedTemplateNext-Klasse selbst oben befindet Hierarchie, und in diesem Fall sollte ControlType, wie oben gezeigt, nicht √ºbergeben werden. Ohne static_cast wird der Code kompiliert und ruft einfach OnCreate der falschen Klasse auf. Durch Entfernen der ControlType-√úbertragung wird das Programm jedoch erneut kompiliert.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich ist dies alles zu kompliziert, unzuverl√§ssig und erfordert die Verf√ºgbarkeit von Quellcodes aller Klassen. </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen wir nur Objekte der zuletzt abgeleiteten Klasse erstellen, und eine ihrer Basisklassen kann aufgrund der ControlType-√úbertragung nicht erstellt werden (oder wenn der Zeiger im C-Stil √ºbergeben wird, diese Objekte jedoch falsch initialisiert werden). </font><font style="vertical-align: inherit;">Wir brauchen eine andere L√∂sung, einfacher und zuverl√§ssiger.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Vorlage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obige Variante der Vorlagenvererbung und die √úbergabe des Typs des erstellten Objekts an die WindowClassBase-Klasse, in der das Fenster erstellt und OnCreate aufgerufen wird, weist jedoch schwerwiegende Nachteile auf. Wir brauchen eine andere, zuverl√§ssigere und effizientere Option. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C ++ 11 wird ein neuer Vorlagentyp eingef√ºhrt: eine Vorlage mit einer variablen Anzahl von Argumenten oder eine variable Vorlage. Seine Parameter sind eine Folge von Typen bisher unbekannter L√§nge. Anstelle riskanter Manipulationen mit dem Steuerelementtyp im vorherigen Beispiel habe ich mich f√ºr den anderen Weg entschieden: Um Situationen zu vermeiden, in denen die Zwischenklasse in der Hierarchie die √ºbergeordnete Klasse in der Hierarchie durch falsche Parametrisierung ersetzt (im obigen Beispiel war es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;) k√∂nnen Sie diese Art der Parametrisierung im Allgemeinen entfernen, indem Sie diese Klassen einfach nebeneinander platzieren. Beispielsweise wird mit drei aufeinanderfolgenden Vererbungen in den Vorlagenparametern schlie√ülich die folgende Liste gebildet: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Liste genauer verarbeiten, eines ihrer letzten Elemente (abh√§ngig davon, wie Sie sie zusammengestellt haben) Sie k√∂nnen die gew√ºnschte Klasse in der Hierarchie extrahieren und damit arbeiten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall sollten Sie anstelle der zuvor beschriebenen Vorlagen WindowClassTemplate und WindowClassControlBaseTemplate, die der Stamm-WindowClassBase am n√§chsten liegen und die Grundlage f√ºr alle anderen Vererbungen bilden, eine neue variable Vorlagenklasse schreiben. In seiner einfachsten Version wird es so sein:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst wird eine allgemeine Beschreibung der Klassenvorlage ohne den Body deklariert. Dann wird seine Spezialisierung festgelegt, bei der der erste Typ vom Rest getrennt wird. Er ist f√ºr uns von Interesse. Dies gilt f√ºr den Fall, dass sich jede nachfolgende Klasse beim Verschieben der Hierarchiekette zu WindowClassBase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Parameterliste </font><font style="vertical-align: inherit;">befindet </font><font style="vertical-align: inherit;">. Dann wird die Klasse, die wir brauchen, am Anfang sein, und es ist sehr einfach, sie vom Rest zu trennen. Sie k√∂nnen es anders machen: Jede neue Klasse stellt sich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an den Anfang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der Vorlagenoptionen. Dann ist die Klasse oben in der Hierarchie die letzte in der Liste, und das Extrahieren von dort ist viel schwieriger. In diesem speziellen Fall sind diese beiden Ans√§tze v√∂llig identisch, aber der erste ist viel einfacher zu implementieren (auch w√§hrend der Kompilierung - Sie m√ºssen nicht die gesamte Liste verarbeiten, indem Sie das letzte Element daraus extrahieren), und er ist es, der oben angegeben ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Element, das die h√∂chste Klasse in der Hierarchie darstellt, wird aus der Liste abgerufen und an WindowClassBase √ºbergeben. Wenn OnCreate daf√ºr definiert ist, wird es aufgerufen. Andernfalls wird das OnCreate der n√§chsten Basisklasse in Bezug darauf aufgerufen. Wenn die Variablenparameterliste leer ist (wir versuchen, ein Objekt aus WindowClassVariadicTemplate zu erstellen), schl√§gt die Kompilierung fehl und erfordert mindestens einen Typ in der Parameterliste.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Klasse, die auf WindowClassVariadicTemplate basiert, sieht folgenderma√üen aus:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse, die eine undefinierte Liste von PrevWndClasses-Parametern akzeptiert hat, √ºbergibt sie weiter an die Basisklasse und f√ºgt sich als erstes Element mit einer leeren Liste von Parametern davor ein. </font><font style="vertical-align: inherit;">Da diese Klasse WindowClassVariadic1 selbst variabel ist, ist WindowClassVariadic1 &lt;&gt; ebenfalls variabel, allerdings ohne Parameter, und diese gesamte Folge von Klassen ist tats√§chlich eine variable Vorlage, von der jedes Element auch eine variable Vorlage ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende abgeleitete Klasse ist:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Ausnahme der √Ñnderung des Namens der Ableitung und der Basis hat die Klasse genau die gleiche Form wie die vorherige. </font><font style="vertical-align: inherit;">Die n√§chste Klasse ist √§hnlich:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Bedeutung der polymorphen Mehrfachvererbung: Indem wir eine Klasse auf diese Weise deklarieren, garantieren wir nicht nur die Erstellung von Objekten dieses Typs, sondern auch alle Objekte aller anderen daraus abgeleiteten Klassen, egal wie viel und was auch immer sie in Zukunft sind. In diesem Fall wird in WindowClassBase immer das richtige OnCreate aufgerufen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist diese Variablenvorlage die erste M√∂glichkeit, das Problem des Aufrufs von OnCreate beim Erstellen eines Fensters zu l√∂sen, das alle zuvor festgelegten Anforderungen vollst√§ndig erf√ºllt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Blick auf die Zukunft, in der letztendlich die beste Methode in der gegebenen Situation gefunden wurde, k√∂nnen Sie mit der Implementierung der Vererbung √ºber eine Variablenvorlage eine komplexere Kompilierungslogik in WindowClassBase implementieren: Wenn Sie auf alle Typen zugreifen k√∂nnen, bei denen die Vererbung stattgefunden hat, k√∂nnen Sie flexibel zwischen den erforderlichen ausw√§hlen oder Kriterien und rufen Sie die darin definierte Elementfunktion auf. </font><font style="vertical-align: inherit;">Dies ist jedoch immer noch ein etwas anderer Fall.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierungsklasse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ich die Reaktion von static_cast auf abgeleitete Typen nicht kannte, suchte ich weiter nach anderen M√∂glichkeiten, um die √úbertragung der Vertex-Klasse der Hierarchie an WindowClassBase zu implementieren. </font><font style="vertical-align: inherit;">Irgendwann dachte ich dar√ºber nach, die OnCreate-Implementierung in eine separate Klasse zu bringen, die speziell daf√ºr erstellt wurde:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse parametrisiert eine andere Klasse, die alle anderen √úberschreibungen f√ºr virtuelle Funktionen implementiert. </font><font style="vertical-align: inherit;">Es leitet sich aus der bereits beschriebenen WindowClassTemplate ab:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klassenvererbung erfolgt wie gewohnt f√ºr virtuelle Funktionen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur die speziell f√ºr die Implementierung von OnCreate definierte Initialisierungsklasse wird gem√§√ü der Vererbungskette von Klasse zu Klasse √ºbertragen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Befindet sich diese Klasse am oberen Rand der Hierarchie, entspricht der Parameter WndClsInit WindowClassInit1 - der f√ºr diese Klasse definierten Initialisierungsklasse - und wird weiter entlang der Hierarchiekette √ºbertragen. Wenn diese Klasse in der Kette zwischengeschaltet ist, akzeptiert sie einfach die an sie √ºbergebene Klasse und gibt sie weiter. Dann ist diese Option im Vergleich zu den vorherigen insofern g√ºnstig, als die Vorlagen sich nicht selbst √ºbertragen, sondern eine Klasse von Drittanbietern √ºbertragen, was viel einfacher implementiert ist (und aussieht). Eine Vorlage in dieser Form eignet sich auch ohne √Ñnderungen f√ºr die Implementierung der gesamten Vererbungskette: Es erfolgt nur die √Ñnderung von Klassennamen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zur Konvertierung im C-Stil wird in WindowClassTemplate diese Form der Vererbung in static_cast jedoch nicht √ºbersehen: Sie kann einfach nicht konvertiert werden, wenn diese von (WindowClassTemplate *) nach (WindowClassInit1 *) √ºbergeben wird. </font><font style="vertical-align: inherit;">Und das ist logisch: WindowClassInit1 ist eigentlich eine fremde Klasse, die nur als Typ an diesen Punkt √ºbergeben wurde. Sie ist in keiner Weise mit WindowClassTemplate und der gesamten Kette von Ableitungen davon verbunden, daher ist eine Zeigerkonvertierung in diese Klasse nicht akzeptabel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeleitete Verkettung von Klassentypen in WindowClassBase, bedingte √úbertragung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schlie√ülich wurde f√ºr diese Situation der beste Weg gefunden, den Typ der abgeleiteten Klasse √ºber die gesamte Vererbungskette auf die Stammbasis WindowClassBase zu √ºbertragen, ohne die Nachteile der vorherigen und gleichzeitig einfacher als die variable Vorlage. </font><font style="vertical-align: inherit;">Definieren Sie die folgende Vorlagenklasse basierend auf WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse akzeptiert DerWndCls als Parameter, der standardm√§√üig dieser Klasse entspricht. </font><font style="vertical-align: inherit;">W√§hrend der √úbertragung wird DerWndCls mit dieser Klasse verglichen: Bei Gleichheit (der Standardwert, dh die angegebene Klasse befindet sich oben in der Hierarchie) √ºbergibt sie sich selbst mit einer leeren Liste von Parametern. </font><font style="vertical-align: inherit;">Andernfalls werden die empfangenen DerWndCls weitergeleitet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich halte diese L√∂sung in jeder Hinsicht f√ºr die beste in dieser Situation:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine einzige Form der Klassendefinition f√ºr die gesamte Vererbungskette;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfache und transparente Logik der Klassen√ºbertragung entlang der gesamten Vererbungskette;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kein Overhead aufgrund der variablen Vorlage (in diesen F√§llen, wie in diesem Fall, wenn dies nicht erforderlich ist).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreckliche Vergeltung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeutet das alles? </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie, wenn Sie eine solche unkonventionelle Form der Vererbung verwenden m√∂chten, alle Ihre Klassen streng definiert formalisieren m√ºssen, damit sie die √úbertragung einer m√∂glichen neuen Ableitung durch sich selbst erm√∂glichen. </font><font style="vertical-align: inherit;">Dies ist eine sehr einfache Anforderung, und wenn Sie es w√ºnschen, ist es einfach zu befolgen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt noch eine andere, viel weniger triviale Frage: die Beziehung zwischen Typen und Zeigern. </font><font style="vertical-align: inherit;">Kluge Leute haben geschrieben: Spielen Sie nicht mit solchen Dingen im Konstruktor und versto√üen Sie gegen die Prinzipien der Sprache und die Logik des Compilers. </font><font style="vertical-align: inherit;">Aber ich habe nicht gehorcht und es trotzdem getan. </font><font style="vertical-align: inherit;">Jetzt kommt nat√ºrliche Vergeltung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also 4 Klassen:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich oben geschrieben habe, sind ihr spezifischer Inhalt und ihre Arbeitslogik v√∂llig unwichtig. </font><font style="vertical-align: inherit;">Das einzig Wichtige ist, dass im Titel der Klassendefinition. </font><font style="vertical-align: inherit;">Basierend auf diesen Klassen erstellen wir 4 Objekte:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erweitern die Definitionen ihrer Typen, die hinter leeren Klammern versteckt sind, mit den Standardargumenten. Typ w1 ist WindowClassDerivedAlternative1. Der Typ w2 ist WindowClassDerivedAlternative2 und seine Basisklasse ist WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. Der Typ w3 ist WindowClassDerivedAlternative3, seine Basisklasse ist WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt; und seine Basisklasse ist WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. √Ñhnliches gilt f√ºr das vierte Objekt. Schauen Sie sich das folgende Diagramm an:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem Sie jede neue abgeleitete Klasse auf der Grundlage einer bestimmten Basisklasse erstellen, die auf diese Weise definiert ist, definieren Sie nicht nur eine neue Klasse, sondern gleichzeitig die gesamte Kette ihrer Basisklassen erneut. Es wird parallel zur Kette seiner eigenen Basisklasse sein. Ihre Klasse wird ihre eigenen Basisklassen haben, und keine von ihnen kann zu einer der urspr√ºnglichen Basisklassen f√ºhren, obwohl der Generierungscode f√ºr alle diese Klassen der gleiche ist! Es scheint echte Fantasie, aber es ist wirklich! Dies bedeutet, dass alle √ºblichen Methoden zum Manipulieren geerbter Klassen und Zeiger nicht funktionieren! In dieser speziellen Architektur speichert nur die Basis-WindowClassBase die Situation, andernfalls w√§re es auch unm√∂glich, ein Array aus den Basisklassen zu erstellen (z. B. basierend auf der WindowClassTemplate).weil alle diese Klassen unterschiedliche Typen haben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So ist die bekannte und verst√§ndliche Definition der Form:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... wird die Kompilierung beenden, da Sie versuchen, einen Typzeiger zu erstellen, der nicht mit dem Typ des w2-Objekts kompatibel ist, obwohl Sie vor einer halben Stunde selbst eine Klasse geschrieben haben, die von der WindowClassDerivedAlternative1 &lt;&gt; -Klasse abgeleitet ist und auf der das w2-Objekt erstellt wurde.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Gewohnheitsgesetze aufh√∂ren zu wirken, kann dies einen Schock verursachen. </font><font style="vertical-align: inherit;">Und bei alledem gibt es tats√§chlich keine schmutzigen Compiler-Hacks, erzwungenen Typkonvertierungen und andere wirklich schlechte Dinge. </font><font style="vertical-align: inherit;">Alles ist √§u√üerst sauber und legal: Vorlagen, Standardparameter und Tools f√ºr die Typbibliothek. </font><font style="vertical-align: inherit;">Nur bekannte Methoden zum Schreiben von Code funktionieren nicht mehr. </font><font style="vertical-align: inherit;">Dies in einem realen Projekt zu verwenden bedeutet, dort eine Gefahrenzone zu deklarieren, die nur von qualifiziertem Fachpersonal mit geeigneten Schutzma√ünahmen betreten werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code-Experimente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um es allen zu erleichtern, die experimentieren m√∂chten, und Zeit beim Tippen zu sparen, habe ich auf GitHub alle Projekte ver√∂ffentlicht, die als Grundlage f√ºr diesen Artikel dienten: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
W√§hlen Sie einfach ein Projekt als Startprojekt aus, da Sie sonst in einem Meer bunter Fenster ertrinken.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄûWenn das alles so ein Witz ist, dann sieht es angesichts der Anstrengungen zu ernst und nat√ºrlich aus. </font><font style="vertical-align: inherit;">Und wenn es kein Scherz ist, dann wird kein normaler Entwickler, der bei klarem Verstand ist, so etwas wirklich verwenden. </font><font style="vertical-align: inherit;">Und √ºberhaupt, Alter, w√ºrdest du nicht am Ende Unsinn leiden und nicht etwas tun </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Geld bringt, es ist</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√ºtzlich. " </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben Recht, wenn Sie so denken. </font><font style="vertical-align: inherit;">In diesem Artikel habe ich nur gezeigt, dass C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Frage der praktischen Anwendung dieser Strukturen bleibt offen. Im Allgemeinen gilt dies eher f√ºr generalisierte und Metaprogrammierung. M√∂glicherweise m√ºssen Sie √ºberhaupt keine Objekte dieser Klassen erstellen, aber die Klassen selbst werden m√∂glicherweise aus irgendeinem Grund ben√∂tigt. Ja, und Sie wissen nie, welche n√ºtzlichen L√∂sungen Sie auf dieser Basis finden k√∂nnen ... Das urspr√ºngliche CRTP wird verwendet! Und es wird nicht einmal irgendwo verwendet, sondern direkt in der Standardbibliothek! Wer nicht glaubt oder sich nicht erinnert, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur√ºck zur urspr√ºnglichen Aufgabe mit Fenstern ... Besonders jetzt, n√ºchtern </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ohne Gras im</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√ºckblick auf all diese drei Jahre sp√§ter ... Auch wenn wir die Tatsache verwerfen, dass ich ein banales Thema angesprochen habe, das bereits millionenfach bereist wurde, und das f√ºr niemanden seit langem von Interesse war, denn im </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ernst Jungen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normale Leute haben </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt, ich w√ºrde nur sicherstellen, dass ein funktionales Objekt an die Fensterklasse √ºbergeben wird. </font><font style="vertical-align: inherit;">Es ist nicht schwierig, die √úbertragung durch die Vererbungskette sicherzustellen, aber es wird alles einfach, klar und ohne Verzerrung erledigt, und Sie erhalten eine v√∂llig normale vorhersehbare Klasse ohne Nebenwirkungen, die Sie begleiten und f√ºr absolut jeden entwickeln k√∂nnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was in diesem Artikel passiert ist, ist nur eine interessante, nicht triviale Aufgabe, die ich immer noch l√∂sen konnte. </font><font style="vertical-align: inherit;">Ich hoffe das war auch f√ºr dich interessant.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507114/index.html">Ode Excel: 34 Jahre Magie</a></li>
<li><a href="../de507116/index.html">"Udalenka". Notizen vom gestrigen B√ºroentwickler. Teil 2</a></li>
<li><a href="../de507124/index.html">PDB ist nicht nur wertvolles Fell</a></li>
<li><a href="../de507132/index.html">Vladimir Kitov: ‚ÄûEs ist unm√∂glich zu verstehen, wie wegweisende Wissenschaftler in den 1950er Jahren die universelle Computerisierung vorausgesehen haben!‚Äú</a></li>
<li><a href="../de507138/index.html">Geologie des 21. Jahrhunderts als Geodatenwissenschaft</a></li>
<li><a href="../de507148/index.html">Senden Sie magische Links mit Node.js.</a></li>
<li><a href="../de507150/index.html">Wir zeichnen ein Interferenzbild in JavaScript</a></li>
<li><a href="../en486014/index.html">SLAC Tour: US Department of Energy National Accelerator Laboratory at Stanford</a></li>
<li><a href="../en486018/index.html">Session Survey Results</a></li>
<li><a href="../en486024/index.html">Really simple graphics in R for science and journalism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>