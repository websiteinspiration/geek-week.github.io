<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏻 🌎 👨🏼‍✈️ Accès sécurisé à une maison intelligente en l'absence d'une adresse IP publique (partie 2) 💰 🧓🏻 😮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="introduction
 Dans la première partie, j'ai écrit sur l'énoncé du problème et comment la liste de souhaits a été transformée. En fin de compte, j'ai d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Accès sécurisé à une maison intelligente en l'absence d'une adresse IP publique (partie 2)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505412/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la première partie,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai écrit sur l'énoncé du problème et comment la liste de souhaits a été transformée. </font><font style="vertical-align: inherit;">En fin de compte, j'ai décidé d'utiliser OpenVPN, mais, du fait que j'ai décidé de tout exécuter dans des conteneurs Docker, il s'est avéré que ce n'était pas si simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je dois dire tout de suite que plus tard, j'ai tout refait, donc j'ai refusé le VPS externe. </font><font style="vertical-align: inherit;">Cependant, comme tout est dans des conteneurs, au cours du processus, je suis tombé sur un certain nombre de fonctionnalités intéressantes, qui seront discutées.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne décrirai que les points clés.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioBroker</font></font></h3><br>
<pre><code class="plaintext hljs">docker run -d --name iobhost  --net=host -v /opt/iobroker/:/opt/iobroker/ --device=/dev/ttyACM0 --env-file /opt/ioBroker_env.list --restart=always buanet/iobroker:latest
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis que j'ai une passerelle MiHome, des capteurs y sont connectés, même plusieurs scénarios sont mis en place, que je ne veux pas encore casser, je lui ai connecté ioBroker. Il a vu les capteurs, il n'a pas eu à les lier de nouveau au bâton Zigbee (bien qu'il y en ait aussi, et que certains boutons y soient connectés). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, afin que ioBroker contacte MiHome Gateway et le démarre avec le paramètre --net = host. Ceux. il utilise l'interface hôte; vous n'avez pas besoin de spécifier les ports à transmettre au conteneur. Sans cela, il ne pourrait pas voir la passerelle, car il fonctionne par multidiffusion.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paramètre --device = / dev / ttyACM0 est nécessaire pour transmettre la clé USB Zigbee au conteneur. </font><font style="vertical-align: inherit;">Toujours dans /opt/ioBroker_env.list, j'ai dû ajouter la ligne USBDEVICES = "/ dev / ttyACM0". </font><font style="vertical-align: inherit;">Il est important que cette ligne soit présente au moment du premier démarrage du conteneur, lorsqu'il voit un répertoire vide et commence sa configuration initiale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez le configurer plus tard, bien sûr, mais vous devrez effectuer des mouvements corporels supplémentaires.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serveur MQTT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur un VPS externe, il a lancé le moustique éclipse. </font><font style="vertical-align: inherit;">J'ai d'abord configuré TLS pour lui en émettant un certificat Let's encrypt. </font><font style="vertical-align: inherit;">Il a alors décidé que les clients devaient présenter le certificat, et seulement ensuite le nom et le mot de passe (protection contre la bruteforce). </font><font style="vertical-align: inherit;">Je l'ai donc refait à auto-signé, afin que les clients écrivent des certificats.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Openvpn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisé des images populaires avec le Docker Hub. </font><font style="vertical-align: inherit;">Pour le serveur (VPS) kylemanna / openvpn. </font><font style="vertical-align: inherit;">Pour le client (le serveur domestique sur lequel ioBroker est installé) - ekristen / openvpn-client.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personnalisation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, j'ai dû bricoler. </font><font style="vertical-align: inherit;">Dans le processus, j'ai bien ressenti les aspects réseau du docker, en travaillant avec iptables, j'en ai découvert un nouveau, y compris </font><font style="vertical-align: inherit;">netplan avec lequel je n'avais aucune affaire auparavant. </font><font style="vertical-align: inherit;">En fait, j'ai donc décidé d'écrire cet article.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serveur VPS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'installation d'OpenVPN et la configuration, tout est standard, comme </font><font style="vertical-align: inherit;">il est écrit </font><font style="vertical-align: inherit;">sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://hub.docker.com/r/kylemanna/openvpn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce que j'ai fait en plus était d'augmenter les bouclages supplémentaires sur le VPS et le serveur domestique. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/netplan/01-netcfg.yaml</font></font></i><br>
<br>
<pre><code class="plaintext hljs">	# This file describes the network interfaces available on your system<font></font>
	# For more information, see netplan(5).<font></font>
	network:<font></font>
	  version: 2<font></font>
	  renderer: networkd<font></font>
	  &lt;b&gt;ethernets:<font></font>
	    lo:<font></font>
	      renderer: networkd<font></font>
	      match:<font></font>
	        name: lo<font></font>
	      addresses:<font></font>
        - 192.168.16.1/32&lt;/b&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bold a mis en évidence «l'additif». Les espaces ne semblent pas être affichés, bien qu'ils soient très importants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les adresses dans les exemples utiliseront 192.168.6.0 pour le réseau domestique et 192.168.16.0 pour le bouclage. J'essaierai de ne faire aucune erreur nulle part. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openvpn.conf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajouté</font></font><br>
<br>
<pre><code class="plaintext hljs">server 192.168.16.192 255.255.255.192<font></font>
push "dhcp-option DNS 192.168.16.6"<font></font>
push "route 192.168.16.0 255.255.255.128"<font></font>
client-to-client<font></font>
client-config-dir       /etc/openvpn/ccd/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai spécialement fait un bouclage à partir de 192.168.16.0/25, et je donne des adresses aux clients à partir de 192.168.16.128/25, afin que par la suite les règles de résolution dans iptables puissent être configurées avec une seule grille 192.168.16.0/24 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, VPS a un bouclage de 192.168.16.1, il a mqtt dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le serveur domestique a 192.168.16.6. Il existe iobroker, alias dns pour les clients domestiques et redéfinit un certain nombre de noms de domaine pour la connexion à partir du réseau domestique ou via un VPN. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y avait une idée partout pour enregistrer sa "vraie" IP depuis le réseau. Tapez ccd / iobroker pour spécifier </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iroute 192.168.6.6 255.255.255.255</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais, apparemment du fait qu'il s'agit d'une adresse du réseau sur l'interface WiFi de l'ordinateur portable domestique, et dans de nombreux cas, c'est la passerelle par défaut, il y a eu des problèmes. Y compris avec un smartphone. Et je voulais que le réseau domestique fonctionne à la fois avec un client actif et sans lui. Et je n'ai pas eu à déconnecter frénétiquement le client, rentrant chez lui pour avoir accès à d'autres ressources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, j'ai configuré ce serveur et ses conteneurs pour toujours interagir avec le bouclage, que le VPN soit actif ou non. Et la même adresse était adressée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ccd / iobroker</font></font></i><br>
<br>
<pre><code class="plaintext hljs">iroute 192.168.16.6 255.255.255.255</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, tous les clients VPN savent que le réseau 192.168.16.0/24 est accessible via un VPN. S'ils envoient des paquets à 192.168.16.1 (VPS de bouclage), le paquet est chiffré, pénètre dans le conteneur openvpn, déchiffré, la route par défaut passe à 172.17.0.1 (passerelle par défaut dans les conteneurs par défaut), il arrive à l'hôte, tout va bien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comment puis-je «cingler» le client VPN à partir de l'hôte VPS ou accéder au serveur domestique avec l'adresse 192.168.16.6 (et non son IP temporaire sur le tunnel VPN qui est à l'intérieur du conteneur OpenVPN)? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Évidemment, le maillage 192.168.16.0 doit être routé vers le conteneur OpenVPN. Bien sûr, je peux voir que c'est 172.17.0.3. Mais un jour, cela pourrait changer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si OpenVPN était déployé directement sur le serveur, et non dans le conteneur, tout fonctionnerait par lui-même. </font><font style="vertical-align: inherit;">Et puis j'ai dû le faire avec ruse. </font><font style="vertical-align: inherit;">Je crée un script élaboré par les plus récents du système et je le mets dedans:</font></font><br>
<br>
<pre><code class="plaintext hljs">ipaddr=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' vpn-client)<font></font>
route add -net 192.168.16.0/24 gw $ipaddr</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. </font><font style="vertical-align: inherit;">via docker inspect, je trouve l'adresse IP du conteneur en cours d'exécution, puis j'y achemine la grille de la manière habituelle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contrairement au rc.local habituel, j'ai dû le rechercher sur Google, mais comment, en fait, faire un script qui fonctionne en dernier. </font><font style="vertical-align: inherit;">Voici une brève instruction: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez le fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/custom.target</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">[Unit] <font></font>
Description=My Custom Target<font></font>
Requires=multi-user.target<font></font>
After=multi-user.target<font></font>
AllowIsolate=yes<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez le fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/last_command.service</font></font></i> <br>
<br>
<pre><code class="plaintext hljs">[Unit]<font></font>
Description=My custom command<font></font>
After=multi-user.target<font></font>
[Service]<font></font>
Type=simple<font></font>
ExecStart=/usr/local/bin/my_last_command.sh<font></font>
[Install]<font></font>
WantedBy=custom.target<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez le répertoire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/custom.target.wants</font></font></i><br>
<br>
<pre><code class="plaintext hljs">ln -s /etc/systemd/system/last_command.service \   /etc/systemd/system/custom.target.wants/last_command.service<font></font>
systemctl daemon-reload<font></font>
systemctl set-default custom.target</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez démarrer immédiatement, sans attendre un redémarrage: systemctl isolate custom.target </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, après le redémarrage </font><font style="vertical-align: inherit;">, le </font><font style="vertical-align: inherit;">fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/local/bin/my_last_command.sh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décrit dans ExecStart </font><font style="vertical-align: inherit;">sera le dernier à être lancé </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iptables</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le serveur mqtt, j'ai 2 ports levés: 8883 avec TLS et authentification, accessible depuis Internet pour les capteurs distants. Oui, et je peux moi-même en quelque sorte connecter MQTT Explorer et vérifier quoi et comment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1883 déjà sans TLS, ne nécessite qu'un nom d'utilisateur et un mot de passe. Nécessaire pour la maison Sonoff rfBridge, dont TLS ne sait pas comment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas effrayant, car le trafic de la maison ira au serveur avec iobroker, qui est la passerelle par défaut pour 192.168.16.0, il transmettra le paquet à un conteneur avec OpenVPN, etc. Cependant, vous devez autoriser l'accès au port 1883 uniquement de l'intérieur. Ceux. iptables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche standard consiste à refuser l'accès à ce port de n'importe où, puis à suivre la règle qui autorise l'accès à partir des réseaux internes.</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -I INPUT -p tcp -m tcp --dport 1883 -j DROP<font></font>
iptables -I INPUT -s 172.17.0.0/24 -p tcp -m tcp --dport 1883 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La grille est indiquée ici 172.17.0.0, car à partir d'OpenVPN je vais aux "voisins" en conséquence, je vais masquer NAT (ce conteneur iobroker qui rfBridge du réseau WiFi), et non des originaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et donc ça marche. </font><font style="vertical-align: inherit;">Mais il y a une nuance. </font><font style="vertical-align: inherit;">Mon port 1883 est transmis au conteneur mqtt. </font><font style="vertical-align: inherit;">Et, comme il s'est avéré, iptables remplit d'abord la chaîne DOCKER-USER. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, avec cette règle, l'accès au port 1883 a été autorisé _à_ la règle de blocage. </font><font style="vertical-align: inherit;">Et à partir d'Internet, vous pouvez également vous y connecter facilement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une règle de blocage doit être créée dans la chaîne DOCKER-USER!</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -I DOCKR-USER -p tcp -m tcp --dport 1883 -j DROP<font></font>
iptables -I INPUT -s 172.17.0.0/24 -p tcp -m tcp --dport 1883 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais celui du bas, permettant l'accès à partir des réseaux internes, nécessite pour une raison quelconque INPUT.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serveur domestique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie principale est la même. </font><font style="vertical-align: inherit;">Cependant, bien qu'il soit un client, il a dû acheminer le trafic d'un réseau WiFi (rfBridge) vers mqtt sur VPS. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">circulation: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rfBridge (192.168.6.8) -&gt; hôte iobroker (192.168.6.6) -&gt; conteneur vpn-client (172.17.0.?) -&gt; conteneur opevpn sur VPS -&gt; VPS loopback (192.168.16.1) -&gt; conteneur mqtt (port 1883) Nous </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
autorisons les paquets "forward" pour la grille avec les clients et les bouclages:</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -A FORWARD -d 192.168.16.0/24 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et passer aux spécificités des conteneurs.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tache 1</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous vous en souvenez, l'interaction entre les sous-systèmes que j'ai configurés via le bouclage. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">il est nécessaire que les paquets sur 192.168.16.6 de vpn-client soient envoyés à l'hôte (172.17.0.1), et non au tunnel VPN. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous exécutez cette commande dans un conteneur en cours d'exécution, tout fonctionnera. </font><font style="vertical-align: inherit;">Après le redémarrage, cela sera oublié, mais vous pouvez le spécifier dans le fichier de configuration iobroker.ovpn </font></font><br>
<code>route 192.168.16.6 255.255.255.255 172.17.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et openvpn installera cette route au démarrage du conteneur. </font><font style="vertical-align: inherit;">Ceci est résolu facilement de manière standard.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tâche 2</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les paquets du réseau domestique 192.168.6.0 (par exemple, de rfBridge) vont à l'hôte iobroker et sont transférés vers le conteneur vpn-client. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, je n'inclus pas délibérément le réseau 192.168.6.0 dans le domaine de chiffrement, le conteneur OpenVPN sur le VPS ne sait pas quoi faire avec ce réseau. La solution évidente est de faire du NAT à l'intérieur de vpn-client afin que le paquet sur le VPS provienne de son adresse. Mais il y a une nuance. Comment enregistrer les commandes iptables requises après le redémarrage du conteneur? Iptables-persistent n'est pas si facile à mettre là-bas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez, bien sûr, assembler un nouveau récipient avec des additifs. Mais je ne veux pas, car la procédure de mise à niveau deviendra plus compliquée. Au lieu de "tué et lancé le dernier, et il a extrait la configuration du dossier monté", il va falloir lancer l'assemblage ... Pas pour ça je communique avec des containers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, j'ai décidé "après le démarrage du conteneur, d'exécuter de force des commandes qui indiquent à iptables de faire du NAT". </font><font style="vertical-align: inherit;">J'ai utilisé l'équipe pour cela </font></font><br>
<code>docker events --filter "container=vpn-client" --filter "event=start"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elle se bloque et attend l'événement spécifié dans les filtres. </font><font style="vertical-align: inherit;">Dans mon cas, démarrez le conteneur. </font><font style="vertical-align: inherit;">Après cela, via docker exec, j'exécute les commandes requises depuis l'hôte qu'il contient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, par analogie avec VPS, je configure </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/local/bin/my_last_command.sh</font></font></i><br>
<br>
<pre><code class="plaintext hljs">#!/bin/bash<font></font>
cont="vpn-client"<font></font>
ipaddr=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' $cont)<font></font>
route add -net 192.168.16.0/24 gw $ipaddr<font></font>
for (( ; ; ))<font></font>
do<font></font>
  docker events --filter "container=$cont" --filter "event=start"<font></font>
  docker exec -it $cont iptables -t nat -I POSTROUTING -s 192.168.16.0/255.255.255.0 -j MASQUERADE<font></font>
  docker exec -it $cont iptables -t nat -I POSTROUTING -s 192.168.6.0/255.255.255.0 -j MASQUERADE<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe des exemples dans lesquels la sortie des événements docker est passée à l'entrée awk, qui exécute les commandes. </font><font style="vertical-align: inherit;">Mais il m'a semblé plus facile de «suspendre» avant l'événement, d'exécuter des commandes et d'attendre à nouveau l'événement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honnêtement, je ne voulais pas écrire ce post. J'ai acquis une expérience intéressante, mais ça s'est avéré «pas beau», c'est trop difficile, je n'aime pas tellement ça. Encore une fois, j'ai tout refait, refusé VPS en général. Mais depuis que j'ai promis la deuxième partie ... De plus, j'ai été impressionnée par l'approche des événements dockers, j'ai voulu la partager. Je pense que cela sera utile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalement, je l'ai décidé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je n'ai pas pu publier de vis via le proxy inverse et que je peux facilement prendre mqtt de l'extérieur en tant que service, je n'ai pas besoin de VPS pour cette tâche. Je peux également télécharger le firmware des mises à jour OTA vers l'hébergement, il y a un avantage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mqtt a pris wqtt.ru. </font><font style="vertical-align: inherit;">TLS est (les mots de passe sont envoyés sous une forme sécurisée). </font><font style="vertical-align: inherit;">La vitesse est excellente (10 ms contre 80 ms pour mymqtthub). </font><font style="vertical-align: inherit;">Les sujets à réécrire dans '$ device / &lt;crazy ID&gt; / events' (comme Yandex) ne sont pas requis. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">dans ce cas, vous pouvez sauter quelque part facilement. </font><font style="vertical-align: inherit;">Le prix est bon marché (300 roubles par an). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je poste le firmware pour OTA sur celui existant pour l'hébergement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'accès à vis se fait toujours par Zerotier. </font><font style="vertical-align: inherit;">C'est très simple et pratique. </font><font style="vertical-align: inherit;">Et même s'ils sont cassés, il est peu probable que je regarde le niveau de CO2 dans ma maison. </font><font style="vertical-align: inherit;">Et même si cela se produit, cela deviendra bientôt célèbre que s'ils me brisent personnellement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est beau, cela fonctionne sans échec, il est facile de faire des changements si nécessaire, il n'y a pas de serveurs inutiles qui ont besoin de maintenance, je suis satisfait.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505394/index.html">Antiquités: Nokia E90, le dernier communicateur</a></li>
<li><a href="../fr505398/index.html">Les côtés sombres et clairs du travail chez Yandex</a></li>
<li><a href="../fr505400/index.html">À quoi devraient ressembler les modèles?</a></li>
<li><a href="../fr505402/index.html">Superposition d'une texture 2D sur un objet 3D à l'aide de p5.js (partie 2 - Application d'un motif à un cube)</a></li>
<li><a href="../fr505404/index.html">La façon la plus simple d'apprendre l'anglais avec des vidéos TED</a></li>
<li><a href="../fr505416/index.html">MikroTik en mode répéteur - tout comme One-Two-Three</a></li>
<li><a href="../fr505418/index.html">[Question] Avez-vous vu des gens qui utilisent des abonnements au contenu mobile?</a></li>
<li><a href="../hi486176/index.html">कॉर्पोरेट ईमेल पत्राचार मेमो</a></li>
<li><a href="../hi486178/index.html">FOSS News No. 1 - 27 जनवरी - 2 फरवरी, 2020 के लिए स्वतंत्र और मुक्त स्रोत समाचार की समीक्षा</a></li>
<li><a href="../hi486180/index.html">सर्वर रहित एप्लिकेशन बनाने के लिए सुझाव और स्रोत</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>