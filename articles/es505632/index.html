<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèª üëäüèΩ ‚úèÔ∏è Asignadores de memoria üîÆ üï∂Ô∏è üç¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Hola a todos! No hace mucho tiempo, despu√©s de un estudio exhaustivo de los asignadores y los algoritmos de asignaci√≥n de memoria, as√≠ como su poster...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Asignadores de memoria</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Hola a todos! </font><font style="vertical-align: inherit;">No hace mucho tiempo, despu√©s de un estudio exhaustivo de los asignadores y los algoritmos de asignaci√≥n de memoria, as√≠ como su posterior aplicaci√≥n en la pr√°ctica, se me ocurri√≥ la idea de escribir un art√≠culo que los describiera con el mayor detalle posible. </font><font style="vertical-align: inherit;">Creo que este tema ser√° bastante popular, ya que hay muy pocas fuentes en la red, especialmente en la parte de habla rusa, dedicadas a este tema.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefacio</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, me gustar√≠a se√±alar de inmediato que si alguien escucha por primera vez los t√©rminos "asignador", "algoritmos de asignaci√≥n de memoria" y no comprende para qu√© sirve todo esto, entonces, antes de leer este art√≠culo, le recomiendo que se familiarice con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fuente . </font><font style="vertical-align: inherit;">Este art√≠culo describe muy bien qu√© problemas existen en los asignadores de memoria est√°ndar y para qu√© fines vale la pena usar otros m√©todos de asignaci√≥n de memoria, adem√°s de los est√°ndares. </font><font style="vertical-align: inherit;">Aqu√≠ hablar√© solo sobre los algoritmos de distribuci√≥n en s√≠ mismos y, por supuesto, al final dar√© una implementaci√≥n de uno de los asignadores, que se puede usar sin problemas en los contenedores C ++ est√°ndar.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los basicos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cinco operaciones principales que se pueden realizar en un asignador se resaltan conceptualmente (me gustar√≠a se√±alar que no todos los asignadores pueden corresponder expl√≠citamente a esta interfaz):</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : crea un asignador y le da una cierta cantidad de memoria;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : selecciona un bloque de cierto tama√±o del √°rea de memoria que controla el asignador;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desasignar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - libera un bloque espec√≠fico;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : libera todos los bloques asignados de la memoria del asignador (la memoria asignada al asignador no se libera);</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destruir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : destruye el asignador con la posterior liberaci√≥n de memoria asignada al asignador.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignador lineal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asignador lineal, tambi√©n es "lineal": este es el tipo de asignador m√°s simple. La idea es guardar un puntero al comienzo del bloque de memoria para el asignador asignado, y tambi√©n usar un puntero o representaci√≥n num√©rica diferente, que deber√° moverse cada vez que se complete la asignaci√≥n del asignador. En este asignador, la fragmentaci√≥n interna se minimiza porque todos los elementos se insertan secuencialmente (localidad espacial), y la √∫nica fragmentaci√≥n entre ellos es la alineaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, propongo considerar varios ejemplos en los que se mostrar√° claramente en detalle c√≥mo funciona este asignador. Tome un bloque de memoria igual a 14 bytes y dele el control del asignador. Como se puede ver en la imagen a continuaci√≥n, guardamos un puntero al comienzo de la memoria ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), y tambi√©n almacena dos punteros, o dos representaciones num√©ricas que contienen informaci√≥n sobre el total ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y los </font><font style="vertical-align: inherit;">tama√±os de memoria </font><font style="vertical-align: inherit;">usados ‚Äã‚Äã( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usados</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine que el asignador recibi√≥ una solicitud para asignar 4 bytes de memoria. </font><font style="vertical-align: inherit;">Las acciones del asignador en la ejecuci√≥n de esta solicitud ser√°n las siguientes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comprobar si hay suficiente memoria para asignar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guarde el puntero utilizado actualmente, que luego se le dar√° al usuario como puntero a un bloque de memoria asignada desde el asignador;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desplazar el puntero usado en una cantidad igual al tama√±o del bloque de memoria asignado, es decir </font><font style="vertical-align: inherit;">por 4 bytes.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, por ejemplo, llega una solicitud para la asignaci√≥n de 8 bytes y, en consecuencia, las acciones del asignador ser√°n exactamente las mismas independientemente del tama√±o del bloque de memoria asignado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero aqu√≠ ya ser√° un poco m√°s interesante, por ejemplo, si llega una solicitud para asignar solo 1 byte, y si no queremos alinear bloques en la memoria (por ejemplo, direcciones que son m√∫ltiplos de 2, 4, ...), entonces las acciones del asignador seguir√°n siendo exactamente las mismas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, si necesitamos asignar bloques de memoria con una cierta alineaci√≥n (por ejemplo, alineaci√≥n de direcciones m√∫ltiplo de 2), entonces la acci√≥n del asignador cambia ligeramente. No cambia en t√©rminos de implementaci√≥n, sino que, adem√°s de los datos en s√≠ iguales al volumen de un byte, tambi√©n tomamos un byte adicional de la memoria del asignador para la alineaci√≥n, que no tiene ning√∫n significado. Esta es precisamente la fragmentaci√≥n m√≠nima muy posible de memoria dentro de un asignador lineal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genial, ahora es el momento de hablar sobre liberar memoria. Como se se√±al√≥ anteriormente, este tipo de alocotor no admite la liberaci√≥n selectiva de ciertos bloques de memoria. Es decir, si dibujamos una analog√≠a sutil con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tener un puntero para, por ejemplo, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA00</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podr√≠amos liberar este bloque de memoria, pero un asignador lineal no puede permitirnos hacer esto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo lo que podemos hacer es liberar toda la memoria ocupada completamente dentro del asignador y continuar trabajando con √©l como si estuviera completamente vac√≠o.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignador de piscina</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea de un asignador de bloques es que divide una gran parte de la memoria en partes m√°s peque√±as del </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mismo tama√±o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En esencia, tambi√©n es un asignador muy simple, ya que cuando se solicita la asignaci√≥n, simplemente devuelve una de las ubicaciones de memoria libre de un tama√±o fijo, y cuando se solicita que se libere, simplemente guarda esta √°rea de memoria para uso futuro. Por lo tanto, la distribuci√≥n es muy r√°pida y la fragmentaci√≥n sigue siendo muy peque√±a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, as√≠ como con un asignador lineal, propongo considerar todo con un ejemplo para comprender con m√°s detalle c√≥mo funciona, por lo que tomamos un bloque de memoria igual a 12 bytes y se lo damos al control del asignador. Como puede ver en la imagen a continuaci√≥n, mantenemos el puntero al principio (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y el final ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de la memoria controlada por el asignador, as√≠ como una lista ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloques libres</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de las direcciones de los bloques libres en el asignador. Como un medio para almacenar datos de que el bloque est√° ocupado o libre, puede usar muchas herramientas, por ejemplo, una matriz de valores booleanos, pero decid√≠ elegir una lista simplemente conectada, ya que caracteriza este concepto de manera m√°s simple y clara (por cierto, los enlaces de la lista pueden almacenarse en bloques libres de memoria, eliminando as√≠ los costos adicionales de la memoria).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si llega una solicitud para asignar un bloque de memoria, las acciones del asignador son muy primitivas. Primero, verifica si hay enlaces en la lista de bloques libres, si no est√°n all√≠, entonces no es dif√≠cil adivinar que la memoria en el asignador ya se ha agotado. Si hay al menos un enlace all√≠, simplemente saca el enlace ra√≠z o de cola (en esta implementaci√≥n se proporcionan enlaces de cola) de la lista y le da su direcci√≥n al usuario. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si llega una solicitud para la asignaci√≥n de varios bloques de memoria, entonces el asignador de la misma manera realiza las mismas acciones, descritas en el paso anterior.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a la liberaci√≥n del bloque, si llega una solicitud de liberaci√≥n, entonces el asignador simplemente agrega esta direcci√≥n a uno de los extremos de una lista simplemente conectada. Vale la pena se√±alar un momento en el que, por ejemplo, una direcci√≥n que no coincide con la direcci√≥n de memoria del asignador, por ejemplo, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xEFAB12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">puede venir como la direcci√≥n del bloque que se va a liberar </font><font style="vertical-align: inherit;">, y luego ser√° posible que le demos al usuario un trozo de memoria que no nos pertenece (por supuesto , esto conducir√° a un comportamiento indefinido o si tiene mucha suerte, simplemente bloquee el programa). Para evitar este posible problema, solo </font><i><font style="vertical-align: inherit;">se utilizan el </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que le permiten verificar si el usuario se equivoc√≥ con la direcci√≥n durante la solicitud de la operaci√≥n de liberaci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de ir m√°s all√° de la memoria que el asignador no controla, hay otro posible problema. </font><font style="vertical-align: inherit;">Un usuario puede presentar una solicitud para liberar absolutamente cualquier direcci√≥n ubicada en el √°rea de memoria del asignador, pero no igual a la direcci√≥n de inicio de cualquiera de los bloques, digamos un bloque con la direcci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA07</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta operaci√≥n, por supuesto, conducir√° a un comportamiento indefinido. </font><font style="vertical-align: inherit;">Si es necesario verificar adicionalmente si el usuario est√° haciendo todo correctamente, entonces es posible rastrear esto. </font><font style="vertical-align: inherit;">Para rastrear esto, hay muchas soluciones, por ejemplo, para almacenar direcciones y bloques ocupados tambi√©n, o incluso verificar la direcci√≥n para la multiplicidad de tama√±os de bloque en el asignador (todo depende de la imaginaci√≥n y de la situaci√≥n particular en la que se utiliza el asignador).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignador de pila</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, esta es una evoluci√≥n inteligente de un asignador lineal que le permite administrar la memoria como una pila. Todo es igual que antes, guardamos el puntero con el bloque "encabezado" (en adelante se usar√° como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encabezado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) en la direcci√≥n de memoria actual y lo movemos hacia adelante para cada asignaci√≥n. A diferencia de un asignador lineal, tambi√©n podemos moverlo hacia atr√°s, es decir, realizar la operaci√≥n de desasignaci√≥n, que no es compatible con un asignador lineal. Como antes, se mantiene el principio de localidad espacial, y la fragmentaci√≥n sigue siendo m√≠nima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Propongo considerar varios ejemplos, todos con el mismo bloque de memoria de 14 bytes. Al igual que con un asignador lineal, tambi√©n almacenamos punteros al comienzo de la memoria ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y al final ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), as√≠ como un puntero al final de la memoria </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">utilizada</font></i><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando llega una solicitud de asignaci√≥n de memoria, adem√°s de asignar una cierta cantidad de memoria solicitada por el usuario, tambi√©n asignamos un encabezado (el usuario no interactuar√° con √©l de ninguna manera), en el que almacenamos informaci√≥n sobre cu√°ntos bytes se asignaron (en este ejemplo, el tama√±o del encabezado es 2 bytes). Por ejemplo, si recibi√≥ una solicitud de asignaci√≥n de 2 bytes, el estado del asignador ser√° exactamente el mismo que en la figura a continuaci√≥n. Es importante tener en cuenta que al usuario no se le dar√° un puntero al t√≠tulo, sino al bloque que sigue inmediatamente al t√≠tulo, es decir, en este ejemplo, este es el bloque con la direcci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA02</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una situaci√≥n similar ser√°, por ejemplo, con la asignaci√≥n de 6 bytes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero con el lanzamiento, todo es un poco m√°s interesante (como se discuti√≥ anteriormente, solo podemos asignar y liberar memoria usando el algoritmo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Primero, del puntero que el usuario pide que se libere, debe restar el tama√±o del encabezado, luego desreferenciar el valor y solo despu√©s de eso mover el puntero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al tama√±o del encabezado junto con el tama√±o del bloque obtenido del encabezado. </font><font style="vertical-align: inherit;">Aqu√≠, al igual que con el asignador de bloques, es posible una situaci√≥n de liberaci√≥n de bloques de memoria "aleatorios", que tambi√©n conducir√° a un comportamiento indefinido. </font><font style="vertical-align: inherit;">Depende de todos complementar los asignadores con controles adicionales o no. </font><font style="vertical-align: inherit;">Lo m√°s importante es no olvidarse de este momento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, habiendo entendido los conceptos b√°sicos, es hora de aprender algo m√°s serio.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Distribuidor est√°ndar primitivo"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, se presentar√° una implementaci√≥n del asignador, que se puede utilizar sin problemas con STL. El algoritmo de asignaci√≥n de memoria en este asignador ser√° similar al algoritmo utilizado por el asignador est√°ndar. Quiero se√±alar de inmediato que no pretendo ser una implementaci√≥n completa de malloc, tom√© solo los conceptos b√°sicos con la adici√≥n de mi l√≥gica en algunos lugares. Todas sus sutilezas y matices, por supuesto, no se tuvieron en cuenta en esta implementaci√≥n ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo se basa en la interacci√≥n con "fragmentos" (en adelante, se utilizar√° como una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secci√≥n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en esta implementaci√≥n, su tama√±o es est√°tico y debe ser un m√∫ltiplo de cuatro, as√≠ como todas las asignaciones de memoria de la memoria del asignador est√°n alineadas por un m√∫ltiplo de cuatro), que se discutir√° m√°s adelante. Como ejemplo, tome una secci√≥n con un tama√±o de 16 bytes. En su interior, contendr√° punteros al inicio ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y al final ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de la memoria, un puntero al bloque de memoria m√°xima ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y muchos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloques libres</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), en el que se almacenar√°n los encabezados de los bloques libres. El tama√±o del encabezado en esta implementaci√≥n es de 4 bytes, pero puede variar f√°cilmente en tama√±o para los fines que necesita. Por ejemplo, si sabe con certeza que el tama√±o de los bloques de memoria asignados no ser√° mayor que el valor num√©rico m√°ximo que se puede representar en una o dos variables de bytes, puede usar un encabezado de 1 o 2 bytes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la operaci√≥n de asignaci√≥n de memoria desde una secci√≥n, primero debe verificar si hay suficiente memoria (en esta implementaci√≥n, esta es una operaci√≥n constante, solo la comparamos con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encabezado y, si el tama√±o de la memoria asignada es menor que el bloque m√°ximo, entonces tenemos suficiente memoria para esta asignaci√≥n). Si hay suficiente memoria, simplemente le damos la direcci√≥n de memoria despu√©s del encabezado, como en el asignador de pila, y tambi√©n eliminamos el encabezado anterior del conjunto de bloques libres y solo despu√©s de eso agregamos el nuevo encabezado al bloque de memoria reci√©n asignado. Es importante tener en cuenta que si asignamos memoria del bloque m√°ximo, entonces tendremos que actualizar el valor del bloque m√°ximo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En las selecciones posteriores, todo sucede exactamente igual que en el paso anterior.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero ahora, tan pronto como termina la memoria en la secci√≥n, el asignador toma y simplemente crea otra secci√≥n del mismo tama√±o o mayor (en esta implementaci√≥n, todas las secciones tienen el mismo tama√±o). Tambi√©n vale la pena asegurarse de que el tama√±o del posible bloque para la asignaci√≥n no exceda el tama√±o del gr√°fico menos el tama√±o del encabezado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, en la nueva secci√≥n, puede asignar f√°cilmente los bloques de memoria necesarios. La asignaci√≥n de memoria ocurrir√° exactamente en el mismo escenario que en la secci√≥n anterior.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora un poco sobre por qu√© en esta implementaci√≥n, el tama√±o de la trama debe ser un m√∫ltiplo de cuatro. La respuesta es muy simple: esto se hace para facilitar la implementaci√≥n y la percepci√≥n del algoritmo. Como tal situaci√≥n es posible, al final de la secci√≥n puede quedar algo de √°rea de memoria, que simplemente no se ajusta al encabezado (un ejemplo de esto se muestra en la siguiente figura). Para resolver este problema, ser√° posible llenar esta memoria con una alineaci√≥n adicional, o hacer que el tama√±o del encabezado sea m√°s peque√±o o usar herramientas adicionales para rastrear este posible problema, de lo contrario, esta memoria se perder√° y lo m√°s importante, en el futuro, ¬°la memoria perdida puede acumularse!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de liberar memoria, debe determinar en qu√© secci√≥n se encuentra el bloque (en la implementaci√≥n actual, esta operaci√≥n es de complejidad lineal en relaci√≥n con el n√∫mero total de secciones, si se entiende que habr√° un gran n√∫mero de secciones, entonces puede hacerse constante agregando un √≠ndice de secci√≥n al encabezado, en el que se asign√≥ la memoria). A continuaci√≥n, la operaci√≥n de desasignaci√≥n es id√©ntica al asignador de pila, excepto que deber√° agregar la direcci√≥n de encabezado del bloque desasignado al conjunto de bloques libres, as√≠ como actualizar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si el tama√±o del bloque reci√©n lanzado es mayor que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es importante tener en cuenta que en esta implementaci√≥n, con cada lanzamiento de memoria posterior, se intenta desfragmentar en el √°rea desde la cual se liber√≥ la memoria. La desfragmentaci√≥n es necesaria para combinar bloques libres en bloques grandes. Por ejemplo, en esta situaci√≥n, como en la figura a continuaci√≥n, no podemos asignar 6 bytes, incluso si el tama√±o de la memoria libre nos permite hacer esto, ¬°pero la fragmentaci√≥n nos dice un "no" firme y decisivo! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La operaci√≥n de desfragmentaci√≥n es muy primitiva. Su esencia radica en el hecho de que despu√©s de la operaci√≥n de liberar memoria, verifica si dos bloques vecinos a la izquierda y a la derecha de los liberados est√°n libres. Si dos bloques vecinos son libres, entonces se combinan en una sola unidad.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n me gustar√≠a se√±alar que esta implementaci√≥n ser√° desastrosamente horrible para trabajar con la asignaci√≥n de peque√±os bloques de memoria, por ejemplo, igual a 1 byte. </font><font style="vertical-align: inherit;">En esta situaci√≥n, obtenemos +7 bytes adicionales para asignar solo un byte de memoria debido al hecho de que el tama√±o del encabezado es de 4 bytes y m√°s 3 bytes para eliminar las direcciones que deben ser m√∫ltiplos de cuatro. </font><font style="vertical-align: inherit;">Con esto, quiero decir que no debe usar ciegamente ning√∫n algoritmo de asignaci√≥n de memoria, ya que en lugar de la optimizaci√≥n tan esperada, a veces solo puede obtener costos adicionales. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que la teor√≠a ser√° suficiente y, por lo tanto, como dijo Linus Torvalds: ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chatter no vale nada. </font><font style="vertical-align: inherit;">Mu√©strame el c√≥digo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Bueno, empecemos ...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los requisitos para los asignadores se dan en el est√°ndar C ++ en el cap√≠tulo " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisitos del asignador [allocator.requirements]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">En funci√≥n de esos requisitos, la interfaz de asignaci√≥n m√°s primitiva que se puede utilizar en STL deber√≠a tener este aspecto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se supone que los contenedores STL no acceden al asignador directamente, sino a trav√©s de la plantilla std :: allocator_traits, que proporciona valores como:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
‚Ä¶ <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, descubrimos los requisitos, ahora finalmente estamos comenzando a escribir un asignador. </font><font style="vertical-align: inherit;">Para empezar, escribiremos alguna interfaz o adaptador, de hecho es dif√≠cil llamarlos a ambos, as√≠ que dejemos que sea una especie de "capa" en la que, usando estrategias, podemos cambiar f√°cilmente el algoritmo de asignaci√≥n de memoria para ciertos fines:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias a la estrategia para la asignaci√≥n de memoria, podemos hacer algo como esto:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, podemos cambiar de manera flexible los algoritmos de distribuci√≥n para los fines necesarios en una situaci√≥n dada. </font><font style="vertical-align: inherit;">El √∫nico requisito para AllocationStrategy es que deben tener </font><i><font style="vertical-align: inherit;">operaciones de </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desasignaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De aqu√≠ en adelante se utilizan contenedores est√°ndar. </font><font style="vertical-align: inherit;">Estoy de acuerdo en que habr√° muchas asignaciones del mont√≥n. </font><font style="vertical-align: inherit;">Creo que para aquellos que escribir√°n sus asignadores, esto ser√° inaceptable. </font><font style="vertical-align: inherit;">Como alternativa, por supuesto, puede escribir sus propios contenedores o usar los de otra persona, afilados para ciertas necesidades, pero en esta implementaci√≥n trat√© de presentar el material lo m√°s f√°cilmente posible, por lo que mi elecci√≥n recay√≥ en contenedores est√°ndar.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora un poco sobre c√≥mo puede decorar el uso de asignadores junto con contenedores est√°ndar: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n puede usar asignadores con punteros inteligentes, pero para esto tendr√° que escribir una peque√±a capa: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno y ahora, finalmente, un ejemplo de uso de todo esto:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me gustar√≠a centrarme en el hecho de que esta implementaci√≥n es la m√°s primitiva, pero se puede ampliar f√°cilmente en la direcci√≥n que necesite, ¬°para que todo est√© en sus manos!</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias por su atenci√≥n, realmente espero que este art√≠culo sea √∫til para alguien. </font><font style="vertical-align: inherit;">Tambi√©n deseo que todos tengan √©xito en su estrecha interacci√≥n con la memoria, y lo m√°s importante, no olviden las palabras muy importantes de Donald Knuth: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La optimizaci√≥n prematura es la ra√≠z de todos los males</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con la implementaci√≥n completa del asignador.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuentes utilizadas</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es505614/index.html">Las tasas de dep√≥sito de los bancos m√°s grandes cayeron a un m√≠nimo hist√≥rico: ¬øc√≥mo afecta esto a la econom√≠a, y d√≥nde cambia</a></li>
<li><a href="../es505616/index.html">Reconocimiento del alfabeto ruso: desde recopilar un conjunto de datos hasta crear una GUI</a></li>
<li><a href="../es505618/index.html">Plantillas GRASP: Creador</a></li>
<li><a href="../es505620/index.html">HackTheBox. Tutorial Nido. NTFS streams, C # inverso y SMB walker</a></li>
<li><a href="../es505624/index.html">¬øC√≥mo procesar un marco de datos con miles de millones de registros en segundos?</a></li>
<li><a href="../es505634/index.html">Configuraci√≥n de proxy para WSL (Ubuntu)</a></li>
<li><a href="../es505640/index.html">Publicaci√≥n Calificaci√≥n Objetividad</a></li>
<li><a href="../es505642/index.html">Corutinas transparentes</a></li>
<li><a href="../es505644/index.html">Los titulares de los derechos de autor lo intentaron: las lecciones de videos musicales de YouTube con el an√°lisis de las canciones de otras personas pueden desaparecer</a></li>
<li><a href="../es505648/index.html">Los dos errores de Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>