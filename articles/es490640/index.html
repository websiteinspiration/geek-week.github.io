<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈 💷 👆🏻 Sobrecarga en C ++. Parte III Sobrecarga de declaraciones nuevas / eliminar 👨🏼‍💻 🍞 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos la serie "C ++, cavando en profundidad". El propósito de esta serie es informar lo más posible sobre las diversas características del leng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sobrecarga en C ++. Parte III Sobrecarga de declaraciones nuevas / eliminar</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos la serie "C ++, cavando en profundidad". </font><font style="vertical-align: inherit;">El propósito de esta serie es informar lo más posible sobre las diversas características del lenguaje, posiblemente bastante especial. </font><font style="vertical-align: inherit;">Este artículo trata sobre la sobrecarga del operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es el tercer artículo de la serie, el primero dedicado a las funciones y plantillas de sobrecarga, ubicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el segundo dedicado a los operadores de sobrecarga, ubicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este artículo concluye una serie de tres artículos sobre sobrecarga en C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabla de contenido</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabla de contenido</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Formas estándar de operadores nuevos / eliminados</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ admite varias opciones de operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se pueden dividir en estándar básico, estándar adicional y personalizado. </font><font style="vertical-align: inherit;">Esta sección y la sección 2 analizan los formularios estándar; los formularios personalizados se analizarán en la sección 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Formularios estándar básicos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las principales formas estándar de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizadas al crear y eliminar un objeto y una matriz del tipo son las </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguientes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Su trabajo se puede describir de la siguiente manera. Cuando se llama al operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la memoria se asigna primero al objeto. Si la selección es exitosa, se llama al constructor. Si el constructor produce una excepción, la memoria asignada se libera. Cuando se llama al operador, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo sucede en el orden inverso: primero, se llama al destructor, luego se libera la memoria. El destructor no debe lanzar excepciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el operador</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizado para crear una matriz de objetos, la memoria se asigna primero para toda la matriz. Si la selección es exitosa, se llama al constructor predeterminado (u otro constructor, si hay un inicializador) para cada elemento de la matriz comenzando desde cero. Si algún constructor arroja una excepción, entonces, para todos los elementos creados de la matriz, se llama al destructor en el orden inverso de la llamada del constructor, luego se libera la memoria asignada. Para eliminar una matriz, debe llamar al operador </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y para todos los elementos de la matriz, se llama al destructor en el orden inverso del constructor, luego se libera la memoria asignada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Atención! Es necesario llamar a la forma correcta del operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependiendo de si se elimina un solo objeto o una matriz. Esta regla debe observarse estrictamente, de lo contrario, puede obtener un comportamiento indefinido, es decir, puede suceder cualquier cosa: pérdidas de memoria, bloqueo, etc. Ver [Meyers1] para más detalles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la descripción anterior, es necesaria una aclaración. Para los llamados tipos triviales (tipos incorporados, estructuras de estilo C), el constructor predeterminado puede no ser llamado, y el destructor no hace nada en ningún caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de asignación de memoria estándar, cuando no es posible satisfacer la solicitud, lanzan una excepción de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero esta excepción puede ser detectada, para esto necesita instalar un interceptor global usando una llamada de función </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para más detalles vea [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cualquier forma de operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplicar de forma segura al puntero nulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear una matriz con un operador, el </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamaño se puede establecer en cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas formas del operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permiten el uso de inicializadores en llaves.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Formularios estándar adicionales</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al conectar el archivo de encabezado </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, quedan disponibles 4 formularios de operador estándar más </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros dos de ellos se denominan </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocación no asignada </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Un argumento </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un puntero a una región de memoria que es lo suficientemente grande como para contener una instancia o matriz. Además, el área de memoria debe tener una alineación adecuada. Esta versión del operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no asigna memoria; solo proporciona una llamada al constructor. Por lo tanto, esta opción le permite separar las fases de asignación de memoria e inicialización de objetos. Esta característica se usa activamente en contenedores estándar. Por </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supuesto, no se puede llamar al </font><font style="vertical-align: inherit;">operador </font><font style="vertical-align: inherit;">para los objetos creados de esta manera. Para eliminar un objeto, debe llamar directamente al destructor y luego liberar la memoria de una manera que dependa del método de asignación de memoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las dos </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">últimas </font><font style="vertical-align: inherit;">opciones se denominan el operador que no lanza excepciones </font><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y difieren en que si es imposible satisfacer la solicitud, regresan </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero no lanzan una excepción de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La eliminación de un objeto ocurre usando el operador principal </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estas opciones se consideran obsoletas y no se recomiendan para su uso.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Asignación de memoria y funciones libres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las formas estándar de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizan las siguientes funciones de asignación y desasignación:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones se definen en el espacio de nombres global. </font><font style="vertical-align: inherit;">Las funciones de asignación de memoria para las declaraciones de host </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hacen nada y simplemente regresan </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 admite formas adicionales de asignación de memoria y funciones de desasignación, lo que indica la alineación. </font><font style="vertical-align: inherit;">Éstos son algunos de ellos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos formularios no son directamente accesibles para el usuario, son utilizados por el compilador para objetos cuyos requisitos de alineación son superiores </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que el problema principal es que el usuario no los oculta accidentalmente (ver sección 2.2.1). </font><font style="vertical-align: inherit;">Recuerde que en C ++ 11 se hizo posible establecer explícitamente la alineación de los tipos de usuario.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Sobrecargar las formas estándar de operadores nuevos / eliminar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sobrecarga de las formas estándar de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consiste en definir funciones definidas por el usuario para asignar y liberar memoria cuyas firmas coinciden con las estándar. </font><font style="vertical-align: inherit;">Estas funciones se pueden definir en el espacio de nombres global o en una clase, pero no en un espacio de nombres que no sea global. </font><font style="vertical-align: inherit;">La función de asignación de memoria para una declaración de host estándar </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se puede definir en el espacio de nombres global. </font><font style="vertical-align: inherit;">Después de tal definición, los operadores correspondientes los </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usarán, no los estándares.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Sobrecarga en el espacio de nombres global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos, por ejemplo, en un módulo en un espacio de nombres global que se definen funciones definidas por el usuario:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, en realidad habrá un reemplazo (reemplazo) de las funciones estándar para asignar y liberar memoria para todas las llamadas del operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para cualquier clase (incluidas las estándar) en todo el módulo. Esto puede conducir al caos completo. Tenga en cuenta que el mecanismo de sustitución descrito es un mecanismo especial implementado solo para este caso, y no un mecanismo general de C ++. En este caso, cuando se implementan las funciones del usuario para asignar y liberar memoria, se hace imposible llamar a las funciones estándar correspondientes, están completamente ocultas (el operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no ayuda), y cuando intenta llamarlas, se produce una llamada recursiva a la función del usuario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Función definida de espacio de nombres global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También reemplazará al estándar, pero habrá menos problemas potenciales, porque el operador que no arroja excepciones </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rara vez se usa. </font><font style="vertical-align: inherit;">Pero el formulario estándar tampoco está disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La misma situación con funciones para matrices. </font><font style="vertical-align: inherit;">Se desaconseja encarecidamente las </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
declaraciones de sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el espacio de nombres global.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Sobrecarga de clase</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sobrecarga de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en una clase carece de las desventajas descritas anteriormente. </font><font style="vertical-align: inherit;">La sobrecarga solo es efectiva al crear y eliminar instancias de la clase correspondiente, independientemente del contexto de invocación de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al implementar funciones definidas por el usuario para asignar y liberar memoria utilizando el operador, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede acceder a las funciones estándar correspondientes. </font><font style="vertical-align: inherit;">Considera un ejemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, el seguimiento simplemente se agrega a las operaciones estándar. </font><font style="vertical-align: inherit;">Ahora, en términos </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizará estas funciones para asignar y liberar memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones son formalmente estáticas y se pueden declarar como </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero esencialmente son instancias, con la llamada a la función </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comienza la creación de la instancia y la llamada de la función </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completa su eliminación. </font><font style="vertical-align: inherit;">Estas funciones nunca se requieren para otras tareas. </font><font style="vertical-align: inherit;">Además, como se mostrará a continuación, la función </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es esencialmente virtual. </font><font style="vertical-align: inherit;">Por lo tanto, es más correcto declararlos sin ellos </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Acceso a formas estándar de operadores nuevos / eliminados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se pueden usar con un operador de resolución de alcance adicional, por ejemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En este caso, la función </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definida en la clase se ignorará y se utilizará el estándar correspondiente. </font><font style="vertical-align: inherit;">Del mismo modo, puede usar el operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Ocultar otras formas de operadores nuevos / eliminar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ahora para la clase </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intentamos usar lanzar o no lanzar excepciones </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obtenemos un error. </font><font style="vertical-align: inherit;">El hecho es que la función </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocultará otras formas </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El problema se puede resolver de dos maneras. </font><font style="vertical-align: inherit;">En el primero, debe agregar las opciones apropiadas a la clase (estas opciones simplemente deben delegar el funcionamiento de la función estándar). </font><font style="vertical-align: inherit;">En el segundo, debe utilizar un operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un operador de resolución de alcance, por ejemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Contenedores estándar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si intentamos colocar las instancias </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en algún contenedor estándar, por ejemplo </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, veremos que nuestras funciones no se utilizan para asignar y liberar memoria. </font><font style="vertical-align: inherit;">El hecho es que todos los contenedores estándar tienen su propio mecanismo para asignar y liberar memoria (una clase especial de asignador, que es un parámetro de plantilla del contenedor), y utilizan un operador de colocación para inicializar los elementos </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Herencia</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se heredan las funciones para asignar y liberar memoria. Si estas funciones se definen en la clase base, pero no en la derivada, los operadores se sobrecargarán para la clase derivada </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y las funciones definidas y asignadas en la clase base se utilizarán para asignar y liberar memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora considere una jerarquía de clases polimórficas, donde cada clase sobrecarga a los operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ahora, deje que la instancia de la clase derivada se elimine utilizando el operador a </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">través de un puntero a la clase base. Si el destructor de la clase base es virtual, entonces el estándar garantiza que se llama al destructor de esta clase derivada. En este caso </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la </font><font style="vertical-align: inherit;">llamada a </font><font style="vertical-align: inherit;">la </font><font style="vertical-align: inherit;">función </font><font style="vertical-align: inherit;">definida para esta clase derivada </font><font style="vertical-align: inherit;">también está garantizada </font><font style="vertical-align: inherit;">. Por lo tanto, la función es </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente virtual.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Forma alternativa de la función delete () del operador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una clase (especialmente cuando se usa la herencia), a veces es conveniente usar una forma alternativa de la función para liberar memoria:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El parámetro </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establece el tamaño del elemento (incluso en la versión de la matriz). </font><font style="vertical-align: inherit;">Este formulario le permite usar diferentes funciones para asignar y liberar memoria, dependiendo de la clase derivada específica.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Operadores de usuario nuevos / eliminar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ puede admitir formas de operador personalizadas de la </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente forma:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que estos formularios sean compatibles, es necesario determinar las funciones apropiadas para asignar y liberar memoria:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lista de parámetros adicionales de las funciones de asignación de memoria no debe estar vacía y no debe consistir en una </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, su firma no debe coincidir con una de las estándar. Listas de parámetros adicionales en </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben coincidir. Los argumentos pasados ​​al operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben corresponder a parámetros adicionales de las funciones de asignación de memoria. Una función personalizada </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también puede tener el formato con un parámetro de tamaño opcional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones se pueden definir en el espacio de nombres global o en una clase, pero no en un espacio de nombres que no sea global. Si se definen en el espacio de nombres global, no reemplazan, sino que sobrecargan, las funciones estándar de asignación y liberación de memoria, por lo que su uso es predecible y seguro, y las funciones estándar siempre están disponibles. Si se definen en la clase, ocultan los formularios estándar, pero se puede obtener acceso a los formularios estándar utilizando el operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esto se describe en detalle en la sección 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los </font><font style="vertical-align: inherit;">formularios de </font><font style="vertical-align: inherit;">operador </font><font style="vertical-align: inherit;">definidos por el usuario </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se denominan </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ubicación definida por el usuario </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No deben confundirse con el operador de colocación estándar (sin asignación) </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descrito en la sección 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El formulario de operador correspondiente </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no existe. </font><font style="vertical-align: inherit;">Hay </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos formas de </font><font style="vertical-align: inherit;">eliminar un objeto creado utilizando un operador definido por el usuario </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si una función definida por el usuario </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delega una operación de asignación de memoria a funciones de asignación de memoria estándar, entonces se puede usar un operador estándar </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De lo contrario, deberá llamar explícitamente al destructor y luego a la función definida por el usuario </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El compilador llama a la función definida por el usuario en </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un solo caso: cuando el </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constructor lanza una excepción </font><font style="vertical-align: inherit;">durante la operación del operador definido por el usuario </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un ejemplo (en alcance global).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definición de funciones de asignación de memoria.</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En estos ejemplos, las funciones de usuario </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operación delegada correspondiente a las funciones estándar. A veces, esta opción es útil, pero el objetivo principal de la sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es crear un nuevo mecanismo para asignar / liberar memoria. La tarea no es simple, y antes de emprenderla, uno debe pensar cuidadosamente en todo. Scott Meyers [Meyers1] analiza los posibles motivos para tomar tal decisión (por supuesto, el principal es la eficiencia). También analiza los principales problemas técnicos asociados con la implementación correcta de las funciones definidas por el usuario para asignar y liberar memoria (utilizando la función</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sincronización multiproceso, alineación). </font><font style="vertical-align: inherit;">Guntheroth proporciona un ejemplo de la implementación de funciones relativamente simples de asignación de memoria y desasignación definidas por el usuario. </font><font style="vertical-align: inherit;">Antes de crear su propia versión, debe buscar soluciones ya preparadas, por ejemplo, puede traer la biblioteca Pool del proyecto Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Clases de asignación de contenedores estándar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se mencionó anteriormente, los contenedores estándar utilizan clases especiales de asignación para asignar y liberar memoria. </font><font style="vertical-align: inherit;">Estas clases son parámetros de plantilla de contenedores y el usuario puede definir su versión de dicha clase. </font><font style="vertical-align: inherit;">Los motivos para tal solución son aproximadamente los mismos que para los operadores de sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] describe cómo crear tales clases.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliografía</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimización de programas en C ++. </font><font style="vertical-align: inherit;">Métodos probados para aumentar la productividad.: Por. </font><font style="vertical-align: inherit;">De inglés </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Uso efectivo de C ++. </font><font style="vertical-align: inherit;">55 formas seguras de mejorar la estructura y el código de sus programas.: Per. </font><font style="vertical-align: inherit;">De inglés </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490626/index.html">Una guía completa de datos- * atributos HTML</a></li>
<li><a href="../es490628/index.html">¿Qué hacer cuando CSS bloquea el análisis de páginas?</a></li>
<li><a href="../es490630/index.html">Carga de matrices NumPy desde disco: comparación de memmap () y Zarr / HDF5</a></li>
<li><a href="../es490634/index.html">Eventos digitales en Moscú del 2 al 8 de marzo.</a></li>
<li><a href="../es490636/index.html">Eventos digitales en San Petersburgo del 2 al 8 de marzo.</a></li>
<li><a href="../es490642/index.html">Plugin para monitorear aplicaciones K8s DevOpsProdigy KubeGraf v1.3.0: nueva versión y nuevas características</a></li>
<li><a href="../es490644/index.html">Repositorio rpm simple usando Inotify y webdav</a></li>
<li><a href="../es490648/index.html">Usando Kata Containers en Kubernetes</a></li>
<li><a href="../es490650/index.html">Los principales errores al compilar un CV por parte de especialistas en TI para principiantes</a></li>
<li><a href="../es490652/index.html">Logística. Introducción Casi complicado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>