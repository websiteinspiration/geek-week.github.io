<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëà üí∑ üëÜüèª Sobrecarga en C ++. Parte III Sobrecarga de declaraciones nuevas / eliminar üë®üèº‚Äçüíª üçû üë©üèø‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos la serie "C ++, cavando en profundidad". El prop√≥sito de esta serie es informar lo m√°s posible sobre las diversas caracter√≠sticas del leng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sobrecarga en C ++. Parte III Sobrecarga de declaraciones nuevas / eliminar</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos la serie "C ++, cavando en profundidad". </font><font style="vertical-align: inherit;">El prop√≥sito de esta serie es informar lo m√°s posible sobre las diversas caracter√≠sticas del lenguaje, posiblemente bastante especial. </font><font style="vertical-align: inherit;">Este art√≠culo trata sobre la sobrecarga del operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es el tercer art√≠culo de la serie, el primero dedicado a las funciones y plantillas de sobrecarga, ubicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el segundo dedicado a los operadores de sobrecarga, ubicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este art√≠culo concluye una serie de tres art√≠culos sobre sobrecarga en C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabla de contenido</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabla de contenido</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Formas est√°ndar de operadores nuevos / eliminados</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ admite varias opciones de operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se pueden dividir en est√°ndar b√°sico, est√°ndar adicional y personalizado. </font><font style="vertical-align: inherit;">Esta secci√≥n y la secci√≥n 2 analizan los formularios est√°ndar; los formularios personalizados se analizar√°n en la secci√≥n 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Formularios est√°ndar b√°sicos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las principales formas est√°ndar de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizadas al crear y eliminar un objeto y una matriz del tipo son las </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguientes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Su trabajo se puede describir de la siguiente manera. Cuando se llama al operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la memoria se asigna primero al objeto. Si la selecci√≥n es exitosa, se llama al constructor. Si el constructor produce una excepci√≥n, la memoria asignada se libera. Cuando se llama al operador, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo sucede en el orden inverso: primero, se llama al destructor, luego se libera la memoria. El destructor no debe lanzar excepciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el operador</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizado para crear una matriz de objetos, la memoria se asigna primero para toda la matriz. Si la selecci√≥n es exitosa, se llama al constructor predeterminado (u otro constructor, si hay un inicializador) para cada elemento de la matriz comenzando desde cero. Si alg√∫n constructor arroja una excepci√≥n, entonces, para todos los elementos creados de la matriz, se llama al destructor en el orden inverso de la llamada del constructor, luego se libera la memoria asignada. Para eliminar una matriz, debe llamar al operador </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y para todos los elementos de la matriz, se llama al destructor en el orden inverso del constructor, luego se libera la memoria asignada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Atenci√≥n! Es necesario llamar a la forma correcta del operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependiendo de si se elimina un solo objeto o una matriz. Esta regla debe observarse estrictamente, de lo contrario, puede obtener un comportamiento indefinido, es decir, puede suceder cualquier cosa: p√©rdidas de memoria, bloqueo, etc. Ver [Meyers1] para m√°s detalles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la descripci√≥n anterior, es necesaria una aclaraci√≥n. Para los llamados tipos triviales (tipos incorporados, estructuras de estilo C), el constructor predeterminado puede no ser llamado, y el destructor no hace nada en ning√∫n caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de asignaci√≥n de memoria est√°ndar, cuando no es posible satisfacer la solicitud, lanzan una excepci√≥n de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero esta excepci√≥n puede ser detectada, para esto necesita instalar un interceptor global usando una llamada de funci√≥n </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para m√°s detalles vea [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cualquier forma de operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplicar de forma segura al puntero nulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear una matriz con un operador, el </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tama√±o se puede establecer en cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas formas del operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permiten el uso de inicializadores en llaves.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Formularios est√°ndar adicionales</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al conectar el archivo de encabezado </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, quedan disponibles 4 formularios de operador est√°ndar m√°s </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros dos de ellos se denominan </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocaci√≥n no asignada </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Un argumento </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un puntero a una regi√≥n de memoria que es lo suficientemente grande como para contener una instancia o matriz. Adem√°s, el √°rea de memoria debe tener una alineaci√≥n adecuada. Esta versi√≥n del operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no asigna memoria; solo proporciona una llamada al constructor. Por lo tanto, esta opci√≥n le permite separar las fases de asignaci√≥n de memoria e inicializaci√≥n de objetos. Esta caracter√≠stica se usa activamente en contenedores est√°ndar. Por </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supuesto, no se puede llamar al </font><font style="vertical-align: inherit;">operador </font><font style="vertical-align: inherit;">para los objetos creados de esta manera. Para eliminar un objeto, debe llamar directamente al destructor y luego liberar la memoria de una manera que dependa del m√©todo de asignaci√≥n de memoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las dos </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∫ltimas </font><font style="vertical-align: inherit;">opciones se denominan el operador que no lanza excepciones </font><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y difieren en que si es imposible satisfacer la solicitud, regresan </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero no lanzan una excepci√≥n de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La eliminaci√≥n de un objeto ocurre usando el operador principal </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estas opciones se consideran obsoletas y no se recomiendan para su uso.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Asignaci√≥n de memoria y funciones libres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las formas est√°ndar de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizan las siguientes funciones de asignaci√≥n y desasignaci√≥n:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones se definen en el espacio de nombres global. </font><font style="vertical-align: inherit;">Las funciones de asignaci√≥n de memoria para las declaraciones de host </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hacen nada y simplemente regresan </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 admite formas adicionales de asignaci√≥n de memoria y funciones de desasignaci√≥n, lo que indica la alineaci√≥n. </font><font style="vertical-align: inherit;">√âstos son algunos de ellos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos formularios no son directamente accesibles para el usuario, son utilizados por el compilador para objetos cuyos requisitos de alineaci√≥n son superiores </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que el problema principal es que el usuario no los oculta accidentalmente (ver secci√≥n 2.2.1). </font><font style="vertical-align: inherit;">Recuerde que en C ++ 11 se hizo posible establecer expl√≠citamente la alineaci√≥n de los tipos de usuario.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Sobrecargar las formas est√°ndar de operadores nuevos / eliminar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sobrecarga de las formas est√°ndar de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consiste en definir funciones definidas por el usuario para asignar y liberar memoria cuyas firmas coinciden con las est√°ndar. </font><font style="vertical-align: inherit;">Estas funciones se pueden definir en el espacio de nombres global o en una clase, pero no en un espacio de nombres que no sea global. </font><font style="vertical-align: inherit;">La funci√≥n de asignaci√≥n de memoria para una declaraci√≥n de host est√°ndar </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se puede definir en el espacio de nombres global. </font><font style="vertical-align: inherit;">Despu√©s de tal definici√≥n, los operadores correspondientes los </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar√°n, no los est√°ndares.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Sobrecarga en el espacio de nombres global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos, por ejemplo, en un m√≥dulo en un espacio de nombres global que se definen funciones definidas por el usuario:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, en realidad habr√° un reemplazo (reemplazo) de las funciones est√°ndar para asignar y liberar memoria para todas las llamadas del operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para cualquier clase (incluidas las est√°ndar) en todo el m√≥dulo. Esto puede conducir al caos completo. Tenga en cuenta que el mecanismo de sustituci√≥n descrito es un mecanismo especial implementado solo para este caso, y no un mecanismo general de C ++. En este caso, cuando se implementan las funciones del usuario para asignar y liberar memoria, se hace imposible llamar a las funciones est√°ndar correspondientes, est√°n completamente ocultas (el operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no ayuda), y cuando intenta llamarlas, se produce una llamada recursiva a la funci√≥n del usuario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funci√≥n definida de espacio de nombres global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n reemplazar√° al est√°ndar, pero habr√° menos problemas potenciales, porque el operador que no arroja excepciones </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rara vez se usa. </font><font style="vertical-align: inherit;">Pero el formulario est√°ndar tampoco est√° disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La misma situaci√≥n con funciones para matrices. </font><font style="vertical-align: inherit;">Se desaconseja encarecidamente las </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
declaraciones de sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el espacio de nombres global.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Sobrecarga de clase</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sobrecarga de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en una clase carece de las desventajas descritas anteriormente. </font><font style="vertical-align: inherit;">La sobrecarga solo es efectiva al crear y eliminar instancias de la clase correspondiente, independientemente del contexto de invocaci√≥n de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al implementar funciones definidas por el usuario para asignar y liberar memoria utilizando el operador, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede acceder a las funciones est√°ndar correspondientes. </font><font style="vertical-align: inherit;">Considera un ejemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, el seguimiento simplemente se agrega a las operaciones est√°ndar. </font><font style="vertical-align: inherit;">Ahora, en t√©rminos </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizar√° estas funciones para asignar y liberar memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones son formalmente est√°ticas y se pueden declarar como </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero esencialmente son instancias, con la llamada a la funci√≥n </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comienza la creaci√≥n de la instancia y la llamada de la funci√≥n </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completa su eliminaci√≥n. </font><font style="vertical-align: inherit;">Estas funciones nunca se requieren para otras tareas. </font><font style="vertical-align: inherit;">Adem√°s, como se mostrar√° a continuaci√≥n, la funci√≥n </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es esencialmente virtual. </font><font style="vertical-align: inherit;">Por lo tanto, es m√°s correcto declararlos sin ellos </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Acceso a formas est√°ndar de operadores nuevos / eliminados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se pueden usar con un operador de resoluci√≥n de alcance adicional, por ejemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En este caso, la funci√≥n </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definida en la clase se ignorar√° y se utilizar√° el est√°ndar correspondiente. </font><font style="vertical-align: inherit;">Del mismo modo, puede usar el operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Ocultar otras formas de operadores nuevos / eliminar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ahora para la clase </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intentamos usar lanzar o no lanzar excepciones </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obtenemos un error. </font><font style="vertical-align: inherit;">El hecho es que la funci√≥n </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocultar√° otras formas </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El problema se puede resolver de dos maneras. </font><font style="vertical-align: inherit;">En el primero, debe agregar las opciones apropiadas a la clase (estas opciones simplemente deben delegar el funcionamiento de la funci√≥n est√°ndar). </font><font style="vertical-align: inherit;">En el segundo, debe utilizar un operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un operador de resoluci√≥n de alcance, por ejemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Contenedores est√°ndar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si intentamos colocar las instancias </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en alg√∫n contenedor est√°ndar, por ejemplo </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, veremos que nuestras funciones no se utilizan para asignar y liberar memoria. </font><font style="vertical-align: inherit;">El hecho es que todos los contenedores est√°ndar tienen su propio mecanismo para asignar y liberar memoria (una clase especial de asignador, que es un par√°metro de plantilla del contenedor), y utilizan un operador de colocaci√≥n para inicializar los elementos </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Herencia</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se heredan las funciones para asignar y liberar memoria. Si estas funciones se definen en la clase base, pero no en la derivada, los operadores se sobrecargar√°n para la clase derivada </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y las funciones definidas y asignadas en la clase base se utilizar√°n para asignar y liberar memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora considere una jerarqu√≠a de clases polim√≥rficas, donde cada clase sobrecarga a los operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ahora, deje que la instancia de la clase derivada se elimine utilizando el operador a </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trav√©s de un puntero a la clase base. Si el destructor de la clase base es virtual, entonces el est√°ndar garantiza que se llama al destructor de esta clase derivada. En este caso </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la </font><font style="vertical-align: inherit;">llamada a </font><font style="vertical-align: inherit;">la </font><font style="vertical-align: inherit;">funci√≥n </font><font style="vertical-align: inherit;">definida para esta clase derivada </font><font style="vertical-align: inherit;">tambi√©n est√° garantizada </font><font style="vertical-align: inherit;">. Por lo tanto, la funci√≥n es </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente virtual.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Forma alternativa de la funci√≥n delete () del operador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una clase (especialmente cuando se usa la herencia), a veces es conveniente usar una forma alternativa de la funci√≥n para liberar memoria:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El par√°metro </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establece el tama√±o del elemento (incluso en la versi√≥n de la matriz). </font><font style="vertical-align: inherit;">Este formulario le permite usar diferentes funciones para asignar y liberar memoria, dependiendo de la clase derivada espec√≠fica.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Operadores de usuario nuevos / eliminar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ puede admitir formas de operador personalizadas de la </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente forma:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que estos formularios sean compatibles, es necesario determinar las funciones apropiadas para asignar y liberar memoria:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lista de par√°metros adicionales de las funciones de asignaci√≥n de memoria no debe estar vac√≠a y no debe consistir en una </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, su firma no debe coincidir con una de las est√°ndar. Listas de par√°metros adicionales en </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben coincidir. Los argumentos pasados ‚Äã‚Äãal operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben corresponder a par√°metros adicionales de las funciones de asignaci√≥n de memoria. Una funci√≥n personalizada </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n puede tener el formato con un par√°metro de tama√±o opcional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones se pueden definir en el espacio de nombres global o en una clase, pero no en un espacio de nombres que no sea global. Si se definen en el espacio de nombres global, no reemplazan, sino que sobrecargan, las funciones est√°ndar de asignaci√≥n y liberaci√≥n de memoria, por lo que su uso es predecible y seguro, y las funciones est√°ndar siempre est√°n disponibles. Si se definen en la clase, ocultan los formularios est√°ndar, pero se puede obtener acceso a los formularios est√°ndar utilizando el operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esto se describe en detalle en la secci√≥n 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los </font><font style="vertical-align: inherit;">formularios de </font><font style="vertical-align: inherit;">operador </font><font style="vertical-align: inherit;">definidos por el usuario </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se denominan </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ubicaci√≥n definida por el usuario </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No deben confundirse con el operador de colocaci√≥n est√°ndar (sin asignaci√≥n) </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descrito en la secci√≥n 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El formulario de operador correspondiente </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no existe. </font><font style="vertical-align: inherit;">Hay </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos formas de </font><font style="vertical-align: inherit;">eliminar un objeto creado utilizando un operador definido por el usuario </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si una funci√≥n definida por el usuario </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delega una operaci√≥n de asignaci√≥n de memoria a funciones de asignaci√≥n de memoria est√°ndar, entonces se puede usar un operador est√°ndar </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De lo contrario, deber√° llamar expl√≠citamente al destructor y luego a la funci√≥n definida por el usuario </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El compilador llama a la funci√≥n definida por el usuario en </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un solo caso: cuando el </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constructor lanza una excepci√≥n </font><font style="vertical-align: inherit;">durante la operaci√≥n del operador definido por el usuario </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ hay un ejemplo (en alcance global).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definici√≥n de funciones de asignaci√≥n de memoria.</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En estos ejemplos, las funciones de usuario </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operaci√≥n delegada correspondiente a las funciones est√°ndar. A veces, esta opci√≥n es √∫til, pero el objetivo principal de la sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es crear un nuevo mecanismo para asignar / liberar memoria. La tarea no es simple, y antes de emprenderla, uno debe pensar cuidadosamente en todo. Scott Meyers [Meyers1] analiza los posibles motivos para tomar tal decisi√≥n (por supuesto, el principal es la eficiencia). Tambi√©n analiza los principales problemas t√©cnicos asociados con la implementaci√≥n correcta de las funciones definidas por el usuario para asignar y liberar memoria (utilizando la funci√≥n</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sincronizaci√≥n multiproceso, alineaci√≥n). </font><font style="vertical-align: inherit;">Guntheroth proporciona un ejemplo de la implementaci√≥n de funciones relativamente simples de asignaci√≥n de memoria y desasignaci√≥n definidas por el usuario. </font><font style="vertical-align: inherit;">Antes de crear su propia versi√≥n, debe buscar soluciones ya preparadas, por ejemplo, puede traer la biblioteca Pool del proyecto Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Clases de asignaci√≥n de contenedores est√°ndar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se mencion√≥ anteriormente, los contenedores est√°ndar utilizan clases especiales de asignaci√≥n para asignar y liberar memoria. </font><font style="vertical-align: inherit;">Estas clases son par√°metros de plantilla de contenedores y el usuario puede definir su versi√≥n de dicha clase. </font><font style="vertical-align: inherit;">Los motivos para tal soluci√≥n son aproximadamente los mismos que para los operadores de sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] describe c√≥mo crear tales clases.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliograf√≠a</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimizaci√≥n de programas en C ++. </font><font style="vertical-align: inherit;">M√©todos probados para aumentar la productividad.: Por. </font><font style="vertical-align: inherit;">De ingl√©s </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Uso efectivo de C ++. </font><font style="vertical-align: inherit;">55 formas seguras de mejorar la estructura y el c√≥digo de sus programas.: Per. </font><font style="vertical-align: inherit;">De ingl√©s </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490626/index.html">Una gu√≠a completa de datos- * atributos HTML</a></li>
<li><a href="../es490628/index.html">¬øQu√© hacer cuando CSS bloquea el an√°lisis de p√°ginas?</a></li>
<li><a href="../es490630/index.html">Carga de matrices NumPy desde disco: comparaci√≥n de memmap () y Zarr / HDF5</a></li>
<li><a href="../es490634/index.html">Eventos digitales en Mosc√∫ del 2 al 8 de marzo.</a></li>
<li><a href="../es490636/index.html">Eventos digitales en San Petersburgo del 2 al 8 de marzo.</a></li>
<li><a href="../es490642/index.html">Plugin para monitorear aplicaciones K8s DevOpsProdigy KubeGraf v1.3.0: nueva versi√≥n y nuevas caracter√≠sticas</a></li>
<li><a href="../es490644/index.html">Repositorio rpm simple usando Inotify y webdav</a></li>
<li><a href="../es490648/index.html">Usando Kata Containers en Kubernetes</a></li>
<li><a href="../es490650/index.html">Los principales errores al compilar un CV por parte de especialistas en TI para principiantes</a></li>
<li><a href="../es490652/index.html">Log√≠stica. Introducci√≥n Casi complicado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>