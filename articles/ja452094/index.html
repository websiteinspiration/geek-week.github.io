<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆓 🎀 👩🏾‍🎨 .NET：マルチスレッドと非同期を操作するためのツール。パート1 ☮️ 🙇🏼 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私はHabrに関するオリジナルの記事を公開しています。その翻訳はCodingsightブログに投稿されています。
 2番目の部分はここから入手できます。
 
 今ここで結果を待たずに非同期で何かをしたり、それを実行している複数のユニット間で多くの作業を共有したりする必要性は、コンピュータの登場前でも...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET：マルチスレッドと非同期を操作するためのツール。パート1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452094/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はHabrに関するオリジナルの記事を公開しています。その翻訳は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codingsight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブログに投稿されてい</font><font style="vertical-align: inherit;">ます。</font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の部分は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ここから</font></a><font style="vertical-align: inherit;">入手でき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今ここで結果を待たずに非同期で何かをしたり、それを実行している複数のユニット間で多くの作業を共有したりする必要性は、コンピュータの登場前でもありました。それらの出現により、そのような必要性は非常に明白になった。さて、2019年に、100のプロセスが同時に動作するのではなく、さらに多くのスレッドを実行する、8コアのIntel Coreプロセッサーを搭載したラップトップでこの記事を入力してください。その隣には、2年前に購入したわずかにボロボロの電話があり、オンボードの8核プロセッサが搭載されています。テーマ別のリソースには、作者が16コアプロセッサを搭載した今年のフラッグシップスマートフォンを賞賛する記事やビデオが満載です。 MS Azureは、128コアプロセッサと2 TB RAMを備えた仮想マシンを1時間あたり20ドル未満で提供します。残念ながら、流れの相互作用を制御できなければ、この力を最大化して抑制することは不可能です。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用語</font></font></h3><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス（Process）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -分離されたアドレス空間であるOSオブジェクトにはスレッドが含まれます。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド（スレッド）-OS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト、実行の最小単位、プロセスの一部、スレッドは、プロセス内のスレッド間でメモリやその他のリソースを共有します。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチタスク</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はOSのプロパティであり、複数のプロセスを同時に実行する機能です。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコア</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はプロセッサのプロパティであり、複数のコアをデータ処理に使用する機能です。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチプロセッシング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はコンピュータのプロパティであり、複数のプロセッサを物理的に同時に</font><font style="vertical-align: inherit;">処理する機能</font><font style="vertical-align: inherit;">です。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はプロセスのプロパティであり、データ処理を複数のスレッドに分散する機能です。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列処理</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ユニットごとに物理的に同時に複数のアクションを</font><font style="vertical-align: inherit;">実行します- </font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -この処理の完了を待たずに操作を実行すると、実行結果を後で処理できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比喩</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての定義が適切であるとは限らず、一部には追加の説明が必要なので、正式に導入された用語に朝食を調理するためのメタファーを追加します。この比喩で朝食を調理することはプロセスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
朝の朝食の調理私（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）がキッチン（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピュータ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">やってき</font><font style="vertical-align: inherit;">ます。私は2つの手（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コア</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を持ってい</font><font style="vertical-align: inherit;">ます。キッチンには、</font><font style="vertical-align: inherit;">オーブン、やかん、トースター、冷蔵庫などの</font><font style="vertical-align: inherit;">さまざまなデバイス（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が</font><font style="vertical-align: inherit;">あります</font><font style="vertical-align: inherit;">。ガスを入れ、フライパンをのせ、そこに油を注ぎます。暖まるまで待ちません（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期、Non-Blocking-IO-Wait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。冷蔵庫から卵を取り出してプレートに入れ、片手で叩きます（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド＃1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、2番目（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド＃2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）私はプレート（共有リソース）を保持します。今でもやかんをオンにしますが、手が足りません（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread Starvation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）この間、フライパンは加熱され（結果を処理しています）、ホイップしたものを注ぎます。私はやかんに手を伸ばして電源を入れ、その中の水が沸騰する様子を愚かに観察します（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocking-IO-Wait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が、この間にオムレツをたたく皿を洗うことができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両手だけでオムレツを調理しましたが、それ以上はありませんが、同時に、オムレツを泡立てる瞬間に3つの操作が行われました：オムレツを泡立てる、皿を握る、フライパンを加熱する。多くの場合、効果的な解決策は、IOからデータを受信して​​いるときにCPUを使用することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比喩を続ける：</font></font><br>
<br>
<ul>
<li>     ,           .  :         .</li>
<li>   ,    —  .</li>
<li>       — </li>
</ul><br>
<h3> .NET</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の多くのものと同様に、スレッドの操作では、.NETが適しています。</font><font style="vertical-align: inherit;">新しいバージョンごとに、彼はそれらを操作するための新しいツール、OSスレッドの抽象化の新しいレイヤーをますます提供しています。</font><font style="vertical-align: inherit;">フレームワーク開発者は、抽象化の構築に取り組む際に、高レベルの抽象化を使用するときに可能性を残すアプローチを使用します。これは、1つまたは複数のレベル下に下がります。</font><font style="vertical-align: inherit;">ほとんどの場合、これは必要ありません。さらに、ショットガンが足で撃たれる可能性が開かれますが、まれに、これが現在の抽象化レベルでは解決しない問題を解決する唯一の方法である場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツールとは、フレームワークとサードパーティパッケージによって提供されるプログラムインターフェイス（API）の両方と、マルチスレッドコードに関連する問題の検索を簡略化するソフトウェアソリューション全体のことです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム開始</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETでスレッドを操作するための最も基本的なThreadクラス。</font><font style="vertical-align: inherit;">コンストラクターは、次の2つのデリゲートのいずれかを受け入れます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadStart-パラメータなし</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParametrizedThreadStart-タイプオブジェクトの1つのパラメーター。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デリゲートは、Startメソッドを呼び出した後に新しく作成されたスレッドで実行されます。ParametrizedThreadStart型のデリゲートがコンストラクターに渡された場合、オブジェクトをStartメソッドに渡す必要があります。</font><font style="vertical-align: inherit;">このメカニズムは、ローカル情報をストリームに転送するために必要です。</font><font style="vertical-align: inherit;">スレッドの作成は負荷の高い操作であり、少なくとも1MBのメモリがスタックに割り当てられており、OS APIとの対話が必要なため、スレッド自体は重いオブジェクトであることに注意してください。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Thread(...).Start(...);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ThreadPoolクラスは、プールの概念を表します。 .NETでは、スレッドプールはエンジニアリングの仕事であり、Microsoft開発者は、さまざまなシナリオで最適に機能するように多大な努力を払ってきました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な概念：</font></font></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初から、バックグラウンドのアプリケーションは複数のスレッドを予約して作成し、それらを使用する機会を提供します。スレッドが頻繁かつ大量に使用される場合、呼び出しコードのニーズを満たすためにプールが拡張されます。適切なタイミングでプールに空きフローがない場合、フローの1つが戻るのを待つか、新しいフローを作成します。したがって、スレッドプールはいくつかの短いアクションには最適であり、アプリケーション全体でサービスとして動作する操作にはあまり適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プールからスレッドを使用するには、WaitCallbackタイプのデリゲートを受け入れるQueueUserWorkItemメソッドがあり、これはParametrizedThreadStartと同じシグネチャであり、それに渡されるパラメーターは同じ機能を実行します。</font></font></i><br>
<br>
<pre><code class="cs hljs">ThreadPool.QueueUserWorkItem(...);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あまり知られていないスレッドプールメソッドRegisterWaitForSingleObjectを使用して、非ブロッキングIO操作を整理します。</font><font style="vertical-align: inherit;">このメソッドに渡されたデリゲートは、メソッドに渡されたWaitHandleが「Released」になると呼び出されます。</font></font><br>
<br>
<pre><code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETにはストリームタイマーがあり、そのハンドラーがプールから取得したストリームで呼び出されるという点でWinForms / WPFタイマーとは異なります。</font></font><br>
<br>
<pre><code class="cs hljs">System.Threading.Timer
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デリゲートを実行のためにプールからストリームに送信するかなりエキゾチックな方法、BeginInvokeメソッドもあります。</font></font><br>
<br>
<pre><code class="cs hljs">DelegateInstance.BeginInvoke
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、上記のメソッドの多くであるKernel32.dll Win32 APIからのCreateThreadに要約される呼び出しの関数について簡単に説明します。</font><font style="vertical-align: inherit;">externメソッドのメカニズムのおかげで、この関数を呼び出す方法があります。</font><font style="vertical-align: inherit;">レガシーコードの恐ろしい例でこのような課題を一度だけ見ました。それを行うための作者のモチベーションはまだ謎です。</font></font><br>
<br>
<pre><code class="cs hljs">Kernel32.dll CreateThread
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの表示とデバッグ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのサードパーティコンポーネントおよび.NETプールによって個人的に作成したスレッドは、[スレッド] Visual Studioウィンドウで表示できます。</font><font style="vertical-align: inherit;">このウィンドウには、アプリケーションがデバッグ中で、ブレークモード（ブレークモード）の場合にのみ、フローに関する情報が表示されます。</font><font style="vertical-align: inherit;">ここでは、各スレッドのスタック名と優先順位を簡単に表示し、デバッグを特定のスレッドに切り替えることができます。</font><font style="vertical-align: inherit;">ThreadクラスのPriorityプロパティを使用すると、スレッドの優先度を設定できます。OCとCLRは、スレッド間でCPU時間を分割する際の推奨事項として認識します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク並列ライブラリ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク並列ライブラリ（TPL）は.NET 4.0で登場しました。</font><font style="vertical-align: inherit;">現在は、非同期を処理するための標準で主要なツールです。</font><font style="vertical-align: inherit;">古いアプローチを使用するコードはすべてレガシーと見なされます。</font><font style="vertical-align: inherit;">TPLの基本単位は、System.Threading.Tasks名前空間のTaskクラスです。</font><font style="vertical-align: inherit;">タスクはスレッドを抽象化したものです。</font><font style="vertical-align: inherit;">新しいバージョンのC＃を使用すると、タスクを操作するエレガントな方法が得られました-非同期/待機オペレーター。</font><font style="vertical-align: inherit;">これらの概念により、非同期コードを単純で同期のように書くことができました。これにより、スレッドの内部キッチンをほとんど理解していない人でも、それらを使用するアプリケーション、つまり長時間の操作中にハングしないアプリケーションを書くことが可能になりました。</font><font style="vertical-align: inherit;">async / awaitの使用は、1つまたは複数の記事のトピックですが、いくつかの文の要点を取得しようとします。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncはTaskまたはvoidを返すメソッドの修飾子です</font></font></li>
<li> await    Task`.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度：awaitオペレーターは、一般的なケース（例外があります）で現在の実行スレッドをさらに解放し、タスクがその実行を終了すると、スレッド（実際にはコンテキストを言う方が適切ですが、後で詳しく説明します）は自由にメソッドを続行できます。 .NET内では、このメカニズムは、記述されたメソッドがクラス全体（ステートマシン）になり、これらの状態に応じて個別に実行できる場合に、yield returnと同じ方法で実装されます。興味のある方は、asyn/ awaitを使用して簡単なコードを記述し、JetBrains dotPeekとコンパイラ生成コードを有効にしてアセンブリをコンパイルおよび表示できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクを起動して使用するためのオプションを検討してください。以下のサンプルコードを使用して、何もしない新しいタスクを作成します（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread.Sleep（10000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ですが、実際には、CPUに関連するある種の複雑な作業になるはずです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> TCO = System.Threading.Tasks.TaskCreationOptions;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VoidAsyncMethod</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">var</span> cancellationSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(
        <span class="hljs-comment">// Code of action will be executed on other context</span>
        () =&gt; Thread.Sleep(<span class="hljs-number">10000</span>),<font></font>
        cancellationSource.Token,<font></font>
        TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness,<font></font>
        scheduler<font></font>
    );<font></font>
<font></font>
    <span class="hljs-comment">//  Code after await will be executed on captured context</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクはいくつかのオプションで作成されます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LongRunningは、タスクがすぐに完了しないというヒントです。つまり、プールからスレッドを取得せず、他のユーザーに害を与えないように、このタスク用に別のスレッドを作成することを検討する価値があるかもしれません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AttachedToParent-Taskは階層に配置できます。</font><font style="vertical-align: inherit;">このオプションが使用されている場合、タスクはそれ自体が完了し、子の完了を待機している状態になる可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreferFairness-後で送信されるタスクの前に、実行のために先に送信されたタスクを完了するとよいでしょう。</font><font style="vertical-align: inherit;">しかし、これは単なる推奨であり、結果は保証されません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの2番目のパラメーターがCancellationTokenを渡しました。起動後の操作のキャンセルを正しく処理するには、実行されたコードにCancellationTokenのステータスチェックを入力する必要があります。チェックがない場合、CancellationTokenSourceオブジェクトで呼び出されるCancelメソッドは、タスクが開始する前にのみタスクの実行を停止できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のパラメーターは、TaskSchedulerタイプのスケジューラーオブジェクトを渡しました。このクラスとその子孫は、スレッドごとにTask'ovを配布する方法を制御するように設計されています。デフォルトでは、Taskはプールからランダムなスレッドで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
awaitオペレーターは、作成されたTaskに適用されます。つまり、タスクの後に記述されたコードは、待機前のコードと同じコンテキスト（多くの場合、同じスレッド上にある）で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドはasync voidとしてマークされています。つまり、メソッド内でawait演算子を使用することはできますが、呼び出し元のコードは実行を待機できません。これが必要な場合、メソッドはTaskを返す必要があります。 async voidとマークされたメソッドは非常に一般的です：原則として、これらはイベントハンドラーや、ファイアアンドフォーゲットの原理で機能する他のメソッドです。実行の完了まで待機する機会を与えるだけでなく、結果も返す必要がある場合は、Taskを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、他の場合と同様に、StartNewメソッドが返したタスクでは、falseパラメーターを指定してConfigureAwaitメソッドを呼び出すことができます。その後、待機後の実行は、キャプチャされたコンテキストではなく、任意のコンテキストで続行されます。待機後のコードで実行コンテキストが重要でない場合は、常にこれを行う必要があります。これは、ライブラリ形式でパッケージ化されるコードを作成する際のMSからの推奨事項でもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが完了するまで待つ方法についてもう少し詳しく見てみましょう。以下は、コメント付きのサンプルコードで、待機が条件付きで良好な場合と条件付きで不良の場合です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnotherMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
    <span class="hljs-keyword">int</span> result = <span class="hljs-keyword">await</span> AsyncMethod(); <span class="hljs-comment">// good</span><font></font>
<font></font>
    result = AsyncMethod().Result; <span class="hljs-comment">// bad</span><font></font>
<font></font>
    AsyncMethod().Wait(); <span class="hljs-comment">// bad</span><font></font>
<font></font>
    IEnumerable&lt;Task&gt; tasks = <span class="hljs-keyword">new</span> Task[] {<font></font>
        AsyncMethod(), OtherAsyncMethod()<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.WhenAll(tasks); <span class="hljs-comment">// good</span>
    <span class="hljs-keyword">await</span> Task.WhenAny(tasks); <span class="hljs-comment">// good</span><font></font>
<font></font>
    Task.WaitAll(tasks.ToArray()); <span class="hljs-comment">// bad</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の例では、タスクが完了するのを待機し、呼び出しスレッドをブロックしません。呼び出しスレッドが自分に任されるまで、結果がすでに存在する場合にのみ結果の処理に戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のバリアントでは、メソッドの結果が計算されるまで呼び出しスレッドをブロックします。これは、プログラムの貴重なリソースであるスレッドを単純なアイドル状態で取得しただけでなく、呼び出すメソッドコードが待機していて、同期コンテキストが待機後に呼び出しスレッドに戻る場合、デッドロックが発生するため、これは悪いことです。 ：呼び出しスレッドは、非同期メソッドの結果が計算されるまで待機します。非同期メソッドは、呼び出しスレッドでの実行を継続しようとしても無駄になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチのもう1つの欠点は、複雑なエラー処理です。事実は、async / awaitを使用するときの非同期コードのエラーは非常に扱いやすいことです。コードは同期であるかのように動作します。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪魔払い</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を適用すると</font><font style="vertical-align: inherit;">、Task'eの同期の期待は元の例外からAggregateExceptionに変わります。例外を処理するには、InnerException型を調べて、1つのcatchブロック内にifチェーンを書き込むか、C＃のより一般的なcatchブロックチェーンの代わりにcatch when構成を使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目と最後の例も同じ理由で不良とマークされ、すべて同じ問題が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WhenAnyおよびWhenAllメソッドは、Task'ovのグループを待機するときに非常に便利です。それらは、Task'ovのグループを1つにラップします。これは、グループからのTask'aの最初の操作時、または全員が実行を終了したときに機能します。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フローストップ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな理由により、開始後にストリームを停止する必要がある場合があります。これを行うにはいくつかの方法があります。 Threadクラスには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abort</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptという</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切な名前の2つのメソッドがあります</font><font style="vertical-align: inherit;">。最初のものは使用をお勧めしません。任意の時点で呼び出された後、任意の命令の処理中に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadAbortedException</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がスローされ</font><font style="vertical-align: inherit;">ます。整数変数をインクリメントするときに、そのような例外がクラッシュするとは思わないでしょう？この方法を使用する場合、これは非常に現実的な状況です。 CLRがコードの特定のセクションでそのような例外をスローしないようにする必要がある場合は、それを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread.BeginCriticalRegion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への呼び出しでラップできます</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread.EndCriticalRegion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このような呼び出しは、finallyブロックに記述されたすべてのコードをラップします。このため、フレームワークコードの腸では、tryが空のブロックを見つけることができますが、最終的には空ではありません。マイクロソフトでは、.netコアに含まれていなかったため、この方法の使用を推奨していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interruptメソッドは、より予測どおりに機能します。</font><font style="vertical-align: inherit;">スレッドがアイドル状態の場合にのみ</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadInterruptedExceptionを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除いてスレッドを中断でき</font><font style="vertical-align: inherit;">ます。この状態では、WaitHandle、ロックを待機している間、またはThread.Sleepを呼び出した後、中断状態になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のオプションはどちらも、予測不能であるため悪いです。解決策は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体</font><font style="vertical-align: inherit;">と</font><b><font style="vertical-align: inherit;">CancellationTokenSource</font></b><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">を使用すること</font><font style="vertical-align: inherit;">です。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、CancellationTokenSourceクラスのインスタンスが作成され、それを所有する人だけが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを呼び出して操作を停止でき</font><font style="vertical-align: inherit;">ます。 CancellationTokenのみがオペレーション自体に渡されます。 CancellationTokenの所有者は、自分で操作をキャンセルすることはできませんが、操作がキャンセルされたかどうかのみを確認できます。これを行うには、ブール型プロパティ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCancellationRequested</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThrowIfCancelRequested</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドがあり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">CancellationTokenSourceのキャンセルされたCancellationTokenインスタンスでCancelメソッドが呼び出されると、</font><font style="vertical-align: inherit;">後者は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCancelledException</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をスローし</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。そして、私が使用することをお勧めするのはこの方法です。これは、例外操作を中断できるポイントを完全に制御できるため、以前のオプションよりも優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドを停止する最も残酷なオプションは、Win32 APIのTerminateThread関数を呼び出すことです。</font><font style="vertical-align: inherit;">この関数を呼び出した後のCLRの動作は予測できない場合があります。</font><font style="vertical-align: inherit;">MSDNでは、この関数について次のように書かれています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「TerminateThreadは、最も極端な場合にのみ使用するべき危険な関数です。</font><font style="vertical-align: inherit;">「</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FromAsyncメソッドを使用してレガシーAPIをタスクベースに変換する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが導入された後に開始され、ほとんどの開発者に静かな恐怖を引き起こさなくなったプロジェクトに取り組むことができて幸運だった場合、サードパーティとチームの両方が過去に拷問を受けた多くの古いAPIに対処する必要はありません。幸い、.NET Framework開発チームが私たちの面倒を見てくれましたが、おそらく目標は私たち自身の面倒を見ることでした。とはいえ、.NETには、古い非同期プログラミングアプローチで記述されたコードを簡単に新しいものに変換するための多数のツールがあります。それらの1つはTaskFactoryのFromAsyncメソッドです。以下のコード例を使用して、WebRequestクラスの古い非同期メソッドを、このメソッドを使用してTaskにラップします。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> state = <span class="hljs-literal">null</span>;<font></font>
WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string">"http://github.com"</span>);
<span class="hljs-keyword">await</span> Task.Factory.FromAsync(<font></font>
    wr.BeginGetResponse,<font></font>
    we.EndGetResponse<font></font>
);<font></font>
</code></pre><br>
<i>            ,        BeginDoSomething  IAsyncResult   EndDoSomething  .</i><br>
<br>
<h4> legacy-API  Task Based    TaskCompletionSource</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考慮すべきもう1つの重要なツールは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">です。関数、目的、動作原理の観点からは、先ほど書いたThreadPoolクラスのRegisterWaitForSingleObjectメソッドを思い出させるかもしれません。このクラスを使用すると、古い非同期APIをTaskで簡単かつ便利にラップできます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの目的のために意図されたTaskFactoryクラスのFromAsyncメソッドについてはすでに説明しました。ここで、マイクロソフトが過去15年間提供してきた.netでの非同期モデルの開発の全履歴を思い出す必要があります。タスクベースの非同期パターン（TAP）の前に、非同期プログラミングパターン（APP）がありました。これは、</font><b><font style="vertical-align: inherit;">IAsyncResult</font></b><font style="vertical-align: inherit;">および</font><b><font style="vertical-align: inherit;">End</font></b><font style="vertical-align: inherit;">メソッドを</font><font style="vertical-align: inherit;">返す</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DoSomething </font><font style="vertical-align: inherit;">メソッドに関するものでした。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b>DoSomething     legacy        FromAsync,   ,     Event Based Asynchronous Pattern (<b>EAP</b>),  ,         .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskCompletionSourceは、イベントモデルを中心に構築されたTaskとレガシーAPIをラップするのに最適です。彼の作品の本質は次のとおりです。このクラスのオブジェクトには、タイプがTaskのパブリックプロパティがあり、その状態はTaskCompletionSourceクラスのメソッドSetResult、SetExceptionなどを通じて制御できます。 await演算子がこのタスクに適用された場所では、TaskCompletionSourceに適用されたメソッドに応じて、例外が発生して実行またはクラッシュします。すべてがまだ明確でない場合は、次のコード例を見てみましょう。古いEAP APIがTaskCompletionSourceを使用してTaskにラップされています。イベントが発生すると、TaskはCompleted状態に転送され、awaitオペレーターをこのTaskに適用したメソッドが実行を再開します</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを取得します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Task&lt;Result&gt; <span class="hljs-title">DoAsync</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> SomeApiInstance someApiObj</span>)</span> {<font></font>
<font></font>
    <span class="hljs-keyword">var</span> completionSource = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;Result&gt;();<font></font>
    someApiObj.Done += <font></font>
        result =&gt; completionSource.SetResult(result);<font></font>
    someApiObj.Do();<font></font>
<font></font>
    result completionSource.Task;<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSourceのヒントとコツ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いAPIをラップするだけでは、TaskCompletionSourceを使用できません。</font><font style="vertical-align: inherit;">このクラスを使用すると、スレッドを占有しないタスクでさまざまなAPIを設計する興味深い可能性が開かれます。</font><font style="vertical-align: inherit;">そして、フローは、私たちが覚えているように、高価なリソースであり、その数は（主にRAMのボリュームによって）制限されています。</font><font style="vertical-align: inherit;">この制限は、たとえば、複雑なビジネスロジックを持つロードされたWebアプリケーションを開発することで簡単に実現できます。</font><font style="vertical-align: inherit;">ロングポーリングのようなトリックの実装について話している可能性を検討してください。</font></font><br>
<br>
<i>      :     API        ,   API  -      ,     .   —  API   HTTP   WebSocket     -    .     HTTP . HTTP        .       ,             TimerInterval / 2.         Long Polling,             Timeout    .   ,   ,  ,    .</i><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">while</span>(!eventOccures &amp;&amp; !timeoutExceeded)  {<font></font>
<font></font>
  CheckTimout();<font></font>
  CheckEvent();<font></font>
  Thread.Sleep(<span class="hljs-number">1</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのようなソリューションは、イベントを待機しているクライアントの数が増えるとすぐにひどく証明されます。そのような各クライアントは、イベントを見越して、ストリーム全体を占有します。はい、イベントのトリガーでさらに1ミリ秒の遅延が発生します。ほとんどの場合、それは重要ではありませんが、ソフトウェアを実際よりも悪化させるのはなぜですか。 Thread.Sleep（1）を削除すると、無駄に1つのプロセッサコアが100％アイドル状態で読み込まれ、無駄なサイクルで回転します。 TaskCompletionSourceを使用すると、このコードを簡単にやり直して、上記で識別されたすべての問題を解決できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">LongPollingApi</span> {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-keyword">int</span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;Msg&gt; <span class="hljs-title">AcceptMessageAsync</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> duration</span>)</span> {<font></font>
<font></font>
        <span class="hljs-keyword">var</span> cs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;Msg&gt;();<font></font>
        tasks[userId] = cs;<font></font>
        <span class="hljs-keyword">await</span> Task.WhenAny(Task.Delay(duration), cs.Task);
        <span class="hljs-keyword">return</span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> userId, Msg m</span>)</span> {<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (tasks.TryGetValue(userId, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> completionSource))<font></font>
            completionSource.SetResult(m);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコードは製品版ではなく、単なるデモです。</font><font style="vertical-align: inherit;">実際のケースでそれを使用するには、少なくとも誰も予期しないときにメッセージが到着した場合の状況にも対処する必要があります。この場合、AsseptMessageAsyncメソッドは既に完了したタスクを返す必要があります。</font><font style="vertical-align: inherit;">このケースが最も頻繁である場合は、ValueTaskの使用を検討できます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージのリクエストを受信すると、TaskCompletionSourceを作成してディクショナリに配置し、最初に何が起こるかを待機します。指定された時間間隔が経過するか、メッセージが受信されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueTask：理由と方法</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期/待機演算子は、yield return演算子のように、メソッドからステートマシンを生成します。つまり、新しいオブジェクトを作成します。これはほとんど常に重要ではありませんが、まれに問題が発生する可能性があります。このケースは、非常に頻繁に呼び出されるメソッドであり、1秒あたり数万から数十万の呼び出しについて話します。そのようなメソッドがほとんどの場合にすべての待機メソッドを迂回して結果を返すように記述されている場合、.NETはこれを最適化するツール、つまりValueTask構造を提供します。それを明確にするために、その使用例を検討してください。私たちが頻繁にアクセスするキャッシュがあります。その中にいくつかの値があり、それらを返すだけです。そうでない場合は、それらの背後にある遅いIOに移動します。後者を非同期に実行する必要があります。つまり、メソッド全体が非同期です。したがって、メソッドを作成する明白な方法は次のとおりです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetById</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> id</span>)</span> {<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (cache.TryGetValue(id, <span class="hljs-keyword">out</span> <span class="hljs-keyword">string</span> val))
        <span class="hljs-keyword">return</span> val;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> RequestById(id);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し最適化したいという欲求と、Roslynがこのコードをコンパイルすることによって生成するものを少し恐れているため、この例を次のように書き直すことができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetById</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> id</span>)</span> {<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (cache.TryGetValue(id, <span class="hljs-keyword">out</span> <span class="hljs-keyword">string</span> val))
        <span class="hljs-keyword">return</span> Task.FromResult(val);
    <span class="hljs-keyword">return</span> RequestById(id);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、この場合の最適なソリューションは、ホットパスを最適化することです。つまり、余分な割り当てやGCへの負荷なしにディクショナリから値を取得しますが、IOに移動する必要があるまれなケースでは、すべてがプラスのままです。 /マイナス古い：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> ValueTask&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetById</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> id</span>)</span> {<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (cache.TryGetValue(id, <span class="hljs-keyword">out</span> <span class="hljs-keyword">string</span> val))
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ValueTask&lt;<span class="hljs-keyword">string</span>&gt;(val);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ValueTask&lt;<span class="hljs-keyword">string</span>&gt;(RequestById(id));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードフラグメントを詳しく見てみましょう。キャッシュに値がある場合、構造を作成します。それ以外の場合、実際のタスクは重要なものにラップされます。</font><font style="vertical-align: inherit;">呼び出し元のコードは、このコードがどのように実行されたかには関係ありません。C＃の構文では、ValueTaskはこの場合の通常のTaskと同じように動作します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskSchedulers：タスク起動戦略の管理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に検討したいAPIは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">とその派生</font><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">TPLには、Task'ovをスレッドごとに配布するための戦略を制御する機能があることを前述しました。</font><font style="vertical-align: inherit;">このような戦略は、TaskSchedulerクラスの子孫で定義されています。</font><font style="vertical-align: inherit;">マイクロソフトが開発</font><font style="vertical-align: inherit;">した</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParallelExtensionsExtras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリには</font><font style="vertical-align: inherit;">、.NETの一部ではなく、Nugetパッケージとして提供される</font><font style="vertical-align: inherit;">ほとんどすべての戦略</font><font style="vertical-align: inherit;">が含まれています。</font><font style="vertical-align: inherit;">それらのいくつかを簡単に検討します。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentThreadTaskScheduler-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のスレッドでタスクを実行します</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LimitedConcurrencyLevelTask​​Scheduler-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時に実行されるタスクの数を、コンストラクターで受け入れられるNパラメーターに制限します</font></font></li>
<li><b>OrderedTaskScheduler </b> —   LimitedConcurrencyLevelTaskScheduler(1),     .</li>
<li><b>WorkStealingTaskScheduler </b> —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">work-stealing</a>    .     ThreadPool.   ,   .NET ThreadPool   ,    ,                  .        . ..      WorkStealingTaskScheduler’    ,   ThreadPool     .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueuedTaskScheduler-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優先度付きのキュールールに従ってタスクを実行できます</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPerTaskScheduler-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行されるタスクごとに個別のスレッドを作成します。</font><font style="vertical-align: inherit;">予測できないほど長く実行されるタスクに役立ちます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicrosoftブログのTaskSchedulersに関する</font><font style="vertical-align: inherit;">
優れた詳細な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studioのタスクに関連するすべての便利なデバッグ用に、[タスク]ウィンドウがあります。</font><font style="vertical-align: inherit;">このウィンドウでは、タスクの現在のステータスを確認し、現在実行中のコード行に移動できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLinqとParallelクラス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Taskと.NETでそれらについて述べられたすべてに加えて、PLinq（Linq2Parallel）とParallelクラスの2つの興味深いツールがあります。 1つ目は、複数のスレッドですべてのLinq操作の並列実行を約束します。スレッド数は、WithDegreeOfParallelism拡張メソッドで構成できます。残念ながら、ほとんどの場合、デフォルトでは実行モードのPLinqは、データソースの内部に関する十分な情報がないため、大幅な速度向上を実現できません。一方、試行価格は非常に低く、Linqメソッドチェーンの前でAsParallelメソッドを呼び出して、パフォーマンステストを実行するだけです。さらに、パーティションメカニズムを使用して、データソースの性質に関する追加情報をPLinqに転送できます。あなたは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ここで</font></a><font style="vertical-align: inherit;">もっと読むことができ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallel静的クラスは、Foreachコレクションを並列に反復処理し、Forループを実行し、Invokeに複数のデリゲートを並列に実行するためのメソッドを提供します。</font><font style="vertical-align: inherit;">現在のスレッドの実行は、計算が完了するまで停止されます。</font><font style="vertical-align: inherit;">スレッドの数は、ParallelOptionsを最後の引数として渡すことで構成できます。</font><font style="vertical-align: inherit;">オプションを使用して、TaskSchedulerとCancellationTokenを指定することもできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートの資料やその後の作業中に収集した情報を基にこの記事を書き始めたとき、そんなにうまくいくとは思っていませんでした。</font><font style="vertical-align: inherit;">ここで、この記事を入力しているテキストエディターが15ページ目がなくなったことを非難するように言ったら、中間結果を要約します。</font><font style="vertical-align: inherit;">その他のトリック、API、ビジュアルツール、および落とし穴については、今後の記事で説明します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のPCのリソースを使用するには、スレッド、非同期、並列処理を行うためのツールを知っている必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETには、この目的のためのさまざまなツールがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レガシーが見つかることが多いため、すべてが一度に表示されるわけではありませんが、多くの努力なしに古いAPIを変換する方法があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETでのスレッドの操作は、クラスThreadおよびThreadPoolで表されます</font></font></li>
<li> Thread.Abort, Thread.Interrupt,  Win32 API TerminateThread      .      CancellationToken’</li>
<li> —  ,   .   ,     .      TaskCompletionSource</li>
<li>     .NET        Task’.</li>
<li> c# async/await    </li>
<li>  Task’       TaskScheduler’ </li>
<li> ValueTask      hot-paths  memory-traffic</li>
<li> Tasks  Threads Visual Studio          </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLinqはクールなツールですが、データソースに関する十分な情報がない可能性がありますが、これはパーティショニングメカニズムを使用して修正できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継続的な</font><font style="vertical-align: inherit;">...</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452078/index.html">Kubernetesの予約：存在します</a></li>
<li><a href="../ja452086/index.html">私のピクセルには何がありますか：プラズモンメタサーフェスを使用したナノピクセルの作成</a></li>
<li><a href="../ja452088/index.html">セマンティックセグメンテーションによる道路認識</a></li>
<li><a href="../ja452090/index.html">手続き型パズルジェネレーターの作成</a></li>
<li><a href="../ja452092/index.html">アプリ内アップデート：Androidアプリケーションアップデートの高速化</a></li>
<li><a href="../ja452098/index.html">フロントエンド開発者Habrのログ：リファクタリングと反射</a></li>
<li><a href="../ja452102/index.html">ドローンが好きな人のための写真ゲーム：AirSelfie 2について簡単に</a></li>
<li><a href="../ja452106/index.html">2019年6月16日の夏のDIYミーティングにスピーカーを招待します</a></li>
<li><a href="../ja452108/index.html">Docker：無害なアドバイス</a></li>
<li><a href="../ja452110/index.html">Ansibleでディスク交換を自動化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>