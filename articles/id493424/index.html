<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèΩ üëèüèæ üëõ Kami menerapkan konversi kode Python üë©‚Äçüåæ üë©üèª‚Äç‚öñÔ∏è ü¶ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Habr. 
 
 Hari ini kami menawarkan kepada Anda terjemahan dari artikel yang menyentuh topik yang bukan paling banyak dibahas: kompilasi kode deng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kami menerapkan konversi kode Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini kami menawarkan kepada Anda terjemahan dari artikel yang menyentuh topik yang bukan paling banyak dibahas: kompilasi kode dengan Python, yaitu: bekerja dengan pohon sintaksis abstrak (AST) dan kode byte. Meskipun Python adalah bahasa yang ditafsirkan, fitur-fitur seperti itu sangat penting dari sudut pandang optimasi. Kami akan membicarakannya hari ini.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pernahkah Anda bertanya-tanya bagaimana sebenarnya kompiler mengoptimalkan kode Anda sehingga bekerja lebih cepat? </font><font style="vertical-align: inherit;">Ingin tahu apa itu pohon sintaksis abstrak (AST) dan untuk apa pohon itu digunakan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ulasan ini menjelaskan bagaimana kode Python dikonversi ke bentuk pohon (AST). </font><font style="vertical-align: inherit;">Setelah membangun AST program Anda, Anda dapat melanjutkan untuk mencari optimasi dan transformasi kode Anda. </font><font style="vertical-align: inherit;">Namun, perlu diingat bahwa mengoptimalkan program Python dengan cara yang tidak sepele </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat sulit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode program sebagai pohon</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana komputer memastikan bahwa ia mengevaluasi ekspresi dari kode Anda dalam urutan yang benar? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan ini, ia terlebih dahulu membuat ulang kode program Anda menjadi struktur pohon yang disebut AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika bekerja dengan bahasa pemrograman yang ditafsirkan (seperti Python), secara umum diterima bahwa penerjemah melewati kode Anda dan melakukan semua yang ditemuinya, tepat di tempat, tanpa mengubah kode Python menjadi kode mesin dengan cara apa pun. Namun, dalam praktiknya, skema eksekusi ini memicu banyak masalah, yang membuatnya sangat merepotkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambil contoh, masalah sederhana seperti itu sebagai prioritas operator. Dalam ekspresi tampilan </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bagian tersebut pertama kali dihitung</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan hanya dengan demikian 3 dapat ditambahkan ke hasil perkalian. Mungkin Anda belajar diutamakan operator di kelas matematika dengan menggambar pohon-pohon ini di bawah ungkapan: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python menggunakan aturan standar notasi matematika (perkalian terlebih dahulu, kemudian penambahan). Agar tidak membingungkan apa pun dengan prioritas operator, dengan Python, pada awalnya itu dibangun pohon seperti pada gambar sebelumnya. Operasi umum adalah penambahan (pada akar pohon), dan sementara sisi kiri jumlah ini adalah angka reguler, di sebelah kanan kami memiliki produk. Struktur data yang dihasilkan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti Operasi Biner (Operasi Biner) dan menunjukkan bahwa dalam operasi seperti penambahan dan perkalian - dua operan. Secara alami, Anda tidak akan mendapatkan tambahan apa pun jika bagian yang tepat dari ekspresi tidak memiliki nilai yang benar - karena itu, Anda harus terlebih dahulu menggandakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam teori kompiler dan bahasa pemrograman, pohon seperti itu disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pohon Sintaksis Abstrak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . AST dalam contoh di atas termasuk dua simpul </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dua simpul, </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan satu simpul </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada fitur bagus di Python - kemampuan untuk langsung melihat dan menampilkan AST untuk program Python tertentu. Yang diperlukan hanyalah mengimpor modul standar</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, parsing program, dan kemudian menampilkan hasilnya di layar (omong-omong, parsing adalah proses mengubah kode sumber program ke pohon AST).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, Anda akan melihat bahwa akan ada node dan bidang tambahan di AST yang dihasilkan oleh Python, dan itu akan ditampilkan pada satu baris, yang membuatnya tampak lebih rumit pada pandangan pertama daripada yang sebenarnya. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita membaginya menjadi node yang terpisah, seperti terakhir kali - dan buka kembali AST, sudah di atas, sebagai bagian dari keseluruhan pohon: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas, Python "berpikir" bahwa baris yang kami berikan untuk parsing adalah seluruh modul. Tubuh modul adalah daftar semua instruksi yang terkandung di dalamnya. Satu-satunya instruksi dalam contoh kita adalah ekspresi </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang maknanya persis seperti yang kita bahas di atas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: simpul </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki bidang tambahan </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(disingkat "konteks"), yang memiliki nilai </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jadi Python mengatakan bahwa kita menggunakan nilai yang disimpan dalam variabel </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan tidak (kembali) mendefinisikan atau menghapus nama </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sekarang langkah Anda, coba parsing sesuatu seperti </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font><font style="vertical-align: inherit;">diri Anda sendiri </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan Anda akan melihat bagaimana bidang </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam node </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berubah menjadi </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, masing-masing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong: jika Anda menginstal modul</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka output AST ke layar dapat dibuat jauh lebih indah, dan bahkan mengubah AST kembali menjadi kode Python langsung.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses kompilasi: sisanya</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mengumpulkan program AST, pada prinsipnya mungkin untuk menyelesaikan seluruh program dengan melalui AST dan melakukan operasi sesuai urutan yang ditunjukkan. Namun, pendekatan ini setidaknya memiliki dua kelemahan. Pertama, AST dapat menempati jumlah memori yang relatif besar, terutama jika mengandung informasi yang berlebihan. Kedua, AST traversal mungkin membutuhkan waktu lebih lama dari yang diperlukan. Singkatnya: itu bisa dilakukan, tetapi tidak efisien. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compiler tidak memproses AST secara langsung, tetapi menyiapkan bytecode, yang kemudian dieksekusi pada mesin virtual Python. Meskipun membahas detail proses ini berada di luar cakupan artikel ini, prinsip dasarnya adalah bahwa kompiler menerjemahkan AST menjadi notasi Polandia terbalik (RPN). Alih-alih menempatkan operator</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antara operan kiri dan kanan, kami meletakkannya setelah kedua operan. Pada contoh di </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atas, kami mendapatkan urutan </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dan notasi ini sangat baik karena Anda dapat langsung melihat dari urutan: pertama Anda perlu melakukan perkalian, dan hanya kemudian penambahan). Karena masing-masing dari lima elemen dalam urutan ini pada prinsipnya dapat direpresentasikan sebagai byte tunggal, kode tersebut disebut kode byte. Python kemudian menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mesin virtual yang ditumpuk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menjalankan kode ini secara efisien.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan kata lain, proses penyusunan program yang ditulis dengan Python berlangsung dalam dua tahap. </font><font style="vertical-align: inherit;">Pertama, program yang diterima oleh input diuraikan, dan hasilnya adalah pohon sintaksis abstrak (AST). </font><font style="vertical-align: inherit;">Compiler kemudian melewati AST dan menghasilkan bytecode. </font><font style="vertical-align: inherit;">Setelah itu, interpreter Python mengeksekusi bytecode ini. </font><font style="vertical-align: inherit;">Setelah melakukan optimasi, ini dapat diterapkan baik pada level AST atau pada level bytecode. </font><font style="vertical-align: inherit;">Kedua opsi ini memiliki kelebihan dan kekurangannya sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, perlu diingat bahwa meskipun AST umum dalam setiap implementasi Python, proses menerjemahkan AST ke dalam bytecode mungkin berbeda, dan dalam beberapa implementasi Python, katakanlah, JavaScript, daripada bytecode, dapat dihasilkan pada tahap perantara.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigma dari bahasa pemrograman lain</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak semua bahasa pemrograman menggunakan notasi infiks, seperti pada Python. </font><font style="vertical-align: inherit;">Dua contoh yang patut dicatat dalam kasus ini adalah PostScript, di mana program ditulis langsung dalam notasi Polandia terbalik, dan Lisp, tentu saja, di mana program biasanya ditulis dalam notasi Polandia. </font><font style="vertical-align: inherit;">Jadi, ekspresi kita contoh di atas, dalam Lips akan mengambil formulir berikut: </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konversi simpul dalam AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memiliki program AST, bagaimana mengkonversi setiap bagian dari pohon ini? Dengan fitur bawaan Python yang nyaman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita melihat AST dan, misalnya, menemukan bahwa kedua bidang </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simpul </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah angka (node </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), kita dapat melakukan perhitungan yang sesuai sebelumnya, dan kemudian menggantinya dengan </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simpul normal </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, Anda harus bertindak sangat hati-hati agar tidak mengubah perilaku program, melakukan transformasi seperti itu. Misalnya, dalam </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jelas bahwa hasilnya adalah 4. Tapi kita tidak bisa mengganti semua ekspresi nomor 4 karena empat fungsi </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masih benar dipanggil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi, mulailah dengan optimasi sederhana. Di mana pun nama muncul dalam kode sumber program </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, gantilah dengan nilai 3.14159265. Modul Python </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah menyediakan struktur data yang diperlukan untuk melakukan ini: kelas konverter </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang melewati semua AST dan memeriksa untuk setiap node apakah dapat diganti. Secara default, metode transformasi hanya mengembalikan node sumber untuk setiap node, sehingga kami mendapatkan AST yang sama dengan yang kami mulai. Tetapi kita dapat dengan mudah menimpa metode untuk node </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, katakanlah, sehingga memeriksa untuk </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melihat apakah itu, dan kemudian mengembalikan node </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan node dengan nama asli ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar konverter / pengoptimal melewati pohon kami, perlu memanggil metode </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang kemudian akan mengembalikan pohon baru yang diubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, tidak mungkin untuk mengkompilasi dan menjalankan AST yang dihasilkan, alasannya adalah satu detail teknis. Ini belum terlihat, tetapi (hampir) semua node di AST juga memiliki bidang </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mereka menunjukkan posisi yang tepat dari simpul tertentu dalam kode sumber. Jika Anda tidak menginstalnya dengan benar, kompiler akan bersumpah dan menolak untuk bekerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita salin bidang yang sesuai dari node sumber </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke node baru </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anda kemudian dapat mengkompilasi dan menjalankan AST yang dihasilkan:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi kompilasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak hanya menuntut kode sumber (di mana bisa menjadi program itu sendiri, atau garis AST), tapi nama file (seperti yang kita diminta </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), serta salah satu dari tiga: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kebutuhan untuk menyalin bidang yang menggambarkan posisi node dalam kode sumber muncul cukup sering. Oleh karena itu, modul </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki fungsi khusus </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya untuk tujuan ini, dan kita dapat menulis:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, Anda dapat memperluas contoh sebelumnya sehingga benar-benar melakukan optimasi, yaitu pada node </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menurut aturan transformasi, pertama-tama kita harus mengubah / mengoptimalkan kiri, dan kemudian simpul kanan sebagai bagian dari BinOp. </font><font style="vertical-align: inherit;">Jika sebagai hasilnya ternyata kedua node kiri dan kanan adalah angka, maka perhitungan dapat dilakukan tepat di tempat dan mengganti yang asli dengan </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasil numerik dari operasi.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, kompiler CPython sudah mengoptimalkan node </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti yang ditunjukkan di sini. </font><font style="vertical-align: inherit;">Kode yang sesuai ditulis dalam C dan diberikan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Harap perhatikan: Pengoptimal CPython lebih universal dan berfungsi tidak hanya dengan angka, seperti dalam contoh yang kami pertimbangkan, tetapi dengan berbagai jenis nilai konstan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memeriksa Nodes di AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara memastikan bahwa transformasi yang kami lakukan benar? Pertama, Anda perlu mem-bypass AST sepenuhnya dan memeriksa keseluruhan program. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengoptimal yang disajikan di atas tetap merupakan kesalahan serius. Apa yang terjadi jika Anda mendefinisikan kembali suatu tempat di program </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Bayangkan saja sesuatu yang sederhana dan dapat dipahami </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pengoptimal kami hanya akan mengganti pi di sisi kiri ekspresi dengan nilai numerik 3.14159265, dan Python kemudian akan menolak untuk mengkompilasi karena tidak dapat menetapkan apa pun ke nilai literal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin inilah perilaku yang Anda cari, menjadikan pi konstanta yang benar, yang diganti selama kompilasi dan tidak pernah dapat dipindahkan, yaitu, ia tidak bisa mendapatkan nilai yang berbeda. Namun, ini jelas melanggar semantik Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi apa yang harus dilakukan jika kita ingin tetap menggunakan semantik Python, tetapi ganti pi jika memungkinkan? Dalam hal ini, Anda harus terlebih dahulu melewati seluruh program dan memeriksa apakah nilai untuk ditugaskan di suatu tempat </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sampai kita memperumitnya: kita tidak akan menggunakan untuk mengganti pi jika setidaknya satu titik dalam program memiliki nilai penugasan </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita menggunakan node pengunjung, mirip dengan simpul konverter yang dijelaskan di atas. Tidak seperti konverter, pengunjung tidak dimaksudkan untuk mengubah node, ia hanya melewati AST dan memeriksa node (mengunjungi mereka). Dengan demikian, metode kunjungan tidak menghasilkan apa-apa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, kami memeriksa apakah node mengacu </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melakukan apa pun selain memuat nilai</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ingat bidang konteks </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini dipanggil oleh pengunjung untuk setiap simpul yang kami tidak menyediakan metode kunjungan khusus. </font><font style="vertical-align: inherit;">Dengan kata lain: tidak ada metode seperti itu </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di kelas </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang bisa kita panggil menggunakan </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mengenai definisi fungsi, kita harus memanggil pengunjung umum untuk memastikan bahwa seluruh isi fungsi juga diproses dengan benar. </font><font style="vertical-align: inherit;">Jika tidak, kami dapat menyembunyikan instruksi dalam fungsi </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengubah nilainya secara global </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga pengoptimal kami tidak akan melihat apa pun.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai Lokal dalam Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode kami, yang memungkinkan kami untuk menentukan apakah programmer telah mengubah pi, ternyata agak kasar. </font><font style="vertical-align: inherit;">Namun, kompilator Python bertindak sangat mirip ketika menentukan nama mana dalam lingkup fungsi yang sesuai dengan variabel lokal. </font><font style="vertical-align: inherit;">Jika suatu variabel berubah di suatu tempat dalam lingkup fungsi (dan tidak secara eksplisit dibuat global, misalnya, menggunakan instruksi global), maka variabel ini dianggap lokal di seluruh cakupan fungsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh berikut akan dieksekusi dengan baik tanpa baris keempat. </font><font style="vertical-align: inherit;">Tapi, meskipun </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baris keempat tidak pernah dieksekusi, itu masih dianggap tugas</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan karenanya, x menjadi variabel lokal pada skala seluruh fungsi, dan bahkan pada baris 3. Karena itu Python akan bersumpah bahwa variabel x pada baris ketiga belum penting.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tertarik pada detail cara kerja Python di sini, lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / symtable.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Python, seperti pada kebanyakan bahasa pemrograman, program tertentu tidak dijalankan langsung dari kode sumber. </font><font style="vertical-align: inherit;">Bahkan, terjemahan kode sumber berlangsung dalam dua tahap: pertama, pohon sintaksis abstrak (AST) dibuat darinya, dan kemudian kode byte untuk mesin virtual yang ditumpuk. </font><font style="vertical-align: inherit;">Python juga menyediakan sejumlah fitur yang sangat bagus untuk menganalisis dan bahkan mengubah AST dari program Python tertentu, setelah itu AST yang dimodifikasi dapat dikompilasi dan dieksekusi. </font><font style="vertical-align: inherit;">Dengan demikian, kami dapat dengan mudah menerapkan optimasi kami sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, saya hanya menghilangkan banyak detail di sini. </font><font style="vertical-align: inherit;">Untuk memastikan bahwa optimasi Anda akan berfungsi dengan benar dalam semua kasus dan keadaan yang mungkin adalah masalah yang sangat sepele. </font><font style="vertical-align: inherit;">Namun, tujuan artikel ini bukan untuk memberi tahu Anda tentang pengoptimalan yang siap digunakan dalam produksi, tetapi untuk memberikan gagasan dasar tentang bagaimana Python menganalisis kode program Anda sehingga Anda dapat mempelajari cara mengonversi dengan benar dan kemudian mengoptimalkannya.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id493408/index.html">Helikopter mini DJI Mavic jatuh seperti linggis</a></li>
<li><a href="../id493412/index.html">Game dengan Wifi di ESP32</a></li>
<li><a href="../id493416/index.html">IDA Pro dan teknik reverse engineering</a></li>
<li><a href="../id493418/index.html">Mengapa pembelajaran mesin menggunakan data "sintetis"</a></li>
<li><a href="../id493420/index.html">Cara saya untuk memperkenalkan siswa sekolah menengah pertama ke Python</a></li>
<li><a href="../id493426/index.html">Organisasi kode dalam layanan microser dan pendekatan saya menggunakan arsitektur heksagonal dan DDD</a></li>
<li><a href="../id493428/index.html">"Kami tidak akan memunculkan teori konspirasi." Bicara tentang konferensi ML dengan orang-orang dari perusahaan sains dan TI</a></li>
<li><a href="../id493430/index.html">Arsitektur Net untuk Aplikasi Web</a></li>
<li><a href="../id493432/index.html">Mengapa tidak memulai karier di perusahaan kecil non-IT</a></li>
<li><a href="../id493436/index.html">Program untuk mengubah hak akses dan mendaftar nama file / direktori di Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>