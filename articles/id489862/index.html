<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•’ ğŸ° ğŸ” Perencanaan dalam Go: Bagian II - The Go Scheduler ğŸ„ ğŸŒƒ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Ini adalah posting kedua dalam seri tiga bagian, yang akan memberikan gambaran tentang mekanika dan semantik karya penjadwal di Go. Postin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Perencanaan dalam Go: Bagian II - The Go Scheduler</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font><font style="vertical-align: inherit;">Ini adalah posting kedua dalam seri tiga bagian, yang akan memberikan gambaran tentang mekanika dan semantik karya penjadwal di Go. </font><font style="vertical-align: inherit;">Posting ini tentang perencana Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama dari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seri ini, saya menjelaskan aspek penjadwal sistem operasi yang, menurut pendapat saya, penting untuk memahami dan mengevaluasi semantik penjadwal Go. </font><font style="vertical-align: inherit;">Dalam posting ini, saya akan menjelaskan pada tingkat semantik bagaimana penjadwal Go bekerja. </font><font style="vertical-align: inherit;">Go Scheduler adalah sistem yang kompleks dan detail mekanis kecil tidak penting. </font><font style="vertical-align: inherit;">Penting untuk memiliki model yang baik tentang bagaimana segala sesuatu bekerja dan berperilaku. </font><font style="vertical-align: inherit;">Ini akan memungkinkan Anda untuk membuat keputusan teknik terbaik.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program Anda mulai</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika program Go Anda mulai, itu diberikan prosesor logis (P) untuk setiap inti virtual yang ditentukan pada mesin host. Jika Anda memiliki prosesor dengan beberapa utas perangkat keras per inti fisik (Hyper-Threading), setiap utas perangkat keras akan disajikan kepada program Anda sebagai inti virtual. Untuk lebih memahami hal ini, lihat laporan sistem untuk MacBook Pro saya. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat bahwa saya memiliki satu prosesor dengan 4 inti fisik. Laporan ini tidak mengungkapkan jumlah utas perangkat keras per inti fisik. Prosesor Intel Core i7 memiliki teknologi Hyper-Threading, yang berarti bahwa inti fisik memiliki 2 utas perangkat keras. Ini memberitahu Go bahwa 8 core virtual tersedia untuk menjalankan utas OS secara paralel. Untuk memverifikasi ini, pertimbangkan program berikut:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika saya menjalankan program ini di komputer saya, hasil memanggil fungsi NumCPU () akan menjadi 8. Program Go mana pun yang saya jalankan di komputer saya akan mendapatkan 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diberi aliran OS ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Utas ini masih dikelola oleh OS, dan OS masih bertanggung jawab untuk menempatkan utas di kernel untuk dieksekusi. Ini berarti bahwa ketika saya menjalankan Go di komputer saya, saya memiliki 8 utas yang tersedia untuk melakukan pekerjaan saya, masing-masing ditautkan secara individual ke </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
program </font><font style="vertical-align: inherit;">P. </font><font style="vertical-align: inherit;">Each Go juga diberi Goroutine awal ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine pada dasarnya adalah Coroutine, tetapi Go, jadi kami mengganti huruf C dengan G dan mendapatkan kata Goroutine. Anda dapat menganggap Goroutine sebagai utas tingkat aplikasi, dan semuanya mirip dengan utas OS. Sama seperti utas OS dihidupkan dan dimatikan oleh kernel, program konteks dihidupkan dan dimatikan oleh konteks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teka-teki terakhir adalah antrian eksekusi. </font><font style="vertical-align: inherit;">Ada dua antrian eksekusi yang berbeda di penjadwal Go: antrian eksekusi global (GRQ) dan antrian eksekusi lokal (LRQ). </font><font style="vertical-align: inherit;">Setiap P diberi LRQ yang mengontrol goroutine yang ditugaskan untuk mengeksekusi dalam konteks P. Goroutine ini hidup dan mati dari konteks M yang ditugaskan untuk P. GRQ ini adalah untuk goroutine yang tidak ditugaskan ke P. Ada proses untuk memindahkan goroutine dari GRQ ke LRQ, yang akan kita bahas nanti. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar menunjukkan semua komponen ini bersamaan.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="gambar"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perencana koperasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang kami katakan di posting pertama, penjadwal OS adalah penjadwal preemptive. Pada dasarnya, ini berarti bahwa Anda tidak dapat memprediksi apa yang akan dilakukan perencana pada waktu tertentu. Kernel membuat keputusan dan semuanya bersifat non-deterministik. Aplikasi yang berjalan di atas sistem operasi tidak mengontrol apa yang terjadi di dalam kernel dengan penjadwalan kecuali mereka menggunakan primitif sinkronisasi seperti instruksi atom dan panggilan mutex.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler adalah bagian dari Go Runtime, dan Go Runtime ada di dalam aplikasi Anda. Ini berarti bahwa penjadwal Go berfungsi di ruang pengguna di kernel. Implementasi Go scheduler saat ini bukan preemptive, tetapi scheduler interaktif. Menjadi perencana kooperatif berarti perencana itu membutuhkan peristiwa yang didefinisikan dengan baik di ruang pengguna yang terjadi pada titik aman dalam kode untuk membuat keputusan perencanaan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang baik tentang perencana kolaboratif Go adalah bahwa ia terlihat dan terasa proaktif. </font><font style="vertical-align: inherit;">Anda tidak dapat memprediksi apa yang akan dilakukan penjadwal Go. </font><font style="vertical-align: inherit;">Hal ini disebabkan oleh fakta bahwa pengambilan keputusan untuk penjadwal ini tidak tergantung pada pengembang, tetapi pada waktu eksekusi Go. </font><font style="vertical-align: inherit;">Penting untuk menganggap penjadwal Go sebagai penjadwal proaktif, dan karena penjadwal adalah non-deterministik, itu tidak terlalu sulit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negara Gorutin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sama seperti aliran, goroutine memiliki tiga tingkat tinggi yang sama. Mereka menentukan peran yang dimainkan perencana Go dengan setiap goroutine. Goroutin dapat di salah satu dari tiga negara: Menunggu, Siap, atau Memenuhi. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menunggu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ini berarti bahwa goroutine dihentikan dan menunggu sesuatu untuk melanjutkan. Ini dapat terjadi karena alasan seperti menunggu sistem operasi (panggilan sistem) atau sinkronisasi panggilan (operasi atom dan mutex). Jenis keterlambatan ini adalah penyebab utama buruknya kinerja. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesiapan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ini berarti bahwa goroutine ingin waktu untuk mengikuti instruksi yang diberikan. </font><font style="vertical-align: inherit;">Jika Anda memiliki banyak goroutine yang membutuhkan waktu, maka goroutine harus menunggu lebih lama untuk mendapatkan waktu. </font><font style="vertical-align: inherit;">Selain itu, jumlah waktu masing-masing yang diterima goroutine berkurang karena semakin banyak goroutine yang bersaing untuk mendapatkan waktu. </font><font style="vertical-align: inherit;">Jenis penundaan penjadwalan ini juga dapat menyebabkan kinerja yang buruk. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemenuhan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ini berarti bahwa goroutine telah ditempatkan di M dan mengikuti instruksinya. </font><font style="vertical-align: inherit;">Pekerjaan yang terkait dengan aplikasi telah selesai. </font><font style="vertical-align: inherit;">Ini yang diinginkan semua orang.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sakelar konteks</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler membutuhkan peristiwa ruang pengguna yang terdefinisi dengan baik yang terjadi pada titik aman dalam kode untuk beralih konteks. </font><font style="vertical-align: inherit;">Peristiwa dan titik aman ini muncul di panggilan fungsi. </font><font style="vertical-align: inherit;">Panggilan fungsi sangat penting untuk kinerja Penjadwal Go. </font><font style="vertical-align: inherit;">Jika Anda menjalankan loop sempit apa pun yang tidak membuat panggilan fungsi, Anda akan menyebabkan keterlambatan penjadwalan dan pengumpulan sampah. </font><font style="vertical-align: inherit;">Sangat penting bahwa pemanggilan fungsi terjadi dalam jumlah waktu yang wajar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada empat kelas peristiwa yang terjadi dalam program Go Anda yang memungkinkan perencana untuk membuat keputusan perencanaan. </font><font style="vertical-align: inherit;">Ini tidak berarti bahwa ini akan selalu terjadi di salah satu acara ini. </font><font style="vertical-align: inherit;">Ini berarti bahwa penjadwal mendapat kesempatan.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan kata kunci go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengumpul sampah</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan sistem</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinkronisasi</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
kata kunci </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> Kata kunci </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> adalah bagaimana Anda membuat goroutine. </font><font style="vertical-align: inherit;">Begitu goroutine baru dibuat, itu memberi perencana kesempatan untuk membuat keputusan perencanaan. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage Collector (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Karena GC bekerja dengan set goroutinnya sendiri, gorutin ini membutuhkan waktu untuk menjalankan M. </font><font style="vertical-align: inherit;">Ini memaksa GC untuk menciptakan banyak kekacauan dalam perencanaan. </font><font style="vertical-align: inherit;">Namun, perencana sangat pandai dalam apa yang dilakukan goroutine, dan ia akan menggunakannya untuk mengambil keputusan. </font><font style="vertical-align: inherit;">Salah satu solusi yang masuk akal adalah dengan mengubah konteks ke goroutine, yang ingin mengakses sumber daya sistem, dan tidak ada orang lain kecuali itu selama pengumpulan sampah. </font><font style="vertical-align: inherit;">Ketika GC bekerja, banyak keputusan perencanaan dibuat. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan sistem</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika goroutine membuat panggilan sistem yang akan membuatnya memblokir M, scheduler dapat mengalihkan konteks ke goroutine lain, ke M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinkronisasi yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sama. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika panggilan ke operasi atom, sebuah mutex atau saluran menyebabkan goroutine diblokir, penjadwal dapat mengubah konteks untuk memulai goroutine baru. </font><font style="vertical-align: inherit;">Setelah goroutine dapat berfungsi kembali, ia dapat di-antri dan akhirnya kembali ke M.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan sistem asinkron</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika sistem operasi yang Anda jalankan memiliki kemampuan untuk memproses panggilan sistem secara tidak sinkron, apa yang disebut dengan poller jaringan dapat digunakan untuk memproses panggilan sistem dengan lebih efisien. </font><font style="vertical-align: inherit;">Ini dicapai dengan menggunakan kqueue (MacOS), epoll (Linux) atau iocp (Windows) di masing-masing OS ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panggilan sistem jaringan dapat ditangani secara tidak sinkron oleh banyak sistem operasi yang kita gunakan saat ini. Di sinilah poller jaringan menunjukkan dirinya, karena tujuan utamanya adalah untuk memproses operasi jaringan. Menggunakan poller jaringan untuk panggilan sistem jaringan, scheduler dapat mencegah goroutine dari memblokir M selama panggilan sistem ini. Ini membantu menjaga M tersedia untuk mengeksekusi goroutine lain di LRQ P tanpa perlu membuat M. baru. Ini membantu mengurangi beban perencanaan dalam OS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara terbaik untuk melihat bagaimana ini bekerja adalah dengan melihat contoh. Gambar tersebut menunjukkan skema perencanaan dasar kami. Gorutin-1 dieksekusi pada M, dan 3 Gorutin lagi sedang menunggu di LRQ untuk mendapatkan waktu mereka di M. Polling jaringan tidak digunakan, dan ia tidak ada hubungannya.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gambar berikut, Gorutin-1 (G1) ingin membuat panggilan sistem jaringan, sehingga G1 pindah ke poller Jaringan dan diperlakukan sebagai panggilan sistem jaringan asinkron. </font><font style="vertical-align: inherit;">Setelah G1 dipindahkan ke Network poller, M sekarang tersedia untuk mengeksekusi goroutine lain dari LRQ. </font><font style="vertical-align: inherit;">Dalam hal ini, Gorutin-2 beralih ke M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gambar berikut, panggilan jaringan sistem berakhir dengan panggilan jaringan asinkron, dan G1 bergerak kembali ke LRQ untuk P. Setelah G1 dapat beralih kembali ke M, kode yang terkait dengan Go, untuk kode yang dia menjawab bisa mengeksekusi lagi. </font><font style="vertical-align: inherit;">Kemenangan besar adalah bahwa tidak ada Ms tambahan yang diperlukan untuk melakukan panggilan sistem jaringan. </font><font style="vertical-align: inherit;">Poller jaringan memiliki utas OS, dan prosesnya melalui loop peristiwa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan sistem sinkron</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi ketika goroutine ingin membuat panggilan sistem yang tidak dapat dijalankan secara tidak sinkron? </font><font style="vertical-align: inherit;">Dalam kasus ini, Poller jaringan tidak dapat digunakan, dan goroutine yang membuat panggilan sistem akan memblokir M. Ini buruk, tetapi tidak ada cara untuk mencegah ini. </font><font style="vertical-align: inherit;">Salah satu contoh panggilan sistem yang tidak dapat dilakukan secara tidak sinkron adalah panggilan sistem berbasis file. </font><font style="vertical-align: inherit;">Jika Anda menggunakan CGO, mungkin ada situasi lain di mana fungsi C memanggil juga memblokir M.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem operasi Windows dapat membuat panggilan sistem asinkron berbasis file. </font><font style="vertical-align: inherit;">Secara teknis, ketika bekerja pada Windows, Anda dapat menggunakan poller jaringan.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat apa yang terjadi dengan panggilan sistem sinkron (misalnya, file I / O) yang akan memblokir M. Angka tersebut menunjukkan diagram perencanaan dasar kami, tetapi kali ini G1 akan membuat panggilan sistem sinkron yang akan memblokir M1. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gambar berikut, penjadwal dapat menentukan bahwa G1 menyebabkan kunci M. Pada titik ini, penjadwal memutus M1 dari P dengan G1 yang menghalangi masih terpasang. Penjadwal kemudian memperkenalkan M2 baru untuk melayani P. Pada titik ini, G2 dapat dipilih dari LRQ dan termasuk dalam konteks M2. Jika M sudah ada karena pertukaran sebelumnya, transisi ini lebih cepat daripada kebutuhan untuk membuat M. baru</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah selanjutnya melengkapi panggilan sistem kunci yang dibuat oleh G1. </font><font style="vertical-align: inherit;">Pada titik ini, G1 dapat kembali ke LRQ dan dilayani lagi oleh P. M1 lalu disisihkan untuk penggunaan di masa mendatang jika skenario ini harus diulang.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="gambar"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja mencuri</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aspek lain dari penjadwal adalah bahwa ia adalah perencana pencurian goroutine. Ini membantu dalam beberapa bidang untuk mendukung perencanaan yang efektif. Pertama, hal terakhir yang Anda butuhkan adalah agar M pergi ke keadaan siaga, karena begitu ini terjadi, OS akan mengganti M dari kernel menggunakan konteks. Ini berarti bahwa P tidak dapat melakukan pekerjaan apa pun, bahkan jika ada Goroutine dalam keadaan sehat, sampai M beralih kembali ke kernel. Pencurian Gorutin juga membantu menyeimbangkan interval waktu antara semua Ps sehingga pekerjaan lebih baik didistribusikan dan dilakukan lebih efisien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gambar, kami memiliki program Go multi-threaded dengan dua Ps masing-masing melayani empat Gs dan satu G dalam GRQ. Apa yang terjadi jika salah satu P dengan cepat melayani semua G-nya?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, P1 tidak lagi memiliki goroutine untuk dieksekusi. Tetapi ada goroutine dalam kondisi kerja, baik di LRQ untuk P2, dan di GRQ. Ini adalah momen ketika P1 perlu mencuri goroutine. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aturan untuk mencuri goroutine adalah sebagai berikut. Semua kode dapat dilihat di sumber runtime.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, berdasarkan aturan-aturan ini, P1 harus memeriksa P2 untuk keberadaan goroutine di LRQ-nya dan mengambil setengah dari apa yang ditemukannya. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi jika P2 selesai melayani semua programnya dan P1 tidak memiliki yang tersisa di LRQ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 telah menyelesaikan semua pekerjaannya dan sekarang harus mencuri goroutin. </font><font style="vertical-align: inherit;">Pertama, dia akan melihat LRQ P1, tetapi tidak akan menemukan Goroutine. </font><font style="vertical-align: inherit;">Selanjutnya dia akan melihat GRQ. </font><font style="vertical-align: inherit;">Di sana ia akan menemukan G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 mencuri G9 dari GRQ dan mulai melakukan pekerjaan itu. </font><font style="vertical-align: inherit;">Apa yang baik tentang semua pencurian ini adalah memungkinkan M untuk tetap sibuk dan tidak menjadi tidak aktif.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="gambar"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh praktis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan mekanika dan semantik, saya ingin menunjukkan kepada Anda bagaimana semua ini bersatu sehingga penjadwal Go dapat melakukan lebih banyak pekerjaan seiring waktu. Bayangkan aplikasi multi-utas yang ditulis dalam C, di mana program mengelola dua utas OS yang saling mengirim pesan. Ada 2 utas dalam gambar yang mengirim pesan bolak-balik. Utas 1 menerima konteks-switched inti 1 dan sekarang berjalan, yang memungkinkan utas 1 untuk mengirim pesannya ke utas 2.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, ketika utas 1 selesai mengirim pesan, sekarang ia harus menunggu jawaban. Ini akan menyebabkan utas 1 terputus dari konteks kernel 1 dan dimasukkan ke dalam status menunggu. Segera setelah utas 2 menerima pemberitahuan pesan, ia masuk ke kondisi sehat. Sekarang OS dapat melakukan sakelar konteks dan menjalankan utas 2 pada kernel, yang ternyata adalah kernel 2. Kemudian utas 2 memproses pesan dan mengirim pesan baru kembali ke utas 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, aliran beralih kembali ke konteks ketika pesan dari aliran 2 diterima oleh aliran 1. Sekarang, aliran 2 beralih dari status run ke status tunggu, dan streaming 1 beralih dari status siaga ke status siap dan akhirnya kembali ke status jalankan, yang memungkinkannya memproses dan mengirim pesan baru kembali. Semua konteks ini beralih dan perubahan status membutuhkan waktu untuk diselesaikan, yang membatasi kecepatan pekerjaan. Karena setiap saklar konteks memerlukan penundaan ~ 1000 nanodetik, dan kami berharap perangkat keras mengeksekusi 12 instruksi per nanodetik, Anda melihat 12.000 instruksi yang kurang lebih tidak dieksekusi selama sakelar konteks ini. Karena aliran ini juga berpotongan antara inti yang berbeda,Kemungkinan tambahan keterlambatan cache-line juga tinggi.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gambar ada dua gorutins yang selaras satu sama lain, menyampaikan pesan bolak-balik. G1 mendapatkan saklar konteks M1, yang berjalan pada Core 1, yang memungkinkan G1 untuk melakukan tugasnya. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut, ketika G1 selesai mengirim pesan, sekarang dia perlu menunggu jawaban. Ini akan menyebabkan G1 terputus dari konteks M1 dan dimasukkan ke dalam status siaga. Segera setelah G2 diberitahu tentang pesan tersebut, pesan tersebut masuk ke kondisi sehat. Sekarang penjadwal Go dapat melakukan pengalihan konteks dan menjalankan G2 pada M1, yang masih berjalan pada Core 1. Kemudian G2 memproses pesan dan mengirim pesan baru kembali ke G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada langkah berikutnya, semuanya beralih lagi ketika pesan yang dikirim oleh G2 diterima oleh G1. Sekarang, konteks G2 beralih dari status eksekusi ke status tunggu, dan konteks G1 beralih dari status tunggu ke status eksekusi dan, akhirnya, kembali ke status eksekusi, yang memungkinkannya memproses dan mengirim pesan baru kembali. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal-hal di permukaan tampaknya tidak berbeda. Semua perubahan konteks yang sama dan perubahan status terjadi terlepas dari apakah Anda menggunakan Streaming atau Goroutine. Namun, ada perbedaan besar antara penggunaan Streams dan Gorutin, yang mungkin tidak jelas pada pandangan pertama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika goroutine digunakan, utas dan kernel OS yang sama digunakan untuk semua pemrosesan. Ini berarti bahwa dari sudut pandang OS, OS Flow tidak pernah masuk ke kondisi menunggu; tidak pernah. Akibatnya, semua instruksi yang kami hilangkan saat mengalihkan konteks saat menggunakan stream tidak hilang saat menggunakan goroutin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada dasarnya, Go mengubah pekerjaan IO / Blocking menjadi pekerjaan yang terikat prosesor di level OS. Karena semua peralihan konteks terjadi pada tingkat aplikasi, kami tidak kehilangan yang sama ~ 12 ribu instruksi (rata-rata) pada peralihan konteks yang kami kehilangan saat menggunakan stream. Di Go, switch konteks yang sama menghabiskan biaya ~ 200 nanodetik atau ~ 2,4 ribu perintah. Penjadwal juga membantu meningkatkan kinerja caching string dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Itu sebabnya kami tidak membutuhkan lebih banyak utas daripada kami memiliki inti virtual. </font><font style="vertical-align: inherit;">Go dapat melakukan lebih banyak pekerjaan seiring waktu, karena penjadwal Go mencoba menggunakan lebih sedikit utas dan melakukan lebih banyak pada setiap utas, yang membantu mengurangi beban pada OS dan perangkat keras.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Scheduler benar-benar luar biasa dalam hal memperhitungkan kerumitan OS dan perangkat keras. Kemampuan untuk mengubah operasi I / O / mengunci menjadi operasi yang terikat prosesor pada tingkat sistem operasi adalah tempat kami memperoleh keuntungan besar dalam menggunakan lebih banyak daya prosesor dari waktu ke waktu. Inilah sebabnya mengapa Anda tidak membutuhkan lebih banyak utas OS daripada Anda memiliki kernel virtual. Anda dapat dengan wajar berharap bahwa semua pekerjaan Anda akan selesai (dengan penjilidan CPU dan I / O / kunci) dengan satu utas OS per kernel virtual. Ini dimungkinkan untuk aplikasi jaringan dan aplikasi lain yang tidak memerlukan panggilan sistem yang memblokir utas OS.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai pengembang, Anda harus tetap memahami apa yang aplikasi Anda lakukan dalam hal jenis pekerjaan. </font><font style="vertical-align: inherit;">Anda tidak dapat membuat goroutine dalam jumlah tak terbatas dan mengharapkan kinerja luar biasa. </font><font style="vertical-align: inherit;">Less selalu lebih, tetapi dengan pemahaman semantik penjadwal Go ini, Anda dapat membuat keputusan rekayasa yang lebih baik.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489852/index.html">Otentikasi transparan di ASP.Net Core di Linux</a></li>
<li><a href="../id489854/index.html">Redux vs MobX tanpa kebingungan</a></li>
<li><a href="../id489856/index.html">Banach-Tarski membalikkan paradoks atau cara mengurangi volume data yang disimpan sebanyak lima kali</a></li>
<li><a href="../id489858/index.html">Internasionalisasi: Membuat Web Dapat Diakses oleh Semua Orang</a></li>
<li><a href="../id489860/index.html">Sejarah Telefunken: phoenix elektronik Jerman dari Wilhelm II dan Goebbels to the Beatles dan hari ini</a></li>
<li><a href="../id489868/index.html">Membekukan Mozilla WebThings</a></li>
<li><a href="../id489870/index.html">Offline offline gratis oleh Node.js di Nizhny Novgorod</a></li>
<li><a href="../id489872/index.html">Bagaimana sistem DLP dan modul OCR mencegah karyawan memalsukan pemindaian paspor</a></li>
<li><a href="../id489874/index.html">Cross compiling Rust untuk executable Windows dari Linux</a></li>
<li><a href="../id489876/index.html">Bagaimana kami memecahkan masalah tiga monolit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>