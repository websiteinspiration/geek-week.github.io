<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìá üö£üèæ üèåÔ∏è Tabla hash simple para GPU üöè üß° üèîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publiqu√© en Github un nuevo proyecto llamado A Simple GPU Hash Table . 
 
 Esta es una tabla hash simple para la GPU, capaz de procesar cientos de mil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tabla hash simple para GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Publiqu√© en Github un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo proyecto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> llamado </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una tabla hash simple para la GPU, capaz de procesar cientos de millones de insertos por segundo. </font><font style="vertical-align: inherit;">En mi computadora port√°til con una NVIDIA GTX 1060, el c√≥digo inserta 64 millones de pares clave-valor generados aleatoriamente en aproximadamente 210 ms y elimina 32 millones de pares en aproximadamente 64 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, la velocidad en la computadora port√°til es de aproximadamente 300 millones de insertos / segundo y 500 millones de extracciones / segundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tabla est√° escrita en CUDA, aunque la misma t√©cnica se puede aplicar a HLSL o GLSL. </font><font style="vertical-align: inherit;">La implementaci√≥n tiene varias limitaciones que aseguran un alto rendimiento en la tarjeta de video:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo se procesan claves de 32 bits y los mismos valores.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tabla hash tiene un tama√±o fijo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y este tama√±o debe ser igual a dos en grado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para claves y valores, debe reservar un marcador de delimitaci√≥n simple (en el c√≥digo anterior es 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesa hash sin cerraduras</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tabla hash utiliza direccionamiento abierto con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detecci√≥n lineal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, es solo una matriz de pares clave-valor que se almacena en la memoria y tiene un excelente rendimiento de cach√©. </font><font style="vertical-align: inherit;">Este no es el caso con el encadenamiento, lo que significa buscar un puntero en una lista vinculada. </font><font style="vertical-align: inherit;">Una tabla hash es una matriz simple que almacena elementos </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tama√±o de la tabla es igual a dos en potencia, y no un n√∫mero primo, porque para usar la m√°scara pow2 / AND, una instrucci√≥n r√°pida es suficiente y el operador del m√≥dulo es mucho m√°s lento. Esto es importante en el caso de la detecci√≥n lineal, ya que en una b√∫squeda lineal en la tabla, el √≠ndice de la ranura debe estar envuelto en cada ranura. Y como resultado, el costo de la operaci√≥n se agrega m√≥dulo en cada ranura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tabla almacena solo la clave y el valor de cada elemento, no el hash de la clave. Dado que la tabla solo almacena claves de 32 bits, el hash se calcula muy r√°pidamente. El c√≥digo anterior usa el hash Murmur3, que realiza solo unos pocos cambios, XOR y multiplicaciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tabla hash utiliza una t√©cnica de protecci√≥n de bloqueo que no depende del orden de colocaci√≥n de la memoria. Incluso si algunas operaciones de escritura violan el orden de otras operaciones, la tabla hash seguir√° manteniendo el estado correcto. Hablaremos de esto a continuaci√≥n. La t√©cnica funciona muy bien con tarjetas de video en las que compiten miles de hilos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las claves y los valores en la tabla hash se inicializan para vaciarse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo puede modificarse para que pueda procesar claves y valores de 64 bits. Las claves requieren operaciones de lectura, escritura e intercambio at√≥micas (comparar e intercambiar). Y los valores requieren operaciones de lectura y escritura at√≥micas. Afortunadamente, en CUDA, las operaciones de lectura y escritura para valores de 32 y 64 bits son at√≥micas siempre que est√©n alineadas de forma natural (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), y las tarjetas de video modernas admiten operaciones at√≥micas de 64 bits de comparaci√≥n con intercambio. </font><font style="vertical-align: inherit;">Por supuesto, al cambiar a 64 bits, el rendimiento disminuir√° ligeramente.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado de la tabla hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada par clave-valor en una tabla hash puede tener uno de cuatro estados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clave y el significado est√°n vac√≠os. </font><font style="vertical-align: inherit;">En este estado, la tabla hash se inicializa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clave ha sido registrada, pero el valor a√∫n no. </font><font style="vertical-align: inherit;">Si otro hilo de ejecuci√≥n est√° leyendo datos en ese momento, entonces devuelve un valor vac√≠o. </font><font style="vertical-align: inherit;">Esto es normal, lo mismo suceder√≠a si otro hilo de ejecuci√≥n funcionara un poco antes, y estamos hablando de una estructura de datos competitiva.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se registran tanto la clave como el valor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor est√° disponible para otros hilos de ejecuci√≥n, pero la clave a√∫n no lo est√°. </font><font style="vertical-align: inherit;">Esto puede suceder porque el modelo de programaci√≥n CUDA implica un modelo de memoria mal ordenado. </font><font style="vertical-align: inherit;">Esto es normal; en cualquier caso, la clave todav√≠a est√° vac√≠a, incluso si el valor ya no es tal.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un matiz importante es que tan pronto como la clave se ha escrito en la ranura, ya no se mueve, incluso si se elimina la clave, hablaremos de esto a continuaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo de tabla hash incluso funciona con modelos de memoria mal ordenados que no conocen el orden de lectura y escritura en la memoria. </font><font style="vertical-align: inherit;">Cuando analizamos la inserci√≥n, la b√∫squeda y la eliminaci√≥n en la tabla hash, recuerde que cada par clave-valor se encuentra en uno de los cuatro estados descritos anteriormente.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertar en una tabla hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una funci√≥n CUDA que inserta pares clave-valor en una tabla hash se ve as√≠:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para insertar una clave, el c√≥digo itera sobre la matriz de la tabla hash comenzando con el hash de la clave insertada. En cada ranura de la matriz, se realiza una operaci√≥n de comparaci√≥n at√≥mica con el intercambio, en el que la clave en esta ranura se compara con una vac√≠a. Si se detecta una falta de coincidencia, la clave en la ranura se actualiza a la clave insertada y luego se devuelve la clave original de la ranura. Si esta clave original estaba vac√≠a o correspond√≠a a la clave insertada, entonces el c√≥digo encontr√≥ una ranura adecuada para la inserci√≥n y trae el valor insertado a la ranura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si en una llamada del n√∫cleo</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay varios elementos con la misma clave, entonces cualquiera de sus valores se puede escribir en la ranura de la clave. </font><font style="vertical-align: inherit;">Esto se considera normal: una de las operaciones de escritura de valores clave durante la llamada ser√° exitosa, pero dado que todo esto sucede en paralelo dentro de varios hilos de ejecuci√≥n, no podemos predecir qu√© operaci√≥n de escritura en la memoria ser√° la √∫ltima.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√∫squeda de tabla hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥digo del buscador clave:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para encontrar el valor de la clave almacenada en la tabla, iteramos sobre la matriz comenzando con el hash de la clave deseada. </font><font style="vertical-align: inherit;">En cada ranura, verificamos si la clave es la que estamos buscando y, de ser as√≠, devolvemos su valor. </font><font style="vertical-align: inherit;">Tambi√©n verificamos si la clave est√° vac√≠a, y si es as√≠, interrumpimos la b√∫squeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no podemos encontrar la clave, entonces el c√≥digo devuelve un valor vac√≠o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas estas operaciones de b√∫squeda se pueden realizar de manera competitiva durante las inserciones y eliminaciones. </font><font style="vertical-align: inherit;">Cada par de la tabla tendr√° uno de los cuatro estados descritos anteriormente para la secuencia.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminaci√≥n de tabla hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥digo de eliminaci√≥n de clave:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eliminar una clave es inusual: dejamos la clave en la tabla y marcamos su valor (no la clave en s√≠) vac√≠a. </font><font style="vertical-align: inherit;">Este c√≥digo es muy similar </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, excepto que cuando se encuentra una coincidencia para la clave, hace que su valor est√© vac√≠o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se mencion√≥ anteriormente, una vez que la clave se escribe en la ranura, ya no se mueve. </font><font style="vertical-align: inherit;">Incluso cuando elimina un elemento de la tabla, la clave permanece en su lugar, solo su valor se vac√≠a. </font><font style="vertical-align: inherit;">Esto significa que no necesitamos usar la operaci√≥n at√≥mica de escribir el valor de la ranura, porque no importa si el valor actual est√° vac√≠o o no, seguir√° estando vac√≠o.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar el tama√±o de una tabla hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede cambiar el tama√±o de la tabla hash creando una tabla m√°s grande e insertando elementos no vac√≠os de la tabla anterior. </font><font style="vertical-align: inherit;">No implement√© esta funcionalidad porque quer√≠a mantener el c√≥digo de muestra simple. </font><font style="vertical-align: inherit;">Adem√°s, en los programas CUDA, la asignaci√≥n de memoria a menudo se realiza en el c√≥digo del host y no en el n√∫cleo CUDA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art√≠culo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A A-Lock-Wait Wait-Free Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> describe c√≥mo cambiar dicha estructura de datos protegida con bloqueo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Competitividad</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los fragmentos anteriores de c√≥digo, las funciones </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proceso de un solo par clave-valor a la vez. </font><font style="vertical-align: inherit;">Y a continuaci√≥n </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">procesan una serie de pares en paralelo, cada par en un hilo GPU separada de ejecuci√≥n:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una tabla hash bloqueable admite inserciones, b√∫squedas y eliminaciones concurrentes. Dado que los pares clave-valor siempre est√°n en uno de los cuatro estados, y las claves no se mueven, la tabla garantiza la correcci√≥n incluso cuando se utilizan diferentes tipos de operaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, si procesamos un paquete de inserciones y eliminaciones en paralelo, y si hay claves duplicadas en la matriz de entrada de pares, entonces no podremos predecir qu√© pares "ganar√°n": se escribir√°n en la tabla hash en √∫ltimo lugar. Supongamos que llamamos un c√≥digo de inserci√≥n con una matriz de entrada de pares </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cuando se completa el c√≥digo, los pares </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y est√°n </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garantizados para estar presentes en la tabla, pero al mismo tiempo cualquiera de los pares aparecer√° en ella </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto puede o no ser un problema, todo depende de la aplicaci√≥n. Puede saber de antemano que no hay claves duplicadas en la matriz de entrada, o puede que no le importe qu√© valor se escribi√≥ por √∫ltima vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si esto es un problema para usted, entonces necesita dividir los pares duplicados en diferentes llamadas CUDA del sistema. En CUDA, cualquier operaci√≥n de llamada al n√∫cleo siempre finaliza antes de la siguiente llamada del n√∫cleo (al menos dentro del mismo hilo. En diferentes hilos, el n√∫cleo se ejecuta en paralelo). Si en el ejemplo anterior, llame a un n√∫cleo con </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y al otro con </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces la clave </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtendr√° un valor </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora hablemos sobre si la funci√≥n </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uso de un puntero simple (simple) o variable (vol√°til) a una matriz de pares en una tabla hash.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La documentaci√≥n de CUDA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> establece que:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El compilador puede, a su discreci√≥n, optimizar las operaciones de lectura y escritura en la memoria global o compartida ... Estas optimizaciones pueden deshabilitarse usando la palabra clave </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... cualquier enlace a esta variable se compila en una instrucci√≥n real de lectura o escritura en la memoria.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las consideraciones de correcci√≥n no requieren aplicaci√≥n </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si el hilo de ejecuci√≥n usa el valor almacenado en cach√© de una operaci√≥n de lectura anterior, entonces esto significa que usar√° informaci√≥n un poco desactualizada. </font><font style="vertical-align: inherit;">Pero a√∫n as√≠, esta es informaci√≥n del estado correcto de la tabla hash en un cierto punto de la llamada del kernel. </font><font style="vertical-align: inherit;">Si necesita usar la informaci√≥n m√°s reciente, puede usar el puntero </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero luego el rendimiento disminuir√° ligeramente: seg√∫n mis pruebas, cuando elimina 32 millones de elementos, la velocidad disminuye de 500 millones de eliminaci√≥n / seg a 450 millones de eliminaci√≥n / seg.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuaci√≥n</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la prueba para insertar 64 millones de elementos y eliminar 32 millones de ellos, </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√°cticamente no hay </font><font style="vertical-align: inherit;">competencia entre </font><font style="vertical-align: inherit;">y la tabla hash para la GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas√≥ 70 691 ms en la inserci√≥n y eliminaci√≥n de elementos con la liberaci√≥n posterior </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la liberaci√≥n de millones de elementos lleva mucho tiempo, ya que </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se realizan numerosas asignaciones de memoria en el </font><font style="vertical-align: inherit;">interior </font><font style="vertical-align: inherit;">). Honestamente, hay </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitaciones completamente diferentes. Este es un √∫nico subproceso de ejecuci√≥n de la CPU, admite valores clave de cualquier tama√±o, funciona bien a altas tasas de utilizaci√≥n y muestra un rendimiento estable despu√©s de numerosas eliminaciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La duraci√≥n de la tabla hash para la GPU y la comunicaci√≥n entre programas fue de 984 ms. Esto incluye el tiempo necesario para colocar la tabla en la memoria y eliminarla (asignaci√≥n √∫nica de 1 GB de memoria, que lleva algo de tiempo en CUDA), insertar y eliminar elementos, y tambi√©n iterar sobre ellos. Tambi√©n se tiene en cuenta toda la copia desde y hacia la memoria de la tarjeta de video. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La propia tabla hash tom√≥ 271 ms. Esto incluye el tiempo empleado por la tarjeta de video para insertar y eliminar elementos, y no tiene en cuenta el tiempo que lleva copiar en la memoria e iterar sobre la tabla resultante. Si la tabla GPU dura mucho tiempo, o si la tabla hash est√° contenida completamente en la memoria de la tarjeta de video (por ejemplo, para crear una tabla hash que ser√° utilizada por otro c√≥digo GPU y no por el procesador central), el resultado de la prueba es relevante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tabla hash para la tarjeta de video muestra un alto rendimiento debido a su gran ancho de banda y paralelizaci√≥n activa.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desventajas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La arquitectura de la tabla hash tiene varios problemas a tener en cuenta:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agrupamiento interfiere con el sondeo lineal, por lo que las claves en la tabla est√°n lejos de ser ideales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las teclas no se eliminan mediante la funci√≥n </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y con el tiempo desordenan la tabla.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, el rendimiento de la tabla hash puede disminuir gradualmente, especialmente si existe durante mucho tiempo y se realizan numerosas inserciones y eliminaciones. </font><font style="vertical-align: inherit;">Una forma de mitigar estas deficiencias es volver a mostrar una nueva tabla con una tasa de utilizaci√≥n bastante baja y filtrar las claves remotas al volver a mostrar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ilustrar los problemas descritos, utilizo el c√≥digo anterior para crear una tabla para 128 millones de elementos, insertar√© c√≠clicamente 4 millones de elementos hasta llenar 124 millones de espacios (la utilizaci√≥n es de aproximadamente 0,96). </font><font style="vertical-align: inherit;">Aqu√≠ est√° la tabla de resultados, cada fila es una llamada al n√∫cleo de CUDA con la inserci√≥n de 4 millones de elementos nuevos en una tabla hash:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasa de uso </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duraci√≥n de inserci√≥n 4 194 304 elementos</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.608448 ms (361.314798 millones de claves / seg.)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A medida que aumenta la utilizaci√≥n, disminuye la productividad. Esto no es deseable en la mayor√≠a de los casos. Si una aplicaci√≥n inserta elementos en una tabla y luego los descarta (por ejemplo, al contar palabras en un libro), entonces esto no es un problema. Pero si la aplicaci√≥n utiliza una tabla hash de larga duraci√≥n (por ejemplo, en un editor de gr√°ficos para almacenar partes de im√°genes no vac√≠as cuando el usuario a menudo inserta y elimina informaci√≥n), este comportamiento puede ser problem√°tico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y midi√≥ la profundidad de sondear la tabla hash despu√©s de 64 millones de inserciones (factor de utilizaci√≥n 0.5). La profundidad promedio fue de 0.4774, por lo que la mayor√≠a de las teclas se ubicaron en la mejor ranura posible o en una ranura desde la mejor posici√≥n. La profundidad m√°xima de sondeo fue de 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego med√≠ la profundidad de sondeo en la tabla con 124 millones de insertos (tasa de utilizaci√≥n 0.97). La profundidad promedio ya era 10.1757, y la m√°xima - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). El rendimiento del sonido lineal cae dr√°sticamente a altas tasas de utilizaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es mejor mantener baja esta tabla hash. Pero luego aumentamos la productividad al consumir memoria. Afortunadamente, en el caso de claves y valores de 32 bits, esto puede justificarse. Si en el ejemplo anterior en la tabla para 128 millones de elementos se guarda el coeficiente de utilizaci√≥n de 0.25, entonces no podemos colocar m√°s de 32 millones de elementos en √©l, y se perder√°n los 96 millones de ranuras restantes: 8 bytes por cada par, 768 MB de memoria perdida.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que estamos hablando de la p√©rdida de memoria de la tarjeta de video, que es un recurso m√°s valioso que la memoria del sistema. </font><font style="vertical-align: inherit;">Aunque la mayor√≠a de las tarjetas gr√°ficas de escritorio modernas que admiten CUDA tienen al menos 4 GB de memoria (al momento de escribir, NVIDIA 2080 Ti tiene 11 GB), perder esos vol√∫menes no ser√° la mejor decisi√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√°s adelante, escribir√© m√°s sobre la creaci√≥n de tablas hash para tarjetas de video que no tengan problemas con la profundidad del sonido, as√≠ como las formas de reutilizar las ranuras remotas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medici√≥n de profundidad de detecci√≥n</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para determinar la profundidad del sonido de la clave, podemos extraer el hash de la clave (su √≠ndice ideal en la tabla) de su √≠ndice de tabla real:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido a la magia de dos n√∫meros binarios en el c√≥digo adicional y al hecho de que la capacidad de la tabla hash es igual a dos en potencia, este enfoque funcionar√° incluso cuando el √≠ndice clave se mueva al comienzo de la tabla. </font><font style="vertical-align: inherit;">Tome una clave que est√° dividida en 1 pero insertada en la ranura 3. Luego, para una tabla con capacidad 4 obtenemos </font></font><code>(3 ‚Äî 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo que es equivalente a 2.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tiene preguntas o comentarios, escr√≠bame en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o abra un nuevo tema en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c√≥digo est√° inspirado en algunos excelentes art√≠culos:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tabla de hash sin bloqueo m√°s simple del mundo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una tabla de hash sin bloqueo y sin espera</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el futuro, continuar√© escribiendo sobre implementaciones de tablas hash para tarjetas de video y analizar√© su rendimiento. </font><font style="vertical-align: inherit;">Tengo planes de encadenar, hash Robin Hood y cuckoo hash utilizando operaciones at√≥micas en estructuras de datos que sean convenientes para tarjetas de video.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es492540/index.html">El juego "¬°Espera un momento!" en arduino</a></li>
<li><a href="../es492546/index.html">Comprobaci√≥n de la vulnerabilidad de cualquier sitio que use Nikto</a></li>
<li><a href="../es492548/index.html">Aprendizaje autom√°tico de Unity: ense√±ar a los agentes de MO a saltar por encima de las paredes</a></li>
<li><a href="../es492552/index.html">C√≥mo vivir y trabajar en cuarentena en Barcelona</a></li>
<li><a href="../es492558/index.html">Hola, esto es COVID19: ¬øEl coronavirus vive en la superficie de un tel√©fono inteligente?</a></li>
<li><a href="../es492562/index.html">Tres √∫tiles webinars de Apache Ignite en su programa de cuarentena</a></li>
<li><a href="../es492566/index.html">An√°lisis de la combinaci√≥n de un algoritmo de b√∫squeda de clic codicioso con enumeraci√≥n parcial de v√©rtices de gr√°ficos</a></li>
<li><a href="../es492568/index.html">Obtenga un extracto de Rosreestr a trav√©s de FSIS USRN y python. Parte 2</a></li>
<li><a href="../es492572/index.html">El estado actual del mundo Java: tendencias y hechos para uno de los lenguajes de programaci√≥n m√°s populares</a></li>
<li><a href="../es492574/index.html">Reflexiones sobre la probabilidad de despegue: Apple AirPods con Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>