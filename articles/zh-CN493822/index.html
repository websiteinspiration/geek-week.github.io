<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 👐🏼 🚕 UEFI在各种平台上实施的问题和功能 👩🏼‍🎤 👌🏽 💽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自2000年发布第一个EFI规范以来，已经过去了十九年。该界面花了十年时间才进入用户市场并获得了立足点。目前，您几乎看不到主板固件中没有UEFI的现代计算机。接口标准在官方文档中增加了“内容”和数千页。对于普通用户，除了偶尔启用了安全启动的冲突之外，什么都没有改变。但是，如果工作面转向发展，一切都会...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>UEFI在各种平台上实施的问题和功能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gaz-is/blog/493822/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自2000年发布第一个EFI规范以来，已经过去了十九年。该界面花了十年时间才进入用户市场并获得了立足点。目前，您几乎看不到主板固件中没有UEFI的现代计算机。接口标准在官方文档中增加了“内容”和数千页。对于普通用户，除了偶尔启用了安全启动的冲突之外，什么都没有改变。但是，如果工作面转向发展，一切都会变得更加有趣。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1f/ek/as/1fekaswnox-diqt-hgzmaiqnq4g.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UEFI模块化体系结构的概念本身就意味着这些模块不仅可以在标准配置中使用，还可以下载自己的模块。文件系统驱动程序（不限于原生eFi-shy FAT？），外围设备驱动程序，应用程序，引导加载程序-您可以手动加载所有内容，最好加载一些Shell。您可以更“深入”一步，查看固件的内容，从而避免自己因使用SecureBoot而舞动，也无需编写脚本层（集线器页面上有足够的文章）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此基础上，产生了在加载操作系统之前创建执行各种安全功能的功能模块的想法，该功能模块可以进一步结合并成为一种集成的受信任的引导环境，从而影响引导和运行时接口的服务，从而使固件中的模块与磁盘上的模块之间相互兼容。没有低水平的干预，只有得到安全管理员的允许，才能“推动”任何事情。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个想法的实现使我们了解到UEFI的许多细微差别和微妙之处-从许多未记录的或记录不充分的功能，错误开始，到所有开发人员都钟爱的未定义行为结束。</font><font style="vertical-align: inherit;">让我们按顺序开始。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平台依赖</font></font></h4><br>
<img src="https://habrastorage.org/webt/wn/pz/1f/wnpz1fwi6hrqqhoogamysefkdic.png" width="770"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在集成到平台中时，首先需要了解的是我们是否可以使用它？ UEFI规范的版本很重要，在大多数设备上，它的显示范围是2.1到2.7。较新的产品尚未投放市场。发现了较旧的版本，由于缺少必要的协议或弯曲的编写驱动程序以实现其性能，因此其性能可能受到限制。例如，UnicodeCollat​​ion通常是不够的，当访问smbios时，存在未记录的错误，通过SetVariable（）进行的语言更改功能不起作用。任何事情都可能发生，这取决于供应商和新鲜程度，因为有时您甚至必须将协议放在相对较新的板上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使在我们的实践中，我也很幸运地偶然发现了两台装有Intel Bay Trail D和32位固件的小型计算机。这种情况很少见，但有一次需要紧急重新编译模块。实际上，就像问题一样：将来我们会不会遇到具有相同容量的更现代的平台？如果我们见面，那在哪里？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是确定如何集成。模块内置在固件中，固件位于主板上的SPI芯片中，带有Intel ME的PCH位于附近。这里出现了最有趣的问题-如何到达那里？好的老程序员带着“鳄鱼”-这很好，很可靠。即使您没有赶上最后，也可以随时查看板上的发光LED，它们有足够的电量来自程序员。除某些较旧的HP型号外，它几乎可以完美地工作，带有固件的mikruha SOIC-16十分容易取用，因此，将适配器设计和焊接到她的腿上比挤压夹子更容易。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/uu/ce/6b/uuce6bumbvwdovmxow0ntfoeynm.png" width="770"><br>
<img src="https://habrastorage.org/webt/qj/kf/k1/qjkfk14esp5_ol1vchn8fkaiwt4.png" width="770"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我知道在哈布雷（Habré）上有一些人为flashrom的写作做出了贡献，这要归功于他们。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，尽管程序员可以可靠地进行转储删除，但是如果您需要在多台计算机上的UEFI中安装某些内容，或者如果您的桌面上没有安装目标平台，则此方法不适合。对我们来说幸运的是，制造商留下了本机固件实用程序：英特尔（CS）ME系统工具套件中的FPT（闪存编程工具），以及American Megatrends中Aptio的AFU（AMI固件更新）。这些实用程序是从EFI环境以及Windows，Linux和DOS操作系统启动的。这些实用程序在某种程度上是可以互换的，两者都可以使您确定图像，即使不是整个图像，也可以是某些区域。有时他们甚至会让您回信。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/hk/vz/pp/hkvzppckxwb02epv3ieytikh5y0.png" width="770"><br>
<img src="https://habrastorage.org/webt/we/qx/3y/weqx3ysvpinegiv9gxh9biw7xdg.png" width="770"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他写，不写</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是整合路径上第一个严重的绊脚石出现的地方。并非所有主板都允许您读取整个固件，从而</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁止访问</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ME区域（ME几乎是神圣的，Intel不允许以良好的方式读取它，但是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以糟糕的方式，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们并不总是希望</font><font style="vertical-align: inherit;">读取</font><font style="vertical-align: inherit;">）。甚至更少-甚至将一些东西倒入BIOS区域，除非它是一个带符号的胶囊。成功的可能性取决于芯片组的制造商和新鲜程度而有很大差异。在某些型号的主板上，您会看到一张有趣的图片：旧供应商板上未记录的图片在新时代飞逝。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有时</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">IFR解析器</font></a><font style="vertical-align: inherit;">有助于对抗写保护</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这为隐藏的设置和变量打开了帷幕。</font><font style="vertical-align: inherit;">有时，只有硬核跳线才有帮助，允许访问录音或“关闭” ME（如果提供的话）。</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统的复杂性</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大多数情况下，Acer，Asus，AsRock和技嘉主板的编写都没有不必要的困难。</font><font style="vertical-align: inherit;">英特尔，惠普和服务器硬件脱颖而出。</font><font style="vertical-align: inherit;">HP不仅不允许以编程方式自行编写，而且还承诺任何尝试修改固件（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CodeRush</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于查找和禁用完整性检查的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。英特尔或多或少地记录了第87个芯片组，然后对打开BIOS区域门的要求充耳不闻。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于英特尔，第一次很有趣。使用UEFITool实用程序将模块导入到固件中，我们遇到了一个有趣的错误：如果在所有自由格式之后在DXE卷的末尾插入ffs模块，则组装后的图像会使面板“变砖”。解决方案是在任何本机DXE驱动程序之后添加模块。我们并没有立即解决这个问题，起初看起来像是英特尔正在监视固件的完整性，例如HP。后来很明显，没有自动导入模块的实用程序是无法做到的，编写此问题后问题就消失了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，服务器端硬件更简单，更复杂。一方面，总有其他方法可以更新和修改服务器上的BIOS，另一方面，这些相同的BIOS中的自定义量非常庞大，因为它们不会在服务器上跳过并安装容量非常大的闪存芯片，并且通常还会对其进行备份。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在服务器上安装时，能够通过IPMI远程更新BIOS总是很高兴。没错，为此，您需要一个许可证，当然要付费。如果未在正确的时间出现，很可能会陷入一种类似于我们在Supermicro服务器BIOS中引入模块的情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引入模块后，由于安全模块之一的阻塞，负载被紧紧冻结（它们没有考虑服务器BIOS的笨拙行为，因此不会发生这种情况！）。在没有能力通过IPMI来回滚BIOS的情况下，这只手对程序员来说是很困难的，但是运气不好-标准的SOIC-8夹不足以用于SOIC-16芯片！好吧，因为在理论上服务器主板可以从连接的媒体进行备份，因此可以从根目录中提取SUPER.ROM映像。但是这种机制无法启动，因为根据系统，一切正常，一切正常，因此不需要BIOS回滚！该怎么办？！..故事最终在城市中流传，以寻找正确的剪辑，紧急重新焊接电线，中国人以一种难以理解的顺序涂抹了我们，最后-闪烁着。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
联想出来更有趣。在从供应商处收到的交换机上，在外壳的下面发现一个控制板，带有两个用于固件的“ mikruh”，一个用于操作系统的SSD和一个固定电池。事实证明，BIOS是一个棘手的问题，我不想以任何方式吃掉修改过的映像，只屈从于程序员。在尝试写下一些东西的过程中，他们将带有控制台ubuntu的闪存驱动器插入到交换机中（终端未提供图形），并非常安全地启动。完成所需的操作后，他们使用旧内存中的halt -p命令关闭了系统。由于缺少电源，该交换机本质上不适合任何关机，因此尚未做好准备，也不想再启动。脸上的连接一次烧毁，风扇安静地沙沙作响，所有端口都没有发出声音。重新刷新没有帮助，电池像手套一样坐着-我们害怕打破固定座。结果，一块薄薄的介电板在毅力和言语激励下在触点下方爬行，擦除了易失性存储器，使开关栩栩如生。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对从两种碎屑中提取的倾销进行的研究显示出很多有趣的事情。特别是，主固件的NVRAM中有大量“无效”条目，而备份中有多个类似的条目。好吧，这不是使用DXE驱动程序在卷中以前遇到的数据哈希。一个人只能猜测启动开关问题的确切原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，软件部分很少会失去意想不到的细微差别。在第87个芯片组之前（来自不同制造商）的许多主板都具有令人不愉快的功能，当在Shell控制台中输入“ dh -v”命令时，会产生无尽的错误流。手动输入并不重要，但是在将数据收集到文件中时，不幸的是挂起。在这两种情况下，您都必须重新启动计算机。我很高兴与此同时数据文件不会膨胀到巨大的大小。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/z-/rr/_k/z-rr_k9f6o7pmt_ezbza-ysrjzw.png" width="770"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，带有华擎H81M-DGS主板的Kraftway BIOS非常任性。因此，它通过挂起来响应Ctrl Alt Del Del，只有Reset可以从中输出它。在Shell'e中跳过启动脚本&lt;startup.nsh&gt;时存在问题-一秒钟即可选择，而不是五个默认脚本。也许这些问题是由KSS专有模块的修改引起的，或者此问题是错误地“拧松了” ME。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在华硕H97-PLUS板上，固件具有以下功能-BootOrder随时间溢出。原因很可能是因为代码中的错误。尽管也许制造商希望将所有已连接的引导设备保留在板上，但并没有计算出一天内可能会有十几个引导设备。因此，当BootOrder溢出时，系统会在引导过程中挂起。要清洁它，您必须关闭所有引导设备并打开系统。固件会自行清除，系统会直接引导进入BIOS Setup Shell。性能将一直保持到下一次溢出为止。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总结与不同供应商的董事会合作的经验，您得出的结论是，即使已经采用了众所周知的模型，也几乎不可能找出您将在下一个董事会上处理的EFI级别上有什么意外之处。</font><font style="vertical-align: inherit;">这是一种彩票，因为有时在收集有关系统的信息时可能会遇到困难。</font><font style="vertical-align: inherit;">也许这对制造商有着不可磨灭的研究理想主义和信念，因为当在其上运行旧版本的FPT或MEInfo时，带有ME v11和v12的一些最新的主板又会如何挂起？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬件协议的工作问题</font></font></h4><br>
<img src="https://habrastorage.org/webt/j2/yo/ze/j2yozeg6zdyfa--juz_ycvvobbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们开始使用USB设备时，会弹出一些问题-驱动器和令牌。发生这种情况的原因通常是：与外设一起使用的BIOS代码是独立硬件供应商（IHV）针对特定外设的驱动程序和应用程序的危险混合物，芯片组制造商（在我们的情况下为Intel）的代码，BIOS制造商的代码和代码由主板制造商提供。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出现以下“有趣”情况：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
令牌“未检测到”。同时，LED点亮。最有可能的是，主机控制器没有经过USB设备的初始重置过程，也就是没有供电，但是通过更改D +和D-线进行的重置无法正常工作，并且如果没有它，使用令牌进行任何进一步的操作都是没有意义的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在装入外壳之前，计算机将冻结（再次，连接了令牌）。在这种情况下，如果没有令牌，PC将正常启动。 Live，看起来像这样：计算机似乎在启动后立即崩溃，而令牌仍在连接器中伸出。您将其取出-加载突然继续。连接-再次挂起。显而易见的问题是在UEFI中，人们只能推测其原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无法打开USB_IO接口的情况。也许它仅与用于智能卡的接口-USB CCID连接。某些AMI驱动程序已经使用EFI_OPEN_PROTOCOL_BY_DRIVER参数打开了USB_IO。驱动程序具有带有GUID的协议：</font></font><br>
<br>
<pre><code class="plaintext hljs">#define EFI_AMI_USB_CCID_PROTOCOL_GUID	 { 0x5FDEE00D, 0xDA40, 0x405A, { 0xB9, 0x2E, 0xCF, 0x4A, 0x80, 0xEA, 0x8F, 0x76} }<font></font>
 // Workaround.      EFI_OPEN_PROTOCOL_BY_DRIVER,  ,     EFI_OPEN_PROTOCOL_GET_PROTOCOL.<font></font>
 //<font></font>
 // Open USB I/O Protocol<font></font>
 //<font></font>
 Status = gBS-&gt;OpenProtocol (<font></font>
 ControllerHandle,<font></font>
 &amp;gEfiUsbIoProtocolGuid,<font></font>
 (VOID **) &amp;UsbIo,<font></font>
 This-&gt;DriverBindingHandle,<font></font>
 ControllerHandle,<font></font>
 EFI_OPEN_PROTOCOL_BY_DRIVER<font></font>
 );<font></font>
<font></font>
 if (EFI_ACCESS_DENIED == Status)<font></font>
 {		// AMI BIOS workaround (BindingStop will not be invoked)<font></font>
	 Status = gBS-&gt;OpenProtocol(<font></font>
		 ControllerHandle,<font></font>
		 &amp;gEfiUsbIoProtocolGuid,<font></font>
		 (VOID **)&amp;UsbIo,<font></font>
		 This-&gt;DriverBindingHandle,<font></font>
		 ControllerHandle,<font></font>
		 EFI_OPEN_PROTOCOL_GET_PROTOCOL<font></font>
	 );<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，不会调用BindingStop（），即设备提取事件不受监视，驱动程序将尝试使用无效的句柄。 HP Compaq Elite 8300 SFF PC和其他一些计算机已观察到这种情况。这或者是供应商对有害驱动程序的保护，还是一种常规的开发错误。也许AMI一直在朝着USB CCID的方向做一些事情，但是干扰驱动程序无法卸载，因为它与USB HID，USB MassStorage一起位于同一AMI UHCI模块中。与UninstallInterface（）相似。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或另一个有趣的功能。在未检测到令牌的UEFI BIOS之一中，USB_IO允许读取设备描述符，但EFI_INVALID_PARAMETER返回到下一个UsbBulkTransfer（）。而且，这仅在某些类型的令牌（具有绝对相同的参数）上发生，而其他令牌则运行完美。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，有趣的是，协议UsbBulkTransfer（）是在EFI_USB_IO_PROTOCOL协议中实现的。</font><font style="vertical-align: inherit;">它旨在保证无限制的时间或超时参数中指定的时间的包交付。</font><font style="vertical-align: inherit;">但是对MassStorage设备进行了一项实验：将大文件复制到USB闪存驱动器时，该文件已被删除。</font><font style="vertical-align: inherit;">PC挂紧。</font><font style="vertical-align: inherit;">连接USB闪存驱动器时，PC下垂并继续写入文件，好像什么都没发生。</font><font style="vertical-align: inherit;">令牌也有相同的情况，但有其自身的特点。</font><font style="vertical-align: inherit;">这是一个体系结构问题，在EFI中，除了计时器外没有其他中断，并且设备根据轮询进行操作。</font><font style="vertical-align: inherit;">也就是说，系统在USB轮询中的某处崩溃，但没有达到超时，当设备重新出现时，它只是继续并完成了操作。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟化</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还应该谈谈虚拟环境。当前市场上有两个支持EFI环境仿真的主要平台：VMware和VirtualBox。与“真实”系统进行交互时，两者都有其优点和缺点。 VMware环境可以充分使用NVRAM变量，但是在DXE模块初始化期间以可视方式显示消息时会迷迷糊糊：在最佳情况下，将优先考虑有关查找可引导媒体的本机消息，而忽略了我们所需的内容。相反，VirtualBox完美地呈现了所需的所有内容，但不想记住长变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VMware花园中的另一块小石头-内置的FAT32驱动程序仅支持8.3表示法的文件创建和编辑。</font><font style="vertical-align: inherit;">目前尚不清楚为什么要这样做，但这显然需要引起注意。</font><font style="vertical-align: inherit;">在真实平台上可能会观察到类似的驱动程序实现，但到目前为止，我们还没有遇到过。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，在虚拟机中，固件实用程序，编程器，跳线和不舒服的芯片之间并没有共舞。</font><font style="vertical-align: inherit;">单独的ROM文件UEFITool和配置文件中的一行。</font><font style="vertical-align: inherit;">几乎是田园诗。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到底</font></font></h4><br>
<img src="https://habrastorage.org/webt/cb/qg/va/cbqgvany9ens-l7ippxwgzox9co.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自CHIPSEC的一部分请求。</font><font style="vertical-align: inherit;">他们在哪里教这些圣礼？</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，UEFI Shell中的开发和实现是一个引人入胜的创新过程。</font><font style="vertical-align: inherit;">即使在著名的领域，您也总是可以遇到新的事物。</font><font style="vertical-align: inherit;">一方面，令人鼓舞的是该标准正在制定中，另一方面，令人遗憾的是，生产者对其的具体实施过于“创造性”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要问题是而且仍然存在：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开发固件时，供应商会脱离UEFI规范。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施期间代码中的错误。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NDV代码，在集成过程中弹出。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后但并非最不重要的一点是，官方（阅读，开放）文档中没有很多内容，例如，对通过PCI设备（例如MEI，HECI）与ME通信的协议的说明。</font><font style="vertical-align: inherit;">您可以找到寄存器的描述，但不能找到命令。</font><font style="vertical-align: inherit;">找到一个GUID，但找不到其目的。</font><font style="vertical-align: inherit;">这再次使工作返回到长时间的分析，在平台上收集数据和统计数据并使用反汇编程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应该指出的是，这种情况正在缓慢但肯定会得到纠正，我想相信，标准的制定将成为相当可预测且非常令人愉快的过程的时机已经不远了。</font><b><font style="vertical-align: inherit;">
Gazinformservice LLC </font></b><b><font style="vertical-align: inherit;">
的硬件和软件保护产品小组负责人</font></b></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Onipchuk</font></font><br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493810/index.html">五年的文件识别市场密集开发</a></li>
<li><a href="../zh-CN493814/index.html">我们如何在巴塞罗那进行采访</a></li>
<li><a href="../zh-CN493816/index.html">Git指南 第1部分：有关.git目录的所有信息</a></li>
<li><a href="../zh-CN493818/index.html">Git指南 部分2：黄金法则和其他基础基础</a></li>
<li><a href="../zh-CN493820/index.html">Kubernetes负载平衡和扩展长期连接</a></li>
<li><a href="../zh-CN493826/index.html">分而治之：改善水的电解</a></li>
<li><a href="../zh-CN493828/index.html">界面如何讲述视频游戏中的故事</a></li>
<li><a href="../zh-CN493830/index.html">初级iOS开发人员在初次采访中会问什么问题</a></li>
<li><a href="../zh-CN493832/index.html">冠状病毒COVID-19分发仪表板（React + Chart.js + BootstrapTable）</a></li>
<li><a href="../zh-CN493840/index.html">评论：Asana，Jira，Bitrix-24，Trello，YouGile。你喜欢什么，什么惹恼了？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>