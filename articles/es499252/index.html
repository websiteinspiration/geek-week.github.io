<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 👸 🤚🏽 Crear un juego de carreras pseudo-tridimensional 🔩 👱🏿 🕗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando era niño, rara vez iba a salas de arcade porque realmente no las necesitaba, porque tenía juegos increíbles para C64 en casa ... pero hay tres ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Crear un juego de carreras pseudo-tridimensional</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499252/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/6e3/cff/d166e3cff9c2a3cefeb68f5c1ddc02d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando era niño, rara vez iba a salas de arcade porque realmente no las necesitaba, porque tenía juegos increíbles para C64 en casa ... pero hay tres juegos de arcade para los que siempre tuve dinero: Donkey Kong, Dragons Lair y Outrun ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y realmente me encantó Outrun: velocidad, colinas, palmeras y música, incluso en la versión débil para el C64.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/aee/56f/48eaee56f43d8a25e840c6ae13268db4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así que decidí intentar escribir un juego de carreras pseudo-tridimensional de la vieja escuela al estilo de Outrun, Pitstop o Pole position. </font><font style="vertical-align: inherit;">No planeo armar un </font><font style="vertical-align: inherit;">juego </font><font style="vertical-align: inherit;">completo y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero me parece interesante volver a examinar la mecánica con la que estos juegos realizaron sus trucos. </font><font style="vertical-align: inherit;">Curvas, colinas, sprites y una sensación de velocidad ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, aquí está mi "proyecto de fin de semana", que finalmente tardó cinco o seis semanas en el fin de semana</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/27b/d28/7ec27bd28630dbbaf7b81c87233c28ac.png"></div><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jugar un juego</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código fuente</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La versión jugable se parece más a una demostración técnica que a un juego real. </font><font style="vertical-align: inherit;">De hecho, si quieres crear una verdadera carrera pseudo-tridimensional, esta será la base más mínima que necesitas para convertir gradualmente en un juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No está pulido, es un poco feo, pero completamente funcional. </font><font style="vertical-align: inherit;">Le mostraré cómo implementarlo por su cuenta en cuatro simples pasos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puedes jugar</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demostración de ruta directa</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo con curvas</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo con las colinas</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versión terminada</font></font></a></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre el rendimiento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El rendimiento de este juego </font><font style="vertical-align: inherit;">depende </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la máquina / navegador. </font><font style="vertical-align: inherit;">En los navegadores modernos, funciona bien, especialmente en aquellos que tienen aceleración de GPU de lienzo, pero un mal controlador de gráficos puede hacer que se congele. </font><font style="vertical-align: inherit;">En el juego, puedes cambiar la resolución y la distancia de representación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre la estructura del código</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sucedió que el proyecto se implementó en Javascript (debido a la simplicidad de la creación de prototipos), pero no está destinado a demostrar las técnicas o técnicas recomendadas de Javascript. </font><font style="vertical-align: inherit;">De hecho, para facilitar la comprensión, el Javascript de cada ejemplo está incrustado directamente en la página HTML (¡horror!); </font><font style="vertical-align: inherit;">peor, usa variables y funciones globales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si estuviera creando un juego real, el código sería mucho más estructurado y racionalizado, pero como se trata de una demostración técnica de un juego de carreras, decidí seguir con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1. Carreteras rectas.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¿cómo comenzamos a crear un juego de carreras pseudo-tridimensional? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, necesitamos</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repetir trigonometría</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recordemos los conceptos básicos de la proyección en 3D.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un bucle de juego</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargar imágenes de sprites</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construir geometría de carreteras</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizar fondo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderiza el camino</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render car</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementar soporte de teclado para control de máquina</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero antes de comenzar, leamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la página pseudo 3d de Lou</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traducción</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habré], la única fuente de información (que pude encontrar) sobre cómo crear el juego de carreras psevdotrohmernuyu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Terminaste de leer el artículo de Lou? </font><font style="vertical-align: inherit;">¡Multa! </font><font style="vertical-align: inherit;">Crearemos una variación de sus colinas realistas utilizando la técnica de segmentos proyectados en 3D. </font><font style="vertical-align: inherit;">Haremos esto gradualmente durante las siguientes cuatro partes. </font><font style="vertical-align: inherit;">Pero comenzaremos ahora, con la versión v1, y crearemos una geometría de carretera recta muy simple al proyectarla en un elemento de lienzo HTML5.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La demostración se puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un poco de trigonometría</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar con la implementación, usemos los conceptos básicos de la trigonometría para recordar cómo proyectar un punto en el mundo 3D en una pantalla 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso más simple, si no toca vectores y matrices, la ley de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triángulos similares se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usa para la proyección 3D </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usamos la siguiente notación:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = altura de la cámara</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distancia de la cámara a la pantalla</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distancia de la cámara al automóvil</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = pantalla </font><strong><font style="vertical-align: inherit;">y</font></strong><font style="vertical-align: inherit;"> coordenada</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces podemos usar la ley de triángulos similares para calcular </font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = h * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como se muestra en el diagrama:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También podría dibujar un diagrama similar en una vista superior en lugar de una vista lateral, y derivar una ecuación similar para calcular la coordenada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">pantalla:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x = w * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = la mitad del ancho de la carretera (desde la cámara hasta el borde de la carretera). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escalamos por un factor</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d / z</font></font></strong></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistemas coordinados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En forma de diagrama, se ve hermoso y simple, pero cuando comienza a codificar, puede confundirse un poco, porque elegimos nombres arbitrarios, y no está claro con qué designamos las coordenadas del mundo 3D y cuáles son las coordenadas de la pantalla 2D. </font><font style="vertical-align: inherit;">También suponemos que la cámara está en el centro del origen del mundo, aunque en realidad seguirá a la máquina. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se acerca más formalmente, entonces debemos realizar:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversión</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de coordenadas mundiales a coordenadas de pantalla</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyectar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordenadas de la cámara en un plano de proyección normalizado</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escalar las</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordenadas proyectadas a las coordenadas de la pantalla física (en nuestro caso, esto es lienzo)</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/5d2/30f/b595d230f4f45b9b0c9409266d5804d8.png"></div><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: en el presente sistema 3D </font><font style="vertical-align: inherit;">, la </font><font style="vertical-align: inherit;">etapa de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotación</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se realiza entre las etapas 1 y 2 </font><font style="vertical-align: inherit;">, pero como simularemos las curvas, no necesitamos una rotación.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyección</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las ecuaciones de proyección formales se pueden representar de la siguiente manera:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El punto de conversión de ecuaciones ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traslación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) se calcula en relación con la cámara</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las ecuaciones de proyección ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyecto</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) son variaciones de la "ley de triángulos similares" que se muestra arriba.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las ecuaciones de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escala</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><strong><font style="vertical-align: inherit;">escala</font></strong><font style="vertical-align: inherit;"> ) tienen en cuenta la diferencia entre:</font></font><br>
<ul>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matemática</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde 0,0 está en el centro y el eje y está arriba, y</font></font></li>
<li><em></em>,  0,0     ,   y  :</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/050/aad/11f050aadea0d1c537baefcb06f7c2f0.png"></div><br>
<blockquote><em>:   3d-         <code>Vector</code>  <code>Matrix</code>     3d-,      ,      WebGL (  )…       .           Outrun.</em></blockquote><br>
<h2>  </h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/27b/1bd/3b727b1bdb285d874bd659c29db13522.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La última pieza del rompecabezas será una forma de calcular </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la distancia desde la cámara al plano de proyección. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar de simplemente escribir un valor fijo de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sería más útil calcularlo desde el campo de visión vertical deseado. </font><font style="vertical-align: inherit;">Gracias a esto, podremos "acercar" la cámara si es necesario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si suponemos que estamos proyectando en un plano de proyección normalizado, cuyas coordenadas están en el rango de -1 a +1, entonces </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede calcularse de la siguiente manera:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 / tan (fov / 2)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definir fov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como una (de muchas) variables, podemos ajustar el alcance para ajustar el algoritmo de representación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructura del código Javascript</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comienzo del artículo, ya dije que el código no cumple con las pautas para escribir Javascript: es una demostración “rápida y sucia” con funciones y variables globales simples. </font><font style="vertical-align: inherit;">Sin embargo, dado que voy a crear cuatro versiones separadas (recta, curvas, colinas y sprites), almacenaré algunos métodos reutilizables </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro de los siguientes módulos:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es algunas funciones secundarias de ayuda DOM.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Util</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilidades generales, principalmente funciones matemáticas auxiliares.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juego</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : funciones generales de soporte de juegos, como el descargador de imágenes y el bucle del juego.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : funciones de representación auxiliares en el lienzo.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Explicaré en detalle los métodos </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo si se relacionan con el juego en sí y no son solo funciones matemáticas o DOM auxiliares. </font><font style="vertical-align: inherit;">Con suerte, por el nombre y el contexto, quedará claro qué deberían hacer los métodos.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como de costumbre, el código fuente está en la documentación final.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bucle de juego simple</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de renderizar algo, necesitamos un bucle de juego. </font><font style="vertical-align: inherit;">Si lees alguno de mis artículos anteriores sobre juegos ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breakout</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serpientes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boulderdash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), entonces ya has visto ejemplos de mi ciclo de juego favorito con un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paso de tiempo fijo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No profundizaré en los detalles, y simplemente reutilizaré parte del código de juegos anteriores para crear un bucle de juego con un paso de tiempo fijo usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El principio es que cada uno de mis cuatro ejemplos puede llamar </font></font><code>Game.run(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usar sus propias versiones</font></font><br>
<br>
<ul>
<li><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Actualización del mundo del juego con un paso de tiempo fijo.</font></font></li>
<li><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Actualización del mundo del juego cuando el navegador lo permite.</font></font></li>
</ul><br>
<pre><code class="javascript hljs">run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{<font></font>
<font></font>
  Game.loadImages(options.images, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> update = options.update,    <span class="hljs-comment">// method to update game logic is provided by caller</span>
        render = options.render,    <span class="hljs-comment">// method to render the game is provided by caller</span>
        step   = options.step,      <span class="hljs-comment">// fixed frame step (1/fps) is specified by caller</span>
        now    = <span class="hljs-literal">null</span>,<font></font>
        last   = Util.timestamp(),<font></font>
        dt     = <span class="hljs-number">0</span>,<font></font>
        gdt    = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">frame</span>(<span class="hljs-params"></span>) </span>{<font></font>
      now = Util.timestamp();<font></font>
      dt  = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (now - last) / <span class="hljs-number">1000</span>); <span class="hljs-comment">// using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab</span><font></font>
      gdt = gdt + dt;<font></font>
      <span class="hljs-keyword">while</span> (gdt &gt; step) {<font></font>
        gdt = gdt - step;<font></font>
        update(step);<font></font>
      }<font></font>
      render();<font></font>
      last = now;<font></font>
      requestAnimationFrame(frame);<font></font>
    }<font></font>
    frame(); <span class="hljs-comment">// lets get this party started</span><font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez más, esta es una nueva versión de las ideas de mis juegos de lienzo anteriores, por lo que si no comprende cómo funciona el bucle del juego, vuelva a uno de los artículos anteriores.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imágenes y sprites</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de que comience el ciclo del juego, cargamos dos hojas de sprites separadas (hojas de sprites):</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fondo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tres capas de paralaje para cielo, colinas y árboles</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprites</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><strong><font style="vertical-align: inherit;">sprites de</font></strong><font style="vertical-align: inherit;"> máquina (además de árboles y vallas publicitarias que se agregarán a la versión final)</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La hoja de sprites se generó utilizando una pequeña tarea </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la fábrica de sprites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rake and </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Ruby Gem</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta tarea genera las hojas de sprites combinadas, así como las coordenadas x, y, w, h, que se almacenarán en las constantes </font></font><code>BACKGROUND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: Creé los fondos usando Inkscape, y la mayoría de los sprites son gráficos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomados</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la versión anterior de Outrun para Genesis y utilizados como ejemplos de entrenamiento.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables del juego</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de las imágenes de fondos y sprites, necesitaremos varias variables del juego, a saber:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> fps           = <span class="hljs-number">60</span>;                      <span class="hljs-comment">// how many 'update' frames per second</span>
<span class="hljs-keyword">var</span> step          = <span class="hljs-number">1</span>/fps;                   <span class="hljs-comment">// how long is each frame (in seconds)</span>
<span class="hljs-keyword">var</span> width         = <span class="hljs-number">1024</span>;                    <span class="hljs-comment">// logical canvas width</span>
<span class="hljs-keyword">var</span> height        = <span class="hljs-number">768</span>;                     <span class="hljs-comment">// logical canvas height</span>
<span class="hljs-keyword">var</span> segments      = [];                      <span class="hljs-comment">// array of road segments</span>
<span class="hljs-keyword">var</span> canvas        = Dom.get(<span class="hljs-string">'canvas'</span>);       <span class="hljs-comment">// our canvas...</span>
<span class="hljs-keyword">var</span> ctx           = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// ...and its drawing context</span>
<span class="hljs-keyword">var</span> background    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our background image (loaded below)</span>
<span class="hljs-keyword">var</span> sprites       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our spritesheet (loaded below)</span>
<span class="hljs-keyword">var</span> resolution    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// scaling factor to provide resolution independence (computed)</span>
<span class="hljs-keyword">var</span> roadWidth     = <span class="hljs-number">2000</span>;                    <span class="hljs-comment">// actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth</span>
<span class="hljs-keyword">var</span> segmentLength = <span class="hljs-number">200</span>;                     <span class="hljs-comment">// length of a single segment</span>
<span class="hljs-keyword">var</span> rumbleLength  = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of segments per red/white rumble strip</span>
<span class="hljs-keyword">var</span> trackLength   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z length of entire track (computed)</span>
<span class="hljs-keyword">var</span> lanes         = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of lanes</span>
<span class="hljs-keyword">var</span> fieldOfView   = <span class="hljs-number">100</span>;                     <span class="hljs-comment">// angle (degrees) for field of view</span>
<span class="hljs-keyword">var</span> cameraHeight  = <span class="hljs-number">1000</span>;                    <span class="hljs-comment">// z height of camera</span>
<span class="hljs-keyword">var</span> cameraDepth   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z distance camera is from screen (computed)</span>
<span class="hljs-keyword">var</span> drawDistance  = <span class="hljs-number">300</span>;                     <span class="hljs-comment">// number of segments to draw</span>
<span class="hljs-keyword">var</span> playerX       = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// player x offset from center of road (-1 to 1 to stay independent of roadWidth)</span>
<span class="hljs-keyword">var</span> playerZ       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// player relative z distance from camera (computed)</span>
<span class="hljs-keyword">var</span> fogDensity    = <span class="hljs-number">5</span>;                       <span class="hljs-comment">// exponential fog density</span>
<span class="hljs-keyword">var</span> position      = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current camera Z position (add playerZ to get player's absolute Z position)</span>
<span class="hljs-keyword">var</span> speed         = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current speed</span>
<span class="hljs-keyword">var</span> maxSpeed      = segmentLength/step;      <span class="hljs-comment">// top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)</span>
<span class="hljs-keyword">var</span> accel         =  maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// acceleration rate - tuned until it 'felt' right</span>
<span class="hljs-keyword">var</span> breaking      = -maxSpeed;               <span class="hljs-comment">// deceleration rate when braking</span>
<span class="hljs-keyword">var</span> decel         = -maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// 'natural' deceleration rate when neither accelerating, nor braking</span>
<span class="hljs-keyword">var</span> offRoadDecel  = -maxSpeed/<span class="hljs-number">2</span>;             <span class="hljs-comment">// off road deceleration is somewhere in between</span>
<span class="hljs-keyword">var</span> offRoadLimit  =  maxSpeed/<span class="hljs-number">4</span>;             <span class="hljs-comment">// limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos de ellos se pueden personalizar mediante controles de la interfaz de usuario para cambiar los valores críticos durante la ejecución del programa, de modo que pueda ver cómo afectan la representación del camino. </font><font style="vertical-align: inherit;">Otros se recalculan a partir de valores de IU personalizados en el método </font></font><code>reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestionamos Ferrari</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizamos combinaciones de teclas para </font></font><code>Game.run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que proporcionan una entrada de teclado simple que establece o restablece variables que informan las acciones actuales del jugador:</font></font><br>
<br>
<pre><code class="javascript hljs">Game.run({<font></font>
  ...<font></font>
  keys: [<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">false</span>; } }<font></font>
  ],<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El estado del jugador está controlado por las siguientes variables:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">velocidad</font></strong><font style="vertical-align: inherit;"> actual.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la posición Z actual en la pista. </font><font style="vertical-align: inherit;">Tenga en cuenta que esta es una posición de cámara, no un Ferrari.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la posición actual del jugador en X en el camino. </font><font style="vertical-align: inherit;">Normalizado en el rango de -1 a +1, para no depender del valor real </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas variables se establecen dentro del método </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que realiza las siguientes acciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actualizaciones </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basadas en la actual </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se actualiza </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando presiona la tecla izquierda o derecha.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aumenta </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se presiona la tecla arriba.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disminuye </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se presiona la tecla hacia abajo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se reduce </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si no se presionan las teclas arriba y abajo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se reduce </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encuentra fuera del borde de la carretera y en el césped.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso de las carreteras directas, el método es </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bastante claro y simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{<font></font>
<font></font>
  position = Util.increase(position, dt * speed, trackLength);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> dx = dt * <span class="hljs-number">2</span> * (speed/maxSpeed); <span class="hljs-comment">// at top speed, should be able to cross from left to right (-1 to 1) in 1 second</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyLeft)<font></font>
    playerX = playerX - dx;<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyRight)<font></font>
    playerX = playerX + dx;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyFaster)<font></font>
    speed = Util.accelerate(speed, accel, dt);<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keySlower)<font></font>
    speed = Util.accelerate(speed, breaking, dt);<font></font>
  <span class="hljs-keyword">else</span><font></font>
    speed = Util.accelerate(speed, decel, dt);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) &amp;&amp; (speed &gt; offRoadLimit))<font></font>
    speed = Util.accelerate(speed, offRoadDecel, dt);<font></font>
<font></font>
  playerX = Util.limit(playerX, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// dont ever let player go too far out of bounds</span>
  speed   = Util.limit(speed, <span class="hljs-number">0</span>, maxSpeed); <span class="hljs-comment">// or exceed maxSpeed</span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No se preocupe, será mucho más difícil cuando en la versión final agreguemos sprites y reconocimiento de colisión.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometría del camino</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de que podamos renderizar el mundo del juego, necesitamos construir una matriz </font></font><code>segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el método </font></font><code>resetRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada uno de estos segmentos de la carretera finalmente se proyectará desde sus coordenadas mundiales para que se convierta en un polígono 2D en las coordenadas de la pantalla. </font><font style="vertical-align: inherit;">Para cada segmento, almacenamos dos puntos, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el centro del borde más cercano a la cámara y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el centro del borde más alejado de la cámara.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53a/fa4/076/53afa40768a00b49833703b1457a6941.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estrictamente hablando, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada segmento es idéntico a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 del</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segmento anterior, pero me parece que es más fácil almacenarlos como puntos separados y convertir cada segmento por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos mantenemos separados </font></font><code>rumbleLength</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque podemos tener hermosas curvas detalladas y colinas, pero al mismo tiempo rayas horizontales. Si cada segmento posterior tiene un color diferente, esto creará un mal efecto estroboscópico. Por lo tanto, queremos tener muchos segmentos pequeños, pero agruparlos para formar franjas horizontales separadas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetRoad</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments = [];<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; <span class="hljs-number">500</span> ; n++) { <span class="hljs-comment">// arbitrary road length</span><font></font>
    segments.push({<font></font>
       <span class="hljs-attr">index</span>: n,
       <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
    });<font></font>
  }<font></font>
<font></font>
  trackLength = segments.length * segmentLength;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solo con coordenadas mundiales </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque solo necesitamos carreteras rectas. Las </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordenadas </font><font style="vertical-align: inherit;">siempre será 0, y los </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordenadas </font><font style="vertical-align: inherit;">siempre dependerán del valor escalado </font></font><code>+/- roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Más tarde, cuando agreguemos curvas y colinas, esta parte cambiará. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También estableceremos objetos vacíos para almacenar representaciones de estos puntos en la cámara y en la pantalla para no crear un montón de objetos temporales en cada uno </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para minimizar la recolección de basura, debemos evitar asignar objetos dentro del ciclo del juego.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el automóvil llega al final del camino, simplemente regresamos al comienzo del ciclo. </font><font style="vertical-align: inherit;">Para simplificar esto, crearemos un método para encontrar un segmento para cualquier valor de Z, incluso si va más allá de la longitud del camino:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSegment</span>(<span class="hljs-params">z</span>) </span>{
  <span class="hljs-keyword">return</span> segments[<span class="hljs-built_in">Math</span>.floor(z/segmentLength) % segments.length];<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación de fondo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comienza representando la imagen de fondo. </font><font style="vertical-align: inherit;">En las siguientes partes, donde agregaremos curvas y colinas, necesitaremos el fondo para realizar el desplazamiento de paralaje, por lo que ahora comenzaremos a movernos en esta dirección, representando el fondo como tres capas separadas:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<font></font>
<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.SKY);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.HILLS);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.TREES);<font></font>
<font></font>
  ...</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado de carreteras</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, la función de renderizado itera a través de todos los segmentos y proyectos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada segmento desde las coordenadas mundiales hasta las coordenadas de la pantalla, recortando el segmento si es necesario y de otra manera renderizándolo:</font></font><br>
<br>
<pre><code class="javascript hljs">  <span class="hljs-keyword">var</span> baseSegment = findSegment(position);
  <span class="hljs-keyword">var</span> maxy        = height;
  <span class="hljs-keyword">var</span> n, segment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
    segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
    Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
    Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
        (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
      <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    Render.segment(ctx, width, lanes,<font></font>
                   segment.p1.screen.x,<font></font>
                   segment.p1.screen.y,<font></font>
                   segment.p1.screen.w,<font></font>
                   segment.p2.screen.x,<font></font>
                   segment.p2.screen.y,<font></font>
                   segment.p2.screen.w,<font></font>
                   segment.color);<font></font>
<font></font>
    maxy = segment.p2.screen.y;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arriba, ya hemos visto los cálculos necesarios para proyectar un punto; La versión de JavaScript combina transformación, proyección y escala en un solo método:</font></font><br>
<br>
<pre><code class="javascript hljs">project: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth</span>) </span>{<font></font>
  p.camera.x     = (p.world.x || <span class="hljs-number">0</span>) - cameraX;<font></font>
  p.camera.y     = (p.world.y || <span class="hljs-number">0</span>) - cameraY;<font></font>
  p.camera.z     = (p.world.z || <span class="hljs-number">0</span>) - cameraZ;<font></font>
  p.screen.scale = cameraDepth/p.camera.z;<font></font>
  p.screen.x     = <span class="hljs-built_in">Math</span>.round((width/<span class="hljs-number">2</span>)  + (p.screen.scale * p.camera.x  * width/<span class="hljs-number">2</span>));<font></font>
  p.screen.y     = <span class="hljs-built_in">Math</span>.round((height/<span class="hljs-number">2</span>) - (p.screen.scale * p.camera.y  * height/<span class="hljs-number">2</span>));<font></font>
  p.screen.w     = <span class="hljs-built_in">Math</span>.round(             (p.screen.scale * roadWidth   * width/<span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de calcular la pantalla </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cada punto </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilizamos los mismos cálculos de proyección para calcular el ancho proyectado ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) del segmento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teniendo las coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la pantalla de los </font><font style="vertical-align: inherit;">puntos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , así como el ancho proyectado de la carretera </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , podemos calcular fácilmente con la ayuda de una función auxiliar </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos los polígonos necesarios para renderizar hierba, carretera, franjas horizontales y líneas divisorias, utilizando la función auxiliar general </font></font><code>Render.polygon</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ver . </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado de autos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, lo último que necesita el método </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una representación de Ferrari:</font></font><br>
<br>
<pre><code class="javascript hljs">  Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,<font></font>
                cameraDepth/playerZ,<font></font>
                width/<span class="hljs-number">2</span>,<font></font>
                height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este método se llama </font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y no </font></font><code>car</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque en la versión final del juego habrá otros autos en la carretera, y queremos separar el Ferrari del jugador de otros autos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función auxiliar </font></font><code>Render.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa el método de lienzo llamado </font></font><code>drawImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para renderizar el sprite, habiéndolo escalado previamente usando la misma escala de proyección que se usó antes:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en este caso es la distancia relativa de la máquina a la cámara, almacenada en la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerZ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, la función "sacude" el automóvil un poco a altas velocidades, agregando un poco de aleatoriedad a la ecuación de escala, dependiendo de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad / velocidad máxima</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aquí está lo que tenemos:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/dfd/3e8/845dfd3e88ef0a22b2c9fd021140ff3b.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hicimos una gran cantidad de trabajo solo para crear un sistema con carreteras rectas. </font><font style="vertical-align: inherit;">Agregamos</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo auxiliar genérico </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dom</font></font></strong></li>
<li><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">Util</font></strong><font style="vertical-align: inherit;"> módulo de matemáticas general</font></font><strong><font style="vertical-align: inherit;"></font></strong></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> módulo auxiliar de lienzo general </font><font style="vertical-align: inherit;">...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... incluyendo </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Render.polygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>Render.sprite</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciclo de juego de lanzamiento fijo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descargador de imágenes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controlador de teclado</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fondo de paralaje</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hoja de sprites con autos, árboles y vallas publicitarias</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geometría rudimentaria de la carretera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para controlar la máquina</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para representar el fondo, la carretera y el auto del jugador</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etiqueta HTML5 </font></font><code>&lt;audio&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con música de carreras (¡bonificación oculta!)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... lo que nos dio una buena base para un mayor desarrollo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 2. Curvas.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta parte, explicaremos con más detalle cómo funcionan las curvas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte anterior, compilamos la geometría de la carretera en forma de una serie de segmentos, cada uno de los cuales tiene coordenadas mundiales que se transforman en relación con la cámara y luego se proyectan en la pantalla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo necesitábamos la coordenada mundial </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cada punto, porque en carreteras rectas, tanto </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eran iguales a cero.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/551/359/c78551359ef7c11e4af48b4285d61842.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si creáramos un sistema 3D completamente funcional, podríamos implementar las curvas calculando las </font><font style="vertical-align: inherit;">franjas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de los polígonos que se muestran arriba. Sin embargo, este tipo de geometría será bastante difícil de calcular, y para esto será necesario agregar la etapa de rotación 3D a las ecuaciones de proyección ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... si seguimos este camino, sería mejor usar WebGL o sus análogos, pero este proyecto no tiene otras tareas para nuestro proyecto. Solo queremos usar trucos pseudo-tridimensionales de la vieja escuela para simular curvas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, probablemente se sorprenderá al saber que no calcularemos las coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de los segmentos de la carretera en absoluto ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En su lugar, utilizaremos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el consejo de Lu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Para curvar la carretera, simplemente cambie la posición de la línea central de la forma de la curva ... comenzando desde la parte inferior de la pantalla, la cantidad de desplazamiento del centro de la carretera hacia la izquierda o hacia la derecha aumenta gradualmente"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, la línea central es el valor </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasado a los cálculos de proyección. </font><font style="vertical-align: inherit;">Esto significa que cuando realizamos </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada segmento de la carretera, puede simular las curvas cambiando el valor </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gradualmente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para saber cuánto cambiar, necesitamos almacenar un valor en cada segmento </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este valor indica cuánto se debe desplazar el segmento desde la línea central de la cámara. </font><font style="vertical-align: inherit;">Ella estará:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negativo para curvas de giro a la izquierda</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positivo para curvas que giran a la derecha</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menos para curvas suaves</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más para curvas cerradas</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los valores mismos se eligen de manera bastante arbitraria; </font><font style="vertical-align: inherit;">a través de prueba y error, podemos encontrar buenos valores en los que las curvas parecen ser "correctas":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> }, <span class="hljs-comment">// num segments</span>
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de elegir buenos valores para las curvas, debemos evitar espacios en las transiciones cuando la línea se convierte en una curva (o viceversa). </font><font style="vertical-align: inherit;">Esto se puede lograr </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ablandando</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al entrar y salir de las curvas. </font><font style="vertical-align: inherit;">Haremos esto aumentando gradualmente (o disminuyendo) el valor </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cada segmento utilizando las funciones de suavizado tradicionales hasta que alcance el valor deseado:</font></font><br>
<br>
<pre><code class="javascript hljs">easeIn:    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*<span class="hljs-built_in">Math</span>.pow(percent,<span class="hljs-number">2</span>);                           },
<span class="hljs-attr">easeOut</span>:   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span>-percent,<span class="hljs-number">2</span>));                     },
<span class="hljs-attr">easeInOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*((-<span class="hljs-built_in">Math</span>.cos(percent*<span class="hljs-built_in">Math</span>.PI)/<span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>);        },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, ahora, teniendo en cuenta la función de agregar un segmento a la geometría ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos crear un método para entrar, encontrar y salir sin problemas de una carretera curva:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve</span>) </span>{
  <span class="hljs-keyword">var</span> n;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve);<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y encima puedes imponer geometría adicional, por ejemplo, curvas en forma de S:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSCurves</span>(<span class="hljs-params"></span>) </span>{<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambios en el método update ()</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los únicos cambios que deben hacerse al método </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son la aplicación de un tipo de fuerza centrífuga cuando la máquina se mueve a lo largo de una curva. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Establecemos un factor arbitrario que se puede ajustar de acuerdo con nuestras preferencias.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> centrifugal = <span class="hljs-number">0.3</span>;   <span class="hljs-comment">// centrifugal force multiplier when going around curves</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y luego actualizaremos la posición en </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">función de su velocidad actual, valor de curva y multiplicador de fuerza centrífuga:</font></font><br>
<br>
<pre><code class="javascript hljs">playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación de curvas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijimos anteriormente que puede representar curvas simuladas cambiando el valor </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizado en los cálculos de proyección durante la ejecución de </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada segmento de carretera.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, almacenaremos la variable de unidad </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que aumentará para cada segmento en un valor </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, así como la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se utilizará como compensación del valor </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizado en los cálculos de proyección. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar las curvas, necesitamos lo siguiente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desplazar la proyección </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada segmento por </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desplazar la proyección </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada segmento por </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aumentar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para el siguiente segmento en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, para evitar transiciones desgarradas al cruzar los límites del segmento, debemos hacer que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx se</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicialice con el valor de la curva interpolada de los segmentos base actuales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambie el método de la </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente manera:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> baseSegment = findSegment(position);
<span class="hljs-keyword">var</span> basePercent = Util.percentRemaining(position, segmentLength);
<span class="hljs-keyword">var</span> dx = - (baseSegment.curve * basePercent);
<span class="hljs-keyword">var</span> x  = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  Util.project(segment.p1, (playerX * roadWidth) - x,      cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
  Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
<font></font>
  x  = x + dx;<font></font>
  dx = dx + segment.curve;<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fondo de desplazamiento de paralaje</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, necesitamos desplazar las capas de fondo de paralaje, almacenando el desplazamiento para cada capa ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> skySpeed    = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// background sky layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> hillSpeed   = <span class="hljs-number">0.002</span>; <span class="hljs-comment">// background hill layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> treeSpeed   = <span class="hljs-number">0.003</span>; <span class="hljs-comment">// background tree layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> skyOffset   = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current sky scroll offset</span>
<span class="hljs-keyword">var</span> hillOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current hill scroll offset</span>
<span class="hljs-keyword">var</span> treeOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current tree scroll offset</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y aumentarlo durante el tiempo </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependiendo del valor de la curva del segmento de jugador actual y su velocidad ...</font></font><br>
<br>
<pre><code class="javascript hljs">skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y luego usa para usar este desplazamiento cuando haces </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capas de fondo.</font></font><br>
<br>
<pre><code class="javascript hljs">Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, aquí obtenemos las curvas pseudo-tridimensionales falsas:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La parte principal del código que agregamos es construir la geometría de la carretera con el valor correspondiente </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al darse cuenta de ello, agregar fuerza centrífuga durante el tiempo es </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho más fácil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La representación de curvas se realiza en solo unas pocas líneas de código, pero puede ser difícil entender (y describir) exactamente qué está sucediendo aquí. Hay muchas formas de simular curvas y es muy fácil deambular cuando se implementan en un callejón sin salida. Es aún más fácil dejarse llevar por una tarea externa e intentar hacer todo "correctamente"; Antes de que te des cuenta de esto, comenzarás a crear un sistema 3D completamente funcional con matrices, rotaciones y geometría 3D real ... que, como dije, no es nuestra tarea.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando escribí este artículo, estaba seguro de que definitivamente había problemas en mi implementación de las curvas. </font><font style="vertical-align: inherit;">Tratando de visualizar el algoritmo, no entendí por qué necesitaba dos valores de las unidades </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x en</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lugar de uno ... y si no puedo explicar completamente algo, entonces algo salió mal en alguna parte ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... pero el tiempo del proyecto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"en el fin de semana ”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> casi </font><em><font style="vertical-align: inherit;">ha</font></em><font style="vertical-align: inherit;"> expirado, y, francamente, las curvas me parecen bastante hermosas, y al final, esto es lo más importante.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499240/index.html">A través de espinas a las estrellas, o análisis de datos en los asuntos del cielo</a></li>
<li><a href="../es499242/index.html">Los investigadores transmitieron datos desde una PC de escritorio a través de vibraciones a través de una mesa</a></li>
<li><a href="../es499244/index.html">Organizaciones sinergéticas. Parte II</a></li>
<li><a href="../es499246/index.html">Investigación de la función logística como ley de desarrollo industrial.</a></li>
<li><a href="../es499248/index.html">Cómo reconocemos el equipo de protección personal</a></li>
<li><a href="../es499254/index.html">El miembro del comité del programa PyConRu 2020 responde preguntas sobre Python: una apariencia actualizada y un poco de análisis</a></li>
<li><a href="../es499262/index.html">Hackathon final en línea para SMZhack autónomo: proyectos que afectarán a la gente</a></li>
<li><a href="../es499268/index.html">Conciencia espacial: ¿qué pueden hacer las gafas Hololens?</a></li>
<li><a href="../es499272/index.html">Componentes de soldadura 0201. Nervioso, aléjese de las pantallas</a></li>
<li><a href="../es499274/index.html">Desmontamos la nueva cápsula. Sabemos cuántos micrófonos y cómo funciona.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>