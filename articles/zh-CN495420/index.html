<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛏️ 🤞🏿 👨‍🎨 按正金字塔排序 🐥 🖱️ 👩🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在哈布雷（Habré）上进行堆排序（这也是金字塔式排序）已经用一个或两次以上的好词记住了，但这一直是众所周知的信息。每个人都知道通常的二进制堆，但是算法理论也有：
 
 n堆；一堆基于莱昂纳多数的堆； Deramide（堆和二叉搜索树的混合体）；迷你锦标赛镜像（反向）堆；弱桩荣的堆二项式桩上帝知道其...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>按正金字塔排序</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/495420/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img width="750" height="322" src="https://habrastorage.org/webt/jf/fj/_q/jffj_qzdbowiyg-ae0vt73ddewc.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在哈布雷（Habré）上进行堆排序（这也是金字塔式排序）已经用一个或两次以上的好词记住了，但这一直是众所周知的信息。每个人都知道通常的二进制堆，但是算法理论也有：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n堆；一堆基于莱昂纳多数的堆； Deramide（堆和二叉搜索树的混合体）；迷你锦标赛镜像（反向）堆；弱桩荣的堆二项式桩上帝知道其他什么东西…… </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而不同年份中最聪明的计算机科学代表提出了使用这些金字塔结构的排序算法。谁在乎他们的工作-对于那些人，我们正在开始一连串的文章，专门讨论如何使用这些结构进行排序。堆的世界是多种多样的-希望您会感兴趣。</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="EDISON软件-网络开发"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON软件-网络开发"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文是在EDISON的支持下编写的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动应用程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">开发，</font></a><font style="vertical-align: inherit;">并提供</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软件测试服务</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们喜欢算法理论！</font><font style="vertical-align: inherit;">;-)</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有这样一类算法-按选择排序。</font><font style="vertical-align: inherit;">总体思路是，减少数组的无序部分，因为它会搜索从数组重新排列成递增排序区域的最大元素。</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="69" src="https://habrastorage.org/webt/ew/-y/d5/ew-yd57sbecvuebvverib0a80am.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
排序通常的选择是蛮力的。</font><font style="vertical-align: inherit;">如果为求最大值而线性遍历数组很简单，则这种算法的时间复杂度不能超过O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一堆</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理数组最高点的最有效方法是将数据组织成一个特殊的树结构，称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一棵树，其中所有父节点不少于子节点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
堆的其他名称- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">金字塔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序树</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下如何轻松，几乎免费地以树的形式呈现数组。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
取数组的第一个元素，并认为这是树的根-第一层的节点。</font><font style="vertical-align: inherit;">接下来的2个元素是第二级的节点，即根元素的左右后代。</font><font style="vertical-align: inherit;">接下来的4个元素是第3层的节点，即数组的第二个/第三个元素的右/左后代。</font><font style="vertical-align: inherit;">接下来的8个元素是第4层的节点，是第3层的元素的后代。</font><font style="vertical-align: inherit;">等等。</font><font style="vertical-align: inherit;">在此图中，二叉树的节点严格位于数组中相应元素的严格下方：</font></font><br>
<br>
<div style="text-align:center;"><img width="627" height="340" src="https://habrastorage.org/webt/ut/e6/in/ute6inpfajr64j1tlpggpl5w8fo.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
虽然，在这种扫描中更经常地描绘图中的树： </font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/3l/pz/yi/3lpzyizc7eephsbmsc9viexmr2u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您从这个角度看，那么很清楚为什么将一堆排序称为金字塔排序。不过，这与您将象棋大象称为军官，白嘴鸦称为图拉，女王/王后称为女王/王后一样。</font><font style="vertical-align: inherit;">第</font><b><font style="vertical-align: inherit;">i</font></b><font style="vertical-align: inherit;">个元素</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的后代</font><font style="vertical-align: inherit;">的索引由elementary确定（如果数组的第一个元素的索引被视为等于0，这在大多数编程语言中都是习惯的）：</font><font style="vertical-align: inherit;">
2× </font><b><font style="vertical-align: inherit;">i</font></b><font style="vertical-align: inherit;"> + 1的</font><font style="vertical-align: inherit;">左后代</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">
右子级：2× </font><b><font style="vertical-align: inherit;">i</font></b><font style="vertical-align: inherit;"> + 2 </font><font style="vertical-align: inherit;">
（我在图表上在动画中，传统上，数组的索引以1开头，其公式略有不同：左子元素：</font><nobr><font style="vertical-align: inherit;">2× </font></nobr><nobr><b><font style="vertical-align: inherit;">i</font></b></nobr><font style="vertical-align: inherit;">和右子</font><font style="vertical-align: inherit;">元素</font><font style="vertical-align: inherit;">：</font><nobr><font style="vertical-align: inherit;">2× </font></nobr><nobr><b><font style="vertical-align: inherit;">i</font></b></nobr><nobr><font style="vertical-align: inherit;"> + 1</font></nobr></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><nobr><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b></nobr><font style="vertical-align: inherit;"></font><nobr><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是这些已经是很小的算术差异了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果从这些公式得到的后代索引超出数组，则表示</font><font style="vertical-align: inherit;">第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个项没有子项。</font><font style="vertical-align: inherit;">第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素</font><font style="vertical-align: inherit;">也可能</font><font style="vertical-align: inherit;">是左后代（落在数组的最后一个元素（其中元素为奇数个）上），但是没有右元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，任何数组都可以轻松地以树的形式表示，但是，这还不是堆，因为在数组中，某些子元素可能大于其父元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使基于数组创建的树成为堆，需要对其进行适当的筛选。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">筛分</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整理一堆的灵魂正在筛选。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对元素的筛选是，如果它小于不可分割链中组合的子孙，则必须将该元素尽可能低地移动，并且将大子孙提升1级。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该图显示了物料的筛选路径。蓝色表示要进行筛选的元素。绿色-分支中较大的后代。因为它们的尺寸比制作屏幕的蓝色结大，所以它们将被提升一级。来自最高蓝色节点的元素本身将移至绿色链中最低后代的位置。</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="249" src="https://habrastorage.org/webt/rh/i5/p_/rhi5p_yzvebng8-pywu-zuli7h0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使分类树从普通树中脱颖而出并进一步支持该树处于此（分类）状态，需要进行筛选。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此图像中，重新分配了数组的元素，以便已将其布置在堆中。</font><font style="vertical-align: inherit;">尽管该数组已分解为排序树，但尚未对其进行排序（升序或降序），尽管树中的所有后代均小于其父节点。</font><font style="vertical-align: inherit;">但是，排序树中最大的元素始终位于主根中，这一点非常重要。</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/iz/yg/lk/izyglkygfz4sh7izbjkhhsbdsvk.png"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序::堆排序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法实际上很简单：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阶段1.我们从整个数组中形成一个排序树。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们从右向左传递元素（从最后到第一个），如果元素具有后代，则对其进行筛选。</font></font></li>
<li><b> 2.       .</b>             ,        .   (  )        .        , ..   .       ,      —             .         ,             .</li>
</ul><br>
<br>
<div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/cr/ik/_t/crik_twwuqdjsiclj7t-mcdjx78.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经典金字塔排序实现的Python代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#    </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range((len(data) - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        HeapSift(data, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        HeapSift(data, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
<font></font>
<span class="hljs-comment">#   ,      </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSift</span>(<span class="hljs-params">data, start, end</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
    <font></font>
    <span class="hljs-comment">#      ,</span>
    <span class="hljs-comment">#   ,    </span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
<font></font>
        child = root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> <span class="hljs-comment">#  </span>
        <span class="hljs-comment">#      -  </span>
        <span class="hljs-keyword">if</span> child &gt; end: <span class="hljs-keyword">break</span> <font></font>
<font></font>
        <span class="hljs-comment">#       ,</span>
        <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">if</span> child + <span class="hljs-number">1</span> &lt;= end <span class="hljs-keyword">and</span> data[child] &lt; data[child + <span class="hljs-number">1</span>]:<font></font>
            child += <span class="hljs-number">1</span><font></font>
<font></font>
        <span class="hljs-comment">#     ,   </span>
        <span class="hljs-comment">#       , </span>
        <span class="hljs-comment">#       </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[child]:<font></font>
            data[root], data[child] = data[child], data[root]<font></font>
            root = child<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法复杂度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么简单堆是好的-与其他类型的树不同，它不需要单独存储（例如，必须在使用前创建基于数组的二进制搜索树）。任何数组都已经是一棵树，您可以在其中随时随地识别父级和后代。额外内存的复杂度为O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），一切都会立即发生。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于时间的复杂性，这取决于筛分。</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绕过了一次筛分</font><font style="vertical-align: inherit;">。首先，我们对</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素进行筛选，以便从数组中构建初始堆-此步骤需要</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在第二阶段，当我们取出</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前堆中的最大值，我们对剩余的未排序部分进行一次筛分，即 </font><font style="vertical-align: inherit;">这一阶段也使我们付出</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代价</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总时间复杂度：O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，金字塔分类既没有退化也没有更好的情况。</font><font style="vertical-align: inherit;">任何阵列都将以适当的速度处理，但不会降级或记录。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平均而言，堆排序比快速排序要慢一些。</font><font style="vertical-align: inherit;">但是对于quicksort，您可以选择一个计算机挂在其上的Killer阵列，但是对于heapsort，则不是。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th rowspan="2"></th>
<th colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间复杂度</font></font></th>
</tr>
<tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最差</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最好的</font></font></th>
</tr>
<tr>
<th> </th>
<td colspan="3" align="center">O(<b>n</b> log <b>n</b>)</td>
</tr>
<tr>
<th> </th>
<td align="center">O(<b>n</b><sup>2</sup>)</td>
<td align="center">O(<b>n</b> log <b>n</b>)</td>
<td align="center">O(<b>n</b>)</td>
</tr>
</tbody></table></div><br>
<br>
<h2>   :: Ternary heapsort</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下三元堆。您不会从二进制中相信它，它的不同之处仅在于父节点的最大值不是两个，而是三个后代。在为第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素编码的</font><font style="vertical-align: inherit;">三元堆中，对</font><font style="vertical-align: inherit;">三个后代进行类似计算（如果第一个元素索引= 0）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左后代3× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中间后代3× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右后代3× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（如果索引以1开头，如本文中的动画所示，然后在这些公式中您只需要减去1）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
排序过程：</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="251" src="https://habrastorage.org/webt/-g/8n/rn/-g8nrn8fbhvbv4wvceklzcw2rio.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方面，与二进制堆相比，树中的级别数显着减少，这意味着筛选期间平均将减少交换。</font><font style="vertical-align: inherit;">另一方面，要找到最小后代，则需要进行更多比较-因为现在的后代不再是两个，而是每个三个。</font><font style="vertical-align: inherit;">总的来说，就时间复杂度而言-我们发现了某个地方，我们失去了某个地方，但总的来说是一样的。</font><font style="vertical-align: inherit;">三元堆中的数据排序比二进制中的数据快一点，但是这种加速非常小。</font><font style="vertical-align: inherit;">在金字塔式分类的所有变体中，算法的开发人员都倾向于采用二进制选项，因为三元算法据说更难以实现（尽管在算法中添加两三行额外的“困难”），并且速度增益很小。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按n堆大小排序:: N-narny堆排序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您不能止步于此，而是根据一堆串后代对任意数量的后代进行排序。也许如果您继续增加后代的数量，可以大大提高进程的速度？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于</font><font style="vertical-align: inherit;">数组索引的第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素（如果计数为零），其</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后代的计算非常简单：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个后代：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个后代：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三个后代：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N个后代：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + N </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于按N堆排序的Python代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#      N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    n = <span class="hljs-number">3</span> <span class="hljs-comment">#    </span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range(len(data), <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        NHeapSift(data, n, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        NHeapSift(data, n, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
    <font></font>
<span class="hljs-comment">#  -     N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSift</span>(<span class="hljs-params">data, n, start, end</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        <font></font>
        <span class="hljs-comment">#   (    )</span>
        <span class="hljs-comment">#   </span>
        child = root * n + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> child &gt; end: 
            <span class="hljs-keyword">break</span> <font></font>
<font></font>
        max = child<font></font>
        <font></font>
        <span class="hljs-comment">#    </span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<font></font>
            current = root * n + k<font></font>
            <span class="hljs-keyword">if</span> current &gt; end:
                <span class="hljs-keyword">break</span><font></font>
                <font></font>
            <span class="hljs-keyword">if</span> data[current] &gt; data[max]:<font></font>
                max = current<font></font>
        <font></font>
        <span class="hljs-comment">#     </span>
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[max]:<font></font>
            data[root], data[max] = data[max], data[root]<font></font>
            root = max<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，更多并不意味着更好。</font><font style="vertical-align: inherit;">如果将情况带到极限，并为N个元素的数组获取N个后代，则按一堆排序将退化为按通常选择进行排序。</font><font style="vertical-align: inherit;">而且，这也会成为按选择排序的更差版本，因为将执行无意义的手势：筛选将首先将最大值放在数组的第一位，然后将最大值发送到末尾（在选择排序中，最大值将立即发送到末尾）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果三元堆最小地超过了二进制，则四元组已经丢失。</font><font style="vertical-align: inherit;">在几个中找到最大后代变得太昂贵了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个系列预告片</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，二元/三元/ n堆的主要缺点是无法跳转，其复杂度高于</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">摆脱僵局的方法是在排序中使用更复杂的堆品种。</font><font style="vertical-align: inherit;">一周之内，我们将了解Edsger Dijkstra对此的看法。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img width="627" height="475" src="https://habrastorage.org/webt/qi/dn/w-/qidnw-xsewiihfsqbr8ajkj4jhi.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单击动画以转到带有以下排序的文章</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">金字塔</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系列文章：</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel应用程序AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按选择排序</font></font></a><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：N金字塔</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：莱昂纳多数</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：弱堆</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">束排序：笛卡尔树</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他堆排序：镜像堆，迷你堆，自下而上筛选</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按分布排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合排序</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AlgoLab应用程序添加了按n堆排序。</font><font style="vertical-align: inherit;">要选择后代数，请在此类单元格的注释中，为n指定一个数字。</font><font style="vertical-align: inherit;">可能值的范围是2到5（不再有意义，因为对于n&gt; = 6，不能保证在正常比例下具有三个嵌套级别的动画适合屏幕）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495408/index.html">＃02-整个字节还不够... | 变化的十字架</a></li>
<li><a href="../zh-CN495412/index.html">诺伯特·维纳（Norbert Wiener）。一个有趣的人。同事，敌人为独立而奋斗</a></li>
<li><a href="../zh-CN495414/index.html">恐惧的后果</a></li>
<li><a href="../zh-CN495416/index.html">pipeplot-控制台中管道的数据流的交互式可视化</a></li>
<li><a href="../zh-CN495418/index.html">Blazor客户端在线商店：第4部分-将项目添加到购物车</a></li>
<li><a href="../zh-CN495422/index.html">专业：移动开发人员</a></li>
<li><a href="../zh-CN495432/index.html">有陷阱的单身人士</a></li>
<li><a href="../zh-CN495434/index.html">过去两周发生的运输情况</a></li>
<li><a href="../zh-CN495436/index.html">我们开放使用DLP系统的实践课程</a></li>
<li><a href="../zh-CN495438/index.html">适用于Excel用户的R语言（免费视频课程）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>