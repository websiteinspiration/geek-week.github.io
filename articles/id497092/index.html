<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¦‡ ğŸ„ ğŸ© Komputer buatan sendiri dari papan AON ğŸ´ ğŸ“‚ ğŸ‘‚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, beberapa artikel tentang komputer buatan yang dibuat dari berbagai komponen non-standar telah muncul di HabrÃ©. Saya juga memutuskan unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Komputer buatan sendiri dari papan AON</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497092/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baru-baru ini, beberapa artikel tentang komputer buatan yang dibuat dari berbagai komponen non-standar telah muncul di HabrÃ©. </font><font style="vertical-align: inherit;">Saya juga memutuskan untuk berbicara tentang komputer saya, yang dibuat pada tahun 1993. </font><font style="vertical-align: inherit;">Setelah antusiasme umum terhadap sinclair, saya ingin memiliki komputer 8-bit yang sepenuhnya asli berdasarkan z80 dan, selain itu, membuat perangkat lunak untuk itu, mulai dari sistem operasi dan diakhiri dengan mainan. </font><font style="vertical-align: inherit;">Apa yang terjadi, baca di bawah potongan.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertanyaan pertama yang muncul saat membuat komputer Anda adalah pertanyaan tentang arsitektur. Saya memutuskan bahwa itu akan cukup kompak, berdasarkan pada prosesor z80, tanpa menampilkan gambar di TV, tetapi dengan layar teks LCD, keyboard yang cukup besar, output suara dalam bentuk tweeter nada tunggal (standar pada waktu itu untuk sebagian besar komputer) dan port RS232 untuk menghubungkan ke komputer lain untuk keperluan pemrograman dan debugging.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, muncul masalah di mana mendapatkan papan sirkuit tercetak untuk sirkuit yang sepenuhnya asli, karena pada tahun 1993 orang Cina belum memproduksi papan untuk seluruh dunia, dan itu sangat mahal untuk memesan pengembangan dan produksi di pabrik. Dan kemudian saya mengalihkan perhatian saya ke papan dari mana ID penelepon dibuat - pengidentifikasi nomor otomatis. Mereka dijual di pasar Mitinsky, memiliki kesempatan untuk menginstal komponen yang saya butuhkan, tetapi perlu ditingkatkan. Dijual ada beberapa jenis papan sirkuit cetak yang, jika ingatanku, saya memilih papan yang disebut "Rus."</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan saya mengingatkan Anda untuk pembaca muda apa itu AON. Itu adalah telepon dengan pemanggilan tombol (ngomong-ngomong, pada waktu itu cukup keren, karena sebagian besar ponsel memiliki disk pemintalan), yang terdiri dari 12 tombol dan indikator 9-segmen, 7-segmen yang menyala di mana nomor telepon ditampilkan, jika itu mungkin untuk menentukan dan beberapa informasi lainnya. Papan AON berisi prosesor z80, port paralel 58055, sirkuit dekoder, timer 58053, ROM 32-kilobyte (dengan penghapusan ultraviolet), RAM statis 8-kilobyte, bagian analog yang terhubung ke saluran telepon dan, mungkin, sesuatu yang lain, apa yang saya lupa selama beberapa tahun terakhir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keyboard 12 tombol dan indikator yang tersedia pada Caller ID tidak cocok untuk saya, karena mereka biasanya tidak dapat memasukkan informasi atau menampilkannya (dalam huruf-huruf tertentu). Oleh karena itu, diputuskan untuk menggunakan keyboard buatan sendiri 40 tombol dan layar LCD 24-karakter teks, yang kemudian dijual. Untuk menghubungkan keyboard dan layar LCD, perlu untuk memodifikasi skema AON. Hal pertama yang saya lakukan adalah membuang seluruh bagian analog yang terkait dengan saluran telepon, atau lebih tepatnya, saya tidak menyegelnya. Pada saat yang sama, kaki output pada decoder, yang memilih debit indikator dan kaki pada port paralel 58055, dibebaskan. Layar LCD memerlukan 4 baris untuk mengirimkan informasi, tetapi untuk keyboard itu perlu menggunakan decoder.Karena 40 tombol pada keyboard disusun dalam matriks 5 baris 8 buah, diputuskan untuk menghubungkan 8 tombol ini ke dekoder sehingga dapat dipindai dengan memasok kombinasi yang berbeda dari tiga baris ke input dekoder dan membaca 5 nilai dari deretan tombol menggunakan KR580VB55. Dengan demikian, kode pindai tombol yang ditekan pada keyboard berukuran satu byte, di mana tiga bit pertama menentukan kolom di mana tombol ditekan, dan sisa 5 bit yang ditunjukkan di baris mana tombol ini (atau beberapa tombol sekaligus) ditekan . Selain itu, saya menganggap bahwa 8 kilobyte RAM tidak akan cukup dan menggantinya dengan 32 kilobyte. Pada saat yang sama, saya harus menyolder ulang beberapa track pada papan sirkuit tercetak, untungnya, casing RAM 8- dan 32-kilobyte hampir identik dalam pinout. Lewat sini,Saya mendapat ROM 32 kilobyte dan RAM 32 kilobyte (saya ingat bahwa Z80 dapat menangani maksimum 64 kilobyte, sehingga saya menggunakan ruang alamat secara maksimal). Selain itu, dua baris lagi 58055 pergi ke port serial RS232, yang diperlukan untuk menghubungkan ke komputer lain. Saya menempatkan semua ekonomi ini dalam kasing dari tester. Hasilnya adalah desain ini:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ecb/42e/7d8/ecb42e7d814bec4eb951fefbe55d2257.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah perangkat keras selesai, tiba saatnya untuk membuat perangkat lunak. Di sini perlu dicatat bahwa proses penciptaannya tidak terlihat sama sekali seperti sekarang ini. Pertama, sebagian besar ditulis dalam assembler z80 (walaupun pada saat itu hampir semua program untuk sistem tersebut ditulis dalam assembler, well, kecuali untuk BASIC). Untuk kompilasi dari assembler pada tahap pertama, teman saya membantu saya, yang memiliki komputer Profi - klon sinclair, tetapi dengan TR-DOS di dalamnya. Kemudian saya mulai menggunakan IBM PC saya, yang merupakan OS / 2, yang menjalankan MS-DOS di jendela terpisah, di mana, pada gilirannya, emulator TR-DOS diluncurkan, di mana kompilasi berlangsung. Saya harus mengatakan bahwa ketika perangkat lunak tumbuh secara nyata, proses kompilasi dan perakitan memakan waktu sepuluh menit. Masalah kedua adalahbahwa tidak ada alat debugging ada dan, karena itu, perlu untuk mengunduh semuanya setiap kali di komputer buatan saya dan memeriksa cara kerjanya (hal pertama yang harus dilakukan adalah program untuk bekerja RS232 pada 9600 bit per detik untuk mengunduh). Dan akhirnya, harus dikatakan bahwa setelah men-debug gambar ROM, perlu untuk menulisnya ke ROM ini sendiri, setelah sebelumnya menghapus apa yang sudah ditulis di sana. Penghapusan dilakukan dengan menggunakan lampu ultraviolet untuk penyamakan melalui jendela khusus di rumah sirkuit mikro, yang kemudian ditutup dengan kertas perekat hitam khusus, yang berfungsi untuk menutup lubang di sisi disket 5-inci untuk melindunginya dari penulisan. Selain itu, karena saya tidak memiliki programmer, untuk menulis versi baru perangkat lunak dalam ROM, setiap kali saya harus pergi ke teman saya ke ujung lain dari Moskow,yang memiliki programmer ini. Di sini perlu untuk mengklarifikasi pertanyaan, bagaimana mungkin untuk men-debug gambar ROM tanpa memuatnya ke dalam ROM ini? Ada alamat dasar untuk ini, yang digunakan semua perangkat lunak saya, mengubah alamat dengan 32 kilobyte. Yaitu, gambar ROM baru dimuat ke dalam RAM dan didebug di sana, dan setelah debugging, alamat dasar diatur ke nol, semuanya dikompilasi lagi, dan saya pergi ke seorang teman untuk menulis versi baru dalam ROM.semuanya dikompilasi lagi dan saya pergi ke seorang teman untuk menulis versi baru di ROM.semuanya dikompilasi lagi dan saya pergi ke seorang teman untuk menulis versi baru di ROM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika proses "coding" - "debugging" - "firmware" di-debug, muncul pertanyaan untuk menulis sistem operasi. Sistem operasi harus mendukung input keyboard, menampilkan informasi pada layar LCD, mendukung untuk mengeluarkan suara yang berbeda dan melakukan semua ini secara paralel, jika mungkin, yaitu multi-tasking. Untuk semua ini, arsitektur berikut dipilih - ada tiga jenis tugas di OS: beberapa tugas real-time dengan prioritas tertinggi, satu tugas pengguna yang berinteraksi dengan orang itu sendiri dan tugas latar belakang yang berfungsi saat prosesor diam. Saya menutup tugas dengan prioritas tertinggi pada interupsi, yang dihasilkan oleh timer KR580VI53 10 kali per detik. Harus dikatakan bahwa dalam Caller ID, interupsi dihasilkan 400 kali per detik, karena itu perlu untuk memperbarui indikator sangat sering untuksehingga seseorang tidak melihat flicker. Selain memperbarui indikator dalam interupsi, keyboard disurvei untuk mencari tombol yang ditekan. Gangguan yang sering terjadi pada AON menyebabkan fakta bahwa sebagian besar waktu prosesor dihabiskan untuk interupsi, dan saya ingin komputer saya melakukan sesuatu yang bermanfaat. Karena saya memasang layar LCD sebagai perangkat tampilan informasi, yang memiliki memori sendiri dan tidak perlu memperbarui secara dinamis, kebutuhan untuk frekuensi interupsi seperti itu tidak lagi diperlukan. Secara eksperimental ditetapkan bahwa 10 interupsi per detik sudah cukup untuk polling keyboard.bahwa sebagian besar waktu prosesor dihabiskan untuk interupsi, dan saya ingin komputer saya melakukan sesuatu yang bermanfaat. Karena saya memasang layar LCD sebagai perangkat tampilan informasi, yang memiliki memori sendiri dan tidak perlu memperbarui secara dinamis, kebutuhan untuk frekuensi interupsi seperti itu tidak lagi diperlukan. Secara eksperimental ditetapkan bahwa 10 interupsi per detik sudah cukup untuk polling keyboard.bahwa sebagian besar waktu prosesor dihabiskan untuk interupsi, dan saya ingin komputer saya melakukan sesuatu yang bermanfaat. Karena saya memasang layar LCD sebagai perangkat tampilan informasi, yang memiliki memori sendiri dan tidak perlu memperbarui secara dinamis, kebutuhan untuk frekuensi interupsi seperti itu tidak lagi diperlukan. Secara eksperimental ditetapkan bahwa 10 interupsi per detik sudah cukup untuk polling keyboard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, tugas real-time diluncurkan pada setiap interupsi dan menempatkan informasi baru dalam antrian acara khusus. Peristiwa tersebut terdiri dari beberapa jenis dan berisi informasi yang berkaitan dengan jenis peristiwa, misalnya, acara "tombol yang ditekan" berisi kode pemindaian. Sebenarnya, salah satu tugas prioritas yang dimulai pada setiap interupsi adalah tugas polling keyboard dan secara terprogram menghapus bouncing kontak. Selain tugas ini, ada juga tugas-tugas prioritas - timer yang tugas pengguna dapat mengatur, dan yang, setelah waktu yang ditentukan, mengantri acara yang sesuai, ada alarm yang bekerja pada waktu, jam dan kalender tertentu, dan ada juga tugas yang memutar musik menggunakan pemrograman KR580VI53, dan input ke dalamnya dimasukkan data dalam bentuk catatan. Lewat sini,tugas pengguna bisa mulai memutar musik dan melakukan hal-hal lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pekerjaan yang bermanfaat di komputer saya dilakukan oleh tugas pengguna yang dikendalikan oleh peristiwa. Pandangan khas dari tugas semacam itu tampak seperti:</font></font><br>
<br>
<pre><code class="plaintext hljs">while(true) {<font></font>
  Event e;<font></font>
<font></font>
  GetEvent(e);<font></font>
<font></font>
  /* process event */<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini fungsi GetEvent (e) menunggu acara muncul dalam antrian dan, ketika muncul, mengisi struktur Acara. Jelas bahwa menurut peristiwa tertentu, program dapat keluar dari loop tak terbatas dan mentransfer kontrol kembali ke monitor sistem, yang meluncurkan tugas pengguna. Karena peristiwa dalam tugas pengguna biasanya diproses dengan cepat, program menunggu acara baru muncul dalam prosedur GetEvent (e). Untuk memanfaatkan ekspektasi ini, tugas latar belakang diperkenalkan bahwa program pengguna dapat berjalan dan bekerja secara independen. Yaitu, ketika gangguan dari penghitung waktu terjadi, tugas waktu-nyata pertama kali dipenuhi dengan menempatkan peristiwa dalam antrian, kemudian setelah gangguan, tugas pengguna memproses semua peristiwa dari antrian, dan sisa waktu hingga gangguan berikutnya diberikan pada tugas latar belakang.Hari ini, skema seperti itu terlihat alami, tetapi pada tahun 1993 sangat progresif.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah lain terkait dengan fakta bahwa layar LCD tidak dapat menampilkan huruf Rusia. Ini karena fakta bahwa indikator-indikator seperti itu baru saja muncul di pasar kita dan tidak ada yang secara khusus menjelaskannya. Secara alami, tidak ada perpustakaan untuk bekerja dengan mereka, tetapi hanya ada spesifikasi dan deskripsi perintah. Oleh karena itu, semua pekerjaan inisialisasi dan bekerja dengannya harus ditulis dari awal. Saya memecahkan masalah dengan Russification sebagai berikut: prosedur khusus ditulis, inputnya adalah string dengan teks Rusia yang perlu ditampilkan. Prosedur ini menggantikan semua huruf Rusia yang mirip dengan Latin dengan huruf Latin yang sesuai, dan yang tidak mungkin diganti dibuat dengan cepat menggunakan gambar khusus yang dapat diunduh ke layar LCD. Ini harus diperhatikanbahwa ada delapan gambar pengguna seperti itu di dalamnya dan, karenanya, dalam teks Rusia tidak boleh lebih dari delapan huruf, yang analognya tidak ada dalam alfabet Latin. Tapi biasanya sudah cukup. Fitur menyenangkan lain yang saya gunakan adalah bahwa jika Anda mengubah gambar khusus untuk satu karakter, Anda mendapatkan animasi yang lucu. Saya menggunakan kesempatan ini dalam permainan pencari ranjau, yang akan saya bahas di bawah, di mana bendera di atas tambang yang ditemukan berkibar di angin dan bom meledak.Saya menggunakan kesempatan ini dalam permainan pencari ranjau, yang akan saya bahas di bawah, di mana bendera di atas tambang yang ditemukan berkibar di angin dan bom meledak.Saya menggunakan kesempatan ini dalam permainan ranjau, yang akan saya bahas di bawah ini, di mana bendera di atas tambang telah diterbangkan angin dan bom meledak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya akan memberi tahu Anda tentang tugas-tugas pengguna yang saya buat untuk komputer saya. Ketika saya mulai membuat mereka, saya segera menyadari bahwa menulisnya di assembler, seperti yang dilakukan semua orang pada waktu itu untuk sistem seperti sinclair, cukup menyedihkan. Karena saya memprogram C pada PC IBM, saya memikirkan apakah mungkin memprogram pada C dan pada komputer saya. Setelah beberapa pencarian, saya menemukan kompiler dari bahasa C untuk TR-DOS, apalagi, dalam versi K&amp;R klasiknya. Kompiler ini agak primitif, misalnya, ia tidak memeriksa apakah jumlah parameter yang diteruskan ke prosedur sesuai dengan angka aktualnya, belum lagi memeriksa tipenya. Tetapi jika saya bisa menggunakan kompiler ini untuk komputer saya, itu akan menjadi kemajuan luar biasa. Masalahnya adalah bagaimana mengadaptasi kode yang diterima oleh kompiler ini untuk komputer saya.Di sini saya menggunakan cara klasik, yang sudah kita lupakan, dan pada tahun 1993 mereka masih ingat. Cara ini adalah dengan mengkompilasi kode sumber tidak langsung ke file objek, tetapi ke kode sumber assembler. Dengan demikian, itu hanya diperlukan untuk menulis makro yang akan memungkinkan memanggil prosedur assembler dikompilasi dari kode dan sebaliknya, dengan transfer parameter yang benar, yang dilakukan. Menggunakan kompiler ini, selain kenyamanan bekerja dengan kode, memberikan keuntungan besar lain - menjadi mungkin untuk bekerja dengan perkalian integer / divisi (saya ingat bahwa Z80 tidak memiliki perkalian integer dan perintah pembagian), dan juga (lihatlah!), Kemampuan untuk bekerja dengan angka titik mengambang. Namun, untuk ini saya harus berurusan dengan perpustakaan yang terpasang pada kompiler,karena semua operasi matematika setelah kompilasi dilakukan sebagai panggilan ke perpustakaan ini. Masalahnya adalah bahwa perpustakaan ini menggunakan variabel temporer yang ditempatkan oleh kompiler dalam model memori khusus untuk TR-DOS, yang, tentu saja, sama sekali tidak sesuai dengan model memori komputer saya. Saya harus mencari semua variabel sementara seperti itu dan mengulanginya untuk alamat yang sesuai dengan RAM saya. Tetapi sebagai bonus, saya mendapat banyak fungsi standar seperti sinus dan cosinus, yang saya gunakan dalam tugas saya, yang akan saya bahas di bawah ini.Saya harus mencari semua variabel sementara seperti itu dan mengulanginya untuk alamat yang sesuai dengan RAM saya. Tetapi sebagai bonus, saya mendapat banyak fungsi standar seperti sinus dan cosinus, yang saya gunakan dalam tugas saya, yang akan saya bahas di bawah ini.Saya harus mencari semua variabel sementara seperti itu dan mengulanginya untuk alamat yang sesuai dengan RAM saya. Tetapi sebagai bonus, saya mendapat banyak fungsi standar seperti sinus dan cosinus, yang saya gunakan dalam tugas saya, yang akan saya bahas di bawah ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program pertama yang dibuat menggunakan kompiler C adalah program untuk memeriksa operasi RAM yang benar. Program ini melewati seluruh RAM, menulis, dan kemudian membaca berbagai pola dan membandingkan hasilnya. Selain itu, seluruh proses ditampilkan pada layar LCD, yang juga mengkonfirmasi operasi yang benar dari prosedur yang terkait dengannya. Jelas bahwa ini hanya ujian sebelum menulis program yang lebih menarik. Hal berikutnya yang saya lakukan adalah membuat hex editor untuk mengubah isi RAM. Editor ini sudah memiliki kemungkinan yang cukup luas, termasuk tidak hanya melihat dan mengedit sel memori, tetapi juga mencari byte yang menarik dalam RAM. Secara khusus, menjadi mungkin untuk menulis program kecil secara langsung dalam RAM dalam kode mesin. Untuk menguji kemampuan suara komputer Anda,Saya membuat program seperti "kotak musik" yang memainkan berbagai melodi (saya ingat melodi direkam sebagai catatan). Lebih lanjut, sebuah program untuk permainan "bulls and sapi" ditulis, di mana seseorang diminta untuk menebak angka acak empat digit yang dikandung oleh komputer (ya, saya juga membuat generator angka acak). Dalam program ini, saya harus membuat daftar gulir dengan riwayat nomor yang sudah dimasukkan, karena tidak mungkin untuk menampilkan daftar panjang pada dua baris. Program berikutnya yang dibuat adalah "pencari ranjau" klasik pada bidang 16x16. Karena saya hanya memiliki dua garis yang tersedia, saya melakukan pengguliran, menambahkan iringan musik dan animasi bendera yang terbang di angin dan meledak bom. Selanjutnya, untuk meditasi, saya membuat sebuah program yang menunjukkan cacing merangkak ke arah yang acak,menggunakan kemampuan untuk mengunggah gambar khusus ke layar. Nah, dan di mana tanpa tic-tac-toe klasik? Di dalamnya saya menguji algoritma minimax, yaitu komputer menghitung (agak cepat) semua opsi dan tidak pernah hilang. Karena sistem operasi saya mendukung alarm, waktu, dan kalender, saya membuat program pengguna yang mengatur waktu, tanggal, dan beberapa alarm yang, ketika waktu yang ditentukan tercapai, memainkan melodi yang berbeda. Dan akhirnya, mahkota penciptaan di komputer saya adalah program untuk menghitung lintasan gerak dalam masalah dua benda gravitasi. Yaitu, untuk posisi awal dan kecepatan tubuh tertentu, serta massa dari pusat penarik,masalah integrasi numerik dari sistem dua persamaan diferensial biasa nonlinier dari urutan kedua dengan langkah integrasi yang diberikan diselesaikan. Untuk ini, saya menambahkan prosedur yang secara numerik mengintegrasikan persamaan ini. Semua variabel adalah format floating point ganda. Di sini saya menekankan sekali lagi bahwa dalam prosesor z80 tidak hanya ada dukungan perangkat keras untuk bekerja dengan floating point, tetapi juga perkalian / pembagian bilangan bulat biasa, semuanya dilakukan secara terprogram. Integrasi ini bekerja sangat lambat, sekitar satu langkah per detik, tetapi berhasil!tetapi juga perkalian / pembagian bilangan bulat biasa, semuanya dilakukan secara terprogram. Integrasi ini bekerja sangat lambat, sekitar satu langkah per detik, tetapi berhasil!tetapi juga perkalian / pembagian bilangan bulat biasa, semuanya dilakukan secara terprogram. Integrasi ini bekerja sangat lambat, sekitar satu langkah per detik, tetapi berhasil!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang masih ingin saya implementasikan, tetapi tidak berhasil - pertama, alokasi dinamis / deallokasi memori, sehingga saya dapat secara fleksibel mengelola sumber daya dari setiap tugas. </font><font style="vertical-align: inherit;">Juga, perekaman / pembacaan pada kaset tidak dilaksanakan, seperti yang dilakukan di Sinclair. </font><font style="vertical-align: inherit;">Tetapi secara keseluruhan, saya senang dengan apa yang berhasil saya lakukan. </font><font style="vertical-align: inherit;">Saya menekankan bahwa semua hal di atas adalah dalam ROM 32 kilobyte - ukuran saat ini dari satu email yang tidak terlalu besar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat komputer saya beraksi di sini:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/3J76Rx2lqXQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/iT-V_L6mIfA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan unduh perangkat lunaknya di sini</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497074/index.html">Tentang Phrasal Verbs-3 (on / off)</a></li>
<li><a href="../id497080/index.html">â€œAnda Tidak Bisa Bosan Di Sini: Cara Kerjanya di Cabang Regional Solar JSOC</a></li>
<li><a href="../id497082/index.html">Presentasi Rapat ROS kedua tentang topik: Gazebo dan alat untuk robot</a></li>
<li><a href="../id497086/index.html">CQRS dan Layanan Mikro dalam Pengembangan Produk</a></li>
<li><a href="../id497090/index.html">Node.js pada tahun 2020: Keluar dan Keluar Secara Normal</a></li>
<li><a href="../id497096/index.html">Pertahanan ancaman seluler: langkah pemasaran atau tren baru?</a></li>
<li><a href="../id497098/index.html">Bagaimana kami membuat autopilot pertama untuk pemanen gabungan pada analitik video di dunia</a></li>
<li><a href="../id497100/index.html">Luncurkan Jupyter ke orbit LXD</a></li>
<li><a href="../id497106/index.html">Tutorial jaringan simulator ns-3. Bab 1.2</a></li>
<li><a href="../id497108/index.html">Fighting Covid-2019: Giliran Besar datang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>