<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¢ üíÜüèª üå∑ Anzeigen von Suchergebnissen und Leistungsproblemen üë®üèæ üôéüèΩ üë©üèº‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eines der typischen Szenarien in allen bekannten Anwendungen besteht darin, nach bestimmten Kriterien nach Daten zu suchen und diese in einer leicht l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Anzeigen von Suchergebnissen und Leistungsproblemen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/493438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der typischen Szenarien in allen bekannten Anwendungen besteht darin, nach bestimmten Kriterien nach Daten zu suchen und diese in einer leicht lesbaren Form anzuzeigen. </font><font style="vertical-align: inherit;">Es kann auch zus√§tzliche M√∂glichkeiten zum Sortieren, Gruppieren und Paginieren geben. </font><font style="vertical-align: inherit;">Theoretisch ist die Aufgabe trivial, aber bei der L√∂sung machen viele Entwickler eine Reihe von Fehlern, die dann unter der Leistung leiden. </font><font style="vertical-align: inherit;">Lassen Sie uns versuchen, verschiedene L√∂sungen f√ºr dieses Problem in Betracht zu ziehen und Empfehlungen f√ºr die Auswahl der effektivsten Implementierung zu formulieren.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/kc/-s/mskc-s_1t4wcxa9w7i04zg4cjjq.jpeg" alt="Bild"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paging-Option 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Option, die Ihnen in den Sinn kommt, besteht darin, die Suchergebnisse in ihrer klassischsten Form zu paginieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/xx/vs/rdxxvst5xhcdfxzvlgrob1csxdk.png" width="498" height="232"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, eine Anwendung verwendet eine relationale Datenbank. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen Sie zwei SQL-Abfragen ausf√ºhren, um Informationen in diesem Formular anzuzeigen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeilen f√ºr die aktuelle Seite abrufen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie die Gesamtzahl der Zeilen, die den Suchkriterien entsprechen - dies ist zum Anzeigen von Seiten erforderlich.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die erste Abfrage am Beispiel der Test-MS SQL-Datenbank </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdventureWorks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 2016 Server. </font><font style="vertical-align: inherit;">Zu diesem Zweck verwenden wir die Tabelle Sales.SalesOrderHeader:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obige Abfrage zeigt die ersten 50 Bestellungen aus einer Liste an, sortiert in absteigender Reihenfolge nach dem Datum der Hinzuf√ºgung, dh den letzten 50 Bestellungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es l√§uft schnell auf Testbasis, aber schauen wir uns den Ausf√ºhrungsplan und die E / A-Statistiken an:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/e8/u8/rwe8u8un-1t5bm3yttan4qsfqrg.png" width="624" height="144"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen E / A-Statistiken f√ºr jede Anforderung abrufen, indem Sie den Befehl SET STATISTICS IO ON in der Abfragelaufzeit ausf√ºhren. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie dem Ausf√ºhrungsplan entnehmen k√∂nnen, ist es am ressourcenintensivsten, alle Zeilen der Quelltabelle nach dem Datum des Hinzuf√ºgens zu sortieren. </font><font style="vertical-align: inherit;">Und das Problem ist, dass die Sortierung umso schwieriger ist, je mehr Zeilen in der Tabelle angezeigt werden. </font><font style="vertical-align: inherit;">In der Praxis sollten solche Situationen vermieden werden. F√ºgen Sie daher den Index zum Zeitpunkt der Hinzuf√ºgung hinzu und pr√ºfen Sie, ob sich der Ressourcenverbrauch ge√§ndert hat:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7y/so/g1/7ysog13xd9kalhv9fakieghj4je.png" width="720" height="148"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 165, physical reads 0, read-ahead reads 5, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich wurde es viel besser. </font><font style="vertical-align: inherit;">Aber wurden alle Probleme gel√∂st? </font><font style="vertical-align: inherit;">Lassen Sie uns die Suchanforderung f√ºr Bestellungen √§ndern, bei denen die Gesamtkosten der Waren 100 USD √ºberschreiten:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yn/_c/7s/yn_c7stdebp1utx8_ck4fbrvxjq.png" width="800" height="137"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 1081, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine lustige Situation: Der Abfrageplan ist etwas schlechter als der vorherige, aber die tats√§chliche Anzahl der logischen Lesungen ist fast doppelt so hoch wie bei einem vollst√§ndigen Tabellenscan. </font><font style="vertical-align: inherit;">Es gibt eine L√∂sung: Wenn wir den zusammengesetzten Preis aus dem vorhandenen Index erstellen und den Gesamtpreis der Waren als zweites Feld addieren, erhalten wir erneut 165 logische Lesevorg√§nge:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> IX_SalesOrderHeader_OrderDate_SubTotal <span class="hljs-keyword">on</span> Sales.SalesOrderHeader(OrderDate, SubTotal);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Reihe von Beispielen kann noch lange fortgesetzt werden, aber die beiden Hauptgedanken, die ich hier ausdr√ºcken m√∂chte, sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzuf√ºgen eines neuen Kriteriums oder einer neuen Sortierreihenfolge zur Suchabfrage kann die Ausf√ºhrungsgeschwindigkeit erheblich beeinflussen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jedoch nur einen Teil der Daten und nicht alle Ergebnisse subtrahieren m√ºssen, die den Suchbedingungen entsprechen, gibt es viele M√∂glichkeiten, eine solche Abfrage zu optimieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir nun mit der zweiten Abfrage fort, die ganz am Anfang erw√§hnt wurde - mit der Abfrage, die die Anzahl der Datens√§tze z√§hlt, die die Suchkriterien erf√ºllen. </font><font style="vertical-align: inherit;">Nehmen Sie das gleiche Beispiel: Finden Sie Bestellungen, die mehr als 100 US-Dollar kosten:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Gegenwart des oben angegebenen zusammengesetzten Index erhalten wir:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/tg/yz/nbtgyzsg7her2lswpnfq2jbmotk.png" width="517" height="197"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass die Abfrage den gesamten Index durchl√§uft, ist nicht √ºberraschend, da sich das Zwischensummenfeld nicht an der ersten Position befindet und die Abfrage es daher nicht verwenden kann. Das Problem wird gel√∂st, indem dem Feld Zwischensumme ein weiterer Index hinzugef√ºgt wird. Infolgedessen werden bereits 48 logische Lesevorg√§nge ausgef√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen noch einige Beispiele f√ºr Anforderungen zum Z√§hlen der Menge nennen, aber das Wesentliche bleibt gleich: Das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empfangen eines Teils der Daten und das Z√§hlen der Gesamtmenge sind zwei grundlegend unterschiedliche Anforderungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und jede erfordert ihre eigenen Optimierungsma√ünahmen. Im allgemeinen Fall k√∂nnen Sie keine Kombination von Indizes finden, die f√ºr beide Abfragen gleich gut funktioniert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend ist eine der wichtigen Anforderungen, die bei der Entwicklung einer solchen Suchl√∂sung gekl√§rt werden sollten, ob es f√ºr das Unternehmen wirklich wichtig ist, die Gesamtzahl der gefundenen Objekte zu sehen. </font><font style="vertical-align: inherit;">Es kommt oft vor, dass nein. </font><font style="vertical-align: inherit;">Die Navigation zu bestimmten Seitenzahlen ist meiner Meinung nach eine L√∂sung mit einem sehr engen Umfang, da die meisten Paging-Szenarien wie "Zur n√§chsten Seite gehen" aussehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paging-Option 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Benutzer m√∂chten nicht wissen, wie viele Objekte insgesamt gefunden wurden. </font><font style="vertical-align: inherit;">Versuchen wir, die Suchseite zu vereinfachen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/pr/1t/tcpr1teevrkdz8tcwsbjmx_dl5i.png" width="498" height="230"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich hat sich nur die Tatsache ge√§ndert, dass es keine M√∂glichkeit gibt, zu bestimmten Seitenzahlen zu gelangen, und jetzt muss diese Tabelle nicht mehr wissen, wie viele davon angezeigt werden k√∂nnen. Es stellt sich jedoch die Frage: Woher wei√ü die Tabelle, ob Daten f√ºr die n√§chste Seite vorhanden sind (um den Link ‚ÄûWeiter‚Äú korrekt anzuzeigen)? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort ist sehr einfach: Sie k√∂nnen einen Datensatz mehr von der Datenbank abziehen, als Sie anzeigen m√ºssen, und das Vorhandensein dieses "zus√§tzlichen" Datensatzes zeigt an, ob der n√§chste Teil vorhanden ist. Um eine Seite mit Daten zu erhalten, m√ºssen Sie nur eine Abfrage ausf√ºhren. Dies verbessert die Leistung erheblich und erleichtert die Unterst√ºtzung dieser Funktionalit√§t. In meiner Praxis gab es einen Fall, in dem die Weigerung, die Gesamtzahl der Datens√§tze zu z√§hlen, die Ausgabe der Ergebnisse um das 4-5-fache beschleunigte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diesen Ansatz gibt es mehrere Optionen f√ºr die Benutzeroberfl√§che: die Befehle "Zur√ºck" und "Vorw√§rts", wie im obigen Beispiel, die Schaltfl√§che "Mehr laden", die den angezeigten Ergebnissen einfach einen neuen Teil hinzuf√ºgt, "unendliches Scrollen", der nach dem Prinzip "Mehr laden" funktioniert. ", Aber das Signal, um den n√§chsten Teil zu erhalten, ist der Benutzer, durch alle angezeigten Ergebnisse bis zum Ende zu scrollen. </font><font style="vertical-align: inherit;">Unabh√§ngig von der visuellen L√∂sung bleibt das Prinzip der Datenerfassung gleich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Nuancen der Implementierung von Paging</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In allen Beispielen der obigen Abfragen wird der Ansatz "Offset + Nummer" verwendet, wenn die Abfrage selbst angibt, in welcher Reihenfolge die Ergebniszeilen und wie viele Zeilen zur√ºckgegeben werden sollen. </font><font style="vertical-align: inherit;">√úberlegen Sie zun√§chst, wie Sie die √úbertragung von Parametern in diesem Fall am besten organisieren k√∂nnen. </font><font style="vertical-align: inherit;">In der Praxis habe ich verschiedene Wege getroffen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Seriennummer der angeforderten Seite (pageIndex), Seitengr√∂√üe (pageSize).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Seriennummer des ersten zur√ºckgegebenen Datensatzes (startIndex), die maximale Anzahl der Datens√§tze als Ergebnis (Anzahl).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Seriennummer des ersten zur√ºckgegebenen Datensatzes (startIndex), die Seriennummer des zuletzt zur√ºckgegebenen Datensatzes (endIndex).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick scheint dies so elementar zu sein, dass es keinen Unterschied gibt. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht der Fall - die bequemste und universellste Option ist die zweite (startIndex, count). </font><font style="vertical-align: inherit;">Daf√ºr gibt es mehrere Gr√ºnde:</font></font><br>
<br>
<ul>
<li>    +1 ,  ,    pageIndex  pageSize  . ,    50   .    ,      ,  .   ¬´+1¬ª    , ,          1  51,   ‚Äî  51  101  ..     51   pageIndex,      52  102  .. ,             ‚Äî     ¬´¬ª ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die dritte Option ist √ºberhaupt nicht sinnvoll, da Sie zum Ausf√ºhren von Abfragen in den meisten Datenbanken immer noch die Menge und nicht den Index des letzten Datensatzes √ºbertragen m√ºssen. </font><font style="vertical-align: inherit;">Lassen Sie die Subtraktion von startIndex von endIndex und eine elementare arithmetische Operation, aber es ist hier √ºberfl√ºssig.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun sollten wir die M√§ngel der Implementierung von Paging durch "Offset + Menge" beschreiben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Abrufen jeder n√§chsten Seite ist teurer und langsamer als die vorherige, da die Datenbank weiterhin alle Datens√§tze "von Anfang an" gem√§√ü den Such- und Sortierkriterien durchsuchen und dann beim gew√ºnschten Fragment anhalten muss.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle DBMS k√∂nnen diesen Ansatz unterst√ºtzen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Alternativen, aber sie sind auch unvollkommen. </font><font style="vertical-align: inherit;">Der erste dieser Ans√§tze wird als "Keyset-Paging" oder "Suchmethode" bezeichnet und besteht aus Folgendem: Nach dem Empfang eines Teils k√∂nnen Sie sich die Werte der Felder im letzten Datensatz auf der Seite merken und sie dann verwenden, um den n√§chsten Teil abzurufen. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir die folgende Anfrage ausgef√ºhrt:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und im letzten Datensatz haben wir den Wert des Bestelldatums '2014-06-29' erhalten. </font><font style="vertical-align: inherit;">Um zur n√§chsten Seite zu gelangen, k√∂nnen Sie Folgendes versuchen:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass OrderDate ein nicht eindeutiges Feld ist und die oben erw√§hnte Bedingung wahrscheinlich viele der erforderlichen Zeilen √ºberspringt. </font><font style="vertical-align: inherit;">Um diese Anforderung eindeutig zu machen, m√ºssen Sie der Bedingung ein eindeutiges Feld hinzuf√ºgen (angenommen, 75074 ist der letzte Wert des Prim√§rschl√ºssels aus dem ersten Teil):</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> (OrderDate = <span class="hljs-string">'2014-06-29'</span> <span class="hljs-keyword">AND</span> SalesOrderID &lt; <span class="hljs-number">75074</span>)
   <span class="hljs-keyword">OR</span> (OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>, SalesOrderID <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Option funktioniert ordnungsgem√§√ü, ist jedoch im Allgemeinen schwierig zu optimieren, da die Bedingung den Operator OR enth√§lt. Wenn der Wert des Prim√§rschl√ºssels mit dem Wachstum von OrderDate w√§chst, kann die Bedingung vereinfacht werden, indem nur der Filter von SalesOrderID belassen wird. Wenn jedoch keine strikte Korrelation zwischen den Werten des Prim√§rschl√ºssels und dem Feld besteht, nach dem das Ergebnis sortiert ist, kann dieses ODER in den meisten DBMS nicht vermieden werden. Die mir bekannte Ausnahme ist PostgreSQL, wo der Tupelvergleich vollst√§ndig unterst√ºtzt wird und die obige Bedingung als "WHERE (OrderDate, SalesOrderID) &lt;('2014-06-29', 75074) geschrieben werden kann. Wenn Sie einen zusammengesetzten Schl√ºssel mit diesen beiden Feldern haben, sollte eine √§hnliche Anforderung ziemlich einfach sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite alternative Ansatz kann beispielsweise in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ElasticSearch-Bildlauf-API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder gefunden werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cosmos DB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wenn eine Abfrage zus√§tzlich zu Daten eine spezielle Kennung zur√ºckgibt, mit der Sie den n√§chsten Datenstapel abrufen k√∂nnen. </font><font style="vertical-align: inherit;">Wenn dieser Bezeichner eine unbegrenzte Lebensdauer hat (wie in Comsos DB), ist dies eine hervorragende M√∂glichkeit, Paging mit sequentiellem √úbergang zwischen Seiten zu implementieren (Option 2 oben erw√§hnt). </font><font style="vertical-align: inherit;">M√∂gliche Nachteile: Nicht alle DBMS werden unterst√ºtzt. </font><font style="vertical-align: inherit;">Die empfangene n√§chste Stapelkennung hat m√∂glicherweise eine begrenzte Lebensdauer, was im Allgemeinen nicht f√ºr die Implementierung der Benutzerinteraktion geeignet ist (z. B. die ElasticSearch-Bildlauf-API).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexe Filterung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erschweren die Aufgabe weiter. </font><font style="vertical-align: inherit;">Angenommen, es ist erforderlich, die sogenannte facettierte Suche zu implementieren, die jedem aus Online-Shops bekannt ist. </font><font style="vertical-align: inherit;">Die obigen Beispiele, die auf der Auftragstabelle basieren, sind in diesem Fall nicht sehr aussagekr√§ftig. Daher wechseln wir aus der AdventureWorks-Datenbank zur Produkttabelle:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/di/ws/13/diws13cm-qjxoy3igxslnbvizca.png" width="595" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist die Idee der facettierten Suche? </font><font style="vertical-align: inherit;">Dabei wird f√ºr jedes Filterelement die Anzahl der Datens√§tze angezeigt, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diesem Kriterium entsprechen, </font><i><font style="vertical-align: inherit;">wobei die in allen anderen Kategorien ausgew√§hlten Filter ber√ºcksichtigt werden</font></i><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir in diesem Beispiel beispielsweise die Kategorie Fahrr√§der und die Farbe Schwarz ausw√§hlen, werden in der Tabelle nur schwarze Fahrr√§der angezeigt, aber gleichzeitig:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr jedes Kriterium der Gruppe ‚ÄûKategorien‚Äú wird die Anzahl der Produkte aus dieser Kategorie in Schwarz angezeigt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr jedes Kriterium der Gruppe Farben wird die Anzahl der Fahrr√§der dieser Farbe angezeigt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel f√ºr die Ausgabe des Ergebnisses f√ºr solche Bedingungen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/y8/v2/q2/y8v2q2j76mcfnmjmirzu8jrnhyu.png" width="605" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn neben der Kategorie ‚ÄûKleidung‚Äú auch die verf√ºgbaren schwarzen Kleidungsst√ºcke in der Tabelle angezeigt werden. </font><font style="vertical-align: inherit;">Die Anzahl der schwarzen Produkte im Abschnitt "Farbe" wird ebenfalls gem√§√ü den neuen Bedingungen neu berechnet. Nur im Abschnitt "Kategorien" √§ndert sich nichts ... Ich hoffe, diese Beispiele reichen aus, um den bekannten facettierten Suchalgorithmus zu verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich nun vor, wie dies relational implementiert werden kann. </font><font style="vertical-align: inherit;">F√ºr jede Gruppe von Kriterien wie Kategorie und Farbe ist eine separate Anforderung erforderlich:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> pc.ProductCategoryID, pc.Name, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductCategory pc <span class="hljs-keyword">ON</span> ps.ProductCategoryID = pc.ProductCategoryID
<span class="hljs-keyword">WHERE</span> p.Color = <span class="hljs-string">'Black'</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pc.ProductCategoryID, pc.Name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/79/az/mf79azaflzgu-1gatq4gtbhcdzw.png" width="331" height="90"></div><br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> Color, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
<span class="hljs-keyword">WHERE</span> ps.ProductCategoryID = <span class="hljs-number">1</span> <span class="hljs-comment">--Bikes</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Color
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/ec/r5/cfecr5njjmi93lsdrei1teygmhi.png" width="190" height="110"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist falsch an dieser Entscheidung? </font><font style="vertical-align: inherit;">Sehr einfach - es skaliert nicht gut. </font><font style="vertical-align: inherit;">Jeder Filterabschnitt erfordert eine separate Abfrage zum Z√§hlen von Mengen, und diese Abfragen sind nicht die einfachsten. </font><font style="vertical-align: inherit;">In Online-Shops kann es in einigen Abschnitten mehrere Dutzend Abschnitte des Filters geben, was ein ernstes Leistungsproblem darstellen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise bieten sie mir nach diesen Aussagen einige L√∂sungen an, n√§mlich:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kombinieren Sie alle Mengenzahlen in einer Abfrage. </font><font style="vertical-align: inherit;">Technisch ist dies mit dem Schl√ºsselwort UNION m√∂glich, nur hilft es nicht viel bei der Leistung - auf jeden Fall muss die Datenbank jedes Fragment von Grund auf neu ausf√ºhren.</font></font></li>
<li> .      ,    .   ,      . ,   10 ¬´¬ª,     5 .   ¬´¬ª    ,       -.         9- ,  ,        .     50 ,    ,     2<sup>50</sup>.         ,  .     ,            5-10 . ,          ,  -  ,      ,                (     ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gl√ºcklicherweise hat eine solche Aufgabe seit langem ausreichend effektive L√∂sungen, die vorhersehbar mit gro√üen Datenmengen funktionieren. F√ºr jede dieser Optionen ist es sinnvoll, die Neuberechnung der Facetten und das Abrufen der Ergebnisseite in zwei parallele Aufrufe an den Server zu unterteilen und die Benutzeroberfl√§che so zu organisieren, dass das Laden der Daten in die Facetten die Anzeige der Suchergebnisse nicht beeintr√§chtigt.</font></font><br>
<br>
<ul>
<li>   ¬´¬ª   . ,        ,       ,   ,      ‚Äî ¬´1425  , ?¬ª       ,    ¬´¬ª.                 ¬´¬ª.  ,   ,             .        -. ,       ,        .</li>
<li> search engine      ,   Solr, ElasticSearch, Sphinx  .      ¬´¬ª         .    ,          ,       ‚Äî     .      ,  search engine       ,    :     ,    ,    ;       search engine      .       ‚Äî     .      ¬´ ¬ª.          ¬´¬ª    ,   ,            .      ,   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">transactional outbox</a>      .</li>
</ul><br>
<h2></h2><br>
<ol>
<li>     ‚Äî  ,             .   ¬´¬ª  ¬´¬ª ‚Äî    ,      :<br>
<ul>
<li>                   ‚Äî       .</li>
<li>   ,         ,    ,     .  -          ‚Äî    .</li>
</ul></li>
<li>                ,          ‚Äî         #2.</li>
<li>     faceted search,        :<br>
<ul>
<li>        .</li>
<li> search engine   Solr, ElasticSearch, Sphinx  .   ,         ,            . </li>
</ul></li>
<li>   faceted search              .      ,   ,        .</li>
<li>   SQL   ,   ,    ,           (   ¬´¬ª ).           ,   ‚Äî  ¬´¬ª.           ,        .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493426/index.html">Organisation von Code in Microservices und mein Ansatz zur Verwendung von hexagonaler Architektur und DDD</a></li>
<li><a href="../de493428/index.html">"Wir werden keine Verschw√∂rungstheorien hervorbringen." Sprechen Sie √ºber ML-Konferenzen mit Menschen aus Wissenschafts- und IT-Unternehmen</a></li>
<li><a href="../de493430/index.html">Netzarchitektur f√ºr Webanwendungen</a></li>
<li><a href="../de493432/index.html">Warum nicht eine Karriere in einem kleinen Nicht-IT-Unternehmen beginnen?</a></li>
<li><a href="../de493436/index.html">Programm zum √Ñndern von Zugriffsrechten und zum Registrieren von Datei- / Verzeichnisnamen auf Bash</a></li>
<li><a href="../de493440/index.html">Influencer Marketing in China: Worauf basiert es und was k√∂nnen Influencer im Notfall bieten?</a></li>
<li><a href="../de493442/index.html">PSA-Erinnerung</a></li>
<li><a href="../de493444/index.html">Das Projekt "Glas". Energieeffizienz-Einweg-Tee- / Kaffeetassen</a></li>
<li><a href="../de493446/index.html">Wochenendlesung: 10 ungew√∂hnliche Soundgeschichten - von Spionagespielen und Verschw√∂rungstheorien bis hin zu entspannender ASMR</a></li>
<li><a href="../de493448/index.html">Federeffizientes Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>