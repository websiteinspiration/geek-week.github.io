<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 💆🏻 🌷 Anzeigen von Suchergebnissen und Leistungsproblemen 👨🏾 🙎🏽 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eines der typischen Szenarien in allen bekannten Anwendungen besteht darin, nach bestimmten Kriterien nach Daten zu suchen und diese in einer leicht l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Anzeigen von Suchergebnissen und Leistungsproblemen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/493438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der typischen Szenarien in allen bekannten Anwendungen besteht darin, nach bestimmten Kriterien nach Daten zu suchen und diese in einer leicht lesbaren Form anzuzeigen. </font><font style="vertical-align: inherit;">Es kann auch zusätzliche Möglichkeiten zum Sortieren, Gruppieren und Paginieren geben. </font><font style="vertical-align: inherit;">Theoretisch ist die Aufgabe trivial, aber bei der Lösung machen viele Entwickler eine Reihe von Fehlern, die dann unter der Leistung leiden. </font><font style="vertical-align: inherit;">Lassen Sie uns versuchen, verschiedene Lösungen für dieses Problem in Betracht zu ziehen und Empfehlungen für die Auswahl der effektivsten Implementierung zu formulieren.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/kc/-s/mskc-s_1t4wcxa9w7i04zg4cjjq.jpeg" alt="Bild"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paging-Option 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Option, die Ihnen in den Sinn kommt, besteht darin, die Suchergebnisse in ihrer klassischsten Form zu paginieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/xx/vs/rdxxvst5xhcdfxzvlgrob1csxdk.png" width="498" height="232"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, eine Anwendung verwendet eine relationale Datenbank. </font><font style="vertical-align: inherit;">In diesem Fall müssen Sie zwei SQL-Abfragen ausführen, um Informationen in diesem Formular anzuzeigen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeilen für die aktuelle Seite abrufen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen Sie die Gesamtzahl der Zeilen, die den Suchkriterien entsprechen - dies ist zum Anzeigen von Seiten erforderlich.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die erste Abfrage am Beispiel der Test-MS SQL-Datenbank </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdventureWorks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 2016 Server. </font><font style="vertical-align: inherit;">Zu diesem Zweck verwenden wir die Tabelle Sales.SalesOrderHeader:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obige Abfrage zeigt die ersten 50 Bestellungen aus einer Liste an, sortiert in absteigender Reihenfolge nach dem Datum der Hinzufügung, dh den letzten 50 Bestellungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es läuft schnell auf Testbasis, aber schauen wir uns den Ausführungsplan und die E / A-Statistiken an:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/e8/u8/rwe8u8un-1t5bm3yttan4qsfqrg.png" width="624" height="144"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können E / A-Statistiken für jede Anforderung abrufen, indem Sie den Befehl SET STATISTICS IO ON in der Abfragelaufzeit ausführen. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie dem Ausführungsplan entnehmen können, ist es am ressourcenintensivsten, alle Zeilen der Quelltabelle nach dem Datum des Hinzufügens zu sortieren. </font><font style="vertical-align: inherit;">Und das Problem ist, dass die Sortierung umso schwieriger ist, je mehr Zeilen in der Tabelle angezeigt werden. </font><font style="vertical-align: inherit;">In der Praxis sollten solche Situationen vermieden werden. Fügen Sie daher den Index zum Zeitpunkt der Hinzufügung hinzu und prüfen Sie, ob sich der Ressourcenverbrauch geändert hat:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7y/so/g1/7ysog13xd9kalhv9fakieghj4je.png" width="720" height="148"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 165, physical reads 0, read-ahead reads 5, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich wurde es viel besser. </font><font style="vertical-align: inherit;">Aber wurden alle Probleme gelöst? </font><font style="vertical-align: inherit;">Lassen Sie uns die Suchanforderung für Bestellungen ändern, bei denen die Gesamtkosten der Waren 100 USD überschreiten:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yn/_c/7s/yn_c7stdebp1utx8_ck4fbrvxjq.png" width="800" height="137"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 1081, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine lustige Situation: Der Abfrageplan ist etwas schlechter als der vorherige, aber die tatsächliche Anzahl der logischen Lesungen ist fast doppelt so hoch wie bei einem vollständigen Tabellenscan. </font><font style="vertical-align: inherit;">Es gibt eine Lösung: Wenn wir den zusammengesetzten Preis aus dem vorhandenen Index erstellen und den Gesamtpreis der Waren als zweites Feld addieren, erhalten wir erneut 165 logische Lesevorgänge:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> IX_SalesOrderHeader_OrderDate_SubTotal <span class="hljs-keyword">on</span> Sales.SalesOrderHeader(OrderDate, SubTotal);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Reihe von Beispielen kann noch lange fortgesetzt werden, aber die beiden Hauptgedanken, die ich hier ausdrücken möchte, sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzufügen eines neuen Kriteriums oder einer neuen Sortierreihenfolge zur Suchabfrage kann die Ausführungsgeschwindigkeit erheblich beeinflussen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jedoch nur einen Teil der Daten und nicht alle Ergebnisse subtrahieren müssen, die den Suchbedingungen entsprechen, gibt es viele Möglichkeiten, eine solche Abfrage zu optimieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir nun mit der zweiten Abfrage fort, die ganz am Anfang erwähnt wurde - mit der Abfrage, die die Anzahl der Datensätze zählt, die die Suchkriterien erfüllen. </font><font style="vertical-align: inherit;">Nehmen Sie das gleiche Beispiel: Finden Sie Bestellungen, die mehr als 100 US-Dollar kosten:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Gegenwart des oben angegebenen zusammengesetzten Index erhalten wir:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/tg/yz/nbtgyzsg7her2lswpnfq2jbmotk.png" width="517" height="197"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass die Abfrage den gesamten Index durchläuft, ist nicht überraschend, da sich das Zwischensummenfeld nicht an der ersten Position befindet und die Abfrage es daher nicht verwenden kann. Das Problem wird gelöst, indem dem Feld Zwischensumme ein weiterer Index hinzugefügt wird. Infolgedessen werden bereits 48 logische Lesevorgänge ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können noch einige Beispiele für Anforderungen zum Zählen der Menge nennen, aber das Wesentliche bleibt gleich: Das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empfangen eines Teils der Daten und das Zählen der Gesamtmenge sind zwei grundlegend unterschiedliche Anforderungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und jede erfordert ihre eigenen Optimierungsmaßnahmen. Im allgemeinen Fall können Sie keine Kombination von Indizes finden, die für beide Abfragen gleich gut funktioniert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend ist eine der wichtigen Anforderungen, die bei der Entwicklung einer solchen Suchlösung geklärt werden sollten, ob es für das Unternehmen wirklich wichtig ist, die Gesamtzahl der gefundenen Objekte zu sehen. </font><font style="vertical-align: inherit;">Es kommt oft vor, dass nein. </font><font style="vertical-align: inherit;">Die Navigation zu bestimmten Seitenzahlen ist meiner Meinung nach eine Lösung mit einem sehr engen Umfang, da die meisten Paging-Szenarien wie "Zur nächsten Seite gehen" aussehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paging-Option 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Benutzer möchten nicht wissen, wie viele Objekte insgesamt gefunden wurden. </font><font style="vertical-align: inherit;">Versuchen wir, die Suchseite zu vereinfachen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/pr/1t/tcpr1teevrkdz8tcwsbjmx_dl5i.png" width="498" height="230"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich hat sich nur die Tatsache geändert, dass es keine Möglichkeit gibt, zu bestimmten Seitenzahlen zu gelangen, und jetzt muss diese Tabelle nicht mehr wissen, wie viele davon angezeigt werden können. Es stellt sich jedoch die Frage: Woher weiß die Tabelle, ob Daten für die nächste Seite vorhanden sind (um den Link „Weiter“ korrekt anzuzeigen)? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort ist sehr einfach: Sie können einen Datensatz mehr von der Datenbank abziehen, als Sie anzeigen müssen, und das Vorhandensein dieses "zusätzlichen" Datensatzes zeigt an, ob der nächste Teil vorhanden ist. Um eine Seite mit Daten zu erhalten, müssen Sie nur eine Abfrage ausführen. Dies verbessert die Leistung erheblich und erleichtert die Unterstützung dieser Funktionalität. In meiner Praxis gab es einen Fall, in dem die Weigerung, die Gesamtzahl der Datensätze zu zählen, die Ausgabe der Ergebnisse um das 4-5-fache beschleunigte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diesen Ansatz gibt es mehrere Optionen für die Benutzeroberfläche: die Befehle "Zurück" und "Vorwärts", wie im obigen Beispiel, die Schaltfläche "Mehr laden", die den angezeigten Ergebnissen einfach einen neuen Teil hinzufügt, "unendliches Scrollen", der nach dem Prinzip "Mehr laden" funktioniert. ", Aber das Signal, um den nächsten Teil zu erhalten, ist der Benutzer, durch alle angezeigten Ergebnisse bis zum Ende zu scrollen. </font><font style="vertical-align: inherit;">Unabhängig von der visuellen Lösung bleibt das Prinzip der Datenerfassung gleich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Nuancen der Implementierung von Paging</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In allen Beispielen der obigen Abfragen wird der Ansatz "Offset + Nummer" verwendet, wenn die Abfrage selbst angibt, in welcher Reihenfolge die Ergebniszeilen und wie viele Zeilen zurückgegeben werden sollen. </font><font style="vertical-align: inherit;">Überlegen Sie zunächst, wie Sie die Übertragung von Parametern in diesem Fall am besten organisieren können. </font><font style="vertical-align: inherit;">In der Praxis habe ich verschiedene Wege getroffen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Seriennummer der angeforderten Seite (pageIndex), Seitengröße (pageSize).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Seriennummer des ersten zurückgegebenen Datensatzes (startIndex), die maximale Anzahl der Datensätze als Ergebnis (Anzahl).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Seriennummer des ersten zurückgegebenen Datensatzes (startIndex), die Seriennummer des zuletzt zurückgegebenen Datensatzes (endIndex).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick scheint dies so elementar zu sein, dass es keinen Unterschied gibt. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht der Fall - die bequemste und universellste Option ist die zweite (startIndex, count). </font><font style="vertical-align: inherit;">Dafür gibt es mehrere Gründe:</font></font><br>
<br>
<ul>
<li>    +1 ,  ,    pageIndex  pageSize  . ,    50   .    ,      ,  .   «+1»    , ,          1  51,   —  51  101  ..     51   pageIndex,      52  102  .. ,             —     «» ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die dritte Option ist überhaupt nicht sinnvoll, da Sie zum Ausführen von Abfragen in den meisten Datenbanken immer noch die Menge und nicht den Index des letzten Datensatzes übertragen müssen. </font><font style="vertical-align: inherit;">Lassen Sie die Subtraktion von startIndex von endIndex und eine elementare arithmetische Operation, aber es ist hier überflüssig.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun sollten wir die Mängel der Implementierung von Paging durch "Offset + Menge" beschreiben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Abrufen jeder nächsten Seite ist teurer und langsamer als die vorherige, da die Datenbank weiterhin alle Datensätze "von Anfang an" gemäß den Such- und Sortierkriterien durchsuchen und dann beim gewünschten Fragment anhalten muss.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle DBMS können diesen Ansatz unterstützen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Alternativen, aber sie sind auch unvollkommen. </font><font style="vertical-align: inherit;">Der erste dieser Ansätze wird als "Keyset-Paging" oder "Suchmethode" bezeichnet und besteht aus Folgendem: Nach dem Empfang eines Teils können Sie sich die Werte der Felder im letzten Datensatz auf der Seite merken und sie dann verwenden, um den nächsten Teil abzurufen. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir die folgende Anfrage ausgeführt:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und im letzten Datensatz haben wir den Wert des Bestelldatums '2014-06-29' erhalten. </font><font style="vertical-align: inherit;">Um zur nächsten Seite zu gelangen, können Sie Folgendes versuchen:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass OrderDate ein nicht eindeutiges Feld ist und die oben erwähnte Bedingung wahrscheinlich viele der erforderlichen Zeilen überspringt. </font><font style="vertical-align: inherit;">Um diese Anforderung eindeutig zu machen, müssen Sie der Bedingung ein eindeutiges Feld hinzufügen (angenommen, 75074 ist der letzte Wert des Primärschlüssels aus dem ersten Teil):</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> (OrderDate = <span class="hljs-string">'2014-06-29'</span> <span class="hljs-keyword">AND</span> SalesOrderID &lt; <span class="hljs-number">75074</span>)
   <span class="hljs-keyword">OR</span> (OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>, SalesOrderID <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Option funktioniert ordnungsgemäß, ist jedoch im Allgemeinen schwierig zu optimieren, da die Bedingung den Operator OR enthält. Wenn der Wert des Primärschlüssels mit dem Wachstum von OrderDate wächst, kann die Bedingung vereinfacht werden, indem nur der Filter von SalesOrderID belassen wird. Wenn jedoch keine strikte Korrelation zwischen den Werten des Primärschlüssels und dem Feld besteht, nach dem das Ergebnis sortiert ist, kann dieses ODER in den meisten DBMS nicht vermieden werden. Die mir bekannte Ausnahme ist PostgreSQL, wo der Tupelvergleich vollständig unterstützt wird und die obige Bedingung als "WHERE (OrderDate, SalesOrderID) &lt;('2014-06-29', 75074) geschrieben werden kann. Wenn Sie einen zusammengesetzten Schlüssel mit diesen beiden Feldern haben, sollte eine ähnliche Anforderung ziemlich einfach sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite alternative Ansatz kann beispielsweise in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ElasticSearch-Bildlauf-API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder gefunden werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cosmos DB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wenn eine Abfrage zusätzlich zu Daten eine spezielle Kennung zurückgibt, mit der Sie den nächsten Datenstapel abrufen können. </font><font style="vertical-align: inherit;">Wenn dieser Bezeichner eine unbegrenzte Lebensdauer hat (wie in Comsos DB), ist dies eine hervorragende Möglichkeit, Paging mit sequentiellem Übergang zwischen Seiten zu implementieren (Option 2 oben erwähnt). </font><font style="vertical-align: inherit;">Mögliche Nachteile: Nicht alle DBMS werden unterstützt. </font><font style="vertical-align: inherit;">Die empfangene nächste Stapelkennung hat möglicherweise eine begrenzte Lebensdauer, was im Allgemeinen nicht für die Implementierung der Benutzerinteraktion geeignet ist (z. B. die ElasticSearch-Bildlauf-API).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexe Filterung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erschweren die Aufgabe weiter. </font><font style="vertical-align: inherit;">Angenommen, es ist erforderlich, die sogenannte facettierte Suche zu implementieren, die jedem aus Online-Shops bekannt ist. </font><font style="vertical-align: inherit;">Die obigen Beispiele, die auf der Auftragstabelle basieren, sind in diesem Fall nicht sehr aussagekräftig. Daher wechseln wir aus der AdventureWorks-Datenbank zur Produkttabelle:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/di/ws/13/diws13cm-qjxoy3igxslnbvizca.png" width="595" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist die Idee der facettierten Suche? </font><font style="vertical-align: inherit;">Dabei wird für jedes Filterelement die Anzahl der Datensätze angezeigt, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diesem Kriterium entsprechen, </font><i><font style="vertical-align: inherit;">wobei die in allen anderen Kategorien ausgewählten Filter berücksichtigt werden</font></i><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir in diesem Beispiel beispielsweise die Kategorie Fahrräder und die Farbe Schwarz auswählen, werden in der Tabelle nur schwarze Fahrräder angezeigt, aber gleichzeitig:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für jedes Kriterium der Gruppe „Kategorien“ wird die Anzahl der Produkte aus dieser Kategorie in Schwarz angezeigt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für jedes Kriterium der Gruppe Farben wird die Anzahl der Fahrräder dieser Farbe angezeigt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel für die Ausgabe des Ergebnisses für solche Bedingungen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/y8/v2/q2/y8v2q2j76mcfnmjmirzu8jrnhyu.png" width="605" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn neben der Kategorie „Kleidung“ auch die verfügbaren schwarzen Kleidungsstücke in der Tabelle angezeigt werden. </font><font style="vertical-align: inherit;">Die Anzahl der schwarzen Produkte im Abschnitt "Farbe" wird ebenfalls gemäß den neuen Bedingungen neu berechnet. Nur im Abschnitt "Kategorien" ändert sich nichts ... Ich hoffe, diese Beispiele reichen aus, um den bekannten facettierten Suchalgorithmus zu verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich nun vor, wie dies relational implementiert werden kann. </font><font style="vertical-align: inherit;">Für jede Gruppe von Kriterien wie Kategorie und Farbe ist eine separate Anforderung erforderlich:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> pc.ProductCategoryID, pc.Name, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductCategory pc <span class="hljs-keyword">ON</span> ps.ProductCategoryID = pc.ProductCategoryID
<span class="hljs-keyword">WHERE</span> p.Color = <span class="hljs-string">'Black'</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pc.ProductCategoryID, pc.Name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/79/az/mf79azaflzgu-1gatq4gtbhcdzw.png" width="331" height="90"></div><br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> Color, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
<span class="hljs-keyword">WHERE</span> ps.ProductCategoryID = <span class="hljs-number">1</span> <span class="hljs-comment">--Bikes</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Color
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/ec/r5/cfecr5njjmi93lsdrei1teygmhi.png" width="190" height="110"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist falsch an dieser Entscheidung? </font><font style="vertical-align: inherit;">Sehr einfach - es skaliert nicht gut. </font><font style="vertical-align: inherit;">Jeder Filterabschnitt erfordert eine separate Abfrage zum Zählen von Mengen, und diese Abfragen sind nicht die einfachsten. </font><font style="vertical-align: inherit;">In Online-Shops kann es in einigen Abschnitten mehrere Dutzend Abschnitte des Filters geben, was ein ernstes Leistungsproblem darstellen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise bieten sie mir nach diesen Aussagen einige Lösungen an, nämlich:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kombinieren Sie alle Mengenzahlen in einer Abfrage. </font><font style="vertical-align: inherit;">Technisch ist dies mit dem Schlüsselwort UNION möglich, nur hilft es nicht viel bei der Leistung - auf jeden Fall muss die Datenbank jedes Fragment von Grund auf neu ausführen.</font></font></li>
<li> .      ,    .   ,      . ,   10 «»,     5 .   «»    ,       -.         9- ,  ,        .     50 ,    ,     2<sup>50</sup>.         ,  .     ,            5-10 . ,          ,  -  ,      ,                (     ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise hat eine solche Aufgabe seit langem ausreichend effektive Lösungen, die vorhersehbar mit großen Datenmengen funktionieren. Für jede dieser Optionen ist es sinnvoll, die Neuberechnung der Facetten und das Abrufen der Ergebnisseite in zwei parallele Aufrufe an den Server zu unterteilen und die Benutzeroberfläche so zu organisieren, dass das Laden der Daten in die Facetten die Anzeige der Suchergebnisse nicht beeinträchtigt.</font></font><br>
<br>
<ul>
<li>   «»   . ,        ,       ,   ,      — «1425  , ?»       ,    «».                 «».  ,   ,             .        -. ,       ,        .</li>
<li> search engine      ,   Solr, ElasticSearch, Sphinx  .      «»         .    ,          ,       —     .      ,  search engine       ,    :     ,    ,    ;       search engine      .       —     .      « ».          «»    ,   ,            .      ,   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">transactional outbox</a>      .</li>
</ul><br>
<h2></h2><br>
<ol>
<li>     —  ,             .   «»  «» —    ,      :<br>
<ul>
<li>                   —       .</li>
<li>   ,         ,    ,     .  -          —    .</li>
</ul></li>
<li>                ,          —         #2.</li>
<li>     faceted search,        :<br>
<ul>
<li>        .</li>
<li> search engine   Solr, ElasticSearch, Sphinx  .   ,         ,            . </li>
</ul></li>
<li>   faceted search              .      ,   ,        .</li>
<li>   SQL   ,   ,    ,           (   «» ).           ,   —  «».           ,        .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493426/index.html">Organisation von Code in Microservices und mein Ansatz zur Verwendung von hexagonaler Architektur und DDD</a></li>
<li><a href="../de493428/index.html">"Wir werden keine Verschwörungstheorien hervorbringen." Sprechen Sie über ML-Konferenzen mit Menschen aus Wissenschafts- und IT-Unternehmen</a></li>
<li><a href="../de493430/index.html">Netzarchitektur für Webanwendungen</a></li>
<li><a href="../de493432/index.html">Warum nicht eine Karriere in einem kleinen Nicht-IT-Unternehmen beginnen?</a></li>
<li><a href="../de493436/index.html">Programm zum Ändern von Zugriffsrechten und zum Registrieren von Datei- / Verzeichnisnamen auf Bash</a></li>
<li><a href="../de493440/index.html">Influencer Marketing in China: Worauf basiert es und was können Influencer im Notfall bieten?</a></li>
<li><a href="../de493442/index.html">PSA-Erinnerung</a></li>
<li><a href="../de493444/index.html">Das Projekt "Glas". Energieeffizienz-Einweg-Tee- / Kaffeetassen</a></li>
<li><a href="../de493446/index.html">Wochenendlesung: 10 ungewöhnliche Soundgeschichten - von Spionagespielen und Verschwörungstheorien bis hin zu entspannender ASMR</a></li>
<li><a href="../de493448/index.html">Federeffizientes Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>