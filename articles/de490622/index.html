<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏼 ➿ 🎫 Bekämpfung von Speicherlecks in Webanwendungen 💪🏾 🏉 ↩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als wir von der Entwicklung von Websites, deren Seiten auf dem Server erstellt werden, zur Erstellung von einseitigen Webanwendungen übergingen, die a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bekämpfung von Speicherlecks in Webanwendungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490622/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als wir von der Entwicklung von Websites, deren Seiten auf dem Server erstellt werden, zur Erstellung von einseitigen Webanwendungen übergingen, die auf dem Client gerendert werden, haben wir bestimmte Spielregeln übernommen. Eine davon ist der genaue Umgang mit Ressourcen auf dem Gerät des Benutzers. Dies bedeutet: Blockieren Sie nicht den Hauptstrom, drehen Sie den Laptop-Lüfter nicht und legen Sie den Akku des Telefons nicht ein. Wir tauschten eine Verbesserung der Interaktivität von Webprojekten und die Tatsache aus, dass ihr Verhalten eher dem Verhalten gewöhnlicher Anwendungen ähnelte, einer neuen Klasse von Problemen, die es in der Welt des Server-Renderings nicht gab.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/wv/_c/nl/wv_cnlo46dgs8op0yzhybzgkpw8.jpeg"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solches Problem sind Speicherlecks. </font><font style="vertical-align: inherit;">Eine schlecht gestaltete einseitige Anwendung kann leicht Megabyte oder sogar Gigabyte Speicher verschlingen. </font><font style="vertical-align: inherit;">Es kann immer mehr Ressourcen beanspruchen, selbst wenn es sich ruhig auf der Registerkarte "Hintergrund" befindet. </font><font style="vertical-align: inherit;">Die Seite einer solchen Anwendung kann nach der Erfassung einer exorbitanten Menge an Ressourcen stark "langsamer" werden. </font><font style="vertical-align: inherit;">Außerdem kann der Browser den Tab einfach herunterfahren und dem Benutzer mitteilen: "Es ist ein Fehler aufgetreten."</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/e9d/da8/34be9dda87ca7f35d70a1a934816ce78.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etwas ist schief gelaufen</font></font></font></i><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können Sites, die auf dem Server gerendert werden, auch unter einem Speicherverlustproblem leiden. Aber hier geht es um Serverspeicher. Gleichzeitig ist es sehr unwahrscheinlich, dass solche Anwendungen einen Speicherverlust auf dem Client verursachen, da der Browser den Speicher nach jedem Benutzerübergang zwischen den Seiten löscht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Thema Speicherlecks wird in Webentwicklungspublikationen nicht gut behandelt. Trotzdem bin ich mir fast sicher, dass die meisten nicht trivialen Einzelseitenanwendungen unter Speicherlecks leiden - es sei denn, die Teams, die sich mit ihnen befassen, verfügen über zuverlässige Tools, um dieses Problem zu erkennen und zu beheben. Der Punkt hier ist, dass es in JavaScript extrem einfach ist, eine bestimmte Menge an Speicher zufällig zuzuweisen und dann einfach zu vergessen, diesen Speicher freizugeben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, wird den Lesern seine Erfahrungen bei der Bekämpfung von Speicherlecks in Webanwendungen mitteilen und Beispiele für deren effektive Erkennung nennen.</font></font><br>
<cut></cut><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist so wenig darüber geschrieben?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst möchte ich darüber sprechen, warum so wenig über Speicherlecks geschrieben wird. </font><font style="vertical-align: inherit;">Ich nehme an, hier finden Sie mehrere Gründe:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlende Beschwerden von Benutzern: Die meisten Benutzer sind nicht damit beschäftigt, den Task-Manager beim Surfen im Internet genau zu überwachen. </font><font style="vertical-align: inherit;">In der Regel treten beim Entwickler keine Beschwerden von Benutzern auf, bis der Speicherverlust so schwerwiegend ist, dass die Anwendung nicht mehr funktioniert oder die Anwendung verlangsamt wird.</font></font></li>
<li>  :   Chrome   -   ,     .          .</li>
<li> :            .</li>
<li>      :       «»     .   ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>,   -.</li>
</ul><br>
<h2><font color="#3AC1EF">  </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Bibliotheken und Frameworks für die Entwicklung von Webanwendungen wie React, Vue und Svelte verwenden das Komponentenmodell der Anwendung. In diesem Modell ist der häufigste Weg, einen Speicherverlust zu verursachen, ungefähr so:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles. </font><font style="vertical-align: inherit;">Dies ist alles, was benötigt wird, um ein Projekt mit einem Speicherverlust auszustatten. </font><font style="vertical-align: inherit;">Rufen Sie dazu einfach die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addEventListener-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode eines </font><font style="vertical-align: inherit;">globalen Objekts (wie </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>&lt;body&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder ähnliches) auf und vergessen Sie beim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufheben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Bereitstellung</font></a><font style="vertical-align: inherit;"> der Komponente, den Ereignis-Listener mit der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">removeEventListener-</font></a><font style="vertical-align: inherit;"> Methode zu entfernen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Folgen sind jedoch noch schlimmer, da das Leck der gesamten Komponente auftritt. </font><font style="vertical-align: inherit;">Dies liegt an der Tatsache, dass die Methode </font></font><code>this.onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angehängt ist </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zusammen mit dieser Komponente tritt ein Leck ihrer untergeordneten Komponenten auf. </font><font style="vertical-align: inherit;">Es ist sehr wahrscheinlich, dass alle dieser Komponente zugeordneten DOM-Knoten auslaufen. </font><font style="vertical-align: inherit;">Infolgedessen kann die Situation sehr schnell außer Kontrolle geraten, was zu sehr schlimmen Konsequenzen führt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So lösen Sie dieses Problem:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">this</span>.onMessage = <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situationen, in denen Speicherlecks am häufigsten auftreten</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erfahrung zeigt, dass Speicherlecks am häufigsten auftreten, wenn die folgenden APIs verwendet werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier treten am häufigsten Speicherverluste auf. </font><font style="vertical-align: inherit;">Um das Problem zu lösen, reicht es aus, zum richtigen Zeitpunkt anzurufen </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">setTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">setInterval</a>.   ,        (,  30 ),  ,   ,      ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">clearTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">clearInterval</a>. ,    <code>setTimeout</code>,  «»   ,    ,     <code>setInterval</code>-.  ,    <code>setTimeout</code>       .</li>
<li>API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IntersectionObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ResizeObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MutationObserver</a>   .  ,  ,  .         .     -         ,  ,   ,     ,   ,   <code>disconnect</code>  .    ,     DOM    ,           ,  -.        -,     .  —  <code>&lt;body&gt;</code>,  <code>document</code>,   <code>header</code>  <code>footer</code>,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Promise-</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>      .   ,    ,     —   ,      . , ,  «»   ,        .    «»     <code>.then()</code>-.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositorys, die durch globale Objekte dargestellt werden. </font><font style="vertical-align: inherit;">Wenn Sie den Status einer Anwendung mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> steuern </font><font style="vertical-align: inherit;">, wird der Statusspeicher durch ein globales Objekt dargestellt. </font><font style="vertical-align: inherit;">Wenn Sie mit einem solchen Speicher unachtsam umgehen, werden unnötige Daten nicht gelöscht, wodurch seine Größe ständig zunimmt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unendliches DOM-Wachstum. </font><font style="vertical-align: inherit;">Wenn die Seite endloses Scrollen ohne </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtualisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">, bedeutet dies, dass die Anzahl der DOM-Knoten auf dieser Seite unbegrenzt zunehmen kann.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben haben wir Situationen untersucht, in denen Speicherlecks am häufigsten auftreten, aber es gibt natürlich viele andere Fälle, die das für uns interessante Problem verursachen.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Identifizierung von Speicherlecks</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir uns der Herausforderung zugewandt, Speicherlecks zu identifizieren. Zunächst denke ich nicht, dass eines der vorhandenen Tools dafür sehr gut geeignet ist. Ich habe die Firefox-Speicheranalysetools und die Tools von Edge und IE ausprobiert. Getestet sogar Windows Performance Analyzer. Die besten dieser Tools sind jedoch immer noch Chrome Developer Tools. Es stimmt, in diesen Werkzeugen gibt es viele "scharfe Ecken", die es wert sind, kennengelernt zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter den Tools, die der Chrome-Entwickler zur Verfügung stellt, interessiert uns am meisten der Profiler </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Registerkarte </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Sie Heap-Snapshots erstellen können. Es gibt andere Tools zum Analysieren von Speicher in Chrome, aber ich konnte keine besonderen Vorteile daraus ziehen, um Speicherlecks zu erkennen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/e42/63a/e7de4263abd59eecce420c4bcbfc55ea.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Heap-Snapshot-Tool können Sie Snapshots des Speichers des Hauptstroms, der Web-Worker oder der Iframe-Elemente erstellen.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn das Chrome-Tool-Fenster wie in der vorherigen Abbildung dargestellt aussieht, werden beim Klicken auf die Schaltfläche</font></font><code>Take snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen zu allen Objekten im Speicher der ausgewählten virtuellen Maschine erfasst JavaScript der untersuchten Seite. Dies umfasst Objekte, auf die verwiesen wird</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Objekte, auf die durch die im Aufruf verwendeten Rückrufe verwiesen wird</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usw. Eine Momentaufnahme des Gedächtnisses kann als „eingefrorener Moment“ der Arbeit der untersuchten Entität wahrgenommen werden, der Informationen über den gesamten von dieser Entität verwendeten Speicher darstellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem das Bild aufgenommen wurde, kommen wir zum nächsten Schritt, um Lecks zu finden. Es besteht darin, ein Szenario zu reproduzieren, in dem laut Entwickler ein Speicherverlust auftreten kann. Zum Beispiel öffnet und schließt es ein bestimmtes modales Fenster. Nachdem das ähnliche Fenster geschlossen wurde, wird erwartet, dass die Menge des zugewiesenen Speichers auf die Ebene zurückkehrt, die vor dem Öffnen des Fensters vorhanden war. Daher machen sie ein anderes Bild und vergleichen es dann mit dem zuvor aufgenommenen Bild. In der Tat ist der Vergleich von Bildern das wichtigste Merkmal, das uns interessiert </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/776/4c7/92d7764c7fbe5d561032c3bc092e1541.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen den ersten Schnappschuss, dann ergreifen wir Maßnahmen, die einen Speicherverlust verursachen können, und dann machen wir einen weiteren Schnappschuss. </font><font style="vertical-align: inherit;">Wenn es kein Leck gibt, ist die Größe des zugewiesenen Speichers gleich.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Richtig, dies</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist</font><i><font color="#999999"><font style="vertical-align: inherit;"> alles andere als</font></font></i><font style="vertical-align: inherit;"> ein ideales Werkzeug. </font><font style="vertical-align: inherit;">Es gibt einige wissenswerte Einschränkungen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst wenn Sie auf die kleine Schaltfläche im Bedienfeld klicken, mit der </font><font style="vertical-align: inherit;">die Speicherbereinigung </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestartet wird ( </font></font><code>Collect garbage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), müssen Sie möglicherweise mehrere aufeinanderfolgende Bilder aufnehmen, um sicherzustellen, dass der Speicher wirklich gelöscht wird. </font><font style="vertical-align: inherit;">Ich habe normalerweise drei Schüsse. </font><font style="vertical-align: inherit;">Hier lohnt es sich, sich auf die Gesamtgröße jedes Bildes zu konzentrieren - es sollte sich am Ende stabilisieren.</font></font></li>
<li>    -, -,  <code>iframe</code>,      ,   ,          .   ,        JavaScript.   —      ,       ,    .</li>
<li>           «».             .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung zu diesem Zeitpunkt recht komplex ist, stellen Sie möglicherweise beim Vergleichen von Schnappschüssen viele „undichte“ Objekte fest. </font><font style="vertical-align: inherit;">Hier ist die Situation etwas kompliziert, da das, was mit einem Speicherverlust verwechselt werden kann, nicht immer der Fall ist. </font><font style="vertical-align: inherit;">Vieles, was verdächtig ist, sind nur normale Prozesse für die Arbeit mit Objekten. </font><font style="vertical-align: inherit;">Der von einigen Objekten belegte Speicher wird gelöscht, um andere Objekte in diesem Speicher abzulegen, etwas wird in den Cache geleert, und der entsprechende Speicher wird nicht sofort gelöscht, und so weiter.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen uns auf den Weg durch das Informationsrauschen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich fand heraus, dass der beste Weg, um das Rauschen von Informationen zu durchbrechen, darin besteht, die Aktionen zu wiederholen, die einen Speicherverlust verursachen sollen. Anstatt das modale Fenster nach der ersten Aufnahme nur einmal zu öffnen und zu schließen, kann dies beispielsweise sieben Mal erfolgen. Warum 7? Ja, wenn auch nur, weil 7 eine wahrnehmbare Primzahl ist. Dann müssen Sie eine zweite Aufnahme machen und im Vergleich zur ersten herausfinden, ob ein bestimmtes Objekt 7 Mal (oder 14 Mal oder 21 Mal) „durchgesickert“ ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/ac2/243/2a7ac2243dc82f0e7887b23098e7c893.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen Sie Heap-Snapshots. Bitte beachten Sie, dass wir Bild Nr. 3 mit Bild Nr. 6 vergleichen. Tatsache ist, dass ich drei Aufnahmen hintereinander gemacht habe, damit Chrome mehr Speicherbereinigungssitzungen hat. Beachten Sie außerdem, dass einige Objekte sieben Mal „durchgesickert“ sind.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ein weiterer nützlicher Trick besteht darin, dass Sie zu Beginn der Studie, bevor Sie das erste Bild erstellen, den Vorgang einmal ausführen und dabei erwartungsgemäß ausführen. Speicherleck. Dies wird insbesondere empfohlen, wenn im Projekt die Codeaufteilung verwendet wird. In einem solchen Fall ist es sehr wahrscheinlich, dass bei der ersten Ausführung der verdächtigen Aktion die erforderlichen JavaScript-Module geladen werden, was sich auf die Menge des zugewiesenen Speichers auswirkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben Sie möglicherweise eine Frage, warum Sie besonders auf die Anzahl der Objekte und nicht auf die Gesamtspeichermenge achten sollten. Hier können wir sagen, dass wir intuitiv danach streben, die Menge an "undichtem" Speicher zu reduzieren. In diesem Zusammenhang könnten Sie denken, dass Sie die Gesamtmenge des verwendeten Speichers überwachen sollten. Aber dieser Ansatz passt aus einem wichtigen Grund nicht besonders gut zu uns. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn etwas „leckt“, passiert es, weil Sie (nacherzählt von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joe Armstrong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) eine Banane brauchen, aber am Ende eine Banane, den Gorilla, der sie hält, und zusätzlich den ganzen Dschungel. Wenn wir uns auf die Gesamtmenge des Gedächtnisses konzentrieren, ist dies dasselbe wie das „Messen“ des Dschungels und nicht der Banane, die uns interessiert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/af8/847/7e8af8847ab7e8689e1638ac218582d6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorilla isst eine Banane.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nun zurück zum obigen Beispiel mit</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eine Leckquelle ist ein Ereignis-Listener, der auf eine Funktion verweist. Und diese Funktion bezieht sich wiederum auf eine Komponente, die möglicherweise Links zu einer Reihe guter Dinge wie Arrays, Strings und Objekten speichert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie den Unterschied zwischen den Bildern analysieren und die Entitäten nach dem Speicherplatz sortieren, den sie belegen, können Sie viele Arrays, Linien und Objekte sehen, von denen die meisten höchstwahrscheinlich nicht mit dem Leck zusammenhängen. Und schließlich müssen wir genau den Ereignis-Listener finden, von dem aus alles begann. Er nimmt im Vergleich zu dem, worauf er sich bezieht, sehr wenig Gedächtnis ein. Um das Leck zu beheben, müssen Sie eine Banane finden, nicht den Dschungel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Datensätze nach der Anzahl der "durchgesickerten" Objekte sortieren, werden Sie 7 Ereignis-Listener bemerken. </font><font style="vertical-align: inherit;">Und vielleicht 7 Komponenten und 14 Unterkomponenten und vielleicht noch etwas Ähnliches. </font><font style="vertical-align: inherit;">Diese Zahl 7 sollte sich vom Gesamtbild abheben, da es sich dennoch um eine eher auffällige und ungewöhnliche Zahl handelt. </font><font style="vertical-align: inherit;">In diesem Fall spielt es keine Rolle, wie oft die verdächtige Aktion wiederholt wird. </font><font style="vertical-align: inherit;">Wenn bei der Untersuchung von Bildern der Verdacht berechtigt ist, werden ebenso viele „durchgesickerte“ Objekte aufgezeichnet. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie die Quelle eines Speicherverlusts schnell identifizieren.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linkbaumanalyse</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Tool zum Erstellen von Snapshots bietet die Möglichkeit, „Verknüpfungsketten“ anzuzeigen, mit denen Sie herausfinden können, auf welche Objekte andere Objekte verweisen. </font><font style="vertical-align: inherit;">Dadurch kann die Anwendung funktionieren. </font><font style="vertical-align: inherit;">Durch die Analyse solcher "Ketten" oder "Bäume" von Links können Sie genau herausfinden, wo der Speicher für das "undichte" Objekt zugewiesen wurde.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/77a/07d/7bf77a07dd2d15e479f77c2279b9942d.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über die Gliederkette können Sie herausfinden, welches Objekt sich auf das "undichte" Objekt bezieht. </font><font style="vertical-align: inherit;">Beim Lesen dieser Ketten muss berücksichtigt werden, dass sich die darin befindlichen Objekte auf die oben befindlichen Objekte beziehen.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Im obigen Beispiel gibt es eine Variable namens</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referenziert in dem Abschluss (</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), auf den der Ereignis-Listener verweist. </font><font style="vertical-align: inherit;">Wenn Sie auf den Link zum Quellcode klicken, wird ein ziemlich verständlicher Text des Programms angezeigt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> () </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> someObject = <span class="hljs-keyword">new</span> SomeObject();
<span class="hljs-keyword">const</span> onMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, onMessage);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir diesen Code mit der vorherigen Abbildung vergleichen, stellt sich heraus, dass es sich bei </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Abbildung um einen Abschluss handelt </font></font><code>onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auf </font><font style="vertical-align: inherit;">den verwiesen wird </font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">künstliches Beispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Echte Speicherlecks können viel weniger offensichtlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist erwähnenswert, dass das Heap-Snapshot-Tool einige Einschränkungen aufweist:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Snapshot-Datei speichern und dann erneut hochladen, gehen Links zu Dateien mit Code verloren. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise einen Snapshot heruntergeladen haben, können Sie nicht feststellen, dass sich der Abschlusscode des Ereignis-Listeners in Zeile 22 der Datei befindet </font></font><code>foo.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da diese Informationen äußerst wichtig sind, ist es fast nutzlos, Heap-Snapshot-Dateien zu speichern oder sie beispielsweise an jemanden zu übertragen.</font></font></li>
<li>     <code>WeakMap</code>,  Chrome       ,      . ,   ,     ,    ,   .    <code>WeakMap</code> —     .</li>
<li>Chrome  ,    .  ,        ,     ,     ,     .      ,       <code>object</code>,    <code>EventListener</code>.   <code>object</code> —     ,  ,   ,  «»   7  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine Beschreibung meiner grundlegenden Strategie zur Identifizierung von Speicherlecks. </font><font style="vertical-align: inherit;">Ich habe diese Technik erfolgreich eingesetzt, um Dutzende von Lecks zu erkennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stimmt, ich muss sagen, dass dieser Leitfaden zum Auffinden von Speicherlecks nur einen kleinen Teil dessen abdeckt, was in der Realität geschieht. </font><font style="vertical-align: inherit;">Dies ist nur der Anfang der Arbeit. </font><font style="vertical-align: inherit;">Darüber hinaus müssen Sie in der Lage sein, die Installation von Haltepunkten, die Protokollierung und das Testen von Korrekturen durchzuführen, um festzustellen, ob sie das Problem lösen. </font><font style="vertical-align: inherit;">Und leider bedeutet dies im Wesentlichen eine ernsthafte Zeitinvestition.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatisierte Speicherverlustanalyse</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte diesen Abschnitt mit der Tatsache beginnen, dass ich keinen guten Ansatz zur Automatisierung der Erkennung von Speicherlecks finden konnte. Chrome verfügt über eine eigene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance.memory-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">. Aus Datenschutzgründen können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedoch keine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausreichend detaillierten Daten erfassen. Daher kann diese API in der Produktion nicht zum Erkennen von Lecks verwendet werden. Die W3C Web - </font><font style="vertical-align: inherit;">Performance - </font><font style="vertical-align: inherit;">Arbeitsgruppe zuvor diskutierten </font><font style="vertical-align: inherit;">Speicher </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber ihre Mitglieder haben noch einen neuen Standard zu vereinbaren entwickelt , um </font><font style="vertical-align: inherit;">diese API zu ersetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Testumgebungen können Sie die Granularität der Datenausgabe </font></font><code>performance.memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mithilfe des Chrome-Flags </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhöhen - Enable-Precision-Memory-Info</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Heap-Snapshots können weiterhin mit dem eigenen Team des Chromedriver erstellt werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: takeHeapSnapshot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dieses Team hat die gleichen Einschränkungen, die wir bereits besprochen haben. Wenn Sie diesen Befehl verwenden, ist es aus den oben beschriebenen Gründen wahrscheinlich sinnvoll, ihn dreimal aufzurufen und dann nur das zu verwenden, was als Ergebnis seines letzten Aufrufs empfangen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Ereignis-Listener die häufigste Ursache für Speicherverluste sind, werde ich über eine andere von mir verwendete Leckerkennungstechnik sprechen. Es besteht darin, Affen-Patches für die API zu erstellen </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Links zu zählen, um zu überprüfen, ob ihre Anzahl auf Null zurückkehrt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Beispiel, wie dies gemacht wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Chrome Developer Tools können Sie auch die native API </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getEventListeners verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um herauszufinden, welche Ereignis-Listener an ein bestimmtes Element angehängt sind. </font><font style="vertical-align: inherit;">Dieser Befehl ist jedoch nur in der Entwicklersymbolleiste verfügbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte hinzufügen, dass Matthias Binens mir von einer anderen nützlichen Chrome-Tools-API erzählt hat. </font><font style="vertical-align: inherit;">Dies sind </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queryObjects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Damit können Sie Informationen zu allen Objekten abrufen, die mit einem bestimmten Konstruktor erstellt wurden. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier finden Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gutes Material zu diesem Thema zur Automatisierung der Speicherleckerkennung in Puppeteer.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Suchen und Beheben von Speicherlecks in Webanwendungen steckt noch in den Kinderschuhen. Hier habe ich über einige Techniken gesprochen, die in meinem Fall gut funktionierten. Es sollte jedoch anerkannt werden, dass die Anwendung dieser Techniken immer noch mit gewissen Schwierigkeiten verbunden und zeitaufwändig ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei allen Leistungsproblemen ist eine Prise im Voraus ein Pfund wert. Vielleicht findet es jemand nützlich, die entsprechenden synthetischen Tests vorzubereiten, anstatt das Leck zu analysieren, nachdem es bereits aufgetreten ist. Und wenn es sich nicht um ein Leck handelt, sondern um mehrere, kann sich die Analyse des Problems in etwas wie das Schälen von Zwiebeln verwandeln: Nachdem ein Problem behoben wurde, wird ein anderes entdeckt, und dieser Vorgang wiederholt sich (und die ganze Zeit wie bei Zwiebeln) Tränen in den Augen). Codeüberprüfungen können auch dazu beitragen, häufige Leckmuster zu identifizieren. Aber dies - wenn Sie wissen - wo Sie suchen müssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript ist eine Sprache, die sicheres Arbeiten mit Speicher ermöglicht. </font><font style="vertical-align: inherit;">Daher ist es etwas ironisch, wie leicht Speicherverluste in Webanwendungen auftreten. </font><font style="vertical-align: inherit;">Dies ist teilweise auf die Funktionen der Benutzeroberflächen des Geräts zurückzuführen. </font><font style="vertical-align: inherit;">Sie müssen viele Ereignisse anhören: Mausereignisse, Bildlaufereignisse, Tastaturereignisse. </font><font style="vertical-align: inherit;">Das Anwenden all dieser Muster kann leicht zu Speicherlecks führen. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass unsere Webanwendungen den Speicher sparsam nutzen, können wir ihre Leistung steigern und sie vor „Abstürzen“ schützen. </font><font style="vertical-align: inherit;">Darüber hinaus zeigen wir damit Respekt vor den Ressourcengrenzen von Benutzergeräten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liebe Leser! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind in Ihren Webprojekten Speicherlecks aufgetreten?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490610/index.html">Baidu schlägt Waymo in Kalifornien Robomobile Autonomy Rating</a></li>
<li><a href="../de490612/index.html">Funktionaler Ansatz für Transaktionen auf Scala oder schreiben Sie Ihre eigene nützliche Monade</a></li>
<li><a href="../de490616/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 404 (24. Februar - 1. März 2020)</a></li>
<li><a href="../de490618/index.html">Goroutine-Stapelpuffer</a></li>
<li><a href="../de490620/index.html">Wenn ich die Worte "Wiederherstellung des neuronalen Netzwerks" höre, klettere ich, um Backups zu überprüfen</a></li>
<li><a href="../de490624/index.html">Funktionsrichtlinien-HTTP-Header- und Webbrowser-Steuerung</a></li>
<li><a href="../de490626/index.html">Eine vollständige Anleitung zu Daten- * HTML-Attributen</a></li>
<li><a href="../de490628/index.html">Was tun, wenn CSS das Parsen von Seiten blockiert?</a></li>
<li><a href="../de490630/index.html">Laden von NumPy-Arrays von der Festplatte: Vergleich von memmap () und Zarr / HDF5</a></li>
<li><a href="../de490634/index.html">Digitale Veranstaltungen in Moskau vom 2. bis 8. März</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>