<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏻 🐭 😓 关于Flutter的提供程序包的详细信息 🚪 🤚🏽 🤰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 我们的中期计划包括发行Flutter书。对于Dart语言作为主题，我们仍然持较为谨慎的立场，因此我们将尝试根据本文的结果评估其相关性。它将侧重于提供程序包，因此，将侧重于Flutter中的状态管理。
 
 Provider是由Remy Rusle编写并由Google和Flutter社...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于Flutter的提供程序包的详细信息</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/503074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的中期计划包括发行Flutter书。</font><font style="vertical-align: inherit;">对于Dart语言作为主题，我们仍然持较为谨慎的立场，因此我们将尝试根据本文的结果评估其相关性。</font><font style="vertical-align: inherit;">它将侧重于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包</font><font style="vertical-align: inherit;">，因此，</font><font style="vertical-align: inherit;">将侧重</font><font style="vertical-align: inherit;">于Flutter中的状态管理。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provider是由</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remy Rusle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写</font><font style="vertical-align: inherit;">并由Google和Flutter社区采用</font><font style="vertical-align: inherit;">的状态管理程序包</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是什么是状态管理？</font><font style="vertical-align: inherit;">对于初学者来说，条件是什么？</font><font style="vertical-align: inherit;">让我提醒您，状态仅仅是代表您的应用程序中的UI的数据。</font><font style="vertical-align: inherit;">状态管理是一种创建，访问，处理和处置数据的方法。</font><font style="vertical-align: inherit;">为了更好地理解Provider包，我们简要概述了Flutter中状态管理的历史。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. StatefulWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatelessWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个简单的UI组件，仅在有数据时才显示。有</font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有“记忆“;它是根据需要创建和销毁的。 Flutter还具有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatefulWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在其中有一个内存，这要归功于它长寿的卫星</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">。此类有一个方法</font></font><code>setState()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当调用</font><font style="vertical-align: inherit;">该方法</font><font style="vertical-align: inherit;">时，将启动一个小部件，该小部件将重建状态并以新形式显示状态。这是开箱即用提供的Flutter状态管理的最简单形式。这是一个带有按钮的示例，该按钮始终显示上次按下的时间：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyWidget</span>&gt; </span>{
  <span class="hljs-built_in">DateTime</span> _time = <span class="hljs-built_in">DateTime</span>.now();  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(_time.toString()),<font></font>
      onPressed: () {<font></font>
        setState(() =&gt; _time = <span class="hljs-built_in">DateTime</span>.now());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么这种方法有什么问题呢？</font><font style="vertical-align: inherit;">假设您的应用程序在根目录中存储了一些全局状态</font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它包含打算在UI的各个部分中使用的数据。</font><font style="vertical-align: inherit;">该数据以参数的形式共享并传递给每个子小部件。</font><font style="vertical-align: inherit;">计划更改此数据的所有事件都将以回调的形式弹出。</font><font style="vertical-align: inherit;">因此，通过所有中间小部件，将传递许多参数和回调，这很快会引起混乱。</font><font style="vertical-align: inherit;">更糟糕的是，对上述根目录的任何更新都将导致整个窗口小部件树的重建，效率低下。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. InheritedWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InheritedWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个特殊的小部件，其后代无需直接链接即可访问它。</font><font style="vertical-align: inherit;">仅通过转到</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使用小部件即可注册自动重建，这将在重建祖先小部件时发生。</font><font style="vertical-align: inherit;">此技术使您可以更有效地组织UI的更新。</font><font style="vertical-align: inherit;">您可以选择仅选择那些需要重建的特定小部件，而不用响应状态的微小变化而重建应用程序的大块。</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论何时使用</font></font><code>MediaQuery.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或，</font><font style="vertical-align: inherit;">您都已经在</font><font style="vertical-align: inherit;">使用</font></font><code>Theme.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">的确，您不太可能使用状态保存来实现自己的InheritedWidget。</font><font style="vertical-align: inherit;">事实是正确实施它们并不容易。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.范围模型</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Brian Egan于2017年创建的软件包，它易于使用</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来存储应用程序状态。</font><font style="vertical-align: inherit;">首先，您需要创建一个继承自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的状态对象，</font><font style="vertical-align: inherit;">然后</font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其属性更改时</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">它。</font><font style="vertical-align: inherit;">这种情况让人联想到</font><font style="vertical-align: inherit;">Java中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyChangeListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接口的实现</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span> </span>{<font></font>
  String _foo;  String get foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> set <span class="hljs-title">foo</span><span class="hljs-params">(String value)</span> </span>{<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了提供状态对象，我们将此对象包装在</font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序根目录</font><font style="vertical-align: inherit;">中的小部件</font><font style="vertical-align: inherit;">中：</font></font><br>
<br>
<pre><code class="java hljs">ScopedModel&lt;MyModel&gt;(<font></font>
  model: MyModel(),<font></font>
  child: MyApp(...)<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，任何后代小部件都将能够</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModelDescendant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件</font><font style="vertical-align: inherit;">进行访问</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">模型实例将传递给参数</font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> ScopedModelDescendant&lt;MyModel&gt;(<font></font>
      builder: (context, child, model) =&gt; Text(model.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任何子代小部件也将能够更新模型，这将自动引发任何</font></font><code>ScopedModelDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型</font><font style="vertical-align: inherit;">的重建</font><font style="vertical-align: inherit;">（只要我们的模型正确调用</font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = ScopedModel.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Flutter中作为状态管理工具而得到普及，但是它的使用仅限于提供继承类</font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用这种更改通知模式的</font><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. BLoC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> '18 </font><font style="vertical-align: inherit;">会议上，</font><font style="vertical-align: inherit;">引入</font><font style="vertical-align: inherit;">了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">业务逻辑组件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（BLoC）</font><font style="vertical-align: inherit;">模式</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">模式是</font><font style="vertical-align: inherit;">从小部件提取状态的又一工具。 BLoC类是长期存在的非UI组件，可保留状态并将其公开为流和接收者。除了UI之外，还可以</font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">状态和业务逻辑，您可以简单地实现小部件，</font><font style="vertical-align: inherit;">并使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行自动重建。结果，小部件“变得愚蠢”，并且变得更容易测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BLoC类示例：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloc</span> </span>{
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;MyType&gt;();  Stream&lt;MyType&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<font></font>
  StreamSink&lt;MyType&gt; <span class="hljs-keyword">get</span> sink =&gt; _controller.sink;<font></font>
  <font></font>
  myMethod() {<font></font>
    <span class="hljs-comment">//  </span><font></font>
    sink.add(foo);<font></font>
  }  dispose() {<font></font>
    _controller.close();<font></font>
  }<font></font>
}<font></font>
 ,   BLoC:<font></font>
<span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
 <span class="hljs-keyword">return</span> StreamBuilder&lt;MyType&gt;(<font></font>
  stream: myBloc.stream,<font></font>
  builder: (context, asyncSnapshot) {<font></font>
    <span class="hljs-comment">//  </span><font></font>
 });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BLoC模式的问题在于，如何创建和销毁BLoC对象并不明显。</font></font><code>myBloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上面的示例中</font><font style="vertical-align: inherit;">如何创建</font><font style="vertical-align: inherit;">实例？</font><font style="vertical-align: inherit;">我们该如何打电话</font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摆脱他？</font><font style="vertical-align: inherit;">流需要使用</font></font><code>StreamController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，应该</font></font><code>closed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽快使用它-这样做是为了防止内存泄漏。</font><font style="vertical-align: inherit;">（在Dart中没有类析构器；只有类</font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个方法</font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">此外，尚不清楚如何在多个小部件之间共享此BLoC。</font><font style="vertical-align: inherit;">开发人员通常很难掌握BLoC。</font><font style="vertical-align: inherit;">有几种软件包试图简化这一过程。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.提供者</font></font></h4><br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Remy Rusle在2018年编写的一个软件包，类似于</font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但其功能不限于提供Model的子类。这也是结束语</font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但提供程序可以提供任何状态对象，包括BLoC，流，期货等。由于提供者是如此简单和灵活，因此Google在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '19大会上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣布，将来它将</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成为管理状态的首选软件包。当然，也可以使用其他软件包，但是如果您有任何疑问，Google建议在停止</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内置“带有小部件，用于小部件”。</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您将带有状态的任何对象放置在小部件树中，并为其他任何小部件（子级）打开对其的访问权限。</font><font style="vertical-align: inherit;">它还</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过用数据初始化状态对象并在将其从窗口小部件树中删除后进行清理来帮助管理状态对象的生存期。</font><font style="vertical-align: inherit;">因此，它</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甚至适合于实现BLoC组件，或者可以用作其他状态管理解决方案的基础！</font><font style="vertical-align: inherit;">或简单地用于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现依赖关系</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -一个花哨的术语，表示以某种方式将数据传输到小部件，从而允许您放松连接并提高代码的可测试性。</font><font style="vertical-align: inherit;">最后，</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有一组专门的类，因此使用起来更加方便。</font><font style="vertical-align: inherit;">接下来，我们将仔细研究每个类。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本提供者</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流提供者</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未来提供者</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多供应商</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代理提供者</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用它</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，首先在文件中添加一个依赖项</font></font><code>pubspec.yaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<code>provider: ^3.0.0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在需要的地方</font><font style="vertical-align: inherit;">导入包</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<code>import 'package:provider/provider.dart';</code><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base provider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在应用程序的根目录中</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建base </font></font><code>Provide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r；</font><font style="vertical-align: inherit;">这将包含我们模型的一个实例：</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该参数</font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个实例</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果要将现有实例传递给它，请在此处使用构造函数</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Provider.value</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，您可以</font></font><code>MyApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Widget </font><font style="vertical-align: inherit;">在任何地方使用此模型实例</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;MyModel&gt;(<font></font>
      builder: (context, value, child) =&gt; Text(value.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上面的示例中，该类</font><font style="vertical-align: inherit;">使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Consumer</font></a><font style="vertical-align: inherit;">窗口小部件</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取实例</font><font style="vertical-align: inherit;">。这个小部件使我们可以将</font><font style="vertical-align: inherit;">对象包含在参数中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
现在，如果要更新模型中的数据该怎么办？假设我们有另一个小部件，在其中单击按钮时，应该更新属性</font><font style="vertical-align: inherit;">：</font></font><code>MyModel</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>builder</code><font style="vertical-align: inherit;"></font><code>value</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>foo</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意用于访问实例的特定语法</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。从功能上讲，这等效于访问widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码无法轻松获取链接的情况下，</font><font style="vertical-align: inherit;">小部件</font><font style="vertical-align: inherit;">很有用</font></font><code>BuildContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您认为</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们之前创建</font><font style="vertical-align: inherit;">的原始小部件会怎样</font><font style="vertical-align: inherit;">？会在其中显示新的含义</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吗？</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，没有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。无法收听旧的传统Dart对象中的更改（至少没有反射，这在Flutter中没有提供）。因此，</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将无法“看到”我们已经正确更新了属性，</font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并命令</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应</font><font style="vertical-align: inherit;">而对小部件进行了</font><font style="vertical-align: inherit;">更新。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是有希望！</font><font style="vertical-align: inherit;">您可以使我们的班级</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施一个杂项</font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每当我们的属性之一发生更改时</font><font style="vertical-align: inherit;">，将需要一些时间来更改模型的实现并调用特殊方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它的工作方式大致相同</font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是在这种情况下，您无需继承模型的特定类就很好了。</font><font style="vertical-align: inherit;">实现混合就足够了</font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">看起来是这样的：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{
  <span class="hljs-built_in">String</span> _foo;  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> foo(<span class="hljs-built_in">String</span> value) {<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如你所看到的，我们更换我们的财产</font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><code>getter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>setter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，支持由_foo私有变量。</font><font style="vertical-align: inherit;">这样，我们可以“拦截”对foo属性所做的任何更改，并让我们的侦听器知道我们的对象已更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，从外部开始</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以更改实现，以便它使用另一个名为的类</font></font><code> ChangeNotifierProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs">ChangeNotifierProvider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像这样！</font><font style="vertical-align: inherit;">现在，当我们</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新</font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例中</font><font style="vertical-align: inherit;">的属性</font><font style="vertical-align: inherit;">时</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将</font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动更新以反映此更改。</font><font style="vertical-align: inherit;">酷吧？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说说。</font><font style="vertical-align: inherit;">您可能已经注意到</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用以下语法</font><font style="vertical-align: inherit;">的按钮处理程序</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一旦模型更改</font><font style="vertical-align: inherit;">，此语法将自动导致实例重建</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">也许我们不需要这个。</font><font style="vertical-align: inherit;">最后，它</font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅包含一个按钮，该按钮在值更改时根本不会更改</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了避免重建，您可以使用以下语法访问我们的模型而无需注册进行重建：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context, listen: <span class="hljs-keyword">false</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是包装中提供的另一种魅力</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
乍看之下，</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尚不清楚为什么需要它</font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最后，</font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果需要在Flutter中使用流，则</font><font style="vertical-align: inherit;">可以只使用常规方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，在这里我们收听</font></font><code>onAuthStateChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由提供</font><font style="vertical-align: inherit;">的流</font></font><code>FirebaseAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context {<font></font>
  <span class="hljs-keyword">return</span> StreamBuilder(<font></font>
   stream: FirebaseAuth.instance.onAuthStateChanged, <font></font>
   builder: (BuildContext context, AsyncSnapshot snapshot){ <font></font>
     ...<font></font>
   });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以</font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在应用程序的根目录中</font><font style="vertical-align: inherit;">提供流</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs">StreamProvider&lt;FirebaseUser&gt;.value(<font></font>
  stream: FirebaseAuth.instance.onAuthStateChanged,<font></font>
  child: MyApp(...),<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后使用子小部件，通常使用</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
  <span class="hljs-keyword">return</span> Consumer&lt;FirebaseUser&gt;(<font></font>
    builder: (context, value, child) =&gt; Text(value.displayName),<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的小部件代码不仅变得更加简洁，而且还抽象出了数据来自流的事实。如果我们决定将基本实现更改为</font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则无需更改小部件代码。您将看到，这适用于下面显示的所有其他提供程序。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FutureProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
与上面的示例类似，在</font><font style="vertical-align: inherit;">使用小部件时</font><font style="vertical-align: inherit;">，它</font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是标准的替代方法</font></font><code> FutureBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一个例子：</font></font><br>
<br>
<pre><code class="plaintext hljs">FutureProvider&lt;FirebaseUser&gt;.value(<font></font>
  value: FirebaseAuth.instance.currentUser(),<font></font>
  child: MyApp(...),<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
消费的子控件这个值，我们使用相同的实现</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为例子</font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是由</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueNotifier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类实现的Dart接口，该接口</font><font style="vertical-align: inherit;">获取一个值并在其更改为另一个值时通知侦听器。</font><font style="vertical-align: inherit;">例如，可以将整数计数器包装在简单的模型类中：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> </span>{
  <span class="hljs-keyword">final</span> ValueNotifier&lt;<span class="hljs-built_in">int</span>&gt; counter = ValueNotifier(<span class="hljs-number">0</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理复杂类型时，它</font></font><code>ValueNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储在其中</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的运算符</font><font style="vertical-align: inherit;">来确定值是否已更改。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们创建最简单的一个</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将包含我们的主模型，然后是一个</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嵌套的</font></font><code>ValueListenableProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">侦听属性</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: Consumer&lt;MyModel&gt;(builder: (context, value, child) {<font></font>
    <span class="hljs-keyword">return</span> ValueListenableProvider&lt;<span class="hljs-built_in">int</span>&gt;.value(<font></font>
      value: value.counter,<font></font>
      child: MyApp(...)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，此嵌套提供程序的类型为</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可能还有其他。</font><font style="vertical-align: inherit;">如果您注册了多个相同类型的提供者，则提供者将返回“最近”（最接近的祖先）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从任何子窗口小部件</font><font style="vertical-align: inherit;">监听属性的方法</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<font></font>
      builder: (context, value, child) {<font></font>
        <span class="hljs-keyword">return</span> Text(value.toString());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，这是</font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从另一个窗口小部件</font><font style="vertical-align: inherit;">更新属性的方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">请注意：我们需要访问原始副本</font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.counter.value++;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果您使用许多Widget</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么在应用程序的根目录中，您会从许多附件中得到一个丑陋的结构：</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;Foo&gt;.value( <font></font>
  value: foo, <font></font>
  child: Provider&lt;Bar&gt;.value( <font></font>
    value: bar, <font></font>
    child: Provider&lt;Baz&gt;.value( <font></font>
      value: baz , <font></font>
      child: MyApp(...)<font></font>
    ) <font></font>
  ) <font></font>
)</code></pre><br>
<code>MultiProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您在同一级别上将它们全部声明。</font><font style="vertical-align: inherit;">只是语法糖：在系统内级别，它们始终保持嵌套状态。</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt;.value(value: foo), <font></font>
    Provider&lt;Bar&gt;.value(value: bar), <font></font>
    Provider&lt;Baz&gt;.value(value: baz), <font></font>
  ], <font></font>
  child: MyApp(...), <font></font>
)<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProxyProvider</font></font></i></a><br>
<br>
<code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在第三个软件包发行版中添加的一个有趣的类</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它使您可以声明自己可能依赖于其他提供程序的提供程序，最多一对一。</font><font style="vertical-align: inherit;">在此示例中，Bar类是特定于实例的</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这在编译本身相互依赖的根服务集时很有用。</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider ( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt; ( <font></font>
      builder: (context) =&gt; Foo(),<font></font>
    ), <font></font>
    ProxyProvider&lt;Foo, Bar&gt;(<font></font>
      builder: (context, value, previous) =&gt; Bar(value),<font></font>
    ), <font></font>
  ], <font></font>
  child: MyApp(...),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个泛型类型参数是您所依赖</font></font><code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的类型，第二个是它返回的类型。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何同时收听许多提供商</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们希望单个窗口小部件侦听许多提供程序并在它们发生任何变化时进行重建怎么办？</font><font style="vertical-align: inherit;">您可以使用小部件选项同时收听最多6个提供程序</font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将收到实例作为其他方法参数</font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="dart hljs">Consumer2&lt;MyModel, <span class="hljs-built_in">int</span>&gt;(<font></font>
  builder: (context, value, value2, child) {<font></font>
    <span class="hljs-comment">//value  MyModel</span>
    <span class="hljs-comment">//value2  int</span><font></font>
  },<font></font>
);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用时，</font></font><code>InheritedWidget</code> <code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它允许</font><font style="vertical-align: inherit;">您</font><font style="vertical-align: inherit;">按照Flutter中的习惯管理状态。</font><font style="vertical-align: inherit;">它允许窗口小部件以抽象基础通知机制的方式访问状态对象并收听状态对象。</font><font style="vertical-align: inherit;">通过创建锚点以根据需要创建这些对象并在需要时将其删除，可以更轻松地管理状态对象的寿命。</font><font style="vertical-align: inherit;">此机制可用于轻松实现依赖关系，甚至可作为更高级状态管理选项的基础。</font><font style="vertical-align: inherit;">随着Google的加持和Flutter社区中越来越多的支持，它</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已成为值得一试的软件包！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN503062/index.html">开发人员在硅谷的实际生活成本</a></li>
<li><a href="../zh-CN503064/index.html">您没有等待的物联网（第3部分）。建立模拟模型</a></li>
<li><a href="../zh-CN503068/index.html">在技​​术和商业的十字路口：IT领导者在瑞士开设了一所新大学</a></li>
<li><a href="../zh-CN503070/index.html">电热杯。打造疯狂的电动踏板车/电动自行车</a></li>
<li><a href="../zh-CN503072/index.html">只是另一种工具：通过所需状态配置了解服务配置 </a></li>
<li><a href="../zh-CN503082/index.html">作为NAS / FTP的电报</a></li>
<li><a href="../zh-CN503084/index.html">Lightbend学院课程评论-反应式建筑</a></li>
<li><a href="../zh-CN503086/index.html">在线转录服务是否安全且保密？</a></li>
<li><a href="../zh-CN503088/index.html">我们如何选择承运人的货物</a></li>
<li><a href="../zh-CN503096/index.html">管理者为什么要工人回收？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>