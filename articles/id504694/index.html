<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¹ ğŸ ğŸ‘‰ğŸ¼ Cara mengkompilasi dekorator - C ++, Python dan implementasinya sendiri. Bagian 1 ğŸ’˜ ğŸ‘©ğŸ¾â€ğŸ”¬ ğŸ‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rangkaian artikel ini akan dikhususkan untuk kemungkinan membuat dekorator dalam C ++, fitur-fitur pekerjaan mereka dalam Python, dan salah satu opsi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cara mengkompilasi dekorator - C ++, Python dan implementasinya sendiri. Bagian 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504694/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rangkaian artikel ini akan dikhususkan untuk kemungkinan membuat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dekorator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam C ++, fitur-fitur pekerjaan mereka dalam Python, dan salah satu opsi untuk mengimplementasikan fungsi ini dalam bahasa yang dikompilasi sendiri akan dipertimbangkan, menggunakan pendekatan umum untuk membuat penutupan - konversi penutupan dan modernisasi pohon sintaksis.</font></font></p><br>
<img src="https://habrastorage.org/webt/mm/gu/wn/mmguwnnsrlpzur2dgs8pf0woq7m.png"><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penolakan</font></font></b>
                        <div class="spoiler_text">        ,    Python â€”    .   Python  ,    (). -   ( ),        -    ( ,    ..),   Python  Â«Â»      .<br>
</div>
                    </div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekorator dalam C ++</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya berawal dari kenyataan bahwa teman saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VoidDruid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memutuskan untuk menulis kompiler kecil sebagai diploma, fitur utama di antaranya adalah dekorator. Bahkan selama pra-pertahanan, ketika dia menguraikan semua keuntungan dari pendekatannya, yang termasuk mengubah AST, saya bertanya-tanya: apakah benar-benar mustahil untuk mengimplementasikan dekorator yang sama ini dalam C ++ yang hebat dan kuat dan melakukannya tanpa syarat dan pendekatan yang rumit? Googling topik ini, saya tidak menemukan pendekatan sederhana dan umum untuk menyelesaikan masalah ini (omong-omong, saya hanya menemukan artikel tentang penerapan pola desain) dan kemudian duduk untuk menulis dekorator saya sendiri.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, sebelum melanjutkan ke deskripsi langsung implementasi saya, saya ingin berbicara sedikit tentang bagaimana lambda dan penutupan di C ++ diatur dan apa perbedaan di antara mereka. </font><font style="vertical-align: inherit;">Segera buat reservasi bahwa jika tidak disebutkan standar tertentu, maka secara default yang saya maksud adalah C ++ 20. </font><font style="vertical-align: inherit;">Singkatnya, lambdas adalah fungsi anonim, dan penutupan adalah fungsi yang menggunakan objek dari lingkungannya. </font><font style="vertical-align: inherit;">Jadi misalnya, dimulai dengan C ++ 11, lambda dapat dideklarasikan dan dipanggil seperti ini:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{<font></font>
    [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }(<span class="hljs-number">10</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atau tetapkan nilainya ke variabel dan panggil nanti.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{
    <span class="hljs-keyword">auto</span> lambda = [] (<span class="hljs-keyword">int</span> a) <font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
    lambda(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi apa yang terjadi selama kompilasi dan apa itu lambda? </font><font style="vertical-align: inherit;">Untuk membenamkan diri dalam struktur internal lambda, buka saja situs web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppinsights.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan jalankan contoh pertama kami. </font><font style="vertical-align: inherit;">Selanjutnya, saya lampirkan kesimpulan yang mungkin:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_60_19</span>
{</span>
<span class="hljs-keyword">public</span>: 
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">using</span> retType_60_19 = <span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>);
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">retType_60_19</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> __invoke;<font></font>
    };<font></font>
    <font></font>
<span class="hljs-keyword">private</span>: 
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __invoke(<span class="hljs-keyword">int</span> a)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<font></font>
    }    <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, ketika mengkompilasi, lambda berubah menjadi kelas, atau lebih tepatnya functor (objek yang didefinisikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dengan nama unik yang dihasilkan secara otomatis, yang memiliki </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menerima parameter yang kami lewati ke lambda dan tubuhnya berisi kode yang harus dieksekusi lambda kita. </font><font style="vertical-align: inherit;">Dengan ini, semuanya jelas, tetapi bagaimana dengan dua metode lainnya, mengapa mereka? </font><font style="vertical-align: inherit;">Yang pertama adalah operator casting ke pointer fungsi, prototipe yang bertepatan dengan lambda kita, dan yang kedua adalah kode yang harus dieksekusi ketika lambda kita dipanggil pada tugas awal untuk pointer, misalnya,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> (*p_lambda) (<span class="hljs-keyword">int</span>) = lambda;<font></font>
p_lambda(<span class="hljs-number">10</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, ada sedikit teka-teki, tapi bagaimana dengan penutupan? </font><font style="vertical-align: inherit;">Mari kita menulis contoh paling sederhana dari penutupan yang menangkap variabel "a" dengan referensi dan meningkatkannya dengan satu.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, mekanisme untuk membuat closures dan lambdas di C ++ hampir sama, sehingga konsep-konsep ini sering membingungkan dan lambdas dan closure hanya disebut lambdas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi kembali ke representasi internal penutupan di C ++.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_61_20</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
    </span>{<font></font>
        a += <span class="hljs-number">1</span>;<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> &amp; a;
<span class="hljs-keyword">public</span>:<font></font>
    __lambda_61_20(<span class="hljs-keyword">int</span> &amp; _a)<font></font>
    : a{_a}<font></font>
    {}<font></font>
};</code></pre><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, kami telah menambahkan konstruktor non-standar baru yang mengambil parameter kami dengan referensi dan menyimpannya sebagai anggota kelas. </font><font style="vertical-align: inherit;">Sebenarnya, inilah mengapa Anda harus sangat berhati-hati ketika mengatur [&amp;] atau [=], karena seluruh konteks akan disimpan dalam penutupan, dan ini bisa sangat suboptimal dari memori. </font><font style="vertical-align: inherit;">Selain itu, kami kehilangan operator casting ke pointer fungsi, karena sekarang untuk konteks panggilan normal diperlukan. </font><font style="vertical-align: inherit;">Dan sekarang kode di atas tidak akan dikompilasi:</font></font><br>
<br>
</p><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">auto</span> closure = [&amp;a] () { a += <span class="hljs-number">1</span>; };<font></font>
    closure();<font></font>
    <span class="hljs-keyword">void</span> (*ptr)(<span class="hljs-keyword">int</span>) = closure;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, jika Anda masih harus melewati penutupan di suatu tempat, tidak ada yang membatalkan penggunaan fungsi std ::.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; function = closure;<font></font>
function();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang setelah kita mengetahui secara kasar apa itu lambdas dan penutupan di C ++, mari beralih ke menulis dekorator secara langsung. </font><font style="vertical-align: inherit;">Tetapi pertama-tama, Anda perlu memutuskan persyaratan kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, dekorator harus mengambil fungsi atau metode kita sebagai input, menambahkan fungsionalitas yang kita perlukan (misalnya, ini akan dihilangkan) dan mengembalikan fungsi baru ketika dipanggil, yang mengeksekusi kode kita dan kode fungsi / metode. Pada titik ini, setiap pythonis yang menghargai diri sendiri akan mengatakan: "Tapi bagaimana bisa begitu! Penghias harus mengganti objek asli dan panggilan apa pun dengan namanya harus memanggil fungsi baru! " Hanya ini adalah batasan utama C ++, kami tidak dapat menghentikan pengguna dari memanggil fungsi yang lama. Tentu saja, ada opsi untuk mendapatkan alamatnya di memori dan menggilingnya (dalam hal ini, mengaksesnya akan menyebabkan penghentian program yang tidak normal) atau mengganti badannya dengan peringatan bahwa itu tidak boleh digunakan di konsol, tetapi ini penuh dengan konsekuensi serius. Jika opsi pertama tampaknya cukup sulit,maka yang kedua, ketika menggunakan berbagai optimisasi kompiler, juga dapat menyebabkan crash, dan karena itu kami tidak akan menggunakannya. Juga, penggunaan sihir makro apa pun di sini saya anggap berlebihan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita beralih ke menulis dekorator kami. </font><font style="vertical-align: inherit;">Pilihan pertama yang muncul di benak saya adalah ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;R(Args...)&gt;&amp; f)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> [=](Args... args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> f(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan itu menjadi struktur dengan metode statis yang mengambil fungsi std :: dan mengembalikan penutupan yang akan mengambil parameter yang sama dengan fungsi kita dan ketika dipanggil, ia hanya akan memanggil fungsi kita dan mengembalikan hasilnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita buat fungsi sederhana yang ingin kita hias.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"here"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan utama kita akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; f = myFunc;
    <span class="hljs-keyword">auto</span> decorated = Decorator::make(f);<font></font>
    decorated(<span class="hljs-number">10</span>);<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya berfungsi, semuanya baik-baik saja dan secara umum Hore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, solusi ini memiliki beberapa masalah. </font><font style="vertical-align: inherit;">Mari kita mulai dengan urutan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode ini hanya dapat dikompilasi dengan versi C ++ 14 dan lebih tinggi, karena tidak mungkin untuk mengetahui jenis yang dikembalikan sebelumnya. </font><font style="vertical-align: inherit;">Sayangnya, saya harus hidup dengan ini dan saya tidak menemukan opsi lain.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make membutuhkan std :: function untuk diteruskan ke sana, dan meneruskan fungsi dengan nama mengarah ke kesalahan kompilasi. </font><font style="vertical-align: inherit;">Dan ini sama sekali tidak senyaman yang kita inginkan! </font><font style="vertical-align: inherit;">Kami tidak dapat menulis kode seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">Decorator::make([](){});<font></font>
Decorator::make(myFunc);<font></font>
<span class="hljs-keyword">void</span>(*ptr)(<span class="hljs-keyword">int</span>) = myFunc;<font></font>
Decorator::make(ptr);</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, tidak mungkin untuk menghias metode kelas.</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, setelah percakapan singkat dengan kolega, opsi berikut diciptakan untuk C ++ 17 ke atas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] (<span class="hljs-keyword">auto</span> &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do something"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keuntungan dari opsi khusus ini adalah bahwa sekarang kita dapat menghiasi objek apa pun yang memiliki </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jadi misalnya, kita dapat melewatkan nama fungsi bebas, pointer, lambda, functor, std :: function, dan tentu saja metode kelas. </font><font style="vertical-align: inherit;">Dalam kasus yang terakhir, juga akan diperlukan untuk menyampaikan konteks ketika memanggil fungsi yang diterjemahkan.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi aplikasi</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> decorated_1 = Decorator::make(myFunc);<font></font>
    decorated_1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> my_lambda = [] (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) <font></font>
    { <font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <font></font>
    };<font></font>
    <span class="hljs-keyword">auto</span> decorated_2 = Decorator::make(my_lambda);<font></font>
    decorated_2(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> (*ptr)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = myFunc;
    <span class="hljs-keyword">auto</span> decorated_3 = Decorator::make(ptr);<font></font>
    decorated_3(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; fun = myFunc;
    <span class="hljs-keyword">auto</span> decorated_4 = Decorator::make(fun);<font></font>
    decorated_4(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_5 = Decorator::make(decorated_4);<font></font>
    decorated_5(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<font></font>
<font></font>
    <span class="hljs-keyword">auto</span> decorated_6 = Decorator::make(&amp;MyClass::func);<font></font>
    decorated_6(MyClass(<span class="hljs-number">10</span>));<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, kode ini dapat dikompilasi dengan C ++ 14 jika ada ekstensi untuk menggunakan std :: invoke, yang perlu diganti dengan std :: __ invoke. </font><font style="vertical-align: inherit;">Jika tidak ada ekstensi, maka Anda harus menyerahkan kemampuan untuk menghias metode kelas, dan fungsi ini tidak akan tersedia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tidak menulis "std :: forward &lt;type (args)&gt; yang rumit ..." Anda dapat menggunakan fungsionalitas yang tersedia dengan C ++ 20 dan membuat lambda boilerda kami!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> Decorator<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Function&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">make</span><span class="hljs-params">(Function&amp;&amp; func)</span>
    </span>{
        <span class="hljs-keyword">return</span> [func = <span class="hljs-built_in">std</span>::forward&lt;Function&gt;(func)] <font></font>
        &lt;<span class="hljs-keyword">typename</span> ...Args&gt; (Args &amp;&amp; ...args) <font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::invoke(<font></font>
                func,<font></font>
                <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...<font></font>
            );<font></font>
        };<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya sangat aman dan bahkan berfungsi seperti yang kita inginkan (atau setidaknya berpura-pura). </font><font style="vertical-align: inherit;">Kode ini dikompilasi untuk versi gcc dan clang 10-x dan Anda dapat menemukannya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Juga akan ada implementasi untuk berbagai standar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel selanjutnya, kita akan beralih ke implementasi dekorator kanonik menggunakan contoh Python dan struktur internal mereka.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id504682/index.html">Nostalgia Post: j2me, Gravity Defied, 64kb</a></li>
<li><a href="../id504686/index.html">Cara menggambar kucing</a></li>
<li><a href="../id504688/index.html">Topeng tidak berguna: kritik ilmiah terhadap kebijakan sosial di KOVID-19</a></li>
<li><a href="../id504690/index.html">Kisah Bagaimana Saya Mengkonfigurasi Azure AD B2C pada Bereaksi dan Bereaksi Asli Bagian 3 (Tutorial)</a></li>
<li><a href="../id504692/index.html">Dasar-Dasar ZFS: Penyimpanan dan Kinerja</a></li>
<li><a href="../id504696/index.html">Berita dari dunia OpenStreetMap No. 513 (12.05.2020-18.05.2020)</a></li>
<li><a href="../id504698/index.html">Onboarding di situs jarak jauh</a></li>
<li><a href="../id504700/index.html">"Sketsa" tablet grafis Soviet</a></li>
<li><a href="../id504702/index.html">Orang tidak mau tahu bahasa Inggris</a></li>
<li><a href="../id504706/index.html">Manajemen Daya Wi-Fi Otomatis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>