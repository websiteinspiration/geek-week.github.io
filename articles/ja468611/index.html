<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏿 🧒🏾 🍅 .NETマルチスレッド：パフォーマンスが不足している場合 🚮 👨🏿‍🍳 🖤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NETプラットフォームは、多くのビルド済み同期プリミティブとスレッドセーフなコレクションを提供します。たとえば、アプリケーションの開発時にスレッドセーフキャッシュやリクエストキューを実装する必要がある場合は、これらの既製のソリューションが通常使用されます。場合によっては、これによりパフォーマンスの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NETマルチスレッド：パフォーマンスが不足している場合</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETプラットフォームは、多くのビルド済み同期プリミティブとスレッドセーフなコレクションを提供します。たとえば、アプリケーションの開発時にスレッドセーフキャッシュやリクエストキューを実装する必要がある場合は、これらの既製のソリューションが通常使用されます。場合によっては、これによりパフォーマンスの問題が発生します。ロックの待機時間が長くなり、メモリが過剰に消費され、ガベージコレクションが長くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題は、標準的なソリューションが非常に一般的になっていることを考慮に入れれば解決できます。シナリオにはオーバーヘッドがあり、冗長である可能性があります。したがって、たとえば、特定のケースに対して独自の効果的なスレッドセーフなコレクションを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
猫の下</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">-DotNext</font></a><font style="vertical-align: inherit;">会議からの私のレポートのビデオとトランスクリプト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは、標準の.NETライブラリのツール（Task.Delay、SemaphoreSlim、ConcurrentDictionary）を使用した場合のいくつかの例を分析し、パフォーマンスの低下を引き起こし、特定のタスクに合わせて調整されたソリューションを提供します。これらの欠点はありません。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートの時点で、彼はコントゥルで働いていました。</font><font style="vertical-align: inherit;">Konturはビジネス向けのさまざまなアプリケーションを開発しており、私が担当したチームはインフラストラクチャを扱い、他のチームの開発者が製品サービスを作成するのに役立つさまざまなサポートサービスとライブラリを開発しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インフラストラクチャチームは、独自のデータウェアハウス、Windows用のアプリケーションホスティングシステム、およびマイクロサービスの開発用のさまざまなライブラリを作成します。</font><font style="vertical-align: inherit;">私たちのアプリケーションはマイクロサービスアーキテクチャに基づいています-すべてのサービスはネットワークを介して相互にやり取りします。もちろん、非同期およびマルチスレッドコードを大量に使用します。</font><font style="vertical-align: inherit;">これらのアプリケーションのいくつかは、パフォーマンスが非常に重要であり、多くの要求を処理できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日は何について話しますか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETでのマルチスレッドと非同期。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期プリミティブとコレクションのスタッフィング。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準的なアプローチで負荷に対応できない場合はどうすればよいですか？</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETでマルチスレッドおよび非同期コードを操作するいくつかの機能を分析してみましょう。</font><font style="vertical-align: inherit;">いくつかの同期プリミティブと並行コレクションを見て、それらが内部にどのように配置されているかを見てみましょう。</font><font style="vertical-align: inherit;">十分なパフォーマンスがない場合、標準クラスが負荷に対応できない場合、およびこの状況で何かを実行できるかどうかについて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生産現場で起こった4つの物語をお伝えします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履歴1：Task.Delay＆TimerQueue</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この話は、以前のDotNextでの話も含めて、かなり有名です。</font><font style="vertical-align: inherit;">しかし、結構面白い続編が出たので追加しました。</font><font style="vertical-align: inherit;">だからポイントは何ですか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1ポーリングとロングポーリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーは長い操作を実行し、クライアントはそれらを待ちます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポーリング：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントは定期的にサーバーに結果を問い合わせます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長いポーリング：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントは長いタイムアウトでリクエストを送信し、サーバーは操作が完了すると応答します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
利点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交通量が少ない</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントは結果についてより早く学ぶ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、XMLファイルをPDFに変換するアプリケーションなど、いくつかの長いリクエストを処理できるサーバーがあり、これらのタスクを実行して処理し、その結果を非同期的に待機したいクライアントがあるとします。このような期待はどのように実現できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の方法は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポーリング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。クライアントはサーバーでタスクを開始し、このタスクのステータスを定期的に確認しますが、サーバーはタスクのステータスを返します（「完了」/「未完了」/「エラーで完了」）。クライアントは、結果が表示されるまで定期的にリクエストを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方法- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロングポーリング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここでの違いは、クライアントが長いタイムアウトでリクエストを送信することです。</font><font style="vertical-align: inherit;">このような要求を受け取ったサーバーは、タスクが完了していないことをすぐに報告するのではなく、結果が表示されるまでしばらく待機します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、通常のポーリングよりもロングポーリングの利点は何でしょうか。</font><font style="vertical-align: inherit;">まず、生成されるトラフィックが少なくなります。</font><font style="vertical-align: inherit;">ネットワーク要求が少なくなり、ネットワーク全体で追跡されるトラフィックが少なくなります。</font><font style="vertical-align: inherit;">また、クライアントは、複数のポーリングリクエスト間の間隔を待つ必要がないため、通常のポーリングよりも早く結果を知ることができます。</font><font style="vertical-align: inherit;">私たちが得たいものは理解できます。</font><font style="vertical-align: inherit;">これをコードにどのように実装しますか？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク：タイムアウトタスク</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を待機し、タイムアウト</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
await SendAsync（）;</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、サーバーにリクエストを送信するタスクがあり、その結果をタイムアウトで待機したい場合、つまり、このタスクの結果を返すか、なんらかのエラーを送信します。</font><font style="vertical-align: inherit;">C＃コードは次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> sendTask = SendAsync();<font></font>
<span class="hljs-keyword">var</span> delayTask = Task.Delay(timeout);<font></font>
<span class="hljs-keyword">var</span> task = <span class="hljs-keyword">await</span> Task.WhenAny(sendTask, delayTask);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (task == delayTask)<font></font>
    <span class="hljs-keyword">return</span> Timeout;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、結果を待機したいTaskとTask.Delayを起動します。</font><font style="vertical-align: inherit;">次に、Task.WhenAnyを使用して、TaskまたはTask.Delayのいずれかを待機しています。</font><font style="vertical-align: inherit;">Task.Delayが最初に実行されたことが判明した場合、タイムアップでタイムアウトが発生し、エラーを返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このコードは完全ではなく、改善することができます。</font><font style="vertical-align: inherit;">たとえば、SendAsyncが以前に戻った場合にTask.Delayをキャンセルしても問題はありませんが、これは今のところあまり興味深いものではありません。</font><font style="vertical-align: inherit;">要するに、このようなコードを記述して、タイムアウトの長いポーリングに適用すると、パフォーマンスの問題が発生するということです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2ロングポーリングの問題</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大きなタイムアウト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの同時クエリ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;高いCPU使用率</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、問題はプロセッサリソースの大量消費です。</font><font style="vertical-align: inherit;">プロセッサが100％で完全にロードされ、アプリケーションが通常動作を停止する場合があります。</font><font style="vertical-align: inherit;">プロセッサリソースをまったく消費していないように見えます。非同期操作をいくつか行い、サーバーからの応答を待機しますが、プロセッサはまだロードされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況に直面したとき、アプリケーションからメモリダンプを削除しました。</font></font><br>
<br>
<pre><code class="cs hljs">      ~*e!clrstack<font></font>
System.Threading.Monitor.Enter(System.Object)<font></font>
System.Threading.TimerQueueTimer.Change(…)<font></font>
System.Threading.Timer.TimerSetup(…)<font></font>
System.Threading.Timer..ctor(…)<font></font>
System.Threading.Tasks.Task.Delay(…)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダンプを分析するために、WinDbgツールを使用しました。</font><font style="vertical-align: inherit;">すべてのマネージスレッドのスタックトレースを表示するコマンドを入力し、そのような結果を見ました。</font><font style="vertical-align: inherit;">プロセスには非常に多くのスレッドがあり、ロックを待機しています。</font><font style="vertical-align: inherit;">Monitor.Enterメソッドは、C＃のロック構造が拡張されるものです。</font><font style="vertical-align: inherit;">このロックは、TimerおよびTimerQueueTimerと呼ばれるクラス内でキャプチャされます。</font><font style="vertical-align: inherit;">Timerでは、それらを作成しようとしたときにTask.Delayから来ました。</font><font style="vertical-align: inherit;">それは何ですか？</font><font style="vertical-align: inherit;">Task.Delayが開始すると、TimerQueue内のロックが取得されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3コンボイのロック</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのスレッドが1つのロックをロックしようとします</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックの下で、少しのコードが実行されます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの実行ではなく、スレッドの同期に時間が費やされます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドブロックはブロックされます-それらは無限ではありません</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションにはロックコンボイがありました。</font><font style="vertical-align: inherit;">多くのスレッドが同じロックを取得しようとします。</font><font style="vertical-align: inherit;">このロックの下で、かなりの量のコードが実行されます。</font><font style="vertical-align: inherit;">ここでのプロセッサリソースは、アプリケーションコード自体ではなく、このロックでスレッド間でスレッドを同期する操作に費やされています。</font><font style="vertical-align: inherit;">また、.NETに関連する機能にも注目してください。ロックコンボイに参加するスレッドは、スレッドプールのスレッドです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、スレッドプールのスレッドがブロックされると、スレッドが終了する可能性があります-スレッドプール内のスレッド数は制限されます。</font><font style="vertical-align: inherit;">設定は可能ですが、まだ上限があります。</font><font style="vertical-align: inherit;">到達すると、すべてのスレッドプールスレッドがロックコンボイに参加し、スレッドプールに関連するコードはアプリケーションで実行されなくなります。</font><font style="vertical-align: inherit;">これは状況を大きく悪化させます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4 TimerQueue</font></font></h3><br>
<ul>
<li>   .NET-.</li>
<li>  :<br>
 — Task.Delay<br>
 — CancellationTocken.CancelAfter<br>
 — HttpClient</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimerQueueは、.NETアプリケーションのすべてのタイマーを管理するクラスです。 WinFormsでプログラミングしたことがある場合は、タイマーを手動で作成した可能性があります。タイマーが何であるかを知らない人のために：それらはTask.Delay（これは単に私たちのケースです）で使用され、CancellationToken内のCancelAfterメソッドでも使用されます。つまり、Task.DelayをCancellationToken.CancelAfterで置き換えても、何の助けにもなりません。さらに、タイマーは、HttpClientなどの多くの内部.NETクラスで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の知る限り、HttpClientハンドラの一部の実装にはタイマーがあります。それらを明示的に使用しない場合でも、Task.Delayを開始しないでください。おそらく、とにかくそれらを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、TimerQueueが内部にどのように配置されているかを見てみましょう。</font></font><br>
<br>
<ul>
<li>Global state (per-appdomain):<br>
 — Double linked list of TimerQueueTimer<br>
 — Lock object</li>
<li>Routine,   </li>
<li>     </li>
<li> : O(1) + lock</li>
<li> : O(1) + lock</li>
<li> : O(N) + lock</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimerQueueの内部にはグローバルな状態があり、TimerQueueTimerタイプのオブジェクトの二重リンクリストです。 TimerQueueTimerには、他のTimerQueueTimerへのリンク、リンクされたリストの近隣へのリンク、タイマーの時間が含まれ、タイマーが起動したときに呼び出されるコールバックも含まれます。この二重にリンクされたリストは、ロックオブジェクトによって保護されています。アプリケーションでロックコンボイが発生したものだけです。また、TimerQueueの内部には、タイマーに関連付けられたコールバックを起動するルーチンがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイマーは決して応答時間の順序ではなく、構造全体が新しいタイマーの追加/削除用に最適化されています。ルーチンが開始すると、二重にリンクされたリスト全体を実行し、機能するタイマーを選択して、コールバックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの操作の複雑さはそのようなものです。</font><font style="vertical-align: inherit;">タイマーの追加と削除はユニットごとに行われ、タイマーの開始は行ごとに行われます。</font><font style="vertical-align: inherit;">さらに、アルゴリズムの複雑さですべてが許容できる場合は、1つの問題があります。これらすべての操作がロックを取得するため、あまり良くありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのような状況が起こり得ますか？</font><font style="vertical-align: inherit;">TimerQueueに蓄積されているタイマーが多すぎるため、Routineが開始すると、長い線形操作がロックされます。</font><font style="vertical-align: inherit;">このため、ロックコンボイが発生します。</font><font style="vertical-align: inherit;">この問題は.NET Coreで修正されました。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイマーロックの競合を減らす（coreclr＃14527）</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックシャーディング</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -Environment.ProcessorCount TimerQueueのTimerQueueTimer</font></font></li>
<li>Separate queues for short/long-living timers</li>
<li>Short timer: time &lt;= 1/3 second</li>
</ul><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのように修正されましたか？それらは、TimerQueueをめちゃくちゃにしました。AppDomain全体に対して静的であった1つのTimerQueueの代わりに、アプリケーション全体に対して、いくつかのTimerQueueが作成されました。スレッドがそこに到着してタイマーを開始しようとすると、これらのタイマーはランダムなTimerQueueに分類され、スレッドは1つのロックで衝突する可能性が低くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、.NET Coreでは、いくつかの最適化が適用されました。タイマーは長命と短命に分けられ、別々のTimerQueueが使用されます。短命のタイマーは、1/3秒未満になるように選択されました。なぜそのような定数が選ばれたのかわかりません。 .NET Coreでは、タイマーの問題を検出できませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/dotnet/coreclr/labels/netfx-port-consider</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この修正は、.NET Frameworkバージョン4.8にバックポートされました。上記のリンクにnetfx-port-considerタグが示されています。.NETCore、CoreCLR、CoreFXリポジトリに移動すると、このタグを使用して.NET Frameworkにバックポートされる問題を検索できます。現在は約50個あります。つまり、オープンソースの.NETは大いに役立ち、かなりの数のバグが修正されました。変更履歴.NET Framework 4.8を読むことができます。他の.NETリリースよりも多くのバグが修正されています。興味深いことに、この修正は.NET Framework 4.8ではデフォルトでオフになっています。それはあなたが知っているApp.configと呼ばれるファイル全体に含まれています</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この修正を有効にするApp.configの設定はUseNetCoreTimerと呼ばれます。</font><font style="vertical-align: inherit;">.NET Framework 4.8がリリースされる前は、アプリケーションが機能し、コンボイをロックしないためには、Task.Delayの実装を使用する必要がありました。</font><font style="vertical-align: inherit;">その中で、どのタイマーを呼び出すかをより効率的に理解するために、バイナリヒープの使用を試みました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5 Task.Delay：ネイティブ実装</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリヒープ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャーディング</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは役に立ちましたが、すべての場合ではありません</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリヒープを使用すると、コールバックを呼び出すルーチンを最適化できますが、キューから任意のタイマーを削除するのにかかる時間が悪化します。このためには、ヒープを再構築する必要があります。</font><font style="vertical-align: inherit;">これが、.NETが二重にリンクされたリストを使用する理由と考えられます。</font><font style="vertical-align: inherit;">もちろん、ここではバイナリヒープを使用するだけでは役に立たないため、TimerQueueも計算する必要がありました。</font><font style="vertical-align: inherit;">このソリューションはしばらくの間機能しましたが、タイマーはコード内で明示的に開始された場所だけでなく、サードパーティのライブラリや.NETコードでも使用されるため、すべてが再びロックコンボイに落ちました。</font><font style="vertical-align: inherit;">この問題を完全に修正するには、.NET Frameworkバージョン4.8にアップグレードし、.NET開発者による修正を有効にする必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.6 Task.Delay：結論</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いたるところに落とし穴-最もよく使われるものでも</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレステストを行う</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コアに切り替え、最初にバグ修正（および新しいバグ）を取得します:)</font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この全体の話からの結論は何ですか？</font><font style="vertical-align: inherit;">まず、落とし穴はどこにでも見られます。たとえば、同じTask、Task.Delayのように、毎日考えているクラスでさえ、その落とし穴があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案のストレステストを実施することをお勧めします。</font><font style="vertical-align: inherit;">この問題は、負荷テストの段階で特定したものです。</font><font style="vertical-align: inherit;">その後、他のアプリケーションの本番環境で数回撮影しましたが、それでもストレステストにより、実際にこの問題が発生するまでの時間を遅らせることができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Coreに切り替えます-バグ修正（および新しいバグ）を最初に受信します。</font><font style="vertical-align: inherit;">新しいバグがないところはどこですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイマーの話は終わり、次のステップに進みます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストーリー2：SemaphoreSlim</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の話は有名なSemaphoreSlimについてです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1サーバースロットル</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーで同時に処理されるリクエストの数を制限する必要があります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーにスロットルを実装したかったのです。</font><font style="vertical-align: inherit;">それは何ですか？</font><font style="vertical-align: inherit;">CPUのスロットルはご存じでしょう。プロセッサが過熱すると、周波数が低下して冷却され、パフォーマンスが制限されます。</font><font style="vertical-align: inherit;">だからここです。</font><font style="vertical-align: inherit;">私たちのサーバーはN個のリクエストを並行して処理でき、落ちることはありません。</font><font style="vertical-align: inherit;">何をしたいですか？</font><font style="vertical-align: inherit;">同時に処理されるリクエストの数をこの定数に制限し、それ以上のリクエストが来た場合、キューに入れられ、先に来たリクエストが実行されるまで待機するようにします。</font><font style="vertical-align: inherit;">この問題はどのように解決できますか？</font><font style="vertical-align: inherit;">何らかの同期プリミティブを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマフォは、N回待機できる同期プリミティブであり、その後N +に最初に到着した人などは、先に入力した人がセマフォを解放するまで待機します。</font><font style="vertical-align: inherit;">次のようなことがわかります。2つの実行スレッド、2つのワーカーがセマフォの下に行き、残りは並んでいました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、それはSemaphoreが私たちにはあまり適していないということです。それは.NET同期であるため、SemaphoreSlimを使用して次のコードを記述しました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> semaphore = <span class="hljs-keyword">new</span> SemaphoreSlim(N);<font></font>
…<font></font>
<span class="hljs-keyword">await</span> semaphore.WaitAsync();<font></font>
<span class="hljs-keyword">await</span> HandleRequestAsync(request);<font></font>
semaphore.Release();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SemaphoreSlimを作成して待機し、Semaphoreの下でリクエストを処理した後、Semaphoreを解放します。</font><font style="vertical-align: inherit;">これはサーバースロットリングの理想的な実装であるように思われ、これ以上はできません。</font><font style="vertical-align: inherit;">しかし、すべてがはるかに複雑です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2サーバーの調整：複雑化</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFOオーダーでのリクエストの処理</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セマフォスリム</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並行スタック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビジネスロジックについて少し忘れました。スロットリングになるリクエストは、実際のhttpリクエストです。原則として、タイムアウトには、この要求を自動的に送信したユーザーが設定するか、しばらくしてからF5キーを押すユーザーのタイムアウトが設定されます。したがって、通常のセマフォのようにキュー順でリクエストを処理する場合、最初に、タイムアウトしたキューからのすべてのリクエストがすでに処理されている可能性があります。スタック順で作業する場合-最後に来たすべての要求の最初に処理すれば、そのような問題は発生しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SemaphoreSlimに加えて、ConcurrentStack、TaskCompletionSourceを使用して多くのコードをラップし、すべてが必要な順序で機能するようにしました。 TaskCompletionSourceは、CancellationTokenSourceに似ていますが、CancellationTokenではなくTaskです。 TaskCompletionSourceを作成し、そこからタスクを引き出して配布し、このタスクの結果を設定する必要があることをTaskCompletionSourceに伝えることができます。このタスクを待機している人は、この結果について知ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすべてそれを実装しました。コードはひどいです。そして最悪の場合、それは機能しないことが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かなり負荷の高いアプリケーションで使用を開始してから数か月後に、問題が発生しました。前のケースと同じように、CPU消費量は100％に増加しました。同じことを行って、ダンプを削除し、WinDbgでそれを見て、再びロックコンボイを見つけました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回は、ロックコンボイがSemaphoreSlim.WaitAsyncおよびSemaphoreSlim.Release内で発生しました。 SemaphoreSlim内にロックがあり、ロックフリーではないことがわかりました。これは、私たちにとってかなり深刻な欠点であることがわかりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SemaphoreSlimの内部には、内部状態（まだその下に移動できるワーカーの数のカウンター）と、このSemaphoreで待機している人の二重リンクリストがあります。ここでの考え方はほぼ同じです。このセマフォで待つことができ、期待をキャンセルして、このキューを離れることができます。ちょうど私たちの生活を台無しにしたロックがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが決めたのは、私たちが作成しなければならなかったすべての恐ろしいコードでダウンしました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐにロックフリーになり、スタック順ですぐに機能するセマフォを書いてみましょう。待機のキャンセルは重要ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この条件を定義します。これがcurrentCountの数になります-これは、セマフォに残っている場所の数です。セマフォに席が残っていない場合、この数は負の数になり、キューにあるワーカーの数を示します。 TaskCompletionSource'ovで構成されるConcurrentStackもあります。これは、必要に応じてプルされるウェイター 'ovのスタックです。 WaitAsyncメソッドを書いてみましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword">ref</span> currentCount);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (decrementedCount &gt;= <span class="hljs-number">0</span>)<font></font>
    <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
<font></font>
<span class="hljs-keyword">var</span> waiter = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-keyword">bool</span>&gt;();<font></font>
waiters.Push(waiter);<font></font>
<font></font>
<span class="hljs-keyword">return</span> waiter.Task;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、カウンターを減らし、セマフォで自分のために1か所取ります。空きがある場合は、「それだけです、あなたはセマフォの下に行きました」と言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマフォに場所がない場合は、TaskCompletionSourceを作成し、それをwaiter'ovのスタックにスローして、Taskを外部に返します。</font><font style="vertical-align: inherit;">時間が来ると、このタスクは機能し、ワーカーは自分の作業を続行してセマフォの下に移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Releaseメソッドを記述します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> countBefore = Interlocked.Increment(<span class="hljs-keyword">ref</span> currentCount) - <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">if</span> (countBefore &lt; <span class="hljs-number">0</span>)<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (waiters.TryPop(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> waiter))<font></font>
        waiter.TrySetResult(<span class="hljs-literal">true</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Releaseメソッドは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セマフォの1席無料</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">currentCountを増分する</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
currentCountに従って、シグナルを送る必要があるスタック内にウェイターがあるかどうかがわかる場合、そのようなウェイターをスタックから引き出してシグナルします。ここでウェイターはTaskCompletionSourceです。このコードへの質問：それは論理的なようですが、それでも機能しますか？どのような問題がありますか？ continuation'yとTaskCompletionSource'yが起動される場所に関連するニュアンスがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを検討してください。 TaskCompletionSourceを作成し、2つのタスクを起動しました。最初のタスクはユニットを表示し、結果をTaskCompletionSourceに設定してから、コンソールにデュースを表示します。 2番目のタスクは、このTaskCompletionSourceとそのタスクを待機し、そのスレッドをスレッドプールから永久にブロックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何が起こりますか？コンパイル時のタスク2は2つのメソッドに分割され、2番目のメソッドはThread.Sleepを含む継続です。 TaskCompletionSourceの結果を設定した後、この継続は、最初のタスクが実行されたのと同じスレッドで実行されます。したがって、最初のタスクのフローは永久にブロックされ、コンソールへのデュースは出力されなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、このコードを変更しようとしましたが、コンソールユニットへの出力を削除すると、スレッドプールから別のスレッドで継続が開始され、デュースが出力されました。その場合、継続は同じスレッドで実行され、スレッドプールに到達するのは読者への質問です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-keyword">bool</span>&gt;(<font></font>
 TaskCreationOptions.RunContinuationsAsynchronously);<font></font>
	<font></font>
<span class="hljs-comment">/* OR */</span><font></font>
	<font></font>
Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal">true</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、対応するRunContinuationsAsynchronouslyフラグを使用してTaskCompletionSourceを作成するか、スレッドで実行されないようにTask.Run/ThreadPool.QueueUserWorkItem内でTrySetResultメソッドを呼び出します。スレッドで実行すると、望ましくない副作用が発生する可能性があります。また、もう1つ問題があります。詳しく説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WaitAsyncメソッドとReleaseメソッドを確認し、Releaseメソッドの別の問題を見つけてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たぶん、彼女をそんなに単純に不可能に見つけること。ここには人種があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、WaitAsyncメソッドでは状態の変化がアトミックでないためです。</font><font style="vertical-align: inherit;">最初にカウンターをデクリメントし、次にウェイターをスタックにプッシュします。</font><font style="vertical-align: inherit;">リリースがデクリメントとプッシュの間に実行される場合は、スタックから何もプルしないように終了する可能性があります。</font><font style="vertical-align: inherit;">これを考慮に入れる必要があり、Releaseメソッドでは、ウェイターがスタックに表示されるのを待ちます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> countBefore = Interlocked.Increment(<span class="hljs-keyword">ref</span> currentCount) - <span class="hljs-number">1</span>;<font></font>
	<font></font>
<span class="hljs-keyword">if</span> (countBefore &lt; <span class="hljs-number">0</span>)<font></font>
{<font></font>
    Waiter waiter;<font></font>
	<font></font>
    <span class="hljs-keyword">var</span> spinner = <span class="hljs-keyword">new</span> SpinWait();<font></font>
	<font></font>
    <span class="hljs-keyword">while</span> (!waiter.TryPop(<span class="hljs-keyword">out</span> waiter))<font></font>
      spinner.SpinOnce();<font></font>
	<font></font>
    waiter.TrySetResult(<span class="hljs-literal">true</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、何とか引き出すまでループで実行します。</font><font style="vertical-align: inherit;">もう一度プロセッササイクルを無駄にしないために、SpinWaitを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の数回の繰り返しでは、ループでスピンします。</font><font style="vertical-align: inherit;">反復回数が多くなると、ウェイターが長時間表示されなくなり、スレッドはThread.Sleepに移動して、CPUリソースを再び浪費しないようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、LIFOオーダーのセマフォは私たちのアイデアだけではありません。</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LowLevelLifoSemaphore</font></font></b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windowsでは、IO完了ポートをWindowsスタックとして使用します</font></font></li>
</ul><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</font></font></a></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET自体にはそのようなセマフォがありますが、CoreCLR、CoreFX、CoreRTにはありません。</font><font style="vertical-align: inherit;">.NETリポジトリを覗くと、非常に役立つことがあります。</font><font style="vertical-align: inherit;">LowLevelLifoSemaphoreというセマフォがあります。</font><font style="vertical-align: inherit;">とにかく、このセマフォは私たちには適していません。同期しているからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注目すべきことに、WindowsではIO Completionポートを通じて動作します。</font><font style="vertical-align: inherit;">それらはスレッドがそれらを待つことができるという特性を持っており、これらのスレッドはLIFOの順序で解放されます。</font><font style="vertical-align: inherit;">この機能はそこで使用され、それは本当にLowLevelです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3結論：</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワークの充填があなたの負荷の下で生き残ることを期待しないでください</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なケースよりも特定の問題を解決する方が簡単です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレステストは常に役立つわけではありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロッキングに注意</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この全体の話からの結論は何ですか？</font><font style="vertical-align: inherit;">まず、標準ライブラリから使用するフレームワークの一部のクラスが負荷に対処することを期待しないでください。</font><font style="vertical-align: inherit;">SemaphoreSlimが悪いとは言いたくありません。このシナリオでは特に不適切であることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のタスク用にセマフォを書く方がはるかに簡単であることがわかりました。</font><font style="vertical-align: inherit;">たとえば、待機のキャンセルはサポートされていません。</font><font style="vertical-align: inherit;">この機能は通常のSemaphoreSlimで利用できますが、ありませんが、これによりコードを簡略化することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
負荷テストは役立ちますが、必ずしも役立つとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETは予期しない場所で頻繁にロックを行うことで知られています-それらに注意することをお勧めします。</font><font style="vertical-align: inherit;">コードにロック構造を作成する場合は、「ここでの実際の負荷は何ですか？」と考えることをお勧めします。</font><font style="vertical-align: inherit;">そして、突然CPU使用率が100％になると、すべてのスレッドがロックされ、おそらくこれは.NET内のどこかで発生しています。</font><font style="vertical-align: inherit;">それを覚えておいてください。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の話に移りましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストーリー3：（A）同期IO</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期ではないことが判明した非同期I / Oのストーリー。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックコンボイもここで発生しました。これは、OverlappedおよびPinnableBufferCacheというクラス内のスタックトレースによって発生しました。ロックがありました。これらのクラスは何ですか：OverlappedおよびPinnableBufferCache？</font></font><br>
 <br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OVERLAPPED</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、すべてのI / O操作に使用されるWindowsの構造です。かなりロードされたアプリケーションがありました。これは、分散ファイルシステムのシャードの1つです。それはディスクとネットワーク上のファイルで多くの働きをします。そして、彼はそのような構造をたくさん必要としました、その結果、錠の護送隊が明らかにされました。このロックコンボイの一般的な理由は何か、以前はすべてが機能していた理由を理解し始めましたが、現在は停止しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この話はずっと前、.NET 4.5.1と4.5.2の時代に起こったことに注意してください。その後、.NET 4.5.2がリリースされました。違いは、.NET 4.5.2での変更点です。 .NET 4.5.1では、これらのOverlappedオブジェクトのプールであるOverlappedDataCacheと呼ばれるクラスがありました。実際、非同期操作ごとにそれらを作成する理由は、プールを作成する方が簡単です。このプールは良好で、ConcurrentStackに基づくロックフリーであり、問​​題はありませんでした。 .NET 4.5.2では、これらのオブジェクトのプルを最適化することを決定しました。OverlappedDataCacheを削除し、PinableBufferCacheを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは何ですか？</font><font style="vertical-align: inherit;">PinnableBufferCacheは、オブジェクトがキックされている間にオーバーラップされたオブジェクトをネイティブコードに転送する必要があることを想定して設計されています。</font><font style="vertical-align: inherit;">したがって、すでに第2世代に該当するオブジェクトを配布するとよいでしょう。</font><font style="vertical-align: inherit;">PinnableBufferCacheは2つの部分に分割されています。</font><font style="vertical-align: inherit;">最初の部分はConcurrentStackに基づいており、ロックフリーです。</font><font style="vertical-align: inherit;">すでに第2世代にあるオブジェクトを対象としています。</font><font style="vertical-align: inherit;">このプールの内部には、まだゼロおよび第1世代にあるオブジェクト用の2番目の部分があり、何らかの理由で、ロックのない構造ではなく、ロック付きの通常のリストを使用します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1 PinnableBufferCache</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LockConvoy：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファが不足した場合</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトがプールに返されたとき</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、バッファオブジェクトが不足し、新しいオブジェクトを作成する必要があるときにロックコンボイが発生しました。</font><font style="vertical-align: inherit;">この場合、これらのオブジェクトがプールに返されると、それらは不良リストに分類されます。オブジェクトが返されると、ロックがキャプチャされて、ゼロおよび第1世代のプールのオブジェクトが第2世代に転送されたかどうかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PinnableBufferCacheコードの調査を開始したところ、ドキュメントに記載されていない環境変数にアクセスできることがわかりました。</font><font style="vertical-align: inherit;">それはこのように呼ばれました：</font></font><br>
<br>
<pre><code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この変数を使用すると、最初にプールに入れるオブジェクトの数を設定できます。</font><font style="vertical-align: inherit;">私たちは次のように決定しました。</font><font style="vertical-align: inherit;">それを使って、この変数に大きな数を入れましょう。」</font><font style="vertical-align: inherit;">これで、アプリケーションに次のブードゥーコードが追加されました。</font></font><br>
<br>
<pre><code class="cs hljs">Environment.SetEnvironmentVariable(<font></font>
  <span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span>, <span class="hljs-string">"10000"</span>);<font></font>
	<font></font>
<span class="hljs-keyword">new</span> Overlapped().GetHashCode();<font></font>
	<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<font></font>
    GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何をしているのですか？</font><font style="vertical-align: inherit;">最初に環境変数を設定してから、プールが初期化されるようにOverlappedオブジェクトを作成し、手動でガベージコレクションを数回呼び出します。</font><font style="vertical-align: inherit;">このプールにあるすべてのオブジェクトが第2世代に入るようにガベージコレクションが呼び出され、PinableBufferCacheがロックコンボイで背後にあります。</font><font style="vertical-align: inherit;">このソリューションは機能していることが判明し、フレームワークのコードではまだ有効です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Coreでは、PinnableBufferCache </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">OverlappedDataをネイティブメモリに移動し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">という事実を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">取り除きました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、それらをメモリに固定する必要はなくなりました。ガベージコレクタはネイティブメモリにあるため、どこにも移動できません。</font><font style="vertical-align: inherit;">.NET Coreのストーリーはここで終わりました。</font><font style="vertical-align: inherit;">.NET Frameworkでは、私が間違っていない限り、この修正はまだ転送されていません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2結論：</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての最適化が同じように役立つわけではありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今回はラッキー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして再び.NET Core</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは明らかに、ガベージコレクターの負荷を減らすことで、ここでより良いことをしたかったのです。</font><font style="vertical-align: inherit;">.NET開発者が変数を介してこのプールのオブジェクトの最小数を設定する機会を提供できたことは非常に幸運でした。それ以外の場合は、もっとひどいハックを書かなければなりませんでした。</font><font style="vertical-align: inherit;">もう一度、.NET Coreを試してください。</font><font style="vertical-align: inherit;">おそらくこれでパフォーマンスの問題が解決し、このためのブードゥーコードを書く必要さえありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、キーと値のコレクションに移りましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履歴4：同時Key-Valueコレクション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETには複数の並行コレクションがあります。</font><font style="vertical-align: inherit;">これらは、ConcurrentStackおよびConcurrentQueueのロックフリーのコレクションであり、問​​題はありませんでした。</font><font style="vertical-align: inherit;">ConcurrentDictionaryのコレクションがあり、すべてがより興味深いです。</font><font style="vertical-align: inherit;">それは記録のためにロックフリーではありません、ロックがありますが、今はそれらについてではありません。</font><font style="vertical-align: inherit;">なぜConcurrentDictionaryを使用するのですか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 ConcurrentDictionary</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーション：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">索引</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長所：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ライブラリに含まれています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">便利な操作（TryAdd / TryUpdate / AddOrUpdate）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックフリーの読書</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックフリーの列挙</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、さまざまなキャッシュ、メモリインデックス、および複数のスレッドからアクセスできるようにする必要があるその他の構造に使用されます。彼は、.NET Frameworkでさえ、完全に標準であることで愛されています。複数のスレッドから作業するための非常に便利な操作があります。そして重要なのは、ロックフリーの読み取りと列挙があることです。もちろん、トリックがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETのハッシュテーブルに基づくコレクションがどのように機能するかを見てみましょう。ほとんどのキーと値のコレクションはハッシュテーブルに基づいており、次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッシュコードが計算され、bucket'ovの数がモジュロで計算されます。コレクション自体には、要素が格納される複数のバケットがあります。衝突が発生した場合、リンクリストの原則によって相互に接続されているいくつかの要素が1つのバケットに分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、各正方形は個別のオブジェクトであり、ほとんどConcurrentDictionaryです。 ConcurrentDictionaryでは、キーと値のペアごとに個別のオブジェクトが作成されます。さらに、値を置き換えるときに、値自体が特定のサイズよりも大きい場合、それらの値は常に再作成されるため、メモリトラフィックも発生します。完全にConcurrentDictionaryにするために、私はロックを描きました。 1つの正方形は1つのオブジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、通常の辞書がどのように機能するかを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のディクショナリはコンカレントよりもトリッキーですが、メモリ内でよりコンパクトです。これには、バケット配列とエントリー配列の2つの配列があります。 buckets配列には、entries配列内のこのバケットの最初の要素のインデックスが含まれています。すべてのキーと値のペアは、entries配列に格納されます。リンクされたリストは、配列内のインデックスを参照することにより、ここで編成されます。つまり、さらに、キーと値のペアでは、整数intが格納され、バケット内の次の要素のインデックスが格納されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ConcurrentDictionaryと通常のディクショナリを使用するときに発生するメモリオーバーヘッドを比較してみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の辞書から始めましょう。記憶の過剰、私はここで自分自身のキーと値ではないすべてを意味します。通常のディクショナリの場合、このオーバーヘッドは次の要素のハッシュコードとインデックス、2つの整数を構成します。これは8バイトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ConcurrentDictionaryを見てください。 ConcurrentDictionaryでは、要素はConcurrentDictionary.Nodeオブジェクト内に格納されます。これはオブジェクト、クラスです。このクラスには、int hashCodeと、リンクリスト内の次のオブジェクトへのリンクが含まれています。つまり、オブジェクトヘッダー、テーブルメソッドへの参照（これは既に16バイトです）、int hashCodeがあり、オブジェクトへの参照があります。サイズを混在させていない場合、64ビットプラットフォームでは28バイトのオーバーヘッドになります。通常のディクショナリと比較してかなり。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリのオーバーヘッドに加えて、ConcurrentDictionaryは、多くのオブジェクトを持っているため、GCに負荷をかけることができます。私は非常にシンプルなベンチマークを書きました。特定のサイズのConcurrentDictionaryを作成し、GC.Collectメソッドの稼働時間を測定します。何をもらったの？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれらの結果を得ました。</font><font style="vertical-align: inherit;">プロセスに1000万要素のConcurrentDictionaryがある場合、コンピューターでのガベージコレクションは0.5秒かかりますが、サーバーでは、この0.5秒は数秒に変わる可能性があり、すでに許容できない可能性があります。</font><font style="vertical-align: inherit;">これは通常の辞書では起こりません。</font><font style="vertical-align: inherit;">いくつの要素を入れても、通常の配列、2つのオブジェクトがあり、すべてが非常に優れています。</font><font style="vertical-align: inherit;">ガベージコレクタは動作時間に影響を与えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ConcurrentDictionaryを使用するときに発生する問題にどのように対処できますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2シンプルなソリューション</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ制限</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TTL</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書+ロック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャーディング</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルで効果的なソリューションを見てみましょう。</font><font style="vertical-align: inherit;">ConcurrentDictionaryのサイズを制限できます。</font><font style="vertical-align: inherit;">キャッシュを1000万要素に保つ必要があることはほとんどありません。</font><font style="vertical-align: inherit;">あなたは千を保つことができ、問題はありません。</font><font style="vertical-align: inherit;">要素のTTLを作成し、定期的にそれらをクリーニングできます。</font><font style="vertical-align: inherit;">場合によっては、ロック付きの通常のディクショナリを使用すると非常に効果的です。</font><font style="vertical-align: inherit;">もちろん、ここでのロックがパフォーマンスを低下させないようにする必要があります。</font><font style="vertical-align: inherit;">辞書に要素を配置する前に、このアプローチを開発して自分でロック付きのディクショナリーを解凍し、ハッシュコードで要素をいくつかのディクショナリーに分解すると、同じロックで競合することはありません。</font><font style="vertical-align: inherit;">しかし、シンプルなソリューションが機能しないことがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3インデックス</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インメモリインデックスを保存する必要があります&lt;Guid、Guid&gt;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックス&gt; 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテム</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のスレッドからの読み取りが常に発生する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レアエントリー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コレクション内のすべての要素をリストできる必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは同じような状況に直面しました。</font><font style="vertical-align: inherit;">私たちには非常に重要なアプリケーションがあります。これは私たちの分散ファイルシステムのマスターであり、GuidからGuidにメモリ内インデックスを格納し、サーバー上のファイルの場所を覚えておく必要があります。</font><font style="vertical-align: inherit;">このインデックスには約100万の要素が含まれていました。</font><font style="vertical-align: inherit;">誰かが常にこのインデックスから何かを読み取りますが、このインデックスに書き込むことはほとんどありません。</font><font style="vertical-align: inherit;">たまたま、このアプリケーションでは、第2世代のガベージコレクションに約15秒かかりました。</font><font style="vertical-align: inherit;">それは受け入れられませんでした。</font><font style="vertical-align: inherit;">セマフォと同じことを行い、独自のアナログConcurrentDictionaryを作成することにしました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りと一覧表示のためにロックフリーである必要があり、メモリのオーバーヘッドとGCの負荷が少なくなります。また、1人のライターと複数のリーダーでスクリプトをサポートするだけで十分です。つまり、彼らがめったにそれに書き込むことはなく、私たちはそれを読むのに十分なほど、書くのが上手である必要はありません。彼が何らかの無効な状態になる可能性もあり、一度に複数のライターが彼に近づいた場合、それらは外部から同期できます。そして、可能であれば、これらすべてがラージオブジェクトヒープに分類されません。何故なの？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなことをしようと決心したとき、これらの要件に合わせて通常の辞書を変更できるかどうかを調査することから始めました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のディクショナリには、エントリの配列であるbucket'ovの配列があります。エントリには、キー、値、ハッシュとリンク、次の要素のインデックスが格納されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のディクショナリはスレッドセーフであり、ライターがない場合、リーダーは状態を変更できません。</font><font style="vertical-align: inherit;">おそらくこれはいくつかの問題を解決することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りと並行してレコードがある場合、何が問題になる可能性がありますか？</font><font style="vertical-align: inherit;">まず、サイズを変更するとき、配列がより大きな配列に置き換えられると、読者はコレクションの異なるバージョンに関連する2つの配列を見ることができます。</font><font style="vertical-align: inherit;">この問題は非常に簡単に解決されます。</font><font style="vertical-align: inherit;">辞書があり、2つの配列、バケット、エントリがあり、これらの配列を1つのオブジェクトに結合し、必要に応じてInterlockedを介して置き換えます。</font><font style="vertical-align: inherit;">したがって、読者は異なるバージョンの2つの配列を決して見ることはありません。</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書</font></font></b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライターがいない場合でもスレッドセーフで読み取り可能</font></font></li>
<li>    ,   ?<br>
 —  Resize  buckets  entries  <br>
 —      -<br>
 —    Dictionary.Entry<br>
 —   -  </li>
</ul><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターネットには恐ろしい話があり、通常のディクショナリへのマルチスレッドアクセスでは、bucket'ov内のインデックスリンクをループできます。実際、このサイクルは、競合するライターが複数いる場合にのみ発生します。競争力のあるライターが1人しかいない場合は、リーダーだけが中断でき、ライターはコレクションを必要な状態にします。 2人の並列ライターがいる場合、それらはコレクション内でサイクルを形成でき、これは非常に簡単に再現できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辞書のエントリの代わりにゴミを読むことができます。間違ったコレクションのどこかにあるインデックスリンクに誤ってジャンプする可能性があります。これらの問題を解決する方法を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は.NET Frameworkバージョン1.1に由来します。</font><font style="vertical-align: inherit;">Hashtableクラスが登場しました。これは、オブジェクトを処理する非ジェネリックバージョンのディクショナリです。</font><font style="vertical-align: inherit;">MSDNで直接それについては、必要なスクリプトを実装していると言われています。</font><font style="vertical-align: inherit;">同時に読み込まれる場合はスレッドセーフであり、書き込みスレッドは1つだけです。</font><font style="vertical-align: inherit;">興味をそそられました。</font><font style="vertical-align: inherit;">彼らはハッシュテーブルが内部に配置されている方法を分解し始めました。</font><font style="vertical-align: inherit;">特定された問題のいくつかを解決する方法を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Dictionary.Entryの代わりにゴミを読む</font></font></h3><br>
<img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが起こるのでしょうか？</font><font style="vertical-align: inherit;">Dictionary.Entryは大きく、8バイトを超えています。実際には可能ですが、アトミックに読み取ることができないようです。</font><font style="vertical-align: inherit;">どうやってするの？</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">bool</span> writing;<font></font>
<span class="hljs-keyword">int</span> version;<font></font>
<font></font>
<span class="hljs-keyword">this</span>.writing = <span class="hljs-literal">true</span>;<font></font>
buckets[index] = …;<font></font>
<span class="hljs-keyword">this</span>.version++;<font></font>
<span class="hljs-keyword">this</span>.writing = <span class="hljs-literal">false</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの変数が巻き上げられます。フラグ（現在、読み取りたい構造に書き込んでいるかどうか）とintバージョンです。</font><font style="vertical-align: inherit;">非常に標準的なソリューション、ねじ込みバージョン。</font><font style="vertical-align: inherit;">作者はフラグを設定し、今何を書くか、書き込み、バージョンの更新、フラグの削除を行います。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">bool</span> writing;<font></font>
<span class="hljs-keyword">int</span> version;<font></font>
	<font></font>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
{<font></font>
  <span class="hljs-keyword">int</span> version = <span class="hljs-keyword">this</span>.version;<font></font>
  bucket = bickets[index];<font></font>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.writing || version != <span class="hljs-keyword">this</span>.version)<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
  <span class="hljs-keyword">break</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーはクリーンな読み取りを行い、ループでスピンし、読み取り中にこのフラグのバージョンとステータスが変更されたかどうかを確認します。</font><font style="vertical-align: inherit;">アイテムが変更されているか、現在変更されている場合は、もう一度読んでみてください。</font><font style="vertical-align: inherit;">このソリューションでは、8バイトを超えるアトミック構造を読み取ることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5ガベージへの参照インデックスを通過する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように起こるか見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辞書では、レコードがある場合、そこから読み取るときに別のバケットにジャンプできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの要素で構成される辞書があります。</font><font style="vertical-align: inherit;">ここでは、簡単にするために、0と2のキーを書きました。これは1つのバケットで、残りの1つを2で割ったものです。</font><font style="vertical-align: inherit;">リーダーが来て0を読み取ります。次に、彼は現在2になっているセルに移動する必要があることを覚えています。その後、ストリームが中断されます。</font><font style="vertical-align: inherit;">次にライターが来て2を削除し、次にこのデュースの場所に追加します。たとえば、1。1は2で割った余りをもう1つ与えます-これは別のバケットになります。</font><font style="vertical-align: inherit;">私たちの読者は、デュースのいる独房に行く必要があることを思い出しました。</font><font style="vertical-align: inherit;">彼はそこから読みます1-それだけです、私たちは別のバケツにジャンプしました。</font><font style="vertical-align: inherit;">Hashtableでは、bucket'ovとインデックスリンクを完全に破棄することで、この問題を回避しました。</font><font style="vertical-align: inherit;">そこでは、衝突を解決する別のアプローチが使用されています- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダブルハッシュ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6衝突処理</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素は配列に格納されます。</font></font></li>
<li>    </li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>      </li>
<li>   ,  resize</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>    ,     </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
衝突処理は、いわゆるトラバーサル順序で処理されます。同じようにすべての要素が1つの配列にありますが、同時にBuckets配列はなくなり、Entries配列のみが存在します（Entriesと呼ばれるはずですが、Bucketsと呼ばれます）。次は、この構造で検索する要素のハッシュコードです。要素を検索するために、この配列内のセルを通過する必要がある順序を理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記録するとき、トラバーサル順序で最初の空きセルに要素を書き込みます。フリーセルがない場合は、コレクションのサイズを変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りについて：必要な要素が見つかるまで、または明らかに他の要素がないという兆候がある要素が見つかるまで、トラバーサルの順序で進みます。おそらく、回避策のあるアイデアはやや曖昧に思えたので、例を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
順次クロールになり得る最も単純なクロール順序を検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼はどのように働きますか？いくつかのキーがあり、そこからのハッシュコードは2です。この配列のインデックスとして引き続き使用できるように、コレクションの容量を法としてハッシュコードを取得します。ハッシュ-2があります。特定のキーを持つ、そのようなハッシュを持つ要素を見つけたいと考えています。インデックス2のセルを見てみましょう。この要素はありますか？ある場合は、すでに見つかっていることを意味し、返却します。他の要素があった場合は、カウントの次のセル、つまりインデックス3のセルに移動します。要素がそこにあるかどうかを確認し、ない場合は、4番目の要素に移動してゼロに移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hashtableで使用されるトラバーサル順序は順次ではありません。より複雑で、いわゆるダブルハッシュを使用します。単位ではなく、ハッシュを使用して計算される別の数値であるという点で、逐次的なものとは異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列を通過するステップのサイズとこの配列のサイズが互いに素の数である場合、配列を走査するときに、すべての要素を1回だけ通過します。これはハッシュテーブルで使用されるものです。配列のサイズが常に素数になるようにしました-任意の数がステップサイズとして適しています。任意のセルから、アレイに沿ってループに沿ってさらにセル内を歩き始めます。したがって、バケットはありません。どこにジャンプしたり、何かを読んだりすることも、これらのリンクを壊すこともできません。それは良くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、彼らが望んでいたほとんどすべてがすでに実装されており、ロックフリーの列挙を実装し、LOHに入るのを避けることが残っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックのない転送を行う方法は？ MSDNでは、Hashtableのドキュメントに、列挙に対してスレッドセーフではないと記載されています。この問題は、データ構造の特殊性のために、同じキーを持つ要素が列挙中に削除されて再度追加された場合に繰り返される可能性があるという事実によって発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作を避けたい場合は、純粋な読み取りを使用できますが、コレクション内の個々の要素ではなく、bucket'ovを使用できます。私たちのコレクションは、通常のハッシュテーブルであるバケット付きの通常のディクショナリのアイデアに基づいていますが、これらのバケットは常に完全な状態で完全に読み取られます。つまり、誰かがバケットに書き込めた場合、バケットを再度読み取る必要があります。録音はそれほど頻繁ではないため、これはそれほど重要ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造がラージオブジェクトヒープに入らないようにします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、それを共有できます。</font><font style="vertical-align: inherit;">CustomDictionaryをCustomDictionarySegmentに置き換え、上にラップします。</font><font style="vertical-align: inherit;">辞書があり、要素はハッシュによって分散されているいくつかのセグメントで構成されています。</font><font style="vertical-align: inherit;">各セグメントは、前に説明した辞書です。</font><font style="vertical-align: inherit;">これらの各セグメントでは、配列は小さく、ラージオブジェクトヒープに分類されません。</font><font style="vertical-align: inherit;">これらの配列自体は小さいので、それらのバケットは小さいです。</font><font style="vertical-align: inherit;">したがって、突然誰かが何かに書き込んだ場合、それらをきれいに読んだり、バケツ全体を再度読んだりするような贅沢をすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアイデアの発展として、セグメントをロックすることができます。</font><font style="vertical-align: inherit;">その結果、ほぼ同じ.NETのConcurrentDictionaryが得られますが、通常のすべての機能が必要ない特定のシナリオへの適用は制限されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.7結論</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETは完璧ではありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何も完璧ではありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準クラスのしくみを理解する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">車輪を再発明する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストバイク</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべてからの結論は何ですか？</font><font style="vertical-align: inherit;">.NETは完璧ではありません。</font><font style="vertical-align: inherit;">何も完璧ではありません。</font><font style="vertical-align: inherit;">標準ライブラリにあるすべての構造は、非常に多くのシナリオで機能します。</font><font style="vertical-align: inherit;">あなたはあなた自身のシナリオを持っていますか-あなたは他に何かが必要です。</font><font style="vertical-align: inherit;">コードを作成するときは、標準ソリューションが適切かどうかをテストして確認してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何か問題が発生した場合は、それがどのように機能するか、使用する標準クラスの中に何があるかを学びます。</font><font style="vertical-align: inherit;">それがどのように機能するかを学び、コードで何を変更する必要があるかを正確に理解していない場合は、いくつかの内部矛盾に陥り、自転車を発明する必要があるかもしれません。</font><font style="vertical-align: inherit;">自転車を発明しました-自転車をテストして、機能することを確認してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味深い驚きConcurrentDictionary：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//habr.com/en/company/skbkontur/blog/348508/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/vostok/commons.threading</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/epeshk/dotnext-2019-threading</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のリンクは、ConcurrentDictionaryのいくつかのトリックに関する私の同僚のIlya Loktionovによる記事へのリンクです。</font><font style="vertical-align: inherit;">ちなみに、KonturインフラストラクチャチームのIlya Loktionov（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディアフィルム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、それらがなければ、このレポートは行われなかったでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでGitHubへのリンクも提供します。</font><font style="vertical-align: inherit;">2番目のリンクは、オープンソースにあるライブラリへのリンクであり、説明されているLIFO-Semaphoreが含まれています。</font><font style="vertical-align: inherit;">レポートに含まれていたコード例を含むリポジトリへの3番目のリンク。</font></font><br>
<blockquote>6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">«.NET:  »</a>    ,        .NET Framework  .NET Core,  ,        .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468601/index.html">プロジェクト期間の見積もり。なぜそれはほとんど常に控えめな表現であり、それについて何をすべきか</a></li>
<li><a href="../ja468603/index.html">RutrackerにはeSNIが含まれています。DPI時代の終わりとロックの終わり</a></li>
<li><a href="../ja468605/index.html">ポインターへのポインターへの定数ポインター...</a></li>
<li><a href="../ja468607/index.html">ラジオエンジニア向けAndroid（パート2）</a></li>
<li><a href="../ja468609/index.html">複数のスケジューリングの不可解なパフォーマンス</a></li>
<li><a href="../ja468621/index.html">ホームネットワークをDoHに変換するか、フィルタリングノーズをもう一度クリックします。</a></li>
<li><a href="../ja468623/index.html">Habrのレビューが欲しい</a></li>
<li><a href="../ja468625/index.html">サーバーレス：15％遅く、8倍高価</a></li>
<li><a href="../ja468627/index.html">ADAM-6200 I / Oモジュール</a></li>
<li><a href="../ja468629/index.html">100万回実行しても画像が破損しないフィルターを作成する方法-パート2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>