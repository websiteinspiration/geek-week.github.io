<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçê üí™üèæ üèÖ Einfache Diagrammdurchquerung: Tiefensuche und Breitensuche am Beispiel von JavaScript ü•ã üßë ‚úäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sch√∂nen Tag. 
 
 Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚ÄûAlgorithmen in Graphen: Sprechen wir √ºber die Tiefensuche (DFS) und die Breitensu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Einfache Diagrammdurchquerung: Tiefensuche und Breitensuche am Beispiel von JavaScript</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504374/"><img src="https://habrastorage.org/webt/_f/kf/kl/_fkfkl3gfkmnwtes2eypbueifxe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sch√∂nen Tag. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich pr√§sentiere Ihnen die √úbersetzung des Artikels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûAlgorithmen in Graphen: Sprechen wir √ºber die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiefensuche </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">(DFS) und die</font></a><font style="vertical-align: inherit;"> Breitensuche </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">(BFS)‚Äú</font></a><font style="vertical-align: inherit;"> von Try Khov.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist eine Graphen√ºberquerung?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einfachen Worten, eine Diagrammdurchquerung ist ein √úbergang von einem ihrer Scheitelpunkte zu einem anderen auf der Suche nach den Verbindungseigenschaften dieser Scheitelpunkte. </font><font style="vertical-align: inherit;">Verkn√ºpfungen (Linien, die Scheitelpunkte verbinden) werden als Richtungen, Pfade, Fl√§chen oder Kanten eines Diagramms bezeichnet. </font><font style="vertical-align: inherit;">Die Eckpunkte des Graphen werden auch als Knoten bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beiden Hauptalgorithmen f√ºr das Durchlaufen von Graphen sind die Tiefensuche (DFS) und die Breitensuche (BFS). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass beide Algorithmen zum Durchlaufen des Graphen verwendet werden, weisen sie einige Unterschiede auf. </font><font style="vertical-align: inherit;">Beginnen wir mit DFS.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefensuche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die DFS folgt dem Konzept ‚Äûtief gehen, mit dem Kopf voran‚Äú. Die Idee ist, dass wir uns vom Startgipfel (Punkt, Ort) in eine bestimmte Richtung (entlang eines bestimmten Pfades) bewegen, bis wir das Ende des Pfades oder Ziels (gew√ºnschter Gipfel) erreichen. Wenn wir das Ende des Pfades erreicht haben, es aber kein Ziel ist, kehren wir zur√ºck (bis zu verzweigten oder divergierenden Pfaden) und gehen einen anderen Weg. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns ein Beispiel an. Angenommen, wir haben einen gerichteten Graphen, der so aussieht: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir befinden uns am Punkt ‚Äûs‚Äú und m√ºssen den Scheitelpunkt ‚Äût‚Äú finden. Mit DFS untersuchen wir einen der m√∂glichen Pfade, bewegen uns bis zum Ende und gehen zur√ºck, wenn wir t nicht finden, und erkunden einen anderen Pfad. So sieht der Prozess aus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier bewegen wir uns entlang des Pfades (p1) zum n√§chsten Gipfel und sehen, dass dies nicht das Ende des Pfades ist. Deshalb fahren wir mit dem n√§chsten Gipfel fort. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das Ende von p1 erreicht, aber t nicht gefunden, also kehren wir zu s zur√ºck und bewegen uns auf dem zweiten Pfad. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Spitze des Pfades ‚Äûp2‚Äú erreicht haben, der dem Punkt ‚Äûs‚Äú am n√§chsten liegt, sehen wir drei m√∂gliche Richtungen f√ºr die weitere Bewegung. Da wir bereits den Gipfel besucht haben, der die erste Richtung kr√∂nt, bewegen wir uns entlang der zweiten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erreichten wieder das Ende des Weges, fanden aber t nicht und gingen zur√ºck. Wir folgen dem dritten Weg und erreichen schlie√ülich den gew√ºnschten Gipfel "t". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert DFS. Wir bewegen uns auf einem bestimmten Weg bis zum Ende. Wenn das Ende des Pfades der gew√ºnschte Peak ist, sind wir fertig. Wenn nicht, gehen Sie zur√ºck und gehen Sie einen anderen Weg, bis wir alle Optionen untersucht haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir folgen diesem Algorithmus f√ºr jeden besuchten Scheitelpunkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Notwendigkeit einer wiederholten Wiederholung der Prozedur zeigt die Notwendigkeit einer Rekursion an, um den Algorithmus zu implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der JavaScript-Code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A: [B,C], B:[D,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">adj, v, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// v -   ()</span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-comment">//    ,    </span>
	<span class="hljs-keyword">if</span>(v === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">if</span>(v.visited) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	v.visited = <span class="hljs-literal">true</span>
	<span class="hljs-comment">//    (  ) v</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">if</span>(!neighbor.visited) {
			<span class="hljs-comment">//     ,      </span>
			<span class="hljs-keyword">let</span> reached = dfs(adj, neighbor, t)
			<span class="hljs-comment">//  true,  </span>
			<span class="hljs-keyword">if</span>(reached) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-comment">//   v  t  </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Mit diesem speziellen DFS-Algorithmus k√∂nnen Sie √ºberpr√ºfen, ob es m√∂glich ist, von einem Ort zum anderen zu gelangen. </font><font style="vertical-align: inherit;">DFS kann f√ºr verschiedene Zwecke verwendet werden. </font><font style="vertical-align: inherit;">Diese Ziele bestimmen, wie der Algorithmus selbst aussehen wird. </font><font style="vertical-align: inherit;">Das allgemeine Konzept sieht jedoch genau so aus.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS-Analyse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns diesen Algorithmus analysieren. Da wir jeden ‚ÄûNachbarn‚Äú jedes Knotens umgehen und die zuvor besuchten ignorieren, haben wir eine Laufzeit von O (V + E). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine kurze Erkl√§rung, was V + E bedeutet: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V ist die Gesamtzahl der Eckpunkte. E ist die Gesamtzahl der Fl√§chen (Kanten). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es mag angemessener erscheinen, V * E zu verwenden, aber lassen Sie uns dar√ºber nachdenken, was V * E bedeutet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * E bedeutet, dass wir in Bezug auf jeden Scheitelpunkt alle Fl√§chen des Graphen untersuchen m√ºssen, unabh√§ngig davon, ob diese Fl√§chen zu einem bestimmten Scheitelpunkt geh√∂ren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andererseits bedeutet V + E, dass wir f√ºr jeden Scheitelpunkt nur die angrenzenden Kanten auswerten. </font><font style="vertical-align: inherit;">Zur√ºck zum Beispiel: Jeder Scheitelpunkt hat eine bestimmte Anzahl von Fl√§chen. Im schlimmsten Fall gehen wir um alle Scheitelpunkte (O (V)) herum und untersuchen alle Fl√§chen (O (E)). </font><font style="vertical-align: inherit;">Wir haben V Eckpunkte und E Fl√§chen, also erhalten wir V + E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir die Rekursion verwenden, um jeden Scheitelpunkt zu durchlaufen, bedeutet dies, dass ein Stapel verwendet wird (unendliche Rekursion f√ºhrt zu einem Stapel√ºberlauffehler). </font><font style="vertical-align: inherit;">Daher ist die r√§umliche Komplexit√§t O (V). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun das BFS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breite Suche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFS folgt dem Konzept "weit ausdehnen und auf die H√∂he eines Vogelfluges steigen" ("weit gehen, Vogelperspektive"). Anstatt sich auf einem bestimmten Weg bis zum Ende zu bewegen, muss bei BFS jeweils ein Nachbar vorw√§rts bewegt werden. Dies bedeutet Folgendes: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt dem Pfad zu folgen, bedeutet BFS, die Nachbarn, die s am n√§chsten liegen, in einer einzigen Aktion (Schritt) zu besuchen und dann die Nachbarn der Nachbarn usw. zu besuchen, bis t erkannt wird. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/vb/ny/1uvbnygi83vt6bxqnmv1hbwuzyq.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/en/jq/tgenjqvsz1zipcv3obsicrhq78a.png"><br>
<br>
<img src="https://habrastorage.org/webt/tf/j9/on/tfj9on04zudfmelpbn00xeh_tpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie unterscheidet sich DFS von BFS? Ich denke gerne, dass die DFS voranschreitet und die BFS es nicht eilig hat, sondern alles in einem Schritt studiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann stellt sich die Frage: Woher wissen Sie, welche Nachbarn zuerst besucht werden sollten?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu k√∂nnen wir das Konzept "First In, First Out" (First-In-First-Out, FIFO) aus der Warteschlange verwenden. </font><font style="vertical-align: inherit;">Wir stellen zuerst den Peak in die Warteschlange, der uns am n√§chsten liegt, dann die nicht besuchten Nachbarn und setzen diesen Vorgang fort, bis die Warteschlange leer ist oder bis wir den gesuchten Scheitelpunkt finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A:[B,C,D], B:[E,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">adj, s, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// s -  </span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">let</span> queue = []
	<span class="hljs-comment">//  s  </span><font></font>
	queue.push(s)<font></font>
	<span class="hljs-comment">//  s         </span>
	s.visited = <span class="hljs-literal">true</span>
	<span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-comment">//   ()   </span>
		<span class="hljs-keyword">let</span> v = queue.shift()
		<span class="hljs-comment">// abj[v] -  v</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
			<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span>(!neighbor.visited) {
				<span class="hljs-comment">//    </span><font></font>
				queue.push(neighbor)<font></font>
				<span class="hljs-comment">//    </span>
				neighbor.visited = <span class="hljs-literal">true</span>
				<span class="hljs-comment">//     ,  </span>
				<span class="hljs-keyword">if</span>(neighbor === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
			}<font></font>
		} <font></font>
	}<font></font>
	<span class="hljs-comment">//  t  ,     </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFS-Analyse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass BFS langsamer ist. Wenn Sie sich die Visualisierungen jedoch genau ansehen, k√∂nnen Sie feststellen, dass sie dieselbe Laufzeit haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer Warteschlange wird jeder Scheitelpunkt verarbeitet, bevor ein Ziel erreicht wird. Dies bedeutet, dass BFS im schlimmsten Fall alle Scheitelpunkte und Fl√§chen untersucht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass BFS m√∂glicherweise langsamer erscheint, ist es tats√§chlich schneller, da bei der Arbeit mit gro√üen Diagrammen festgestellt wird, dass DFS viel Zeit damit verbringt, Pfaden zu folgen, die sich letztendlich als falsch herausstellen. BFS wird h√§ufig verwendet, um den k√ºrzesten Weg zwischen zwei Spitzen zu finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit ist die BFS-Laufzeit auch O (V + E), und da wir eine Warteschlange verwenden, die alle Eckpunkte enth√§lt, ist ihre r√§umliche Komplexit√§t O (V).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analogien aus dem wirklichen Leben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Analogien aus dem wirklichen Leben geben, dann stelle ich mir die Arbeit von DFS und BFS so vor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich an DFS denke, stelle ich mir eine Maus in einem Labyrinth auf der Suche nach Nahrung vor. </font><font style="vertical-align: inherit;">Um zum Ziel zu gelangen, muss die Maus viele Male in eine Sackgasse geraten, zur√ºckkehren und sich auf andere Weise bewegen usw., bis sie einen Weg aus dem Labyrinth oder der Nahrung findet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/f3/ji/-ef3ji72zi8egr3xa26zqvt1x4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine vereinfachte Version sieht folgenderma√üen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/hb/dr/kqhbdrkv6xstug0ss3l5bpr1l9k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich an BFS denke, stelle ich mir wiederum Kreise auf dem Wasser vor. </font><font style="vertical-align: inherit;">Das Fallen eines Steins ins Wasser f√ºhrt zur Ausbreitung von St√∂rungen (Kreisen) in alle Richtungen vom Zentrum aus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/lz/zp/pvlzzpnzfssjv8yzpkc49ovtsho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine vereinfachte Version sieht folgenderma√üen aus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/w9/sc/s-w9scwvyp93tvyk2zwimmfc_um.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefen- und Breitensuche werden verwendet, um das Diagramm zu durchlaufen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS bewegt sich entlang der Kanten hin und her, und BFS verteilt sich auf der Suche nach einem Ziel auf die Nachbarn.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS verwendet den Stapel und BFS die Warteschlange.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Laufzeit von beiden ist O (V + E) und die r√§umliche Komplexit√§t ist O (V).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Algorithmen haben eine andere Philosophie, sind aber f√ºr die Arbeit mit Grafiken gleicherma√üen wichtig.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis </font><font style="vertical-align: inherit;">Per .: Ich bin kein Spezialist f√ºr Algorithmen und Datenstrukturen. Wenn daher Fehler, Ungenauigkeiten oder falsche Formulierungen festgestellt werden, schreiben Sie bitte zur Korrektur und Kl√§rung in einen pers√∂nlichen Brief. </font><font style="vertical-align: inherit;">Ich werde dankbar sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank f√ºr Ihre Aufmerksamkeit.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504354/index.html">Reduzieren Sie die Gr√∂√üe des ML-Modells ohne Registrierung und SMS</a></li>
<li><a href="../de504356/index.html">PHP 8 in acht Codeteilen</a></li>
<li><a href="../de504358/index.html">PuppetConf 2016. Kubernetes f√ºr Systemadministratoren. Teil 2</a></li>
<li><a href="../de504362/index.html">Laden Sie schnell gro√üe Datenmengen in Google Colab</a></li>
<li><a href="../de504370/index.html">Office 365- und Microsoft-Teams - Einfache Zusammenarbeit und Auswirkungen auf die Sicherheit</a></li>
<li><a href="../de504382/index.html">Wie ich (PhD Neurobiology) in 6 Monaten Data Scientist wurde</a></li>
<li><a href="../de504384/index.html">F√ºhren Sie TypeScript schrittweise in Ihr React-Projekt ein</a></li>
<li><a href="../de504386/index.html">Virtuelle Variablen der Klasse Vassbotn H.</a></li>
<li><a href="../de504392/index.html">Wie viele Programmierer und W√∂rter ben√∂tigen Sie, um einen handschriftlichen Pass zu erkennen?</a></li>
<li><a href="../de504400/index.html">Caching. Teil 2: 60 Tage vor der Ver√∂ffentlichung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>