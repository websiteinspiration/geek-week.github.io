<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍐 💪🏾 🏅 Einfache Diagrammdurchquerung: Tiefensuche und Breitensuche am Beispiel von JavaScript 🥋 🧑 ✊🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schönen Tag. 
 
 Ich präsentiere Ihnen die Übersetzung des Artikels „Algorithmen in Graphen: Sprechen wir über die Tiefensuche (DFS) und die Breitensu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Einfache Diagrammdurchquerung: Tiefensuche und Breitensuche am Beispiel von JavaScript</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504374/"><img src="https://habrastorage.org/webt/_f/kf/kl/_fkfkl3gfkmnwtes2eypbueifxe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schönen Tag. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich präsentiere Ihnen die Übersetzung des Artikels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Algorithmen in Graphen: Sprechen wir über die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiefensuche </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">(DFS) und die</font></a><font style="vertical-align: inherit;"> Breitensuche </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">(BFS)“</font></a><font style="vertical-align: inherit;"> von Try Khov.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist eine Graphenüberquerung?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einfachen Worten, eine Diagrammdurchquerung ist ein Übergang von einem ihrer Scheitelpunkte zu einem anderen auf der Suche nach den Verbindungseigenschaften dieser Scheitelpunkte. </font><font style="vertical-align: inherit;">Verknüpfungen (Linien, die Scheitelpunkte verbinden) werden als Richtungen, Pfade, Flächen oder Kanten eines Diagramms bezeichnet. </font><font style="vertical-align: inherit;">Die Eckpunkte des Graphen werden auch als Knoten bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beiden Hauptalgorithmen für das Durchlaufen von Graphen sind die Tiefensuche (DFS) und die Breitensuche (BFS). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass beide Algorithmen zum Durchlaufen des Graphen verwendet werden, weisen sie einige Unterschiede auf. </font><font style="vertical-align: inherit;">Beginnen wir mit DFS.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefensuche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die DFS folgt dem Konzept „tief gehen, mit dem Kopf voran“. Die Idee ist, dass wir uns vom Startgipfel (Punkt, Ort) in eine bestimmte Richtung (entlang eines bestimmten Pfades) bewegen, bis wir das Ende des Pfades oder Ziels (gewünschter Gipfel) erreichen. Wenn wir das Ende des Pfades erreicht haben, es aber kein Ziel ist, kehren wir zurück (bis zu verzweigten oder divergierenden Pfaden) und gehen einen anderen Weg. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns ein Beispiel an. Angenommen, wir haben einen gerichteten Graphen, der so aussieht: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir befinden uns am Punkt „s“ und müssen den Scheitelpunkt „t“ finden. Mit DFS untersuchen wir einen der möglichen Pfade, bewegen uns bis zum Ende und gehen zurück, wenn wir t nicht finden, und erkunden einen anderen Pfad. So sieht der Prozess aus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier bewegen wir uns entlang des Pfades (p1) zum nächsten Gipfel und sehen, dass dies nicht das Ende des Pfades ist. Deshalb fahren wir mit dem nächsten Gipfel fort. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das Ende von p1 erreicht, aber t nicht gefunden, also kehren wir zu s zurück und bewegen uns auf dem zweiten Pfad. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Spitze des Pfades „p2“ erreicht haben, der dem Punkt „s“ am nächsten liegt, sehen wir drei mögliche Richtungen für die weitere Bewegung. Da wir bereits den Gipfel besucht haben, der die erste Richtung krönt, bewegen wir uns entlang der zweiten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erreichten wieder das Ende des Weges, fanden aber t nicht und gingen zurück. Wir folgen dem dritten Weg und erreichen schließlich den gewünschten Gipfel "t". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert DFS. Wir bewegen uns auf einem bestimmten Weg bis zum Ende. Wenn das Ende des Pfades der gewünschte Peak ist, sind wir fertig. Wenn nicht, gehen Sie zurück und gehen Sie einen anderen Weg, bis wir alle Optionen untersucht haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir folgen diesem Algorithmus für jeden besuchten Scheitelpunkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Notwendigkeit einer wiederholten Wiederholung der Prozedur zeigt die Notwendigkeit einer Rekursion an, um den Algorithmus zu implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der JavaScript-Code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A: [B,C], B:[D,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">adj, v, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// v -   ()</span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-comment">//    ,    </span>
	<span class="hljs-keyword">if</span>(v === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">if</span>(v.visited) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	v.visited = <span class="hljs-literal">true</span>
	<span class="hljs-comment">//    (  ) v</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">if</span>(!neighbor.visited) {
			<span class="hljs-comment">//     ,      </span>
			<span class="hljs-keyword">let</span> reached = dfs(adj, neighbor, t)
			<span class="hljs-comment">//  true,  </span>
			<span class="hljs-keyword">if</span>(reached) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-comment">//   v  t  </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Mit diesem speziellen DFS-Algorithmus können Sie überprüfen, ob es möglich ist, von einem Ort zum anderen zu gelangen. </font><font style="vertical-align: inherit;">DFS kann für verschiedene Zwecke verwendet werden. </font><font style="vertical-align: inherit;">Diese Ziele bestimmen, wie der Algorithmus selbst aussehen wird. </font><font style="vertical-align: inherit;">Das allgemeine Konzept sieht jedoch genau so aus.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS-Analyse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns diesen Algorithmus analysieren. Da wir jeden „Nachbarn“ jedes Knotens umgehen und die zuvor besuchten ignorieren, haben wir eine Laufzeit von O (V + E). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine kurze Erklärung, was V + E bedeutet: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V ist die Gesamtzahl der Eckpunkte. E ist die Gesamtzahl der Flächen (Kanten). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es mag angemessener erscheinen, V * E zu verwenden, aber lassen Sie uns darüber nachdenken, was V * E bedeutet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * E bedeutet, dass wir in Bezug auf jeden Scheitelpunkt alle Flächen des Graphen untersuchen müssen, unabhängig davon, ob diese Flächen zu einem bestimmten Scheitelpunkt gehören.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andererseits bedeutet V + E, dass wir für jeden Scheitelpunkt nur die angrenzenden Kanten auswerten. </font><font style="vertical-align: inherit;">Zurück zum Beispiel: Jeder Scheitelpunkt hat eine bestimmte Anzahl von Flächen. Im schlimmsten Fall gehen wir um alle Scheitelpunkte (O (V)) herum und untersuchen alle Flächen (O (E)). </font><font style="vertical-align: inherit;">Wir haben V Eckpunkte und E Flächen, also erhalten wir V + E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir die Rekursion verwenden, um jeden Scheitelpunkt zu durchlaufen, bedeutet dies, dass ein Stapel verwendet wird (unendliche Rekursion führt zu einem Stapelüberlauffehler). </font><font style="vertical-align: inherit;">Daher ist die räumliche Komplexität O (V). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun das BFS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breite Suche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFS folgt dem Konzept "weit ausdehnen und auf die Höhe eines Vogelfluges steigen" ("weit gehen, Vogelperspektive"). Anstatt sich auf einem bestimmten Weg bis zum Ende zu bewegen, muss bei BFS jeweils ein Nachbar vorwärts bewegt werden. Dies bedeutet Folgendes: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt dem Pfad zu folgen, bedeutet BFS, die Nachbarn, die s am nächsten liegen, in einer einzigen Aktion (Schritt) zu besuchen und dann die Nachbarn der Nachbarn usw. zu besuchen, bis t erkannt wird. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/vb/ny/1uvbnygi83vt6bxqnmv1hbwuzyq.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/en/jq/tgenjqvsz1zipcv3obsicrhq78a.png"><br>
<br>
<img src="https://habrastorage.org/webt/tf/j9/on/tfj9on04zudfmelpbn00xeh_tpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie unterscheidet sich DFS von BFS? Ich denke gerne, dass die DFS voranschreitet und die BFS es nicht eilig hat, sondern alles in einem Schritt studiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann stellt sich die Frage: Woher wissen Sie, welche Nachbarn zuerst besucht werden sollten?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu können wir das Konzept "First In, First Out" (First-In-First-Out, FIFO) aus der Warteschlange verwenden. </font><font style="vertical-align: inherit;">Wir stellen zuerst den Peak in die Warteschlange, der uns am nächsten liegt, dann die nicht besuchten Nachbarn und setzen diesen Vorgang fort, bis die Warteschlange leer ist oder bis wir den gesuchten Scheitelpunkt finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A:[B,C,D], B:[E,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">adj, s, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// s -  </span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">let</span> queue = []
	<span class="hljs-comment">//  s  </span><font></font>
	queue.push(s)<font></font>
	<span class="hljs-comment">//  s         </span>
	s.visited = <span class="hljs-literal">true</span>
	<span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-comment">//   ()   </span>
		<span class="hljs-keyword">let</span> v = queue.shift()
		<span class="hljs-comment">// abj[v] -  v</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
			<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span>(!neighbor.visited) {
				<span class="hljs-comment">//    </span><font></font>
				queue.push(neighbor)<font></font>
				<span class="hljs-comment">//    </span>
				neighbor.visited = <span class="hljs-literal">true</span>
				<span class="hljs-comment">//     ,  </span>
				<span class="hljs-keyword">if</span>(neighbor === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
			}<font></font>
		} <font></font>
	}<font></font>
	<span class="hljs-comment">//  t  ,     </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFS-Analyse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass BFS langsamer ist. Wenn Sie sich die Visualisierungen jedoch genau ansehen, können Sie feststellen, dass sie dieselbe Laufzeit haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer Warteschlange wird jeder Scheitelpunkt verarbeitet, bevor ein Ziel erreicht wird. Dies bedeutet, dass BFS im schlimmsten Fall alle Scheitelpunkte und Flächen untersucht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass BFS möglicherweise langsamer erscheint, ist es tatsächlich schneller, da bei der Arbeit mit großen Diagrammen festgestellt wird, dass DFS viel Zeit damit verbringt, Pfaden zu folgen, die sich letztendlich als falsch herausstellen. BFS wird häufig verwendet, um den kürzesten Weg zwischen zwei Spitzen zu finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit ist die BFS-Laufzeit auch O (V + E), und da wir eine Warteschlange verwenden, die alle Eckpunkte enthält, ist ihre räumliche Komplexität O (V).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analogien aus dem wirklichen Leben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Analogien aus dem wirklichen Leben geben, dann stelle ich mir die Arbeit von DFS und BFS so vor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich an DFS denke, stelle ich mir eine Maus in einem Labyrinth auf der Suche nach Nahrung vor. </font><font style="vertical-align: inherit;">Um zum Ziel zu gelangen, muss die Maus viele Male in eine Sackgasse geraten, zurückkehren und sich auf andere Weise bewegen usw., bis sie einen Weg aus dem Labyrinth oder der Nahrung findet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/f3/ji/-ef3ji72zi8egr3xa26zqvt1x4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine vereinfachte Version sieht folgendermaßen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/hb/dr/kqhbdrkv6xstug0ss3l5bpr1l9k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich an BFS denke, stelle ich mir wiederum Kreise auf dem Wasser vor. </font><font style="vertical-align: inherit;">Das Fallen eines Steins ins Wasser führt zur Ausbreitung von Störungen (Kreisen) in alle Richtungen vom Zentrum aus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/lz/zp/pvlzzpnzfssjv8yzpkc49ovtsho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine vereinfachte Version sieht folgendermaßen aus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/w9/sc/s-w9scwvyp93tvyk2zwimmfc_um.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefen- und Breitensuche werden verwendet, um das Diagramm zu durchlaufen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS bewegt sich entlang der Kanten hin und her, und BFS verteilt sich auf der Suche nach einem Ziel auf die Nachbarn.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS verwendet den Stapel und BFS die Warteschlange.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Laufzeit von beiden ist O (V + E) und die räumliche Komplexität ist O (V).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Algorithmen haben eine andere Philosophie, sind aber für die Arbeit mit Grafiken gleichermaßen wichtig.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis </font><font style="vertical-align: inherit;">Per .: Ich bin kein Spezialist für Algorithmen und Datenstrukturen. Wenn daher Fehler, Ungenauigkeiten oder falsche Formulierungen festgestellt werden, schreiben Sie bitte zur Korrektur und Klärung in einen persönlichen Brief. </font><font style="vertical-align: inherit;">Ich werde dankbar sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihre Aufmerksamkeit.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504354/index.html">Reduzieren Sie die Größe des ML-Modells ohne Registrierung und SMS</a></li>
<li><a href="../de504356/index.html">PHP 8 in acht Codeteilen</a></li>
<li><a href="../de504358/index.html">PuppetConf 2016. Kubernetes für Systemadministratoren. Teil 2</a></li>
<li><a href="../de504362/index.html">Laden Sie schnell große Datenmengen in Google Colab</a></li>
<li><a href="../de504370/index.html">Office 365- und Microsoft-Teams - Einfache Zusammenarbeit und Auswirkungen auf die Sicherheit</a></li>
<li><a href="../de504382/index.html">Wie ich (PhD Neurobiology) in 6 Monaten Data Scientist wurde</a></li>
<li><a href="../de504384/index.html">Führen Sie TypeScript schrittweise in Ihr React-Projekt ein</a></li>
<li><a href="../de504386/index.html">Virtuelle Variablen der Klasse Vassbotn H.</a></li>
<li><a href="../de504392/index.html">Wie viele Programmierer und Wörter benötigen Sie, um einen handschriftlichen Pass zu erkennen?</a></li>
<li><a href="../de504400/index.html">Caching. Teil 2: 60 Tage vor der Veröffentlichung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>