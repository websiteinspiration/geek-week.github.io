<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏽 👩🏼‍🚒 🔩 本番環境でReactフックを使用するための5つのベストプラクティス 🤟🏽 👴🏻 🚝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本日の翻訳を公開している記事の著者は、commercetoolsが2019年の初めにReactフックを採用したと述べています-React 16.8.0での登場時。それ以来、同社のプログラマーはコードを常に処理し、フックに変換してきました。Reactフックを使用すると、コンポーネントの状態を使用したり...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>本番環境でReactフックを使用するための5つのベストプラクティス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/494712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本日の翻訳を公開している記事の著者は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commercetools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が2019年の初めに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reactフック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">採用した</font><font style="vertical-align: inherit;">と述べています</font><font style="vertical-align: inherit;">-React 16.8.0での登場時。</font><font style="vertical-align: inherit;">それ以来、同社のプログラマーはコードを常に処理し、フックに変換してきました。</font><font style="vertical-align: inherit;">Reactフックを使用すると、コンポーネントの状態を使用したり、クラスを使用せずに他のReact機能を使用したりできます。</font><font style="vertical-align: inherit;">フックを使用すると、機能コンポーネントを操作するときに、コンポーネントのライフサイクルのイベントに「接続」して、状態の変化に応答できます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/dp/fq/jr/dpfqjrae_1gxg8w2fhzc6izgffa.jpeg"></a><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フックの実装結果について簡単に</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言えば、フックが私たちに与えたものについて話すと、コンポーネントからロジックを抽出し、さまざまな機能の構成を容易にすることで、コードベースを簡素化するのに役立ちました。</font><font style="vertical-align: inherit;">さらに、フックの使用は私たちが多くを学んだという事実につながりました。</font><font style="vertical-align: inherit;">たとえば、既存の機能を継続的に改善して、コードをより適切に構造化する方法です。</font><font style="vertical-align: inherit;">Reactフックを引き続き使用しながら、さらに多くの興味深いことを学ぶことができると確信しています。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フック実装の強み</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックの紹介が私たちに与えたものです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの読みやすさの向上。</font><font style="vertical-align: inherit;">これは、以前よりも小さいコンポーネントツリーを使用することで可能になりました。</font><font style="vertical-align: inherit;">このようなコンポーネントツリーの作成は、レンダリングプロパティと高次コンポーネントを放棄したいという願望によって促進されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードのデバッグ機能の改善。</font><font style="vertical-align: inherit;">React開発者ツールによって提供されたコードの視覚的な表現と追加のデバッグ情報を自由に使用できました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトのモジュール性を改善する。</font><font style="vertical-align: inherit;">フックの機能的な性質により、繰り返し使用するのに適したロジックを作成および適用するプロセスが簡素化されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">責任の分離。</font><font style="vertical-align: inherit;">Reactコンポーネントはインターフェース要素の外観を担当し、フックはカプセル化されたプログラムロジックへのアクセスを提供します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、本番環境でのフックの使用に関する推奨事項を共有したいと思います。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.コンポーネントからタイムリーにフックを取得し、カスタムフックを作成する</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能コンポーネントでフックを使い始めるのは非常に簡単です。</font><font style="vertical-align: inherit;">たとえば、私たちはどこか</font></font><code>React.useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、どこ</font><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">すぐに応募</font></font><code>React.useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、仕事を続けました。</font><font style="vertical-align: inherit;">ただし、このアプローチでは、フックが提供できるすべての機会を最大限に活用することはできません。</font><font style="vertical-align: inherit;">提示</font></font><code>React.useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小型の形で</font></font><code>use&lt;StateName&gt;State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、及び</font></font><code>React.useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-の形で</font></font><code>use&lt;EffectName&gt;Effect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私たちは以下のことを達成することができました：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントは通常のフックよりも小さいです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フックはさまざまなコンポーネントで再利用できます。</font></font></li>
<li>,         React,  ,    . ,   <code>State&lt;StateName&gt;</code>   <code>State</code>.        <code>React.useState</code>,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックを取得すると、再利用可能で共有されたロジックがアプリケーションのさまざまな部分でより見やすくなります。コンポーネントコードに組み込まれたフックのみを使用する場合、類似または重複したロジックに気づくのはより困難です。結果のフックはサイズが小さく、コードのようなものをほとんど含まない場合があります</font></font><code>useToggleState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一方、などの大きなフックに</font></font><code>useProductFetcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、より多くの機能を含めることができます。これらはどちらも、Reactコンポーネントのサイズを小さくすることでコードベースを簡素化するのに役立ちました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例では、要素の選択を制御するように設計された小さなReactフックを作成します。</font><font style="vertical-align: inherit;">この機能をカプセル化することの利点は、そのようなロジックがアプリケーションで使用される頻度を理解するとすぐに明らかになります。</font><font style="vertical-align: inherit;">たとえば、リストから注文のセットを選択します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> [selected, setSelected] = React.useState()
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> select = React.useCallback(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> setSelected(<span class="hljs-comment">/** ... */</span>), [<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selected,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setSelect<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;])<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">selectedIds</span>=<span class="hljs-string">{selected}</span> <span class="hljs-attr">onSelect</span>=<span class="hljs-string">{id</span> =&gt;</span> select(id)} /&gt;</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">const</span> useSelection = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> [selected, setSelected] = React.useState()
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> select = React.useCallback(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> setSelected(<span class="hljs-comment">/** ... */</span>), [<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selected,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setSelect<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;])<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> [selected, select]<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> [selected, select] = useSelection()<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">selectedIds</span>=<span class="hljs-string">{selected}</span> <span class="hljs-attr">onSelect</span>=<span class="hljs-string">{id</span> =&gt;</span> select(id)} /&gt;</span><font></font>
}<font></font>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. React.useDebugValueの利点について</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.useDebugValue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フック</font><font style="vertical-align: inherit;">は、あまり知られていないReact機能を参照します。</font><font style="vertical-align: inherit;">このフックは、コードのデバッグ中に開発者を助けることができます;それは共有のために設計されたフックでそれを使用するのに役立ちます。</font><font style="vertical-align: inherit;">これらは、アプリケーションの多くのコンポーネントで使用されるユーザーフックです。</font><font style="vertical-align: inherit;">ただし、</font></font><code>useDebugValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込みフックはすでに標準のデバッグ値を記録しているため、すべてのユーザーフックで使用することはお勧めしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの一部の機能を有効にする必要性について決定を下すように設計されたカスタムフックを作成することを想像してください。</font><font style="vertical-align: inherit;">決定の基礎となるアプリケーション状態データは、さまざまなソースから取得できます。</font><font style="vertical-align: inherit;">これらはReactコンテキストオブジェクトに格納でき、アクセスはを通じて整理されます</font></font><code>React.useContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者のデバッグを支援するために、React開発者ツールを使用しているときに、分析されたフラグ名（</font></font><code>flagName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とフラグ値のバリアント</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">について知ることが役立つ場合があります</font></font><code>flagVariation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合、小さなフックを使用すると役立ちます</font></font><code>React.useDebugValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFeatureToggle</span>(<span class="hljs-params">flagName, flagVariation = true</span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> flags = React.useContext(FlagsContext)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> isFeatureEnabled = getIsFeatureEnabled(flagName, flagVariation)(flags)<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;React.useDebugValue({<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flagName,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flagVariation,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">isEnabled</span>: isFeatureEnabled<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;})<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> isFeatureEnabled<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、React開発者のツールを使用して、フラグ値のオプションに関する情報、フラグ名に関する情報、および関心のある機能がオンになっているかどうかを確認できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a37/b3d/78c/a37b3d78c562b28184abd5d5a8fe1c93.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.useDebugValueフックを適用した後のReact開発者ツールの</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
使用ユーザーフックがまたはのような標準フックを使用する</font></font><code>React.useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font><code>React.useRef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのようなフックは対応するステータスまたは参照オブジェクトデータをすでにログに記録して</font><font style="vertical-align: inherit;">いることに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">結果として、ここでのビュー構成の使用は</font></font><code>React.useDebugValue({ state })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特に有用</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">はありません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.フックの組み合わせと構成</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業にフックを実装し始め、コンポーネントでフックを使用するようになると、同じコンポーネントに5〜10個のフックが存在する可能性があることがすぐにわかりました。この場合、さまざまなタイプのフックが使用されました。たとえば、2〜3個のフック</font></font><code>React.useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次にフック</font></font><code>React.useContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（たとえば、アクティブユーザーに関する情報を取得するため）、フック</font></font><code>React.useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-router</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-intl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの他のライブラリからの</font><font style="vertical-align: inherit;">フックを使用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記が何度も繰り返された結果、非常に小さなコンポーネントでもそれほどコンパクトではありませんでした。これを回避するために、これらの個々のフックをユーザーフックに抽出し始めました。そのデバイスはコンポーネントまたは一部のアプリケーション機能に依存していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注文の作成を目的としたアプリケーションメカニズムを想像してみてください。</font><font style="vertical-align: inherit;">このメカニズムを開発する際、さまざまなタイプのフックだけでなく、多くのコンポーネントが使用されました。</font><font style="vertical-align: inherit;">これらのフックは、カスタムフックとして組み合わせることができ、コンポーネントの使いやすさが向上します。</font><font style="vertical-align: inherit;">これは、小さなフックのセットを1つのフックに結合する例です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OrderCreate</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderCreater,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderFetcher,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applicationContext,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToNextStep,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pendingOrder,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updatePendingChanges,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;revertPendingChanges<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;} = useOrderCreate()<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> (<span class="hljs-comment">/** ...children */</span>)<font></font>
}<font></font>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. React.useReducerとReact.useStateの比較</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>React.useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントの状態を処理するための標準的なフックとして</font><font style="vertical-align: inherit;">
しばしば</font><font style="vertical-align: inherit;">使用しました。ただし、時間の経過とともに、コンポーネントの状態は複雑になる可能性があります。これは、状態にいくつかの値が存在するなど、コンポーネントの新しい要件によって異なります。場合によっては、使用</font></font><code>React.useReducer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すると、複数の値を使用する必要がなくなり、状態を更新するロジックが簡略化されます。 HTTPリクエストを作成してレスポンスを受信するときの状態管理を想像してください。これを行うには、次のような値を処理する必要があるかもしれない</font></font><code>isLoading</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">代わりに、レデューサーを使用して状態を制御し、状態の変化を管理するためのさまざまなアクションを自由に使用できます。</font><font style="vertical-align: inherit;">このアプローチは、理想的には、インターフェースの状態をステートマシンの形で認識することを開発者に奨励します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信</font></font><code>React.useReducer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されるレデューサー</font><font style="vertical-align: inherit;">は、システムがアクションの現在の状態を受信し、次の状態を返す必要がある</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">使用されるレデューサーに似てい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">アクションには、そのタイプに関する情報と、次の状態が形成される基礎となるデータが含まれます。</font><font style="vertical-align: inherit;">以下は、特定のカウンターを制御するように設計された単純なレデューサーの例です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">switch</span> (action) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> <span class="hljs-string">'increment'</span>: <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> <span class="hljs-string">'decrement'</span>: <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> <span class="hljs-string">'reset'</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unexpected action'</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このレデューサーは単独でテストでき、次を使用してコンポーネントで使用でき</font></font><code>React.useReducer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> [count, dispatch] = React.useReducer(reducer, initialState);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{count}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch('increment')}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch('decrement')}&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch('reset')}&gt;reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、前の3つのセクションで調べた内容を適用できます</font></font><code>useCounterReducer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、すべてをに抽出できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、インターフェース要素の外観を記述するコンポーネントからアクションタイプ情報を隠すことにより、コードが改善されます。</font><font style="vertical-align: inherit;">その結果、これはコンポーネントへの実装の詳細の漏洩を防ぐのに役立ち、コードをデバッグするための追加の機会も提供します。</font><font style="vertical-align: inherit;">結果のカスタムフックとそれを使用するコンポーネントは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> CounterActionTypes = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">Increment</span>: <span class="hljs-string">'increment'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">Decrement</span>: <span class="hljs-string">'decrement'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">Reset</span>: <span class="hljs-string">'reset'</span>,<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> useCounterReducer = <span class="hljs-function">(<span class="hljs-params">initialState</span>) =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> [count, dispatch] = React.useReducer(reducer, initialState);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> increment = React.useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(CounterActionTypes.Increment));
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> decrement = React.useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(CounterActionTypes.Decrement));
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> reset = React.useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(CounterActionTypes.Reset));<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrement<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> {count, increment} = useCounterReducer(<span class="hljs-number">0</span>);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{count}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;);<font></font>
};<font></font>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.フックの段階的な実装</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見、段階的にフックを導入するという考えは完全に論理的ではないように思えるかもしれませんが、ここでは、そのように考えている人が私の推論に従うだけであることをお勧めします。時間の経過とともに、さまざまなパターンがコードベースでアプリケーションを見つけます。私たちの場合、これらのパターンには、高次コンポーネント、レンダリングプロパティ、そしてフックが含まれます。プロジェクトを新しいパターンに変換するとき、開発者はすべてのコードを即座に書き直そうとはしませんが、これは一般的にほとんど不可能です。その結果、プロジェクトをReactフックに転送するための計画を立てる必要がありますが、コードに大きな変更を加えることはできません。コードに変更を加えると、通常、サイズと複雑さが増すため、このタスクは非常に困難な場合があります。フックを導入することで、これを回避するよう努めています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのコードベースは、クラスベースのコンポーネントと機能コンポーネントを使用しています。特定の状況でどのコンポーネントが使用されたかに関係なく、Reactフックを通じてロジックを共有しようとしました。最初に、ロジックをフックに実装し（またはそれらの特定のメカニズムの既存の実装を繰り返す）、次にこれらのフックが使用される高次の小さなコンポーネントを作成します。その後、これらの高次コンポーネントを使用して、クラスベースのコンポーネントを作成します。その結果、さまざまな種類のコンポーネントで使用できるロジックが1か所に配置されます。高次コンポーネントを介してコンポーネントにフック機能を実装する例を次に示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> injectTracking = <span class="hljs-function">(<span class="hljs-params">propName = <span class="hljs-string">'tracking'</span></span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">WrappedComponent</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> WithTracking = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> tracking = useTracking();<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> trackingProp = {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[propName]: tracking,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} {<span class="hljs-attr">...trackingProp</span>} /&gt;</span></span>;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;WithTracking.displayName = wrapDisplayName(WrappedComponent, <span class="hljs-string">'withTracking'</span>);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> WithTracking;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> injectTracking;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><code>useTracking</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネント</font><font style="vertical-align: inherit;">でのフック機能の実装を示して</font><font style="vertical-align: inherit;">います</font></font><code>WrappedComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ちなみに、これにより、とりわけ、システムの古い部分でのフックの実装とテストの書き換えのタスクを分離することができました。</font><font style="vertical-align: inherit;">このアプローチでは、コードベースのすべての部分でフックを使用するためのメカニズムを自由に使用できます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactフックを使用してコードベースを改善した例をいくつか紹介します。</font><font style="vertical-align: inherit;">フックがプロジェクトにも役立つことを願っています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reactフックを使用していますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja494692/index.html">4D針による痛みのない注射</a></li>
<li><a href="../ja494700/index.html">ロシア中の人々の移動のデータセットに基づく特定の都市での感染のシナリオ</a></li>
<li><a href="../ja494702/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo. 408（2020年3月23日〜29日）</a></li>
<li><a href="../ja494704/index.html">CMI5、またはSCORM後の生活</a></li>
<li><a href="../ja494710/index.html">Webプロジェクトでの最新のグラフィック形式の使用</a></li>
<li><a href="../ja494714/index.html">可変フォントがWebプロジェクトのパフォーマンスに与えるプラスの影響について</a></li>
<li><a href="../ja494716/index.html">CSSのautoキーワードに関するすべて</a></li>
<li><a href="../ja494718/index.html">OpenStreetMap No. 504の世界からのニュース（2020年3月10日〜2020年3月3日）</a></li>
<li><a href="../ja494720/index.html">パンダによる私のチートシート</a></li>
<li><a href="../ja494722/index.html">Windows、Linux、およびmacOS用のMicrosoft PowerShell 7.1の最初のプレビューバージョン</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>