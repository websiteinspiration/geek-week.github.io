<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏾 💚 🍹 Unityでローグライクをゼロから作成：ダンジョンジェネレーター 📦 🆎 📌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今回は、ダンジョンジェネレータのアルゴリズムの実装に突入します。では前回の記事、我々は最初の部屋を作成し、そして今、私たちはダンジョンレベルの残りの部分を生成します。
 
 しかし、始める前に、前回の投稿の誤りを修正したいと思います。実際、ここ数週間、私は何か新しいことを学びました。そのため、私が行...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityでローグライクをゼロから作成：ダンジョンジェネレーター</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回は、ダンジョンジェネレータのアルゴリズムの実装に突入します。では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々は最初の部屋を作成し、そして今、私たちはダンジョンレベルの残りの部分を生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、始める前に、前回の投稿の誤りを修正したいと思います。実際、ここ数週間、私は何か新しいことを学びました。そのため、私が行った作業の一部が古くなっているので、それについてお話ししたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成したPositionクラスを覚えていますか？実際、Unityには、まったく同じ機能を実行する組み込みクラスがすでにありますが、制御が若干向上しています。宣言と処理が簡単です。このクラスはVector2Intと呼ばれます。したがって、開始する前に、MapManager.csからPositionクラスを削除し、各Position変数をVector2Int変数に置き換えます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DungeonGenerator.csスクリプトのいくつかの場所で同じことを行う必要があります。</font><font style="vertical-align: inherit;">それでは、残りのアルゴリズムに取り掛かりましょう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ7-部屋/ホールの生成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回作成したFirstRoom（）関数に小さな変更を加えます。</font><font style="vertical-align: inherit;">マップの他のすべての要素を生成してコードの束を複製する別の関数を作成する代わりに、この関数を変換して、一般化されたGenerateFeature（）に変換します。</font><font style="vertical-align: inherit;">したがって、名前をFirstRoomからGenerateFeatureに変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この関数にパラメーターを渡す必要があります。</font><font style="vertical-align: inherit;">まず第一に、あなたはそれがどのような機能を生成するかを知る必要があります-部屋や廊下。</font><em><font style="vertical-align: inherit;">タイプ</font></em><font style="vertical-align: inherit;">と呼ばれる文字列を渡すことができます</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、関数は要素の開始点、つまりどの壁からの要素であるかを知る必要があります（常に古い要素の壁から新しい要素を作成するため）。そのためには、Wall引数として渡すだけで十分です。</font><font style="vertical-align: inherit;">最後に、作成される最初の部屋には特別な特性があるため、アイテムが最初の部屋であるかどうかを示すオプションのブール変数が必要です。</font><font style="vertical-align: inherit;">デフォルトではfalseです：bool isFirst = false。</font><font style="vertical-align: inherit;">したがって、関数のタイトルは次のように変わります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについて：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいよ </font><font style="vertical-align: inherit;">次のステップは、要素の幅と高さの計算方法を変更することです。</font><font style="vertical-align: inherit;">それらを計算している間、部屋の高さと幅の最小値と最大値の間のランダムな値を取得します-これは部屋には理想的ですが、廊下では機能しません。</font><font style="vertical-align: inherit;">したがって、これまでのところ、次のようになっています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、方向に応じて、廊下の幅または高さは3の一定のサイズになります。</font><font style="vertical-align: inherit;">したがって、要素が何であるか（部屋または廊下）を確認してから、適切な計算を実行する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そう。</font><font style="vertical-align: inherit;">アイテムが部屋かどうかを確認します。</font><font style="vertical-align: inherit;">はいの場合、以前と同じように</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 行います-高さと幅の最小値と最大値の間の間隔で乱数を取得します。</font><font style="vertical-align: inherit;">しかし</font><font style="vertical-align: inherit;">、少し違うことをする必要がある場合</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">今度</font><font style="vertical-align: inherit;">は同じことをします。</font><font style="vertical-align: inherit;">廊下の向きを確認する必要があります。</font><font style="vertical-align: inherit;">幸いにも、壁を生成するときに、壁が向いている方向に関する情報を保存するので、それを使用して廊下の方向を取得します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、変数minCorridorLengthはまだ宣言していません。</font><font style="vertical-align: inherit;">変数宣言に戻って、maxCorridorLengthのすぐ上で宣言する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、条件付きswitchステートメントに戻ります。</font><font style="vertical-align: inherit;">ここで何をしているのか：</font><font style="vertical-align: inherit;">壁</font><font style="vertical-align: inherit;">の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方向</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまり、壁が見ている場所の</font><font style="vertical-align: inherit;">値を取得し</font><font style="vertical-align: inherit;">、そこから廊下が進みます。</font><font style="vertical-align: inherit;">方向は、南、北、西、東の4つの値のみを持つことができます。</font><font style="vertical-align: inherit;">南と北の場合、廊下の幅は3（2つの壁と中央の床）で、高さ（長さ）は可変です。</font><font style="vertical-align: inherit;">西と東では、すべてが逆になります。高さは常に3で、幅は可変長になります。</font><font style="vertical-align: inherit;">じゃあやってみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワオ。</font><font style="vertical-align: inherit;">そして、そこで新しいアイテムのサイズを決定しました。</font><font style="vertical-align: inherit;">次に、どこに配置するかを決める必要があります。</font><font style="vertical-align: inherit;">最初の部屋は、マップの中心を基準にしてしきい値内のランダムな場所に配置しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、他のすべての要素では、これは機能しません。それらは、要素が生成される壁のランダムな点の隣から開始する必要があります。コードを変更しましょう。まず、要素が最初の部屋かどうかを確認する必要があります。これが最初の部屋である場合は、以前と同じ方法で開始点を定義します-マップの幅と高さの半分として。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以外の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、要素が最初の部屋ではない場合、要素が生成される壁のランダムな点が取得されます。最初に、壁のサイズが3であるかどうかを確認する必要があります（これは、廊下の終点であることを意味します）。その場合、中央の点が常に選択されます。つまり、壁配列のインデックス1（3つの要素を持つ、配列にはインデックス0、1、2）。ただし、サイズが3でない場合（壁が廊下の終点ではない場合）、ポイント1と壁の長さから2を引いた値の間のランダムな点を取得します。これは、コーナーに作成された通路を避けるために必要です。つまり、たとえば、長さが6の壁では、インデックス0と5（最初と最後）を除外し、ポイント1、2、3、4からランダムなポイントを選択します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、新しい要素が作成される壁上のポイントの位置がわかりました。ただし、そこから要素の生成を開始することはできません。この方法では、既に配置されている壁によって要素がブロックされるためです。また、要素が左下隅から生成され始め、次に増分が右上に実行されるため、壁が見ている方向に応じて、開始位置をさまざまな場所に設定する必要があることに注意することも重要です。さらに、最初の列xと最初の行yは壁になります。新しい要素を壁のポイントのすぐ隣で開始すると、壁の適切な場所ではなく、部屋のコーナーで終わる廊下を作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、壁が北を向いている場合、要素はy軸に沿って北の1つの位置から始まり、x軸に沿って西のランダムな位置に、1から部屋2の幅の範囲で開始する必要があります。</font><font style="vertical-align: inherit;">南方向では、x軸は同じように機能しますが、y軸上の開始位置は、壁上の点の位置から部屋の高さを引いたものです。</font><font style="vertical-align: inherit;">西側と東側の壁は同じロジックに従いますが、軸が逆になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これをすべて行う前に、壁のポイントの位置をVector2Int変数に保存して、後で操作できるようにする必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すごい。</font><font style="vertical-align: inherit;">そうしよう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、サイズと位置を含む要素を生成しました。次のステップは、要素をマップ上に配置することです。</font><font style="vertical-align: inherit;">ただし、最初に、この要素のこの位置にマップ上のスペースが本当にあるかどうかを確認する必要があります。</font><font style="vertical-align: inherit;">ここでは、CheckIfHasSpace（）関数を呼び出すだけです。</font><font style="vertical-align: inherit;">まだ実装していないため、赤で強調表示されます。</font><font style="vertical-align: inherit;">ここで、GenerateFeature（）関数で実行する必要がある作業が完了したら、すぐにこれを行います。</font><font style="vertical-align: inherit;">したがって、赤い下線を無視して続行します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパートでは、壁が作成されます。</font><font style="vertical-align: inherit;">2番目の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループのフラグメントを除いて、それに触れるまで</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿を書いているときに、これらのif-else構文が完全に間違っていることに気付きました。たとえば、それらの一部の壁は長さ1を受け取ります。これは、位置が北壁などに追加されるときに、東壁とのコーナーにある場合、必要に応じて東壁に追加されないために発生します。これにより、生成アルゴリズムに厄介なバグが発生しました。それらを排除しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらを修正することは非常に簡単です。</font><font style="vertical-align: inherit;">位置がすべての</font><em><font style="vertical-align: inherit;">if</font></em><font style="vertical-align: inherit;">構成を通過し、</font><em><font style="vertical-align: inherit;">trueが</font></em><font style="vertical-align: inherit;">返された場合に最初で停止しないように、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを削除するだけで十分</font><em><font style="vertical-align: inherit;">です</font></em><font style="vertical-align: inherit;">。次に、最後の</font><em><font style="vertical-align: inherit;">else</font></em><font style="vertical-align: inherit;">（</font><em><font style="vertical-align: inherit;">else if</font></em><font style="vertical-align: inherit;">ではない</font><em><font style="vertical-align: inherit;">もの</font></em><font style="vertical-align: inherit;">）が</font><em><font style="vertical-align: inherit;">ifに</font></em><font style="vertical-align: inherit;">変更され</font><em><font style="vertical-align: inherit;">ます</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、位置がすでに壁として追加されていることを確認し、追加されていない場合は、床として追加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すばらしい、これでほぼ完了です。</font><font style="vertical-align: inherit;">これで、完全に新しい要素が適切な場所に作成されましたが、最初の部屋と同じです。完全に壁で囲まれています。</font><font style="vertical-align: inherit;">これは、プレイヤーがこの新しい場所に到達できないことを意味します。</font><font style="vertical-align: inherit;">つまり、壁のポイント（記憶するように、Vector2Int型の変数に格納されています）と、Floorの新しい要素の壁の対応するポイントを変換する必要があります。</font><font style="vertical-align: inherit;">ただし、要素が最初の部屋でない場合のみ。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、新しいアイテムが最初の部屋かどうかを確認します。</font><font style="vertical-align: inherit;">そうでない場合は、壁の最後の位置を床に変換し、新しい要素のどのタイルが床に変わるかを確認するために、壁が見ている方向を確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GenerateFeature（）関数の最後の部分に達しました。</font><font style="vertical-align: inherit;">関数が作成する要素に関する情報を追加する行がすでにあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、何かを変更する必要があります。</font><font style="vertical-align: inherit;">まず、要素のタイプは常に部屋と同じではありません。</font><font style="vertical-align: inherit;">幸い、必要な変数はパラメーターとして関数に渡されます。つまり、文字列型です。</font><font style="vertical-align: inherit;">ここで「部屋」をタイプに置き換えてみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い。</font><font style="vertical-align: inherit;">ここで、ゲームのすべての要素を生成するアルゴリズムが正しく機能するために、ここに新しいデータを追加する必要があります。</font><font style="vertical-align: inherit;">つまり、作成されたアイテムの数と作成されたすべてのアイテムのリストをカウントするintです。</font><font style="vertical-align: inherit;">すべての変数を宣言し、countFeaturesという名前のintとallFeaturesという名前の要素のListを宣言する場所に移動します。</font><font style="vertical-align: inherit;">すべての要素のリストはパブリックである必要があり、intカウンターはプライベートにすることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、GenerateFeature（）関数に戻り、最後に数行を追加します。countFeatures変数をインクリメントし、allFeaturesリストに新しい要素を追加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、GenerateFeature（）はほぼ完成です。</font><font style="vertical-align: inherit;">後で空のCheckIfHasSpace関数に入力するためにそれに戻る必要がありますが、最初にそれを作成する必要があります。</font><font style="vertical-align: inherit;">それが今から行うことです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ8-場所があるかどうかを確認する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、GenerateFeature（）関数が完了した直後に新しい関数を作成します。彼女は2つの引数が必要です。要素が始まる位置と、要素が終わる位置です。 2つのVector2Int変数を使用できます。関数はブール値を返して、</font><font style="vertical-align: inherit;">スペースをチェックする</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">使用できるように</font><font style="vertical-align: inherit;">する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今のところ何も返されていないため、赤の下線が引かれています。すぐに修正しますが、現時点では注意を払いません。この関数では、要素の最初と最後の間のすべての位置をループし、MapManager.mapの現在の位置がnullか、何かがすでに存在するかどうかを確認します。そこに何かがある場合は、関数を停止してfalseを返します。そうでない場合は、続行します。関数が満たされた場所を満たさずにループの終わりに達した場合、trueを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、位置がnullかどうかを確認する前に、位置がマップ内にあるかどうかを確認するための線が必要です。それ以外の場合は、配列インデックスエラーとゲームクラッシュが発生する可能性があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいね。</font><font style="vertical-align: inherit;">ここで、この関数をGenerateFeature（）関数内に挿入する場所に戻ります。</font><font style="vertical-align: inherit;">必要な引数を渡さないため、この呼び出しを修正する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは</font><font style="vertical-align: inherit;">、要素に十分なスペースがあるかどうかを確認</font><font style="vertical-align: inherit;">する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifステートメント</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を挿入</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">結果がfalseの場合、新しい要素をMapManager.mapに挿入せずに関数を終了します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な引数、つまり2つのVector2Int変数を渡す必要があります。</font><font style="vertical-align: inherit;">1つ目は、すべてが単純です。これは、要素の始点のx座標とy座標を持つ位置です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目は難しいですが、それほどではありません。</font><font style="vertical-align: inherit;">これは、開始点にyの高さ、xの幅を加えたもので、両方から1を引いたものです（開始点がすでに考慮されているため）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップに進みましょう-GenerateFeature（）関数を呼び出すアルゴリズムを作成します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ9-生成された要素を呼び出す</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の前の部分で作成したGenerateDungeon（）関数に戻ります。</font><font style="vertical-align: inherit;">これで次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数の名前を変更したため、FirstRoom（）の呼び出しには赤の下線が引かれています。</font><font style="vertical-align: inherit;">それでは、最初の部屋の世代と呼びましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部屋は常にRoom、新しいWall（）になるため、タイプとして「Room」を必要な引数として渡しました。最初の部屋は他から作成されないため、nullを渡すだけで、これは正常です。新しいWall（）の代わりに</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用でき</font><em><font style="vertical-align: inherit;">ますが</font></em><font style="vertical-align: inherit;">、これは個人の好みの問題です。最後の引数は、新しい要素が最初の部屋かどうかを決定するため、この場合は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を渡し</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、要点です。 500回実行されるforループを使用します-はい、要素を500回追加しようとします。ただし、作成された要素の数（countFeatures変数）が指定された要素の最大数（maxFeatures変数）と等しい場合は、このサイクルを中断します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このループの最初のステップは、新しい要素が作成される要素を宣言することです。</font><font style="vertical-align: inherit;">1つの要素（最初の部屋）のみを作成した場合、それは元の要素になります。</font><font style="vertical-align: inherit;">それ以外の場合は、既に作成されている要素の1つをランダムに選択します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この要素のどの壁を使用して新しい要素を作成するかを選択します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このChoseWall（）関数はまだありません。</font><font style="vertical-align: inherit;">さっそく書いてみましょう。</font><font style="vertical-align: inherit;">関数の最後に移動して作成します。</font><font style="vertical-align: inherit;">壁を返し、要素を引数として使用して、関数がこの要素の壁を選択できるようにする必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CheckIfHasSpace（）関数とDrawMap（）関数の間に作成しました。</font><font style="vertical-align: inherit;">Unityと共にインストールされるVisual Studioで作業している場合は、左側の-/ +フィールドを使用して、コードの一部を折りたたんだり展開したりして、作業を簡略化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数では、要素がまだ作成されていない壁を見つけます。</font><font style="vertical-align: inherit;">他の要素が既にアタッチされている1つ以上の壁を持つ要素を取得することがあるので、ランダムな壁が空いていないかどうかを何度も確認する必要があります。</font><font style="vertical-align: inherit;">これを行うには、forループを10回繰り返します。これらの10回の後にフリーウォールが見つからない場合、関数はnullを返します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、GenerateDungeon（）関数に戻り、元の要素をパラメーターとしてChoseWall（）関数に渡します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この行</font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、壁検索関数がfalseを返した場合、元の要素は新しい要素を生成できないため、関数は</font><font style="vertical-align: inherit;">サイクル</font><font style="vertical-align: inherit;">を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継続し</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。つまり、新しい要素を作成できず、サイクルの次の反復に進みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、次のアイテムのタイプを選択する必要があります。</font><font style="vertical-align: inherit;">ソース要素が部屋の場合、次の要素は廊下でなければなりません（部屋が廊下のない別の部屋に直接つながることは望ましくありません）。</font><font style="vertical-align: inherit;">ただし、これが廊下である場合は、次の廊下または部屋が次にある可能性を作成する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいよ </font><font style="vertical-align: inherit;">次に、GenerateFeature（）関数を呼び出して、壁と型をパラメーターとして渡します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、Unityインスペクターに移動し、GameManagerオブジェクトを選択して、値を次のように変更します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再生ボタンをクリックすると、結果が表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が言ったように、これは最高のダンジョンではありません。</font><font style="vertical-align: inherit;">行き止まりがたくさんありました。</font><font style="vertical-align: inherit;">しかし、それは完全に機能し、あなたが他に接続されていない部屋がないことを保証します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
楽しんでいただけたでしょうか！</font><font style="vertical-align: inherit;">次の投稿では、ダンジョンを移動するプレーヤーを作成し、マップをASCIIからスプライトに変換します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495570/index.html">PVS-Studioでのウサギの穴の深さまたはC ++インタビュー</a></li>
<li><a href="../ja495572/index.html">ハードウェアエコシステムコミュニティがエレクトロニクス業界のすべての人を対象としたポッドキャストを開始</a></li>
<li><a href="../ja495574/index.html">訪問者の検出とカウント：クラウドと カメラカウンター</a></li>
<li><a href="../ja495576/index.html">micropythonを搭載したesp8266 MKの自走式プラットフォーム</a></li>
<li><a href="../ja495580/index.html">Cucumber JVM-BDDだけではない</a></li>
<li><a href="../ja495592/index.html">辞書の使い方（だけでなく）</a></li>
<li><a href="../ja495594/index.html">ソフトウェアの収益化を開始：ミニデジタルビジネスの作成</a></li>
<li><a href="../ja495596/index.html">オフィスでの遠隔作業。RDP、Port Knocking、Mikrotik：シンプルで安全</a></li>
<li><a href="../ja495602/index.html">コアデータから始めましょう！簡単な言葉では難しい[パート2]</a></li>
<li><a href="../ja495604/index.html">Symfony 4 + Twigでの一時的なローカリゼーション</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>