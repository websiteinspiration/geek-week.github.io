<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏽 👨🏿‍🔬 ➗ Número máximo de valores em enumeração, parte II 🗓️ 🍻 🛀🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primeira parte, teórica  | Parte dois, prática
 
 
 Continuamos a procurar o número máximo possível de valores na enumeração. 
 Desta vez, focaremos o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Número máximo de valores em enumeração, parte II</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501870/"><nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeira parte, teórica</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;|&nbsp;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte dois, prática</font></font></b></nobr><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuamos a procurar o número máximo possível de valores na enumeração. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desta vez, focaremos o lado prático da questão e veremos como o IDE, o compilador e a JVM responderão às nossas conquistas.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></h1><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ferramentas </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método de extração </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantes dinâmicas do arquivo de classes </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dificuldades repentinas </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futuro brilhante </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Teste </font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inseguro </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Javac e Switch </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Conclusão do </font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desempenho </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Recursos adicionais</font></a></font><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<a name="Tools"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ferramentas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javac cuida de nós: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corta caracteres que não gosta nos identificadores</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e proíbe herdar </font><font style="vertical-align: inherit;">deles </font></font><code>java.lang.Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; portanto, para experimentos, precisamos de outras ferramentas. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Testaremos</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
hipóteses usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asmtools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - montador e desmontador para JVM e geraremos arquivos de classe em escala industrial - usando a biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar o entendimento, a essência do que está acontecendo será duplicada em um pseudocódigo do tipo java.</font></font><br>
<br>
<a name="Javac"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ponto de partida, é lógico obter o melhor resultado possível de realizar sem truques, com a ajuda de apenas um </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tudo é simples aqui - criamos o arquivo de origem com a enumeração e adicionamos elementos até o javac se recusar a compilá- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com a maldição “código muito grande”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muito tempo, desde o Java 1.7, esse número foi mantido no nível de 2_746 elementos. </font><font style="vertical-align: inherit;">Mas em algum lugar após o Java 11, houve alterações no algoritmo para armazenar valores no pool constante e o número máximo diminuiu para 2_743. </font><font style="vertical-align: inherit;">Sim, sim, apenas por alterar a ordem dos elementos no conjunto de constantes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos nos concentrar no melhor dos valores.</font></font><br>
<br>
<a name="ExtractMethod"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método de extração</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como um dos fatores limitantes está relacionado ao tamanho do bytecode no bloco de inicialização estática, tentaremos torná-lo o mais fácil possível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de como fica no exemplo da enumeração </font></font><code>FizzBuzz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da primeira parte. </font><font style="vertical-align: inherit;">Os comentários fornecem instruções de montagem apropriadas.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estático {}</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//  0: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: ldc           #22                 // String Fizz</span>
    <span class="hljs-comment">//  6: iconst_0</span>
    <span class="hljs-comment">//  7: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 10: putstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    Buzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 13: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 16: dup</span>
    <span class="hljs-comment">// 17: ldc           #28                 // String Buzz</span>
    <span class="hljs-comment">// 19: iconst_1</span>
    <span class="hljs-comment">// 20: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 23: putstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    FizzBuzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 26: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 29: dup</span>
    <span class="hljs-comment">// 30: ldc           #32                 // String FizzBuzz</span>
    <span class="hljs-comment">// 32: iconst_2</span>
    <span class="hljs-comment">// 33: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 36: putstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span><font></font>
<font></font>
    $VALUES = <span class="hljs-keyword">new</span> FizzBuzz[] {
    <span class="hljs-comment">// 39: iconst_3</span>
    <span class="hljs-comment">// 40: anewarray     #2                  // class FizzBuzz</span><font></font>
        Fizz, <font></font>
    <span class="hljs-comment">// 43: dup</span>
    <span class="hljs-comment">// 44: iconst_0</span>
    <span class="hljs-comment">// 45: getstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    <span class="hljs-comment">// 48: aastore</span><font></font>
        Buzz, <font></font>
    <span class="hljs-comment">// 49: dup</span>
    <span class="hljs-comment">// 50: iconst_1</span>
    <span class="hljs-comment">// 51: getstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 54: aastore</span><font></font>
        FizzBuzz<font></font>
    <span class="hljs-comment">// 55: dup</span>
    <span class="hljs-comment">// 56: iconst_2</span>
    <span class="hljs-comment">// 57: getstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 60: aastore</span><font></font>
    };<font></font>
    <span class="hljs-comment">// 61: putstatic     #1                  // Field $VALUES:[LFizzBuzz;</span>
    <span class="hljs-comment">// 64: return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que vem à mente é colocar a criação e o preenchimento da matriz </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um método separado.</font></font><br>
<br>
<pre><code class="java hljs">$VALUES = createValues();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desenvolvendo essa idéia, a criação de instâncias de elementos de enumeração pode ser transferida para o mesmo método:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    FizzBuzz[] localValues = createValues();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
    Fizz = localValues[index++];<font></font>
    Buzz = localValues[index++];<font></font>
    FizzBuzz = localValues[index++];<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>)<font></font>
    };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Já é melhor, mas cada captura de um elemento da matriz e o incremento subsequente do índice custam 6 bytes, o que é muito caro para nós. </font><font style="vertical-align: inherit;">Coloque-os em um método separado.</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> valueIndex;<font></font>
<font></font>
<span class="hljs-keyword">static</span>  {<font></font>
    $VALUES = createValues();<font></font>
<font></font>
    valueIndex = <span class="hljs-number">0</span>;<font></font>
    Fizz = nextValue();<font></font>
    Buzz = nextValue();<font></font>
    FizzBuzz = nextValue();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">nextValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> $VALUES[valueIndex++];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
São </font><font style="vertical-align: inherit;">necessários 11 bytes para </font><font style="vertical-align: inherit;">inicializar </font><font style="vertical-align: inherit;">e retornar do bloco de inicialização estático </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e 65_524 bytes restantes para inicializar os campos. </font><font style="vertical-align: inherit;">A inicialização de cada campo requer 6 bytes, o que nos permite criar uma enumeração de 10_920 elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quase quatro vezes o crescimento em comparação com o javac deve ser definitivamente comemorado pela geração de código! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código-fonte do gerador: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnumGenerator.java</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Exemplo de classe </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">gerada</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnum.class</font></font></a><br>
<a name="ConDy"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantes dinâmicas de arquivo de classe</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É hora de lembrar sobre o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 309</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e suas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constantes dinâmicas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> misteriosas </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A essência da inovação em poucas palavras: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para tipos já existentes suportados por um conjunto de constantes, foi adicionado outro </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ao carregar uma classe, o tipo dessa constante é conhecido, mas seu valor é desconhecido. O primeiro carregamento de uma constante leva a uma chamada para o método de auto-inicialização especificado em sua declaração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado desse método se torna um valor constante. Não há maneiras de alterar o valor associado a uma constante já inicializada. O que é bastante lógico para uma constante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você também pensou em Singleton, esqueça-o imediatamente. </font><font style="vertical-align: inherit;">A especificação enfatiza separadamente que não há garantia de segurança do encadeamento nesse caso, e o método de inicialização no código multithread pode ser chamado mais de uma vez. </font><font style="vertical-align: inherit;">É garantido apenas que, no caso de várias chamadas para o método de autoinicialização para a mesma constante, a JVM jogue uma moeda e selecione um dos valores calculados para a função do valor constante, e os outros serão sacrificados para o coletor de lixo.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportamental, uma constante CONSTANT_Dynamic é resolvida executando seu método de autoinicialização nos seguintes parâmetros: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um objeto de pesquisa local,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a String representando o componente de nome da constante,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a classe que representa o tipo constante esperado e</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quaisquer argumentos de auto-inicialização restantes.</font></font></li>
</ol><br>
As with invokedynamic, multiple threads can race to resolve, but a unique winner will be chosen and any other contending answers discarded.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para carregar os valores do conjunto de constantes na bytecode, os comandos são fornecidos </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ldc_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>ldc2_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De interesse para nós é o primeiro deles - </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diferentemente dos outros, ele é capaz de carregar valores apenas dos primeiros 255 slots do pool constante, mas leva 1 byte a menos no bytecode. Tudo isso nos permite economizar até 255 bytes e um </font></font><code>255 + ((65_524 - (255 * 5)) / 6) = 10_963</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento na enumeração. Desta vez, o crescimento não é tão impressionante, mas ainda está lá. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Armado com esse conhecimento, vamos começar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No bloco de inicialização estática, em vez de chamadas de método, </font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora carregaremos o valor da constante dinâmica. O valor do </font></font><code>ordinal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">índice ordinal do elemento de enumeração será passado explicitamente, eliminando o campo </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o método de fábrica</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e dúvidas sobre a segurança do encadeamento de nossa implementação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como método de inicialização, usaremos um subtipo especial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que imita o comportamento de um operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em Java. </font><font style="vertical-align: inherit;">A biblioteca padrão fornece um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método MethodHandles.Lookup :: findConstructor ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para obter esse identificador de método </font><font style="vertical-align: inherit;">, mas, no nosso caso, a JVM cuidará da construção do identificador de método necessário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar o construtor de nossa enumeração como um método de inicialização, ele precisará ser ligeiramente modificado alterando a assinatura. </font><font style="vertical-align: inherit;">Os parâmetros necessários para o método de auto-inicialização serão adicionados ao construtor tradicional do elemento de enumeração de nome e número de série:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; enumClass, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
    <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob a forma de pseudo-código, a inicialização terá a seguinte aparência:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);<font></font>
    Buzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);<font></font>
    FizzBuzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);<font></font>
<font></font>
    $VALUES = createValues();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo acima, as instruções são </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">designadas como chamadas de método </font></font><code>JVM_ldc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; no bytecode, em seu lugar, estarão as instruções da JVM correspondentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como agora temos uma constante separada para cada elemento da enumeração, a criação e o preenchimento da matriz </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também podem ser implementados por meio de uma constante dinâmica. </font><font style="vertical-align: inherit;">O método de inicialização é muito simples:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; clazz, FizzBuzz... elements) {
    <span class="hljs-keyword">return</span> elements;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo o truque na lista de parâmetros estáticos para essa constante dinâmica, lá vamos listar todos os elementos que queremos colocar </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métodos de inicialização:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1: # 54 REF_invokeStatic FizzBuzz.createValues: (Ljava / lang / invoke / MethodHandles $ Lookup; Ljava / lang / String; Ljava / lang / Class; [LFizzBuzz;) [LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Argumentos do método:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 1 # 0: Fizz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 2 # 0: Buzz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 3 # 0: FizzBuzz: LFizzBuzz;</font></font><font></font>
</pre><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A JVM estraga a matriz desses parâmetros estáticos e a transmite ao nosso método de autoinicialização como um parâmetro vararg </font></font><code>elements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O número máximo de parâmetros estáticos é tradicional 65_535, portanto, é garantido que seja suficiente para todos os elementos da enumeração, não importa quantos existam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para transferências com um grande número de elementos, essa alteração reduzirá o tamanho do arquivo de classe resultante e, no caso em que, devido ao grande número de elementos, o método </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisou ser dividido em várias partes, ele também salva os slots no pool constante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E no final, é simplesmente lindo.</font></font><br>
<br>
<a name="Surprise"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dificuldades repentinas</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que superamos heroicamente gerando classes manualmente. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bibliotecas de alto nível fornecem uma interface conveniente em troca de alguma restrição à liberdade de ação. </font><font style="vertical-align: inherit;">A biblioteca ASM que usamos para gerar arquivos de classe não é exceção. </font><font style="vertical-align: inherit;">Ele não fornece mecanismos para controlar diretamente o conteúdo do pool de constantes. </font><font style="vertical-align: inherit;">Isso geralmente não é muito importante, mas não no nosso caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você se lembra, precisamos dos primeiros 255 elementos do pool constante para salvar bytes preciosos no bloco de inicialização estática. </font><font style="vertical-align: inherit;">Quando as constantes dinâmicas são adicionadas de maneira padrão, elas serão localizadas em índices aleatórios e misturadas com outros elementos que não são tão críticos para nós. </font><font style="vertical-align: inherit;">Isso nos impedirá de alcançar o máximo.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmento de um conjunto de constantes formado da maneira tradicional</font></font></b>
                        <div class="spoiler_text"><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piscina constante:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   # 1 = Utf8 FizzBuzz</font></font><font></font>
   #2 = Class              #1             // FizzBuzz<font></font>
   #3 = Utf8               java/lang/Enum<font></font>
   #4 = Class              #3             // java/lang/Enum<font></font>
   #5 = Utf8               $VALUES<font></font>
   #6 = Utf8               [LFizzBuzz;<font></font>
   #7 = Utf8               valueIndex<font></font>
   #8 = Utf8               I<font></font>
   #9 = Utf8               Fizz<font></font>
  #10 = Utf8               LFizzBuzz;<font></font>
  #11 = Utf8               Buzz<font></font>
  #12 = Utf8               FizzBuzz<font></font>
  #13 = Utf8               values<font></font>
  #14 = Utf8               ()[LFizzBuzz;<font></font>
  #15 = NameAndType        #5:#6          // $VALUES:[LFizzBuzz;<font></font>
  #16 = Fieldref           #2.#15         // FizzBuzz.$VALUES:[LFizzBuzz;<font></font>
  #17 = Class              #6             // "[LFizzBuzz;"<font></font>
  #18 = Utf8               clone<font></font>
  #19 = Utf8               ()Ljava/lang/Object;<font></font>
  #20 = NameAndType        #18:#19        // clone:()Ljava/lang/Object;<font></font>
  #21 = Methodref          #17.#20        // "[LFizzBuzz;".clone:()Ljava/lang/Object;<font></font>
  ...<font></font>
  #40 = NameAndType        #9:#10         // Fizz:LFizzBuzz;<font></font>
  #41 = Dynamic            #0:#40         // #0:Fizz:LFizzBuzz;<font></font>
  #42 = Fieldref           #2.#40         // FizzBuzz.Fizz:LFizzBuzz;<font></font>
  #43 = NameAndType        #11:#10        // Buzz:LFizzBuzz;<font></font>
  #44 = Dynamic            #0:#43         // #0:Buzz:LFizzBuzz;<font></font>
  #45 = Fieldref           #2.#43         // FizzBuzz.Buzz:LFizzBuzz;<font></font>
  #46 = NameAndType        #12:#10        // FizzBuzz:LFizzBuzz;<font></font>
  #47 = Dynamic            #0:#46         // #0:FizzBuzz:LFizzBuzz;<font></font>
  #48 = Fieldref           #2.#46         // FizzBuzz.FizzBuzz:LFizzBuzz;<font></font>
</pre><br>
</blockquote><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente, existe uma solução alternativa - ao criar uma classe, você pode especificar uma classe de amostra da qual um conjunto de constantes e um atributo com uma descrição dos métodos de autoinicialização serão copiados. </font><font style="vertical-align: inherit;">Só agora temos que gerá-lo manualmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, não é tão difícil quanto parece à primeira vista. </font><font style="vertical-align: inherit;">O formato do arquivo de classe é bastante simples e sua geração manual é um processo um tanto tedioso, mas nem um pouco complicado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A coisa mais importante aqui é um plano claro. </font><font style="vertical-align: inherit;">Para enumerar os </font></font><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos que precisamos:</font></font><br>
<br>
<ul>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nossas constantes dinâmicas</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo </font></font><code>CONSTANT_NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- pares de links para o nome do elemento de enumeração e seu tipo. </font><font style="vertical-align: inherit;">O tipo será o mesmo para todos, este é o tipo de classe da nossa enumeração.</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type records </font></font><code>CONSTANT_Utf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- diretamente os nomes dos elementos de enumeração</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros do tipo </font></font><code>CONSTANT_Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- números de série dos elementos de enumeração passados ​​para o construtor como um valor de parâmetro</font></font><code>ordinal</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nomes das classes atual e base, atributos, assinaturas de método e outros detalhes de implementação chatos. </font><font style="vertical-align: inherit;">Os interessados ​​podem procurar o código fonte do gerador.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem muitos elementos constituintes no conjunto de constantes que se referem a outros elementos do conjunto por índice; portanto, todos os índices que precisamos devem ser calculados com antecedência, </font></font><code>elementNames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é uma lista dos nomes dos elementos de nossa enumeração:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> elementCount = elementNames.size();<font></font>
<font></font>
<span class="hljs-keyword">int</span> baseConDy = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> baseNameAndType = baseConDy + elementCount;
<span class="hljs-keyword">int</span> baseUtf8 = baseNameAndType + elementCount;
<span class="hljs-keyword">int</span> baseInteger = baseUtf8 + elementCount;
<span class="hljs-keyword">int</span> indexThisClass = baseInteger + elementCount;
<span class="hljs-keyword">int</span> indexThisClassUtf8 = indexThisClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClass = indexThisClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClassUtf8 = indexSuperClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodsUtf8 = indexSuperClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexConDyDescriptorUtf8 = indexBootstrapMethodsUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodHandle = indexConDyDescriptorUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodRef = indexBootstrapMethodHandle + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodNameAndType = indexBootstrapMethodRef + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodName = indexBootstrapMethodNameAndType + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodDescriptor = indexBootstrapMethodName + <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> constantPoolSize = indexBootstrapMethodDescriptor + <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois disso, começamos a escrever. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No início - a assinatura do arquivo de classe, os quatro bytes conhecidos por todos </font></font><nobr><code>0xCA 0xFE 0xBA 0xBE</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a versão do formato do arquivo:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Class file header</span><font></font>
u4(CLASS_FILE_SIGNATURE);<font></font>
u4(version);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então - um conjunto de constantes:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool de constantes</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">// Constant pool</span><font></font>
u2(constantPoolSize);<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Dynamic</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_Dynamic, i, baseNameAndType + i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_NameAndType</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_NameAndType, baseUtf8 + i, indexConDyDescriptorUtf8);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Utf8</span>
<span class="hljs-comment">//noinspection ForLoopReplaceableByForEach</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Utf8);<font></font>
    utf8(elementNames.get(i));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Integer</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Integer);<font></font>
    u4(i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ThisClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexThisClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// ThisClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(enumClassName);<font></font>
<font></font>
<span class="hljs-comment">// SuperClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexSuperClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// SuperClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(JAVA_LANG_ENUM);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodsUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(ATTRIBUTE_NAME_BOOTSTRAP_METHODS);<font></font>
<font></font>
<span class="hljs-comment">// ConDyDescriptorUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(binaryEnumClassName);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodHandle</span><font></font>
u1(CONSTANT_MethodHandle);<font></font>
u1(REF_newInvokeSpecial);<font></font>
u2(indexBootstrapMethodRef);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodRef</span><font></font>
u1u2u2(CONSTANT_Methodref, indexThisClass, indexBootstrapMethodNameAndType);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodNameAndType</span><font></font>
u1u2u2(CONSTANT_NameAndType, indexBootstrapMethodName, indexBootstrapMethodDescriptor);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodName</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_NAME);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodDescriptor</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_DESCRIPTOR);<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após a constante piscina falando sobre modificadores de acesso e bandeiras ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>enun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e assim por diante), o nome da classe e seu ancestral:</font></font><br>
<br>
<pre><code class="java hljs">u2(access);<font></font>
u2(indexThisClass);<font></font>
u2(indexSuperClass);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe fictícia que geramos não terá interfaces, campos ou métodos, mas haverá um atributo com uma descrição dos métodos de inicialização:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Interfaces count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Fields count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Methods count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Attributes count</span>
u2(<span class="hljs-number">1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui está o corpo do próprio atributo:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// BootstrapMethods attribute</span><font></font>
u2(indexBootstrapMethodsUtf8);<font></font>
<span class="hljs-comment">// BootstrapMethods attribute size</span>
u4(<span class="hljs-number">2</span> <span class="hljs-comment">/* num_bootstrap_methods */</span> + <span class="hljs-number">6</span> * elementCount);
<span class="hljs-comment">// Bootstrap method count</span><font></font>
u2(elementCount);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {
    <span class="hljs-comment">// bootstrap_method_ref</span><font></font>
    u2(indexBootstrapMethodHandle);<font></font>
    <span class="hljs-comment">// num_bootstrap_arguments</span>
    u2(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// bootstrap_arguments[1]</span><font></font>
    u2(baseInteger + i);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo, a classe é formada. </font><font style="vertical-align: inherit;">Pegamos esses bytes e criamos a partir deles </font></font><code>ClassReader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassReader <span class="hljs-title">getBootstrapClassReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String enumClassName, List&lt;String&gt; elementNames)</span> </span>{
    <span class="hljs-keyword">byte</span>[] bootstrapClassBytes = <span class="hljs-keyword">new</span> ConDyBootstrapClassGenerator(<font></font>
        version,<font></font>
        access,<font></font>
        enumClassName,<font></font>
        elementNames<font></font>
    )<font></font>
    .generate();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (bootstrapClassBytes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassReader(bootstrapClassBytes);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não foi tão difícil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código-fonte do gerador: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConDyBootstrapClassGenerator.java</font></font></a><br>
<a name="Future"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futuro brilhante</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discordamos brevemente de nossas listas:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoverConstantValueAttribute</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING = <span class="hljs-string">"Habrahabr, world!"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object OBJECT = <span class="hljs-keyword">new</span> Object();<font></font>
<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No bloco de inicialização estática dessa classe, de repente haverá apenas uma operação de gravação, no campo </font></font><code>OBJECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">static</span> {<font></font>
    OBJECT = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">//  0: new           #2                  // class java/lang/Object</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
    <span class="hljs-comment">//  7: putstatic     #7                  // Field OBJECT:Ljava/lang/Object;</span>
    <span class="hljs-comment">// 10: return</span><font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas que tal </font></font><code>STRING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A equipe ajudará a esclarecer esse enigma </font></font><nobr><code>javap -c -s -p -v DiscoverConstantValueAttribute.class</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eis o fragmento que nos interessa:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String STRING;<font></font>
  descriptor: Ljava/lang/String;<font></font>
  flags: (<span class="hljs-number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL<font></font>
  ConstantValue: String Habrahabr, world!<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O valor do campo final estático foi movido do bloco de inicialização para um atributo separado </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aqui está o que eles escrevem sobre esse atributo na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 §4.7.2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um atributo ConstantValue representa o valor de uma expressão constante (JLS §15.28) e é usado da seguinte maneira:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o sinalizador ACC_STATIC no item access_flags da estrutura field_info estiver definido, o campo representado pela estrutura field_info receberá o valor representado por seu atributo ConstantValue como parte da inicialização da classe ou interface que declara o campo (§5.5). </font><font style="vertical-align: inherit;">Isso ocorre antes da chamada do método de inicialização de classe ou interface dessa classe ou interface (§2.9.2).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caso contrário, a Java Virtual Machine deve ignorar silenciosamente o atributo.</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se esse atributo ocorrer ao mesmo tempo </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(embora o último não esteja explicitamente explicitado aqui) em um campo, esse campo será inicializado com o valor desse atributo. </font><font style="vertical-align: inherit;">E isso acontece mesmo antes de o método de inicialização estática ser chamado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seria tentador usar esse atributo para inicializar os elementos da enumeração; em nosso capítulo anterior, havia apenas constantes, ainda que dinâmicas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E não somos os primeiros a pensar nessa direção, há uma menção no JEP 309 </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infelizmente, essa menção está no capítulo de trabalho Futuro:</font></font><br>
<br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
futuros Possíveis extensões futuras incluem: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anexando constantes dinâmicas ao atributo ConstantValue de campos estáticos</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto isso, só podemos sonhar com os momentos em que esse recurso passará do estado “bom a fazer” para “pronto”. </font><font style="vertical-align: inherit;">Em seguida, as restrições no tamanho do código no bloco de inicialização perderão sua influência e o número máximo de elementos na enumeração determinará as limitações do pool constante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com estimativas aproximadas, neste caso, podemos esperar por um </font></font><code>65&nbsp;489 / 4 = 16_372</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento. </font><font style="vertical-align: inherit;">Aqui </font></font><code>65_489</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está o número de slots desocupados do pool constante, 46 dos 65_535 teoricamente possíveis foram para cima. </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- o número de faixas horárias necessárias para a declaração de um campo e a constante dinâmica correspondente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O número exato, é claro, só pode ser descoberto após o lançamento da versão do JDK com suporte para esse recurso.</font></font><br>
<br>
<a name="Unsafe"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inseguro</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso inimigo é o crescimento linear do bloco de inicialização com um aumento no número de elementos de enumeração. </font><font style="vertical-align: inherit;">Se tivéssemos encontrado uma maneira de reduzir a inicialização em um loop, removendo a relação entre o número de elementos na enumeração e o tamanho do bloco de inicialização, faríamos outra descoberta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, nenhuma das APIs públicas padrão permite gravar </font></font><code>static final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campos, mesmo dentro de um bloco de inicialização estático. </font><font style="vertical-align: inherit;">Nem o Reflection nem o VarHandles ajudarão aqui. </font><font style="vertical-align: inherit;">Nossa única esperança é grande e terrível </font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma execução insegura do FizzBuzz pode ser algo como isto:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FizzBuzz inseguro</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FizzBuzz {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz[] $VALUES;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Fizz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Buzz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz FizzBuzz;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz[] values() {
        <span class="hljs-keyword">return</span> (FizzBuzz[]) $VALUES.clone();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> (FizzBuzz) Enum.valueOf(FizzBuzz.class, name);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
        <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {<font></font>
            Fizz,<font></font>
            Buzz,<font></font>
            FizzBuzz<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span>  {<font></font>
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
        unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
        String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
            String fieldName = fieldNames[i];<font></font>
            Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
            <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
            unsafe.putObject(FizzBuzz.class, fieldOffset, <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i));<font></font>
        }<font></font>
<font></font>
        $VALUES = createValues();<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem nos permite criar uma enumeração com aproximadamente 21 mil elementos; para mais, a capacidade do pool de constantes não é suficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A documentação em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enum :: ordinal ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exige que seu valor corresponda ao número de sequência do elemento correspondente na declaração de enumeração, portanto, você deve armazenar explicitamente a lista de nomes de campos na ordem correta, quase duplicando o tamanho do arquivo de classe.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public final int ordinal () </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retorna o ordinal desta constante de enumeração (sua posição na declaração de enum, onde a constante inicial é atribuída a um ordinal de zero).</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui a API pública para o conteúdo do pool de constantes pode ajudar, já sabemos como preenchê-la na ordem em que precisamos, mas não existe essa API e é improvável que isso ocorra. O método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getConstantPool ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disponível no OpenJDK é </font><font style="vertical-align: inherit;">declarado como pacote-privado e seria imprudente confiar nele no código do usuário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O bloco de inicialização agora é bastante compacto e quase independente do número de elementos na enumeração, para que você </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possa recusá-lo incorporando seu corpo no loop:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    FizzBuzz[] localValues = <span class="hljs-keyword">new</span> FizzBuzz[fieldNames.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui ocorre um processo semelhante a uma avalanche: juntamente com o método </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as instruções para ler os campos dos elementos de enumeração desaparecem, os registros de tipo </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para esses campos </font><font style="vertical-align: inherit;">se tornam desnecessários </font><font style="vertical-align: inherit;">e, portanto, os </font></font><code>NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo para os registros de tipo </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No pool constante, </font></font><code>2 * &lt;   &gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são </font><font style="vertical-align: inherit;">liberados </font><font style="vertical-align: inherit;">slots que podem ser usados ​​para declarar elementos adicionais de enumeração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas nem tudo é tão otimista, os testes mostram uma diminuição significativa do desempenho: inicializar uma classe de enumeração com 65 mil elementos leva um minuto e meio impensável. Como se viu rapidamente, "o reflexo diminui". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A implementação de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getDeclaredField ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no OpenJDK possui um comportamento assintótico linear do número de campos na classe e nosso bloco de inicialização é quadrático por causa disso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A adição de cache melhora um pouco a situação, embora não a resolva completamente:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    Field[] fields = FizzBuzz.class.getDeclaredFields();<font></font>
    HashMap&lt;String, Field&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(fields.length);<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(Field field : fields) {<font></font>
        cache.put(field.getName(), field);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = cache.get(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }    <font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem insegura descrita neste capítulo permite criar transferências com o número de elementos de até 65_410, quase 24 vezes mais que o resultado alcançável com javac e bastante próximo do limite teórico de 65_505 elementos calculados por nós na publicação anterior do ciclo.</font></font><br>
<br>
<a name="Testing"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifique o desempenho</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para os testes, tomamos o maior enumeração, gerando-lo usando o comando </font></font><nobr><code>java -jar HugeEnumGen.jar -a Unsafe UnsafeHugeEnum</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como resultado, obtemos um arquivo de classe com um tamanho de 2 megabytes e 65_410 elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crie um novo projeto Java no IDEA e inclua a classe gerada como uma biblioteca externa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quase imediatamente, torna-se evidente que o IDEA não está pronto para esse teste de estresse: o </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m4/su/-6/m4su-6bvdkkqmf3pypqrmpzntnw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
preenchimento automático de um elemento de enumeração leva dezenas de segundos, tanto no antigo i5 móvel quanto no i7 8700K mais moderno. E se você tentar usar a correção rápida para adicionar os elementos ausentes ao comutador, o IDEA até pára de redesenhar as janelas. Suspeito que temporariamente, mas não esperei pela conclusão. A capacidade de resposta durante a depuração também deixa muito a desejar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com um pequeno número de elementos em </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFew</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">for</span>(String arg : args) {<font></font>
            System.out.print(arg + <span class="hljs-string">" : "</span>);<font></font>
<font></font>
            <span class="hljs-keyword">try</span> {<font></font>
                UnsafeHugeEnum value = UnsafeHugeEnum.valueOf(arg);<font></font>
<font></font>
                doSwitch(value);<font></font>
            } <span class="hljs-keyword">catch</span>(Throwable e) {<font></font>
                e.printStackTrace(System.out);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSwitch</span><span class="hljs-params">(UnsafeHugeEnum value)</span> </span>{
        <span class="hljs-keyword">switch</span>(value) {
            <span class="hljs-keyword">case</span> VALUE_00001:<font></font>
                System.out.println(<span class="hljs-string">"First"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_31415:<font></font>
                System.out.println(<span class="hljs-string">"(int) (10_000 * Math.PI)"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
                System.out.println(<span class="hljs-string">"Last"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não há surpresas aqui, a compilação e o lançamento são regulares:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java TestFew VALUE_00001 VALUE_00400 VALUE_31415 VALUE_65410<font></font>
VALUE_00001 : First<font></font>
VALUE_00400 : Unexpected value: VALUE_00400<font></font>
VALUE_31415 : (int) (10_000 * Math.PI)<font></font>
VALUE_65410 : Last<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E quanto a mais itens </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Podemos, por exemplo, processar </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos os nossos 65 mil elementos </font><font style="vertical-align: inherit;">em um de uma só </font><font style="vertical-align: inherit;">vez?</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">switch</span>(value) {
    <span class="hljs-keyword">case</span> VALUE_00001:
    <span class="hljs-keyword">case</span> VALUE_00002:<font></font>
        ...<font></font>
    <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
        System.out.println(<span class="hljs-string">"One of known values: "</span> + value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:<font></font>
        System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
        <span class="hljs-keyword">break</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, não. </font><font style="vertical-align: inherit;">Quando tentamos compilar, recebemos várias mensagens de erro:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ javac -fullversion<font></font>
javac full version "14.0.1+7"<font></font>
<font></font>
$ javac TestAll.java<font></font>
TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
TestAll.java:65433: error: too many constants<font></font>
                break;<font></font>
                ^<font></font>
TestAll.java:17: error: code too large<font></font>
    private static void doSwitch(UnsafeHugeEnum value) {<font></font>
                        ^<font></font>
TestAll.java:1: error: too many constants<font></font>
public class TestAll {<font></font>
       ^<font></font>
4 errors<font></font>
</code></pre><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testfew.java</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestAll.java</font></font></a></li>
</ul><br>
<a name="JavacSwitchTranslation"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac e switch</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender o que está acontecendo, precisamos descobrir como ocorre a tradução </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos elementos da enumeração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A especificação da JVM possui um capítulo separado em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 §3.10 Compiling Switches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cujas recomendações se resumem ao </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uso de uma das duas instruções de bytecode, </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não encontraremos </font><font style="vertical-align: inherit;">referências </font><font style="vertical-align: inherit;">a cadeias ou elementos de enumeração neste capítulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A melhor documentação é o código, então é hora de mergulhar na fonte </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A escolha entre </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocorre em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gen :: visitSwitch ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e depende do número de opções em </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Na maioria dos casos, ganha </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch</span>
<span class="hljs-comment">// instruction.</span>
<span class="hljs-keyword">long</span> table_space_cost = <span class="hljs-number">4</span> + ((<span class="hljs-keyword">long</span>) hi - lo + <span class="hljs-number">1</span>); <span class="hljs-comment">// words</span>
<span class="hljs-keyword">long</span> table_time_cost = <span class="hljs-number">3</span>; <span class="hljs-comment">// comparisons</span>
<span class="hljs-keyword">long</span> lookup_space_cost = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nlabels;
<span class="hljs-keyword">long</span> lookup_time_cost = nlabels;
<span class="hljs-keyword">int</span> opcode =<font></font>
    nlabels &gt; <span class="hljs-number">0</span> &amp;&amp;<font></font>
    table_space_cost + <span class="hljs-number">3</span> * table_time_cost &lt;=<font></font>
    lookup_space_cost + <span class="hljs-number">3</span> * lookup_time_cost<font></font>
    ?<font></font>
    tableswitch : lookupswitch;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cabeçalho </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem aproximadamente 16 bytes mais 4 bytes por valor. </font><font style="vertical-align: inherit;">Assim, </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sob nenhuma circunstância pode haver mais </font></font><code>( 65_535 - 16 ) / 4 = 16_379</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, depois de reduzir o número de ramificações </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no corpo </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para 16 mil, resta apenas um erro de compilação, o mais misterioso:</font></font><br>
<br>
<pre><code class="plaintext hljs">TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em busca da fonte do erro, retornaremos um pouco antes, ao estágio de eliminação do açúcar sintático. </font><font style="vertical-align: inherit;">Os </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">métodos são responsáveis pela </font><font style="vertical-align: inherit;">tradução </font></font><code>visitEnumSwitch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mapForEnum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e da classe </font></font><code>EnumMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower.java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também encontramos um pequeno comentário documental:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnumMapping JavaDoc</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/** This map gives a translation table to be used for enum
 *  switches.
 *
 *  &lt;p&gt;For each enum that appears as the type of a switch
 *  expression, we maintain an EnumMapping to assist in the
 *  translation, as exemplified by the following example:
 *
 *  &lt;p&gt;we translate
 *  &lt;pre&gt;
 *          switch(colorExpression) {
 *          case red: stmt1;
 *          case green: stmt2;
 *          }
 *  &lt;/pre&gt;
 *  into
 *  &lt;pre&gt;
 *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 *          case 1: stmt1;
 *          case 2: stmt2
 *          }
 *  &lt;/pre&gt;
 *  with the auxiliary table initialized as follows:
 *  &lt;pre&gt;
 *          class Outer$0 {
 *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 *              static {
 *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 *              }
 *          }
 *  &lt;/pre&gt;
 *  class EnumMapping provides mapping data and support methods for this translation.
 */</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O misterioso </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acaba por fazer parte de uma classe auxiliar gerada automaticamente </font></font><code>TestAll$0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Inside - uma declaração de uma matriz estática e código para inicializá-la. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A matriz corrige a correspondência entre os nomes dos elementos de enumeração e os </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valores numéricos </font><font style="vertical-align: inherit;">atribuídos a eles durante a compilação </font><font style="vertical-align: inherit;">, protegendo assim o código compilado dos efeitos nocivos da refatoração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao reordenar, adicionar novos ou excluir elementos de enumeração existentes, alguns deles podem alterar o valor </font></font><code>ordinal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e é disso que um nível adicional de indireto protege.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
    $SwitchMap$UnsafeHugeEnum[UnsafeHugeEnum.VALUE_00001.ordinal()] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//  9: getstatic     #2                  // Field $SwitchMap$UnsafeHugeEnum:[I</span>
    <span class="hljs-comment">// 12: getstatic     #3                  // Field UnsafeHugeEnum.VALUE_00001:LUnsafeHugeEnum;</span>
    <span class="hljs-comment">// 15: invokevirtual #4                  // Method UnsafeHugeEnum.ordinal:()I</span>
    <span class="hljs-comment">// 18: iconst_1</span>
    <span class="hljs-comment">// 19: iastore</span><font></font>
}<font></font>
<span class="hljs-comment">// 20: goto          24</span>
<span class="hljs-keyword">catch</span>(NoSuchFieldError e) { }
<span class="hljs-comment">// 23: astore_0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código de inicialização é simples e consome de 15 a 17 bytes por elemento. </font><font style="vertical-align: inherit;">Como resultado, o bloco de inicialização estático acomoda a inicialização de não mais que 3_862 elementos. </font><font style="vertical-align: inherit;">Esse número acaba sendo o número máximo de elementos de enumeração que podemos usar em um </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com a implementação atual </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="Conclusion"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que o uso de uma técnica tão simples como alocar a criação de elementos de enumeração e inicializar uma matriz </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um método separado permite aumentar o número máximo de elementos em uma enumeração de 2_746 para 10_920. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os resultados dinâmicos constantes no contexto das realizações anteriores não parecem muito impressionantes e permitem obter apenas 43 elementos a mais, mas com essa abordagem, é muito mais elegante adicionar novas propriedades à enumeração - basta modificar o construtor e transmitir os valores necessários pelos parâmetros estáticos da constante dinâmica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se, em algum momento no futuro, o atributo </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for ensinado a entender as constantes dinâmicas, esse número poderá subir para 10 mil a 16. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Use</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite dar um salto gigante e aumentar o número máximo de elementos para 65_410. Mas não se esqueça que </font></font><code>Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta é uma API proprietária, que com o tempo pode desaparecer e seu uso é um risco considerável, como javac avisa diretamente:</font></font><br>
<br>
<pre><code class="plaintext hljs">Test.java:3: warning: Unsafe is internal proprietary API and may be removed in a future release<font></font>
import sun.misc.Unsafe;<font></font>
               ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, como se viu, não é suficiente gerar uma enumeração gigante, você também precisa poder usá-la. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atualmente, existem problemas com o suporte de tais enumerações no IDE e no nível do compilador Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um grande número de campos na classe pode degradar a capacidade de resposta do IDE durante a edição e durante a depuração. </font><font style="vertical-align: inherit;">Às vezes, até um travamento completo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As restrições impostas pelo formato do arquivo de classe e pelos detalhes de implementação do javac tornam impossível o uso de </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais de 3_862 elementos </font><font style="vertical-align: inherit;">no código </font><font style="vertical-align: inherit;">ao mesmo tempo. </font><font style="vertical-align: inherit;">Dos aspectos positivos, vale ressaltar que esses podem ser elementos arbitrários 3_862. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melhorias adicionais nos resultados são possíveis apenas através do refinamento do compilador Java, mas essa é uma história completamente diferente.</font></font><br>
<br>
<a name="Appendix"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materiais adicionais</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código-fonte do GitHub: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Arquivo JAR coletado: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle/releases/tag/v1.0</font></font></a><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajuda de inicialização suportada</font></font></b>
                        <div class="spoiler_text"><pre><font></font>
Huge enumeration generator<font></font>
<font></font>
    https://github.com/Maccimo/HugeEnumGeneratorArticle<font></font>
<font></font>
Additional information (in Russian):<font></font>
<font></font>
    https://habr.com/ru/post/483392/<font></font>
    https://habr.com/ru/post/501870/<font></font>
<font></font>
Usage:<font></font>
    java -jar HugeEnumGen.jar [ &lt;options&gt; ] &lt;enum name&gt;<font></font>
<font></font>
    &lt;enum name&gt;<font></font>
        An enumeration class name.<font></font>
        Should be a valid Java identifier. May contain package name.<font></font>
<font></font>
Options:<font></font>
<font></font>
    -d &lt;directory&gt;<font></font>
        Output directory path.<font></font>
        Current working directory by default.<font></font>
<font></font>
    -e &lt;item list file&gt;<font></font>
        Path to UTF8-encoded text file with list of enumeration item names.<font></font>
        Item names will be autogenerated if absent.<font></font>
        Mutually exclusive with the -c option.<font></font>
<font></font>
    -c &lt;count&gt;<font></font>
        Count of autogenerated enumeration item names.<font></font>
        Mutually exclusive with the -e option.<font></font>
        Default value: Algorithm-depended<font></font>
<font></font>
    -a &lt;algorithm&gt;<font></font>
        Enumeration generation algorithm.<font></font>
        Supported algorithms:<font></font>
          ConDy          - Employ Constant Dynamic (JEP 309) for enum elements initialization<font></font>
          ExtractMethod  - Extract enum elements initialization code to separate method<font></font>
          Unsafe         - Employ sun.misc.Unsafe for enum elements initialization<font></font>
<font></font>
        Default algorithm: ExtractMethod<font></font>
<font></font>
    -h / -?<font></font>
        Show this help page.<font></font>
<font></font>
Example:<font></font>
<font></font>
    java -jar HugeEnumGen.jar -d ./bin -c 2020 com.habr.maccimo.HugeEnum2020<font></font>
<font></font>
</pre><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt501860/index.html">15 de maio O RU-Center pode adicionar um serviço pago sem a sua participação</a></li>
<li><a href="../pt501862/index.html">Tremulação sob o capô</a></li>
<li><a href="../pt501864/index.html">Assistente ou inspetor: para quem o robô está ligando?</a></li>
<li><a href="../pt501866/index.html">Quantos empregos os robôs destruirão</a></li>
<li><a href="../pt501868/index.html">Como não deixar o contador se jogar ou Transferimos 1C para a nuvem. Instruções passo a passo</a></li>
<li><a href="../pt501872/index.html">Lugar de estudo em sistemas cibernéticos</a></li>
<li><a href="../pt501874/index.html">Arquiteturas modernas de front-end (parte 2)</a></li>
<li><a href="../pt501880/index.html">Sobre a tradução de "começos" e "começos" sem começo, começo e primeiro</a></li>
<li><a href="../pt501882/index.html">Como usamos os algoritmos de visão computacional: processamento de vídeo em um navegador móvel usando o OpenCV.js</a></li>
<li><a href="../pt501884/index.html">Como os arquivos eletrônicos de informações médicas ajudarão a diagnosticar doenças de maneira mais eficaz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>