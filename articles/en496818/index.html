<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìß üôÇ üêÆ Hundreds of thousands of routes per second per core. Yandex.Routing Experience üç≤ üë®üèø‚Äçüè´ üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of weeks ago, Danya Tararukhin told on Habr√© how our service appeared, Yandex.Routing, and how it helps companies with logistics. By creating...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hundreds of thousands of routes per second per core. Yandex.Routing Experience</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/496818/"><img src="https://habrastorage.org/webt/it/we/vn/itwevn4ivk3h4pncvonx-mh4w70.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A couple of weeks ago, Danya Tararukhin </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">told</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Habr√© how our service appeared, Yandex.Routing, and how it helps companies with logistics. </font><font style="vertical-align: inherit;">By creating the platform, we solved several interesting problems, one of which is dedicated to today's post. </font><font style="vertical-align: inherit;">I want to talk about route planning itself and the resources needed for this.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finding the best route between multiple points is a classic discrete optimization problem. </font><font style="vertical-align: inherit;">To solve it, you need to know the distances and travel times between all points. </font><font style="vertical-align: inherit;">That is, to know the matrix of distances and times. </font><font style="vertical-align: inherit;">Two years ago, a long matrix calculation was a very critical problem for us and blocked development. </font><font style="vertical-align: inherit;">The search for the optimal solution with the known matrix took 10 minutes, but the calculation of all the cells of the matrix for large tasks (for several thousand orders) took hours.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve the problem with five thousand orders, you need to know the distances and travel times between all points. These are two matrixes of numbers with the dimension 5000x5000. We plan courier routes for the whole day, and in the morning the courier will get from point to point in one time, and in the evening - for another. So, you need to calculate the matrix of times and distances for each hour of the day. Not all hours of the day are unique, but cork time (morning and evening) needs to be covered well. Therefore, we came to a configuration with thirteen hour slices. In total, we need two cubes (times and distances) each 13x5000x5000. These are 325 million routes, calculated according to the real road graph, in which 165 million edges. Calculation of one route in the well-optimized algorithm of the Yandex.Maps team takes about 10 ms, for a total of 900 hours of calculations.Even when parallelized to 900 CPUs, you need to wait 1 hour. We could not start such a service, we needed a more suitable algorithm.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For further reading, it is useful to know </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dijkstra's algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for finding the shortest path in a graph. It can be imagined as a ‚Äúwave‚Äù emanating from the starting point of the route and going around the entire graph until the finish point is met. The running time of the algorithm is proportional to the edges of the graph, that is, the area covered by the wave: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cz/7s/em/cz7seml-ef9d058gdfhgkoe50_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Almost every candidate for an interview at the interview guesses to the first step of optimizing such a task: you can start the wave from two sides and end the search when the waves meet. The total area of ‚Äã‚Äãtwo waves of half radius is less than one large.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/ch/2c/2gch2cvzqgbjwduk9_agsqhvrma.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The real road graph is quite structured, and this can be used. When you are looking for the shortest distance between Moscow and St. Petersburg, in classical Dijkstra you will be forced to spread the wave in a circle and sort through all the streets and alleys of Moscow, the cities and villages of Moscow Region, the streets of Tver and Novgorod. This is a huge amount of calculations, but you can prepare in advance and remember the optimal routes between cities (aka shortcuts) and not repeat them in runtime. Then, to find the route between two points in the hierarchical Dijkstra, you need to calculate the shortest distances to the desired shortcut. Since hierarchy levels may not be two, but 5-6, they dramatically reduce the search time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Card router team has implemented such optimizations for quite some time. It was they who made it possible to reach 10 ms to search for a route between two points. :) So for now, we have not come close to solving our problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the point-to-point search mode is already extremely optimized, we can optimize the calculation of the series in the matrix. A row is the distance from one point to all the others. While we are looking for the distance to the farthest point, we simultaneously calculate the distances to closer ones. Therefore, calculating the series is equivalent to calculating the distance to the farthest point. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jp/6i/qa/jp6iqadxummylqmj1suh0h2ppe8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We look at the time of calculating the series using this algorithm and recall that sequential calculation of 5000 routes would take about 5000 * 10 ms = 50 s:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/c_/v9/jvc_v98yos03l5xd5w57394s4dk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The graph shows the calculation time of a row in a distance matrix of size 1 * N for different N (according to real data). It can be seen that the calculation of the row of size 1 * 5000 of interest to us fits into 1.3 seconds. A trend line has been added to the chart, which shows that the calculation time is growing slightly more slowly than linearly in N, the order of N ** 0.74</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Already not bad! With this algorithm, we can calculate our cube in 13 * 5000 * 1.3 s = 84 500 s = almost 24 hours. It easily parallels in rows, and when using 50 CPUs, distances are calculated in half an hour. The complexity order of the cube calculation algorithm is O (N ** 1.74):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9c/cr/xd/9ccrxdjoher2ks-ijoa7ur3rd2m.png"><br>
<i>    13   N*N    50 CPU (    13*N/50).      ,        5000 ,           .      10 000,   :      .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this form, two and a half years ago, we launched the first version of our API, which solves the logistics problem. Clients often complained about a long decision time, and they are easy to understand: you started a task to be solved, wait 1 hour, you get a solution and you understand that you forgot to fix the shift time with the driver, you correct it and it all starts all over again. Drivers begin to get nervous, because they risk getting into the morning rush hour, or even do not have time to deliver the order on time. It was necessary to do something. We didn‚Äôt want to ‚Äúthrow‚Äù the problem with iron: we were preparing for heavy loads, it would have required a lot of iron, and the purchase of servers is not happening at once. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A study of academic articles showed that, it turns out, there are algorithms with linear complexity for this task </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! (In the article by reference, there is a large overview of all sorts of modern methods of Dijkstra's acceleration, including for the matrix case.) Calculating the matrix in linear time did not fit in my head. One of our developers volunteered to write a prototype, and this is what happened: The </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/3o/lq/ag3olqspwhrjrvtodp699z6bl64.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time to calculate one matrix of size N * N on one CPU using the "fast matrix" algorithm. Complexity is obtained on the order of O (N ** 1,1). High Ns are knocked out of the trend line, since the generation of the answer and its downloading over the network are already more influencing the time.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
115 seconds per 5000x5000 matrix using a single core and an almost linear dependence on N. Fiction has become a reality! The idea of ‚Äã‚Äãthe algorithm combines the two ideas described above: Dijkstra for series and hierarchical search. Obviously, starting to calculate the second row, at some point we will again go around the same area of ‚Äã‚Äãthe graph that we just went through, calculating the previous row. Therefore, let us memorize the shortest distances to all destinations at the nodes of the hierarchical graph. When we begin to calculate the next series, then, having reached such a node, we will immediately get almost all the distances to other points. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/3y/os/ch3yosqi1h0od0dtee_tn_dsqem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A year and a half ago, this allowed us to save half an hour of time with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logistics and significantly reduce iron intake. </font><font style="vertical-align: inherit;">Previously, for one large request, we needed 50 cores for half an hour, but now - 13 cores for 2 minutes. </font><font style="vertical-align: inherit;">This is approximately 200,000 routes per second per core. </font><font style="vertical-align: inherit;">That rare case when the new algorithm does not just close the class of problems, but expands our ideas about the possible.</font></font><br>
 <br>
<hr><sub><sup><a name="arxiv"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Article ‚ÄúRoute Planning in Transportation Networks‚Äù, see paragraph </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.7.2 ‚ÄúBatched Shortest Paths‚Äù</font></font></a></sup></sub></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en496802/index.html">Simple Made Easy - Rich Hickey (with Russian translation)</a></li>
<li><a href="../en496804/index.html">Installing and Configuring Docker on Windows Subsystem Linux (WSL)</a></li>
<li><a href="../en496810/index.html">General Financial Analysis in Python (Part 3)</a></li>
<li><a href="../en496812/index.html">Zoom - banal negligence or targeted espionage?</a></li>
<li><a href="../en496816/index.html">Can you feel the candidate, is he alive?</a></li>
<li><a href="../en496820/index.html">Pitfalls of Terraform</a></li>
<li><a href="../en496822/index.html">How startups in the United States die due to coronavirus</a></li>
<li><a href="../en496824/index.html">Your Nordic work environment</a></li>
<li><a href="../en496826/index.html">Million sprites at 120+ fps</a></li>
<li><a href="../en496828/index.html">Where to find freelance that will be fun? (Spoiler: not Upwork)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>