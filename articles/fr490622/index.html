<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 👨‍👩‍👧‍👧 😈 Lutte contre les fuites de mémoire dans les applications Web 🎌 👨 🚄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque nous sommes passés du développement de sites Web, dont les pages sont formées sur le serveur, à la création d'applications Web à page unique r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lutte contre les fuites de mémoire dans les applications Web</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490622/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous sommes passés du développement de sites Web, dont les pages sont formées sur le serveur, à la création d'applications Web à page unique rendues sur le client, nous avons adopté certaines règles du jeu. L'un d'eux est la gestion précise des ressources sur l'appareil de l'utilisateur. Cela signifie - ne bloquez pas le flux principal, ne "tournez" pas le ventilateur de l'ordinateur portable, ne mettez pas la batterie du téléphone. Nous avons échangé une amélioration de l'interactivité des projets Web, et le fait que leur comportement devenait plus semblable au comportement des applications ordinaires, une nouvelle classe de problèmes qui n'existait pas dans le monde du rendu de serveur.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/wv/_c/nl/wv_cnlo46dgs8op0yzhybzgkpw8.jpeg"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un de ces problèmes est les fuites de mémoire. </font><font style="vertical-align: inherit;">Une application d'une page mal conçue peut facilement engloutir des mégaoctets ou même des gigaoctets de mémoire. </font><font style="vertical-align: inherit;">Il est capable de prendre de plus en plus de ressources même lorsqu'il se trouve tranquillement sur l'onglet d'arrière-plan. </font><font style="vertical-align: inherit;">La page d'une telle application, après avoir capturé une quantité exorbitante de ressources, peut commencer à "ralentir" considérablement. </font><font style="vertical-align: inherit;">De plus, le navigateur peut simplement fermer l'onglet et dire à l'utilisateur: «Quelque chose s'est mal passé».</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/e9d/da8/34be9dda87ca7f35d70a1a934816ce78.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelque chose a mal tourné</font></font></font></i><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, les sites rendus sur le serveur peuvent également souffrir d'un problème de fuite de mémoire. Mais ici, nous parlons de la mémoire du serveur. Dans le même temps, il est hautement improbable que de telles applications provoquent une fuite de mémoire sur le client, car le navigateur efface la mémoire après chaque transition utilisateur entre les pages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le sujet des fuites de mémoire n'est pas bien couvert dans les publications de développement Web. Et malgré cela, je suis presque sûr que la plupart des applications à page unique non triviales souffrent de fuites de mémoire - à moins que les équipes qui les traitent ne disposent d'outils fiables pour détecter et résoudre ce problème. Le point ici est qu'en JavaScript, il est extrêmement facile d'allouer au hasard une certaine quantité de mémoire, puis d'oublier de libérer cette mémoire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'auteur de l'article, dont nous publions la traduction aujourd'hui, va partager avec les lecteurs son expérience dans la lutte contre les fuites de mémoire dans les applications web, et souhaite également donner des exemples de leur détection efficace.</font></font><br>
<cut></cut><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi est-il si peu écrit à ce sujet?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, je veux expliquer pourquoi si peu de choses sont écrites sur les fuites de mémoire. </font><font style="vertical-align: inherit;">Je suppose que vous pouvez trouver ici plusieurs raisons:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manque de plaintes des utilisateurs: la plupart des utilisateurs ne sont pas occupés à surveiller de près le gestionnaire de tâches lorsqu'ils naviguent sur le Web. </font><font style="vertical-align: inherit;">En règle générale, le développeur ne rencontre pas de plaintes des utilisateurs jusqu'à ce que la fuite de mémoire soit si grave qu'elle entraîne l'incapacité de fonctionner ou de ralentir l'application.</font></font></li>
<li>  :   Chrome   -   ,     .          .</li>
<li> :            .</li>
<li>      :       «»     .   ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>,   -.</li>
</ul><br>
<h2><font color="#3AC1EF">  </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les bibliothèques et les cadres modernes de développement d'applications Web, tels que React, Vue et Svelte, utilisent le modèle de composant de l'application. Dans ce modèle, la façon la plus courante de provoquer une fuite de mémoire est quelque chose comme ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout. </font><font style="vertical-align: inherit;">C'est tout ce qu'il faut pour «équiper» un projet d'une fuite mémoire. </font><font style="vertical-align: inherit;">Pour ce faire, il suffit d'appeler la méthode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d' </font><font style="vertical-align: inherit;">un objet global (comme </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou </font></font><code>&lt;body&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou quelque chose de similaire), puis, lors du démontage du composant, oubliez de supprimer l'écouteur d'événements à l'aide de la méthode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">removeEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais les conséquences sont encore pires, car la fuite de l'ensemble du composant se produit. </font><font style="vertical-align: inherit;">Cela est dû au fait que la méthode est </font></font><code>this.onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attachée à </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Avec ce composant, une fuite de ses composants enfants se produit. </font><font style="vertical-align: inherit;">Il est très probable que tous les nœuds DOM associés à ce composant fuiront. </font><font style="vertical-align: inherit;">En conséquence, la situation peut devenir incontrôlable très rapidement, entraînant de très graves conséquences.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment résoudre ce problème:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">this</span>.onMessage = <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situations dans lesquelles les fuites de mémoire se produisent le plus souvent</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'expérience me dit que les fuites de mémoire se produisent le plus souvent lors de l'utilisation des API suivantes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Méthode </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est là que les fuites de mémoire se produisent le plus souvent. </font><font style="vertical-align: inherit;">Pour résoudre le problème, il suffit d'appeler au bon moment </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">setTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">setInterval</a>.   ,        (,  30 ),  ,   ,      ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clearTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clearInterval</a>. ,    <code>setTimeout</code>,  «»   ,    ,     <code>setInterval</code>-.  ,    <code>setTimeout</code>       .</li>
<li>API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntersectionObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ResizeObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MutationObserver</a>   .  ,  ,  .         .     -         ,  ,   ,     ,   ,   <code>disconnect</code>  .    ,     DOM    ,           ,  -.        -,     .  —  <code>&lt;body&gt;</code>,  <code>document</code>,   <code>header</code>  <code>footer</code>,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promise-</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>      .   ,    ,     —   ,      . , ,  «»   ,        .    «»     <code>.then()</code>-.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Référentiels représentés par des objets globaux. </font><font style="vertical-align: inherit;">Lorsque vous utilisez quelque chose comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour contrôler l'état d'une application </font><font style="vertical-align: inherit;">, le magasin d'état est représenté par un objet global. </font><font style="vertical-align: inherit;">Par conséquent, si vous traitez un tel stockage avec négligence, les données inutiles ne seront pas supprimées de celui-ci, ce qui entraînera une augmentation constante de sa taille.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Croissance DOM infinie. </font><font style="vertical-align: inherit;">Si la page implémente un défilement sans fin sans utiliser de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtualisation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cela signifie que le nombre de nœuds DOM sur cette page peut augmenter de manière illimitée.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessus, nous avons examiné les situations dans lesquelles les fuites de mémoire se produisent le plus souvent, mais, bien sûr, il existe de nombreux autres cas qui causent le problème qui nous intéresse.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Identification des fuites de mémoire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous sommes maintenant passés au défi d'identifier les fuites de mémoire. Pour commencer, je ne pense pas que l'un des outils existants soit très approprié pour cela. J'ai essayé les outils d'analyse de mémoire de Firefox, j'ai essayé les outils de Edge et IE. Testé même Windows Performance Analyzer. Mais les meilleurs de ces outils restent les outils de développement Chrome. Certes, dans ces outils, il existe de nombreux "coins vifs", qui valent la peine d'être connus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parmi les outils fournis par le développeur Chrome, nous sommes particulièrement intéressés par le profileur à </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir de l'onglet </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui vous permet de créer des instantanés de tas. Il existe d'autres outils pour analyser la mémoire dans Chrome, mais je n'ai pas pu en tirer des avantages particuliers pour détecter les fuites de mémoire.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/e42/63a/e7de4263abd59eecce420c4bcbfc55ea.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'outil d'instantané du tas vous permet de prendre des instantanés de la mémoire du flux principal, des travailleurs Web ou des éléments iframe.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si la fenêtre de l'outil Chrome ressemble à celle illustrée dans la figure précédente, lorsque vous cliquez sur le bouton</font></font><code>Take snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les informations sur tous les objets dans la mémoire de la machine virtuelle sélectionnée sont capturées JavaScript de la page étudiée. Cela inclut les objets référencés dans</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les objets référencés par les rappels utilisés dans l'appel</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. Un instantané de la mémoire peut être perçu comme un «moment figé» du travail de l'entité enquêtée, représentant des informations sur toute la mémoire utilisée par cette entité.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois la photo prise, nous passons à l'étape suivante de la recherche de fuites. Elle consiste à reproduire un scénario dans lequel, selon le développeur, une fuite de mémoire peut se produire. Par exemple, il ouvre et ferme une certaine fenêtre modale. Une fois la fenêtre similaire fermée, il est prévu que la quantité de mémoire allouée revienne au niveau qui existait avant l'ouverture de la fenêtre. Par conséquent, ils prennent une autre photo, puis la comparent avec la photo prise précédemment. En fait, la comparaison d'images est la caractéristique la plus importante qui nous intéresse </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/776/4c7/92d7764c7fbe5d561032c3bc092e1541.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous prenons le premier instantané, puis nous entreprenons des actions qui peuvent provoquer une fuite de mémoire, puis nous prenons un autre instantané. </font><font style="vertical-align: inherit;">S'il n'y a pas de fuite, la taille de la mémoire allouée sera égale. C'est</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
vrai,</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est loin d'être un outil idéal. </font><font style="vertical-align: inherit;">Il a certaines limites à connaître:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Même si vous cliquez sur le petit bouton du panneau </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui démarre la récupération de place ( </font></font><code>Collect garbage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), pour être sûr que la mémoire est vraiment effacée, vous devrez peut-être prendre plusieurs photos consécutives. </font><font style="vertical-align: inherit;">J'ai généralement trois coups de feu. </font><font style="vertical-align: inherit;">Ici, il convient de se concentrer sur la taille totale de chaque image - elle devrait finalement se stabiliser.</font></font></li>
<li>    -, -,  <code>iframe</code>,      ,   ,          .   ,        JavaScript.   —      ,       ,    .</li>
<li>           «».             .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce stade, si votre application est assez complexe, vous remarquerez peut-être beaucoup d'objets «qui fuient» lorsque vous comparez des instantanés. </font><font style="vertical-align: inherit;">Ici, la situation est quelque peu compliquée, car ce qui peut être confondu avec une fuite de mémoire n'est pas toujours le cas. </font><font style="vertical-align: inherit;">Une grande partie de ce qui est suspect est juste des processus normaux pour travailler avec des objets. </font><font style="vertical-align: inherit;">La mémoire occupée par certains objets est effacée pour placer d'autres objets dans cette mémoire, quelque chose est vidé dans le cache et de sorte que la mémoire correspondante ne soit pas effacée immédiatement, etc.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous nous frayons un chemin à travers le bruit de l'information</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai trouvé que la meilleure façon de percer le bruit de l'information est de répéter les actions qui sont censées provoquer une fuite de mémoire. Par exemple, au lieu d'ouvrir et de fermer la fenêtre modale une seule fois après la capture du premier plan, cela peut être fait 7 fois. Pourquoi 7? Oui, ne serait-ce que parce que 7 est un nombre premier notable. Ensuite, vous devez prendre une deuxième photo et, en la comparant avec la première, savoir si un certain objet a «fui» 7 fois (ou 14 fois ou 21 fois).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/ac2/243/2a7ac2243dc82f0e7887b23098e7c893.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparez les instantanés de tas. Veuillez noter que nous comparons l'image n ° 3 avec l'image n ° 6. Le fait est que j'ai pris trois clichés de suite pour que Chrome ait plus de sessions de collecte des ordures. De plus, notez que certains objets ont «fui» 7 fois.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Une autre astuce utile est qu'au tout début de l'étude, avant de créer la première image, effectuez la procédure une fois, pendant laquelle, comme prévu, fuite de mémoire. Ceci est particulièrement recommandé si le fractionnement de code est utilisé dans le projet. Dans un tel cas, il est très probable que lors de la première exécution de l'action suspecte, les modules JavaScript nécessaires seront chargés, ce qui affectera la quantité de mémoire allouée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez maintenant vous demander pourquoi vous devez porter une attention particulière au nombre d'objets et non à la quantité totale de mémoire. Ici, nous pouvons dire que nous nous efforçons intuitivement de réduire la quantité de mémoire "qui fuit". À cet égard, vous pourriez penser que vous devriez surveiller la quantité totale de mémoire utilisée. Mais cette approche, pour une raison importante, ne nous convient pas particulièrement bien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si quelque chose «fuit», cela arrive parce que (en racontant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joe Armstrong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) vous avez besoin d'une banane, mais vous vous retrouvez avec une banane, le gorille qui la tient, et aussi, en plus, toute la jungle. Si nous nous concentrons sur la quantité totale de mémoire, ce sera la même chose que «mesurer» la jungle, et non la banane qui nous intéresse.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/af8/847/7e8af8847ab7e8689e1638ac218582d6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorille mangeant une banane.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Revenons maintenant à l'exemple ci-dessus avec</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Une source de fuite est un écouteur d'événements qui fait référence à une fonction. Et cette fonction, à son tour, fait référence à un composant qui, éventuellement, stocke des liens vers un tas de bonnes choses comme des tableaux, des chaînes et des objets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous analysez la différence entre les images, en triant les entités selon la quantité de mémoire qu'elles occupent, cela vous permettra de voir de nombreux tableaux, lignes, objets, dont la plupart ne sont probablement pas liés à la fuite. Et après tout, nous devons trouver l'écouteur d'événements à partir duquel tout a commencé. Lui, par rapport à ce à quoi il fait référence, prend très peu de mémoire. Afin de réparer la fuite, vous devez trouver une banane, pas la jungle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, si vous triez les enregistrements en fonction du nombre d'objets «divulgués», vous remarquerez 7 écouteurs d'événements. </font><font style="vertical-align: inherit;">Et peut-être 7 composants, et 14 sous-composants, et peut-être quelque chose d'autre comme ça. </font><font style="vertical-align: inherit;">Ce nombre 7 devrait se démarquer de la situation dans son ensemble, car il s'agit néanmoins d'un nombre plutôt notable et inhabituel. </font><font style="vertical-align: inherit;">Dans ce cas, peu importe le nombre de répétitions de l'action suspecte. </font><font style="vertical-align: inherit;">Lors de l'examen des images, si les soupçons sont justifiés, il sera enregistré tout autant d'objets «ayant fui». </font><font style="vertical-align: inherit;">C'est ainsi que vous pouvez identifier rapidement la source d'une fuite de mémoire.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse de l'arborescence des liens</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'outil de création d'instantanés offre la possibilité d'afficher des «chaînes de liens» qui vous aident à savoir quels objets sont référencés par d'autres objets. </font><font style="vertical-align: inherit;">C'est ce qui permet à l'application de fonctionner. </font><font style="vertical-align: inherit;">En analysant de telles «chaînes» ou «arbres» de liens, vous pouvez savoir exactement où la mémoire a été allouée pour l'objet «qui fuit».</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/77a/07d/7bf77a07dd2d15e479f77c2279b9942d.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La chaîne de liens vous permet de savoir quel objet fait référence à l'objet "qui fuit". </font><font style="vertical-align: inherit;">Lors de la lecture de ces chaînes, il est nécessaire de tenir compte du fait que les objets qui y sont situés ci-dessous se réfèrent aux objets situés au-dessus.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans l'exemple ci-dessus, il existe une variable appelée</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">référencée dans la fermeture (</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) référencée par l'écouteur d'événement. </font><font style="vertical-align: inherit;">Si vous cliquez sur le lien menant au code source, un texte assez compréhensible du programme sera affiché:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> () </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> someObject = <span class="hljs-keyword">new</span> SomeObject();
<span class="hljs-keyword">const</span> onMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, onMessage);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous comparons ce code avec la figure précédente, il s'avère que </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la figure est une fermeture </font></font><code>onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui fait référence </font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci est un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exemple artificiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les vraies fuites de mémoire peuvent être beaucoup moins évidentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que l'outil d'instantané de tas présente certaines limites:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous enregistrez un fichier d'instantané, puis le téléchargez à nouveau, les liens vers les fichiers avec du code sont perdus. </font><font style="vertical-align: inherit;">Autrement dit, après avoir téléchargé un instantané, il ne sera pas possible de savoir que le code de fermeture de l'écouteur d'événements se trouve à la ligne 22 du fichier </font></font><code>foo.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Étant donné que ces informations sont extrêmement importantes, il est presque inutile d'enregistrer des fichiers d'instantané de tas ou, par exemple, de les transférer à quelqu'un.</font></font></li>
<li>     <code>WeakMap</code>,  Chrome       ,      . ,   ,     ,    ,   .    <code>WeakMap</code> —     .</li>
<li>Chrome  ,    .  ,        ,     ,     ,     .      ,       <code>object</code>,    <code>EventListener</code>.   <code>object</code> —     ,  ,   ,  «»   7  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est une description de ma stratégie de base pour identifier les fuites de mémoire. </font><font style="vertical-align: inherit;">J'ai utilisé avec succès cette technique pour détecter des dizaines de fuites. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certes, je dois dire que ce guide pour trouver les fuites de mémoire ne couvre qu'une petite partie de ce qui se passe dans la réalité. </font><font style="vertical-align: inherit;">Ce n'est que le début du travail. </font><font style="vertical-align: inherit;">De plus, vous devez être en mesure de gérer l'installation des points d'arrêt, la journalisation, les tests de corrections pour déterminer s'ils résolvent le problème. </font><font style="vertical-align: inherit;">Et, malheureusement, tout cela, en substance, se traduit par un sérieux investissement de temps.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse automatisée des fuites de mémoire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux commencer cette section avec le fait que je n'ai pas pu trouver une bonne approche pour automatiser la détection des fuites de mémoire. Chrome a sa propre API </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance.memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais pour des raisons de confidentialité, il </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne vous permet pas de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collecter des données suffisamment détaillées. Par conséquent, cette API ne peut pas être utilisée en production pour détecter les fuites. Le groupe de travail sur les performances Web du W3C a précédemment discuté </font><font style="vertical-align: inherit;">des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outils de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mémoire, mais ses membres doivent encore se mettre d'accord sur une nouvelle norme conçue pour remplacer cette API. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les environnements de test, vous pouvez augmenter la granularité de la sortie des données </font></font><code>performance.memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'aide de l'indicateur Chrome </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">--enable-precise-memory-info</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Les instantanés de tas peuvent toujours être créés à l'aide de la propre équipe du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chromedriver: takeHeapSnapshot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette équipe a les mêmes limites que nous avons déjà discutées. Il est probable que si vous utilisez cette commande, pour les raisons décrites ci-dessus, il est logique de l'appeler trois fois, puis de ne prendre que ce qui a été reçu à la suite de son dernier appel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que les écouteurs d'événements sont la source la plus courante de fuites de mémoire, je vais parler d'une autre technique de détection des fuites que j'utilise. Elle consiste à créer des patchs singe pour l'API </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à compter les liens pour vérifier que leur nombre revient à zéro. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un exemple de la façon dont cela se fait.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les outils de développement Chrome, vous pouvez également utiliser l'API native </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getEventListeners</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour savoir quels écouteurs d'événements sont </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">associés</font></a><font style="vertical-align: inherit;"> à un élément particulier. </font><font style="vertical-align: inherit;">Cette commande n'est cependant disponible que dans la barre d'outils du développeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux ajouter que Matthias Binens m'a parlé d'une autre API d'outils Chrome utile. </font><font style="vertical-align: inherit;">Ce sont des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queryObjects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Avec lui, vous pouvez obtenir des informations sur tous les objets créés à l'aide d'un certain constructeur. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bonnes informations sur ce sujet concernant l'automatisation de la détection des fuites de mémoire dans Puppeteer.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La recherche et la correction des fuites de mémoire dans les applications Web en sont encore à leurs balbutiements. Ici, j'ai parlé de certaines techniques qui, dans mon cas, fonctionnaient bien. Mais il faut reconnaître que l'application de ces techniques est encore lourde de difficultés et de temps.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme pour tout problème de performance, comme on dit, une pincée à l'avance vaut une livre. Peut-être que quelqu'un jugera utile de préparer les tests de synthèse appropriés plutôt que d'analyser la fuite une fois qu'elle s'est déjà produite. Et si ce n'est pas une fuite, mais plusieurs, alors l'analyse du problème peut se transformer en quelque chose comme éplucher des oignons: après qu'un problème est résolu, un autre est découvert, puis ce processus se répète (et tout ce temps, comme pour les oignons , larmes aux yeux). Les révisions de code peuvent également aider à identifier les modèles de fuite courants. Mais ceci - si vous savez - où chercher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript est un langage qui permet de travailler en toute sécurité avec la mémoire. </font><font style="vertical-align: inherit;">Par conséquent, il existe une certaine ironie dans la facilité avec laquelle les fuites de mémoire se produisent dans les applications Web. </font><font style="vertical-align: inherit;">Certes, cela est dû en partie aux caractéristiques des interfaces utilisateur des périphériques. </font><font style="vertical-align: inherit;">Vous devez écouter de nombreux événements: événements de souris, événements de défilement, événements de clavier. </font><font style="vertical-align: inherit;">L'application de tous ces modèles peut facilement entraîner des fuites de mémoire. </font><font style="vertical-align: inherit;">Mais, en veillant à ce que nos applications Web utilisent la mémoire avec parcimonie, nous pouvons augmenter leurs performances et les protéger contre les «plantages». </font><font style="vertical-align: inherit;">De plus, nous démontrons ainsi le respect des limites de ressources des appareils utilisateurs. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chers lecteurs! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avez-vous rencontré des fuites de mémoire dans vos projets Web?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490610/index.html">Baidu bat Waymo en Californie Évaluation de l'autonomie en robotique</a></li>
<li><a href="../fr490612/index.html">Approche fonctionnelle des transactions sur Scala ou écrivez votre propre monade utile</a></li>
<li><a href="../fr490616/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 404 (24 février - 1er mars 2020)</a></li>
<li><a href="../fr490618/index.html">Goroutine Stack Buffers</a></li>
<li><a href="../fr490620/index.html">Quand j'entends les mots "restauré le réseau neuronal", je grimpe pour vérifier les sauvegardes</a></li>
<li><a href="../fr490624/index.html">En-tête HTTP et contrôle du navigateur Web</a></li>
<li><a href="../fr490626/index.html">Un guide complet des attributs data- * HTML</a></li>
<li><a href="../fr490628/index.html">Que faire lorsque CSS bloque l'analyse des pages?</a></li>
<li><a href="../fr490630/index.html">Chargement de tableaux NumPy à partir du disque: comparaison de memmap () et Zarr / HDF5</a></li>
<li><a href="../fr490634/index.html">Événements numériques à Moscou du 2 au 8 mars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>