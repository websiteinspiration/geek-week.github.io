<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏼 🔬 🎌 So funktioniert das Rendern von 3D-Spielen: Licht und Schatten 🏇🏾 🌇 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Implementierung der meisten visuellen Effekte in modernen Spielen hängt vom umsichtigen Einsatz von Licht und Schatten ab. Ohne sie wären Spiele l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>So funktioniert das Rendern von 3D-Spielen: Licht und Schatten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung der meisten visuellen Effekte in modernen Spielen hängt vom umsichtigen Einsatz von Licht und Schatten ab. </font><font style="vertical-align: inherit;">Ohne sie wären Spiele langweilig und leblos. </font><font style="vertical-align: inherit;">Im vierten Teil der Analyse des Renderns von 3D-Spielen konzentrieren wir uns auf das Geschehen in der 3D-Welt sowie auf die Vertex-Verarbeitung und das Textur-Mapping. </font><font style="vertical-align: inherit;">Wir werden wieder viel Mathematik sowie ein solides Verständnis der Grundlagen der Optik brauchen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1: Vertex-Verarbeitung </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2: Rasterisierung und Raytracing </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 3: Texturieren und Filtern von Texturen</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnern Sie sich an die Vergangenheit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor haben wir die wichtigsten Aspekte des Verschiebens und Verarbeitens von Objekten in Szenen, ihre Umwandlung vom dreidimensionalen Raum in ein flaches Pixelraster sowie Möglichkeiten zum Überlagern von Texturen auf diesen Objekten untersucht. Seit vielen Jahren sind solche Vorgänge ein wesentlicher Bestandteil des Renderprozesses, und wir können dies sehen, indem wir 1993 zurückkehren und id Software's Doom starten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fe/056/d0c/2fe056d0c0f37ac3a2970bdc485b79a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach modernen Maßstäben war die Verwendung von Licht und Schatten in diesem Spiel sehr primitiv: Die Lichtquellen wurden nicht berücksichtigt, jede Oberfläche, basierend auf ihren Eckpunkten, erhielt einen allgemeinen Farbwert oder den Wert des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebungslichts</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Alle Zeichen von Schatten wurden dank der gerissenen Verwendung von Texturen und der Wahl der Farbe der Umgebung erzeugt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab keine Schatten, weil sie nicht die Aufgabe von Programmierern waren: Der damalige PC war ein 66-MHz-Prozessor (dh 0,066 GHz!), Eine 40-MB-Festplatte und eine 512-Kilobyte-Grafikkarte mit minimalen 3D-Fähigkeiten. Schneller Vorlauf 23: Beim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berühmten Neustart der Serie sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir eine ganz andere Geschichte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b5/3ca/da0/3b53cada0530afabe788b4a70a0b7319.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viele Technologien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet, um diesen Rahmen zu rendern </font><font style="vertical-align: inherit;">. Er verfügt über Stufen wie die Okklusion des Bildschirmraums, die Tiefenabbildung vor dem Durchgang, Bokeh-Unschärfefilter, Tonkorrekturoperatoren usw. </font><font style="vertical-align: inherit;">Die Berechnung der Beleuchtung und Schattierung jeder Oberfläche erfolgt dynamisch: Sie ändern sich ständig in Abhängigkeit von den Umgebungsbedingungen und den Aktionen des Spielers.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da für jede 3D-Rendering-Operation Mathematik erforderlich ist (eine ganze Reihe von Berechnungen!), Beginnen wir besser mit dem, was hinter den Kulissen eines modernen Spiels passiert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mathe Beleuchtung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um alles richtig zu implementieren, müssen wir das Verhalten von Licht bei der Interaktion mit verschiedenen Oberflächen genau simulieren. Es ist merkwürdig, dass dieses Problem zum ersten Mal im 18. Jahrhundert von einem Mann namens Johann Heinrich Lambert gelöst wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1760 veröffentlichte ein Schweizer Wissenschaftler ein Buch namens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photometria</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Darin skizzierte er die Grundregeln des Verhaltens von Licht; Das bemerkenswerteste davon war das Folgende: Die Oberfläche emittiert Licht (durch Reflexion oder als Lichtquelle) so, dass sich die Helligkeit des emittierten Lichts in Abhängigkeit vom Kosinus des Winkels zwischen der normalen Oberfläche und dem Betrachter ändert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/6a2/f0c/2626a2f0c2f80f30bf5208decab2493c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese einfache Regel legte den Grundstein für die sogenannte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diffuse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beleuchtung. </font><font style="vertical-align: inherit;">Dies ist ein mathematisches Modell, mit dem die Farbe einer Oberfläche in Abhängigkeit von ihren physikalischen Eigenschaften (z. B. ihrer Farbe und dem Grad der Lichtreflexion) und dem Ort der Lichtquelle berechnet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim 3D-Rendering sind viele Informationen erforderlich, die sich in Form eines solchen Schemas am einfachsten vorstellen lassen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/d57/386/918d573864315b11e91405d8e692c59f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen viele Pfeile im Bild, dies </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind Vektoren</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und die folgenden Vektoren sind erforderlich, um die Farbe zu berechnen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 Vektoren für Scheitelpunktposition, Lichtquelle und Kamera, die die Szene betrachten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 Vektoren für die Richtungen der Lichtquelle und der Kamera aus Sicht des Scheitelpunkts</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 normaler Vektor</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Halbvektor (er befindet sich immer in der Mitte zwischen den Richtungsvektoren der Beleuchtung und der Kamera)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden in der Phase der Verarbeitung der Eckpunkte des Renderprozesses berechnet, und die Gleichung, die sie alle vereint (Lambert-Modell genannt), hat folgende Form:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/ba6/279/267ba627905209780406c2148469a7ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, die Farbe des Scheitelpunkts unter diffusem Licht wird berechnet, indem die Farbe der Oberfläche, die Farbe der Lichtquelle und das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalarprodukt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Normalenvektoren des Scheitelpunkts und die Lichtrichtung mit den Dämpfungs- und Projektionsbeleuchtungskoeffizienten multipliziert werden. </font><font style="vertical-align: inherit;">Diese Operation wird für jede Lichtquelle in der Szene ausgeführt, daher das Summensymbol am Anfang der Gleichung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vektoren in dieser Gleichung (und alles, was wir unten sehen) werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalisiert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (wie durch die Symbole über jedem Vektor gezeigt). </font><font style="vertical-align: inherit;">Der normalisierte Vektor behält seine ursprüngliche Richtung bei und seine Länge nimmt auf einen Einheitswert ab (d. H. Gleich 1 Maßeinheit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Farbwerte der Oberfläche und der Lichtquelle sind Standard-RGBA-Zahlen (Rot-, Grün-, Blau- und Alphatransparenz). Sie können ganzzahlig sein (z. B. INT8 für jeden Farbkanal), sind jedoch fast immer Gleitkommazahlen (z. B. FP32). Der Dämpfungskoeffizient bestimmt, wie der Beleuchtungsgrad abnimmt, wenn er sich von der Quelle entfernt, und wird durch eine andere Gleichung berechnet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/17e/a22/6ac17ea2263bf82f6a2e2571bd88e0b0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Begriffe A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind verschiedene Koeffizienten (konstant, linear, quadratisch), die beschreiben, wie sich der Abstand auf das Beleuchtungsniveau auswirkt. Alle werden von Programmierern beim Erstellen einer Rendering-Engine festgelegt. In jeder grafischen API wird dies auf ihre eigene Weise implementiert, aber beim Codieren des Lichtquellentyps werden Koeffizienten eingeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir den letzten Koeffizienten (Flutlicht) betrachten, ist anzumerken, dass es beim 3D-Rendering im Wesentlichen drei Arten von Lichtquellen gibt: Punkt-, Richtungs- und Scheinwerferlicht.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/2be/9ce/3492be9ce1ccf5526a05bb0702f84c35.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Punktquellen senden gleichmäßig Licht in alle Richtungen aus, und Richtungsquellen senden Licht nur in eine Richtung aus (aus mathematischer Sicht ist dies nur eine Punktquelle, die in unendlicher Entfernung entfernt ist). Scheinwerfer sind komplexe Richtungsquellen, da sie Licht in Form eines Kegels emittieren. Die Art und Weise, wie Licht im Körper des Kegels variiert, bestimmt die Größe des inneren und äußeren Teils des Kegels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und ja, für den Suchscheinwerferkoeffizienten gibt es eine andere Gleichung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06a/b47/d9c/06ab47d9c2a0f7d85519d5de77cb299b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wert des Projektorkoeffizienten ist entweder 1 (d. H. Die Quelle ist </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projektor) oder 0 (wenn der Scheitelpunkt außerhalb der Kegelrichtung liegt) oder ein berechneter Wert zwischen den beiden. Die Winkel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">φ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (phi) und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">θ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Theta) geben die Abmessungen des inneren / äußeren Teils des Kegels des Scheinwerfers an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei Vektoren: L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dcs</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dir</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (umgekehrt zur </font><sub><font style="vertical-align: inherit;">Kamerarichtung</font></sub><font style="vertical-align: inherit;"> und </font><font style="vertical-align: inherit;">Scheinwerferrichtung) werden verwendet, um zu bestimmen, ob sich der Kegel des Scheitelpunkts berührt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sollten wir uns daran erinnern, dass all dies notwendig ist, um den Wert der diffusen Beleuchtung zu berechnen, und dass alle diese Operationen für </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jede ausgeführt werden müssen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Lichtquelle in der Szene oder zumindest für jede Quelle, die der Programmierer berücksichtigen wollte. Viele dieser Gleichungen werden von grafischen APIs ausgeführt, können jedoch auch manuell ausgeführt werden, wenn Encoder mehr Kontrolle über das Bild benötigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der realen Welt gibt es jedoch </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unendlich</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> viele Lichtquellen: Jede Oberfläche reflektiert die Beleuchtung, sodass sie alle die Gesamtbeleuchtung der Szene beeinflussen. Selbst nachts gibt es Hintergrundbeleuchtung, egal ob es sich um Sterne und Planeten oder um in der Atmosphäre gestreutes Licht handelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu simulieren, wird ein anderer Beleuchtungswert berechnet: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebungsbeleuchtung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/73b/e8e/94473be8edd6d85ce822d059f021d9a7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Gleichung ist einfacher als bei diffuser Beleuchtung, da keine Richtungen erforderlich sind. </font><font style="vertical-align: inherit;">Hier wird eine einfache Multiplikation verschiedener Koeffizienten durchgeführt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Oberflächenbeleuchtungsfarbe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Markieren Sie die Farbe der globalen 3D-Szene</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Beleuchtungsfarbe aller Lichtquellen in der Szene</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist anzumerken, dass die Dämpfungs- und Projektorkoeffizienten sowie die Summe aller Lichtquellen erneut verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also Hintergrundbeleuchtung und haben die diffuse Beleuchtung von Lichtquellen von verschiedenen Oberflächen der 3D-Welt berücksichtigt. Das Lambert-Modell funktioniert jedoch nur für Materialien, die das Licht von seiner Oberfläche in alle Richtungen reflektieren. Objekte aus Glas oder Metall schafft eine </font><font style="vertical-align: inherit;">andere Art der Reflexion genannt hergestellt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spiegelnde</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; Natürlich gibt es auch für ihn eine Gleichung!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/a60/a49/d6ba60a49dae7eb88da90c7ef26936bf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einzelnen Teile dieser Formel sollten Ihnen bereits bekannt sein: Wir haben zwei Werte für die Spiegelfarbe (einen für die Oberfläche - C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , den anderen für Licht - C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LS</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sowie die üblichen Dämpfungs- und Flutfaktoren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Spiegelreflexion sehr fokussiert und gerichtet ist, werden zwei Vektoren verwendet, um die Helligkeit der Spiegelbeleuchtung zu bestimmen: die Scheitelpunktnormalen und der Halbvektor. Der Koeffizient </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiegelreflexionskraft bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist eine Zahl, die die Helligkeit der Reflexion in Abhängigkeit von den Eigenschaften des Oberflächenmaterials bestimmt. Mit zunehmendem p wird der Spiegeleffekt heller, aber fokussierter und kleiner.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte zu berücksichtigende Element ist das einfachste, da es sich nur um eine Zahl handelt. </font><font style="vertical-align: inherit;">Es wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emittierende</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beleuchtung bezeichnet und auf Objekte angewendet, die eine direkte Lichtquelle darstellen, dh auf eine Flamme, eine Taschenlampe oder die Sonne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass wir jetzt eine Zahl und drei Gleichungssysteme zur Berechnung der Farbe des Scheitelpunkts der Oberfläche haben, wobei die Hintergrundbeleuchtung (Umgebung) sowie die Wechselwirkung zwischen verschiedenen Lichtquellen und den Eigenschaften des Oberflächenmaterials (diffus und spiegelnd) berücksichtigt werden. </font><font style="vertical-align: inherit;">Programmierer können nur eine auswählen oder alle vier kombinieren, indem sie sie einfach falten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/5d4/fc3/6795d4fc38199eed97d7e1fb875556d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optisch sieht die Kombination folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/be2/f53/158be2f5318b5cbb2a142e166d1299ad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die von uns berücksichtigten Gleichungen werden von grafischen APIs (z. B. Direct3D und OpenGL) unter Verwendung ihrer Standardfunktionen angewendet. Für jede Beleuchtungsart gibt es jedoch alternative Algorithmen. </font><font style="vertical-align: inherit;">Beispielsweise kann eine diffuse Beleuchtung mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Oren-Nayyar-Modell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert werden </font><font style="vertical-align: inherit;">, das für sehr raue Oberflächen besser geeignet ist als das Lambert-Modell. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Spiegelreflexionsgleichung kann durch Modelle ersetzt werden, die die Tatsache berücksichtigen, dass sehr glatte Oberflächen wie Glas oder Metall immer noch rau sind, jedoch auf mikroskopischer Ebene. </font><font style="vertical-align: inherit;">Solche Modelle, sogenannte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikrofacettenalgorithmen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , liefern auf Kosten der mathematischen Komplexität realistischere Bilder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig davon, welches Modell verwendet wird, werden sie alle erheblich verbessert, indem die Häufigkeit ihrer Anwendung auf die 3D-Szene erhöht wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertex- oder Pixel-für-Pixel-Berechnungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Untersuchung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheitelpunktverarbeitung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-rasterung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben wir </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">festgestellt</font></a><font style="vertical-align: inherit;"> , dass die Ergebnisse aller kniffligen Beleuchtungsberechnungen, die für jeden Scheitelpunkt durchgeführt wurden, über die Oberfläche zwischen den Scheitelpunkten interpoliert werden sollten. </font><font style="vertical-align: inherit;">Dies liegt daran, dass die mit dem Oberflächenmaterial verbundenen Eigenschaften innerhalb der Scheitelpunkte gespeichert werden. </font><font style="vertical-align: inherit;">Wenn die 3D-Welt in ein 2D-Pixelraster komprimiert wird, bleiben die Pixel nur dort, wo sich der Scheitelpunkt befand.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/129/bc3/e90/129bc3e90652de62263813f5274dea2c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die restlichen Pixel müssen Informationen über die Farbe der Scheitelpunkte übertragen, damit sich die Farben auf der Oberfläche korrekt mischen. Im Jahr 1971 schlug </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Henri Gouraud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , damals Doktorand an der Universität von Utah, eine Methode vor, die jetzt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud Shading heißt</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seine Methode war rechnerisch schnell und wurde viele Jahre lang zum </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De-facto-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standard, aber er hatte auch Probleme. Er konnte die Spiegelbeleuchtung nicht richtig interpolieren, und wenn das Objekt aus einer kleinen Anzahl von Grundelementen bestand, schien das Mischen zwischen den Grundelementen falsch zu sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Lösung für dieses Problem wurde 1973 von Bui Tyong Fong vorgeschlagen, der auch an der Universität von Utah arbeitete. In seinem Forschungsartikel demonstrierte Fong eine Technik zur Interpolation der Normalen von Eckpunkten auf gerasterten Oberflächen. Dies bedeutete, dass die Streu- und Spiegelreflexionsmodelle für jedes Pixel korrekt funktionieren würden, und wir können dies deutlich in </font><font style="vertical-align: inherit;">David Ecks </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Online-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Computergrafik- und WebGL- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Tutorial sehen</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die unten gezeigten Kohlenstoffkugeln werden mit demselben Beleuchtungsmodell gefärbt, aber für linkshändige Berechnungen werden sie vertikal ausgeführt, gefolgt von einer Gouraud-Schattierung, um sie über die gesamte Oberfläche zu interpolieren. Für die Kugel rechts werden die Berechnungen Pixel für Pixel durchgeführt, und der Unterschied ist offensichtlich.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/5b1/329/10a5b13292d99d5250cfbfba7c737a6a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standbilder vermitteln nicht alle Verbesserungen, die durch das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattieren von Phong erzielt wurden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber Sie können die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Online-Demo von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ek </font><font style="vertical-align: inherit;">unabhängig ausführen </font><font style="vertical-align: inherit;">und die Animation ansehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fong hörte hier jedoch nicht auf und veröffentlichte einige Jahre später einen weiteren Forschungsartikel, in dem er zeigte, wie getrennte Berechnungen für Umgebungsreflexion, diffuse Reflexion und Spiegelreflexion mit einer einfachen Gleichung durchgeführt werden können:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/cf9/613/0c0cf9613d8d536c4cdb16750bbca092.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier müssen wir ernsthaft verstehen! Die durch den Buchstaben </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegebenen Werte </font><font style="vertical-align: inherit;">sind die Reflexionskonstanten für die Umgebungs-, diffusen und Spiegelreflexionen. Jeder von ihnen ist ein Bruchteil der entsprechenden Art des reflektierten Lichts von der Größe des einfallenden Lichts; </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte, die </font><font style="vertical-align: inherit;">wir in den obigen Gleichungen gesehen haben (Farbwerte des Oberflächenmaterials für jede Beleuchtungsart). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vektor </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der </font><font style="vertical-align: inherit;">Vektor </font><font style="vertical-align: inherit;">der „perfekten Reflexion“ - die Richtung, in die sich das reflektierte Licht bewegen würde, wenn die Oberfläche perfekt glatt wäre; Sie wird unter Verwendung der Oberflächennormalen und des einfallenden Lichtvektors berechnet. Vektor </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Kamerarichtungsvektor; und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C sind</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normalisiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich gibt es die letzte Konstante in der Gleichung: Der Wert von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">α</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bestimmt den Grad des Oberflächenglanzes. Je glatter das Material ist (d. H. Je mehr es Glas oder Metall ähnelt), desto höher ist die Anzahl. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Gleichung wird üblicherweise als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phong-Reflexionsmodell bezeichnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zum Zeitpunkt seiner Forschung war ein solcher Vorschlag radikal, da er ernsthafte Rechenressourcen erforderte. Eine vereinfachte Version des Modells wurde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jim Blinn erstellt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ersetzte den Teil der Formel von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Halbabstandsvektor und Oberflächennormale). Der Wert von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss für jede Lichtquelle und für jedes Pixel im Rahmen berechnet werden, und</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reicht aus, um für jede Quelle und für die gesamte Szene einmal zu berechnen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Blinn-Fong-Reflexionsmodell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist heute das Standardbeleuchtungssystem und wird standardmäßig in Direct3D, OpenGL, Vulkan usw. verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele andere mathematische Modelle, insbesondere jetzt, wo GPUs Pixel in langen und komplexen Shadern verarbeiten können. zusammen werden solche Formeln als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidirektionale Reflexions- / Transmissionsverteilungsfunktionen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BRDF / BTFD) bezeichnet; Sie sind die Grundlage für die Färbung jedes Pixels auf dem Monitor, wenn wir moderne 3D-Spiele spielen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir jedoch nur Oberflächen betrachtet, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Licht </font><em><font style="vertical-align: inherit;">reflektieren</font></em><font style="vertical-align: inherit;"> : Durchscheinende Materialien lassen Licht durch, während die Lichtstrahlen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gebrochen werden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und einige Oberflächen. </font><font style="vertical-align: inherit;">Beispielsweise reflektiert und lässt Wasser Licht in unterschiedlichem Maße durch.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bringen die Beleuchtung auf ein neues Niveau</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns das </font><font style="vertical-align: inherit;">Ubisoft </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assassin's Creed: Odyssey-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel </font><font style="vertical-align: inherit;">2018 an </font><font style="vertical-align: inherit;">, in dem der Spieler häufig unter Wasser segelt, sowohl in flachen Flüssen als auch in der Tiefsee.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/032/29d/358/03229d3582d6b574b0089a5480cfc08b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bemaltes Holz, Metall, Seile, Stoff und Wasser - all dies reflektiert und bricht das Licht mithilfe einer Reihe von Berechnungen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Für die realistischste Darstellung von Wasser bei gleichbleibender Spielgeschwindigkeit verwendeten Ubisoft-Programmierer eine ganze Reihe von Tricks. Die Wasseroberfläche wird von dem bekannten Trio aus Umgebungslicht, diffusem und spiegelndem Licht beleuchtet, das jedoch durch interessante Merkmale ergänzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste davon wird häufig verwendet, um die Reflexionseigenschaften von Wasser zu erzeugen - dies sind </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screen Space Reflections</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SSR). Diese Technik rendert die Szene, aber die Farben der Pixel hängen von der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Pixels ab, d.h. aus seiner Entfernung zur Kamera. Die </font><font style="vertical-align: inherit;">Tiefe wird in dem sogenannten gespeicherten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefenpuffer</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann wird der Rahmen erneut mit der üblichen Beleuchtung und </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerendert, aber die Szene wird als </font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Rendertextur</font></a></em><font style="vertical-align: inherit;"> gespeichert </font><font style="vertical-align: inherit;">und nicht als fertiger Puffer, der an den Monitor übertragen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach wird ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strahlenmarsch</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durchgeführt </font><font style="vertical-align: inherit;">. Dazu werden Strahlen von der Kamera ausgesendet und Entfernungen entlang des Strahlverlaufs eingestellt. Der Code überprüft die Tiefe des Strahls relativ zu den Pixeln im Tiefenpuffer. Wenn sie denselben Wert haben, überprüft der Code das normale Pixel, um festzustellen, ob es auf die Kamera gerichtet ist. In diesem Fall sucht die Engine nach dem entsprechenden Pixel aus der Rendertextur. Dann kehrt ein weiterer Befehlssatz die Position des Pixels um, so dass es korrekt in der Szene reflektiert wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/58b/1d1/64558b1d13b6bc349bd728278ec9686a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die SSR-Reihenfolge, die in der Frostbite-Engine von EA verwendet wird.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Zusätzlich wird Licht während der Bewegung innerhalb von Materialien gestreut, und für Materialien wie Wasser oder Leder wird ein anderer Trick verwendet, der als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untergrundstreuung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SSS) bezeichnet wird. Wir werden es nicht im Detail erklären, aber Sie können in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Nvidia-Präsentation 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen, wie es verwendet wird, um so erstaunliche Ergebnisse zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">erzielen</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23c/0e1/598/23c0e15983c2cfe6b17ba3d0aab97dc5.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidias FaceWorks-Demo 2013 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">Kehren</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wir zu Assassins Creed Water zurück: Die SSS-Implementierung ist hier kaum erkennbar und wird aus Geschwindigkeitsgründen nicht so häufig verwendet. In früheren Spielen der AC-Serie verwendete Ubisoft </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gefälschtes SSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber im letzten Spiel ist seine Verwendung komplizierter, aber immer noch nicht so groß wie in der Nvidia-Demo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Beleuchtungswerte auf der Wasseroberfläche zu ändern, werden zusätzliche Verfahren durchgeführt, die die Auswirkungen der Tiefe aufgrund einer Änderung der Transparenz in Abhängigkeit von der Entfernung zur Küste korrekt simulieren. Und wenn die Kamera das küstennahe Wasser betrachtet, werden noch mehr Algorithmen verwendet, um Ätz- und Brechungsfaktoren zu berücksichtigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse sind beeindruckend:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb2/486/f56/cb2486f5697db7c578797127371af936.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assassin's Creed: Odyssey - Wasser in seiner ganzen Pracht wiedergeben.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wir haben uns Wasser angesehen, aber was ist mit der Bewegung von Licht in der Luft? Staubpartikel, Feuchtigkeit und andere Elemente führen ebenfalls zu Lichtstreuung. Infolgedessen erhalten die Lichtstrahlen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volumen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bleiben nicht nur ein Satz direkter Strahlen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Thema volumetrische Beleuchtung kann auf ein Dutzend Artikel erweitert werden, daher werden wir darüber sprechen, wie das Spiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rise of the Tomb Raider damit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umgeht </font><font style="vertical-align: inherit;">. Im Video unten gibt es nur eine Hauptlichtquelle - die Sonne scheint durch die Öffnung im Gebäude.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/3w9rHXIYjI4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Lichtvolumen zu erzeugen, nimmt die Spiel-Engine die Sichtbarkeitspyramide der Kamera (siehe unten) und zerlegt sie exponentiell in 64 Teile. Anschließend wird jedes Slice in Raster mit einer Größe von 160 x 94 Elementen gerastert, und alle diese Daten werden in einer dreidimensionalen Rendertextur des FP32-Formats gespeichert. Da Texturen normalerweise zweidimensional sind, werden die "Pixel" des Pyramidenvolumens als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxel bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/857/5cf/3b18575cfb0114e1b8ba8c152c4c4bd1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen 4 x 4 x 4-Voxelblock </font><font style="vertical-align: inherit;">bestimmen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computershader</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , welche aktiven Lichtquellen dieses Volumen beeinflussen, und schreiben diese Informationen dann in eine andere dreidimensionale Rendertextur. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20141102063940/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Gesamtdichte des Lichts innerhalb des </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20141102063940/" rel="nofollow"><font style="vertical-align: inherit;">Voxelblocks abzuschätzen</font></a><font style="vertical-align: inherit;"> , wird eine komplexe Formel verwendet, die als </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20141102063940/" rel="nofollow"><font style="vertical-align: inherit;">Hengy-Greenstein-Streufunktion bezeichnet wird</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann führt der Motor mehrere weitere Shader durch, um die Daten zu verfeinern. Danach wird ein Strahlenmarsch entlang der Scheiben der Pyramide mit der Akkumulation von Lichtdichtewerten durchgeführt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eidos-Montréal behauptet,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass alle diese Vorgänge auf Xbox One ungefähr 0,8 Millisekunden dauern!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl diese Technik nicht in allen Spielen verwendet wird, erwarten die Spieler eine volumetrische Abdeckung in fast allen heute veröffentlichten 3D-Spielen, insbesondere in Ego-Shootern und Action-Adventure-Spielen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/e06/b34/064e06b347c8e5cafe892fbdde2d14de.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die volumetrische Beleuchtung im Rise of the Tomb Raider Fortsetzung von 2018. verwendet</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Anfangs wurde diese Lichttechnik „göttlichen Strahlen“ genannt, oder, wie sie wissenschaftlich genannt werden, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Dämmerung Strahlen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">“</font></em><font style="vertical-align: inherit;"> Eines der ersten Spiele, in denen es verwendet wurde, war </font><font style="vertical-align: inherit;">Cryteks </font><font style="vertical-align: inherit;">erste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crysis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die 2007 veröffentlicht wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies war jedoch keine echte volumetrische Beleuchtung - der Prozess umfasste das anfängliche Rendern der Szene in Form eines Tiefenpuffers, der als Maske verwendet wurde - ein weiterer Puffer, in dem die Pixelfarben dunkler wurden, je näher sie an der Kamera waren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Maskenpuffer wurde mehrmals abgetastet, und der Shader nahm Proben und mischte sie durch Verwischen zusammen. Das Ergebnis dieser Operation wurde mit der fertigen Szene gemischt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d9/f9b/891/5d9f9b891a670f005d77704953040215.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fortschritt der Grafikkarten in den letzten 12 Jahren war enorm. </font><font style="vertical-align: inherit;">Die leistungsstärksten GPUs zum Zeitpunkt der Veröffentlichung von Crysis waren die Nvidia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce 8800 Ultra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die schnellste moderne GPU - die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce RTX 2080 Ti</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügt über mehr als 30-mal mehr Rechenleistung, 14-mal mehr Speicher und 6-mal mehr Bandbreite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit all dieser Rechenleistung können moderne Spiele trotz der zunehmenden Komplexität des Renderns eine viel größere Grafikgenauigkeit und Gesamtgeschwindigkeit bieten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d73/9bf/541/d739bf54169f0900929280cee0d4553b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Göttliche Strahlen“ in Ubisofts The Division 2</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tatsächlich zeigt dieser Effekt jedoch, dass trotz der Bedeutung einer korrekten Beleuchtung für die visuelle Genauigkeit die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abwesenheit von</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Licht </font><font style="vertical-align: inherit;">sogar noch wichtiger ist </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essenz des Schattens</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir einen neuen Abschnitt des Artikels mit dem Spiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In der Abbildung unten sind alle Grafikoptionen für Schatten deaktiviert. </font><font style="vertical-align: inherit;">rechts sind sie enthalten. </font><font style="vertical-align: inherit;">Der Unterschied ist riesig, oder?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/6db/855/3996db855ea5a727cc8b8c8e565227d8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da sich in der realen Welt natürlich Schatten bilden, werden Spiele, in denen sie falsch implementiert sind, niemals richtig aussehen. </font><font style="vertical-align: inherit;">Unser Gehirn ist es gewohnt, Schatten als visuelle Unterstützung zu verwenden, um ein Gefühl von relativer Tiefe, Position und Bewegung zu erzeugen. </font><font style="vertical-align: inherit;">Aber es in einem 3D-Spiel zu machen, ist überraschend schwierig oder zumindest schwierig, es richtig zu machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Ente. </font><font style="vertical-align: inherit;">Hier bewegt sie sich auf dem Feld, und die Sonnenstrahlen erreichen sie und werden korrekt blockiert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2ad/1d8/f3f2ad1d84f865217d5e28cfaab98604.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der ersten Möglichkeiten, den Schatten in der Szene zu implementieren, bestand darin, einen „Schattenpunkt“ unter dem Modell hinzuzufügen. Dies ist völlig unrealistisch, da die Form des Schattens nicht mit der Form des Objekts übereinstimmt, das den Schatten wirft. Dieser Ansatz ist jedoch schnell und einfach zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten 3D-Spiele, zum Beispiel der erste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomb Raider von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1996, verwendeten diese Methode, weil die Hardware dieser Zeit, zum Beispiel Sega Saturn und Sony PlayStation, nichts Besseres bieten konnte. Diese Methode malte einen einfachen Satz von Grundelementen direkt über die Oberfläche, auf der sich das Modell bewegt, und schattierte sie dann. Es wurde auch das Zeichnen am unteren Rand einer einfachen Textur verwendet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/1b8/735/3ad1b8735674a430a18559fc87a28baa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere der ersten Methoden war das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projizieren von Schatten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In diesem Fall wurde das einen Schatten emittierende Grundelement auf eine Ebene projiziert, die den Boden enthielt. </font><font style="vertical-align: inherit;">Ein Teil der dafür notwendigen mathematischen Berechnungen wurde Ende der 80er Jahre von Jim Blinn erstellt. </font><font style="vertical-align: inherit;">Nach modernen Maßstäben ist dies ein einfacher Prozess, der am besten für einfache statische Objekte geeignet ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/130/ced/f47/130cedf47748e034cd6c87d98da9e487.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank der Optimierung wurden durch die Schattenprojektion die ersten würdigen Beispiele für dynamische Schatten geschaffen, beispielsweise im Spiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingpin: Life of Crime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Interplay aus </font><font style="vertical-align: inherit;">dem Jahr 1999 </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie wir im Bild unten sehen, haben nur animierte Charaktere (sogar Ratten!) Schatten, aber dies ist besser als einfache Punkte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/dc7/5a1/2eadc75a107ec0eec8a3c0bc37497b64.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die schwerwiegendsten Probleme bei diesem Ansatz sind: (a) die perfekte Opazität des Schattens und (b) die Projektionsmethode emittiert den Schatten auf einer ebenen Fläche (z. B. auf dem Boden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Probleme können gelöst werden, indem beim Färben des projizierten Grundelements und beim Ausführen mehrerer Projektionen für jedes Zeichen ein Teil der Transparenz angewendet wird. Die PC-Hardwarefunktionen der späten 90er Jahre konnten das zusätzliche Rendering jedoch nicht bewältigen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moderne Technologie zur Erzeugung von Schatten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine genauere Methode zur Implementierung von Schatten wurde bereits 1977 viel früher vorgeschlagen. Während an der Universität von Austin (Texas) arbeitet, schrieb Franklin Crowe einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forschungs - </font><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in dem er mehrere Techniken vorgeschlagen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattenvolumen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen können sie wie folgt beschrieben werden: Der Prozess bestimmt, welche Grundelemente auf die Lichtquelle gerichtet sind; Ihre Rippen sind zu einer Ebene gespannt. Während dies der Projektion von Schatten sehr ähnlich ist, besteht der wichtige Unterschied darin, dass das erzeugte Schattenvolumen dann verwendet wird, um zu überprüfen, ob sich das Pixel innerhalb / außerhalb des Volumens befindet. Dank dieser Informationen können Schatten auf alle Oberflächen und nicht nur auf den Boden abgegeben werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Technik wurde 1991 von Tim Heidmann verbessert, der daran arbeitete</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siliziumgrafiken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Kilgard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> war 1999 an seiner Weiterentwicklung beteiligt </font><font style="vertical-align: inherit;">, und die Methode, die wir in Betracht ziehen werden, wurde im Jahr 2000 von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Carmack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von id Software entwickelt (obwohl Carmacks Methode zwei Jahre zuvor von Bilodo und Songa von Creative Labs unabhängig eröffnet wurde; dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carmack gezwungen war, seinen Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ändern</font></a><font style="vertical-align: inherit;"> , um rechtliche Probleme zu vermeiden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz erfordert das Rendern mehrerer Frames ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multipass-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering genannt - ein </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> teurer Prozess in den frühen 90er Jahren, der heute überall verwendet wird) und ein Konzept namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schablonenpuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu Bildpuffern und Tiefen wird es nicht von der 3D-Szene selbst erstellt. Dieser Puffer ist ein Array von Werten, die in allen Dimensionen (d. H. Auflösung in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in Form eines Rasters gleich sind. </font><font style="vertical-align: inherit;">Die darin gespeicherten Werte werden verwendet, um der Rendering-Engine mitzuteilen, was mit jedem Pixel im Bildpuffer zu tun ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das einfachste Beispiel für die Verwendung dieses Puffers ist die Verwendung als Maske:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b99/dfa/f1c/b99dfaf1c876fb4ed736c5947460efbd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode mit dem Schattenvolumen wird ungefähr so ​​ausgeführt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir rendern die Szene in den Bildspeicher, verwenden jedoch nur die Umgebungsbeleuchtung (wir enthalten auch alle Emissionswerte, wenn das Pixel eine Lichtquelle enthält).</font></font></li>
<li>  ,    ,    (  <em>   (back-face culling)</em>).        (,  )         .   <em></em>   (..     «»)    -     .</li>
<li>  ,       (front-face culling)    -,     .</li>
<li>   ,        ,       -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Schablonenpuffer und Schattenvolumina (allgemein als Schablonenschatten bezeichnet) wurden im 2004 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> id Software-Spiel verwendet </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/015/720/5010157201afaff6066d609748a40eae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass die Oberfläche, auf der der Charakter läuft, immer noch durch den Schatten sichtbar ist? Dies ist der erste Vorteil gegenüber der Schattenprojektion. Darüber hinaus können Sie mit diesem Ansatz den Abstand zur Lichtquelle berücksichtigen (wodurch schwächere Schatten erhalten werden) und Schatten auf jede Oberfläche (einschließlich des Zeichens selbst) werfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Technik weist jedoch schwerwiegende Nachteile auf, von denen der auffälligste darin besteht, dass die Kanten des Schattens vollständig von der Anzahl der Grundelemente abhängen, die zum Erstellen des Objekts verwendet werden, das den Schatten wirft. Darüber hinaus ist Multipassing mit vielen Lese- / Schreibvorgängen in den lokalen Speicher verbunden, weshalb die Verwendung von Schablonenschatten im Hinblick auf die Leistung recht kostspielig ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus gibt es eine Begrenzung für die Anzahl der Schattenvolumes, die mit dem Schablonenpuffer überprüft werden können, da alle Grafik-APIs eine relativ kleine Anzahl von Bits darauf zuweisen (normalerweise nur 8). Aufgrund des Rechenaufwands von Schablonenschatten tritt dieses Problem jedoch normalerweise nicht auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt noch ein anderes Problem - die Schatten selbst sind alles andere als realistisch. Warum? Weil alle Lichtquellen - Lampen, offene Flammen, Laternen und die Sonne - keine einzelnen Punkte im Raum sind, d.h. Sie strahlen Licht in einem bestimmten Bereich aus. Selbst im einfachsten Fall, der unten gezeigt wird, haben echte Schatten selten scharf definierte Kanten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/6b4/52b/b7c6b452bacb558d508a751c5bdebdb1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die dunkelste Schattenregion wird als Vollschatten (Umbra) bezeichnet. </font><font style="vertical-align: inherit;">Halbschatten ist immer ein hellerer Schatten, und die Grenze zwischen den beiden ist oft unscharf (weil es normalerweise viele Lichtquellen gibt). </font><font style="vertical-align: inherit;">Es ist schwierig, dies mit Schablonenpuffern und Volumes zu modellieren, da die erstellten Schatten in einer falschen Form gespeichert werden, damit sie verarbeitet werden können. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow Mapping</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kommt zur Rettung </font><font style="vertical-align: inherit;">! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das grundlegende Verfahren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde 1978 von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lance Williams entwickelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist ziemlich einfach:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für jede Lichtquelle rendern wir die Szene aus der Sicht dieser Quelle und erstellen eine spezielle Textur der Tiefen (dh ohne Farbe, Beleuchtung, Texturierung usw.). </font><font style="vertical-align: inherit;">Die Auflösung dieses Puffers muss nicht der Größe des fertigen Rahmens entsprechen, aber je höher desto besser.</font></font></li>
<li>      ,        (  x,y  z) ,        .</li>
<li>          :   ,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist natürlich ein weiteres Verfahren mit mehreren Durchgängen, aber der letzte Schritt kann mithilfe von Pixel-Shadern ausgeführt werden, sodass die Tiefenprüfung und die nachfolgenden Beleuchtungsberechnungen in einem Durchgang kombiniert werden. Und da der gesamte Prozess der Schattenerstellung nicht von der Anzahl der verwendeten Grundelemente abhängt, ist er viel schneller als die Verwendung des Schablonenpuffers und des Schattenvolumens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider erzeugt die oben beschriebene grundlegende Technik alle Arten von visuellen Artefakten (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perspektivisches Aliasing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Schattenakne“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , „Peter Panning“), von denen die meisten mit der Auflösung und Bitgröße der Tiefenstruktur zusammenhängen. Alle GPUs und Grafik-APIs weisen ähnliche Einschränkungen wie Texturen auf. Daher wurde eine ganze Reihe zusätzlicher Techniken entwickelt, um diese Probleme zu lösen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der Vorteile der Verwendung von Texturen für Tiefeninformationen besteht darin, dass GPUs sie sehr schnell und auf viele verschiedene Arten abtasten und filtern können. Im Jahr 2005 demonstrierte Nvidia eine Texturabtastmethode, mit der einige der visuellen Probleme gelöst werden können, die durch Standardschatten verursacht werden. Außerdem sorgte er für ein gewisses Maß an Glätte der Schattenkanten; Diese Technik wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prozentuale Nahfilterung bezeichnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/5bf/c31/4c05bfc31232887519a64eb7995e7d7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etwa zur gleichen Zeit demonstrierte Futuremark die Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaskadierten Schattenkarten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (CSM) in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3DMark06</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist eine Technik, bei der für jede Lichtquelle mehrere Tiefenstrukturen mit unterschiedlichen Auflösungen erstellt werden. Hochauflösende Texturen werden in der Nähe der Quelle und niedriger verwendet - in einem Abstand von der Quelle. Das Ergebnis sind glattere Schattenübergänge in der Szene ohne Verzerrung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Technik wurde 2006 von Donnelly und Loritzen in ihrem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varianzschatten-Mapping-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">(VSM) sowie von Intel im Jahr 2010 in ihrem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample Distribution Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SDSM) </font><font style="vertical-align: inherit;">verbessert </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/91a/0d8/a2f91a0d8f6c22ba64ab03aeccf50b00.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von SDSM in Shadow of the Tomb Raider</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Um das Bild zu verbessern, verwenden Spieleentwickler häufig ein ganzes Arsenal an Schattierungstechniken, die wichtigste bleibt jedoch die Schattenzuordnung. Es kann jedoch nur auf eine kleine Anzahl aktiver Lichtquellen angewendet werden. Wenn Sie versuchen, es für jede Oberfläche zu modellieren, die Licht reflektiert oder emittiert, sinkt die Bildrate katastrophal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise gibt es eine praktische Technik, die mit jedem Objekt funktioniert. Es entsteht der Eindruck einer Abnahme der Helligkeit der Beleuchtung, die das Objekt erreicht (aufgrund der Tatsache, dass er oder andere Objekte das Licht ein wenig blockieren). Diese Funktion wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebungsokklusion bezeichnet.</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sie hat viele Versionen. Einige von ihnen wurden speziell von Hardwareherstellern entwickelt, z. B. von AMD entwickelte HDAO ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High Definition Ambient Occlusion</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und Nvidia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HBAO +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizon Based Ambient Occlusion</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig davon, welche Version verwendet wird, wird sie angewendet, nachdem die Szene vollständig gerendert wurde, und wird daher als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbearbeitungseffekt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> klassifiziert </font><font style="vertical-align: inherit;">. Tatsächlich wird für jedes Pixel berechnet, wie viel wir in der Szene sehen (mehr dazu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), indem der Wert der Pixeltiefe mit den Pixeln verglichen wird, die ihn an dem entsprechenden Punkt im Tiefenpuffer umgeben (der wiederum als Textur gespeichert ist).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Abtasten des Tiefenpuffers und das anschließende Berechnen der endgültigen Pixelfarbe spielt eine wichtige Rolle bei der Sicherstellung der Qualität der Umgebungsokklusion. </font><font style="vertical-align: inherit;">Wie im Fall von Shadowing muss der Programmierer bei allen Versionen der Umgebungsokklusion für den ordnungsgemäßen Betrieb den Code je nach Situation sorgfältig konfigurieren und anpassen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4e/865/e15/f4e865e159dfa5e83286e1245a5b46f9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider ohne AO ​​(links) und mit HBAO + (rechts)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei richtiger Implementierung hinterlässt dieser visuelle Effekt jedoch einen tiefen Eindruck. </font><font style="vertical-align: inherit;">Achten Sie im obigen Bild auf die Hände, Ananas und Bananen der Person sowie auf das umgebende Gras und die Vegetation. </font><font style="vertical-align: inherit;">Die Farbänderungen bei HBAO + -Pixeln sind recht gering, aber alle Objekte sehen jetzt besser in die Umgebung eingebaut aus (links scheint es, dass eine Person über dem Boden hängt).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eines der letzten in diesem Artikel beschriebenen Spiele auswählen, entspricht die Liste der Rendering-Techniken, die bei der Verarbeitung von Licht und Schatten verwendet werden, der Länge des Artikels. Obwohl nicht jedes neue 3D-Spiel über all diese Technologien verfügt, können Sie sie mit universellen Spiel-Engines wie Unreal optional aktivieren, und Toolkits (z. B. Nvidia-Unternehmen) bieten einen Code, der zum Einfügen in das Spiel bereit ist. Dies beweist, dass es sich nicht um hochspezialisierte hochmoderne Methoden handelt, die einst den besten Programmierern gehörten und jetzt jedem zur Verfügung stehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können diesen Artikel über Licht und Schatten nicht vervollständigen, ohne Raytracing zu erwähnen. Wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben bereits</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dieser Artikelserie </font><font style="vertical-align: inherit;">über diesen Prozess </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">gesprochen</font></a><font style="vertical-align: inherit;"> , aber über den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktuellen Stand der Technologieentwicklung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert eine niedrige Bildrate und einen erheblichen Geldaufwand. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Technologie wird jedoch von Konsolen der nächsten Generation, Microsoft und Sony, unterstützt. Dies bedeutet, dass ihre Verwendung in den nächsten Jahren zu einem weiteren Standardwerkzeug für Entwickler auf der ganzen Welt werden wird, die die visuelle Qualität von Spielen verbessern möchten. </font><font style="vertical-align: inherit;">Schauen Sie sich an, was Remedy in ihrem neuesten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel erreicht hat </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gJ7gdBGXODI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind weit von falschen Schatten in Texturen und einfacher Umgebungsbeleuchtung entfernt!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist nicht alles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Artikel haben wir versucht, über die grundlegenden mathematischen Berechnungen und Techniken zu sprechen, die in 3D-Spielen verwendet werden, um sie so realistisch wie möglich zu gestalten. </font><font style="vertical-align: inherit;">Wir haben auch die Technologien untersucht, die der Modellierung der Wechselwirkung von Licht mit Objekten und Materialien zugrunde liegen. </font><font style="vertical-align: inherit;">Aber das alles war nur die Spitze des Eisbergs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel haben wir Themen wie energiesparende Beleuchtung, Linseneffekt, Blüte, hochdynamisches Rendering, Strahlungsübertragung, Tonkorrektur, Nebel, chromatische Aberration, Photonenkartierung, Kaustik und Radiosität übersprungen - diese Liste geht weiter. </font><font style="vertical-align: inherit;">Eine kurze Studie würde 3-4 weitere Artikel erfordern.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501426/index.html">Unison: Einrichten und Automatisieren der bidirektionalen Synchronisierung von Verzeichnissen auf zwei Servern</a></li>
<li><a href="../de501430/index.html">Großartiger Leitfaden für die Gestaltung und Planung von Website-Inhalten</a></li>
<li><a href="../de501432/index.html">Zwei Alternativen zu JDBC</a></li>
<li><a href="../de501434/index.html">Sicherheitswoche 20: Hacken eines Computers durch Thunderbolt</a></li>
<li><a href="../de501436/index.html">Zahlenerkennungsalgorithmus auf dem Bild mit einer geringen Wahrscheinlichkeit der zweiten Art von Fehler</a></li>
<li><a href="../de501440/index.html">Zabbix 5.0 veröffentlicht</a></li>
<li><a href="../de501442/index.html">Grundlegende Linux-Befehle für Anfänger</a></li>
<li><a href="../de501448/index.html">Wie wir einen einzigartigen Agile-Kurs profiliert haben</a></li>
<li><a href="../de501450/index.html">14 Dinge, die ein iOS-Entwickler wissen muss</a></li>
<li><a href="../de501454/index.html">Sechs Tipps zur Verwendung von PostgreSQL in Funktionstests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>