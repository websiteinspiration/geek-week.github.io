<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 👄 🚽 System.IO.Pipelines-高性能の愛好家のためのあまり知られていないツール 🐿️ ❎ 👩🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="読者こんにちは。.NET Core 2.1のリリースからかなりの時間が経過しました。そして、スパンとメモリのようなクールな革新はすでにかなり広く考えられており、あなたはそれらについて多くを読んだり、見たり聞いたりすることができます。ただし、残念ながら、System.IO.Pipelinesというライ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines-高性能の愛好家のためのあまり知られていないツール</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者こんにちは。</font><font style="vertical-align: inherit;">.NET Core 2.1のリリースからかなりの時間が経過しました。</font><font style="vertical-align: inherit;">そして、スパンとメモリのようなクールな革新はすでにかなり広く考えられており、あなたはそれらについて多くを読んだり、見たり聞いたりすることができます。</font><font style="vertical-align: inherit;">ただし、残念ながら、System.IO.Pipelinesというライブラリには同じ注意が向けられていませんでした。</font><font style="vertical-align: inherit;">このトピックに関するほとんどすべてが、</font><font style="vertical-align: inherit;">多くの人が翻訳して自宅で投稿し</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一の投稿</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">興味のある人がさまざまな角度からテクノロジーを見ることができるように、間違いなくより多くの情報があるはずです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、このライブラリは、ストリーミングデータ処理の処理を高速化することを目的としています。これは、もともとKestrel（ASP.NET CoreのクロスプラットフォームWebサーバー）の開発チームによって作成され使用されていましたが、現在は別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nugetパッケージ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から提供されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックを掘り下げる前に、ライブラリメカニズムをMemoryStreamの改良された類似体として想像することができます。元のMemoryStreamの問題はコピーの数が多すぎることです。これは、プライベートバイト配列が内部でバッファーとして使用されていることを覚えていれば明らかです。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Write</font></a><font style="vertical-align: inherit;">メソッド</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピーがはっきりと見える。したがって、ストリームに書き込むオブジェクトの場合、内部バッファーにコピーが作成され、読み取り中に、内部コピーのコピーがコンシューマーに配信されます。スペースを最も合理的に使用しているようには思えません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
System.IO.Pipelinesは、すべてのストリームを置き換えることを目的としたものではなく、高性能のコードを作成する開発者の武器の追加ツールです。基本的なメソッドとクラスに慣れ、内部でどのように配置されているかを確認し、基本的な例を分析することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部デバイスから始めて、同時に単純なコードフラグメントを見てみましょう。その後、それが何でどのように機能するか、そしてそれがどのように使用されるべきかが明らかになります。 System.IO.Pipelinesを使用する場合、基本的な概念は、追加の割り当てなしですべての読み取り/書き込み操作を実行する必要があることを覚えておく価値があります。しかし、一見魅力的ないくつかの方法はこのルールに反しています。したがって、スピードを上げるために一生懸命試みているコードは、ガベージコレクターを読み込んで、新しいデータと新しいデータにメモリを割り当て始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリの内部ライブラリは、最新バージョンの言語とtimetimeの最も幅広い可能性を使用します-スパン、メモリ、オブジェクトプール、ValueTaskなど。本番環境でこれらの機能を使用する優れた例としては、一見の価値があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、C＃でのストリームの実装に不満を抱いた人もいました。1つのクラスが読み取りと書き込みの両方に使用されていたためです。しかし、彼らが言うように、クラスからメソッドをスローすることはできません。ストリームがポインターの読み取り/書き込み/移動をサポートしていない場合でも、CanRead、CanWrite、およびCanSeekプロパティが有効になり、小さな松葉杖のように見えました。ここでは状況が異なります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプを操作するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PipeWriter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PipeReaderの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つのクラスを使用します</font><font style="vertical-align: inherit;">。これらのクラスはそれぞれ約50行を含み、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Pipe</font></a><font style="vertical-align: inherit;">クラスの疑似ファサード（背後に隠された単一のクラスがあり、多くはないため、最も古典的な化身ではありません）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データを操作するためのすべての基本ロジックが含まれています。</font><font style="vertical-align: inherit;">publicメンバーのうち、2つのコンストラクター、2つのget-onlyプロパティ-ReaderおよびWriter、Reset（）メソッド。クラスを再利用できるように内部フィールドを初期状態にリセットします。</font><font style="vertical-align: inherit;">他の作業方法は、疑似ファサードを使用して呼び出されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeクラスを始めるには</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスインスタンスは320バイトを占有しますが、これは非常に多くなります（ほぼ1キロバイトの3分の1、そのようなオブジェクトの2つはマンチェスターマークIのメモリに収まりません）。</font><font style="vertical-align: inherit;">したがって、大量に割り当てることは悪い考えです。</font><font style="vertical-align: inherit;">また、オブジェクトの意味は、長期的な使用を目的としています。</font><font style="vertical-align: inherit;">プールを使用すると、このステートメントの引数も作成されます。</font><font style="vertical-align: inherit;">結局のところ、プールで使用されるオブジェクトは永久に存続します（いずれにしても、標準では）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスはシール済みとしてマークされ、スレッドセーフであることに注意してください。コードの多くのセクションは重要なセクションであり、ロックでラップされています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開始するには、Pipeクラスのインスタンスを作成し、前述のプロパティを使用してPipeReaderおよびPipeWriterオブジェクトを取得する必要があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な初期化</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">var</span> pipe = <span class="hljs-keyword">new</span> Pipe();<font></font>
    PipeWriter pipeWriter = pipe.Writer;<font></font>
    PipeReader pipeReader = pipe.Reader;<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプを操作するためのメソッドを検討します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。PipeWriterを介した記録の場合-WriteAsync、GetMemory / GetSpan、Advance、FlushAsync、Complete、CancelPendingFlush、OnReaderCompleted。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PipeReaderを介して読み取る場合-AdvanceTo、ReadAsync、TryRead、Complete、CancelPendingRead、OnWriterCompleted。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">投稿</font></a><font style="vertical-align: inherit;">で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述べたように</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスは単一にリンクされたバッファのリストを使用します。しかし、明らかに、それらはPipeReaderとPipeWriterの間で転送されません-すべてのロジックは1つのクラスにあります。このリストは、読み取りと書き込みの両方に使用されます。また、返されたデータはこのリストに格納されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取るデータの先頭（ReadHeadとインデックス）、読み取るデータの末尾（ReadTailとインデックス）、および書き込む場所の先頭（WriteHeadと書き込まれたバッファリングされたバイト数）を示すオブジェクトもあります。</font><font style="vertical-align: inherit;">ここで、ReadHead、ReadTail、およびWriteHeadはリストの特定のセグメントであり、インデックスはセグメント内の特定の位置を示します。</font><font style="vertical-align: inherit;">したがって、録音はセグメントの中央から開始し、次のセグメント全体をキャプチャして、3番目の中央で終了できます。</font><font style="vertical-align: inherit;">これらのポインタはさまざまな方法で移動します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PipeWriterメソッドの概要</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueTask &lt;FlushResult&gt; WriteAsync（ReadOnlyMemory &lt;byte&gt; source、CancellationToken cancelToken）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まさにその魅力的な方法です。非常に適切でトレンディな署名があります-非同期のReadOnlyMemoryを受け入れます。そして、多くの人は、特にスパンとメモリが非常に高速でクールであることを思い出して、誘惑されるかもしれません。しかし、自分をお世辞しないでください。このメソッドが行うことは、それに渡されたReadOnlyMemoryを内部リストにコピーすることだけです。また、「コピー」とは、オブジェクト自体をコピーするのではなく、CopyToメソッドの呼び出しを意味します。つまり、記録したいすべてのデータがコピーされ、メモリがロードされます。この方法は、使用しない方がよいことを確認するためにのみ検討する必要があります。まあ、そしておそらくいくつかのまれな状況では、この動作は適切です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの本体はクリティカルセクションであり、モニターへのアクセスは同期されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最も明白で唯一の適切な方法を使用しない限り、どのように何かを書くかという問題が発生する可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃2 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ&lt;byte&gt; GetMemory（int sizeHint）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは、整数型のパラメーターを1つ取ります。</font><font style="vertical-align: inherit;">その中で、書き込みたいバイト数を示す必要があります（それ以上、ただしそれ以下ではありません）。</font><font style="vertical-align: inherit;">このメソッドは、_writingHeadMemoryに保存されている現在のメモリフラグメントに書き込むための十分なスペースがあるかどうかをチェックします。</font><font style="vertical-align: inherit;">十分な場合は、_writingHeadMemoryがメモリとして返されます。</font><font style="vertical-align: inherit;">そうでない場合は、バッファに書き込まれたデータに対してFlushAsyncメソッドが呼び出されなかった場合、それが呼び出され、前のバッファに接続されている別のBufferSegmentが選択されます（ここにリストがあります）。</font><font style="vertical-align: inherit;">_writingHeadMemoryがない場合は、新しいBufferSegmentで初期化されます。</font><font style="vertical-align: inherit;">そして、次のバッファの割り当ては重要なセクションであり、ロックの下で行われます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はそのような例を見ることを提案します。</font><font style="vertical-align: inherit;">一見すると、コンパイラ（またはランタイム）が悪魔を騙しているように見えるかもしれません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪魔</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">var</span> pipeNoOptions = <span class="hljs-keyword">new</span> Pipe();<font></font>
<font></font>
    Memory&lt;<span class="hljs-keyword">byte</span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number">2</span>);<font></font>
    Console.WriteLine(memoryOne.Length); <span class="hljs-comment">//2048  4096</span><font></font>
<font></font>
    <span class="hljs-keyword">var</span> pipeWithOptions = <span class="hljs-keyword">new</span> Pipe(<span class="hljs-keyword">new</span> PipeOptions(minimumSegmentSize: <span class="hljs-number">5</span>));<font></font>
<font></font>
    Memory&lt;<span class="hljs-keyword">byte</span>&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(<span class="hljs-number">2</span>);<font></font>
    Console.WriteLine(memoryTwo.Length); <span class="hljs-comment">//16</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この例のすべては理解可能でシンプルです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pipeインスタンスを作成するとき、</font><font style="vertical-align: inherit;">それを作成するためのオプションを備え</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PipeOptions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コンストラクターに</font></a><font style="vertical-align: inherit;">渡すことができ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PipeOptionsには、デフォルトの最小セグメントサイズフィールドがあります。少し前までは2048年でしたが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコミット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によりすべて</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">変更され、現在は4096になっています。現時点では、4096を含むバージョンはプレリリースパッケージであり、最新リリースバージョンでは2048でした。これが最初の例の動作を説明しています。標準バッファーのサイズを小さくする必要がある場合は、PipeOptionsタイプのインスタンスで指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、最小サイズが示されている2番目の例では、長さがそれと一致していません。そして、新しいBufferSegmentの作成はプールを使用して行われるため、これはすでに起こっています。 PipeOptionsのオプションの1つはメモリプールです。その後、指定されたプールを使用して新しいセグメントが作成されます。メモリプールを指定しなかった場合、標準のArrayPoolが使用されます。これには、ご存知のように、配列のサイズが異なる複数のバケットがあり（それぞれ次のサイズは前のサイズの2倍です）、特定のサイズを要求されると、適切なサイズの配列のバケットを探します（次に最も近い、または等しいものがあります）。したがって、新しいバッファーはほぼ確実に要求したサイズよりも大きくなります。標準のArrayPool（System.Buffers.TlsOverPerCoreLockedStacksArrayPool）の最小配列サイズは16です。ただし、これは配列のプールであるため、心配しないでください。したがって、ほとんどの場合、アレイはガベージコレクタに圧力をかけず、再利用されます。</font></font><br>
<br>
<h3>#2.5 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Span&lt;byte&gt; GetSpan(int sizeHint)</a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に機能し、メモリからスパンを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、GetMemory（）またはGetSpan（）は、書き込みの主なメソッドです。</font><font style="vertical-align: inherit;">これらは、書き込み可能なオブジェクトを提供します。</font><font style="vertical-align: inherit;">これを行うには、新しい値の配列にメモリを割り当てる必要はありません。内部構造に直接書き込むことができます。</font><font style="vertical-align: inherit;">どちらを使用するかは、主に、使用しているAPIと非同期メソッドに依存します。</font><font style="vertical-align: inherit;">しかしながら、上記を考慮して、疑問が生じる。</font><font style="vertical-align: inherit;">読者は私たちが書いた量をどのように知るのでしょうか？</font><font style="vertical-align: inherit;">プールの特定の実装を常に使用していて、要求とまったく同じサイズの配列が提供される場合、リーダーはバッファー全体を一度に読み取ることができます。</font><font style="vertical-align: inherit;">ただし、すでに述べたように、大きなサイズの確率が高いバッファが割り当てられます。</font><font style="vertical-align: inherit;">これは、操作に必要な以下の方法につながります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃3 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void Advance（intバイト）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ひどいシンプルな方法。</font><font style="vertical-align: inherit;">書き込まれたバイト数を引数として取ります。</font><font style="vertical-align: inherit;">それらは内部カウンター-_unflushedBytesと_writingHeadBytesBufferedをインクリメントします。</font><font style="vertical-align: inherit;">また、_writingHeadMemoryを（Sliceメソッドを使用して）書き込まれたバイト数に正確に切り詰めます。</font><font style="vertical-align: inherit;">したがって、このメソッドを呼び出した後、MemoryまたはSpanの形式で新しいメモリブロックをリクエストする必要があります。以前のブロックに書き込むことはできません。</font><font style="vertical-align: inherit;">そして、メソッド全体がクリティカルセクションであり、ロックの下で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この後、リーダーはデータを受信できるようになります。</font><font style="vertical-align: inherit;">しかし、もう1つのステップが必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃4 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueTask &lt;FlushResult&gt; FlushAsync（CancellationToken cancelToken）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは、受信したメモリに必要なデータを書き込み、そこに書き込んだ量を示した後に呼び出されます。このメソッドはValueTaskを返しますが、非同期ではありません（その子孫のStreamPipeWriterとは異なります）。 ValueTaskは、ほとんどの呼び出しが非同期を使用しない場合、つまり、呼び出し時に必要なすべてのデータが利用可能であり、メソッドが同期的に終了する場合に使用される特別なタイプ（読み取り専用構造体）です。内部には、データまたはタスクのいずれかが含まれます（同期して機能しなかった場合）。 _writerAwaitable.IsCompletedプロパティの状態によって異なります。この待機オブジェクトの状態を変更するものを探すと、未処理の（消費されていない）データの量（これは未読（検査されていない）とまったく同じではない場合）が発生することがわかります。後で説明します）、特定のしきい値（_pauseWriterThreshold）を超えます。デフォルトは16セグメントサイズです。必要に応じて、PipeOptionsで値を変更できます。また、このメソッドは、ブロックされている場合、ReadAsyncメソッドの続きを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IsCanceledとIsCompletedの2つのプロパティを含むFlushResultを返します。</font><font style="vertical-align: inherit;">IsCanceledは、フラッシュがキャンセルされたかどうかを示します（CancelPendingFlush呼び出し）。</font><font style="vertical-align: inherit;">IsCompletedは、PipeReaderが完了したかどうかを示します（Complete（）またはCompleteAsync（）メソッドを呼び出すことによって）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの大部分はLocke Skywalkerで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PipeWriterの他のメソッドは、実装の観点からは関心がなく、使用頻度も低いため、簡単な説明のみを行います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃5 void Complete（Exception exception = null）またはValueTask CompleteAsync（Exception exception = null）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書き込み用にパイプを閉じたことを示します。</font><font style="vertical-align: inherit;">完了すると、書き込みメソッドを使用しようとすると試行がスローされます。</font><font style="vertical-align: inherit;">PipeReaderがすでに完了している場合は、Pipeインスタンス全体も完了しています。</font><font style="vertical-align: inherit;">ほとんどの作業はロックの下で行われます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃6 void CancelPendingFlush（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前が示すように、現在のFlushAsync（）操作を完了します。</font><font style="vertical-align: inherit;">lokがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃7 void OnReaderCompleted（アクション&lt;例外、オブジェクト&gt;コールバック、オブジェクト状態）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーの完了時に委任されたデリゲートを実行します。</font><font style="vertical-align: inherit;">ロックもあります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ドキュメントは</font></a><font style="vertical-align: inherit;">現在、この方法は、いくつかのPipeWriterの相続人で呼び出されないことがあり、将来的に削除されることを言います。</font><font style="vertical-align: inherit;">したがって、ロジックをこれらのメソッドに関連付けないでください。</font></font><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PipeReaderに移動</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueTask &lt;ReadResult&gt; ReadAsync（CancellationTokenトークン）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、FlushAsyncと同様に、ValueTaskが返されます。これは、メソッドがほとんど同期していることを示しますが、常に同期しているわけではありません。 _readerAwaitableの状態によって異なります。 FlushAsyncと同様に、_readerAwaitableが不完全に設定されている場合を見つける必要があります。これは、PipeReaderがリストからすべてを読み取るときに発生します（または、検査済みとしてマークされたデータが含まれていて、続行するにはさらにデータが必要です）。これは実際には論理的です。したがって、経験に基づいて特定された統計に基づいて、すべてのオプションを慎重に設定するには、Pipeを作業に合わせて微調整することが望ましいと結論付けることができます。適切な構成は、非同期実行ブランチの可能性を減らし、データのより効率的な処理を可能にします。メソッドのほぼ全体がロックで囲まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不可解な</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ReadResultを</font></a><font style="vertical-align: inherit;">返します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実際、これは単なるバッファ+操作のステータスを示すフラグです（IsCanceled-ReadAsyncがキャンセルされたかどうか、IsCompletedがPipeWriterが閉じられたかどうかを示します）。この場合、IsCompletedは、PipeWriter Complete（）またはCompleteAsync（）メソッドが呼び出されたかどうかを示す値です。これらのメソッドが例外付きで呼び出された場合、読み取りを試行するとスローされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッファもまた、謎めいたタイプの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReadOnlySequenceを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持ってい</font><font style="vertical-align: inherit;">ます。これは、次に、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">セグメント</font></a><font style="vertical-align: inherit;">を含むためのオブジェクトです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ReadOnlySequenceSegment）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始および終了+対応するセグメント内の開始および終了インデックス。これは実際にはPipeクラス自体の構造に似ています。ちなみに、BufferSegmentはReadOnlySequenceSegmentの後継であり、そこで使用されていることを示唆しています。これのおかげで、ライターからリーダーへのデータ転送のための不要なメモリ割り当てを取り除くことができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReadOnlySpanは、さらに処理するためにバッファから取得できます。画像を完成させるには、バッファに単一のReadOnlySpanが含まれているかどうかを確認できます。含まれている場合、1つの要素からコレクションを反復処理する必要はなく、Firstプロパティを使用して取得できます。それ以外の場合は、バッファー内のすべてのセグメントを調べて、各ReadOnlySpanを処理する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスカッショントピック-null可能な参照型はReadOnlySequenceクラスでアクティブに使用され、goto（ネストを終了せず、生成されたコードではありません）があります-特に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、処理後、データを読み取ることをPipeインスタンスに明確にする必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃2 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool TryRead（ReadResultの結果を出力）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期バージョン。</font><font style="vertical-align: inherit;">そうであれば結果を得ることができます。</font><font style="vertical-align: inherit;">まだそこにない場合は、ReadAsyncとは異なり、ブロックはしませんがfalseを返します。</font><font style="vertical-align: inherit;">ロックでも。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃3 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void AdvanceTo（SequencePositionが消費され、SequencePositionが検査されます）</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドでは、読み取るバイト数と処理するバイト数を指定できます。読み込まれたが処理されていないデータは、次に読み込まれたときに返されます。この機能は一見奇妙に思えるかもしれませんが、バイトのストリームを処理する場合、各バイトを個別に処理する必要はほとんどありません。通常、データはメッセージを使用して交換されます。読者が読んでいるときに、1つのメッセージ全体と2番目のメッセージの一部を受け取ったという状況が発生する場合があります。全体を処理する必要があり、残りの部分と一緒になるように、2番目の部分は次回残す必要があります。 AdvanceToメソッドはSequencePositionを受け取ります。SequencePositionは、実際にはその中のセグメント+インデックスです。 ReadAsyncが読み取ったすべてを処理するときに、buffer.Endを指定できます。それ以外の場合は、処理が停止されたセグメントとインデックスを示す位置を明示的に作成する必要があります。フードlokの下。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、未加工情報の量がインストールされた欠陥（_resumeWriterThreshold）より少ない場合、PipeWriterがブロックされていた場合、それが継続されます。</font><font style="vertical-align: inherit;">デフォルトでは、このしきい値は8セグメントボリュームです（ブロッキングしきい値の半分）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃4 void Complete（Exception exception = null）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PipeReaderを完了します。</font><font style="vertical-align: inherit;">この時点でPipeWriterが完了すると、Pipeインスタンス全体が終了します。</font><font style="vertical-align: inherit;">内部をロックします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃5 void CancelPendingRead（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在予期されている読み取りをキャンセルできます。</font><font style="vertical-align: inherit;">ロック。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃6 void OnWriterCompleted（アクション&lt;例外、オブジェクト&gt;コールバック、オブジェクト状態）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PipeWriterの完了時に実行するデリゲートを指定できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PipeWriterの同様のメソッドと同様に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントには</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除される同じマークがあります。</font><font style="vertical-align: inherit;">フードの下でロックします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のリストは、パイプの使用例を示しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Core Span and Memoryの導入以来、データを処理するための多くのクラスは、これらのタイプを使用したオーバーロードによって補完されてきました。したがって、一般的な相互作用スキームはほぼ同じになります。私の例では、パイプラインを使用してパイプを操作しました（ルートワードが好きです）。チャネル-プロセス間通信用のOSオブジェクト。チャネルAPIは、スパンとメモリのデータを読み取るように拡張されています。非同期バージョンはメモリを使用します。非同期メソッドは、すべてのローカル変数とメソッドパラメーターが格納されている自動生成有限状態マシンを使用してテンプレートメソッドに変換され、Spanは参照読み取り専用構造体であるため、Spanを使用してそれぞれヒープ上に置くことはできません。非同期メソッドでは不可能です。しかし、メソッドの同期バージョンがあり、Spanを使用できます。私の例では、両方を試してみましたが、この状況での同期バージョンの方が優れていることがわかりました。これを使用すると、ガベージコレクションの発生が少なくなり、データ処理が高速になります。しかし、これは大量のデータがあったためだけでした。次のバッチの申請時にデータがない状況が発生する可能性がある場合は、非同期バージョンを使用して、プロセッサーのアイドル状態に負担をかけないようにする必要があります。プロセッサのアイドル状態に負担をかけないように、非同期バージョンを使用する必要があります。プロセッサのアイドル状態に負担をかけないように、非同期バージョンを使用する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例には、いくつかのポイントを説明するコメントがあります。</font><font style="vertical-align: inherit;">パイプからの読み取りと処理を担当するプログラムのフラグメントが分離されているにもかかわらず、ファイルに書き込む場合、データはパイプから読み取るときに書き込まれた場所から正確に読み取られるという事実に注目します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強力な機能のための何年もの進化-非同期メイン</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
    {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> args</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> pipe = <span class="hljs-keyword">new</span> Pipe();
            <span class="hljs-keyword">var</span> dataWriter = <span class="hljs-keyword">new</span> PipeDataWriter(pipe.Writer, <span class="hljs-string">"testpipe"</span>);
            <span class="hljs-keyword">var</span> dataProcessor = <span class="hljs-keyword">new</span> DataProcessor(<span class="hljs-keyword">new</span> ConsoleBytesProcessor(), pipe.Reader);
            <span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();
            <span class="hljs-keyword">await</span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token));<font></font>
        }<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipepatawriter</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PipeDataWriter</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> NamedPipeClientStream _namedPipe;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> PipeWriter _pipeWriter;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Servername = <span class="hljs-string">"."</span>;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipeDataWriter</span>(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-keyword">string</span> pipeName</span>)</span><font></font>
        {<font></font>
            _pipeWriter = pipeWriter ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(pipeWriter));<font></font>
            _namedPipe = <span class="hljs-keyword">new</span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ReadFromPipeAsync</span>(<span class="hljs-params">CancellationToken token</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">await</span> _namedPipe.ConnectAsync(token);<font></font>
<font></font>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
            {<font></font>
                token.ThrowIfCancellationRequested();<font></font>
                <font></font>
                <span class="hljs-comment"><span class="hljs-doctag">///</span>/       Memory<span class="hljs-doctag">&lt;T&gt;</span></span>
                <span class="hljs-comment">//Memory&lt;byte&gt; buffer = _pipeWriter.GetMemory();</span>
                <span class="hljs-comment"><span class="hljs-doctag">///</span>/       Memory<span class="hljs-doctag">&lt;T&gt;</span></span>
		<span class="hljs-comment"><span class="hljs-doctag">///</span>/         -       .</span>
                <span class="hljs-comment">//int readBytes = await _namedPipe.ReadAsync(buffer, token); </span><font></font>
                <font></font>
                <span class="hljs-comment">//         PipeWriter Span</span>
		<span class="hljs-comment">//         -       .</span>
                <span class="hljs-keyword">int</span> readBytes = _namedPipe.Read(_pipeWriter.GetSpan());<font></font>
                <font></font>
                <span class="hljs-comment">//      ,       </span>
		<span class="hljs-comment">//        </span>
                <span class="hljs-keyword">if</span> (readBytes == <span class="hljs-number">0</span>)<font></font>
                {<font></font>
                    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>, token);
                    <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-comment">// ,      </span><font></font>
                _pipeWriter.Advance(readBytes);<font></font>
                <font></font>
                <span class="hljs-comment">//  ,      PipeReader</span>
                FlushResult result = <span class="hljs-keyword">await</span> _pipeWriter.FlushAsync(token);<font></font>
                <font></font>
                <span class="hljs-comment">//  PipeReader  ,      </span>
                <span class="hljs-comment">//        ,     </span>
                <span class="hljs-keyword">if</span> (result.IsCompleted)<font></font>
                {<font></font>
                    <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">//  _pipeWriter     Pipe</span><font></font>
            _pipeWriter.Complete();<font></font>
        }<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データプロセッサ</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataProcessor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IBytesProcessor _bytesProcessor;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> PipeReader _pipeReader;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataProcessor</span>(<span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span>)</span><font></font>
        {<font></font>
            _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(bytesProcessor));<font></font>
            _pipeReader = pipeReader ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(pipeReader));<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartProcessingDataAsync</span>(<span class="hljs-params">CancellationToken token</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
            {<font></font>
                token.ThrowIfCancellationRequested();<font></font>
                <font></font>
                <span class="hljs-comment">//     Pipe</span>
                ReadResult result = <span class="hljs-keyword">await</span> _pipeReader.ReadAsync(token);<font></font>
                ReadOnlySequence&lt;<span class="hljs-keyword">byte</span>&gt; buffer = result.Buffer;<font></font>
                <font></font>
                <span class="hljs-comment">//     </span>
                <span class="hljs-keyword">await</span> _bytesProcessor.ProcessBytesAsync(buffer, token);<font></font>
                <font></font>
                <span class="hljs-comment">// ,      .       ,  </span>
                <span class="hljs-comment">//  ,              </span>
                <span class="hljs-comment">//    IBytesProcessor.ProcessBytesAsync   ,   </span><font></font>
                _pipeReader.AdvanceTo(buffer.End);<font></font>
                <font></font>
                <span class="hljs-comment">//  PipeWriter  ,     </span>
                <span class="hljs-comment">//      ,     </span>
                <span class="hljs-keyword">if</span> (result.IsCompleted)<font></font>
                {<font></font>
                    <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">//  _pipeReader     Pipe</span><font></font>
            _pipeReader.Complete();<font></font>
        }<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトプロセッサ</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IBytesProcessor</span><font></font>
    {<font></font>
        <span class="hljs-function">Task <span class="hljs-title">ProcessBytesAsync</span>(<span class="hljs-params">ReadOnlySequence&lt;<span class="hljs-keyword">byte</span>&gt; bytesSequence, CancellationToken token</span>)</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleBytesProcessor</span> : <span class="hljs-title">IBytesProcessor</span><font></font>
    {<font></font>
        <span class="hljs-comment">//,         IDisposable</span>
        <span class="hljs-keyword">readonly</span> FileStream _fileStream = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">"buffer"</span>, FileMode.Create);<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">ProcessBytesAsync</span>(<span class="hljs-params">ReadOnlySequence&lt;<span class="hljs-keyword">byte</span>&gt; bytesSequence, CancellationToken token</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (bytesSequence.IsSingleSegment)<font></font>
            {<font></font>
                ProcessSingle(bytesSequence.First.Span);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> segment <span class="hljs-keyword">in</span> bytesSequence)<font></font>
                {<font></font>
                    ProcessSingle(segment.Span);<font></font>
                }<font></font>
            }<font></font>
			<font></font>
            <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProcessSingle</span>(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-keyword">byte</span>&gt; span</span>)</span><font></font>
        {<font></font>
            _fileStream.Write(span);<font></font>
        }<font></font>
    }<font></font>
</code></pre><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464909/index.html">「彼らは私たちを見ている」：窓の真下にある目立たないミニバンで何が起こるか</a></li>
<li><a href="../ja464913/index.html">「カイゼンを知る」：生産プロセスを改善するためのこの哲学は何ですか</a></li>
<li><a href="../ja464915/index.html">JavaScriptの末尾再帰の最適化</a></li>
<li><a href="../ja464917/index.html">サイバーパンクの後：現代のサイエンスフィクションの現在のジャンルについて知っておくべきこと</a></li>
<li><a href="../ja464919/index.html">アプリケーションで使用されるRAMの組み込みリソース制御</a></li>
<li><a href="../ja464925/index.html">音声UXのガイド：状況、パターン、ツール（および少しの道徳的サポート）</a></li>
<li><a href="../ja464927/index.html">ASICマイナーの中古品：リスク、検証、書き換えハッシュ</a></li>
<li><a href="../ja464929/index.html">ブラウザの遅延画像読み込み（読み込み属性）</a></li>
<li><a href="../ja464931/index.html">アセンブラ挿入... Cで？</a></li>
<li><a href="../ja464933/index.html">Androidオペレーティングシステム上の電子書籍のアプリケーション。パート4.ゲーム</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>