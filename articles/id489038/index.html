<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—ï¸ ğŸ‘©ğŸ¿â€ğŸ’¼ â›¸ï¸ Buku "Java Concurrency in Practice" ğŸŒªï¸ ğŸ––ğŸ¿ ğŸ¥‚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, habrozhiteli! Streaming adalah bagian mendasar dari platform Java. Prosesor multi-inti adalah hal biasa, dan penggunaan konkurensi yang efektif ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Buku "Java Concurrency in Practice"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="gambar"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, habrozhiteli! Streaming adalah bagian mendasar dari platform Java. Prosesor multi-inti adalah hal biasa, dan penggunaan konkurensi yang efektif menjadi penting untuk membuat aplikasi berkinerja tinggi. Mesin virtual Java yang disempurnakan, dukungan untuk kelas berkinerja tinggi, dan serangkaian blok bangunan yang kaya untuk tugas paralelisasi pada satu waktu merupakan terobosan dalam pengembangan aplikasi paralel. Dalam Java Concurrency in Practice, pencipta teknologi terobosan itu sendiri tidak hanya menjelaskan cara kerjanya, tetapi juga berbicara tentang pola desain. Sangat mudah untuk membuat program kompetitif yang tampaknya berhasil. Namun, pengembangan, pengujian, dan debugging dari program multi-threaded menimbulkan banyak masalah. Kode berhenti bekerja tepat saat yang paling penting: di bawah beban berat.Dalam â€œJava Concurrency in Practiceâ€ Anda akan menemukan teori dan metode spesifik untuk membuat aplikasi paralel yang andal, dapat diskalakan dan didukung. Para penulis tidak menawarkan daftar API dan mekanisme paralelisme, mereka memperkenalkan aturan desain, pola dan model yang tidak tergantung pada versi Java dan tetap relevan dan efektif selama bertahun-tahun.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kutipan. </font><font style="vertical-align: inherit;">Keamanan benang</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin terkejut bahwa pemrograman kompetitif dikaitkan dengan utas atau kunci </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak lebih dari teknik sipil dikaitkan dengan paku keling dan balok-I. </font><font style="vertical-align: inherit;">Tentu saja, pembangunan jembatan membutuhkan penggunaan sejumlah besar paku keling dan balok-I, dan hal yang sama berlaku untuk pembangunan program kompetitif, yang membutuhkan penggunaan benang dan kunci yang benar. </font><font style="vertical-align: inherit;">Tetapi ini hanyalah mekanisme - sarana untuk mencapai tujuan. </font><font style="vertical-align: inherit;">Menulis kode aman adalah, pada dasarnya, mengendalikan akses ke negara, dan, khususnya, ke keadaan bisa berubah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, keadaan suatu objek adalah datanya yang disimpan dalam variabel keadaan, seperti misalnya dan bidang statis atau bidang dari objek dependen lainnya. Status hash HashMap sebagian disimpan di HashMap itu sendiri, tetapi juga di banyak objek Map.Entry. Keadaan objek mencakup data apa pun yang dapat memengaruhi perilakunya. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b>     lock  block,      Â«Â»,     ,  .            blocking.   lock    Â«Â», Â«  Â».     lock ,  ,   ,    Â«Â».  â€”          .       ,          , ,         . â€” . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa utas dapat mengakses variabel bersama, termutasi - mengubah nilainya. Faktanya, kami berusaha melindungi data, bukan kode, dari akses kompetitif yang tidak terkendali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membuat objek thread-safe memerlukan sinkronisasi untuk mengoordinasikan akses ke keadaan bermutasi, kegagalan untuk memenuhi yang dapat menyebabkan korupsi data dan konsekuensi yang tidak diinginkan lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap kali lebih dari satu utas mengakses variabel keadaan dan salah satu utas mungkin menulis kepadanya, semua utas harus mengoordinasikan akses mereka ke sana menggunakan sinkronisasi. Sinkronisasi di Jawa disediakan oleh kata kunci yang disinkronkan, yang memberikan penguncian eksklusif, serta variabel volatil dan atom dan kunci eksplisit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tahan godaan untuk berpikir bahwa ada situasi yang tidak memerlukan sinkronisasi. </font><font style="vertical-align: inherit;">Program ini dapat bekerja dan lulus tes, tetapi tetap tidak berfungsi dan macet kapan saja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika beberapa utas mengakses variabel yang sama dengan keadaan bermutasi tanpa sinkronisasi yang tepat, maka program Anda tidak berfungsi. </font><font style="vertical-align: inherit;">Ada tiga cara untuk memperbaikinya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan bagikan variabel status di semua utas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat variabel status tidak dapat diubah;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gunakan sinkronisasi status setiap kali Anda mengakses variabel status.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Koreksi mungkin memerlukan perubahan desain yang signifikan, sehingga jauh lebih mudah untuk merancang thread-safe kelas segera daripada meningkatkannya nanti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah beberapa utas akan mengakses variabel ini atau itu sulit diketahui. Untungnya, solusi teknis berorientasi objek yang membantu menciptakan kelas yang terorganisir dengan baik dan mudah dirawat - seperti enkapsulasi dan penyembunyian data - juga membantu menciptakan kelas yang aman untuk thread. Semakin sedikit utas yang memiliki akses ke variabel tertentu, semakin mudah memastikan sinkronisasi dan mengatur kondisi di mana variabel ini dapat diakses. Bahasa Java tidak memaksa Anda untuk merangkum keadaan - sangat dapat diterima untuk menyimpan keadaan di bidang publik (bahkan bidang statis publik) atau menerbitkan tautan ke objek yang bersifat internal - tetapi semakin baik kondisi program Anda dienkapsulasi,semakin mudah untuk membuat utas program Anda aman dan membantu pengelola mempertahankannya.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat merancang kelas yang aman untuk benang, solusi teknis berorientasi objek yang baik: enkapsulasi, mutabilitas, dan spesifikasi invarian yang jelas akan menjadi asisten Anda.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika solusi teknis desain berorientasi objek yang baik menyimpang dari kebutuhan pengembang, Anda harus mengorbankan aturan desain yang baik demi kinerja atau kompatibilitas dengan kode legacy. </font><font style="vertical-align: inherit;">Terkadang abstraksi dan enkapsulasi berbeda dengan kinerja - walaupun tidak sesering yang dipikirkan oleh banyak pengembang - tetapi praktik terbaiknya adalah membuat kode terlebih dahulu dan kemudian cepat. </font><font style="vertical-align: inherit;">Coba gunakan optimasi hanya jika pengukuran produktivitas dan kebutuhan menunjukkan bahwa Anda harus melakukannya </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode kompetitif, Anda harus mematuhi praktik ini lebih dari biasanya. Karena kesalahan kompetitif sangat sulit untuk direproduksi dan tidak mudah untuk di-debug, keuntungan dari kenaikan kinerja kecil pada beberapa cabang kode yang jarang digunakan bisa sangat diabaikan dibandingkan dengan risiko bahwa program akan macet dalam kondisi operasi.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jika Anda memutuskan bahwa Anda perlu memecah enkapsulasi, maka tidak semuanya hilang. Program Anda masih dapat dibuat utas agar aman, tetapi prosesnya akan lebih rumit dan lebih mahal, dan hasilnya tidak dapat diandalkan. Bab 4 menjelaskan kondisi-kondisi di mana enkapsulasi variabel keadaan dapat dengan aman dimitigasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh ini, kami telah menggunakan istilah "kelas aman thread" dan "program aman thread" hampir secara bergantian. Apakah program utas aman sepenuhnya dibangun dari kelas utas aman? Opsional: program yang seluruhnya terdiri dari kelas-kelas aman thread mungkin tidak aman thread, dan program aman thread mungkin berisi kelas-kelas yang tidak aman thread. Masalah yang berkaitan dengan tata letak kelas thread-safe juga dibahas dalam Bab 4. Dalam kasus apa pun, konsep kelas thread-safe masuk akal hanya jika kelas merangkum keadaannya sendiri. Istilah "keamanan thread" dapat diterapkan pada kode, tetapi berbicara tentang status dan hanya dapat diterapkan pada array kode yang merangkum statusnya (dapat berupa objek atau keseluruhan program).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Apa itu keamanan utas?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menentukan keamanan utas tidak mudah. </font><font style="vertical-align: inherit;">Pencarian Google cepat memberi Anda banyak pilihan seperti ini: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... dapat dipanggil dari banyak utas program tanpa interaksi yang tidak diinginkan antar utas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... dapat dipanggil oleh dua utas atau lebih secara bersamaan, tanpa memerlukan tindakan lain dari pemanggil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan definisi seperti itu, tidak mengherankan bahwa kami menemukan keselamatan thread membingungkan! </font><font style="vertical-align: inherit;">Bagaimana membedakan kelas thread-safe dari kelas yang tidak aman? </font><font style="vertical-align: inherit;">Apa yang kita maksud dengan kata "aman"? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inti dari setiap definisi yang masuk akal tentang keselamatan benang adalah gagasan tentang kebenaran.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketepatan menyiratkan bahwa kelas sesuai dengan spesifikasinya. </font><font style="vertical-align: inherit;">Spesifikasi mendefinisikan invarian yang membatasi keadaan objek dan kondisi akhir yang menggambarkan efek operasi. </font><font style="vertical-align: inherit;">Bagaimana Anda tahu bahwa spesifikasi untuk kelas sudah benar? </font><font style="vertical-align: inherit;">Tidak mungkin, tetapi ini tidak menghalangi kita untuk menggunakannya setelah kita meyakinkan diri kita sendiri bahwa kode itu berfungsi. </font><font style="vertical-align: inherit;">Jadi mari kita asumsikan kebenaran single-threaded adalah sesuatu yang terlihat. </font><font style="vertical-align: inherit;">Sekarang kita dapat mengasumsikan bahwa kelas thread-safe berperilaku dengan benar selama akses dari beberapa utas.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas adalah thread aman jika berperilaku dengan benar selama akses dari beberapa utas, terlepas dari bagaimana utas ini dijadwalkan atau disatukan oleh lingkungan kerja, dan tanpa sinkronisasi tambahan atau koordinasi lainnya pada bagian dari kode panggilan.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program multi-utas tidak dapat menjadi utas aman jika tidak benar bahkan dalam lingkungan utas tunggal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika objek diimplementasikan dengan benar, maka tidak ada urutan operasi - mengakses metode publik dan membaca atau menulis ke bidang publik - harus melanggar invarian atau postkondisinya. </font><font style="vertical-align: inherit;">Tidak ada rangkaian operasi yang dilakukan secara berurutan atau secara kompetitif pada instance dari kelas thread-safe yang dapat menyebabkan instance berada dalam keadaan tidak valid. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika penggunaan istilah koreksi yang longgar mengganggu Anda di sini, maka Anda dapat menganggap kelas thread-safe sebagai kelas yang salah dalam lingkungan kompetitif, serta dalam lingkungan single-threaded.</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas thread-safe merangkum sinkronisasi yang diperlukan sendiri dan tidak memerlukan bantuan klien.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1. </font><font style="vertical-align: inherit;">Contoh: servlet tanpa dukungan keadaan internal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Bab 1, kami telah membuat daftar struktur yang membuat utas dan memanggil komponen dari mereka yang Anda bertanggung jawab atas keselamatan utas. </font><font style="vertical-align: inherit;">Sekarang kami bermaksud untuk mengembangkan layanan faktorisasi servlet dan secara bertahap memperluas fungsinya dengan tetap menjaga keamanan benang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1 memperlihatkan servlet sederhana yang mendekompres suatu angka dari sebuah query, memfaktorkannya, dan membungkus hasilnya sebagai respons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar 2.1. </font><font style="vertical-align: inherit;">Servlet tanpa dukungan negara internal</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas StatelessFactorizer, seperti kebanyakan servlet, tidak memiliki keadaan internal: tidak mengandung bidang dan tidak merujuk ke bidang dari kelas lain. </font><font style="vertical-align: inherit;">Keadaan untuk perhitungan tertentu hanya ada dalam variabel lokal yang disimpan di tumpukan aliran dan hanya tersedia untuk aliran yang menjalankan. </font><font style="vertical-align: inherit;">Satu utas yang mengakses StatelessFactorizer tidak dapat memengaruhi hasil utas lain yang melakukan hal yang sama, karena utas ini tidak berbagi status.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek tanpa dukungan keadaan internal selalu aman untuk thread.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fakta bahwa sebagian besar servlet dapat diimplementasikan tanpa dukungan internal negara secara signifikan mengurangi beban threading servlets sendiri. </font><font style="vertical-align: inherit;">Dan hanya ketika servlets perlu mengingat sesuatu, persyaratan untuk keamanan utasnya meningkat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Atomicity</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi ketika item keadaan ditambahkan ke objek tanpa dukungan keadaan internal? Misalkan kita ingin menambahkan hit counter yang mengukur jumlah permintaan yang diproses. Anda bisa menambahkan bidang tipe panjang ke servlet dan menambahkannya dengan setiap permintaan, seperti yang ditunjukkan di UnsafeCountingFactorizer di Listing 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.2. Sebuah servlet yang menghitung permintaan tanpa sinkronisasi yang diperlukan. Ini seharusnya tidak dilakukan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="gambar"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, kelas UnsafeCountingFactorizer tidak aman untuk thread, bahkan jika itu berfungsi dengan baik di lingkungan single-threaded. Seperti UnsafeSequence, ia rentan terhadap pembaruan yang hilang. Meskipun penghitungan peningkatan operasi ++ memiliki sintaks yang kompak, itu bukan atomik, yaitu, tidak dapat dibagi, tetapi urutan dari tiga operasi: memberikan nilai saat ini, menambahkan satu ke nilai saat itu dan menuliskan nilai baru kembali. Dalam operasi "baca, ubah, tulis", status yang dihasilkan diturunkan dari yang sebelumnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gbr. </font><font style="vertical-align: inherit;">1.1 ditunjukkan apa yang dapat terjadi jika dua utas mencoba meningkatkan penghitung pada saat yang sama, tanpa sinkronisasi. </font><font style="vertical-align: inherit;">Jika penghitungnya adalah 9, maka karena koordinasi waktu yang gagal, kedua utas akan melihat nilai 9, tambahkan satu padanya, dan tetapkan nilainya menjadi 10. Jadi penghitung hit akan mulai tertinggal satu per satu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin berpikir bahwa memiliki hit counter yang sedikit tidak akurat dalam layanan web adalah kerugian yang dapat diterima, dan terkadang demikian. </font><font style="vertical-align: inherit;">Tetapi jika penghitung digunakan untuk membuat urutan atau pengidentifikasi unik objek, maka mengembalikan nilai yang sama dari beberapa aktivasi dapat menyebabkan masalah integritas data yang serius. </font><font style="vertical-align: inherit;">Kemungkinan munculnya hasil yang salah karena koordinasi waktu yang gagal muncul dalam kondisi balapan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Kondisi balapan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas UnsafeCountingFactorizer memiliki beberapa kondisi lomba </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jenis kondisi lomba yang paling umum adalah situasi "periksa dan kemudian bertindak", di mana pengamatan yang berpotensi usang digunakan untuk memutuskan apa yang harus dilakukan selanjutnya. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita sering menghadapi kondisi balapan di kehidupan nyata. Misalkan Anda berencana untuk bertemu seorang teman di siang hari di Starbucks CafÃ© di Universitetskiy Prospekt. Tetapi Anda akan menemukan bahwa ada dua Starbucks di University Avenue. Pada jam 12:10 Anda tidak melihat teman Anda di kafe A dan pergi ke kafe B, tetapi dia juga tidak ada di sana. Entah teman Anda terlambat, atau dia tiba di kafe A segera setelah Anda pergi, atau dia berada di kafe B, tetapi pergi mencari Anda dan sekarang sedang dalam perjalanan ke kafe A. Kami akan menerima yang terakhir, yaitu, skenario terburuk. Sekarang 12:15, dan kalian berdua bertanya-tanya apakah temanmu menepati janjinya. Apakah Anda akan kembali ke kafe lain? Berapa kali Anda akan bolak-balik? Jika Anda belum menyetujui protokol, Anda dapat menghabiskan sepanjang hari berjalan di sepanjang University Avenue dalam euforia berkafein.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah dengan pendekatan "jalan-jalan dan lihat apakah dia ada di sana" adalah bahwa berjalan di sepanjang jalan antara dua kafe membutuhkan waktu beberapa menit, dan selama waktu ini keadaan sistem dapat berubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh dengan Starbucks menggambarkan ketergantungan hasil pada waktu koordinasi yang relatif dari peristiwa (pada berapa lama Anda menunggu seorang teman saat di kafe, dll). </font><font style="vertical-align: inherit;">Pengamatan bahwa dia tidak ada di kafe A menjadi berpotensi tidak valid: begitu Anda keluar dari pintu depan, ia dapat masuk melalui pintu belakang. </font><font style="vertical-align: inherit;">Sebagian besar kondisi ras menyebabkan masalah seperti pengecualian yang tidak terduga, data yang ditimpa, dan korupsi file.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Contoh: kondisi lomba dalam inisialisasi malas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trik umum menggunakan pendekatan "centang dan kemudian bertindak" adalah inisialisasi malas (LazyInitRace). Tujuannya adalah untuk menunda inisialisasi objek sampai diperlukan, dan untuk memastikan bahwa inisialisasi hanya dilakukan satu kali. Dalam Listing 2.3, metode getInstance memverifikasi bahwa ExpensiveObject diinisialisasi dan mengembalikan instance yang ada, atau, sebaliknya, membuat instance baru dan mengembalikannya setelah mempertahankan referensi padanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.3. Kondisi lomba inisialisasi malas. Ini seharusnya tidak dilakukan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="gambar"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas LazyInitRace berisi kondisi lomba. Misalkan utas A dan B mengeksekusi metode getInstance secara bersamaan. A melihat bahwa bidang instance adalah nol, dan membuat ExpensiveObject baru. Thread B juga memeriksa untuk melihat apakah bidang instance adalah nol yang sama. Kehadiran nol di lapangan pada saat ini tergantung pada koordinasi waktu, termasuk keanehan perencanaan dan jumlah waktu yang diperlukan untuk membuat turunan dari Proyek Mahal dan menetapkan nilai dalam bidang contoh. Jika bidang instance adalah nol ketika B memeriksanya, dua elemen kode yang memanggil metode getInstance bisa mendapatkan dua hasil yang berbeda, bahkan jika metode getInstance seharusnya selalu mengembalikan instance yang sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penghitung hit di UnsafeCountingFactorizer juga berisi kondisi balapan. Pendekatan "baca, ubah, tulis" menyiratkan bahwa untuk menambah penghitung, aliran harus mengetahui nilai sebelumnya dan memastikan bahwa tidak ada orang lain yang mengubah atau menggunakan nilai ini selama proses pembaruan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti kebanyakan kesalahan kompetitif, kondisi balapan tidak selalu mengarah pada kegagalan: koordinasi sementara berhasil. </font><font style="vertical-align: inherit;">Tetapi jika kelas LazyInitRace digunakan untuk instantiate registri seluruh aplikasi, maka ketika itu akan mengembalikan contoh yang berbeda dari beberapa aktivasi, pendaftaran akan hilang atau tindakan akan menerima representasi yang saling bertentangan dari set objek terdaftar. </font><font style="vertical-align: inherit;">Atau jika kelas UnsafeSequence digunakan untuk menghasilkan pengidentifikasi entitas dalam struktur konservasi data, maka dua objek yang berbeda dapat memiliki pengidentifikasi yang sama, melanggar batasan identitas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Tindakan majemuk</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LazyInitRace dan UnsafeCountingFactorizer mengandung urutan operasi yang harus bersifat atomik. </font><font style="vertical-align: inherit;">Tetapi untuk mencegah kondisi balapan, harus ada hambatan bagi utas lain untuk menggunakan variabel sementara satu utas memodifikasinya.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi A dan B adalah atom jika, dari sudut pandang operasi yang menjalankan thread A, operasi B dilakukan seluruhnya oleh thread lain atau bahkan tidak dilakukan sebagian.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomicity dari operasi kenaikan di UnsafeSequence akan menghindari kondisi balapan yang ditunjukkan pada Gambar. 1.1. Operasi "periksa dan kemudian bertindak" dan "baca, ubah, tulis" harus selalu berupa atom. Mereka disebut tindakan gabungan - urutan operasi yang harus dilakukan secara atom agar tetap aman. Pada bagian selanjutnya, kami akan mempertimbangkan penguncian - sebuah mekanisme yang dibangun di Jawa yang menyediakan atomitas. Sementara itu, kami akan memperbaiki masalah dengan cara lain dengan menerapkan kelas aman-thread yang ada, seperti yang ditunjukkan dalam Penghitung faktor di Listing 2.4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.4. Permintaan penghitungan servlet menggunakan AtomicLong</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paket java.util.concurrent.atomic berisi variabel atom untuk mengelola status kelas. Mengganti tipe penghitung dari panjang ke AtomicLong, kami menjamin bahwa semua tindakan yang merujuk pada status penghitung adalah atomic1. Karena keadaan servlet adalah keadaan penghitung, dan penghitung itu aman dari benang, servlet kami menjadi aman dari benang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika elemen keadaan tunggal ditambahkan ke kelas yang tidak mendukung keadaan internal, kelas yang dihasilkan akan aman thread jika negara sepenuhnya dikendalikan oleh objek aman thread. Tetapi, seperti yang akan kita lihat di bagian berikutnya, transisi dari satu variabel keadaan ke variabel berikutnya tidak akan semudah transisi dari nol ke satu.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika nyaman, gunakan objek aman yang ada, seperti AtomicLong, untuk mengontrol keadaan kelas Anda. </font><font style="vertical-align: inherit;">Kemungkinan status objek thread-safe yang ada dan transisinya ke status lain lebih mudah dipelihara dan diperiksa keamanannya daripada variabel status arbitrer.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Â»Informasi lebih lanjut tentang buku ini dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situs web penerbit</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Â» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isi</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Â» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kutipan</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Untuk Khabrozhiteley Diskon 25% untuk kupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jawa</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489022/index.html">Menggunakan RabbitMQ dengan MonsterMQ Bagian 2</a></li>
<li><a href="../id489024/index.html">Perpustakaan Webix JavaScript melalui mata seorang pemula. Bagian 5. Bekerja dengan data di sisi pengguna</a></li>
<li><a href="../id489026/index.html">Mengubah Algoritma Google AdSense Dapat Mengarah ke Pemilik Situs dan Webmaster</a></li>
<li><a href="../id489028/index.html">Tentang kerja jarak jauh</a></li>
<li><a href="../id489034/index.html">Aplikasi seluler UIS yang baru - siksaan atau keselamatan bagi mereka yang mencari pengadaan publik?</a></li>
<li><a href="../id489040/index.html">Contact Center AI: pihak ketiga dalam percakapan baik-baik saja</a></li>
<li><a href="../id489042/index.html">Pembukaan kembali Grand Store: memuat data ke Android menggunakan coroutine</a></li>
<li><a href="../id489044/index.html">Fisika teks. Bagian 1. Simbol</a></li>
<li><a href="../id489046/index.html">Mengemudi Sendiri GAZ66 Monster Truck 1/16</a></li>
<li><a href="../id489048/index.html">Pencatatan dan penelusuran kueri adalah praktik terbaik. Laporan Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>