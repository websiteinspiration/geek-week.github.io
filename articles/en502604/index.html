<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèΩ üîö üè´ An Introduction to TLS for Patrik Patrick (Part 1) ‚õàÔ∏è üë©üèº‚Äçüç≥ üîÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you may already know, this is Patrick. He is a starfish, which means that it is possible, without insulting him, to say that his hands are growing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>An Introduction to TLS for Patrik Patrick (Part 1)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plesk/blog/502604/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you may already know, this is Patrick. He is a starfish, which means that it is possible, without insulting him, to say that his hands are growing from one place. Patrick is also very practical and immediately forgets everything that he does not need - but if he needs something, he wants to know it (because he needs it!). Spoiler: here Patrick is trying to do a TLS Handshake. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/aa/64/diaa64cwcj8dktjvcv-4ba6wtbg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article is written for Patrick and people like him. She was born from a presentation first shown at our internal educational Plesk TechTalk, where employees in an accessible form share information with each other about interesting technologies, processes and solutions. Therefore, the pictures in this article will look like slides :) The author of the original text of the report is program manager Plesk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruslan Kosolapov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, all TLS material covers some small aspect, but not the big picture. </font><font style="vertical-align: inherit;">This is not very practical and Patrick has a headache from this. </font><font style="vertical-align: inherit;">Everything will be different here: briefly, applicable ‚Äúin everyday life‚Äù and as exhaustively as possible.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is TLS and why is it to Patrick</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLS (Transport Layer Security) is a transport layer protection protocol. It is needed so that no one can "listen" to you and find out some important information (most often passwords, if we talk about working on the network). And also in order to protect themselves from falsification and traffic modification during transmission. It is in these two things that the purpose of TLS lies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity, let's consider TLS handshake as a call to Patrick SpongeBob. During a call, someone can eavesdrop on the conversation (standing next to Patrick or turning on in the middle of the line), and generally the Sponge Bob may not be on the other end - all these problems are relevant. And to solve them, Patrick wants to use TLS. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In short, the top-level handshake looks like this: </font></font></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrick:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I want to use TLS, the cipher versions are such and such.</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spongebob:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ok, let's use cipher versions such and such. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, SpongeBob sends the certificate, Patrick checks it, says that everything is fine, the session key is done (there are actually two of them, but it doesn‚Äôt matter). Why use a session key rather than asymmetric encryption - because it's faster. After that, they begin to speak a language incomprehensible to decryption. Thus, everything is protected. </font></font><br>
<img src="https://habrastorage.org/webt/na/xj/yu/naxjyufzfjvlcazi16qsmlf5muq.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything seems to be simple. How it works on hardware is not so important for us. But if you start to think - and Patrick begins to think! - that begs the question of how to generally agree that we will use TLS? After all, once there was no TLS, but there were only ordinary protocols - SMTP, HTTP. How to say what is needed on TLS? And here in our industry everything is as usual - there are many ways!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first they wanted to use a specific port, which would imply the use of TLS on it. </font><font style="vertical-align: inherit;">What are the disadvantages of this? </font><font style="vertical-align: inherit;">And why then did the explicit (explicit) method for starting a TLS session appear? </font><font style="vertical-align: inherit;">There are several reasons:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need a lot of ports - and ports are such a thing that you don‚Äôt want to spend. </font><font style="vertical-align: inherit;">Because the more there are, the more difficult it is to configure the firewall.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The server can ignore this - it has connected to port 443, and there is no TLS there, only HTTP without any HTTPS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Before the connection is established, you cannot find out if the TLS server is supported or not.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this led to the emergence of an explicit method - when we connect to a regular port, and then upgrade our session to TLS. </font><font style="vertical-align: inherit;">For different services, the protocol has different commands, for example, for SMTP there is a separate command at the level of the SMTP protocol - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STARTTLS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">HTTP also has such a joke, it is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upgrade: TLS / 1.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">At the protocol level, it is easier to understand whether a TLS server is supported or not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us dwell a little more on the different types of connections and how things are with TLS for them.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect: HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything would be easy if, as always, there were no nuances. In the case of HTTP, the growing security requirements provide a constant evolution of the process of working with TLS. At first there was a redirect to HTTPS, and this was done simply in the header. This left a loophole for vulnerabilities, so fellow Google came up with HSTS (HTTP Strict Transport Security). This is such a heading in the HTTP response that tells the browser: ‚Äúplease remember that when you come to this domain, go directly to HTTPS, even if the person told you to go to HTTP‚Äù. Thus, there is no redirect and everything happens much safer. In addition, Google has another initiative - you can leave a request so that your site is added to the list for Google Chrome ‚ÄúAlways use HTTPS‚Äù, regardless of any headings. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HSTS solves the redirect from HTTP to HTTPS vulnerabilities, so almost all browsers support HSTS, which is good.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect: exotic (new versions of HTTP and not only)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In HTTP / 2, things are good with TLS: it is always used (as browsers are now made). </font><font style="vertical-align: inherit;">In addition, TLS in HTTP / 2 must be fresh - that is, have version 1.2+. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most likely, very soon Google will sell the widespread use of HTTP / 3, now it is adopted by the IANA standard. </font><font style="vertical-align: inherit;">The story of its appearance and development is rather confusing; </font><font style="vertical-align: inherit;">The main thing to remember Patrick:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTTP / 3 is always TLS 1.3+.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 3 is based on QUIC - it is such a protocol over UDP, which, according to Google, is better than TCP. </font><font style="vertical-align: inherit;">Actually, before the name HTTP / 3 was finally approved, the protocol was called HTTP-over-QUIC.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is still an interesting SCTP protocol, which is used mainly in telecom. </font><font style="vertical-align: inherit;">Above it, both TLS and DTLS are used (this is such TLS for UDP). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in 2 years, QUIC (i.e. HTTP / 3) will be used everywhere, but now there should already be HTTP / 2 everywhere, but in reality it is not everywhere.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect: Mail</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many clients believe that there should be TLS on the 587th port, but there are also nuances here: someone expects TLS by default, and someone expects an explicit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STARTTLS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> request </font><font style="vertical-align: inherit;">from the client. Because of this, various combinations of mail server and mail client sometimes cause unwanted effects. For example, a client enters port 587, expecting that there will be TLS, while the server waits for the client to explicitly request </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STARTTLS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Having received nothing, the client rolls back to port 25. The result is a silent switch to an insecure SMTP connection. When testing and developing, it is worth remembering about such effects of client-server combinations. Autodiscaver has various options for specifying TLS: how it should be, what is expected, and what to do. Many mail clients understand these things. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with TLS support in mail servers and mail clients everything is fine in general, but in particular cases there may be problems and TLS extensions are not very well supported.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect: FTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Little can be said here. </font><font style="vertical-align: inherit;">The main problem is SNI (this is when different domains are on the same IP). </font><font style="vertical-align: inherit;">At the FTP level, the domain name is not transferred. </font><font style="vertical-align: inherit;">In an explicit version, it cannot work, because there is nowhere to write it. </font><font style="vertical-align: inherit;">There are several solution options - some offer so, others so, a general solution has not yet been adopted, there is no standard. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly: there</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is some kind of TLS support for FTP (FTPS, SFTP - an analogue of FTP implemented through SSH), but some aspects are not covered due to the technical limitations of FTP itself.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS Handshake</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, now we know how to initiate communication using TLS in different connections, and Patrick was able to communicate his desire to SpongeBob. </font><font style="vertical-align: inherit;">Once they have agreed that they will use TLS, TLS Handshake is produced. </font><font style="vertical-align: inherit;">Its result should be an agreement between the client and server on how they encrypt it all. </font><font style="vertical-align: inherit;">In addition, the client must make sure that the server is the one that is needed. </font><font style="vertical-align: inherit;">Sometimes the server also checks the client (but much less frequently).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ciphers and Versions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As already mentioned, the first step is to choose which version of TLS and which ciphers will be used for encryption. </font><font style="vertical-align: inherit;">Typically, a cipher looks like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7j/bc/ne/7jbcnel13ieehyi6h6ibu9gi7r4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A set of ciphers is in the IANA registry, and in the TLS protocol in binary form is only its ID. </font><font style="vertical-align: inherit;">As you can see in the figure, here is not just (and not only) the cipher, but also its operating mode and other details necessary for TLS-handshake. </font><font style="vertical-align: inherit;">Patrick does not need to go into details. </font><font style="vertical-align: inherit;">All that is important at this stage is to remember that these letters are good (and the rest are bad):</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DHE</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECDhe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AES128</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AES256</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RSA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ecdsa</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cbc</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gcm</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SHA256</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SHA383</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CHACHA20</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POLY1308</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Picture for remembering good ciphers: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/oz/us/5oozuswdmgo1dmropfliew8ee3w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If it's hard to remember, there are good services that can tell you about it, for example, a service from Mozilla </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssl-config.mozilla.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/im/06/g0/im06g0jqgsdkw3kbie0c3lzfjcq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can immediately see where and how it is supported - this is what the Mozilla guys are trying to follow. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An interesting detail: the client transfers the ciphers in order of priority according to their preferences, but the decision is up to the server - it selects the cipher that it seems to be the best from the list of supported by the client. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Both sides also indicate the maximum supported version of the protocol - in this case, Patrick is more advanced than SpongeBob.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually certificate</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Together with the answer ‚ÄúLet's do it like this‚Äù, the server sends its certificate or certificates - there can be many of them. </font></font><br>
<img src="https://habrastorage.org/webt/ay/9m/p-/ay9mp-c7akdltxlnomatwwq1zdq.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is a certificate? This is a relationship of information (subject) - most often it is the name of a domain or organization - and a public key (public key). That is, the certificate says: ‚ÄúDude, my public key is like that. Now, with his help, we will agree on session keys. ‚Äù Also, with its help, you can check the signature of certificates or something else. That is, in principle, it would be possible to use not certificates, but registries where this relationship is indicated. And in fact, steps in this direction are continuing, because the Certificate Authority mechanism is considered not very good, there is simply nothing else.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the certificate is the structure of 'Subject: Public key' plus the signature of the ishyuer (issuer in transliteration into Russian looks awful, but the closest synonym here is not very close in context to the ‚Äúissuer‚Äù) that this certificate was issued. Ish√ºyer also has a certificate and someone‚Äôs connection with something. You can check the certificate for correctness by taking the public key of the ishyuere and checking the signature. As a result, nothing can be faked here. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's go over the certificate and see what problems it might have. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/14/gt/ox/14gtoxx4czgwthkckj2vjyjfnbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, the serial Number implies uniqueness only within the limits of the ishyuere, although some software considers that it is unique in the whole universe. Fortunately, more often than not, it is truly completely unique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The certificate also indicates which algorithms are used for encryption and signing: RSA or ECDSA - that is, which cryptography to use to work with this public key. The main difference between RSA and ECDSA is that the mathematical principle of ECDSA is based on elliptic curves, and RSA is just on natural numbers, so it is slower and huge keys bits (3-4 thousand) are used to prevent cracking it . And for ECDSA, a 300-bit key is enough and it works faster. Therefore, many are switching to ECDSA - the handshake itself is heavy and I want to reduce it. ECDSA can be asked for when issuing a certificate, and if the prospector supports it, he will do it for you. But the signature of the certificate depends on what private key ishuiur currently has, and not on whether you asked for ECDSA or RSA.Therefore, browsers can show that one is in the signature and the other in the public key, and there is no need to be afraid if the signature is not ECDSA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to get a certificate?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In short - like this: </font></font><br>
<img src="https://habrastorage.org/webt/th/7f/f1/th7ff1g-1g54v0t-_genzf3rc3u.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patrick tells the Certificate Authority: I need a certificate. </font><font style="vertical-align: inherit;">This person (or organization) checks to see if it is Patrick. </font><font style="vertical-align: inherit;">Checks can be very different. </font><font style="vertical-align: inherit;">Of course, Patrick as a client may not have a certificate, but if the server does not have a certificate, then there will be no TLS. </font><font style="vertical-align: inherit;">It is checked whether everything is correctly indicated in the certificate application, whether Patrick really owns the subject for which he is requesting a certificate. </font><font style="vertical-align: inherit;">This is done by higher Certificate Authority centers - conditional people whom everyone believes. </font><font style="vertical-align: inherit;">To issue a certificate, you need to draw up a CSR (Certificate signing request, a request for a certificate).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z1/mi/dk/z1midktpy8soeqqaz_xah-w0sn8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is also a structure, which is quite difficult to work with, because there are few services that allow you to set, specify, verify and see everything. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total, we generate a pair of public key: private key, but we give only the public, and hide the private. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we generate a Certificate Signing Request and sign it with our private key. </font><font style="vertical-align: inherit;">We send all this to the certification authority, and it starts the verification. </font><font style="vertical-align: inherit;">It can be different, for especially cool certificates there are special tricky procedures, but we will dwell on the general case.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAA RR</font></font></h2><br>
<img src="https://habrastorage.org/webt/pg/rh/lw/pgrhlwwd8la4_perxzg4zawlyjy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is such a problem that people whom everyone believes are sometimes not very good. One of the reasons Symantec has become part of DigiCert is because it (Symantec) issued certificates without asking domain owners. You can‚Äôt do this, it was insulting to everyone, but most of all to Symantec itself, because you had to sell your business. To make the server less dependent on such unscrupulous comrades, there is such a thing as CAA RR - a record in DNS, where it says who the owner allows to issue certificates for his domain. This feature is also in Plesk, it is used little so far, approximately like DNSSec, but nonetheless. All certification authorities agreed to check this entry and if it says that this certification authority cannot be issued, it will say: ‚Äúyou did not pass validation, it‚Äôs written in CAA RR,that I can‚Äôt write out a certificate for you ‚Äù- and will not write it out. If there is no entry, then you can. Now Google is pushing the initiative so that customers check the certificate they received for compliance with CAA RR records. The debate is still ongoing.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, CAA RR from the moment we made their support in Plesk expanded by indicating validation methods (that is, you can also indicate here by which method you validate that this domain is yours) and Account URI (Uniform Resource Identifier). </font><font style="vertical-align: inherit;">Popular among users Plesk Let's Encrypt already supports all this (well done!). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this works for any type of certificate, and since we will talk about the differences later, it's time to talk about the types in more detail.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certificate Types</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are three of them:</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Domain validation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The subject is a domain, that is, here we check only it. </font><font style="vertical-align: inherit;">Previously, when there were no automatic validators, validation took place mainly by e-mail through the Whois service. </font><font style="vertical-align: inherit;">This was considered sufficient reason to believe that you are the owner of this domain. </font><font style="vertical-align: inherit;">Then they thought up checking through DNS - they wrote to you by e-mail: ‚Äúand add such and such a record to DNS‚Äù. </font><font style="vertical-align: inherit;">Later automatic methods appeared (we will talk about ACME a little further).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organization validation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the ‚Äúsubject‚Äù field, in addition to the domain name, the name of the organization is also indicated. </font><font style="vertical-align: inherit;">The check consists in validating whether the domain belongs to this organization and whether the person who came for the certificate works there. </font><font style="vertical-align: inherit;">How this is done: they look for organizations on the registers, call, ask for something to be done (the phone turned out to be correct, the right person answered, which means that most likely everything is fine).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extended validation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Same as OV, only cooler. Everything is very regulated here - a 40-page document in the spirit of "in paragraph 5.6.8 should be the following: ...", etc. A lot of things are checked - the country, the department (if indicated in the application), and sometimes a special person even leaves to see with his eyes. What is the practical difference? Almost all browsers have ceased to distinguish between OV and DV, and this is bad, because in this case the name of the organization is not displayed. As a result, no one bothers to create a domain aliepxress.ru, draw the same page and steal credit cards. And it will be absolutely legitimate to create any such domain and get a DV certificate on it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example with EV - the name of the organization is visible here, so if anyone steals something, the user will know that it was Valve Corp corporation, and registering the corporation is somewhat more difficult than the domain (more checks). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6p/kp/kc/6pkpkccn848gjwl1osfx_yc0gjy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, everything goes to the point where EV will cease to be different, on mobile devices it is no longer visible and you need to press a separate button, and in Safari too. </font><font style="vertical-align: inherit;">Google Chrome is still holding (UPD - no longer! I had to make a screen from IE). </font><font style="vertical-align: inherit;">The argumentation of those who do not show: ‚Äúif you are worried, click and look,‚Äù but no one naturally presses.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtaining a Certificate: Automation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's talk about the automated receipt of DV certificates. </font><font style="vertical-align: inherit;">For clarity, let's see how our favorite Let's Encrypt does it. </font><font style="vertical-align: inherit;">He generally has good documentation, if anyone is interested, and even in Russian.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACME</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ACME (Automatic Certificate Management Environment) is a protocol designed to automate and standardize the process of obtaining a certificate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How does ACME prove you are a domain owner? </font><font style="vertical-align: inherit;">You say: I want a certificate and indicate the type of automatic validation - for example, ACME HTTP-01. </font><font style="vertical-align: inherit;">Let's Encrypt asks you to put the data in a file, and if you could put the files on your domain (and Let's Encrypt could pick them up from there via HTTP), you are probably its owner. </font><font style="vertical-align: inherit;">Now this approach is criticized, including from Google, because it does not protect against phishing. </font><font style="vertical-align: inherit;">That is, with manual validation, the aliepxress.ru domain is likely to arouse suspicion, but Let's Encrypt itself so far does not know how (or it can, but badly).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNS challenge</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to ACME, there is also a DNS challenge. </font><font style="vertical-align: inherit;">For example, they tell you: enter a txt record in your DNS zone, put the data in it. </font><font style="vertical-align: inherit;">There are other ways, but not common, and one was canceled altogether, because it turned out to be vulnerable. </font><font style="vertical-align: inherit;">What we have in Plesk: wildcard certificates (which can only be written out using the DNS challenge) do not work for many people, because very often Plesk does not manage the domain‚Äôs DNS zones and extension </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's Encrypt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cannot automate the creation of a record in the DNS zone .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two more words about Let's Encrypt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An important aspect in working with Let's Encrypt certificates is limits. </font><font style="vertical-align: inherit;">In case of doubt (or suspicion that they have been achieved), it is best to follow the link: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letsencrypt.org/docs/rate-limits</font></font></a><br>
<img src="https://habrastorage.org/webt/c0/lx/5g/c0lx5gabymsjx5fzdqfvn1lk-ku.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sometimes they are updated. </font><font style="vertical-align: inherit;">There are unobvious limits that people forget about: most often, judging by requests for support, they are faced with a limit of 100 domain names in the certificate. </font><font style="vertical-align: inherit;">Let's Encrypt also has a staging server and there are more limits, but such certificates are considered non-trusted and for the browser they are similar to self-signed. </font><font style="vertical-align: inherit;">In practice, with a limit of 100 names, they rarely come to us (despite the fact that sites on Plesk have a total of 1,300,000 Let's Encrypt certificates). </font><font style="vertical-align: inherit;">Median, according to our statistics, is 20 names per certificate. </font><font style="vertical-align: inherit;">So if something doesn‚Äôt work, look - maybe the limit is reached. </font><font style="vertical-align: inherit;">Let's Encrypt has good error reporting, and you can usually understand what happened.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What's next?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, after the certificate is received, the server transmits the session key data - this is what will be used for encryption. </font><font style="vertical-align: inherit;">If the server considers that it is necessary to authenticate the client (for example, access is open only to a certain circle of persons), he may ask: the client, who are you? </font><font style="vertical-align: inherit;">And then the client will need to send his certificate. </font><font style="vertical-align: inherit;">After receiving the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ServerHelloDone</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> message </font><i><font style="vertical-align: inherit;">, the</font></i><font style="vertical-align: inherit;"> client realizes that it is time to verify the certificates and work with the keys. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything that we talked about, before TLS 1.3 goes through an open channel, and anyone can see all these things. </font><font style="vertical-align: inherit;">There are several interesting attacks that you can read about yourself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the second </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">series</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the article, we will learn how the client verifies the certificate.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502588/index.html">The incredible story of PowerPoint</a></li>
<li><a href="../en502592/index.html">Neomorphism using SwiftUI. Part 1</a></li>
<li><a href="../en502594/index.html">7 reasons why web projects are not brought to an end, and how to deal with it</a></li>
<li><a href="../en502596/index.html">Free quarantine educational courses: design</a></li>
<li><a href="../en502598/index.html">Security Week 21: Windows Print Service Vulnerability</a></li>
<li><a href="../en502608/index.html">How we started the marketplace of applications in the SaaS service</a></li>
<li><a href="../en502614/index.html">Kubernetes best practices. Setting Queries and Resource Limits</a></li>
<li><a href="../en502620/index.html">Money accounting</a></li>
<li><a href="../en502624/index.html">How do they work on Facebook? Values ‚Äã‚Äãand hiring in a company</a></li>
<li><a href="../en502626/index.html">Automatic iOS screenshots using XCTestplan and Xcode 11</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>