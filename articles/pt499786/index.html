<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛷 💪🏾 👏🏿 Classificação de pilha fraca 🐶 😩 🚣🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De todo o zoológico, essa estrutura é talvez a mais incomum. Ao mesmo tempo, a simplicidade elegante do algoritmo corresponde à sua incrível excentric...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Classificação de pilha fraca</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/499786/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><div style="text-align:center;"><img width="765" height="430" src="https://habrastorage.org/webt/hh/ve/rt/hhvertyrtwsbd99rbboihxxyjjk.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De todo o zoológico, essa estrutura é talvez a mais incomum. </font><font style="vertical-align: inherit;">Ao mesmo tempo, a simplicidade elegante do algoritmo corresponde à sua incrível excentricidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao classificar usando um heap fraco, sempre há menos comparações e trocas do que usar um heap regular. </font><font style="vertical-align: inherit;">Então, sim, uma pilha fraca é mais forte que uma pilha comum.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="EDISON Software - desenvolvimento web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - desenvolvimento web"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo foi escrito com o apoio da EDISON. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estamos envolvidos na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">criação de software embarcado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bem como no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desenvolvimento de aplicativos e sites da web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adoramos a teoria dos algoritmos! </font><font style="vertical-align: inherit;">;-)</font></font></blockquote><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilha fraca</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um heap regular é uma árvore de classificação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na qual qualquer pai é maior (ou igual) que qualquer um de seus descendentes. </font><font style="vertical-align: inherit;">Em uma pilha fraca, esse requisito é enfraquecido - qualquer pai é maior que (ou igual a) qualquer descendente apenas de sua subárvore direita. </font><font style="vertical-align: inherit;">Na subárvore esquerda, os descendentes podem ser menores e maiores que o pai, então você tem muita sorte.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="299" src="https://habrastorage.org/webt/by/f6/ef/byf6efzj8swlst2y_2dvb7onduu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem pode reduzir significativamente o custo de manutenção do conjunto de dados em um estado de heap. </font><font style="vertical-align: inherit;">Afinal, é necessário garantir que o princípio “um descendente não seja mais que um pai” não para toda a estrutura, mas apenas para metade dela. </font><font style="vertical-align: inherit;">Ao mesmo tempo, uma pilha fraca, não sendo uma árvore de classificação 100%, não é pior do que uma pilha comum e, de certa forma, ainda melhor. </font><font style="vertical-align: inherit;">Fez metade da batalha - ande com ousadia! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a raiz da pilha, mesmo que fraca, precisa exatamente do elemento maior, a raiz da subárvore esquerda não.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimizar o número de comparações</font></font></h2><br>
<img align="left" width="215" height="199" src="https://habrastorage.org/webt/ng/cu/e1/ngcue1zei7olyudhfpge5blkcgu.jpeg"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ronald D. Dutton, especialista em algoritmos e teoria de grafos, nos apresentou um grupo fraco em 1993. </font><font style="vertical-align: inherit;">Uma pilha conceitualmente fraca é mais difícil de entender (mas é mais provável que essa dificuldade não seja na complexidade, mas na extravagância, você precisa quebrar seus padrões de consciência pelo joelho) do que uma pilha comum, por isso não recebeu muita distribuição prática. </font><font style="vertical-align: inherit;">No entanto, quando Dutton inventou essa estrutura, ele não apenas queria praticar abstrações abstratas, mas também buscava um objetivo completamente pragmático. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe um limite teórico mais baixo para estimar o número mínimo de comparações (naquelas ordenações em que essas comparações são amplamente usadas): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">= </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ln 2 + O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), onde 1 / ln 2 = 1,4426 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na classificação por um heap fraco, o número de comparações é minimizado e está próximo o suficiente do limite inferior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso pode ser de importância prática se você precisar organizar objetos cuja comparação seja cara, por exemplo, se for para classificar cadeias longas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malabaristas descendentes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Esquerda" e "direita" em uma pilha fraca são um fenômeno situacional. Uma subárvore pode ser descendente esquerda ou direita para seu nó pai - além disso, essa relação "esquerda / direita" para a subárvore e o pai pode alternar repetidamente de um valor para o oposto durante o processo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indicar para o pai que tem o filho certo e a filha esquerda não é simples, mas muito simples. Para fazer isso, você precisa de um bitmap adicional (que consiste apenas em valores de 0/1) para os nós que têm descendentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de como o índice é o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento pai, definimos os índices de seus descendentes esquerdo e direito em uma pilha convencional (índices da matriz medidos a partir de zero): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente esquerdo 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente direito 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma pilha fraca, temos uma cereja no bolo - uma raiz que possui apenas a subárvore direita, portanto, ajustaremos essas fórmulas para os índices descendentes adicionando um deslocamento reverso para 1 posição: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente esquerdo: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Descendente direito: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E finalmente , precisava de bitmap adicional (chame de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), em que o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento observado era se a troca de lugar entre as subárvores esquerda e direita. Se o valor para um elemento for 0, não houve troca. Se o valor for 1, os filhos esquerdo e direito vão na ordem oposta. E as fórmulas nesse caso são as seguintes: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente esquerdo: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente direito: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É assim que parece. </font><font style="vertical-align: inherit;">Os elementos cujos descendentes estão localizados "vice-versa" são destacados em azul. </font><font style="vertical-align: inherit;">Os valores na matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para eles são 1.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="330" src="https://habrastorage.org/webt/h0/by/bm/h0bybmjxpw21mdj1x3uyamtsyk4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode verificar substituindo os valores-pai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o 0/1 correspondente da matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nas fórmulas descendentes </font><font style="vertical-align: inherit;">- os índices dos descendentes serão exibidos conforme necessário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, para qualquer pai trocar as subárvores esquerda e direita, na própria matriz, o grupo de elementos não precisa ser movido para lugar algum. </font><font style="vertical-align: inherit;">Somente o valor 0/1 do pai na matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é </font><b><font style="vertical-align: inherit;">alterado</font></b><font style="vertical-align: inherit;"> e é isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Próximo - uma sessão de mágica com sua subsequente exposição.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construa uma pilha fraca</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trocar descendentes esquerdo e direito é a principal ferramenta para converter em um monte fraco um conjunto de dados de uma matriz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No processo de formação do heap fraco primário, precisamos classificar os elementos da matriz na ordem inversa (começando pela última) e para cada um deles encontrar a ramificação do primeiro pai (direito), para o qual será a subárvore correta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o elemento é o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendente certo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de alguém </font><font style="vertical-align: inherit;">, você não precisa ir muito longe. </font><font style="vertical-align: inherit;">Seu pai imediato é o que você precisa:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/tg/_4/01/tg_401fvyqumg-j_nbwm1-n_bna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o elemento for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendente esquerdo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de alguém </font><font style="vertical-align: inherit;">, você precisará subir vários níveis antes de conhecer o avô desejado, para o qual o elemento está na subárvore direita:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/lk/ud/-f/lkud-fixce2hbm1d7ejuil3pnh8.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então você precisa comparar o descendente e o progenitor encontrado em algum lugar acima. </font><font style="vertical-align: inherit;">E se o descendente for maior que o progenitor, o seguinte deverá ser feito:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o descendente tiver seus descendentes, troque as subárvores esquerda e direita (ou seja, alterne 0/1 na matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para esse elemento).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troque os valores do nó descendente e do nó progenitor.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dê uma olhada em um exemplo específico. </font><font style="vertical-align: inherit;">Digamos que a seguinte situação surgiu:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/8f/-8/kr/8f-8krbczd6kxh2o-cbbe4hdkdc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o elemento da matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] = 87, </font><font style="vertical-align: inherit;">foi encontrado </font><font style="vertical-align: inherit;">o progenitor necessário </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] = 76. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O progenitor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] é menor que o elemento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] (76 &lt;87). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O elemento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] possui subárvores esquerda e direita (marcadas em tons de verde). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você precisa trocar essas subárvores </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(ou seja, para o elemento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] na matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">altere o valor de 0 para 1). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também é necessário trocar os valores dos elementos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1].</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Após as ações necessárias serem concluídas:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/zy/fb/vb/zyfbvbqsvoyyidown3ljp5pe8mk.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o elemento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6], as subárvores esquerda e direita foram trocadas </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(ou seja, na matriz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do elemento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6], o valor de 0 foi alterado para 1). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Houve também uma troca de valores entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você percorrer a matriz do fim ao início e, ao longo do caminho, executar este procedimento para todos os elementos, terá uma pilha fraca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que esse mecanismo estranho funciona é uma explicação mais próxima do final do artigo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisando uma pilha fraca</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um heap é um heap se o elemento máximo estiver na raiz. Usando esse fato, todas as classificações de heap funcionam da mesma maneira. A raiz (onde o máximo está localizado) troca valores com o último elemento da parte não classificada da matriz - como resultado, a parte não classificada da matriz diminui e a parte classificada da matriz aumenta. Após essa troca, o heap deixa de ser um heap, pois o elemento máximo atual não está mais em sua raiz. O heap precisa ser restaurado, ou seja, tornar a árvore resultante um heap novamente - encontre outro elemento máximo e mova-o para a raiz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como recuperar uma pilha binária regular, sabemos - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com a ajuda de uma peneira</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mas como restaurar uma pilha fraca? Para fazer isso, faça o seguinte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da raiz descemos os descendentes esquerdos (da direita para a mais baixa):</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/ka/d1/t8/kad1t8a7egmsgtgrpuqk6txqajc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, subimos os descendentes esquerdos de volta e, ao longo do caminho, cada descendente esquerdo é comparado com um elemento na raiz da pilha. </font><font style="vertical-align: inherit;">E se o próximo descendente esquerdo for maior que a raiz, faremos o mesmo que no estágio anterior: no descendente esquerdo, trocamos as subárvores (se ele tiver um) e alteramos os valores do descendente e raiz esquerdos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, restauraremos o heap fraco - o elemento máximo que está na árvore restante aparecerá na raiz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, novamente, temos este carrossel místico com subárvores que se substituem. </font><font style="vertical-align: inherit;">Então, qual é o segredo do sucesso? </font><font style="vertical-align: inherit;">Por que, se durante a troca de nós com valores, os descendentes esquerdo e direito do nó inferior são trocados, terminamos com uma matriz classificada? </font><font style="vertical-align: inherit;">Você nunca vai adivinhar, embora a resposta seja simples em seu gênio.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação fraca de heap :: Classificação fraca de heap</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, o algoritmo final:</font></font><br>
<br>
<ul>
<li><b>I.     :</b><ul>
<li><b>I.1.</b>    -.</li>
<li><b>I.2.</b>           «» .</li>
<li><b>I.3.</b>       .</li>
<li><b>I.4.</b>       , :<ul>
<li><b>I.4..</b>   ( ⇔ )     ,     .</li>
<li><b>I.4..</b>    «»      .</li>
</ul></li>
</ul></li>
<li><b>II.            ,     :</b><ul>
<li><b>II.1.</b>           .</li>
<li><b>II.2.</b>             .         .</li>
<li><b>II.3.</b>        ,        .   :<ul>
<li><b>II.3..</b>          .</li>
<li><b>II.3..</b>        ,      .</li>
<li><b>II.3..</b>     ,    , :<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c. 1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trocamos subárvores (esquerda ⇔ direita) com descendentes pelo nó no qual o descendente esquerdo atual está localizado.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alteramos a raiz da pilha e o nó com o filho esquerdo atual.</font></font></li>
</ul></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4 </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na raiz do heap fraco está novamente o elemento máximo para a parte restante não classificada da matriz. </font><font style="vertical-align: inherit;">Retornamos ao parágrafo II.1 e repetimos o processo até que todos os elementos sejam classificados.</font></font></li>
</ul></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animação (os índices de matriz em minhas animações começam com um):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código C ++</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na parte inferior da seção "Links", os interessados ​​podem se familiarizar com a implementação dessa classificação em C ++. </font><font style="vertical-align: inherit;">Aqui, dou apenas a parte que ilustra o próprio algoritmo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GETFLAG(r, x) ((r[(x) &gt;&gt; 3] &gt;&gt; ((x) &amp; 7)) &amp; 1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOGGLEFLAG(r, x) (r[(x) &gt;&gt; 3] ^= 1 &lt;&lt; ((x) &amp; 7))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapMerge</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *r, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">if</span> (wheap[i] &lt; wheap[j]) {<span class="hljs-comment">//""  ?</span>
    <span class="hljs-comment">//  ,   </span>
    <span class="hljs-comment">//( "",   "")</span><font></font>
    TOGGLEFLAG(r, j);<font></font>
    <span class="hljs-comment">//  ""  </span><font></font>
    swap(wheap[i], wheap[j]);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapSort</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = Size();
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) {<font></font>
		<font></font>
    <span class="hljs-keyword">int</span> i, j, x, y, Gparent;
    <span class="hljs-keyword">int</span> s = (n + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> [s];<font></font>
		<font></font>
    <span class="hljs-comment">//  ,    </span>
    <span class="hljs-comment">// "",   ""</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">8</span>; ++i) r[i] = <span class="hljs-number">0</span>;<font></font>
		<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {<font></font>
      j = i;<font></font>
      <span class="hljs-comment">//    , </span>
      <span class="hljs-comment">//   ""  </span>
      <span class="hljs-keyword">while</span> ((j &amp; <span class="hljs-number">1</span>) == GETFLAG(r, j &gt;&gt; <span class="hljs-number">1</span>)) j &gt;&gt;= <span class="hljs-number">1</span>;
      <span class="hljs-comment">//       ""  </span>
      Gparent = j &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">//  ,   </span>
      <span class="hljs-comment">//   ""</span><font></font>
      WeakHeapMerge(r, Gparent, i);<font></font>
    }<font></font>
		<font></font>
    <span class="hljs-comment">//      --&gt;</span>
    <span class="hljs-comment">//  --&gt;    </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) {
      <span class="hljs-comment">//      </span>
      <span class="hljs-comment">//       </span>
      swap(wheap[<span class="hljs-number">0</span>], wheap[i]);<font></font>
      x = <span class="hljs-number">1</span>;
      <span class="hljs-comment">//    "" </span>
      <span class="hljs-keyword">while</span>((y = <span class="hljs-number">2</span> * x + GETFLAG(r, x)) &lt; i) x = y;
      <span class="hljs-comment">//  ""     </span>
      <span class="hljs-comment">//        </span>
      <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) {<font></font>
        WeakHeapMerge(r, <span class="hljs-number">0</span>, x);<font></font>
        x &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">//  -   </span>
    <span class="hljs-comment">//    </span>
    swap(wheap[<span class="hljs-number">0</span>], wheap[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">delete</span>[] r;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu gosto especialmente de como a árvore binária é percorrida fácil e naturalmente usando operações bit a bit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade extra de memória</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - é necessária uma matriz adicional, na qual a ordem das subárvores esquerda / direita é fixada para nós com descendentes (cerca da metade da matriz). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, existe uma opinião de que a complexidade da classificação aqui é realmente O (1)! </font><font style="vertical-align: inherit;">Para um elemento, precisamos apenas de um bit adicional (zero / um) para indicar a ordem dos descendentes. </font><font style="vertical-align: inherit;">Se ordenarmos, por exemplo, cadeias de caracteres, é bastante possível anexar esse bit adicional ao próprio elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra maneira de transformar O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) em O (1) é armazenar sinalizadores em um número inteiro. </font><font style="vertical-align: inherit;">Expansão binária de números - um conjunto de zeros e os responsáveis ​​pela ordem das subárvores de todos os elementos da matriz. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento da matriz corresponde ao </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo do número.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade do tempo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o tempo, O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) é o mesmo que um heap regular. </font><font style="vertical-align: inherit;">Ao classificar linhas (especialmente as longas), um heap fraco pode ser mais rápido que um heap normal. </font><font style="vertical-align: inherit;">Mas isso é se classificarmos as longas filas. </font><font style="vertical-align: inherit;">Se ordenarmos os números, então, de acordo com os rumores, um monte comum é mais rápido de gerenciar.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peneiração total</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No estágio de formação do heap inicial fraco, por analogia com o heap usual, a idéia bastante óbvia sugere elevar elementos grandes o mais alto possível. </font><font style="vertical-align: inherit;">Ou seja, se trocássemos os valores do nó inferior e de seu ancestral, seria lógico repetir imediatamente as etapas do ancestral - encontrar o ancestral direito mais próximo para ele e comparar (e se também for necessário trocar valores + troca de subárvores). </font><font style="vertical-align: inherit;">E, se possível, eleve um elemento grande até a raiz. </font><font style="vertical-align: inherit;">É assim que parece no primeiro estágio (as ações no segundo estágio do algoritmo permanecem inalteradas):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/9x/9-/pa/9x9-panzenovigxgpzzal8phtri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pontuação de complexidade do tempo permanece a mesma.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilha binomial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo o que foi feito até agora é uma decepção, uma ilusão. Obviamente, formalmente realizamos algumas manipulações com a árvore binária, alteramos os nós com valores, reorganizamos as subárvores e tudo mais. No entanto, o algoritmo tem um fundo duplo, sobre o qual iremos agora analisar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender esse tipo, você precisa entender o que realmente é uma pilha fraca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se tomarmos uma matriz na qual o número de elementos é uma potência de dois, a pilha fraca e a pilha binomial construída com base em sua base são isomórficas.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="222" src="https://habrastorage.org/webt/nk/ge/qu/nkgequw_s9eaecxl7h9fiz9v2ua.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não olhe para o fato de que um heap fraco é binário e o binômio não. </font><font style="vertical-align: inherit;">Em uma pilha fraca, as subárvores esquerda e direita são essencialmente diferentes. </font><font style="vertical-align: inherit;">A subárvore direita é um descendente no sentido clássico, mas a subárvore esquerda é um "irmão". </font><font style="vertical-align: inherit;">Embora não seja. </font><font style="vertical-align: inherit;">A subárvore esquerda não é nem um "irmão", mas um vetor de "irmãos" com menos nós. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, a pilha fraca e a pilha binomial não são 100% iguais, embora sejam os parentes mais próximos. </font><font style="vertical-align: inherit;">A diferença é óbvia, se você pegar uma matriz cujo número de elementos não seja igual a 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A decomposição binomial de tal matriz fornecerá uma lista conectada de vários heaps ideais (o número de nós em cada um deles é uma certa potência de dois):</font></font><br>
<br>
<div style="text-align:center;"><img width="484" height="222" src="https://habrastorage.org/webt/k_/o8/zk/k_o8zk8rbi4n25ojy9ijrwh8jre.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma pilha fraca nesse caso será uma árvore binária imperfeita:</font></font><br>
<br>
<div style="text-align:center;"><img width="691" height="188" src="https://habrastorage.org/webt/eb/7a/-y/eb7a-yq54lycrpazacxsu6ci0em.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pilha binomial e a pilha fraca são irmãos gêmeos. </font><font style="vertical-align: inherit;">O DNA é o mesmo, embora na aparência você não possa dizer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo secreto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que uma pilha fraca é uma pilha criptobinomial, as subárvores aleatórias encontram subitamente uma explicação simples.</font></font><br>
<br>
<div style="text-align:center;"><img width="497" height="199" src="https://habrastorage.org/webt/xa/tb/p7/xatbp7kfjag7awytapkrebfwdxk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com uma pilha fraca, varra o ouropel pseudobinário e observe as relações reais entre os nós no estilo de pilha binomial. </font><font style="vertical-align: inherit;">Tudo fica claro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não há "fraqueza", é uma árvore de classificação (não binária) em que o princípio "qualquer pai é maior que qualquer de seus descendentes" é alcançado e mantido.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em todos os estágios, comparamos os descendentes não com seus ancestrais, mas com seus pais imediatos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que parece ser uma troca de valores entre um descendente e um ancestral + uma troca de lugares de subárvores em um descendente - acaba sendo a troca da própria proporção (descendente / pai / mãe). </font><font style="vertical-align: inherit;">Se o nó pai for menor que o descendente por valor, o próprio pai se tornará o descendente e o descendente se tornará o pai.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está uma visualização honesta:</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/s0/zb/m_/s0zbm_vg9ocfnzzgwhldn70v7he.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na próxima série</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A próxima pilha que eu gostaria de falar é a minha favorita - a árvore cartesiana. </font><font style="vertical-align: inherit;">Isso não é apenas um monte, mas também uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">árvore de pesquisa binária</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mas então, primeiro, no próximo artigo, algo interessante precisa ser esclarecido sobre as árvores BST. </font><font style="vertical-align: inherit;">E só então, através do artigo, e sobre conversas cartesianas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referências</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap fraco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">heap </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binomial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">heap </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binomial </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Implementação de heap fraco </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/pt/js/7k/ptjs7kchs12_zg8dfph-ld6yp_4.gif"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ronald D. Dutton: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Página pessoal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perfil do site da UCF </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heaps e amigos fracos: desenvolvimentos recentes </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura de dados do Weak-Heap: variantes e aplicativos </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre o desempenho do WEAK-HEAPSORT </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptive heapsort: Código fonte </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/mp/mv/ie/mpmviex2wi0oknklc_zrg5tgfhe.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Kopeliovich - Sala de aula - Pilha fraca (de 48:32 a 1:16:06)</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artigos da série:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicativo Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificações de Câmbio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificações de inserção</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificar por seleção</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de pilhas: N-pirâmides</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificações da pilha: números de Leonardo</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação de heap: heap fraco</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de Cacho: Árvore Cartesiana</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras classificações de pilha: pilha de espelhos, mini-pilha, peneiração de baixo para cima</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de Heap: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesclar classificações</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificar por distribuição</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação híbrida</font></font></a></li>
</ul><br>
<img align="right" width="349" height="264" src="https://habrastorage.org/webt/kf/cj/xj/kfcjxjqyku6wcl2spe8hqzgefz0.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classificação de hoje é adicionada ao aplicativo AlgoLab por um grupo fraco, que o usa - atualize o arquivo do Excel com macros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos comentários da célula com o nome da classificação, você pode especificar algumas configurações. </font><font style="vertical-align: inherit;">Se você definir siftup = 1, a classificação utilizará a triagem completa no primeiro estágio (por padrão siftup = 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você prescrever binomial = 1, a árvore será um “heap binomial” (por padrão, binomial = 0, ou seja, apenas um heap fraco).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt499770/index.html">Aprenda enquanto auto-isolamento</a></li>
<li><a href="../pt499772/index.html">Será muito, muito: como a tecnologia 5G mudará o mercado publicitário</a></li>
<li><a href="../pt499774/index.html">Não é um dia sem esportes - 2: reprogramando uma pulseira chinesa</a></li>
<li><a href="../pt499776/index.html">Características da implementação da linguagem MSH</a></li>
<li><a href="../pt499784/index.html">O que toca nas paredes virtuais?</a></li>
<li><a href="../pt499788/index.html">Curso online gratuito "Documentação técnica em projetos de TI"</a></li>
<li><a href="../pt499792/index.html">Teste de carga Atlassian Jira, Confluence, Bitbucket Part 1</a></li>
<li><a href="../pt499794/index.html">O PostgreSQL e o JDBC espremem todos os sucos. Vladimir Sitnikov</a></li>
<li><a href="../pt499796/index.html">Como os tribunais nos EUA são realizados através do zoom e por que isso é considerado um problema</a></li>
<li><a href="../pt499798/index.html">Duas tapas para o dinheiro: como desenvolvemos um bot de bate-papo financeiro com emissão instantânea de cartão no Azerbaijão</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>