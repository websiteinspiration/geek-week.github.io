<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛸️ 🥇 👨‍👩‍👧‍👦 Nous écrivons mieux la recherche de sous-chaînes que dans les manuels ⤴️ 🚗 🕌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La vie d'un ingénieur est pleine de surprises: surtout quand il faut faire face à la productivité. Par exemple, que se passe-t-il si vous essayez d'ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nous écrivons mieux la recherche de sous-chaînes que dans les manuels</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491750/"><img src="https://habrastorage.org/webt/ri/ei/to/rieitoeutxefbbjts6ag-carfqk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vie d'un ingénieur est pleine de surprises: surtout quand il faut faire face à la productivité. </font><font style="vertical-align: inherit;">Par exemple, que se passe-t-il si vous essayez d'exécuter ce morceau de code Java? </font><font style="vertical-align: inherit;">Cela semble assez innocent:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//   String.repeat  JDK 11  :</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> needle = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">500000</span>) + <span class="hljs-string">"B"</span>;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> haystack = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">1000000</span>) + <span class="hljs-string">"B"</span>;<font></font>
System.out.println(haystack.indexOf(needle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous attendons, attendons, attendons ... Au moins sur mon ordinateur portable OpenJDK 13 2015, trouver une aiguille dans une botte de foin prend environ une minute. </font><font style="vertical-align: inherit;">Notre bonne vieille machine virtuelle Java a traversé des décennies de réglage des performances, elle a effectivement mis en œuvre des intrinsèques pour </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. </font><font style="vertical-align: inherit;">Qu'est-ce qui aurait pu mal tourner?</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est le début d'une série de plusieurs articles gracieuseté de leur auteur, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linas Medžiūnas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et initialement publiés sur le blog </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WiX Engineering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
</blockquote><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinez de plus près ce qui est entré: les données sont spécialement sélectionnées de manière à obtenir des performances quadratiques dans le pire des cas ( </font></font><code>O(nm)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">où </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est la longueur </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est la longueur </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) pour l'algorithme de recherche de sous-chaîne naïve. Nous parcourons tous les caractères dans </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et s'ils coïncident avec les premiers caractères </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous commençons à courir le long </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la boucle intérieure - et ainsi de suite jusqu'au premier caractère incompatible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez faire valoir que cet exemple est inutile, car ces données d'entrée ont été conçues et archivées spécialement, dans la pratique, vous ne rencontrerez pas cela. Réfléchissez bien. Que faire si vous travaillez sur un service Web dont les utilisateurs peuvent charger des chaînes arbitraires, et quelque part à l'arrière du service, il y a du code qui s'exécute</font></font><code>indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur ces lignes? Ensuite, quelques requêtes malveillantes comme celle ci-dessus mettront votre service à genoux. Il vaut la peine de connaître, au moins, les pires cas pour les données d'entrée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, il existe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des algorithmes de recherche de sous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">chaînes</font></a><font style="vertical-align: inherit;"> ayant une complexité linéaire ( </font></font><code>O(n+m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Ils n'ont aucun problème avec les données de l'exemple ci-dessus. Par exemple, le code Scala suivant fait la même chose, mais s'exécute en millisecondes sur le même ordinateur, la même machine virtuelle Java et en utilisant exactement la même chose sous le capot </font></font><code>java.lang.String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">val needle = <span class="hljs-string">"A"</span> * <span class="hljs-number">500000</span> + <span class="hljs-string">"B"</span>
val haystack = <span class="hljs-string">"A"</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">"B"</span>
println(haystack.indexOfSlice(needle))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le secret de l'énorme différence réside dans la méthode </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fait partie de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la bibliothèque standard de Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il implémente l'algorithme linéaire intelligent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Et non, je ne dis pas que la langue X est meilleure que la langue Y. Malheureusement, tout est beaucoup plus compliqué ici! Par exemple, </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans Scala, il s'agit d'une méthode généralisée qui fonctionne non seulement avec des chaînes, mais également dans d'autres collections séquentielles, et peut comparer non seulement des caractères, mais également des éléments d'autres types. Cela devrait être beaucoup plus lent que</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de Java dans le cas du milieu (nous en parlerons plus tard). Ainsi, nous avons un algorithme efficace avec de bien meilleures performances dans le pire des cas, mais en moyenne, il est plus lent car il a une partie constante beaucoup plus grande. Des dilemmes comme celui-ci sont un problème typique de réglage des performances. Il n'y a pas de pilule magique qui résoudra tous les problèmes - vous devez analyser attentivement le problème et faire les bons micro-repères.</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es-tu encore avec moi Bien! Vous voyez, ce n'est qu'une introduction. Je voulais vous motiver à gérer la complexité théorique et les performances pratiques des algorithmes. Dans la suite de cet article, nous verrons quelques implémentations de plusieurs algorithmes de recherche de sous-chaînes et leurs benchmarks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons explorer trois algorithmes de recherche de sous-chaîne. Tous fonctionnent en temps linéaire et nécessitent un prétraitement, linéairement dépendant de la longueur </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le calcul de la même chose </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est requis qu'une seule fois, puis il peut être réutilisé dans plusieurs tentatives de recherche. C'est raisonnable, car dans de nombreux cas, nous devons rechercher la même ligne encore et encore. Et même si nous ne le faisons pas, le précalcul n'est pas une opération particulièrement coûteuse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les algorithmes ci-dessous contournent chacun des caractères de</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une seule fois de suite (pas d'accès aléatoire par index), donc ils fonctionnent tous bien en mode streaming. </font><font style="vertical-align: inherit;">Cet article est survenu au cours d'un travail réel sur un serveur proxy pour la production basé sur le cadre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et cela a influencé certaines des décisions de conception d'API. </font><font style="vertical-align: inherit;">De plus, comme nous avions besoin de faire une recherche sur les tampons d'octets, le code fonctionnera avec </font></font><code>Byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pas avec </font></font><code>Char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt (algorithme KMP)</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'un algorithme de recherche de sous-chaîne bien connu datant des années 70 du siècle dernier. </font><font style="vertical-align: inherit;">Il est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bien décrit dans la littérature</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc je ne le décrirai pas ici en détail. </font><font style="vertical-align: inherit;">L'ILC est basé sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des machines à états</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pendant la phase de calcul préliminaire, un tableau d'indices de liens est construit sur la base de </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pendant la recherche, la machine accepte les caractères </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un par un </font><font style="vertical-align: inherit;">à l'entrée </font><font style="vertical-align: inherit;">et met à jour son état interne en conséquence (et l'état il n'y a qu'un index dans la table des relations). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémentation sur Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithme de recherche de sous-chaîne binaire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au départ, j'ai dû inventer indépendamment le nom de cet algorithme: je n'ai jamais rien vu de tel nulle part dans la littérature. En conséquence, je suis venu au nom de "Shifting Bit Mask". Plus tard, il s'est avéré que cet algorithme et ses variations étaient connus depuis 1964 sous divers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noms anglais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme «Bitap», «Shift-or», «Shift-and», «Baeza-Yates - Gonnet». Merci aux lecteurs qui l'ont trouvé pour moi. Cet article a été écrit bien avant cette nouvelle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet algorithme est basé sur une idée très simple et fonctionne très bien, car il n'y a presque pas de sauts, et il est basé sur plusieurs opérations binaires primitives. De ce fait, il a une limite sur la longueur que </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous allons rechercher: il ne peut pas dépasser 64 octets. Ce nombre a été pris simplement par le nombre de bits</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la JVM. </font><font style="vertical-align: inherit;">Cette limitation est suffisamment généreuse pour un grand nombre de tâches réelles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme j'ai développé moi-même cet algorithme à l'origine, je vais essayer d'en parler plus en détail. </font><font style="vertical-align: inherit;">Tout d'abord, nous pré-calculons le contexte de recherche pour celui souhaité </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeBitMasks</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Array</span>[<span class="hljs-type">Long</span>] = {<font></font>
    require(needle.length &lt;= <span class="hljs-number">64</span>, <span class="hljs-string">"Maximum supported search pattern length is 64."</span>)
    <span class="hljs-keyword">val</span> bitMasks = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Long</span>](<span class="hljs-number">256</span>)
    <span class="hljs-keyword">var</span> bit = <span class="hljs-number">1</span>L
    <span class="hljs-keyword">for</span> (c &lt;- needle) {<font></font>
      bitMasks(toUnsignedInt(c)) |= bit<font></font>
      bit &lt;&lt;= <span class="hljs-number">1</span><font></font>
    }<font></font>
    bitMasks<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pré-calculons </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(64 bits </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) pour chaque valeur d'octet possible (256 pièces </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Pour une valeur d'octet </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il </font></font><code>bitmask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient contient des unités à tous les endroits où il se </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouve </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par exemple, voici un petit masque pour la chaîne "abracadabra": </font><font style="vertical-align: inherit;">
De plus, vous devez pré-calculer </font><font style="vertical-align: inherit;">, ce qui aidera à comprendre que nous avons trouvé une correspondance exacte. </font><font style="vertical-align: inherit;">Cela ressemble à une valeur </font><font style="vertical-align: inherit;">, avec un peu </font><font style="vertical-align: inherit;">en position </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<a rel="noopener noreferrer" href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/099/0d9/f95/0990d9f9590612cce258139fb7c287bd.png"></a><br>
<br><font style="vertical-align: inherit;"></font><code>successBitMask</code><font style="vertical-align: inherit;"></font><code>Long</code><font style="vertical-align: inherit;"></font><code>1</code><font style="vertical-align: inherit;"></font><code>needle.length — 1</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeSuccessBitMask</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Long</span> = {
    <span class="hljs-number">1</span>L &lt;&lt; (needle.length - <span class="hljs-number">1</span>)<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, vous devez faire, en fait, une recherche. Le seul état mutable que nous voulons stocker est </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Pour chaque octet, </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous décalons </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit </font><font style="vertical-align: inherit;">vers la </font><font style="vertical-align: inherit;">gauche </font><font style="vertical-align: inherit;">, définissons son bit le moins significatif </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et faisons un bit </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entre le résultat et </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, calculé pour la valeur d'octet traitée actuelle de </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(cela </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efface tous les bits aux endroits </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui ne correspondent pas à l'octet traité actuel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, après le traitement de chaque octet, seuls les bits qui se trouvent dans des positions appropriées survivront. Et avec chaque octet traité, tous les bits sont décalés vers la gauche d'une position. Si le bit "survit" pendant le nombre d'itérations égal à la longueur</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nous avons trouvé un match! Et nous pouvons le vérifier avec </font></font><code>successBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(value: <span class="hljs-type">Byte</span>): <span class="hljs-type">Boolean</span> = {<font></font>
    currentMask = ((currentMask &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>) &amp; bitMasks(toUnsignedInt(value))<font></font>
    (currentMask &amp; successBitMask) == <span class="hljs-number">0</span>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: la méthode décrite ci-dessus renvoie </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si quelque chose est trouvé, et cela semble contre-intuitif. </font><font style="vertical-align: inherit;">Cela peut être compris de sorte que la valeur </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie la nécessité de poursuivre la recherche, mais l' </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arrête - cela est dû au fait que, comme je l'ai écrit ci-dessus, l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API a été rendue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compatible avec Netty. </font><font style="vertical-align: inherit;">Si vous vous demandez comment exécuter une recherche, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un exemple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, toute la logique se résume à quelques instructions simples du processeur. </font><font style="vertical-align: inherit;">Malheureusement, il reste une vérification complètement inutile des limites des index du tableau </font></font><code>bitMasks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qu'aucun JDK ne peut supprimer (et j'ai regardé l'assembleur généré par plusieurs JDK différents). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémentation complète sur Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aho korasik</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'un autre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algorithme populaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connu depuis 1975. Sa caractéristique distinctive (et parfois très utile) est la possibilité d'en rechercher plusieurs </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en même temps, tandis que tous les caractères de </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont contournés une seule fois (je pense que c'est tout simplement génial!). L'idée que tout cela fonctionne est une extension de l'algorithme KMP, une machine à états finis utilisant un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arbre de préfixe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (qui est construit sur la base de plusieurs </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), contenant des liens vers des liens (comparer avec un tableau unidimensionnel du KMP). Sur la base de ces liens, l'état interne de l'automate est commuté entre les nœuds de l'arbre de préfixe après chaque symbole traité, et certains des nœuds indiquent un résultat de recherche positif pour un particulier</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La phase de précalcul ici est assez compliquée, mais la phase de recherche est d'une simplicité inattendue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un lien vers une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémentation de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> travail </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">sur Scala</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agissait d'une liste complètement incomplète d'algorithmes de recherche de sous-chaîne. </font><font style="vertical-align: inherit;">Nous avons également essayé l' </font><font style="vertical-align: inherit;">algorithme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabin-Karp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l'algorithme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boyer-Moore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De ces deux, Boyer-Moore a montré des performances comparables, mais ils ne sont pas tous deux compatibles avec le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">streaming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (en utilisant un accès aléatoire </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par index), et je les ai donc supprimés de cette enquête.</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repères</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous comparerons les trois algorithmes décrits ci-dessus et, en outre, examinerons les résultats des méthodes </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Java) et </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Scala). Pour être honnête, ce n'est pas une comparaison complètement correcte, car cela </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionne avec des chaînes, et toutes les autres méthodes sont sur des tableaux d'octets. Mais cela ne semble pas invalider les résultats d'une telle comparaison. De plus, j'ai également inclus les résultats </font></font><code>Bytes.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de Guava (v.28.1). Cette méthode fonctionne sur des tableaux d'octets. Et ils l'ont écrit sur Google - tout ce qu'ils y écrivent fonctionne très vite, non? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'écriture de repères est toujours difficile, car vous pouvez envoyer des données complètement différentes à l'entrée, les modifier de différentes manières - non seulement en longueur </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais aussi par le contenu interne de ces lignes (qui peut grandement affecter certains algorithmes). En pratique, il vaut toujours la peine de vérifier les données d'entrée qui sont les plus similaires aux données de vos tâches réelles (c'est ce que nous avons fait dans notre projet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour raccourcir cet article, j'ai utilisé seulement 2 types d'entrées. L'un d'eux est destiné à refléter le cas réel: </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">environ 1,5 Ko de taille (avec du texte lisible par l'homme à l'intérieur) </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 9 octets, et pas dans </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette séquence (cela est nécessaire pour forcer l'algorithme à effectuer une analyse complète). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre type d'entrée est nécessaire pour obtenir le comportement le plus défavorable d'un algorithme quadratique. C'est beaucoup plus court que les données du tout début de cet article: sinon il faudrait attendre une minute entière, tu te souviens? Array</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est défini dans le format </font></font><code>"AA...AAB"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la même longueur que le premier type de données), et </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 64 octets (en particulier pour l'algorithme de recherche de sous-chaîne binaire pour y faire face) un tableau du même type (la correspondance n'est qu'à la toute fin </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un benchmark écrit dans le cadre JMH </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être trouvé ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous avez d'autres idées sur quoi et comment mesurer ici - vous pouvez cloner ce référentiel, modifier quelque chose et publier des commentaires.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À la suggestion de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Sitnikov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , j'ai ajouté des résultats de référence pour </font></font><code>java.util.regex.Pattern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; il utilise l'algorithme de Boyer-Moore sous le capot.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Note du traducteur: à propos, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Sitnikov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est membre de plusieurs comités de programme du groupe JUG Ru et fait lui-même des rapports intéressants. Par exemple, une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vidéo de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son rapport de JPoint 2019 intitulée «Java ralentit: édition CodeCache» </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">est disponible sur le lien</font></a><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultats de référence</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats sont donnés en millisecondes, moins c'est mieux: </font><font style="vertical-align: inherit;">
Ici tout est comme prévu:</font></font><br>
<br>
<code># JMH version: 1.21<br>
# VM version: JDK 13.0.1, OpenJDK 64-Bit Server VM, 13.0.1+9<br>
Benchmark (searchInput) Mode Cnt Score Error Units<br>
javaIndexOf REGULAR avgt 5 0.622 ± 0.002 us/op<br>
shiftingBitMask REGULAR avgt 5 1.982 ± 0.017 us/op<br>
regexPattern REGULAR avgt 5 2.184 ± 0.006 us/op<br>
kmp REGULAR avgt 5 2.635 ± 0.016 us/op<br>
scalaIndexOfSlice REGULAR avgt 5 3.202 ± 0.009 us/op<br>
guavaIndexOf REGULAR avgt 5 3.696 ± 0.095 us/op<br>
ahoCorasic REGULAR avgt 5 7.063 ± 0.040 us/op<br>
shiftingBitMask WORST_CASE avgt 5 1.986 ± 0.010 us/op<br>
kmp WORST_CASE avgt 5 5.120 ± 0.006 us/op<br>
ahoCorasic WORST_CASE avgt 5 6.892 ± 0.025 us/op<br>
scalaIndexOfSlice WORST_CASE avgt 5 8.765 ± 0.007 us/op<br>
regexPattern WORST_CASE avgt 5 11.566 ± 0.086 us/op<br>
javaIndexOf WORST_CASE avgt 5 23.029 ± 0.124 us/op<br>
guavaIndexOf WORST_CASE avgt 5 52.927 ± 0.275 us/op<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les données ordinaires, il domine </font></font><code>javaIndexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il utilise des intrinsèques hautes performances à l'intérieur, à cause desquels la partie constante est petite;</font></font></li>
<li>     ,  :     ,     (<code>O(nm)</code>)   <code>javaIndexOf</code>,           —      ,  <code>shiftingBitMask</code> (  )   .</li>
<li><code>guavaIndexOf</code>      ,    <code>javaIndexOf</code>;  ,        2  ,    <code>shiftingBitMask</code>;</li>
<li><code>scalaIndexOfSlice</code>  -  ,  <code>knuthMorrisPratt</code>,   ,      —   ,  ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la performance n'est pas la caractéristique la plus forte </font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou au moins de sa mise en œuvre; je dois admettre que je n'ai pas vraiment essayé d'y faire des microoptimisations, car je ne l'ai ajoutée qu'en raison de sa caractéristique distinctive: la possibilité de rechercher sur plusieurs lignes à la fois, et similaire au sujet d'un article séparé);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les données d'entrée (et la longueur </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) n'ont pas affecté les performances </font></font><code>shiftingBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans différents cas, les repères peuvent fonctionner de différentes manières. </font><font style="vertical-align: inherit;">Malgré le fait que les résultats ci-dessus semblent très indicatifs, vous devez toujours prendre des mesures vous-même et sur des données qui reflètent vos tâches réelles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base des données présentées, j'ai tiré les conclusions suivantes:</font></font><br>
<br>
<ul>
<li>    <code>String</code>-   ,           ,   <code>String.indexOf</code> ( <code>java.util.regex.Pattern</code> —      );</li>
<li>,   <code>needle</code>   64 ,    ;</li>
<li> ,   --;</li>
<li>   Scala        - (     ),   <code>indexOfSlice</code>    —    ;</li>
<li>    ,  -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout! </font><font style="vertical-align: inherit;">Si vous aimez lire sur les algorithmes, les performances, etc. (ainsi que sur Scala, JVM et Java en général), abonnez-vous à l'auteur de cet article, Linas Medziunas ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le référentiel github avec tout le code de cet article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br>
<img src="https://habrastorage.org/webt/_f/ku/xn/_fkuxncdimo0rsaeealkeqpe8f0.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les traductions d'articles sont publiées avec le soutien du groupe JUG Ru et de la conférence </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPoint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491740/index.html">L'Internet des objets dans Yandex.Cloud: comment les services Yandex IoT Core et Yandex Cloud Functions sont organisés</a></li>
<li><a href="../fr491742/index.html">Sherbet: clavier de jeu ergonomique</a></li>
<li><a href="../fr491744/index.html">Des pirates iraniens ont exploité des vulnérabilités dans un VPN</a></li>
<li><a href="../fr491746/index.html">L'histoire de la synthèse vocale: l'ère des solutions électriques</a></li>
<li><a href="../fr491748/index.html">Technologies qui aident les aveugles à apprendre l'anglais</a></li>
<li><a href="../fr491780/index.html">GitLab 12.8 publié avec navigateur de journaux, NuGet et tableau de bord de conformité</a></li>
<li><a href="../fr491792/index.html">Le HiFiMan sans fil comme étape dans l'évolution du casque isodynamique</a></li>
<li><a href="../fr491800/index.html">Pourquoi tout le monde devrait y penser: réponses aux questions les plus pressantes sur le coronavirus Covid-19</a></li>
<li><a href="../fr491806/index.html">Vitamine B12: comment connaître votre niveau et d'où vient le vieillissement cérébral</a></li>
<li><a href="../fr491810/index.html">VoiceOver sur iOS: résolution des problèmes courants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>