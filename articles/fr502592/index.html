<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍💻 🌦️ 💪🏼 Néomorphisme utilisant SwiftUI. Partie 1 ⛹️ 🥥 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Khabrovites! En prévision du lancement du cours avancé «Développeur IOS», nous avons préparé une autre traduction intéressante.
 
 
 
 Le desig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Néomorphisme utilisant SwiftUI. Partie 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502592/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salut, Khabrovites! </font><font style="vertical-align: inherit;">En prévision du lancement du cours avancé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Développeur IOS»,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons préparé une autre traduction intéressante.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/nr/7d/ml/nr7dmlj7ru0rbnazf8ce8wox3ra.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le design non morphique est peut-être la tendance la plus intéressante de ces derniers mois, bien qu'en réalité Apple l'ait utilisé comme motif de design lors de la WWDC18. </font><font style="vertical-align: inherit;">Dans cet article, nous verrons comment vous pouvez implémenter une conception non morphique à l'aide de SwiftUI, pourquoi vous voudrez peut-être le faire et - plus important encore - comment nous pouvons affiner cette conception pour augmenter son accessibilité.</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : le néomorphisme - également parfois appelé neuromorphisme - a de graves conséquences sur l'accessibilité, donc malgré la tentation de lire la première partie de cet article et de sauter le reste, je vous invite à lire l'article jusqu'au bout et à étudier les avantages et les inconvénients afin que vous puissiez voir l'image complète .</font></font><br>
</blockquote><a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z3tJdxwlo_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bases du néomorphisme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de passer au code, je voudrais brièvement décrire deux principes de base de cette direction dans la conception, car ils seront pertinents au fur et à mesure:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le néomorphisme utilise l'éblouissement et l'ombre pour déterminer les formes des objets à l'écran.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le contraste a tendance à diminuer; </font><font style="vertical-align: inherit;">complètement blanc ou noir ne sont pas utilisés, ce qui vous permet de mettre en évidence les hautes lumières et les ombres.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat final est un look qui rappelle le «plastique extrudé» - une conception d'interface utilisateur qui a certainement l'air fraîche et intéressante sans vous heurter les yeux. </font><font style="vertical-align: inherit;">Je ne peux que répéter encore une fois que la réduction du contraste et l'utilisation des ombres pour mettre en évidence les formes affectent sérieusement l'accessibilité, et nous y reviendrons plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, je pense toujours que le temps passé à apprendre sur le néomorphisme dans SwiftUI en vaut la peine - même si vous ne l'utilisez pas dans vos propres applications, c'est comme un kata d'écriture de code pour vous aider à perfectionner vos compétences. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'accord, assez de bavardages - passons au code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construire une carte non morphique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le point de départ le plus simple est de créer une carte non morphique: un rectangle arrondi qui contiendra des informations. Ensuite, nous verrons comment nous pouvons transférer ces principes à d'autres parties de SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par créer un nouveau projet iOS à l'aide du modèle d'application Single View. Assurez-vous que vous utilisez SwiftUI pour l'interface utilisateur, puis nommez le projet Neumorphism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Astuce: si vous avez accès à l'aperçu de SwiftUI dans Xcode, je vous recommande de l'activer immédiatement - il vous sera beaucoup plus facile d'expérimenter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons commencer par définir une couleur qui représente une teinte crémeuse. </font><font style="vertical-align: inherit;">Ce n'est pas du gris pur, mais plutôt une nuance très subtile qui ajoute un peu de chaleur ou de fraîcheur à l'interface. </font><font style="vertical-align: inherit;">Vous pouvez l'ajouter au répertoire des ressources si vous le souhaitez, mais maintenant c'est plus facile à faire en code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez ceci en </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dehors de la structure </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Color</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> offWhite = <span class="hljs-type">Color</span>(red: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, green: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, blue: <span class="hljs-number">235</span> / <span class="hljs-number">255</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, il est presque blanc, mais il est assez sombre pour donner au vrai blanc une lueur quand nous en avons besoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous pouvons remplir le corps </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en le fournissant </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui occupe tout l'écran, en utilisant notre nouvelle couleur quasi-blanche pour remplir tout l'espace:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">Color</span>.offWhite<font></font>
        }<font></font>
        .edgesIgnoringSafeArea(.all)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour représenter notre carte, nous utiliserons un rectangle arrondi dans la résolution de 300x300 pour la rendre belle et claire à l'écran. </font><font style="vertical-align: inherit;">Ajoutez donc ceci à </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sous la couleur:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par défaut, il sera noir, mais pour la mise en œuvre du néomorphisme, nous voulons réduire fortement le contraste, nous allons donc le remplacer par la même couleur que nous utilisons pour l'arrière-plan, ce qui rend en fait la forme invisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors changez-le comme ceci:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un point important:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous déterminons la forme en utilisant des ombres, une sombre et une claire, comme si la lumière projetait des rayons depuis le coin supérieur gauche de l'écran.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI nous permet d'appliquer plusieurs fois des modificateurs, ce qui facilite l'implémentation du néomorphisme. </font><font style="vertical-align: inherit;">Ajoutez les deux modificateurs suivants à votre rectangle arrondi:</font></font><br>
<br>
<pre><code class="swift hljs">.shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
.shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ils représentent le décalage de l'ombre sombre dans le coin inférieur droit et le décalage de l'ombre claire dans le coin supérieur gauche. </font><font style="vertical-align: inherit;">L'ombre claire est visible car nous avons utilisé un fond quasi blanc, et maintenant la carte devient visible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avons écrit que quelques lignes de code, mais nous avons déjà une carte non morphique - j'espère que vous conviendrez que SwiftUI facilite étonnamment le processus!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/_z/0h/he_z0hdu4zlhtftzxwsvxo5k9t8.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Création d'un simple bouton non morphique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De tous les éléments d'une interface utilisateur, le néomorphisme présente un risque assez faible pour les cartes - si l'interface utilisateur à l'intérieur de vos cartes est claire, la carte peut ne pas avoir de bordure claire, et cela n'affectera pas l'accessibilité. Les boutons sont une autre affaire, car ils sont conçus pour interagir, donc réduire leur contraste peut faire plus de mal que de bien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traitons cela en créant notre propre style de bouton, car c'est ainsi que SwiftUI permet aux configurations de bouton d'être distribuées à de nombreux endroits. C'est beaucoup plus pratique que d'ajouter de nombreux modificateurs à chaque bouton que vous créez - nous pouvons simplement définir le style une fois et l'utiliser à de nombreux endroits.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons définir un style de bouton qui sera en fait vide: SwiftUI nous donnera le libellé du bouton, qui peut être du texte, une image ou autre chose, et nous le renverrons sans modifications. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez cette structure quelque part à l'extérieur </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleButtonStyle</span>: <span class="hljs-title">ButtonStyle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        configuration.label<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est </font></font><code>configuration.label</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui-ci qui contient le contenu du bouton, et bientôt nous ajouterons autre chose. </font><font style="vertical-align: inherit;">Définissons d'abord un bouton qui l'utilise pour que vous puissiez voir comment le design évolue:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Button</span>(action: {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Button tapped"</span>)<font></font>
}) {<font></font>
    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart.fill"</span>)<font></font>
        .foregroundColor(.gray)<font></font>
}<font></font>
.buttonStyle(<span class="hljs-type">SimpleButtonStyle</span>())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous ne verrez rien de spécial à l'écran, mais nous pouvons y remédier en ajoutant notre effet non morphique au style du bouton. Cette fois, nous n'utiliserons pas de rectangle arrondi, car pour les icônes simples, le cercle est meilleur, mais nous devons ajouter une indentation pour que la zone de clic du bouton soit grande et belle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez votre méthode </font></font><code>makeBody()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en ajoutant une indentation, puis en plaçant notre effet non morphique comme arrière-plan du bouton:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
    )</code></pre><br>
<img src="https://habrastorage.org/webt/nm/-x/yp/nm-xyp4klovncqtomhthav-za7y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela nous rapproche suffisamment de l'effet souhaité, mais si vous exécutez l'application, vous verrez qu'en pratique, le comportement n'est toujours pas parfait - le bouton ne réagit pas visuellement lorsqu'il est enfoncé, ce qui semble juste bizarre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ce problème, nous devons lire la propriété </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans notre style de bouton personnalisé, qui indique si le bouton est actuellement enfoncé ou non. Nous pouvons l'utiliser pour améliorer notre style et donner une indication visuelle de la pression du bouton. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par un simple: nous utiliserons des </font></font><code>Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boutons pour l'arrière-plan, puis vérifierons </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et retournerons soit un cercle plat si le bouton est enfoncé, soit notre cercle sombre actuel sinon:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Group</span> {
            <span class="hljs-keyword">if</span> configuration.isPressed {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
            }<font></font>
        }<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'un </font></font><code>isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cercle avec une couleur quasi-blanche est utilisé </font><font style="vertical-align: inherit;">dans l'état </font><font style="vertical-align: inherit;">, il rend notre effet invisible lorsque le bouton est enfoncé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avertissement: en raison de la façon dont SwiftUI calcule les zones enregistrables, nous avons involontairement rendu la zone de clic pour notre bouton très petite - vous devez maintenant appuyer sur l'image elle-même, et non sur la conception non morphologique qui l'entoure. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, ajoutez un modificateur </font></font><code>.contentShape(Circle())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immédiatement après </font></font><code>.padding(30)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, forçant SwiftUI à utiliser tout l'espace disponible du robinet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous pouvons créer l'effet de la concavité artificielle en inversant l'ombre - en copiant deux modificateurs </font></font><code>shadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de l'effet de base, en échangeant les valeurs X et Y pour le blanc et le noir, comme indiqué ici:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">if</span> configuration.isPressed {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estimez le résultat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/nz/gv/bknzgvars2r0e4anrdqngo12wr4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créer des ombres internes pour un clic de bouton</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre code actuel, en principe, fonctionne déjà, mais les gens interprètent l'effet différemment - certains le voient comme un bouton concave, d'autres voient que le bouton n'est toujours pas enfoncé, juste la lumière vient d'un angle différent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'idée de l'amélioration est de créer une ombre intérieure qui simulera l'effet d'appuyer sur le bouton vers l'intérieur. Cela ne fait pas partie du kit SwiftUI standard, mais nous pouvons l'implémenter assez facilement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La création d'une ombre intérieure nécessite deux dégradés linéaires, et ils ne seront que le premier des nombreux dégradés internes que nous utiliserons dans cet article, nous allons donc ajouter immédiatement une petite extension d'assistance pour </font></font><code>LinearGradient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplifier la création de dégradés standard:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LinearGradient</span> </span>{
    <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> colors: <span class="hljs-type">Color</span>...) {
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(gradient: <span class="hljs-type">Gradient</span>(colors: colors), startPoint: .topLeading, endPoint: .bottomTrailing)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cela, nous pouvons simplement fournir une liste variable de couleurs pour récupérer leur dégradé linéaire dans la direction diagonale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, sur le point important: au lieu d'ajouter deux ombres inversées à notre cercle pressé, nous allons superposer un nouveau cercle avec un flou (trait), puis appliquer un autre cercle avec un dégradé comme masque. </font><font style="vertical-align: inherit;">C'est un peu plus compliqué, mais permettez-moi de l'expliquer au coup par coup:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre cercle de base est notre cercle actuel avec un effet néomorphique, rempli d'une couleur quasi blanche.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous plaçons un cercle dessus, encadré par un cadre gris, et floutons légèrement pour adoucir ses bords.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous appliquons un masque avec un autre cercle à ce cercle superposé en haut, cette fois rempli d'un dégradé linéaire.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous appliquez une vue en tant que masque pour une autre, SwiftUI utilise le canal alpha du masque pour déterminer ce qui doit être affiché dans la vue de base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, si nous dessinons un trait gris flou, puis le masquons avec un dégradé linéaire du noir au transparent, le trait flou sera invisible d'un côté et augmentera progressivement de l'autre - nous obtiendrons un dégradé interne lisse. Pour rendre l'effet plus prononcé, nous pouvons légèrement déplacer les cercles ombrés dans les deux sens. Après avoir expérimenté un peu, j'ai trouvé que dessiner une ombre claire avec une ligne plus épaisse qu'une sombre aide à maximiser l'effet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas que deux ombres sont utilisées pour créer un sentiment de profondeur dans le néomorphisme: une claire et une sombre, nous ajouterons donc cet effet de l'ombre intérieure deux fois avec des couleurs différentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez le cercle </font></font><code>configuration.isPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme suit:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Circle</span>()<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.gray, lineWidth: <span class="hljs-number">4</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.black, <span class="hljs-type">Color</span>.clear)))<font></font>
    )<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.white, lineWidth: <span class="hljs-number">8</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: -<span class="hljs-number">2</span>, y: -<span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.clear, <span class="hljs-type">Color</span>.black)))<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous exécutez à nouveau l'application, vous verrez que l'effet d'appuyer sur un bouton est beaucoup plus prononcé et semble meilleur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1r/f1/ha/1rf1hanjn-9zhj0xhglha6e4lr0.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur ce point, la première partie de la traduction a pris fin. </font><font style="vertical-align: inherit;">Dans les prochains jours nous publierons la suite, et maintenant nous vous invitons à en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">savoir plus sur le cours à venir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502576/index.html">Apple Watch pour pas cher: comment ils voulaient me "reproduire" sur Avito et Yulia</a></li>
<li><a href="../fr502578/index.html">Sur la révolution des radars, les délais et l'entrée dans la quatrième dimension</a></li>
<li><a href="../fr502580/index.html">Vous vous engagez en open source en tant que développeur? Nous nous occupons des droits (salut, nginx)</a></li>
<li><a href="../fr502584/index.html">Le fabricant Mi Band publiera un masque transparent auto-désinfectant pour se protéger contre le COVID-19</a></li>
<li><a href="../fr502588/index.html">L'histoire incroyable de PowerPoint</a></li>
<li><a href="../fr502594/index.html">7 raisons pour lesquelles les projets Web ne sont pas interrompus et comment y faire face</a></li>
<li><a href="../fr502596/index.html">Cours éducatifs de quarantaine gratuits: conception</a></li>
<li><a href="../fr502598/index.html">Semaine de sécurité 21: vulnérabilité du service d'impression Windows</a></li>
<li><a href="../fr502604/index.html">Une introduction à TLS pour Patrik Patrick (Partie 1)</a></li>
<li><a href="../fr502608/index.html">Comment nous avons lancé le marché des applications dans le service SaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>