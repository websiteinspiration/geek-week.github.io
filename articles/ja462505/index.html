<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏿 💃🏼 👨🏼‍🔧 関数型プログラミングに騙されないでください 🧐 🕓 🔂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="関数型プログラミングの支持者は、完璧なコード表現力、100％の正確さ、サポートのしやすさ、リファクタリングのしやすさを約束し、さらには最高のパフォーマンスを予測することもできます。ただし、経験豊富な開発者は、これが起こらないことを知っています。プログラミングは大変な作業であり、「魔法の薬」は存在しま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>関数型プログラミングに騙されないでください</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462505/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングの支持者は、完璧なコード表現力、100％の正確さ、サポートのしやすさ、リファクタリングのしやすさを約束し、さらには最高のパフォーマンスを予測することもできます。ただし、経験豊富な開発者は、これが起こらないことを知っています。プログラミングは大変な作業であり、「魔法の薬」は存在しません。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、関数型プログラミングスタイルの要素は、SwiftやKotlinなどの産業用プログラミング言語にすでに浸透しています。これらの言語の開発者は関数型プログラミングに精通しているため、「小規模」でそれを使用して、必要なコンポーネントのすべてではなく多くを提供することができました。さらに遠く-FIのより多くの部分が産業用核兵器に導入され、より良いそしてより完全にサポートが実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業を簡略化するために関数スタイルでプログラミングできると便利です。次に、その使用方法を見ていきます。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mmvHC3UgYmg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitaly Bragilevsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、FPの教師であり、アルゴリズムと計算の理論であり、「Haskell in Depth」の著者であり、Haskell 2020委員会とGHCコンパイラーの監督委員会のメンバーです。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ショートストーリー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングの話は常に正しいとは限りません。多くの場合、このようなAFについて話します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「むかしむかし、遠い銀河系にいたとき、プログラミングは単純で簡単で、優れていました。アルゴリズムとデータ構造はプログラムされており、すべて問題ありません-問題ありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">、すべてのプログラムがクラスで構成されると決定し</font><font style="vertical-align: inherit;">た</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シスの</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怖い人々</font><font style="vertical-align: inherit;">がやって来ました</font><font style="vertical-align: inherit;">： ''すべての人のためのオブジェクト指向プログラミング！すべてがそのような方法でのみ書かれる必要があります '' </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らが強くなると、ソフトウェアを開発することが不可能になりました-多くの問題が現れました。不幸に苦しんでいる開発者を救うために、関数型プログラミングがあります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
救いの主なことは、美しく意味のない絵を描くことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ej/qg/ok/ejqgokehdxnmlm0dhhgck6kbyu4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写真のすべてを適用すると、幸福、平和、静けさがもたらされ、ソフトウェア開発の問題が解決されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストーリーは美しいですが、実際にはすべてが異なります。</font><font style="vertical-align: inherit;">これが私が関数型プログラミングと産業用プログラミングを表す方法です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/og/_n/vvog_n7u5dowxuefad5rrkegnj0.jpeg"><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングは、ファラデーの研究室です。産業プログラミングに適用されるアイデアの発祥の地です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工業用プログラミング言語についての会話では、それらが機能的であるかどうか、FPを使用するかどうかに関係なく、その概念を取り上げるべきではありません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPの主な使命は、主流の言語に優れた要素を伝えることです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全員を機能的なレールに転送したいということは、科学者にファラデーのような実験を強いることと同じです-それは意味がありません。</font><font style="vertical-align: inherit;">現在、このような時代遅れの方法で電気の実験を行っている人はいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を見てみましょう。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジョン・マッカーシー・ファンクション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジョン・マッカーシーはLispの作成者の一人です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pc/6z/fx/pc6zfxhxktuiarb-_n5ppc_f26g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortranは65年前の主要なプログラミング言語でした。</font><font style="vertical-align: inherit;">条件文があります：</font></font><br>
<br>
<pre><code class="plaintext">        IF (I.NE.0) GOTO 40<font></font>
        STMT-1<font></font>
        STMT-2<font></font>
40      STMT-3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数Iの値が0でない場合は、ラベル「40」に移動します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当時、ジョンはチェスをプログラムするプログラムを作成しており、似たようなスタイルで書くのは苦手でした。</font><font style="vertical-align: inherit;">ジョン</font></font><code>XIF(M, N1,N2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、条件を取り、N1またはN2の2つの値のいずれかを返す</font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を作成</font><font style="vertical-align: inherit;">することで、特定の問題を解決すると便利だと考えました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPの最初のアイデアの1つ：「if ... then」というアクションのシーケンスを持つオペレーターから、関数に移動して、すぐに目的の値を取得します。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような関数の大きな欠点は、N1とN2の同時計算です。</font><font style="vertical-align: inherit;">値が1つだけ必要な場合、なぜ追加の計算を行うのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マッカーシーはこの問題について考え、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件付きの三項演算になりました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext">M==0 ? N1 : N2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のファッショナブルなYPでは、時代遅れと見なされます。</font><font style="vertical-align: inherit;">しかし、関数型プログラミングのこの要素は、主流の言語にあります。</font><font style="vertical-align: inherit;">私たちはどこでもそれを使用しており、条件付きの操作を取得するために、他の方法でモデルを作成することを強いられる場合があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォンノイマンのスタイルからプログラミングは無料ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
John BackusはFortranの作成者であり、非常に有名な人物です。</font><font style="vertical-align: inherit;">1977年に彼はコンピュータサイエンスのチューリング賞を受賞しました。</font><font style="vertical-align: inherit;">賞の発表で、「フォンノイマンのスタイルからプログラミングを解放することは可能ですか？」とスピーチを行いました。</font><font style="vertical-align: inherit;">その中で、Fortranの作成者-注-は、以前の方法ではなくプログラミングを要求しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vh/a_/l5/vha_l5z-pwfdapahyuwsq2f7u_c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
音声の主な例の1つは、2つのベクトルのスカラー積を計算するコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の解決策</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、古典的なフォンノイマンプログラムによる</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイクルで見つけることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp">c := 0 <font></font>
for i := 1 step 1 until n do<font></font>
    c := c + a[i]*b[i]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加算器とバッテリーがあります-値を循環してすべてを組み合わせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ問題の解決策は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラムで</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見つけることができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例として、ジョンはコードを発明された言語FPで示しました。</font></font><br>
<br>
<pre><code class="cpp">Def DotP = (Insert +) o (ApplyToAll x) o Transpose</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Johnは、関数の組み合わせを使用することを提案し、</font></font><code>o</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相互に宣言的に相互作用する関数を記述することを</font><font style="vertical-align: inherit;">提案しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの例-クラシックと機能-は同じアクションを実行しますが、バッカスは2番目のスタイルで書く方がより正しいと考えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、誰もがそのように書いています。</font><font style="vertical-align: inherit;">プログラムはおそらく同じスタイルで書かれています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書かない方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて私がJavaを教えていて、学生が同じことをJavaで書いたことを多くの人が思い出させます。</font><font style="vertical-align: inherit;">はい、しかしそれはずっと前のことでした、私たちは若く、正しく書く方法を知りませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/mx/j8/pjmxj8r8gewqos3xzxezmgj909c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、このコードを評価すると、多くの欠点がわかります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互いにネストされたサイクルが使用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードは完全に読み取り不可能です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誤ってチェックされた行の終わり。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウンターが使用されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはまさに誰もが実際に書いていない方法です、それは良いことです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のコード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードは次のようになります。</font></font><br>
<br>
<pre><code class="kotlin">fun countLinesInFiles(fnames: List&lt;String&gt;): Int<font></font>
    = fnames.map { File(it).readLines().size }<font></font>
        .sum()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のコードであり</font><font style="vertical-align: inherit;">、最も関数型の言語ではありませんが、作成することはできません。</font><font style="vertical-align: inherit;">どのように機能しますか？</font><strong><font style="vertical-align: inherit;">ファイル名</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストが</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力され</font><font style="vertical-align: inherit;">、それらのそれぞれの行数が考慮され、すべてが合計され、行の総数が求められます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能要素</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -「マップ」関数-は、指定されたファイル名のリストのすべての要素を処理します。</font><font style="vertical-align: inherit;">次は、</font><font style="vertical-align: inherit;">各ファイルで実行</font><font style="vertical-align: inherit;">する</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlinアクション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。行数をカウントします。ファイルが読み取られ、行に分割されます。</font><font style="vertical-align: inherit;">変数は、そのようなサイクルの各ステップでの特定のファイルの名前です。</font><font style="vertical-align: inherit;">最後に、要素の合計が考慮されます-sum（）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが何を知っているなら</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、Kotlinの中括弧は、コードが実行中であることを理解しています。</font><font style="vertical-align: inherit;">この特定のオペレーティングシステムでは、文字列がどの文字で終わるかは推測しません。</font><font style="vertical-align: inherit;">それは問題ではありません- </font></font><code>readLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは私たちのためにすべてを行います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskellとほぼ同じ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、よく見ると、Haskellが表示されます。</font></font><br>
<br>
<pre><code class="haskell">countLines :: FilePath -&gt; IO Int<font></font>
countLines = fmap (length . lines) . readFile <font></font>
<font></font>
countLinesInFiles :: [FilePath] -&gt; IO Int<font></font>
countLinesInFiles = fmap sum . traverse countLines</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん違いがあります。 Haskellでは、関数型プログラミングなので、1つではなく2つの関数を記述します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の関数は、1つのファイルの行数をカウントします</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。何が起こるかすぐにわかります。入力ではファイル名、Intの出力では整数です。&nbsp; </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">副作用の抑制</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Haskellでは関数が</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">副作用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用していて</font><font style="vertical-align: inherit;">、I / Oが実行されていること</font><font style="vertical-align: inherit;">を通知する必要があるため、「IO」を使用しています</font><font style="vertical-align: inherit;">。これは「汚れた関数」なので、IntだけでなくIO Intでもあります。これは、その数が副作用の結果であることを示しています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の関数は、すでにいくつかのファイルにある行数をカウントします</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">角括弧はHaskellのリストです。</font><font style="vertical-align: inherit;">ファイル名のリスト-FilePathを取得し、同じIO Int-合計を取得します。</font><font style="vertical-align: inherit;">次の行：合計、トラバース-リストのトラバース、およびリストの各要素に対してアクション「countLines」が実行されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の構成。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーションが使用されるすべての場所。」</font><font style="vertical-align: inherit;">「（Backusの場合</font></font><code>o</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は関数の</font><font style="vertical-align: inherit;">組み合わせ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">関数は左から右に記述しますが、右から左に実行されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「F. </font><font style="vertical-align: inherit;">g "関数であり、引数" x "を使用して、値" f（g（x）） "を返します。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数はどこにもありません;それらはそれら自身で置き換えられます。</font><font style="vertical-align: inherit;">この注釈は、FPにとって非常に便利なので使用します。</font><font style="vertical-align: inherit;">主流の言語はこれに遅れています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPとFPの違い</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは現代の非関数型言語でほとんど関数型スタイルでプログラミングします。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに深く掘り下げると、OOPとFPの間に特別な違いがないことは明らかです。</font><font style="vertical-align: inherit;">OOPは、AFとほぼ同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UMLダイアグラムの実装の簡単な例について説明します。</font><font style="vertical-align: inherit;">古典的な例：形状、円、四角、継承、仮想関数。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sm/yu/e1/smyue10nmz3bcdhvsvf8kagfmgi.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swiftの実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は最近、これがOOPではなく、プロトコル指向プログラミングであることを学びました。</font><font style="vertical-align: inherit;">しかし、Swiftでは何も理解できなかったため、何が起こったのかがわかりました。</font></font><br>
<br>
<pre><code class="swift">protocol Shape {<font></font>
    func area() -&gt; Double<font></font>
    func diameter() -&gt; Double<font></font>
}<font></font>
<font></font>
class Circle: Shape {<font></font>
    var r = 0.0<font></font>
    init(radius: Double) {<font></font>
        r = radius<font></font>
    }<font></font>
    func area() -&gt; Double {<font></font>
        return 3.14 * r * r<font></font>
    }<font></font>
    func diameter() -&gt; Double {<font></font>
        return 2 * r<font></font>
    }<font></font>
}<font></font>
<font></font>
class Square: Shape {<font></font>
    var s = 0.0<font></font>
    init(size: Double) {<font></font>
        s = size<font></font>
    }<font></font>
    func area() -&gt; Double {<font></font>
        return s * s<font></font>
    }<font></font>
    func diameter() -&gt; Double {<font></font>
        return sqrt(2) * s<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能しているようですが、OOPは機能していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリアル化、メソッド、コンストラクターなど、実装はすべてシンプルです。</font><font style="vertical-align: inherit;">これは古典的なGrad BuechスタイルのOOPです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、円と正方形でこのコードを実行します。</font></font><br>
<br>
<pre><code class="swift">func testShape(shape: Shape) {<font></font>
    print(shape.area())<font></font>
    print(shape.diameter())<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果が出ました。</font><font style="vertical-align: inherit;">すべてが機能しています。</font></font><br>
<br>
<pre><code class="swift">testShape(shape: Circle(radius: 5))<font></font>
testShape(shape: Square(size: 5))<font></font>
<font></font>
78.5<font></font>
10.0<font></font>
25.0<font></font>
7.0710678118654755</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは多態性が機能するはずですが、これはOOPではなくPOPであるため、おそらく他の機能が機能します。</font><font style="vertical-align: inherit;">しかし、これは重要ではありません-動作する主なもの。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskellの実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、Swiftコードと同じように機能するHaskellコードです。</font></font><br>
<br>
<pre><code class="haskell">data Shape = Circle Double | Square Double<font></font>
<font></font>
area :: Shape -&gt; Double<font></font>
area (Circle r) = 3.14 * r * r<font></font>
area (Square s) = s * s<font></font>
<font></font>
diameter :: Shape -&gt; Double<font></font>
diameter (Circle r) = 2* r<font></font>
diameter (Square s) = sqrt 2 * s</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPでは、データと関数は別々に存在します。</font><font style="vertical-align: inherit;">最初の行には、「代数的データ型」と呼ばれる円または正方形のデータ型があります。</font><font style="vertical-align: inherit;">次に、「or」操作を使用してデータ型を構築します。</font><font style="vertical-align: inherit;">そして、いくつかの関数は面積と直径を考慮します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数はパターンマッチングを使用します—それらはそれが円か正方形かをチェックし、適切な線を選択します。</font><font style="vertical-align: inherit;">これは、Haskellでの動作方法です-個別。</font><font style="vertical-align: inherit;">関数は1つずつ呼び出され、その結果がカウントされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<pre><code class="haskell">&gt; area (Circle 5)<font></font>
78.5<font></font>
&gt; diameter (Circle 5)<font></font>
10.0<font></font>
&gt; area (Square 5)<font></font>
25.0<font></font>
 diameter (Square 5)<font></font>
7.0710678118654755</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直径の概念-図形の最も離れた2点間の距離-は、あらゆる形状の図形に使用され、二乗は対角線です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftとHaskellは逆のアプローチをしているようです。</font><font style="vertical-align: inherit;">我々は持っている</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスとその子孫</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、我々は、実装、および</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティの2種類を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、我々は関数を記述され、それぞれのために、。</font><font style="vertical-align: inherit;">ただし、コードを表の形式で提示する場合、列はフォームのタイプで、行は関数です。違いがないことがわかります。</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サークル</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平方</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直径</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
</tr>
</tbody>
</table></div><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPはこのテーブルを列で処理します。各列は1つのクラスです。</font><font style="vertical-align: inherit;">関数について話しているため、FPは行ごとにテーブルを処理しています。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは何ですか、テーブルの操作方法と見方：行または列を通して？</font><font style="vertical-align: inherit;">関連する概念については、これは重要ではありません。</font><font style="vertical-align: inherit;">これは、オブザーバーとしてのみ私たちにとって重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケジューリングを行う場合、技術的な違いがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP内-仮想メソッドのテーブル上のポインターによって関数が呼び出される前。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FP-関数呼び出しの後、どのエンティティが関数に入ってきたかを調べ、目的の行を選択します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
思想的には、テーブルを操作するだけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代数的データ型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swiftには代数的データ型が存在することが知られています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellコード...</font></font><br>
<br>
<pre><code class="haskell">data Shape = Circle Double | Square Double</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... Swiftはもう少し冗長になります。</font></font><br>
<br>
<pre><code class="swift">enum Shape { <font></font>
    case Circle(radius: Double) <font></font>
    case Square(size: Double)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、考え方は同じです。</font><font style="vertical-align: inherit;">Swiftでは「enum」が使用される代わりに、代数的データ型の「or」演算を除いて、実装は類似しています。</font><font style="vertical-align: inherit;">たとえば、関数は拡張メソッドとしてフォーマットできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellコード...</font></font><br>
<br>
<pre><code class="haskell">area :: Shape -&gt; Double <font></font>
    area (Circle r) = 3.14 * r * r <font></font>
    area (Square s) = s * s</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... Swiftはより冗長です。</font></font><br>
<br>
<pre><code class="swift">extension Shape {<font></font>
    var area: Double {<font></font>
        switch self {<font></font>
            case .Circle(let r): return 3.14 * r * r <font></font>
            case .Square(let s): return s * s<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、繰り返しますが、考え方は同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代数的データ型は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlinに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も存在し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="kotlin">sealed class Shape {<font></font>
    data class Circle(val radius: Double): Shape() <font></font>
    data class Square(val size: Double): Shape()<font></font>
}<font></font>
fun area(sh: Shape): Double {<font></font>
    return when (sh) {<font></font>
        is Shape.Circle -&gt; 3.14 * sh.radius * sh.radius <font></font>
        is Shape.Square -&gt; sh.size * sh.size <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より多くの言葉、しかしイデオロギー的に-同様に。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、KotlinとSwiftは機能的なPLではないと言いますか？</font><font style="vertical-align: inherit;">意外と便利なので、これらの要素を使用します。</font><font style="vertical-align: inherit;">FPの要素は主流の言語になりました。主流の言語は、FPのすべてを最大限に利用してきたため、オブジェクト指向とは言えません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">膨張問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPとFPには別の違いがあります。</font><font style="vertical-align: inherit;">テーブルを拡張し、別の列または行を追加する場合、1つのパラダイムでテーブルを拡張するいくつかの方法がうまく機能し、他の方法ではうまく機能しないという制限があります。</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サークル</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平方</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バツ</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直径</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></td>
</tr>
</tbody>
</table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPでは、1つのクラスを簡単に作成できますが、別のメソッドを追加するには、基本クラスに入り、何かを追加する必要があります。すべてを再コンパイルします。</font><font style="vertical-align: inherit;">多くの困難があります。</font><font style="vertical-align: inherit;">FPも：新しいオブジェクトを追加するときに問題が発生します。基本型の定義を再コンパイルする必要があります。</font><font style="vertical-align: inherit;">逆に、機能を追加するのは簡単です。</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サークル</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平方</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バツ</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +（OOP）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直径</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +（OOP）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +（FP）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +（FP）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></td>
</tr>
</tbody>
</table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右下隅はどちらの方法でも最も難しいです。</font><font style="vertical-align: inherit;">美しくすることは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究者たちは20年間、拡大の問題に取り組んできました。</font><font style="vertical-align: inherit;">このタスクは、YPの表現力をテストすることがよくあります。</font><font style="vertical-align: inherit;">主な例は、おもちゃのプログラミング言語をコンパイルするタスクのようなものであり、言語構成を追加したいとき、型を追加して操作を拡張し、型を静的に制御します。</font><font style="vertical-align: inherit;">しかし、同時に、何も再コンパイルしたくないし、型を明示的にキャストしたくありません-すべてはコンパイラーによって自動的に行われるべきです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションのアプローチ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拡張問題-OOPとFPの間の基本的なジレンマ-には多くの解決策があります。</font><font style="vertical-align: inherit;">それらは過去20年間公開されており、多くのPLがすでにそれらを実装しています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン「ビジター」。</font><font style="vertical-align: inherit;">問題自体が定式化される前から生じた解決策。</font><font style="vertical-align: inherit;">この方法はうまく機能しますが、制限があります。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチメソッド。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンクラスは拡張メソッドです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプクラス。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの代数。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアプローチのすべて、そして「オブジェクトの代数」というひどい名前のソリューションでさえ、何らかの方法で拡張の問題を解決します。</font><font style="vertical-align: inherit;">詳細はやめません。</font><font style="vertical-align: inherit;">しかし、プログラミング言語ではなくプログラミング言語だけに興味がある場合は、自分で学習してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代数について</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代数ではなく、この言葉全般についてお話ししたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるファンクショナルに出会うと、セミグループ、モノイド、ファンクター、モナドといった恐ろしい言葉がすぐに聞こえてきます。時々、職人たちはこの古い絵の正義を証明しているようです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9m/de/9i/9mde9ivlsr1rca-aghsfsyn_sxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは間違いなくハスケルの支持者によって描かれました。他に誰がアインシュタインの形で自分を代表し、誰もがアインシュタインとして彼を代表し、「怖い」言葉を話すと思いますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ファンクター」のようなすべての恐ろしい言葉は、特定のプログラミング問題であり、それ以上のものではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セミグループとモノイドは、同じ種類のエンティティ内のエンティティの配置を単純化します-「複合」パターン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。モノイドとセミグループがあります。エンティティを取得して構成し、処理を容易にするために同じ種類のエンティティを取得するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Kotlinの文字列連結演算は、モノイドの通常の使用法です。</font></font><br>
<br>
<pre><code class="kotlin">val a = "Hello " <font></font>
val b = "world"<font></font>
val c = a + b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般代数についての講義をするとき、私はこう言います。「プログラマー、文字列の折り方を知っていますか？</font><font style="vertical-align: inherit;">これはモノイドです。」</font><font style="vertical-align: inherit;">あなたは正式な数学的定義を与えることができますが、簡潔にそして正式性なしで-これは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの線を1つに配置することです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の例は、HTTPリクエストのプロパティの構成です。</font><font style="vertical-align: inherit;">架空のKotlinでは、次のようになります。</font></font><br>
<br>
<pre><code class="kotlin">val a = HttpReq("f","v1") <font></font>
val b = HttpReq("f2","v2")<font></font>
val c = a + b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のHaskellには、まったく同じことを行うライブラリがあります。</font><font style="vertical-align: inherit;">そこでは、HTTPオブジェクトのプロパティはモノイドです。</font><font style="vertical-align: inherit;">それらを追加し、個々のコンポーネントから新しいHTTPリクエストを作成します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モナドとファンクタでも同じです。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファンクタとモナドを使用すると、一連の計算手順を簡単に説明できます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ステップは1つずつ順番に実行され、どういうわけか互いに依存します。</font><font style="vertical-align: inherit;">依存関係は、順次実行だけでなく、特定のコンテキスト-これらのステップ以外にも存在するものです。</font><font style="vertical-align: inherit;">現代の言語のプログラマーは、たとえばSwiftで「オプションのチェーン」を使用することがあります。</font></font><br>
<br>
<pre><code class="swift">if let johnsStreet = john.residence?.address?.street<font></font>
{ /* SUCCESS */ } else { /* FAILURE */ }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アドレスを計算し、オブジェクトから取得しようとしています。</font><font style="vertical-align: inherit;">「john」というオブジェクトがあります-居住地を抽出します。</font></font><br>
<br>
<ul>
<li><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> は、居住地が不在の可能性があることを意味します。この場合、私たちはすぐに偽になります。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、居住地が存在する場合、そこから住所を取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">住所が不足している可能性もあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在する場合、ラインを取得します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算は逐次的です。オブジェクトから1つ、次に別、次に3番目を取得します。</font><font style="vertical-align: inherit;">ここでのコンテキストは、適切な意味の欠如の可能性です。</font><font style="vertical-align: inherit;">存在しない場合は、elseブランチを返します-この場合、失敗した結果です。</font><font style="vertical-align: inherit;">どの段階でも中断できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swiftの作成者たちは、モナドでプログラマーを怖がらせ始めませんでした。</font><font style="vertical-align: inherit;">彼らはモナドが何であるかを知っており、モナド計算を実行する構文を言語に導入しました：意味のないコンテキストでの一連のステップ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellモナドで同じコードを書いた場合、次のようになります。</font></font><br>
<br>
<pre><code class="haskell">case residence john &gt;&gt;= address &gt;&gt;= street of<font></font>
    Just johnsStreet -&gt; -- SUCCESS<font></font>
    Nothing -&gt; -- FAILURE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;「&gt;&gt; =」モナド結合の主な操作です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、コードの意味はこれから変わりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swiftでは、「オプションの連鎖」のために、新しい構文構造を導入する必要がありました。</font><font style="vertical-align: inherit;">Kotlinでは、コルーチンのために、一連の構文と概念を導入する必要もあります。</font><font style="vertical-align: inherit;">Haskellでは、同じコルーチンが予期せず同じ "&gt;&gt; ="演算子を持つ同じモナド計算に変わります。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モナドには2つのアプローチがあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミング言語を拡張し、モナディック計算の抽象化をプログラマーから隠し、同時に使用する機会を与えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskellのように、抽象化を突き出します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらのアプローチも優れています。</font><font style="vertical-align: inherit;">しかし、大規模な主流のPLで抽象化を上向きにするという考えは、まだ良いとは言えません。</font><font style="vertical-align: inherit;">多くの異なる構文要素を導入し、何が起こっているかについての共通の理解をプログラマーから隠す方が良いと考えられています。</font><font style="vertical-align: inherit;">多分これは良いでしょう-より高いレベルの抽象化に行くよりも簡単です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのエンティティがあり、それらに異なる演算を適用する場合、これは代数です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイル開発ですでに「代数」の塊を使用しています。</font><font style="vertical-align: inherit;">すべてのプログラミングは、さまざまな方法で処理するエンティティです。</font><font style="vertical-align: inherit;">通常、これを「代数」とは呼びませんが、そうです。</font><font style="vertical-align: inherit;">したがって、今では「オブジェクトの代数」の概念は私たちを怖がらせません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化は良いですか悪いですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問に対する単一の答えはありません。プログラミング言語の開発者は、自分が何をしているかを自分で決定します-彼らはプログラマーに抽象化を行うか、構文要素の背後にそれを隠します。</font><strong><font style="vertical-align: inherit;">抽象化は美しい</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
と思います</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューカッスル大学とその共著者の</font><strong><font style="vertical-align: inherit;">Andrei Mokhovに</font></strong></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よるBuild Systems a la Carte</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の複雑なHaskell構文の例を使ってこれを示します</font><font style="vertical-align: inherit;">。この論文は、2018年秋にセントルイスで行われた関数型プログラミングに関する国際会議（ICFP）でDistinguished Paper Awardを受賞しました。この注目すべき作品は、誰もが使用するビルドシステムに捧げられています。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者は、特定のビルドシステムから抽象化し、1つの形式化-抽象化を使用して異なるビルドシステムを表現することを提案しています。</font><font style="vertical-align: inherit;">これを行うために、彼らはストレージの概念を紹介します。</font></font><br>
<br>
<pre><code class="haskell">data Store i k v</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションがあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-組立システムの一定の情報;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-依存キー、たとえば、アセンブリ内のファイル名。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v-それ自体の値、つまり、収集されたファイルなどのアセンブリの結果</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリは抽象化です。 1つの例は、追加のメタ情報を含むファイルを含むファイルシステムです。ファイルにはディスク上の名前と内容があります。&nbsp; </font><strong><font style="vertical-align: inherit;">依存関係</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
もあります</font><font style="vertical-align: inherit;">。一部のファイルがそれらを収集するために他のファイルに依存していることを示したいと思います。オブジェクトファイルをアセンブルするには、まずこれとそれをディスク上で見つけてアセンブルし、それをすべて一緒に使用する必要があります。</font><font style="vertical-align: inherit;">
別の抽象概念- </font><strong><font style="vertical-align: inherit;">「タスク」-ビルドシステムのタスクがあります</font></strong><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="haskell">newtype Task c k v = Task { run :: forall f. c f =&gt; (k -&gt; f v) -&gt; f v }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが抽象化されているため、ここでは複雑なHaskell構文を使用しています。たとえば、モナドは "f"の特殊なケースであり、そこから抽象化が行われます。モナドに加えて、計算のシーケンスを説明する他の方法が存在する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こっていますか？関数「k-&gt; fv」は、キーと値の関係を表します。これは、1つのものを構築する方法です。この機能はパラメータの役割を果たします。この関数を適用した結果、最終的な値が取得されます。ここでは、ビルドシステムの1つのコンポーネントをビルドする方法について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーの構築は、次のタイプ（一連のタスク）によってすでに実行されています。</font></font><br>
<br>
<pre><code class="haskell">type Tasks c k v = k -&gt; Maybe (Task c k v) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、さまざまなビルド方法がさまざまなキーにどのように依存するかを説明する関数でもあります。</font><font style="vertical-align: inherit;">多分オプションのようなものです。</font><font style="vertical-align: inherit;">何かが何かに依存している、または依存していないことを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ビルドシステムの最終的な抽象化を取得します。</font></font><br>
<br>
<pre><code class="haskell">type Build c i k v = Tasks c k v -&gt; k -&gt; Store i k v<font></font>
    -&gt; Store i k v</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力は、依存関係システム全体の説明です。</font><font style="vertical-align: inherit;">次にキーkが来て、そこからアセンブリが始まります。</font><font style="vertical-align: inherit;">次は、初期保管と、完全に組み立てられたシステムでの機能の結果の保管です。</font><font style="vertical-align: inherit;">これは、他の抽象化の上に構築された抽象化の例です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andrei Mokhov et al。違いを識別し、4つのアセンブリシステムの記事で正式な説明を提供しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作る</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shake-Make for Haskellの類似物、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バゼル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エクセル</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の3つの組み立てシステムは多くの人に知られています。</font><font style="vertical-align: inherit;">第4に、Excelもビルドシステムです。</font><font style="vertical-align: inherit;">Excelも抽象的な形式化に該当します-その中でセルは互いに依存しています。</font><font style="vertical-align: inherit;">彼らは1つのセルに値を書き、何か他のものを数えました。</font><font style="vertical-align: inherit;">MakeとExcelには、この抽象化を使用して説明できる共通点があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPが非常に遅い</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、関数型プログラミングに関する一般的な不満です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-あなたのHaskellは遅いです。</font><font style="vertical-align: inherit;">私たちはすでに長い間すべてを数えてきましたが、あなたはまだあなたのプログラムを書いており、いかなる方法でもそれをコンパイルすることはできません。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々はい、時々いいえ。</font><font style="vertical-align: inherit;">実際、パフォーマンスはコンパイラの仕事です。</font><font style="vertical-align: inherit;">理想的なシステムでは、プログラマーが何を書いたかに関係なく、優れたコンパイラーは優れたコードを構築する必要があります。</font><font style="vertical-align: inherit;">それが悪いコードをビルドする場合、これは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラのせいです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言はパフォーマンスを妨げるべきではありません</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、非常に宣言的なHaskellコード：</font></font><br>
<br>
<pre><code class="haskell">h :: [a] -&gt; Int<font></font>
h = length . filter p . map g . map f</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはそれを疑似コードと考えることができます-私は関数の構成を使用しています。</font><font style="vertical-align: inherit;">ある種の入力を受け入れ、次に：</font></font><br>
<br>
<ul>
<li><code>map f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-各要素に関数を適用します</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><code>map g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-各要素に関数を適用します</font></font><code>g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><code>filter p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -すべてをフィルタリング：述語を適用し、述語を満たさないすべてのものを破棄します。</font></font></li>
<li><code>length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -結果のリストの長さを検討します-結果としてこれらのすべての条件を満たす要素の数。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主流の言語プログラマはすぐに叫び始めます：</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ホラー、そこに何サイクルあるか、中間データ構造がいくつあるか...これはまったくプログラミングではありません！</font><font style="vertical-align: inherit;">職業から抜け出す！</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラが弱いからといって。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">融合</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型言語には、他のプログラミング言語に徐々に浸透する「融合」の概念があります。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フュージョンとは？</font><font style="vertical-align: inherit;">簡単な方法で：宣言的で注意深く描かれた一連のステップ全体を命令サイクルに変えることができます。</font></font><br>
<br>
<pre><code class="haskell">c := 0<font></font>
foreach (x : xs)<font></font>
    if p(g(f(x)))<font></font>
        then c := c + 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイクルが</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（！）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、中間データ構造が</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0（！）で</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あることに注意を向けます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンパイラのタスクは、美しく理解できるコードを非常に効率的なプログラムに変換し、それをすべて2〜3個のアセンブラコマンドにコンパイルすることです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちはプログラマーとして、遅いプログラムを書くと考えています。</font><font style="vertical-align: inherit;">しかし、これは私たちの責任ではありません-これはコンパイラの責任です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラー開発者がコードを効率的にするように、よりよく考えてコンパイラーを作成してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUコンピューティング？</font><font style="vertical-align: inherit;">問題ない！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのベクトルのスカラー積を考慮するHaskellコードの別の例：</font></font><br>
<br>
<pre><code class="haskell">dotp :: Acc (Vector Float) -&gt; Acc (Vector Float) -&gt; Acc (Scalar Float) <font></font>
dotp xs ys = fold (+) 0 (zipWith (*) xs ys)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellで何が起こるかは関係ありません。2つのベクトルを取り、それらをコンポーネントごとに乗算して、コンポーネントの合計を求めます。</font><font style="vertical-align: inherit;">Haskellでは、コンパイル後のこのコードがGPUで直接機能することが重要です。</font><font style="vertical-align: inherit;">ベクトルはすぐにGPUに配置され、グラフィックアクセラレータはすべてを実行します。CUDA、Open CLをコンパイルします。</font><font style="vertical-align: inherit;">HaskellはAccelerateライブラリをコンパイルして効率的なコードを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはCUDAで100年を書きましたが、ここでは関数型の短い行を1行書き、非常に効果的なプログラムを得ました。</font><font style="vertical-align: inherit;">すべてが宣言的で高速です！</font><font style="vertical-align: inherit;">これはまさにコンパイラに求めていることです。</font><font style="vertical-align: inherit;">しかし、コンパイラーが今のところうまくいかない問題があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カレー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カレーは大きな問題です。</font><font style="vertical-align: inherit;">それは何ですか？</font><font style="vertical-align: inherit;">タイプa、b、cの3つのパラメーターと結果Dを持つ関数があります。</font></font><br>
<br>
<pre><code class="haskell">f :: A -&gt; B -&gt; C -&gt; D<font></font>
f a b c = ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数を単純に操作する場合、これはパラメーターとして渡すことです。</font><font style="vertical-align: inherit;">もう1つは、引数を部分的に示したときです。</font></font><br>
<br>
<ul>
<li><code>f :: A -&gt; B -&gt; C -&gt; D</code></li>
<li><code>f a :: B -&gt; C -&gt; D</code></li>
<li><code>f a b :: C -&gt; D</code></li>
<li><code>f a b c :: D</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2行目と3行目では、引数の一部を示し、一部を示していません。</font><font style="vertical-align: inherit;">部分的に適用されているこのような関数がどこかに転送されると、問題が発生します。</font><font style="vertical-align: inherit;">コンパイラはまだこれを行うのが得意ではありません-クロージャが作成され、多くのものが転送される必要があり、多くの時間が無駄になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Scalaなどの多くの言語では、動作が異なります。</font></font><br>
<br>
<pre><code class="scala">f :: A -&gt; (B , C) -&gt; D<font></font>
f a p = …<font></font>
    f :: A -&gt; B -&gt; C -&gt; D<font></font>
    f a :: (B, C) -&gt; D<font></font>
    f a p :: D</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは言う：「あなたはこれを禁止することができますが、そうではありません。</font><font style="vertical-align: inherit;">これらの2つの引数を分離することはできません。常に一緒にする必要があります。</font><font style="vertical-align: inherit;">ここではコンパイルしますが、ここではコンパイルしません。」</font><font style="vertical-align: inherit;">その結果、PLはプログラマーの能力を制限します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは関数型言語でも解決されていない未解決の問題です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPでは、正確性を保証する方が簡単です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正確性はFPでうまく機能します。</font><font style="vertical-align: inherit;">Haskellは15年前に、正確性のテストに役立つQuickCheckライブラリを使用して誕生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、文字列をラップする関数があります。</font></font><br>
<br>
<pre><code class="haskell">reverse :: String -&gt; String<font></font>
reverse = ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数のプロパティを作成してテストします。</font><font style="vertical-align: inherit;">同じ行に2回適用すると、元の行が取得されます。</font></font><br>
<br>
<pre><code class="haskell">&gt; quickCheck (\s -&gt; reverse (reverse s) == s)<font></font>
    +++ OK, passed 100 tests.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、これは純粋な関数であり、そのためにそのようなプロパティを思い付くことができます。</font><font style="vertical-align: inherit;">ライブラリは多くの引数（この場合は100）をランダムに生成して実行し、このプロパティが満たされていることを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の例ではなく、コードの操作性をチェックしますが、プロパティを公式化し、すべての引数でこのプロパティが満たされなければならないことを述べています。</font><font style="vertical-align: inherit;">私たちは数学的に働きます。</font><font style="vertical-align: inherit;">このアイデアは、15年前のHaskellで生まれました。</font><font style="vertical-align: inherit;">現在、同様のアイデアが他の言語に浸透しています。</font><font style="vertical-align: inherit;">SwiftとKotlinにはすでにそのようなライブラリーがあると思います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラー例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで間違いが起こると思いますか？</font></font><br>
<br>
<pre><code class="haskell">abs :: Int -&gt; Int <font></font>
abs x = if x &lt; 0 then 0 - x else x<font></font>
<font></font>
head :: [a] -&gt; a --      ! <font></font>
head (x:_) = x <font></font>
<font></font>
example :: Int -&gt; Int<font></font>
example x = if abs x &lt; 0 then head [] else x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中央の関数は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空でない</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストで</font><font style="vertical-align: inherit;">機能することに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="haskell">head :: [a] -&gt; a --      ! <font></font>
head (x:_) = x </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空でないリストが送信された場合、関数</font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はその先頭を返し</font><font style="vertical-align: inherit;">、空のリストでは機能</font><font style="vertical-align: inherit;">しません-飛ぶはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空のリストに対して呼び出された「ヘッド」に到達しますか？</font><font style="vertical-align: inherit;">いいえ、LiquidHaskellはそれを証明できます。</font><font style="vertical-align: inherit;">LiquidHaskellは静的なHaskellコード検証ツールです。</font></font><br>
<br>
<pre><code class="haskell">{-@ abs :: Int -&gt; { n : Int | 0 &lt;= n } @-} <font></font>
abs :: Int -&gt; Int <font></font>
abs x = if x &lt; 0 then 0 - x else x<font></font>
<font></font>
{-@ head :: { xs : [a] | 1 &lt;= len xs } -&gt; a @-} <font></font>
head :: [a] -&gt; a --      ! <font></font>
head (x:_) = x <font></font>
<font></font>
{-@ head :: { xs : [a] | 1 &lt;= len xs } -&gt; a @-} <font></font>
head :: [a] -&gt; a --      ! <font></font>
head (x:_) = x </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数absは常にn以上の数を持つと言えます。</font></font><br>
<br>
<pre><code class="haskell">{-@ abs :: Int -&gt; { n : Int | 0 &lt;= n } @-} <font></font>
abs :: Int -&gt; Int <font></font>
abs x = if x &lt; 0 then 0 - x else x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、関数が特定の長さのリストで定義されていると書きます。</font></font><br>
<br>
<pre><code class="haskell">{-@ head :: { xs : [a] | 1 &lt;= len xs } -&gt; a @-} <font></font>
head :: [a] -&gt; a --      ! <font></font>
head (x:_) = x </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、関数が渡されたものを返すことを証明します。</font><font style="vertical-align: inherit;">Xが関数に渡され、xも返されます。</font></font><br>
<br>
<pre><code class="haskell">{-@ example :: x : Int -&gt; { y : Int | x == y } @-} <font></font>
example :: Int -&gt; Int<font></font>
example x = if abs x &lt; 0 then head [] else x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーまたはそのコンポーネントは、プログラムをチェックして、プログラムのいくつかのプロパティを証明でき、安全であることがわかります。</font><font style="vertical-align: inherit;">純粋な関数での作業が積極的に使用されているため、これはまだ関数型プログラミングです。</font><font style="vertical-align: inherit;">いつかこれが主流の言語で見られる可能性があります。</font><font style="vertical-align: inherit;">たとえばエッフェルでは、オブジェクト指向言語のいくつかの試みがすでにあります。つまり、何か近いことができるということです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは何ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはWeb開発の例です。</font></font><br>
<br>
<pre><code class="haskell">type MyAPI = Get '[PlainText] String<font></font>
    :&lt;|&gt; "conf" :&gt; Get '[JSON] String<font></font>
    :&lt;|&gt; "year" :&gt; Get '[JSON] Int<font></font>
    :&lt;|&gt; "like" :&gt; Get '[JSON] Bool<font></font>
myAPI :: Server MyAPI <font></font>
    = root :&lt;|&gt; year :&lt;|&gt; conf :&lt;|&gt; like</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellには、型を使用してAPI呼び出しをモデル化できるサーバントライブラリがあります。</font><font style="vertical-align: inherit;">たとえば、上記のコードには、1年の会議のURLがいくつかありますが、そうでない場合もあり、結果はJSONでエンコードされます。</font><font style="vertical-align: inherit;">結果にはさまざまなタイプがあることがわかります：String "、Int"、Bool。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるハンドラーを作成します。</font></font><br>
<br>
<pre><code class="haskell">root :: Handler String				<font></font>
root = pure "Welcome to my REST API" 	<font></font>
conf :: Handler String				<font></font>
conf = pure "AppsConf"	   		<font></font>
year :: Handler Int<font></font>
year = pure 2019 conf<font></font>
like :: Handler Bool<font></font>
like = pure True</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてライブラリはすべてを制御します-結果は本来あるべきものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが機能し、型システムがプログラムの正確さを保護します。</font><font style="vertical-align: inherit;">コンパイラーがスキップしないという理由だけで、1年間の要求に対して整数ではなく文字列を返すことができない場合があります。</font><font style="vertical-align: inherit;">正確さはとても良いです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングは興味深いものです。私は誰もがそれに切り替えることを勧めませんが、その要素はすべての通常のPLに移行します。そして、それは素晴らしいことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味がある場合は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Will Kurtの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著書、Programming at Haskell </font><font style="vertical-align: inherit;">から始めて</font><font style="vertical-align: inherit;">ください。ロシア語で、彼女は2018年11月に釈放されました。 3人の生徒が翻訳し、編集しました。私はこの本をHaskellを初めて使う人に勧めます。 600ページすべてをマスターしたら、次へ進みます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Haskell in Depth」は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あるVitaly Bragilevskyによって作成されました。この本はまだ初期段階にあり、まだ完成していませんが、お勧めします。プロモーションコード「slbragilevsky」では、42％の割引が受けられます。</font></font><br>
<br>
<blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Saint AppsConf</a>  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Introductory-</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>,       .    , ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>   ,        iOS, Android, -   —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>   .  ,         ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.<br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">telegram-</a>,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462489/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.374（2019年7月29日〜8月4日）</a></li>
<li><a href="../ja462493/index.html">マルチモデルDBMS-現代の情報システムの基礎？</a></li>
<li><a href="../ja462495/index.html">8月5〜11日のモスクワでのデジタルイベント</a></li>
<li><a href="../ja462501/index.html">独自の証明機関が必要な理由</a></li>
<li><a href="../ja462503/index.html">モニタリングとSREの「ゴールデンシグナル」とは何ですか？</a></li>
<li><a href="../ja462507/index.html">メール配信時：iOSでのプッシュ通知の喪失との戦い</a></li>
<li><a href="../ja462509/index.html">Product Fest-行きたいIT製品管理会議</a></li>
<li><a href="../ja462511/index.html">Google Play Instant。生涯のリファクタリング</a></li>
<li><a href="../ja462513/index.html">移転：領域の準備、選択、開発</a></li>
<li><a href="../ja462515/index.html">システムキーボードを操作するときのバグ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>