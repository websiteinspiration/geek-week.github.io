<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç• üë®üèª‚Äçüç≥ üó£Ô∏è Structures de donn√©es immuables √† la pointe de la technologie üññüèΩ üöì üë∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis des ann√©es, des experts en C ++ discutent de la s√©mantique des valeurs, de l'immuabilit√© et du partage des ressources par la communication. √Ä p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Structures de donn√©es immuables √† la pointe de la technologie</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis des ann√©es, des experts en C ++ discutent de la s√©mantique des valeurs, de l'immuabilit√© et du partage des ressources par la communication. </font><font style="vertical-align: inherit;">√Ä propos d'un nouveau monde sans mutex ni races, sans mod√®les de commandement et d'observation. </font><font style="vertical-align: inherit;">En fait, tout n'est pas si simple. </font><font style="vertical-align: inherit;">Le principal probl√®me r√©side toujours dans nos structures de donn√©es.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les structures de donn√©es immuables ne changent pas leurs valeurs. Pour faire quelque chose avec eux, vous devez cr√©er de nouvelles valeurs. Les anciennes valeurs restent au m√™me endroit, donc elles peuvent √™tre lues √† partir de diff√©rents flux sans probl√®mes et verrous. Par cons√©quent, les ressources peuvent √™tre partag√©es de mani√®re plus rationnelle et ordonn√©e, car les anciennes et les nouvelles valeurs peuvent utiliser des donn√©es communes. Gr√¢ce √† cela, ils sont beaucoup plus rapides √† comparer les uns avec les autres et stockent de mani√®re compacte l'historique des op√©rations avec la possibilit√© d'annulation. Tout cela s'int√®gre parfaitement sur les syst√®mes multi-threads et interactifs: de telles structures de donn√©es simplifient l'architecture des applications bureautiques et permettent aux services de mieux √©voluer. Les structures immuables sont le secret du succ√®s de Clojure et Scala, et m√™me la communaut√© JavaScript en profite d√©sormais, car elles ont la biblioth√®que Immutable.js,√©crit dans les entrailles de la soci√©t√© Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la coupe - vid√©o et traduction du rapport </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la conf√©rence C ++ Russia 2019 Moscou. </font><font style="vertical-align: inherit;">Juan parle d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une biblioth√®que de structures immuables pour C ++. </font><font style="vertical-align: inherit;">Dans la poste:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avantages architecturaux de l'immunit√©;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©ation d'un type de vecteur persistant efficace bas√© sur des arbres RRB;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analyse de l'architecture sur l'exemple d'un simple √©diteur de texte.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La trag√©die de l'architecture bas√©e sur la valeur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre l'importance des structures de donn√©es immuables, nous discutons de la s√©mantique des valeurs. C'est une caract√©ristique tr√®s importante du C ++, je le consid√®re comme l'un des principaux avantages de ce langage. Pour tout cela, il est tr√®s difficile d'utiliser la s√©mantique des valeurs comme on le souhaiterait. Je crois que c'est la trag√©die de l'architecture bas√©e sur la valeur, et la route vers cette trag√©die est pav√©e de bonnes intentions. Supposons que nous devions √©crire un logiciel interactif bas√© sur un mod√®le de donn√©es avec une repr√©sentation d'un document modifiable par l'utilisateur. Lorsque l' </font><font style="vertical-align: inherit;">architecture bas√©e sur les valeurs au c≈ìur de ce mod√®le utilise des </font><font style="vertical-align: inherit;">types de valeurs simples et pratiques qui existent d√©j√† dans la langue: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La logique d'application est cr√©√©e √† partir de fonctions qui prennent les documents par valeur et renvoient une nouvelle version d'un document par valeur. Ce document peut changer √† l'int√©rieur de la fonction (comme cela se produit ci-dessous), mais la s√©mantique des valeurs en C ++, appliqu√©e √† l'argument par valeur et au type de retour par valeur, garantit qu'il n'y a pas d'effets secondaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonctionnalit√© est tr√®s facile √† analyser et √† tester. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque nous travaillons avec des valeurs, nous allons essayer d'impl√©menter l'annulation de l'action. Cela peut √™tre difficile, mais avec notre approche, c'est une t√¢che triviale: nous avons </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec diff√©rents √©tats diff√©rentes copies du document.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons √©galement une interface utilisateur et pour garantir sa r√©activit√©, le mappage de l'interface utilisateur doit √™tre effectu√© dans un thread distinct. Le document est envoy√© √† un autre flux par message, et l'interaction a √©galement lieu sur la base de messages, et non via le partage d'√©tat √† l'aide </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque la copie est re√ßue par le deuxi√®me flux, vous pouvez y effectuer toutes les op√©rations n√©cessaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'enregistrement d'un document sur le disque est souvent tr√®s lent, surtout si le document est volumineux. Par cons√©quent, l'utilisation de </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette op√©ration est effectu√©e de mani√®re asynchrone. Nous utilisons un lambda, mettons un signe √©gal √† l'int√©rieur pour avoir une copie, et maintenant vous pouvez enregistrer sans autres types de synchronisation primitifs.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, supposons que nous ayons √©galement un flux de contr√¥le sonore. Comme je l'ai dit, j'ai beaucoup travaill√© avec des logiciels de musique, et le son est une autre repr√©sentation de notre document, il doit √™tre dans un flux s√©par√©. Par cons√©quent, une copie du document est √©galement requise pour ce flux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cons√©quence, nous avons obtenu un sch√©ma tr√®s beau, mais pas trop r√©aliste. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il doit constamment copier des documents, l'historique des actions pour l'annulation prend des gigaoctets, et pour chaque rendu de l'interface utilisateur, vous devez faire une copie compl√®te du document. En g√©n√©ral, toutes les interactions sont trop co√ªteuses.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que fait le d√©veloppeur C ++ dans cette situation? Au lieu d'accepter un document par valeur, la logique d'application accepte d√©sormais un lien vers le document et le met √† jour si n√©cessaire. Dans ce cas, vous n'avez rien √† retourner. Mais maintenant, il ne s'agit pas de valeurs, mais d'objets et d'emplacements. Cela cr√©e de nouveaux probl√®mes: s'il existe un lien avec l'√âtat avec un acc√®s partag√©, vous en avez besoin </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ceci est extr√™mement co√ªteux, il y aura donc une certaine repr√©sentation de notre interface utilisateur sous la forme d'une arborescence extr√™mement complexe √† partir de divers widgets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous ces √©l√©ments devraient recevoir des mises √† jour lorsqu'un document change, donc un m√©canisme de mise en file d'attente est n√©cessaire pour les signaux de changement. De plus, l'historique du document n'est plus un ensemble d'√©tats, ce sera une mise en ≈ìuvre du mod√®le d'√©quipe. L'op√©ration doit √™tre mise en ≈ìuvre deux fois, dans un sens et dans l'autre, et assurez-vous que tout est sym√©trique. L'enregistrement dans un thread s√©par√© est d√©j√† trop difficile, il faudra donc l'abandonner. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les utilisateurs sont d√©j√† habitu√©s √† l'image du sablier, donc √ßa va s'ils attendent un peu. Une autre chose fait peur - le monstre de p√¢tes gouverne maintenant notre code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä quel moment tout s'est-il d√©grad√©? </font><font style="vertical-align: inherit;">Nous avons tr√®s bien con√ßu notre code, puis nous avons d√ª faire des compromis √† cause de la copie. </font><font style="vertical-align: inherit;">Mais en C ++, la copie est requise pour passer par valeur uniquement pour les donn√©es mutables. </font><font style="vertical-align: inherit;">Si l'objet est immuable, alors l'op√©rateur d'affectation peut √™tre impl√©ment√© de sorte qu'il ne copie que le pointeur vers la repr√©sentation interne et rien de plus.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez une structure de donn√©es qui pourrait nous aider. </font><font style="vertical-align: inherit;">Dans le vecteur ci-dessous, toutes les m√©thodes sont marqu√©es comme </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©tant immuables. </font><font style="vertical-align: inherit;">√Ä l'ex√©cution </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le vecteur ne se met pas √† jour; √† la place, un nouveau vecteur est retourn√©, auquel les donn√©es transf√©r√©es sont ajout√©es. </font><font style="vertical-align: inherit;">Malheureusement, nous ne pouvons pas utiliser de crochets avec cette approche en raison de leur d√©finition. </font><font style="vertical-align: inherit;">Au lieu de cela, vous pouvez utiliser la fonction</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie une nouvelle version avec un √©l√©ment mis √† jour. Notre structure de donn√©es a maintenant une propri√©t√© qui s'appelle la persistance dans la programmation fonctionnelle. Cela ne signifie pas que nous sauvegardons cette structure de donn√©es sur le disque dur, mais le fait que lorsqu'il est mis √† jour, l'ancien contenu n'est pas supprim√© - √† la place, une nouvelle fourchette de notre monde est cr√©√©e, c'est-√†-dire la structure. Gr√¢ce √† cela, nous pouvons comparer les valeurs pass√©es avec le pr√©sent - cela se fait √† l'aide de deux </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les modifications peuvent d√©sormais √™tre v√©rifi√©es directement, elles ne sont plus des propri√©t√©s cach√©es de la structure de donn√©es. Cette fonctionnalit√© est particuli√®rement utile dans les syst√®mes interactifs o√π nous devons constamment modifier les donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre propri√©t√© importante est le partage structurel. Maintenant, nous ne copions pas toutes les donn√©es pour chaque nouvelle version de la structure de donn√©es. M√™me avec </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes les donn√©es ne sont pas copi√©es, mais seulement une petite partie. Toutes nos fourches ont un acc√®s commun √† une vue compacte, proportionnelle au nombre de modifications et non au nombre de copies. Il s'ensuit √©galement que la comparaison est tr√®s rapide: si tout est stock√© dans un bloc m√©moire, dans un pointeur, alors vous pouvez simplement comparer les pointeurs et ne pas examiner les √©l√©ments qui s'y trouvent, s'ils sont √©gaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'un tel vecteur, il me semble, est extr√™mement utile, je l'ai impl√©ment√© dans une biblioth√®que s√©par√©e: c'est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - une biblioth√®que de structures immuables, un projet open source.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En l'√©crivant, je voulais que son utilisation soit famili√®re aux d√©veloppeurs C ++. </font><font style="vertical-align: inherit;">Il existe de nombreuses biblioth√®ques qui impl√©mentent les concepts de programmation fonctionnelle en C ++, mais cela donne l'impression que les d√©veloppeurs √©crivent pour Haskell, et non pour C ++. </font><font style="vertical-align: inherit;">Cela cr√©e des inconv√©nients. </font><font style="vertical-align: inherit;">De plus, j'ai r√©alis√© de bonnes performances. </font><font style="vertical-align: inherit;">Les gens utilisent C ++ lorsque les ressources disponibles sont limit√©es. </font><font style="vertical-align: inherit;">Enfin, je voulais que la biblioth√®que soit personnalisable. </font><font style="vertical-align: inherit;">Cette exigence est li√©e √† l'exigence de performance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A la recherche d'un vecteur magique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la deuxi√®me partie du rapport, nous verrons comment est structur√© ce vecteur immuable. La fa√ßon la plus simple de comprendre les principes d'une telle structure de donn√©es est de commencer par une liste r√©guli√®re. Si vous √™tes un peu familier avec la programmation fonctionnelle (en utilisant Lisp ou Haskell comme exemple), vous savez que les listes sont les structures de donn√©es immuables les plus courantes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, supposons que nous avons une liste avec un seul n≈ìud </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lors de l'ajout de nouveaux √©l√©ments en haut de la liste, de nouveaux n≈ìuds sont cr√©√©s, chacun ayant un pointeur sur un n≈ìud existant. Par cons√©quent, dans l'exemple de la diapositive, nous n'avons pas trois copies d'une liste, mais trois √©l√©ments en m√©moire, c'est-√†-dire </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'ils </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquent des √©l√©ments diff√©rents. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons √©galement cr√©er une fourchette de r√©alit√©, c'est-√†-dire cr√©er une nouvelle liste qui a la m√™me fin, mais un d√©but diff√©rent.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De telles structures de donn√©es sont √©tudi√©es depuis longtemps: Chris Okasaki a √©crit le travail fondamental des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structures de donn√©es purement fonctionnelles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De plus, la structure de donn√©es de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> propos√©e par Ralf Hinze et Ross Paterson est tr√®s int√©ressante </font><font style="vertical-align: inherit;">. Mais pour C ++, ces structures de donn√©es ne fonctionnent pas bien. Ils utilisent de petits n≈ìuds, et nous savons qu'en C ++, les petits n≈ìuds signifient un manque d'efficacit√© de la mise en cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, ils s'appuient souvent sur des propri√©t√©s que C ++ ne poss√®de pas, comme la paresse. Par cons√©quent, le travail de Phil Bagwell sur les structures de donn√©es immuables nous est beaucoup plus utile - un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©crit au d√©but des ann√©es 2000, ainsi que le travail de Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auteur de Clojure. Rich Hickey a cr√©√© une liste, qui n'est en fait pas une liste, mais bas√©e sur des structures de donn√©es modernes: vecteurs et cartes de hachage. Ces structures de donn√©es ont une efficacit√© de mise en cache et interagissent bien avec les processeurs modernes, pour lesquels il n'est pas souhaitable de travailler avec de petits n≈ìuds. De telles structures peuvent √™tre utilis√©es en C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment construire un vecteur immunitaire? Au c≈ìur de toute structure, m√™me √† distance ressemblant √† un vecteur, il doit y avoir un tableau. Mais la baie n'a pas de partage structurel. Pour modifier un √©l√©ment du tableau, sans perdre la propri√©t√© de persistance, vous devez copier le tableau entier. Afin de ne pas faire cela, le tableau peut √™tre divis√© en morceaux s√©par√©s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, lors de la mise √† jour d'un √©l√©ment vectoriel, nous devons copier une seule pi√®ce, et non le vecteur entier. Mais ces √©l√©ments eux-m√™mes ne sont pas une structure de donn√©es; ils doivent √™tre combin√©s d'une mani√®re ou d'une autre. Mettez-les dans un autre tableau. Une fois de plus, le probl√®me se pose que la matrice peut √™tre tr√®s grande, puis la recopier prendra trop de temps.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous divisons ce tableau en morceaux, les pla√ßons √† nouveau dans un tableau s√©par√© et r√©p√©tons cette proc√©dure jusqu'√† ce qu'il n'y ait qu'un seul tableau racine. La structure r√©sultante est appel√©e arbre r√©siduel. Cet arbre est d√©crit par la constante M = 2B, c'est-√†-dire le facteur de ramification de l'arbre. Cet indicateur de branche devrait √™tre une puissance de deux, et nous saurons tr√®s bient√¥t pourquoi. Dans l'exemple de la diapositive, des blocs de quatre caract√®res sont utilis√©s, mais en pratique, des blocs de 32 caract√®res sont utilis√©s. Il existe des exp√©riences avec lesquelles vous pouvez trouver la taille de bloc optimale pour une architecture particuli√®re. Cela vous permet d'obtenir le meilleur ratio de partage structurel et de temps d'acc√®s: plus l'arbre est bas, moins le temps d'acc√®s est important.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lisant ceci, les d√©veloppeurs √©crivant en C ++ pensent probablement: mais toutes les structures arborescentes sont tr√®s lentes! Les arbres poussent avec une augmentation du nombre d'√©l√©ments en eux, et √† cause de cela, les temps d'acc√®s sont d√©grad√©s. C'est pourquoi les programmeurs pr√©f√®rent </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, plut√¥t que </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Je m'empresse de vous rassurer: notre arbre pousse tr√®s lentement. Un vecteur contenant toutes les valeurs possibles d'un entier 32 bits n'a que 7 niveaux de haut. Il peut √™tre d√©montr√© exp√©rimentalement qu'avec cette taille de donn√©es, le rapport du cache au volume de chargement affecte consid√©rablement les performances que la profondeur de l'arborescence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment s'effectue l'acc√®s √† un √©l√©ment d'une arborescence. Supposons que vous deviez passer √† l'√©l√©ment 17. Nous prenons une repr√©sentation binaire de l'index et la divisons en groupes de la taille d'un facteur de branchement.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans chaque groupe, nous utilisons la valeur binaire correspondante et descendons ainsi l'arbre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons ensuite que nous devons modifier cette structure de donn√©es, c'est-√†-dire ex√©cuter la m√©thode </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, vous devez d'abord copier le bloc dans lequel se trouve l'√©l√©ment, puis copier chaque n≈ìud interne sur le chemin de l'√©l√©ment. D'une part, beaucoup de donn√©es doivent √™tre copi√©es, mais en m√™me temps une partie importante de ces donn√©es est commune, cela compense leur volume. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, il existe une structure de donn√©es beaucoup plus ancienne qui est tr√®s similaire √† celle que j'ai d√©crite. Ce sont des pages de m√©moire avec une arborescence de tableaux de pages. Sa gestion s'effectue √©galement par appel </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons d'am√©liorer notre structure de donn√©es. Supposons que nous devons connecter deux vecteurs. La structure de donn√©es d√©crite jusqu'√† pr√©sent pr√©sente les m√™mes limites </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'elle a des cellules vides dans sa partie la plus √† droite. La structure √©tant parfaitement √©quilibr√©e, ces cellules vides ne peuvent pas se trouver au milieu de l'arbre. Par cons√©quent, s'il y a un deuxi√®me vecteur que nous voulons combiner avec le premier, nous devrons copier les √©l√©ments dans des cellules vides, ce qui cr√©era des cellules vides dans le deuxi√®me vecteur, et √† la fin, nous devrons copier le deuxi√®me vecteur entier. Une telle op√©ration a une complexit√© de calcul O (n), o√π n est la taille du deuxi√®me vecteur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous essaierons d'obtenir un meilleur r√©sultat. Il existe une version modifi√©e de notre structure de donn√©es appel√©e arbre √©quilibr√© radix d√©tendu. Dans cette structure, les n≈ìuds qui ne sont pas sur le chemin le plus √† gauche peuvent avoir des cellules vides. Par cons√©quent, dans de tels n≈ìuds incomplets (ou d√©tendus), il est n√©cessaire de calculer la taille du sous-arbre. Vous pouvez maintenant effectuer une op√©ration de jointure complexe mais logarithmique. Cette op√©ration de complexit√© temporelle constante est O (log (32)). Les arbres √©tant peu profonds, le temps d'acc√®s est constant, quoique relativement long. En raison du fait que nous avons une telle op√©ration d'union, une version d√©tendue de cette structure de donn√©es est appel√©e confluente: en plus d'√™tre persistante, et vous pouvez la bifurquer, deux de ces structures peuvent √™tre combin√©es en une seule.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'exemple avec lequel nous avons travaill√© jusqu'√† pr√©sent, la structure des donn√©es est tr√®s soign√©e, mais dans la pratique, les impl√©mentations dans Clojure et d'autres langages fonctionnels sont diff√©rentes. Ils cr√©ent des conteneurs pour chaque valeur, c'est-√†-dire que chaque √©l√©ment du vecteur se trouve dans une cellule distincte, et les n≈ìuds terminaux contiennent des pointeurs vers ces √©l√©ments. Mais cette approche est extr√™mement inefficace, en C ++ ne place g√©n√©ralement pas toutes les valeurs dans un conteneur. Par cons√©quent, il serait pr√©f√©rable que ces √©l√©ments soient situ√©s directement dans les n≈ìuds. Un autre probl√®me se pose alors: diff√©rents √©l√©ments ont des tailles diff√©rentes. Si l'√©l√©ment a la m√™me taille que le pointeur, notre structure ressemblera √† celle illustr√©e ci-dessous:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si les √©l√©ments sont volumineux, la structure de donn√©es perd les propri√©t√©s que nous avons mesur√©es (temps d'acc√®s O (log (32) ()), car la copie de l'une des feuilles prend maintenant plus de temps. Par cons√©quent, j'ai modifi√© cette structure de donn√©es de sorte que lorsque la taille augmente le nombre d'√©l√©ments qu'il contient a diminu√© le nombre de ces √©l√©ments dans les n≈ìuds foliaires.Au contraire, si les √©l√©ments sont petits, ils peuvent d√©sormais s'adapter davantage.La nouvelle version de l'arbre est appel√©e arbre √©quilibr√© radix incorpor√©.Elle n'est pas d√©crite par une constante, mais par deux: l'un d'eux d√©crit n≈ìuds internes, et le second - feuillu. L'impl√©mentation de l'arbre en C ++ permet de calculer la taille optimale de l'√©l√©ment feuille en fonction de la taille des pointeurs et des √©l√©ments eux-m√™mes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre arbre fonctionne d√©j√† assez bien, mais il peut encore √™tre am√©lior√©. Jetez un oeil √† une fonction similaire √† une fonction </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il prend une entr√©e </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, s'ex√©cute </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin du vecteur pour chaque entier entre </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et renvoie ce qui s'est pass√©. Tout est en ordre avec l'exactitude de cette fonction, mais cela fonctionne de mani√®re inefficace. Chaque appel </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copie inutilement le bloc le plus √† gauche: l'appel suivant pousse un autre √©l√©ment et la copie est r√©p√©t√©e √† nouveau et les donn√©es copi√©es par la m√©thode pr√©c√©dente sont supprim√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez essayer une autre impl√©mentation de cette fonction, dans laquelle nous abandonnons la persistance au sein de la fonction. Peut √™tre utilis√© </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec une API mutable compatible avec l'API standard </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Au sein d'une telle fonction, chaque appel </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change la structure des donn√©es.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette impl√©mentation est plus efficace et vous permet de r√©utiliser de nouveaux √©l√©ments sur le bon chemin. √Ä la fin de la fonction, un appel </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est effectu√© qui renvoie immuable </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Les effets secondaires possibles restent invisibles de l'ext√©rieur de la fonction. L'original </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©tait et reste immuable, seules les donn√©es cr√©√©es √† l'int√©rieur de la fonction sont modifi√©es. Comme je l'ai dit, un avantage important de cette approche est que vous pouvez utiliser </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des algorithmes standard qui n√©cessitent des API mutables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un autre exemple.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction n'accepte pas et retourne </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais une cha√Æne d'appel est ex√©cut√©e √† l'int√©rieur </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ici, comme dans l'exemple pr√©c√©dent, une copie inutile √† l'int√©rieur de l'appel peut se produire </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Notez que la premi√®re valeur qui est ex√©cut√©e </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est la valeur nomm√©e et le reste est une valeur r, c'est-√†-dire des liens anonymes. Si vous utilisez le comptage de r√©f√©rences, la m√©thode </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut faire r√©f√©rence √† des compteurs de r√©f√©rence pour les n≈ìuds auxquels la m√©moire est allou√©e dans l'arborescence. Et dans le cas de la valeur r, si le nombre de liens est un, il devient clair qu'aucune autre partie du programme n'acc√®de √† ces n≈ìuds. Ici, les performances sont exactement les m√™mes que dans le cas avec </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ‚üµ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, pour aider le compilateur, nous pouvons l'ex√©cuter </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est utilis√© nulle part ailleurs dans la fonction. Nous avions un avantage important, qui n'√©tait pas dans la </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variante: si nous transmettons la valeur retourn√©e d'un autre say_hi √† la fonction say_hi, alors il n'y aura pas de copies suppl√©mentaires. Dans le cas de c, </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il existe des limites auxquelles une copie excessive peut se produire. En d'autres termes, nous avons une structure de donn√©es persistante et immuable, dont les performances d√©pendent de la quantit√© r√©elle d'acc√®s partag√© lors de l'ex√©cution. S'il n'y a pas de partage, les performances seront les m√™mes que celles d'une structure de donn√©es mutable. Il s'agit d'une propri√©t√© extr√™mement importante. L'exemple que je vous ai d√©j√† montr√© ci-dessus peut √™tre r√©√©crit avec une m√©thode </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'√† pr√©sent, nous avons parl√© de vecteurs, et en plus d'eux, il y a aussi des cartes de hachage. Ils sont d√©di√©s √† un rapport tr√®s utile de Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Saint Graal. Un tri mapp√© de tableau de hachage pour C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il d√©crit des tables de hachage impl√©ment√©es sur la base des m√™mes principes que je viens de parler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suis s√ªr que beaucoup d'entre vous ont des doutes sur les performances de ces structures. Fonctionnent-ils rapidement dans la pratique? J'ai fait de nombreux tests, et en bref ma r√©ponse est oui. Si vous voulez en savoir plus sur les r√©sultats des tests, ils sont publi√©s dans mon article pour la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conf√©rence internationale de programmation fonctionnelle 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, je pense qu'il vaut mieux discuter non pas de valeurs absolues, mais de l'effet que cette structure de donn√©es a sur le syst√®me dans son ensemble. </font><font style="vertical-align: inherit;">Bien s√ªr, la mise √† jour de notre vecteur est plus lente car vous devez copier plusieurs blocs de donn√©es et allouer de la m√©moire pour d'autres donn√©es. </font><font style="vertical-align: inherit;">Mais le contournement de notre vecteur s'effectue presque √† la m√™me vitesse qu'un vecteur normal. </font><font style="vertical-align: inherit;">Il √©tait tr√®s important pour moi d'y parvenir, car la lecture des donn√©es est effectu√©e beaucoup plus souvent que leur modification.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, en raison de la mise √† jour plus lente, il n'est pas n√©cessaire de copier quoi que ce soit, seule la structure des donn√©es est copi√©e. </font><font style="vertical-align: inherit;">Par cons√©quent, le temps consacr√© √† la mise √† jour du vecteur est, pour ainsi dire, amorti pour toutes les copies effectu√©es dans le syst√®me. </font><font style="vertical-align: inherit;">Par cons√©quent, si vous appliquez cette structure de donn√©es dans une architecture similaire √† celle que j'ai d√©crite au d√©but du rapport, les performances augmenteront consid√©rablement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne serai pas infond√© et d√©montrerai ma structure de donn√©es √† l'aide d'un exemple. </font><font style="vertical-align: inherit;">J'ai √©crit un petit √©diteur de texte. </font><font style="vertical-align: inherit;">Il s'agit d'un outil interactif appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans lequel les documents sont repr√©sent√©s par des vecteurs immuables. </font><font style="vertical-align: inherit;">J'ai une copie de la totalit√© de la Wikip√©dia en esp√©ranto sur mon disque, elle p√®se 1 gigaoctet (au d√©but, je voulais t√©l√©charger la version anglaise, mais elle est trop grande). </font><font style="vertical-align: inherit;">Quel que soit l'√©diteur de texte que vous utilisez, je suis s√ªr qu'il n'aimera pas ce fichier. </font><font style="vertical-align: inherit;">Et lorsque vous t√©l√©chargez ce fichier dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous pouvez imm√©diatement le modifier, car le t√©l√©chargement est asynchrone. </font><font style="vertical-align: inherit;">La navigation dans les fichiers fonctionne, rien ne se bloque, non </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pas de synchronisation. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, le fichier t√©l√©charg√© prend 20 millions de lignes de code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de consid√©rer les propri√©t√©s les plus importantes de cet outil, pr√™tons attention √† un d√©tail amusant. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but de la ligne, surlign√©e en blanc au bas de l'image, vous voyez deux tirets. Cette interface utilisateur est probablement famili√®re aux utilisateurs d'emacs; les traits d'union signifient que le document n'a √©t√© modifi√© d'aucune fa√ßon. Si vous apportez des modifications, des ast√©risques s'affichent √† la place des tirets. Mais, contrairement √† d'autres √©diteurs, si vous </font><font style="vertical-align: inherit;">supprimez ces modifications </font><font style="vertical-align: inherit;">dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ne les annulez pas, supprimez-les simplement), les traits d'union r√©appara√Ætront √† la place des ast√©risques, car </font><font style="vertical-align: inherit;">toutes les versions pr√©c√©dentes du texte sont enregistr√©es </font><font style="vertical-align: inherit;">dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gr√¢ce √† cela, un indicateur sp√©cial n'est pas n√©cessaire pour indiquer si le document a √©t√© modifi√©: la pr√©sence de modifications est d√©termin√©e par comparaison avec le document d'origine.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez une autre propri√©t√© int√©ressante de l'outil: copiez le texte entier et collez-le plusieurs fois au milieu du texte existant. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, cela se produit instantan√©ment. </font><font style="vertical-align: inherit;">La jonction de vecteurs ici est une op√©ration logarithmique, et le logarithme de plusieurs millions n'est pas une op√©ration aussi longue. </font><font style="vertical-align: inherit;">Si vous essayez d'enregistrer cet √©norme document sur votre disque dur, cela prendra beaucoup plus de temps, car le texte n'est plus pr√©sent√© comme un vecteur obtenu √† partir de la version pr√©c√©dente de ce vecteur. </font><font style="vertical-align: inherit;">Lors de l'enregistrement sur le disque, la s√©rialisation se produit, donc la persistance est perdue.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour √† une architecture bas√©e sur la valeur</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commen√ßons par la fa√ßon dont vous ne pouvez pas revenir √† cette architecture: en utilisant le contr√¥leur, le mod√®le et la vue de style Java habituels, qui sont le plus souvent utilis√©s pour les applications interactives en C ++. Il n'y a rien de mal avec eux, mais ils ne conviennent pas √† notre probl√®me. D'une part, le mod√®le Model-View-Controller permet la s√©paration des t√¢ches, mais d'autre part, chacun de ces √©l√©ments est un objet, √† la fois d'un point de vue orient√© objet et du point de vue de C ++, c'est-√†-dire que ce sont des zones de m√©moire avec mutable √©tat. View conna√Æt Model; ce qui est bien pire - le mod√®le conna√Æt indirectement la vue, car il y a presque certainement un rappel par lequel la vue est notifi√©e lorsque le mod√®le change. M√™me avec la meilleure impl√©mentation de principes orient√©s objet, nous obtenons beaucoup de d√©pendances mutuelles.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au fur et √† mesure que l'application se d√©veloppe et que de nouveaux mod√®les, contr√¥leurs et vues sont ajout√©s, une situation se produit lorsque, pour modifier un segment du programme, vous devez conna√Ætre toutes les parties qui lui sont associ√©es, toutes les vues qui re√ßoivent des alertes </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. En cons√©quence, tout le monde le monstre familier des p√¢tes commence √† scruter ces d√©pendances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre architecture est-elle possible? Il existe une approche alternative au mod√®le Model-View-Controller appel√©e ¬´Architecture de flux de donn√©es unidirectionnelle¬ª. Ce concept n'a pas √©t√© invent√© par moi, il est utilis√© assez souvent dans le d√©veloppement web. Sur Facebook, cela s'appelle l'architecture Flux, mais en C ++, elle n'est pas encore appliqu√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les √©l√©ments d'une telle architecture nous sont d√©j√† familiers: action, mod√®le et vue, mais la signification des blocs et des fl√®ches est diff√©rente. Les blocs sont des valeurs, pas des objets et pas des r√©gions avec des √©tats mutables. Cela s'applique m√™me √† View. De plus, les fl√®ches ne sont pas des liens, car sans objets il ne peut y avoir de liens. Ici, les fl√®ches sont des fonctions. Entre Action et Mod√®le, il existe une fonction de mise √† jour qui accepte le Mod√®le actuel, c'est-√†-dire l'√©tat actuel du monde, et Action, qui est une repr√©sentation d'un √©v√©nement, par exemple, un clic de souris, ou un √©v√©nement d'un autre niveau d'abstraction, par exemple, l'insertion d'un √©l√©ment ou d'un symbole dans un document. La fonction de mise √† jour met √† jour le document et renvoie le nouvel √©tat du monde. Le mod√®le se connecte au rendu de la fonction Vue, qui prend le mod√®le et renvoie la vue. Cela n√©cessite un cadre dans lequel View peut √™tre repr√©sent√© sous forme de valeurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le d√©veloppement Web, React fait cela, mais en C ++, il n'y a encore rien de tel, m√™me si qui sait, s'il y a des gens qui veulent me payer pour √©crire quelque chose comme √ßa, cela pourrait bient√¥t appara√Ætre. En attendant, vous pouvez utiliser l'API en mode imm√©diat, dans laquelle la fonction de dessin vous permet de cr√©er une valeur comme effet secondaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, la vue doit avoir un m√©canisme qui permet √† l'utilisateur ou √† d'autres sources d'√©v√©nements d'envoyer une action. Il existe un moyen simple de mettre en ≈ìuvre cela, il est pr√©sent√© ci-dessous:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'exception de l'enregistrement et du chargement asynchrones, c'est le code utilis√© dans l'√©diteur qui vient d'√™tre pr√©sent√©. Il y a un objet ici </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vous permet de lire et d'√©crire √† partir de la ligne de commande. De plus, </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est la valeur de Model, il stocke tout l'√©tat de l'application. Comme vous pouvez le voir en haut de l'√©cran, il existe une fonction qui renvoie une nouvelle version </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le cycle √† l'int√©rieur de la fonction est ex√©cut√© jusqu'√† ce que l'application doive se fermer, c'est-√†-dire jusqu'√† ce que </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans la boucle, un nouvel √©tat est trac√©, puis l'√©v√©nement suivant est demand√©. Enfin, l'√©tat est stock√© dans une variable locale </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la boucle recommence. Ce code pr√©sente un avantage tr√®s important: une seule variable mutable existe tout au long de l'ex√©cution du programme, c'est un objet </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les d√©veloppeurs de Clojure appellent cette architecture √† atome unique: il y a un seul point √† travers l'application enti√®re √† travers lequel toutes les modifications sont apport√©es. </font><font style="vertical-align: inherit;">La logique d'application ne participe en aucune fa√ßon √† la mise √† jour de ce point, ce qui en fait un cycle sp√©cialement con√ßu. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, la logique d'application est enti√®rement constitu√©e de fonctions pures, comme des fonctions </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette approche de l'√©criture d'applications, la fa√ßon de penser les logiciels √©volue. </font><font style="vertical-align: inherit;">Le travail commence maintenant non pas avec le diagramme UML des interfaces et des op√©rations, mais avec les donn√©es elles-m√™mes. </font><font style="vertical-align: inherit;">Il existe certaines similitudes avec la conception orient√©e donn√©es. </font><font style="vertical-align: inherit;">Certes, la conception orient√©e donn√©es est g√©n√©ralement utilis√©e pour obtenir des performances maximales, ici, en plus de la vitesse, nous nous effor√ßons de simplicit√© et d'exactitude. </font><font style="vertical-align: inherit;">L'accent est l√©g√®rement diff√©rent, mais il existe d'importantes similitudes dans la m√©thodologie.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessus sont les principaux types de donn√©es de notre application. Le corps principal de l'application se compose de </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est flex_vector, et flex_vector est </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui pour lequel vous pouvez effectuer une op√©ration de jointure. Vient ensuite </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le vecteur dans lequel il est stock√© </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme vous pouvez le voir, il s'agit d'une repr√©sentation tr√®s simple du texte. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stock√© √† l'aide </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de qui a un nom, c'est-√†-dire une adresse dans le syst√®me de fichiers, et en fait </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√© un autre type, simple mais tr√®s utile: </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'un conteneur √† √©l√©ment unique. Il vous permet de placer un tas et de d√©placer un objet, la copie pouvant √™tre trop gourmande en ressources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre type important: </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sur la base de ce type, une fonction d'annulation est active. Il contient un document (sous la forme</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et la position du curseur (coord). Cela vous permet de ramener le curseur √† la position dans laquelle il se trouvait lors de l'√©dition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type suivant est </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. C'est un terme de vim et emacs, car les documents ouverts y sont appel√©s. Il </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a un fichier √† partir duquel le texte a √©t√© t√©l√©charg√©, ainsi que le contenu du texte - cela vous permet de v√©rifier les modifications dans le document. Pour mettre en √©vidence une partie du texte, une variable facultative </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indique le d√©but de la s√©lection. Le vecteur </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est l'histoire du texte. Notez que nous n'utilisons pas le mod√®le d'√©quipe; l'historique se compose uniquement d'√©tats. Enfin, si l'annulation vient de se terminer, nous avons besoin d'un indice de position dans l'historique de l'√©tat </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type suivant: </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il contient un document ouvert (tampon), </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les raccourcis clavier, ainsi qu'un vecteur de </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour le presse-papiers et un autre vecteur pour les messages affich√©s en bas de l'√©cran. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, dans la premi√®re version de l'application, il n'y aura qu'un seul thread et un type d'action qui prend en entr√©e </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tr√®s probablement, beaucoup d'entre vous r√©fl√©chissent d√©j√† √† la fa√ßon de mettre en ≈ìuvre ces op√©rations. </font><font style="vertical-align: inherit;">Si elles sont prises par valeur et retourn√©es par valeur, alors dans la plupart des cas, les op√©rations sont assez simples. </font><font style="vertical-align: inherit;">Le code de mon √©diteur de texte est publi√© sur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous pouvez donc voir √† quoi il ressemble r√©ellement. </font><font style="vertical-align: inherit;">Maintenant, je m'attarderai en d√©tail uniquement sur le code qui impl√©mente la fonction d'annulation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annuler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âcrire correctement une annulation sans l'infrastructure appropri√©e n'est pas si simple. Dans mon √©diteur, je l'ai impl√©ment√© sur le mod√®le d'emacs, donc d'abord quelques mots sur ses principes de base. La commande de retour manque ici, et gr√¢ce √† cela, vous ne pouvez pas perdre de travail. Si un retour est n√©cessaire, toute modification est apport√©e au texte, puis toutes les actions d'annulation font √† nouveau partie de l'historique d'annulation.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce principe est d√©crit ci-dessus. Le losange rouge montre ici une position dans l'histoire: si une annulation n'a tout simplement pas √©t√© effectu√©e, le losange rouge est toujours √† la toute fin. Si vous annulez, le losange ram√®nera un √©tat en arri√®re, mais en m√™me temps, un autre √©tat sera ajout√© √† la fin de la file d'attente - le m√™me que celui que l'utilisateur voit actuellement (S3). Si vous annulez √† nouveau et revenez √† l'√©tat S2, l'√©tat S2 est ajout√© √† la fin de la file d'attente. Si maintenant l'utilisateur fait une sorte de changement, il sera ajout√© √† la fin de la file d'attente en tant que nouvel √©tat de S5, et un losange y sera d√©plac√©. D√©sormais, lors de l'annulation des actions pass√©es, les actions d'annulation pr√©c√©dentes d√©fileront en premier. Pour impl√©menter un tel syst√®me d'annulation, le code suivant suffit:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a deux actions, </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectu√© au cours de toute op√©ration. C'est tr√®s pratique car nous n'avons pas besoin de savoir si une modification du document a eu lieu. La fonction est transparente pour la logique d'application. Apr√®s toute action, la fonction v√©rifie si le document a chang√©. Si un changement s'est produit, le </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenu et la position du curseur pour sont </font><font style="vertical-align: inherit;">ex√©cut√©s </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si l'action n'a pas conduit √† une modification </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(c'est-√†-dire que l'entr√©e re√ßue n'est </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas provoqu√©e par l'action d'annulation), alors </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une valeur est affect√©e </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si n√©cessaire </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous v√©rifions </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. S'il n'a pas de sens, nous le consid√©rons </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin de l'histoire. Si l'historique d'annulation n'est pas vide (c.-√†-d.</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas au tout d√©but de l'histoire), l'annulation est effectu√©e. </font><font style="vertical-align: inherit;">Le contenu et le curseur actuels sont remplac√©s et modifi√©s </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'irr√©vocabilit√© d'une op√©ration d'annulation est obtenue par une fonction </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui est √©galement appel√©e pendant l'op√©ration d'annulation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc une op√©ration </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui prend 10 lignes de code et qui, sans modifications (ou avec des modifications minimes), peut √™tre utilis√©e dans presque toutes les autres applications.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyage dans le temps</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä propos du voyage dans le temps. Comme nous le verrons maintenant, il s'agit d'un sujet li√© √† l'annulation. Je vais d√©montrer le travail d'un framework qui ajoutera des fonctionnalit√©s utiles √† toute application avec une architecture similaire. Le cadre ici est appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette version d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inclut des fonctionnalit√©s de d√©bogage. √Ä partir du navigateur, vous pouvez maintenant ouvrir le d√©bogueur, dans lequel vous pouvez examiner l'√©tat de l'application.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons que la derni√®re action a √©t√© redimensionn√©e, car j'ai ouvert une nouvelle fen√™tre et mon gestionnaire de fen√™tres a automatiquement redimensionn√© la fen√™tre d√©j√† ouverte. Bien s√ªr, pour la s√©rialisation automatique en JSON, j'ai d√ª ajouter une annotation pour struct √† partir de la biblioth√®que de r√©flexion sp√©ciale. Mais le reste du syst√®me est assez universel, il peut √™tre connect√© √† n'importe quelle application similaire. Maintenant, dans le navigateur, vous pouvez voir toutes les actions termin√©es. Bien s√ªr, il y a un √©tat initial qui n'a aucune action. Il s'agit de l'√©tat qui √©tait avant le t√©l√©chargement. De plus, en double-cliquant, je peux ramener l'application √† son √©tat pr√©c√©dent. Il s'agit d'un outil de d√©bogage tr√®s utile qui vous permet de suivre l'occurrence d'un dysfonctionnement dans l'application.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous √™tes int√©ress√©, vous pouvez √©couter mon rapport sur CPPCON 19, Les valeurs les plus pr√©cieuses, l√† j'examinerai ce d√©bogueur en d√©tail. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, l'architecture bas√©e sur les valeurs y est discut√©e plus en d√©tail. </font><font style="vertical-align: inherit;">Dans ce document, je vous explique √©galement comment mettre en ≈ìuvre des actions et les organiser de mani√®re hi√©rarchique. </font><font style="vertical-align: inherit;">Cela garantit la modularit√© du syst√®me et √©limine la n√©cessit√© de tout garder dans une seule grande fonction de mise √† jour. </font><font style="vertical-align: inherit;">En outre, ce rapport parle de t√©l√©chargements de fichiers asynchrones et multithreads. </font><font style="vertical-align: inherit;">Il existe une autre version de ce rapport dans laquelle une demi-heure de mat√©riel suppl√©mentaire est constitu√©e de structures de donn√©es immuables postmodernes.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sumer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense qu'il est temps de faire le point. Je vais citer Andy Wingo - c'est un excellent d√©veloppeur, il a consacr√© beaucoup de temps √† la V8 et aux compilateurs en g√©n√©ral, enfin il est engag√© dans le support de Guile, impl√©mentant Scheme for GNU. R√©cemment, il a √©crit sur son Twitter: ¬´Pour r√©aliser une l√©g√®re acc√©l√©ration du programme, nous mesurons chaque petit changement et ne laissons que ceux qui donnent un r√©sultat positif. Mais nous r√©alisons vraiment une acc√©l√©ration significative, √† l'aveugle, en investissant beaucoup d'efforts, sans avoir 100% de confiance et guid√©s uniquement par l'intuition. Quelle √©trange dichotomie. ¬ª</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il me semble que les d√©veloppeurs C ++ r√©ussissent dans le premier genre. </font><font style="vertical-align: inherit;">Donnez-nous un syst√®me ferm√©, et nous, arm√©s de nos outils, nous en retirerons tout ce qui est possible. </font><font style="vertical-align: inherit;">Mais dans le deuxi√®me genre, nous n'avons pas l'habitude de travailler. </font><font style="vertical-align: inherit;">Bien entendu, la deuxi√®me approche est plus risqu√©e et conduit souvent √† un gaspillage de gros efforts. </font><font style="vertical-align: inherit;">D'autre part, en r√©√©crivant compl√®tement un programme, il peut souvent √™tre rendu plus facile et plus rapide. </font><font style="vertical-align: inherit;">J'esp√®re avoir r√©ussi √† vous convaincre d'essayer au moins cette deuxi√®me approche.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente a pris la parole lors de la conf√©rence C ++ Russia 2019 √† Moscou et a parl√© des structures de donn√©es qui vous permettent de faire des choses int√©ressantes. </font><font style="vertical-align: inherit;">Une partie de la magie de ces structures r√©side dans l'√©lision de la copie - c'est ce dont </font><font style="vertical-align: inherit;">Anton Polukhin et Roman Rusyaev </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parleront</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors de la prochaine conf√©rence </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Suivez les mises </font><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">jour du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur le site.</font></font></blockquote></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr487090/index.html">Un nouveau niveau d'optimisation Windows</a></li>
<li><a href="../fr487092/index.html">Mod√©lisation des processus m√©tiers dans le cadre d'un projet d'impl√©mentation d'un syst√®me ERP</a></li>
<li><a href="../fr487094/index.html">√âv√©nements de retraitement re√ßus de Kafka</a></li>
<li><a href="../fr487096/index.html">Extraits. Comment faciliter le processus de travail avec la documentation</a></li>
<li><a href="../fr487098/index.html">Dessiner avec des fourmis: images proc√©durales utilisant des algorithmes d'optimisation des colonies de fourmis</a></li>
<li><a href="../fr487106/index.html">Contr√¥le RunUO de l'analyseur PVS-Studio</a></li>
<li><a href="../fr487108/index.html">Profil de joueur mobile: recherche MyTracker</a></li>
<li><a href="../fr487110/index.html">Slurm SRE. Une exp√©rience compl√®te avec des experts de Booking.com et de Google.com</a></li>
<li><a href="../fr487112/index.html">Edge of Madness: The Basic Circle</a></li>
<li><a href="../fr487116/index.html">Pourquoi Discord passe de Go √† Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>