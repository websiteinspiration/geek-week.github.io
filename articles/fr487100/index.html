<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍥 👨🏻‍🍳 🗣️ Structures de données immuables à la pointe de la technologie 🖖🏽 🚓 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis des années, des experts en C ++ discutent de la sémantique des valeurs, de l'immuabilité et du partage des ressources par la communication. À p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Structures de données immuables à la pointe de la technologie</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis des années, des experts en C ++ discutent de la sémantique des valeurs, de l'immuabilité et du partage des ressources par la communication. </font><font style="vertical-align: inherit;">À propos d'un nouveau monde sans mutex ni races, sans modèles de commandement et d'observation. </font><font style="vertical-align: inherit;">En fait, tout n'est pas si simple. </font><font style="vertical-align: inherit;">Le principal problème réside toujours dans nos structures de données.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les structures de données immuables ne changent pas leurs valeurs. Pour faire quelque chose avec eux, vous devez créer de nouvelles valeurs. Les anciennes valeurs restent au même endroit, donc elles peuvent être lues à partir de différents flux sans problèmes et verrous. Par conséquent, les ressources peuvent être partagées de manière plus rationnelle et ordonnée, car les anciennes et les nouvelles valeurs peuvent utiliser des données communes. Grâce à cela, ils sont beaucoup plus rapides à comparer les uns avec les autres et stockent de manière compacte l'historique des opérations avec la possibilité d'annulation. Tout cela s'intègre parfaitement sur les systèmes multi-threads et interactifs: de telles structures de données simplifient l'architecture des applications bureautiques et permettent aux services de mieux évoluer. Les structures immuables sont le secret du succès de Clojure et Scala, et même la communauté JavaScript en profite désormais, car elles ont la bibliothèque Immutable.js,écrit dans les entrailles de la société Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la coupe - vidéo et traduction du rapport </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la conférence C ++ Russia 2019 Moscou. </font><font style="vertical-align: inherit;">Juan parle d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une bibliothèque de structures immuables pour C ++. </font><font style="vertical-align: inherit;">Dans la poste:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avantages architecturaux de l'immunité;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">création d'un type de vecteur persistant efficace basé sur des arbres RRB;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analyse de l'architecture sur l'exemple d'un simple éditeur de texte.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tragédie de l'architecture basée sur la valeur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre l'importance des structures de données immuables, nous discutons de la sémantique des valeurs. C'est une caractéristique très importante du C ++, je le considère comme l'un des principaux avantages de ce langage. Pour tout cela, il est très difficile d'utiliser la sémantique des valeurs comme on le souhaiterait. Je crois que c'est la tragédie de l'architecture basée sur la valeur, et la route vers cette tragédie est pavée de bonnes intentions. Supposons que nous devions écrire un logiciel interactif basé sur un modèle de données avec une représentation d'un document modifiable par l'utilisateur. Lorsque l' </font><font style="vertical-align: inherit;">architecture basée sur les valeurs au cœur de ce modèle utilise des </font><font style="vertical-align: inherit;">types de valeurs simples et pratiques qui existent déjà dans la langue: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La logique d'application est créée à partir de fonctions qui prennent les documents par valeur et renvoient une nouvelle version d'un document par valeur. Ce document peut changer à l'intérieur de la fonction (comme cela se produit ci-dessous), mais la sémantique des valeurs en C ++, appliquée à l'argument par valeur et au type de retour par valeur, garantit qu'il n'y a pas d'effets secondaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonctionnalité est très facile à analyser et à tester. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque nous travaillons avec des valeurs, nous allons essayer d'implémenter l'annulation de l'action. Cela peut être difficile, mais avec notre approche, c'est une tâche triviale: nous avons </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec différents états différentes copies du document.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons également une interface utilisateur et pour garantir sa réactivité, le mappage de l'interface utilisateur doit être effectué dans un thread distinct. Le document est envoyé à un autre flux par message, et l'interaction a également lieu sur la base de messages, et non via le partage d'état à l'aide </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque la copie est reçue par le deuxième flux, vous pouvez y effectuer toutes les opérations nécessaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'enregistrement d'un document sur le disque est souvent très lent, surtout si le document est volumineux. Par conséquent, l'utilisation de </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette opération est effectuée de manière asynchrone. Nous utilisons un lambda, mettons un signe égal à l'intérieur pour avoir une copie, et maintenant vous pouvez enregistrer sans autres types de synchronisation primitifs.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, supposons que nous ayons également un flux de contrôle sonore. Comme je l'ai dit, j'ai beaucoup travaillé avec des logiciels de musique, et le son est une autre représentation de notre document, il doit être dans un flux séparé. Par conséquent, une copie du document est également requise pour ce flux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, nous avons obtenu un schéma très beau, mais pas trop réaliste. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il doit constamment copier des documents, l'historique des actions pour l'annulation prend des gigaoctets, et pour chaque rendu de l'interface utilisateur, vous devez faire une copie complète du document. En général, toutes les interactions sont trop coûteuses.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que fait le développeur C ++ dans cette situation? Au lieu d'accepter un document par valeur, la logique d'application accepte désormais un lien vers le document et le met à jour si nécessaire. Dans ce cas, vous n'avez rien à retourner. Mais maintenant, il ne s'agit pas de valeurs, mais d'objets et d'emplacements. Cela crée de nouveaux problèmes: s'il existe un lien avec l'État avec un accès partagé, vous en avez besoin </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ceci est extrêmement coûteux, il y aura donc une certaine représentation de notre interface utilisateur sous la forme d'une arborescence extrêmement complexe à partir de divers widgets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous ces éléments devraient recevoir des mises à jour lorsqu'un document change, donc un mécanisme de mise en file d'attente est nécessaire pour les signaux de changement. De plus, l'historique du document n'est plus un ensemble d'états, ce sera une mise en œuvre du modèle d'équipe. L'opération doit être mise en œuvre deux fois, dans un sens et dans l'autre, et assurez-vous que tout est symétrique. L'enregistrement dans un thread séparé est déjà trop difficile, il faudra donc l'abandonner. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les utilisateurs sont déjà habitués à l'image du sablier, donc ça va s'ils attendent un peu. Une autre chose fait peur - le monstre de pâtes gouverne maintenant notre code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À quel moment tout s'est-il dégradé? </font><font style="vertical-align: inherit;">Nous avons très bien conçu notre code, puis nous avons dû faire des compromis à cause de la copie. </font><font style="vertical-align: inherit;">Mais en C ++, la copie est requise pour passer par valeur uniquement pour les données mutables. </font><font style="vertical-align: inherit;">Si l'objet est immuable, alors l'opérateur d'affectation peut être implémenté de sorte qu'il ne copie que le pointeur vers la représentation interne et rien de plus.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez une structure de données qui pourrait nous aider. </font><font style="vertical-align: inherit;">Dans le vecteur ci-dessous, toutes les méthodes sont marquées comme </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">étant immuables. </font><font style="vertical-align: inherit;">À l'exécution </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le vecteur ne se met pas à jour; à la place, un nouveau vecteur est retourné, auquel les données transférées sont ajoutées. </font><font style="vertical-align: inherit;">Malheureusement, nous ne pouvons pas utiliser de crochets avec cette approche en raison de leur définition. </font><font style="vertical-align: inherit;">Au lieu de cela, vous pouvez utiliser la fonction</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie une nouvelle version avec un élément mis à jour. Notre structure de données a maintenant une propriété qui s'appelle la persistance dans la programmation fonctionnelle. Cela ne signifie pas que nous sauvegardons cette structure de données sur le disque dur, mais le fait que lorsqu'il est mis à jour, l'ancien contenu n'est pas supprimé - à la place, une nouvelle fourchette de notre monde est créée, c'est-à-dire la structure. Grâce à cela, nous pouvons comparer les valeurs passées avec le présent - cela se fait à l'aide de deux </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les modifications peuvent désormais être vérifiées directement, elles ne sont plus des propriétés cachées de la structure de données. Cette fonctionnalité est particulièrement utile dans les systèmes interactifs où nous devons constamment modifier les données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre propriété importante est le partage structurel. Maintenant, nous ne copions pas toutes les données pour chaque nouvelle version de la structure de données. Même avec </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes les données ne sont pas copiées, mais seulement une petite partie. Toutes nos fourches ont un accès commun à une vue compacte, proportionnelle au nombre de modifications et non au nombre de copies. Il s'ensuit également que la comparaison est très rapide: si tout est stocké dans un bloc mémoire, dans un pointeur, alors vous pouvez simplement comparer les pointeurs et ne pas examiner les éléments qui s'y trouvent, s'ils sont égaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'un tel vecteur, il me semble, est extrêmement utile, je l'ai implémenté dans une bibliothèque séparée: c'est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - une bibliothèque de structures immuables, un projet open source.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En l'écrivant, je voulais que son utilisation soit familière aux développeurs C ++. </font><font style="vertical-align: inherit;">Il existe de nombreuses bibliothèques qui implémentent les concepts de programmation fonctionnelle en C ++, mais cela donne l'impression que les développeurs écrivent pour Haskell, et non pour C ++. </font><font style="vertical-align: inherit;">Cela crée des inconvénients. </font><font style="vertical-align: inherit;">De plus, j'ai réalisé de bonnes performances. </font><font style="vertical-align: inherit;">Les gens utilisent C ++ lorsque les ressources disponibles sont limitées. </font><font style="vertical-align: inherit;">Enfin, je voulais que la bibliothèque soit personnalisable. </font><font style="vertical-align: inherit;">Cette exigence est liée à l'exigence de performance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A la recherche d'un vecteur magique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la deuxième partie du rapport, nous verrons comment est structuré ce vecteur immuable. La façon la plus simple de comprendre les principes d'une telle structure de données est de commencer par une liste régulière. Si vous êtes un peu familier avec la programmation fonctionnelle (en utilisant Lisp ou Haskell comme exemple), vous savez que les listes sont les structures de données immuables les plus courantes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, supposons que nous avons une liste avec un seul nœud </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lors de l'ajout de nouveaux éléments en haut de la liste, de nouveaux nœuds sont créés, chacun ayant un pointeur sur un nœud existant. Par conséquent, dans l'exemple de la diapositive, nous n'avons pas trois copies d'une liste, mais trois éléments en mémoire, c'est-à-dire </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'ils </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquent des éléments différents. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons également créer une fourchette de réalité, c'est-à-dire créer une nouvelle liste qui a la même fin, mais un début différent.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De telles structures de données sont étudiées depuis longtemps: Chris Okasaki a écrit le travail fondamental des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structures de données purement fonctionnelles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De plus, la structure de données de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proposée par Ralf Hinze et Ross Paterson est très intéressante </font><font style="vertical-align: inherit;">. Mais pour C ++, ces structures de données ne fonctionnent pas bien. Ils utilisent de petits nœuds, et nous savons qu'en C ++, les petits nœuds signifient un manque d'efficacité de la mise en cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, ils s'appuient souvent sur des propriétés que C ++ ne possède pas, comme la paresse. Par conséquent, le travail de Phil Bagwell sur les structures de données immuables nous est beaucoup plus utile - un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> écrit au début des années 2000, ainsi que le travail de Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auteur de Clojure. Rich Hickey a créé une liste, qui n'est en fait pas une liste, mais basée sur des structures de données modernes: vecteurs et cartes de hachage. Ces structures de données ont une efficacité de mise en cache et interagissent bien avec les processeurs modernes, pour lesquels il n'est pas souhaitable de travailler avec de petits nœuds. De telles structures peuvent être utilisées en C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment construire un vecteur immunitaire? Au cœur de toute structure, même à distance ressemblant à un vecteur, il doit y avoir un tableau. Mais la baie n'a pas de partage structurel. Pour modifier un élément du tableau, sans perdre la propriété de persistance, vous devez copier le tableau entier. Afin de ne pas faire cela, le tableau peut être divisé en morceaux séparés.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, lors de la mise à jour d'un élément vectoriel, nous devons copier une seule pièce, et non le vecteur entier. Mais ces éléments eux-mêmes ne sont pas une structure de données; ils doivent être combinés d'une manière ou d'une autre. Mettez-les dans un autre tableau. Une fois de plus, le problème se pose que la matrice peut être très grande, puis la recopier prendra trop de temps.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous divisons ce tableau en morceaux, les plaçons à nouveau dans un tableau séparé et répétons cette procédure jusqu'à ce qu'il n'y ait qu'un seul tableau racine. La structure résultante est appelée arbre résiduel. Cet arbre est décrit par la constante M = 2B, c'est-à-dire le facteur de ramification de l'arbre. Cet indicateur de branche devrait être une puissance de deux, et nous saurons très bientôt pourquoi. Dans l'exemple de la diapositive, des blocs de quatre caractères sont utilisés, mais en pratique, des blocs de 32 caractères sont utilisés. Il existe des expériences avec lesquelles vous pouvez trouver la taille de bloc optimale pour une architecture particulière. Cela vous permet d'obtenir le meilleur ratio de partage structurel et de temps d'accès: plus l'arbre est bas, moins le temps d'accès est important.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lisant ceci, les développeurs écrivant en C ++ pensent probablement: mais toutes les structures arborescentes sont très lentes! Les arbres poussent avec une augmentation du nombre d'éléments en eux, et à cause de cela, les temps d'accès sont dégradés. C'est pourquoi les programmeurs préfèrent </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, plutôt que </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Je m'empresse de vous rassurer: notre arbre pousse très lentement. Un vecteur contenant toutes les valeurs possibles d'un entier 32 bits n'a que 7 niveaux de haut. Il peut être démontré expérimentalement qu'avec cette taille de données, le rapport du cache au volume de chargement affecte considérablement les performances que la profondeur de l'arborescence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment s'effectue l'accès à un élément d'une arborescence. Supposons que vous deviez passer à l'élément 17. Nous prenons une représentation binaire de l'index et la divisons en groupes de la taille d'un facteur de branchement.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans chaque groupe, nous utilisons la valeur binaire correspondante et descendons ainsi l'arbre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons ensuite que nous devons modifier cette structure de données, c'est-à-dire exécuter la méthode </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, vous devez d'abord copier le bloc dans lequel se trouve l'élément, puis copier chaque nœud interne sur le chemin de l'élément. D'une part, beaucoup de données doivent être copiées, mais en même temps une partie importante de ces données est commune, cela compense leur volume. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, il existe une structure de données beaucoup plus ancienne qui est très similaire à celle que j'ai décrite. Ce sont des pages de mémoire avec une arborescence de tableaux de pages. Sa gestion s'effectue également par appel </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons d'améliorer notre structure de données. Supposons que nous devons connecter deux vecteurs. La structure de données décrite jusqu'à présent présente les mêmes limites </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'elle a des cellules vides dans sa partie la plus à droite. La structure étant parfaitement équilibrée, ces cellules vides ne peuvent pas se trouver au milieu de l'arbre. Par conséquent, s'il y a un deuxième vecteur que nous voulons combiner avec le premier, nous devrons copier les éléments dans des cellules vides, ce qui créera des cellules vides dans le deuxième vecteur, et à la fin, nous devrons copier le deuxième vecteur entier. Une telle opération a une complexité de calcul O (n), où n est la taille du deuxième vecteur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous essaierons d'obtenir un meilleur résultat. Il existe une version modifiée de notre structure de données appelée arbre équilibré radix détendu. Dans cette structure, les nœuds qui ne sont pas sur le chemin le plus à gauche peuvent avoir des cellules vides. Par conséquent, dans de tels nœuds incomplets (ou détendus), il est nécessaire de calculer la taille du sous-arbre. Vous pouvez maintenant effectuer une opération de jointure complexe mais logarithmique. Cette opération de complexité temporelle constante est O (log (32)). Les arbres étant peu profonds, le temps d'accès est constant, quoique relativement long. En raison du fait que nous avons une telle opération d'union, une version détendue de cette structure de données est appelée confluente: en plus d'être persistante, et vous pouvez la bifurquer, deux de ces structures peuvent être combinées en une seule.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'exemple avec lequel nous avons travaillé jusqu'à présent, la structure des données est très soignée, mais dans la pratique, les implémentations dans Clojure et d'autres langages fonctionnels sont différentes. Ils créent des conteneurs pour chaque valeur, c'est-à-dire que chaque élément du vecteur se trouve dans une cellule distincte, et les nœuds terminaux contiennent des pointeurs vers ces éléments. Mais cette approche est extrêmement inefficace, en C ++ ne place généralement pas toutes les valeurs dans un conteneur. Par conséquent, il serait préférable que ces éléments soient situés directement dans les nœuds. Un autre problème se pose alors: différents éléments ont des tailles différentes. Si l'élément a la même taille que le pointeur, notre structure ressemblera à celle illustrée ci-dessous:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si les éléments sont volumineux, la structure de données perd les propriétés que nous avons mesurées (temps d'accès O (log (32) ()), car la copie de l'une des feuilles prend maintenant plus de temps. Par conséquent, j'ai modifié cette structure de données de sorte que lorsque la taille augmente le nombre d'éléments qu'il contient a diminué le nombre de ces éléments dans les nœuds foliaires.Au contraire, si les éléments sont petits, ils peuvent désormais s'adapter davantage.La nouvelle version de l'arbre est appelée arbre équilibré radix incorporé.Elle n'est pas décrite par une constante, mais par deux: l'un d'eux décrit nœuds internes, et le second - feuillu. L'implémentation de l'arbre en C ++ permet de calculer la taille optimale de l'élément feuille en fonction de la taille des pointeurs et des éléments eux-mêmes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre arbre fonctionne déjà assez bien, mais il peut encore être amélioré. Jetez un oeil à une fonction similaire à une fonction </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il prend une entrée </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, s'exécute </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la fin du vecteur pour chaque entier entre </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et renvoie ce qui s'est passé. Tout est en ordre avec l'exactitude de cette fonction, mais cela fonctionne de manière inefficace. Chaque appel </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copie inutilement le bloc le plus à gauche: l'appel suivant pousse un autre élément et la copie est répétée à nouveau et les données copiées par la méthode précédente sont supprimées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez essayer une autre implémentation de cette fonction, dans laquelle nous abandonnons la persistance au sein de la fonction. Peut être utilisé </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec une API mutable compatible avec l'API standard </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Au sein d'une telle fonction, chaque appel </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change la structure des données.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette implémentation est plus efficace et vous permet de réutiliser de nouveaux éléments sur le bon chemin. À la fin de la fonction, un appel </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est effectué qui renvoie immuable </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Les effets secondaires possibles restent invisibles de l'extérieur de la fonction. L'original </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">était et reste immuable, seules les données créées à l'intérieur de la fonction sont modifiées. Comme je l'ai dit, un avantage important de cette approche est que vous pouvez utiliser </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des algorithmes standard qui nécessitent des API mutables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un autre exemple.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction n'accepte pas et retourne </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais une chaîne d'appel est exécutée à l'intérieur </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ici, comme dans l'exemple précédent, une copie inutile à l'intérieur de l'appel peut se produire </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Notez que la première valeur qui est exécutée </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est la valeur nommée et le reste est une valeur r, c'est-à-dire des liens anonymes. Si vous utilisez le comptage de références, la méthode </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut faire référence à des compteurs de référence pour les nœuds auxquels la mémoire est allouée dans l'arborescence. Et dans le cas de la valeur r, si le nombre de liens est un, il devient clair qu'aucune autre partie du programme n'accède à ces nœuds. Ici, les performances sont exactement les mêmes que dans le cas avec </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ⟵ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, pour aider le compilateur, nous pouvons l'exécuter </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est utilisé nulle part ailleurs dans la fonction. Nous avions un avantage important, qui n'était pas dans la </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variante: si nous transmettons la valeur retournée d'un autre say_hi à la fonction say_hi, alors il n'y aura pas de copies supplémentaires. Dans le cas de c, </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il existe des limites auxquelles une copie excessive peut se produire. En d'autres termes, nous avons une structure de données persistante et immuable, dont les performances dépendent de la quantité réelle d'accès partagé lors de l'exécution. S'il n'y a pas de partage, les performances seront les mêmes que celles d'une structure de données mutable. Il s'agit d'une propriété extrêmement importante. L'exemple que je vous ai déjà montré ci-dessus peut être réécrit avec une méthode </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à présent, nous avons parlé de vecteurs, et en plus d'eux, il y a aussi des cartes de hachage. Ils sont dédiés à un rapport très utile de Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Saint Graal. Un tri mappé de tableau de hachage pour C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il décrit des tables de hachage implémentées sur la base des mêmes principes que je viens de parler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suis sûr que beaucoup d'entre vous ont des doutes sur les performances de ces structures. Fonctionnent-ils rapidement dans la pratique? J'ai fait de nombreux tests, et en bref ma réponse est oui. Si vous voulez en savoir plus sur les résultats des tests, ils sont publiés dans mon article pour la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conférence internationale de programmation fonctionnelle 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, je pense qu'il vaut mieux discuter non pas de valeurs absolues, mais de l'effet que cette structure de données a sur le système dans son ensemble. </font><font style="vertical-align: inherit;">Bien sûr, la mise à jour de notre vecteur est plus lente car vous devez copier plusieurs blocs de données et allouer de la mémoire pour d'autres données. </font><font style="vertical-align: inherit;">Mais le contournement de notre vecteur s'effectue presque à la même vitesse qu'un vecteur normal. </font><font style="vertical-align: inherit;">Il était très important pour moi d'y parvenir, car la lecture des données est effectuée beaucoup plus souvent que leur modification.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, en raison de la mise à jour plus lente, il n'est pas nécessaire de copier quoi que ce soit, seule la structure des données est copiée. </font><font style="vertical-align: inherit;">Par conséquent, le temps consacré à la mise à jour du vecteur est, pour ainsi dire, amorti pour toutes les copies effectuées dans le système. </font><font style="vertical-align: inherit;">Par conséquent, si vous appliquez cette structure de données dans une architecture similaire à celle que j'ai décrite au début du rapport, les performances augmenteront considérablement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne serai pas infondé et démontrerai ma structure de données à l'aide d'un exemple. </font><font style="vertical-align: inherit;">J'ai écrit un petit éditeur de texte. </font><font style="vertical-align: inherit;">Il s'agit d'un outil interactif appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans lequel les documents sont représentés par des vecteurs immuables. </font><font style="vertical-align: inherit;">J'ai une copie de la totalité de la Wikipédia en espéranto sur mon disque, elle pèse 1 gigaoctet (au début, je voulais télécharger la version anglaise, mais elle est trop grande). </font><font style="vertical-align: inherit;">Quel que soit l'éditeur de texte que vous utilisez, je suis sûr qu'il n'aimera pas ce fichier. </font><font style="vertical-align: inherit;">Et lorsque vous téléchargez ce fichier dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous pouvez immédiatement le modifier, car le téléchargement est asynchrone. </font><font style="vertical-align: inherit;">La navigation dans les fichiers fonctionne, rien ne se bloque, non </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pas de synchronisation. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, le fichier téléchargé prend 20 millions de lignes de code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de considérer les propriétés les plus importantes de cet outil, prêtons attention à un détail amusant. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début de la ligne, surlignée en blanc au bas de l'image, vous voyez deux tirets. Cette interface utilisateur est probablement familière aux utilisateurs d'emacs; les traits d'union signifient que le document n'a été modifié d'aucune façon. Si vous apportez des modifications, des astérisques s'affichent à la place des tirets. Mais, contrairement à d'autres éditeurs, si vous </font><font style="vertical-align: inherit;">supprimez ces modifications </font><font style="vertical-align: inherit;">dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ne les annulez pas, supprimez-les simplement), les traits d'union réapparaîtront à la place des astérisques, car </font><font style="vertical-align: inherit;">toutes les versions précédentes du texte sont enregistrées </font><font style="vertical-align: inherit;">dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Grâce à cela, un indicateur spécial n'est pas nécessaire pour indiquer si le document a été modifié: la présence de modifications est déterminée par comparaison avec le document d'origine.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez une autre propriété intéressante de l'outil: copiez le texte entier et collez-le plusieurs fois au milieu du texte existant. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, cela se produit instantanément. </font><font style="vertical-align: inherit;">La jonction de vecteurs ici est une opération logarithmique, et le logarithme de plusieurs millions n'est pas une opération aussi longue. </font><font style="vertical-align: inherit;">Si vous essayez d'enregistrer cet énorme document sur votre disque dur, cela prendra beaucoup plus de temps, car le texte n'est plus présenté comme un vecteur obtenu à partir de la version précédente de ce vecteur. </font><font style="vertical-align: inherit;">Lors de l'enregistrement sur le disque, la sérialisation se produit, donc la persistance est perdue.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour à une architecture basée sur la valeur</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par la façon dont vous ne pouvez pas revenir à cette architecture: en utilisant le contrôleur, le modèle et la vue de style Java habituels, qui sont le plus souvent utilisés pour les applications interactives en C ++. Il n'y a rien de mal avec eux, mais ils ne conviennent pas à notre problème. D'une part, le modèle Model-View-Controller permet la séparation des tâches, mais d'autre part, chacun de ces éléments est un objet, à la fois d'un point de vue orienté objet et du point de vue de C ++, c'est-à-dire que ce sont des zones de mémoire avec mutable état. View connaît Model; ce qui est bien pire - le modèle connaît indirectement la vue, car il y a presque certainement un rappel par lequel la vue est notifiée lorsque le modèle change. Même avec la meilleure implémentation de principes orientés objet, nous obtenons beaucoup de dépendances mutuelles.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au fur et à mesure que l'application se développe et que de nouveaux modèles, contrôleurs et vues sont ajoutés, une situation se produit lorsque, pour modifier un segment du programme, vous devez connaître toutes les parties qui lui sont associées, toutes les vues qui reçoivent des alertes </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. En conséquence, tout le monde le monstre familier des pâtes commence à scruter ces dépendances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre architecture est-elle possible? Il existe une approche alternative au modèle Model-View-Controller appelée «Architecture de flux de données unidirectionnelle». Ce concept n'a pas été inventé par moi, il est utilisé assez souvent dans le développement web. Sur Facebook, cela s'appelle l'architecture Flux, mais en C ++, elle n'est pas encore appliquée.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les éléments d'une telle architecture nous sont déjà familiers: action, modèle et vue, mais la signification des blocs et des flèches est différente. Les blocs sont des valeurs, pas des objets et pas des régions avec des états mutables. Cela s'applique même à View. De plus, les flèches ne sont pas des liens, car sans objets il ne peut y avoir de liens. Ici, les flèches sont des fonctions. Entre Action et Modèle, il existe une fonction de mise à jour qui accepte le Modèle actuel, c'est-à-dire l'état actuel du monde, et Action, qui est une représentation d'un événement, par exemple, un clic de souris, ou un événement d'un autre niveau d'abstraction, par exemple, l'insertion d'un élément ou d'un symbole dans un document. La fonction de mise à jour met à jour le document et renvoie le nouvel état du monde. Le modèle se connecte au rendu de la fonction Vue, qui prend le modèle et renvoie la vue. Cela nécessite un cadre dans lequel View peut être représenté sous forme de valeurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le développement Web, React fait cela, mais en C ++, il n'y a encore rien de tel, même si qui sait, s'il y a des gens qui veulent me payer pour écrire quelque chose comme ça, cela pourrait bientôt apparaître. En attendant, vous pouvez utiliser l'API en mode immédiat, dans laquelle la fonction de dessin vous permet de créer une valeur comme effet secondaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, la vue doit avoir un mécanisme qui permet à l'utilisateur ou à d'autres sources d'événements d'envoyer une action. Il existe un moyen simple de mettre en œuvre cela, il est présenté ci-dessous:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'exception de l'enregistrement et du chargement asynchrones, c'est le code utilisé dans l'éditeur qui vient d'être présenté. Il y a un objet ici </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vous permet de lire et d'écrire à partir de la ligne de commande. De plus, </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est la valeur de Model, il stocke tout l'état de l'application. Comme vous pouvez le voir en haut de l'écran, il existe une fonction qui renvoie une nouvelle version </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le cycle à l'intérieur de la fonction est exécuté jusqu'à ce que l'application doive se fermer, c'est-à-dire jusqu'à ce que </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans la boucle, un nouvel état est tracé, puis l'événement suivant est demandé. Enfin, l'état est stocké dans une variable locale </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la boucle recommence. Ce code présente un avantage très important: une seule variable mutable existe tout au long de l'exécution du programme, c'est un objet </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les développeurs de Clojure appellent cette architecture à atome unique: il y a un seul point à travers l'application entière à travers lequel toutes les modifications sont apportées. </font><font style="vertical-align: inherit;">La logique d'application ne participe en aucune façon à la mise à jour de ce point, ce qui en fait un cycle spécialement conçu. </font><font style="vertical-align: inherit;">Grâce à cela, la logique d'application est entièrement constituée de fonctions pures, comme des fonctions </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette approche de l'écriture d'applications, la façon de penser les logiciels évolue. </font><font style="vertical-align: inherit;">Le travail commence maintenant non pas avec le diagramme UML des interfaces et des opérations, mais avec les données elles-mêmes. </font><font style="vertical-align: inherit;">Il existe certaines similitudes avec la conception orientée données. </font><font style="vertical-align: inherit;">Certes, la conception orientée données est généralement utilisée pour obtenir des performances maximales, ici, en plus de la vitesse, nous nous efforçons de simplicité et d'exactitude. </font><font style="vertical-align: inherit;">L'accent est légèrement différent, mais il existe d'importantes similitudes dans la méthodologie.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessus sont les principaux types de données de notre application. Le corps principal de l'application se compose de </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est flex_vector, et flex_vector est </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui pour lequel vous pouvez effectuer une opération de jointure. Vient ensuite </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le vecteur dans lequel il est stocké </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme vous pouvez le voir, il s'agit d'une représentation très simple du texte. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stocké à l'aide </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de qui a un nom, c'est-à-dire une adresse dans le système de fichiers, et en fait </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisé un autre type, simple mais très utile: </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'un conteneur à élément unique. Il vous permet de placer un tas et de déplacer un objet, la copie pouvant être trop gourmande en ressources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre type important: </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sur la base de ce type, une fonction d'annulation est active. Il contient un document (sous la forme</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et la position du curseur (coord). Cela vous permet de ramener le curseur à la position dans laquelle il se trouvait lors de l'édition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type suivant est </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. C'est un terme de vim et emacs, car les documents ouverts y sont appelés. Il </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a un fichier à partir duquel le texte a été téléchargé, ainsi que le contenu du texte - cela vous permet de vérifier les modifications dans le document. Pour mettre en évidence une partie du texte, une variable facultative </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indique le début de la sélection. Le vecteur </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est l'histoire du texte. Notez que nous n'utilisons pas le modèle d'équipe; l'historique se compose uniquement d'états. Enfin, si l'annulation vient de se terminer, nous avons besoin d'un indice de position dans l'historique de l'état </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type suivant: </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il contient un document ouvert (tampon), </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les raccourcis clavier, ainsi qu'un vecteur de </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour le presse-papiers et un autre vecteur pour les messages affichés en bas de l'écran. </font><font style="vertical-align: inherit;">Jusqu'à présent, dans la première version de l'application, il n'y aura qu'un seul thread et un type d'action qui prend en entrée </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Très probablement, beaucoup d'entre vous réfléchissent déjà à la façon de mettre en œuvre ces opérations. </font><font style="vertical-align: inherit;">Si elles sont prises par valeur et retournées par valeur, alors dans la plupart des cas, les opérations sont assez simples. </font><font style="vertical-align: inherit;">Le code de mon éditeur de texte est publié sur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous pouvez donc voir à quoi il ressemble réellement. </font><font style="vertical-align: inherit;">Maintenant, je m'attarderai en détail uniquement sur le code qui implémente la fonction d'annulation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annuler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Écrire correctement une annulation sans l'infrastructure appropriée n'est pas si simple. Dans mon éditeur, je l'ai implémenté sur le modèle d'emacs, donc d'abord quelques mots sur ses principes de base. La commande de retour manque ici, et grâce à cela, vous ne pouvez pas perdre de travail. Si un retour est nécessaire, toute modification est apportée au texte, puis toutes les actions d'annulation font à nouveau partie de l'historique d'annulation.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce principe est décrit ci-dessus. Le losange rouge montre ici une position dans l'histoire: si une annulation n'a tout simplement pas été effectuée, le losange rouge est toujours à la toute fin. Si vous annulez, le losange ramènera un état en arrière, mais en même temps, un autre état sera ajouté à la fin de la file d'attente - le même que celui que l'utilisateur voit actuellement (S3). Si vous annulez à nouveau et revenez à l'état S2, l'état S2 est ajouté à la fin de la file d'attente. Si maintenant l'utilisateur fait une sorte de changement, il sera ajouté à la fin de la file d'attente en tant que nouvel état de S5, et un losange y sera déplacé. Désormais, lors de l'annulation des actions passées, les actions d'annulation précédentes défileront en premier. Pour implémenter un tel système d'annulation, le code suivant suffit:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a deux actions, </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectué au cours de toute opération. C'est très pratique car nous n'avons pas besoin de savoir si une modification du document a eu lieu. La fonction est transparente pour la logique d'application. Après toute action, la fonction vérifie si le document a changé. Si un changement s'est produit, le </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenu et la position du curseur pour sont </font><font style="vertical-align: inherit;">exécutés </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si l'action n'a pas conduit à une modification </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(c'est-à-dire que l'entrée reçue n'est </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas provoquée par l'action d'annulation), alors </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une valeur est affectée </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si nécessaire </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous vérifions </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. S'il n'a pas de sens, nous le considérons </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la fin de l'histoire. Si l'historique d'annulation n'est pas vide (c.-à-d.</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas au tout début de l'histoire), l'annulation est effectuée. </font><font style="vertical-align: inherit;">Le contenu et le curseur actuels sont remplacés et modifiés </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'irrévocabilité d'une opération d'annulation est obtenue par une fonction </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui est également appelée pendant l'opération d'annulation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc une opération </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui prend 10 lignes de code et qui, sans modifications (ou avec des modifications minimes), peut être utilisée dans presque toutes les autres applications.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyage dans le temps</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À propos du voyage dans le temps. Comme nous le verrons maintenant, il s'agit d'un sujet lié à l'annulation. Je vais démontrer le travail d'un framework qui ajoutera des fonctionnalités utiles à toute application avec une architecture similaire. Le cadre ici est appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette version d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inclut des fonctionnalités de débogage. À partir du navigateur, vous pouvez maintenant ouvrir le débogueur, dans lequel vous pouvez examiner l'état de l'application.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons que la dernière action a été redimensionnée, car j'ai ouvert une nouvelle fenêtre et mon gestionnaire de fenêtres a automatiquement redimensionné la fenêtre déjà ouverte. Bien sûr, pour la sérialisation automatique en JSON, j'ai dû ajouter une annotation pour struct à partir de la bibliothèque de réflexion spéciale. Mais le reste du système est assez universel, il peut être connecté à n'importe quelle application similaire. Maintenant, dans le navigateur, vous pouvez voir toutes les actions terminées. Bien sûr, il y a un état initial qui n'a aucune action. Il s'agit de l'état qui était avant le téléchargement. De plus, en double-cliquant, je peux ramener l'application à son état précédent. Il s'agit d'un outil de débogage très utile qui vous permet de suivre l'occurrence d'un dysfonctionnement dans l'application.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous êtes intéressé, vous pouvez écouter mon rapport sur CPPCON 19, Les valeurs les plus précieuses, là j'examinerai ce débogueur en détail. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, l'architecture basée sur les valeurs y est discutée plus en détail. </font><font style="vertical-align: inherit;">Dans ce document, je vous explique également comment mettre en œuvre des actions et les organiser de manière hiérarchique. </font><font style="vertical-align: inherit;">Cela garantit la modularité du système et élimine la nécessité de tout garder dans une seule grande fonction de mise à jour. </font><font style="vertical-align: inherit;">En outre, ce rapport parle de téléchargements de fichiers asynchrones et multithreads. </font><font style="vertical-align: inherit;">Il existe une autre version de ce rapport dans laquelle une demi-heure de matériel supplémentaire est constituée de structures de données immuables postmodernes.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résumer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense qu'il est temps de faire le point. Je vais citer Andy Wingo - c'est un excellent développeur, il a consacré beaucoup de temps à la V8 et aux compilateurs en général, enfin il est engagé dans le support de Guile, implémentant Scheme for GNU. Récemment, il a écrit sur son Twitter: «Pour réaliser une légère accélération du programme, nous mesurons chaque petit changement et ne laissons que ceux qui donnent un résultat positif. Mais nous réalisons vraiment une accélération significative, à l'aveugle, en investissant beaucoup d'efforts, sans avoir 100% de confiance et guidés uniquement par l'intuition. Quelle étrange dichotomie. »</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il me semble que les développeurs C ++ réussissent dans le premier genre. </font><font style="vertical-align: inherit;">Donnez-nous un système fermé, et nous, armés de nos outils, nous en retirerons tout ce qui est possible. </font><font style="vertical-align: inherit;">Mais dans le deuxième genre, nous n'avons pas l'habitude de travailler. </font><font style="vertical-align: inherit;">Bien entendu, la deuxième approche est plus risquée et conduit souvent à un gaspillage de gros efforts. </font><font style="vertical-align: inherit;">D'autre part, en réécrivant complètement un programme, il peut souvent être rendu plus facile et plus rapide. </font><font style="vertical-align: inherit;">J'espère avoir réussi à vous convaincre d'essayer au moins cette deuxième approche.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente a pris la parole lors de la conférence C ++ Russia 2019 à Moscou et a parlé des structures de données qui vous permettent de faire des choses intéressantes. </font><font style="vertical-align: inherit;">Une partie de la magie de ces structures réside dans l'élision de la copie - c'est ce dont </font><font style="vertical-align: inherit;">Anton Polukhin et Roman Rusyaev </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parleront</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors de la prochaine conférence </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Suivez les mises </font><font style="vertical-align: inherit;">à </font><font style="vertical-align: inherit;">jour du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur le site.</font></font></blockquote></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr487090/index.html">Un nouveau niveau d'optimisation Windows</a></li>
<li><a href="../fr487092/index.html">Modélisation des processus métiers dans le cadre d'un projet d'implémentation d'un système ERP</a></li>
<li><a href="../fr487094/index.html">Événements de retraitement reçus de Kafka</a></li>
<li><a href="../fr487096/index.html">Extraits. Comment faciliter le processus de travail avec la documentation</a></li>
<li><a href="../fr487098/index.html">Dessiner avec des fourmis: images procédurales utilisant des algorithmes d'optimisation des colonies de fourmis</a></li>
<li><a href="../fr487106/index.html">Contrôle RunUO de l'analyseur PVS-Studio</a></li>
<li><a href="../fr487108/index.html">Profil de joueur mobile: recherche MyTracker</a></li>
<li><a href="../fr487110/index.html">Slurm SRE. Une expérience complète avec des experts de Booking.com et de Google.com</a></li>
<li><a href="../fr487112/index.html">Edge of Madness: The Basic Circle</a></li>
<li><a href="../fr487116/index.html">Pourquoi Discord passe de Go à Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>