<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏼 ☝🏿 🤵🏽 ジュリア：関数と関数としての構造 🈶 👨🏿‍🚀 👓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Juliaの概念にはクラスとメソッドを備えた「古典的な」オブジェクト指向プログラミングが欠けているという事実にもかかわらず、この言語は、型システムと関数型プログラミングの要素が果たす主要な役割である抽象化ツールを提供します。2つ目のポイントをさらに詳しく見てみましょう。
 
 ジュリアの関数の概念は...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ジュリア：関数と関数としての構造</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451172/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juliaの概念にはクラスとメソッドを備えた「古典的な」オブジェクト指向プログラミングが欠けているという事実にもかかわらず、この言語は、型システムと関数型プログラミングの要素が果たす主要な役割である抽象化ツールを提供します。</font><font style="vertical-align: inherit;">2つ目のポイントをさらに詳しく見てみましょう。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジュリアの関数の概念は、おそらくLispファミリの言語（より正確には、Lisp-1分岐）に最も類似しており、関数は3つのレベルで考えることができます。 。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベル1.ルーチンとして機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブプログラムの割り当てとそれらの名前の割り当ては、Fortranが高級言語と見なされ、Cがまだ存在しなかった先史時代から続いています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この意味で、Julia製品は標準です。 「機能」とは、構文的に手続きと関数に分割されていないということです。何らかの値を取得するために呼び出されるか、データに対して何らかのアクションを実行するためだけに呼び出されるかに関係なく、サブルーチンは関数と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の定義はkeyword </font></font><code>function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">始まり</font><font style="vertical-align: inherit;">、その後に引数のリスト、括弧で囲まれた一連のコマンドが続き、単語はdefinitionで終わります</font></font><code>end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-string">"""
    sum_all(collection)

Sum all elements of a collection and return the result
"""</span>
<span class="hljs-keyword">function</span> sum_all(collection)<font></font>
    sum = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection<font></font>
        sum += collection<font></font>
    <span class="hljs-keyword">end</span><font></font>
    sum<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特徴的な構文は、Lispから継承された動作です。関数からの「通常の」戻り値の場合、単語は</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">あり</font><font style="vertical-align: inherit;">ません</font></font><code>end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。式が</font><font style="vertical-align: inherit;">返される前に計算された最後の値の値</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記の例では、変数の値が返され</font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">したがって、</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の特殊な動作のマーカーとして使用できます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> safe_division(number, divisor)
    <span class="hljs-keyword">if</span> divisor == <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">end</span><font></font>
    number / divisor<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#   </span>
<span class="hljs-keyword">function</span> safe_division1(number, divisor)
    <span class="hljs-keyword">if</span> divisor == <span class="hljs-number">0</span>
        <span class="hljs-number">0</span> <span class="hljs-comment">#            </span>
    <span class="hljs-keyword">else</span><font></font>
        number / divisor<font></font>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短い定義の関数の場合、数学表記に似た短縮構文があります。</font><font style="vertical-align: inherit;">したがって、脚の長さに沿った斜辺の長さの計算は、次のように定義できます。</font></font><br>
<br>
<pre><code class="julia hljs">hypotenuse(a, b) = sqrt(a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三項演算子を使用した「安全な」除算は、次のように書くことができます。</font></font><br>
<br>
<pre><code class="julia hljs">safe_division(number, divisor) = divisor == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : number / divisor
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、関数の引数に型を指定する必要はありません。 Julia JITコンパイラがどのように機能するかを考えると、ダックタイピングが必ずしもパフォーマンスの低下をもたらすとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は証明しようとしたとして</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、以前の記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ジュリアコンパイラは、入力引数のタイプによって戻り値の結果の型を推論することができます。したがって、たとえば、</font></font><code>safe_division</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迅速な作業のための</font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は最小限の変更で済みます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> safe_division(number, divisor)
    <span class="hljs-keyword">if</span> divisor == <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> zero(number / divisor)
    <span class="hljs-keyword">end</span><font></font>
    number / divisor<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、コンパイル段階で両方の引数の型がわかっている場合、返される結果の型も明確に表示されます。</font><font style="vertical-align: inherit;">関数</font></font><code>zero(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、引数と同じ型のnull値を返します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEEE 754</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">よると、ゼロによる除算は、</font><font style="vertical-align: inherit;">浮動小数点数の形式で完全に表現可能な値を持っています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は、固定数の位置引数、デフォルト値の位置引数、名前付き引数、および可変数の引数を持つことができます。</font><font style="vertical-align: inherit;">構文：</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-comment">#   </span>
<span class="hljs-keyword">function</span> hello(name)<font></font>
    println(<span class="hljs-string">"Hello, "</span>, name)
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#     </span>
<span class="hljs-comment">#          </span>
<span class="hljs-keyword">function</span> greeting_d(name, greeting = <span class="hljs-string">"Hello"</span>)<font></font>
    println(greeting, <span class="hljs-string">", "</span>, name)
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#      </span>
<span class="hljs-comment">#         </span>
<span class="hljs-comment">#      </span>
<span class="hljs-keyword">function</span> greeting_kw(name; greeting = <span class="hljs-string">"Hello"</span>)<font></font>
    println(greeting, <span class="hljs-string">", "</span>, name)
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#  greeting   ,       </span>
<span class="hljs-keyword">function</span> greeting_oblkw(name; greeting)<font></font>
    println(greeting, <span class="hljs-string">", "</span>, name)
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#     </span>
<span class="hljs-comment">#  ,   ,      names</span>
<span class="hljs-keyword">function</span> greeting_nary(greeting, names...)<font></font>
    print(greeting)<font></font>
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names<font></font>
        print(<span class="hljs-string">", "</span>, name)
    <span class="hljs-keyword">end</span><font></font>
    print('\n')<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; hello(<span class="hljs-string">"world"</span>)<font></font>
Hello, world<font></font>
<font></font>
julia&gt; greeting_d(<span class="hljs-string">"world"</span>)<font></font>
Hello, world<font></font>
<font></font>
julia&gt; greeting_d(<span class="hljs-string">"Mr. Smith"</span>, <span class="hljs-string">"How do you do"</span>)<font></font>
How <span class="hljs-keyword">do</span> you <span class="hljs-keyword">do</span>, Mr. Smith<font></font>
<font></font>
julia&gt; greeting_kw(<span class="hljs-string">"Mr. Smith"</span>)<font></font>
Hello, Mr. Smith<font></font>
<font></font>
julia&gt; greeting_kw(<span class="hljs-string">"mom"</span>, greeting = <span class="hljs-string">"Hi"</span>)<font></font>
Hi, mom<font></font>
<font></font>
julia&gt; greeting_oblkw(<span class="hljs-string">"world"</span>)<font></font>
ERROR: UndefKeywordError: keyword argument greeting not assigned<font></font>
Stacktrace:<font></font>
 [<span class="hljs-number">1</span>] greeting_oblkw(::<span class="hljs-built_in">String</span>) at ./REPL[<span class="hljs-number">23</span>]:<span class="hljs-number">3</span>
 [<span class="hljs-number">2</span>] top-level scope at none:<span class="hljs-number">0</span><font></font>
<font></font>
julia&gt; greeting_oblkw(<span class="hljs-string">"mom"</span>, greeting = <span class="hljs-string">"Hi"</span>)<font></font>
Hi, mom<font></font>
<font></font>
julia&gt; greeting_nary(<span class="hljs-string">"Hi"</span>, <span class="hljs-string">"mom"</span>, <span class="hljs-string">"dad"</span>, <span class="hljs-string">"everyone"</span>)<font></font>
Hi, mom, dad, everyone<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベル2.データとして機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数名は、直接呼び出しで使用できるだけでなく、値を取得するためのプロシージャが関連付けられている識別子としても使用できます。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> f_x_x(fn, x)<font></font>
    fn(x, x)<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; f_x_x(+, <span class="hljs-number">3</span>)
<span class="hljs-number">6</span> <span class="hljs-comment"># +(3, 3) = 3+3 = 6</span>
julia&gt; f_x_x(*, <span class="hljs-number">3</span>)
<span class="hljs-number">9</span> <span class="hljs-comment"># *(3, 3) = 9</span>
julia&gt; f_x_x(^, <span class="hljs-number">3</span>)
<span class="hljs-number">27</span> <span class="hljs-comment"># ^(3, 3) = 3^3 = 27</span>
julia&gt; f_x_x(log, <span class="hljs-number">3</span>)
<span class="hljs-number">1.0</span> <span class="hljs-comment"># log(3, 3) = 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数引数を取る「クラシック」関数は</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<code>map(f, x...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をすべての要素の値</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（またはi要素のタプル）に適用し、結果を新しいコレクションとして返します。</font></font><br>
<br>
<pre><code class="julia hljs">julia&gt; map(cos, [<span class="hljs-number">0</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">3</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">2</span>, <span class="hljs-number">2</span>*<span class="hljs-literal">π</span>/<span class="hljs-number">3</span>, <span class="hljs-literal">π</span>])
<span class="hljs-number">5</span>-element <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Float64</span>,<span class="hljs-number">1</span>}:
  <span class="hljs-number">1.0</span>                  
  <span class="hljs-number">0.5000000000000001</span>   
  <span class="hljs-number">6.123233995736766e-17</span>
 -<span class="hljs-number">0.4999999999999998</span>   
 -<span class="hljs-number">1.0</span><font></font>
<font></font>
julia&gt; map(+, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<font></font>
(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
</code></pre><br>
<code>reduce(f, x; init_val)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コレクションを単一の値に「縮小」し、チェーンを「拡張」します</font></font><code>f(f(...f(f(init_val, x[1]), x[2])...), x[end])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> myreduce(fn, values, init_val)<font></font>
    accum = init_val<font></font>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> values<font></font>
        accum = fn(accum, x)<font></font>
    <span class="hljs-keyword">end</span><font></font>
    accum<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
縮約中に配列がどの順序で渡される</font></font><code>fn(accum, x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font></font><code>fn(x, accum)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">が呼び出されるかどうかは実際には決定されていないため</font><font style="vertical-align: inherit;">、縮約は、加算または乗算などの可換演算子または結合演算子でのみ予測可能な結果を​​もたらします。</font><font style="vertical-align: inherit;">述語を満たす</font></font><br>
<br>
<code>filter(predicate, x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素の配列を返します</font><font style="vertical-align: inherit;">。</font></font><code>x</code><font style="vertical-align: inherit;"></font><code>predicate</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="julia hljs">julia&gt; filter(isodd, <span class="hljs-number">1</span>:<span class="hljs-number">10</span>)
<span class="hljs-number">5</span>-element <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Int64</span>,<span class="hljs-number">1</span>}:
 <span class="hljs-number">1</span>
 <span class="hljs-number">3</span>
 <span class="hljs-number">5</span>
 <span class="hljs-number">7</span>
 <span class="hljs-number">9</span>
julia&gt; filter(iszero, [[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>, <span class="hljs-number">0</span><span class="hljs-literal">im</span>])
<span class="hljs-number">4</span>-element <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Any</span>,<span class="hljs-number">1</span>}:<font></font>
    [<span class="hljs-number">0</span>] 
   <span class="hljs-number">0.0</span>  
    <span class="hljs-number">1</span>:<span class="hljs-number">0</span> 
 <span class="hljs-number">0</span> + <span class="hljs-number">0</span><span class="hljs-literal">im</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループを記述する代わりに、配列の演算に高次関数を使用すると、いくつかの利点があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> コードが短くなっています </font></font></li>
<li> <code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">、実行されている操作</font></font><code>reduce()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セマンティクスを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示した</font><font style="vertical-align: inherit;">後、サイクルで何が起こっているかのセマンティクスを理解する必要がある</font></font></li>
<li> <code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> コンパイラーは、配列要素の操作がデータから独立していることを理解できるため、追加の最適化を適用できます </font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベル3.抽象化としての機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合に</font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または</font></font><code>filter()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは、独自の名前が割り当てられていない機能を使用する必要があります。</font><font style="vertical-align: inherit;">この場合のJuliaでは</font><font style="vertical-align: inherit;">、このシーケンスに独自の名前を入力しなくても、引数に対する操作</font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を表現できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのような抽象化は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、無名関数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラムダ関数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">（数学の伝統では、そのような関数はラムダ文字で表されるため）。</font><font style="vertical-align: inherit;">このビューの構文は次のとおりです。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-comment">#  </span>
square(x) = x^<span class="hljs-number">2</span>
<span class="hljs-comment">#  </span>
x -&gt; x^<span class="hljs-number">2</span><font></font>
<font></font>
<span class="hljs-comment">#  </span>
hypot(a, b) = sqrt(x^<span class="hljs-number">2</span> + y^<span class="hljs-number">2</span>)
<span class="hljs-comment">#   -    ,    ,</span>
<span class="hljs-comment">#             </span>
(x, y) -&gt; sqrt(x^<span class="hljs-number">2</span> + y^<span class="hljs-number">2</span>)<font></font>
<font></font>
<span class="hljs-comment">#  </span>
fortytwo() = <span class="hljs-number">42</span>
<span class="hljs-comment">#  </span>
() -&gt; <span class="hljs-number">42</span><font></font>
<font></font>
julia&gt; map(i -&gt; map(x -&gt; x^i, <span class="hljs-number">1</span>:<span class="hljs-number">5</span>), <span class="hljs-number">1</span>:<span class="hljs-number">5</span>)
<span class="hljs-number">5</span>-element <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Int64</span>,<span class="hljs-number">1</span>},<span class="hljs-number">1</span>}:<font></font>
 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]         <font></font>
 [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]       <font></font>
 [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">64</span>, <span class="hljs-number">125</span>]     <font></font>
 [<span class="hljs-number">1</span>, <span class="hljs-number">16</span>, <span class="hljs-number">81</span>, <span class="hljs-number">256</span>, <span class="hljs-number">625</span>]   <font></font>
 [<span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">243</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">3125</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前付き関数と匿名関数の両方を変数に割り当て、値として返すことができます。</font></font><br>
<br>
<pre><code class="julia hljs">julia&gt; double_squared = x -&gt; (<span class="hljs-number">2</span> * x)^<span class="hljs-number">2</span>
<span class="hljs-comment">#17 (generic function with 1 method)</span><font></font>
<font></font>
julia&gt; double_squared(<span class="hljs-number">5</span>)
<span class="hljs-number">100</span>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数のスコープと字句の閉鎖</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、それらは、計算に必要なすべてのデータが正式な引数を介して取得されるように関数を記述しようとします。本文に出現する変数名は、仮引数の名前か、関数の本文内に入力された変数の名前のいずれかです。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> normal(x, y)<font></font>
    z = x + y<font></font>
    x + y * z<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> strange(x, y)<font></font>
    x + y * z<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなた</font></font><code>normal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はその本体ですべての変数名が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font><font style="vertical-align: inherit;">いる関数について</font><font style="vertical-align: inherit;">言う</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">ができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべての場所（引数リストを含む）で「x」を「m」（またはその他の識別子）、「y」を「n」、「z」を「sum_of_m_and_n」に置き換えても、式の意味は変わりません。</font><font style="vertical-align: inherit;">関数では、</font></font><code>strange()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前zは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unboundです</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、</font><font style="vertical-align: inherit;">a）この名前が別の名前に置き換えられると、意味が変わる場合があります。b）関数の正確さは、関数の呼び出し時に「z」という名前の変数が定義されているかどうかによって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に言って、関数</font></font><code>normal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もすべてがそれほどきれい</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">はありません。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zという名前の変数が関数の外部で定義されている場合はどうなりますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +と*の文字は、実際には無関係の識別子でもあります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイント2では、同意しないと何もできません。システムで使用されるすべての関数の定義が存在する必要があることは論理的であり、それらの実際の意味が私たちの期待に対応することを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイント1は、見かけよりも明確ではありません。事実は、答えは関数が定義されている場所に依存するということです。グローバルに定義されている場合、その</font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font><code>normal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はローカル変数になります。グローバル変数があったとしても、</font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その値は上書きされません。関数の定義がコードブロック内にある場合、このブロックに以前の定義がある</font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、変更されるのは外部変数の値になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数本体に外部変数の名前が含まれている場合、この名前は、関数が作成された環境に存在していた値に関連付けられます。</font><font style="vertical-align: inherit;">関数自体がこの環境からエクスポートされる場合（たとえば、別の関数から値として返される場合）、新しい環境ではアクセスできない内部環境から変数を「キャプチャ」します。</font><font style="vertical-align: inherit;">これは字句閉鎖と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロージャは主に2つの状況で役立ちます。特定のパラメータに従って関数を作成する必要がある場合と、内部状態を持つ関数が必要な場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部状態をカプセル化する関数の状況を考えてみましょう。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> f_with_counter(fn)<font></font>
    call_count = <span class="hljs-number">0</span><font></font>
    ncalls() = call_count<font></font>
    <span class="hljs-comment"># invoke()  ,    </span>
    <span class="hljs-comment">#    ,  ncalls()</span>
    <span class="hljs-keyword">function</span> invoke(args...)<font></font>
        call_count += <span class="hljs-number">1</span><font></font>
        fn(args...)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment"># call_count     ,</span>
    <span class="hljs-comment">#   invoke()  call_count()       </span><font></font>
    (call = invoke, call_count = ncalls)<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; abscount = f_with_counter(abs)<font></font>
(call = getfield(Main, <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"#invoke#22"</span>)){typeof(abs)}(abs, Core.Box(<span class="hljs-number">0</span>)), call_count = getfield(Main, <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"#ncalls#21"</span>))(Core.Box(<span class="hljs-number">0</span>)))<font></font>
julia&gt; abscount.call_count()<font></font>
<span class="hljs-number">0</span>
julia&gt; abscount.call(-<span class="hljs-number">20</span>)
<span class="hljs-number">20</span><font></font>
julia&gt; abscount.call_count()<font></font>
<span class="hljs-number">1</span>
julia&gt; abscount.call(<span class="hljs-literal">im</span>)
<span class="hljs-number">1.0</span><font></font>
julia&gt; abscount.call_count()<font></font>
<span class="hljs-number">2</span>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケーススタディ：すべて同じ多項式</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の記事、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造などの多項式のプレゼンテーションが考えられています。</font><font style="vertical-align: inherit;">特に、ストレージ構造の1つは、最新のものから始まる係数のリストです。</font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある時点で</font><font style="vertical-align: inherit;">多項式を計算するため</font><font style="vertical-align: inherit;">に、ホーナーのスキームに従って多項式を計算する</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出す</font><font style="vertical-align: inherit;">ことが</font><font style="vertical-align: inherit;">提案されました</font></font><code>evpoly(p, x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な定義コード</font></font></b><div class="spoiler_text"><pre><code class="julia hljs"><span class="hljs-keyword">abstract type</span> AbstractPolynomial <span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-string">"""
    Polynomial &lt;: AbstractPolynomial

Polynomials written in the canonical form

---

    Polynomial(v::T) where T&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}})

Construct a `Polynomial` from the list of the coefficients. The coefficients are assumed to go from power 0 in the ascending order. If an empty collection is provided, the constructor returns a zero polynomial.
"""</span>
<span class="hljs-keyword">struct</span> Polynomial&lt;:AbstractPolynomial<font></font>
    degree::<span class="hljs-built_in">Int</span>
    coeff::<span class="hljs-built_in">NTuple</span>{N, <span class="hljs-built_in">Float64</span>} <span class="hljs-keyword">where</span> N
    <span class="hljs-keyword">function</span> Polynomial(v::T <span class="hljs-keyword">where</span> T&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                            <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}})<font></font>
        coeff = isempty(v) ? (<span class="hljs-number">0.0</span>,) : tuple([<span class="hljs-built_in">Float64</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> v]...)
        <span class="hljs-keyword">return</span> new(length(coeff)-<span class="hljs-number">1</span>, coeff)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-string">"""
    InterpPolynomial &lt;: AbstractPolynomial

Interpolation polynomials in Newton's form

---

    InterpPolynomial(xsample::Vector{&lt;:Real}, fsample::Vector{&lt;:Real})

Construct an `InterpPolynomial` from a vector of points `xsample` and corresponding function values `fsample`. All values in `xsample` must be distinct.
"""</span>
<span class="hljs-keyword">struct</span> InterpPolynomial&lt;:AbstractPolynomial<font></font>
    degree::<span class="hljs-built_in">Int</span>
    xval::<span class="hljs-built_in">NTuple</span>{N, <span class="hljs-built_in">Float64</span>} <span class="hljs-keyword">where</span> N<font></font>
    coeff::<span class="hljs-built_in">NTuple</span>{N, <span class="hljs-built_in">Float64</span>} <span class="hljs-keyword">where</span> N
    <span class="hljs-keyword">function</span> InterpPolynomial(xsample::X,<font></font>
                              fsample::F) <span class="hljs-keyword">where</span> {X&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                                          <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}},<font></font>
                                                 F&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                                          <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}}}
        <span class="hljs-keyword">if</span> !allunique(xsample)<font></font>
            throw(<span class="hljs-built_in">DomainError</span>(<span class="hljs-string">"Cannot interpolate with duplicate X points"</span>))
        <span class="hljs-keyword">end</span><font></font>
        N = length(xsample)<font></font>
        <span class="hljs-keyword">if</span> length(fsample) != N<font></font>
            throw(<span class="hljs-built_in">DomainError</span>(<span class="hljs-string">"Lengths of X and F are not the same"</span>))
        <span class="hljs-keyword">end</span><font></font>
<font></font>
        coeff = [<span class="hljs-built_in">Float64</span>(f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fsample]<font></font>
<font></font>
        <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span>:N
            <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span>:(i-<span class="hljs-number">1</span>)<font></font>
                coeff[i] = (coeff[j] - coeff[i]) / (xsample[j] - xsample[i])<font></font>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        new(N-<span class="hljs-number">1</span>, ntuple(i -&gt; <span class="hljs-built_in">Float64</span>(xsample[i]), N), tuple(coeff...))
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> InterpPolynomial(fn, xsample::T) <span class="hljs-keyword">where</span> {T&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                                          <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}}}<font></font>
    InterpPolynomial(xsample, map(fn, xsample))<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> evpoly(p::Polynomial, z::<span class="hljs-built_in">Real</span>)<font></font>
    ans = p.coeff[<span class="hljs-keyword">end</span>]
    <span class="hljs-keyword">for</span> idx = p.degree:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span><font></font>
        ans = p.coeff[idx] + z * ans<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> evpoly(p::InterpPolynomial, z::<span class="hljs-built_in">Real</span>)<font></font>
    ans = p.coeff[p.degree+<span class="hljs-number">1</span>]
    <span class="hljs-keyword">for</span> idx = p.degree:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span><font></font>
        ans = ans * (z - p.xval[idx]) + p.coeff[idx]<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.:+(p1::Polynomial, p2::Polynomial)
    <span class="hljs-comment">#    ,     </span><font></font>
    deg = max(p1.degree, p2.degree)<font></font>
    coeff = zeros(deg+<span class="hljs-number">1</span>)<font></font>
<font></font>
    coeff[<span class="hljs-number">1</span>:p1.degree+<span class="hljs-number">1</span>] .+= p1.coeff<font></font>
    coeff[<span class="hljs-number">1</span>:p2.degree+<span class="hljs-number">1</span>] .+= p2.coeff<font></font>
<font></font>
    Polynomial(coeff)<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.:+(p1::InterpPolynomial, p2::InterpPolynomial)<font></font>
    xmax = max(p1.xval..., p2.xval...)<font></font>
    xmin = min(p1.xval..., p2.xval...)<font></font>
    deg = max(p1.degree, p2.degree)<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#      </span>
    xmid = <span class="hljs-number">0.5</span> * xmax + <span class="hljs-number">0.5</span> * xmin<font></font>
    dx = <span class="hljs-number">0.5</span> * (xmax - xmin) / cos(<span class="hljs-number">0.5</span> * <span class="hljs-literal">π</span> / (deg + <span class="hljs-number">1</span>))<font></font>
    chebgrid = [xmid + dx * cos((k - <span class="hljs-number">0.5</span>) * <span class="hljs-literal">π</span> / (deg + <span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:deg+<span class="hljs-number">1</span>]<font></font>
    fsample = [evpoly(p1, x) + evpoly(p2, x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> chebgrid]<font></font>
    InterpPolynomial(chebgrid, fsample)<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.:+(p1::InterpPolynomial, p2::Polynomial)<font></font>
    xmax = max(p1.xval...)<font></font>
    xmin = min(p1.xval...)<font></font>
    deg = max(p1.degree, p2.degree)<font></font>
    xmid = <span class="hljs-number">0.5</span> * xmax + <span class="hljs-number">0.5</span> * xmin<font></font>
    dx = <span class="hljs-number">0.5</span> * (xmax - xmin) / cos(<span class="hljs-number">0.5</span> * <span class="hljs-literal">π</span> / (deg + <span class="hljs-number">1</span>))<font></font>
    chebgrid = [xmid + dx * cos((k - <span class="hljs-number">0.5</span>) * <span class="hljs-literal">π</span> / (deg + <span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:deg+<span class="hljs-number">1</span>]<font></font>
    fsample = [evpoly(p1, x) + evpoly(p2, x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> chebgrid]<font></font>
    InterpPolynomial(chebgrid, fsample)<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.:+(p1::Polynomial, p2::InterpPolynomial)<font></font>
    p2 + p1<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造の形での多項式の表現は、数学関数としての直感的な理解に完全には対応していません。</font><font style="vertical-align: inherit;">ただし、関数値を返すことで、多項式を関数として直接指定することもできます。</font><font style="vertical-align: inherit;">だからそれは：</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> Polynomial<font></font>
    degree::<span class="hljs-built_in">Int</span>
    coeff::<span class="hljs-built_in">NTuple</span>{N, <span class="hljs-built_in">Float64</span>} <span class="hljs-keyword">where</span> N
    <span class="hljs-keyword">function</span> Polynomial(v::T <span class="hljs-keyword">where</span> T&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                            <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}})
        <span class="hljs-comment">#     /     P(x) ≡ 0</span>
        coeff = isempty(v) ? (<span class="hljs-number">0.0</span>,) : tuple([<span class="hljs-built_in">Float64</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> v]...)
        <span class="hljs-comment">#   -   new</span>
        <span class="hljs-comment">#  -   </span>
        <span class="hljs-keyword">return</span> new(length(coeff)-<span class="hljs-number">1</span>, coeff)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-string">"""
    evpoly(p::Polynomial, z::Real)

Evaluate polynomial `p` at `z` using the Horner's rule
"""</span>
<span class="hljs-keyword">function</span> evpoly(p::Polynomial, z::<span class="hljs-built_in">Real</span>)<font></font>
    ans = p.coeff[<span class="hljs-keyword">end</span>]
    <span class="hljs-keyword">for</span> idx = p.degree:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span><font></font>
        ans = p.coeff[idx] + z * ans<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定義を、係数の配列/タプルを取り、多項式を計算する実際の関数を返す関数に変換します。</font></font><br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> Polynomial_as_closure(v::T <span class="hljs-keyword">where</span> T&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                        <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}})
    <span class="hljs-comment">#     /     P(x) ≡ 0</span>
    <span class="hljs-keyword">if</span> isempty(v)
        <span class="hljs-keyword">return</span> x::<span class="hljs-built_in">Real</span> -&gt; <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">end</span><font></font>
    <font></font>
    coeff = tuple(map(float, v)...)<font></font>
    degree = length(coeff) - <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">function</span> evpoly(z::<span class="hljs-built_in">Real</span>)<font></font>
        ans = coeff[<span class="hljs-keyword">end</span>]
        <span class="hljs-keyword">for</span> idx = degree:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span><font></font>
            ans = coeff[idx] + z * ans<font></font>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> ans
    <span class="hljs-keyword">end</span><font></font>
<font></font>
    evpoly<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; p = Polynomial_as_closure((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment"># x² + x</span>
(::getfield(Main, <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"#evpoly#28"</span>)){<span class="hljs-built_in">Tuple</span>{<span class="hljs-built_in">Float64</span>,<span class="hljs-built_in">Float64</span>,<span class="hljs-built_in">Float64</span>},<span class="hljs-built_in">Int64</span>}) (generic <span class="hljs-keyword">function</span> with <span class="hljs-number">1</span> method)<font></font>
<font></font>
julia&gt; p(<span class="hljs-number">1</span>) <span class="hljs-comment"># ,    evpoly()!</span>
<span class="hljs-number">2.0</span>
julia&gt; p(<span class="hljs-number">11</span>)
<span class="hljs-number">132.0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、補間多項式の関数を作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な質問：以前の定義の新しい定義で失われたものはありましたか？</font><font style="vertical-align: inherit;">残念ながら、はい-多項式を構造体として定義すると、コンパイラーにヒントが与えられ、この構造体の算術演算子をオーバーロードすることができました。</font><font style="vertical-align: inherit;">残念ながら、ジュリアはそのような強力な型システムの機能を提供していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、この場合、Juliaでは、いわゆる呼び出し可能な構造体を作成できるため、両方の利点を活用できます。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">多項式を構造体として指定できますが、関数として呼び出すことができます！</font><font style="vertical-align: inherit;">前の記事の構造の定義に、次を追加するだけです。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> (p::Polynomial)(z::<span class="hljs-built_in">Real</span>)<font></font>
    evpoly(p, z)<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> (p::InterpPolynomial)(z::<span class="hljs-built_in">Real</span>)<font></font>
    evpoly(p, z)<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の引数を使用して、点のセットから構築された特定の関数の補間多項式の外部コンストラクターを追加することもできます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> InterpPolynomial(fn, xsample::T) <span class="hljs-keyword">where</span> {T&lt;:<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Vector</span>{&lt;:<span class="hljs-built_in">Real</span>},
                                                          <span class="hljs-built_in">NTuple</span>{&lt;:<span class="hljs-built_in">Any</span>, &lt;:<span class="hljs-built_in">Real</span>}}}<font></font>
    InterpPolynomial(xsample, map(fn, xsample))<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義を検証</font></font></b><div class="spoiler_text"><pre><code class="julia hljs">julia&gt; psin = InterpPolynomial(sin, [<span class="hljs-number">0</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">6</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">2</span>, <span class="hljs-number">5</span>*<span class="hljs-literal">π</span>/<span class="hljs-number">6</span>, <span class="hljs-literal">π</span>]) <span class="hljs-comment">#  </span>
InterpPolynomial(<span class="hljs-number">4</span>, (<span class="hljs-number">0.0</span>, <span class="hljs-number">0.5235987755982988</span>, <span class="hljs-number">1.5707963267948966</span>, <span class="hljs-number">2.6179938779914944</span>, <span class="hljs-number">3.141592653589793</span>), (<span class="hljs-number">0.0</span>, <span class="hljs-number">0.954929658551372</span>, -<span class="hljs-number">0.30396355092701327</span>, -<span class="hljs-number">0.05805276197975913</span>, <span class="hljs-number">0.036957536116863636</span>))<font></font>
julia&gt; pcos = InterpPolynomial(cos, [<span class="hljs-number">0</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">6</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">2</span>, <span class="hljs-number">5</span>*<span class="hljs-literal">π</span>/<span class="hljs-number">6</span>, <span class="hljs-literal">π</span>]) <span class="hljs-comment">#  </span>
InterpPolynomial(<span class="hljs-number">4</span>, (<span class="hljs-number">0.0</span>, <span class="hljs-number">0.5235987755982988</span>, <span class="hljs-number">1.5707963267948966</span>, <span class="hljs-number">2.6179938779914944</span>, <span class="hljs-number">3.141592653589793</span>), (<span class="hljs-number">1.0</span>, -<span class="hljs-number">0.2558726308373678</span>, -<span class="hljs-number">0.36358673785585766</span>, <span class="hljs-number">0.1388799037738005</span>, <span class="hljs-number">5.300924469105863e-17</span>))<font></font>
julia&gt; psum = pcos + psin <font></font>
InterpPolynomial(<span class="hljs-number">4</span>, (<span class="hljs-number">3.141592653589793</span>, <span class="hljs-number">2.5416018461576297</span>, <span class="hljs-number">1.5707963267948966</span>, <span class="hljs-number">0.5999908074321635</span>, <span class="hljs-number">0.0</span>), (-<span class="hljs-number">1.0</span>, -<span class="hljs-number">1.2354929267138448</span>, <span class="hljs-number">0.03888175053443867</span>, <span class="hljs-number">0.1969326657535598</span>, <span class="hljs-number">0.03695753611686364</span>))<font></font>
julia&gt; <span class="hljs-keyword">for</span> x = range(<span class="hljs-number">0</span>, <span class="hljs-literal">π</span>, length = <span class="hljs-number">20</span>)<font></font>
           println(<span class="hljs-string">"Error at x = "</span>, x, <span class="hljs-string">": "</span>, abs(psum(x) - (sin(x) + cos(x))))
       <span class="hljs-keyword">end</span>
Error at x = <span class="hljs-number">0.0</span>: <span class="hljs-number">0.0</span>
Error at x = <span class="hljs-number">0.3490658503988659</span>: <span class="hljs-number">0.002748366490382681</span>
Error at x = <span class="hljs-number">0.6981317007977318</span>: <span class="hljs-number">0.0031870524474437723</span>
Error at x = <span class="hljs-number">1.0471975511965976</span>: <span class="hljs-number">0.006538414090220712</span>
Error at x = <span class="hljs-number">1.3962634015954636</span>: <span class="hljs-number">0.0033647273630357244</span>
Error at x = <span class="hljs-number">1.7453292519943295</span>: <span class="hljs-number">0.003570894863996865</span>
Error at x = <span class="hljs-number">2.0943951023931953</span>: <span class="hljs-number">0.007820939854677023</span>
Error at x = <span class="hljs-number">2.443460952792061</span>: <span class="hljs-number">0.004305934583281101</span>
Error at x = <span class="hljs-number">2.792526803190927</span>: <span class="hljs-number">0.00420977797025246</span>
Error at x = <span class="hljs-number">3.141592653589793</span>: <span class="hljs-number">1.1102230246251565e-16</span>
</code></pre><br>
</div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジュリアの関数型プログラミングから借りた機会は、純粋に命令的なスタイルと比較してより表現力豊かな言語を提供します。</font><font style="vertical-align: inherit;">関数形式での構造の表現は、数学的概念のより便利で自然な記録の方法です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451160/index.html">Apache KafkaとSparkストリーミングによるストリーミング</a></li>
<li><a href="../ja451162/index.html">エラー修正-現在のバージョンと新しいバージョンの国際単位系（SI）の物理定数</a></li>
<li><a href="../ja451164/index.html">Pythonで無料の駐車スペースを探す</a></li>
<li><a href="../ja451166/index.html">AIおよびMOシステム用の新しいストレージは何を提供しますか？</a></li>
<li><a href="../ja451170/index.html">ジェフ・ベゾスは月を征服する計画を発表しました</a></li>
<li><a href="../ja451174/index.html">ZXスペクトラムのプログラムを最新の手段でTR-DOSに適合させます。パート1</a></li>
<li><a href="../ja451176/index.html">OpenStreetMap No. 458の世界からのニュース（2019年4月23日-2019年4月9日）</a></li>
<li><a href="../ja451178/index.html">搭乗員ドラゴンパラシュート着陸時の衝突試験</a></li>
<li><a href="../ja451180/index.html">PCBは2つのリニアモーターを置き換えます</a></li>
<li><a href="../ja451182/index.html">C配列のサイズがライブラリバイナリインターフェイスの一部になった方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>