<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø ü•Ö üïäÔ∏è Structures de donn√©es: une liste qui peut tout faire * üéñÔ∏è ü§• ü§¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Par tout, je veux dire l'ex√©cution relativement rapide des op√©rations sur un seul √©l√©ment d'un tableau. 
 
 Les structures de donn√©es qui impl√©mente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Structures de donn√©es: une liste qui peut tout faire *</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Par tout, je veux dire l'ex√©cution relativement rapide des op√©rations sur un seul √©l√©ment d'un tableau. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les structures de donn√©es qui impl√©mentent la liste sont compl√®tes. </font><font style="vertical-align: inherit;">Chacun a ses avantages et ses inconv√©nients. </font><font style="vertical-align: inherit;">Par exemple, dans le monde Java - selon les op√©rations n√©cessaires - vous pouvez utiliser:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (obj), get (obj), set (index, obj): un ensemble de base de presque toutes les listes, par exemple ArrayList. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (index, obj): structures arborescentes, par exemple TreeList from apache common-collections. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (index): comme ci-dessus. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient (obj), indexOf (obj): vous pouvez utiliser un tas d'ArrayList et HashMap. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (obj): ... j'ai du mal √† r√©pondre. </font><font style="vertical-align: inherit;">Dans certains cas, vous pouvez vous en tirer avec un LinkedHashSet. </font><font style="vertical-align: inherit;">Il est r√©solu trivialement en pr√©sence des deux points pr√©c√©dents, mais quelles structures peuvent √† la fois rapidement?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque j'avais besoin d'une structure avec ajout rapide (obj), get (index), remove (index) et indexOf (obj), google n'a pas donn√© de r√©ponse. Je n'ai trouv√© aucun exemple de code ou description de telles structures. Peut-√™tre que je n'y regardais pas, j'ai d√ª l'inventer moi-m√™me. Mais si quelqu'un laisse tomber le lien dans les commentaires, je l'appr√©cierai grandement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-√™tre que quelqu'un a r√©alis√© que vous pouvez prendre une TreeList, qui peut rapidement ins√©rer / supprimer des √©l√©ments au milieu de la liste et ajouter un HashMap de l'objet √† l'index dans la TreeList pour une ex√©cution rapide de indexOf (obj). Et ce sera une d√©cision simple, √©l√©gante, mais incorrecte. Apr√®s tout, lors de l'ajout au milieu ou de la suppression du milieu, il sera n√©cessaire de recalculer les indices, en moyenne, pour la moiti√© des √©l√©ments. Cela d√©gradera les performances en O (n).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, je vais parler d'une structure de donn√©es qui peut faire tout ce qui pr√©c√®de. Qui effectue toute op√©ration sur un √©l√©ment en temps O (log (n)). Eh bien, presque - car le logarithme est effectu√© dans le cas o√π tous les objets de la liste sont diff√©rents. Si la liste contient les m√™mes objets, il est possible d'affaiblir les performances jusqu'√† O (log (n) ^ 2).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vous pr√©viens tout de suite que je ne peindrai pas le code ici. </font><font style="vertical-align: inherit;">Cela peut √™tre assez compliqu√© pour l'article. </font><font style="vertical-align: inherit;">Mais c'est √©crit en Java. </font><font style="vertical-align: inherit;">Bas√© sur la classe TreeList d'Apache Common-Collections. </font><font style="vertical-align: inherit;">La demande de tirage existe d√©j√†, mais au moment de la r√©daction, l'article n'est pas encore vers√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, je ne d√©crirai pas des algorithmes bien connus. </font><font style="vertical-align: inherit;">Par exemple, les algorithmes d'√©quilibrage des arbres. </font><font style="vertical-align: inherit;">Pour la plupart, il peut suffire de tenir pour acquis le fait que l'arbre peut √™tre maintenu en √©quilibre. </font><font style="vertical-align: inherit;">Cela n'affecte pas la compr√©hension de l'id√©e g√©n√©rale. </font><font style="vertical-align: inherit;">Ceux qui veulent en savoir plus peuvent facilement trouver des informations. </font><font style="vertical-align: inherit;">Mais je vais vous parler tr√®s bri√®vement de certaines choses de base, car sans la connaissance des bases, de nombreux √©l√©ments cl√©s ne peuvent pas √™tre compris. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les liens seront √† la fin.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi est-ce n√©cessaire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, ce n'est pas si facile de trouver des situations o√π tout est n√©cessaire directement √† partir de la liste. </font><font style="vertical-align: inherit;">Il est peu probable que ce soit une sorte de structure super n√©cessaire, sinon tout le monde le saurait. </font><font style="vertical-align: inherit;">Cependant, quelques exemples o√π une telle liste pourrait √™tre utile peuvent √™tre donn√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je reconnais que de nombreux exemples sont farfelus. </font><font style="vertical-align: inherit;">Tout ou presque peut √™tre r√©solu d'une autre mani√®re.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en cache et compression</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ma t√¢che initiale, √† cause de laquelle j'ai commenc√© √† rechercher la question. </font><font style="vertical-align: inherit;">Jou√© avec la compression de donn√©es sp√©cifiques et avait besoin d'une liste pour le cache d'objets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e est la suivante: lors du traitement d'un autre objet, nous le recherchons dans la liste. </font><font style="vertical-align: inherit;">S'il n'est pas trouv√©, enregistrez l'objet et ajoutez-le en haut de la liste. </font><font style="vertical-align: inherit;">S'il est trouv√©, nous prenons son index dans la liste et au lieu de l'objet, nous enregistrons uniquement son index, apr√®s quoi nous d√©pla√ßons l'objet en haut de la liste. </font><font style="vertical-align: inherit;">Ainsi, les objets qui se produisent re√ßoivent souvent de petits index et les objets qui se produisent une seule fois finissent par se d√©placer √† la fin de la liste et sont supprim√©s.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tour</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si, au lieu de la file d'attente FIFO habituelle, pour certaines t√¢ches, une structure similaire est utilis√©e, les op√©rations suivantes peuvent √™tre effectu√©es:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©pondez √† la question: combien de t√¢ches sont dans la file d'attente avant cette t√¢che. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimez les t√¢ches de la file d'attente. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C‚Äôest comme dans un supermarch√©. </font><font style="vertical-align: inherit;">Si vous √™tes venu pour une barre de chocolat, mais que vous voyez que la ligne se d√©place lentement, alors peut-√™tre que la barre de chocolat n'est pas si n√©cessaire? </font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tableau des meilleurs scores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous voulons stocker le temps pendant lequel les joueurs terminent un niveau dans une partie. </font><font style="vertical-align: inherit;">Il y a beaucoup de joueurs et ils s'affrontent tous, essayant de montrer le temps minimum. </font><font style="vertical-align: inherit;">Les donn√©es des joueurs peuvent √™tre plac√©es dans un tableau et tri√©es par heure. </font><font style="vertical-align: inherit;">En utilisant cette structure, vous pouvez:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©placez les joueurs plus haut dans la liste s'ils montrent de meilleurs r√©sultats qu'auparavant. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimez des joueurs de la liste, par exemple, en cas d'interdiction de tricherie. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montrez √† chaque joueur o√π il se trouve. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher le tableau des enregistrements page par page. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher une table clairsem√©e √† des endroits, par exemple, temps 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000 endroits. </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure de donn√©es</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure est bas√©e sur un arbre avec une cl√© implicite. </font><font style="vertical-align: inherit;">C'est sur cette approche, par exemple, que se base TreeList dans apache common-collections. </font><font style="vertical-align: inherit;">Pour continuer, vous devez comprendre le fonctionnement de cette structure.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbre de cl√© implicite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un arbre se compose de n≈ìuds (n≈ìuds). </font><font style="vertical-align: inherit;">Chaque n≈ìud contient un lien vers un objet qui est stock√© dans le n≈ìud et 2 liens vers d'autres n≈ìuds: gauche et droite. </font><font style="vertical-align: inherit;">Le n≈ìud sup√©rieur est appel√© n≈ìud racine. </font><font style="vertical-align: inherit;">Dans le cas le plus simple, le n≈ìud ressemble √† ceci:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'arbre binaire classique pour chaque n≈ìud dans le sous-arbre gauche, tous les objets sont plus petits que dans le n≈ìud actuel, et dans la droite - grands. </font><font style="vertical-align: inherit;">Par exemple:</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pour notre objectif, un tel arbre ne convient pas. Nous n'avons pas besoin de stocker les objets tri√©s, mais nous devons y avoir acc√®s par index, comme dans un tableau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment puis-je mettre un tableau dans un arbre? S√©lectionnons un √©l√©ment d'index i au milieu du tableau. Placez le i√®me √©l√©ment du tableau dans le n≈ìud racine. 2 sous-arbres quittent le n≈ìud racine. Dans le sous-arbre gauche, nous mettons la moiti√© du tableau avec index &lt;i, et dans le droit avec index&gt; i. Comment faire? De la m√™me mani√®re: nous s√©lectionnons un √©l√©ment du milieu dans un sous-tableau, mettons cet √©l√©ment dans un n≈ìud, nous obtenons 2 sous-r√©seaux plus petits. Et donc jusqu'√† ce que nous mettions tous les √©l√©ments du tableau dans les n≈ìuds de l'arbre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, un tableau avec les √©l√©ments ["q", "w", "e", "r", "t", "y", "u"] pourrait ressembler √† ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©l√©ment du milieu dans le tableau ¬´r¬ª, nous le mettons dans le n≈ìud racine. Deux sous-r√©seaux ["q", "w", "e"] et ["t", "y", "u"] sont plac√©s dans les sous-arbres gauche et droit. Pour cela, les √©l√©ments centraux sont s√©lectionn√©s dans les sous-r√©seaux, dans notre cas ce sont ¬´w¬ª et ¬´y¬ª, et ils tombent dans les n≈ìuds du niveau suivant. Et ainsi de suite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, l'arbre est √©quilibr√©, la profondeur de tous les sous-arbres est la m√™me. Mais il ne doit pas en √™tre ainsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'image ci-dessus, chaque n≈ìud, en plus de l'√©l√©ment et des liens vers les n≈ìuds gauche et droit, contient le nombre d'√©l√©ments de l'ensemble du sous-arbre. Ces informations doivent √™tre mises √† jour correctement lorsque l'arborescence change. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment trouver, par exemple, un √©l√©ment avec index = 4 dans un tel arbre.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commen√ßons l'analyse √† partir du n≈ìud racine (racine, dans notre cas avec l'√©l√©ment ¬´r¬ª). Nous avons 3 options: nous sommes d√©j√† sur le n≈ìud droit, le n≈ìud droit sur la gauche, le n≈ìud droit sur la droite. Afin de comprendre o√π chercher l'√©l√©ment souhait√©, vous devez comparer la taille du sous-arbre gauche (dans notre cas, left.size = 3) et l'indice actuel (dans notre cas 4). Si ces 2 nombres sont √©gaux, alors nous y avons trouv√© le n≈ìud n√©cessaire et l'√©l√©ment souhait√©. Si la taille du sous-arbre gauche est plus grande, alors le n≈ìud requis dans le sous-arbre gauche. Si c'est moins, alors vous devez regarder dans le sous-arbre de droite, mais vous devez r√©duire l'index souhait√©: index = index - left.size - 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que dans notre cas, left.size &lt;index, nous recherchons dans le sous-arbre de droite l'√©l√©ment avec le nouvel index 4 - 3 - 1 = 0. Acc√©dez au n≈ìud avec l'√©l√©ment ¬´y¬ª.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous faisons la m√™me chose que nous avons fait dans le n≈ìud racine. Comparez left.size et index. Depuis 1&gt; 0, nous regardons dans le sous-arbre gauche, passons au n≈ìud avec l'√©l√©ment ¬´t¬ª. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a pas de sous-arbre gauche dans ce noeud, et sa taille est 0. index = left.size, ce qui signifie que nous avons trouv√© un noeud avec l'index 4 et pouvons en obtenir l'√©l√©ment "t" requis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pseudo code, cela ressemble √† ceci:</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index ‚Äî leftSize ‚Äî <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai essay√© de d√©crire le principe cl√© de la fa√ßon de mettre un tableau dans un arbre. </font><font style="vertical-align: inherit;">Une telle structure fonctionne, bien s√ªr, plus lentement que le tableau classique, pour O (log (n)) contre O (1). </font><font style="vertical-align: inherit;">Mais il pr√©sente un avantage important: l'ajout d'un √©l√©ment au milieu ou la suppression du milieu fonctionne √©galement pour O (log (n)) par rapport √† O (n) pour le tableau. </font><font style="vertical-align: inherit;">Bien s√ªr, √† condition que l'arbre soit plus ou moins √©quilibr√©. </font><font style="vertical-align: inherit;">Il existe de nombreux algorithmes pour maintenir un arbre de mani√®re presque √©quilibr√©e. </font><font style="vertical-align: inherit;">Par exemple, arbre rouge-noir, arbre AVL, arbre cart√©sien. </font><font style="vertical-align: inherit;">Je n'√©crirai pas les d√©tails de l'√©quilibrage de l'arbre, tout algorithme nous convient. </font><font style="vertical-align: inherit;">Supposons simplement que l'arbre est √©quilibr√© en moyenne et que sa profondeur maximale n'est pas tr√®s diff√©rente du minimum.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√©g√®re optimisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche d√©crite ci-dessus, avec la v√©rification de la taille de l'arbre √† gauche est pratique pour la perception, mais peut √™tre effectu√©e un peu plus efficacement. Afin de ne pas regarder dans le sous-arbre gauche √† chaque fois, au lieu de la taille de l'arbre, on peut stocker dans le n≈ìud sa position par rapport √† la position de son n≈ìud parent. Le n≈ìud racine stocke une position absolue qui correspond √† la taille du sous-arbre gauche.</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, le n≈ìud racine ¬´r¬ª a la position 3. Le n≈ìud ¬´w¬ª a la position -2 par rapport au n≈ìud parent ou la position absolue 3 + (-2) = 1. De m√™me, vous pouvez descendre d'un niveau suppl√©mentaire, par exemple, le n≈ìud ¬´e¬ª a la position 3 + (-2) + (+1) = 2. Autrement dit, </font><font style="vertical-align: inherit;">l'indice de n≈ìud est la somme des positions de la racine de l'arbre √† ce n≈ìud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette optimisation, en plus d'une recherche plus rapide d'un √©l√©ment dans la liste, permettra une recherche plus rapide et plus facile de l'index sur le n≈ìud. </font><font style="vertical-align: inherit;">Mais, bien s√ªr, la mise √† jour correcte de la position lors du changement d'arbre est devenue un peu plus difficile.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter l'indexation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, dans l'arbre, nous pouvons prendre un √©l√©ment par index, changer sa valeur, ajouter des √©l√©ments au milieu et supprimer. Essentiellement, nous avons juste besoin d'ajouter une recherche d'index rapide par valeur, indexOf (obj). Ensuite, contient (obj) et supprimer (obj) sera r√©solu trivialement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais d'abord, simplifions un peu la t√¢che. Faisons une structure qui ne stocke que des √©l√©ments uniques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de rechercher rapidement quelque chose, ils utilisent g√©n√©ralement une table. Dans le monde Java, les tables sont appel√©es Map; elles ont 2 impl√©mentations principales: HashMap et TreeMap. La cl√© de la table sera un lien vers l'objet et la valeur sera un lien vers son n≈ìud:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. la structure se compose de deux parties: l'arborescence de la liste elle-m√™me et le tableau avec des liens vers les objets et les n≈ìuds de cet arbre. Lors de la mise √† jour de l'arborescence, la table doit √©galement √™tre mise √† jour. Je ne d√©crirai pas le processus en d√©tail. Intuitivement, cela devrait √™tre compr√©hensible: ajoutez un n≈ìud - mettez-le dans le tableau, supprimez le n≈ìud - supprimez-le de la table. Dans la pratique, il y a des nuances √† √©quilibrer l'arbre: l'algorithme doit changer les liens entre les n≈ìuds et ne pas d√©placer les objets entre les n≈ìuds. Sinon, vous devrez effectuer de nombreuses mises √† jour dans le tableau et les performances chuteront. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, nous supposerons que nous pouvons trouver rapidement le n≈ìud par l'√©l√©ment qu'il contient. Et alors? Nous devons trouver son index, mais cela ne peut pas encore √™tre fait. Mais nous pouvons compliquer la classe de n≈ìuds afin qu'elle contienne non seulement des liens vers les n≈ìuds gauche et droit, mais aussi vers son parent:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, la mise √† jour de l'arbre est un peu plus compliqu√©e, car maintenant nous devons soigneusement mettre √† jour le lien vers le parent. Mais maintenant, connaissant le n≈ìud, nous pouvons remonter dans l'arbre et calculer l'indice de n'importe quel n≈ìud. Si nous avons utilis√© l'optimisation du chapitre pr√©c√©dent, il nous suffit de calculer la somme des positions du n≈ìud actuel √† la racine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une liste contenant des √©l√©ments uniques, le probl√®me peut √™tre consid√©r√© comme r√©solu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certes, nous avons un petit probl√®me. </font><font style="vertical-align: inherit;">Supposons que nous appelons set (index, obj). </font><font style="vertical-align: inherit;">Nous pouvons facilement remplacer un √©l√©ment d'un n≈ìud par un autre, mais uniquement s'il n'y a pas encore de nouvel √©l√©ment dans la liste. </font><font style="vertical-align: inherit;">Et si oui, que dois-je faire? </font><font style="vertical-align: inherit;">Retirer l'article en exc√®s de l'ancienne position et en mettre un nouveau? </font><font style="vertical-align: inherit;">Ou vice versa, ajoutez d'abord, puis supprimez? </font><font style="vertical-align: inherit;">Le r√©sultat peut √™tre diff√©rent. </font><font style="vertical-align: inherit;">Et vous ne pouvez rien faire du tout ou lever une exception. </font><font style="vertical-align: inherit;">Il n'y a pas de solution parfaite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri par des m√©thodes standard d'une telle liste, tr√®s probablement, ne fonctionnera pas non plus. </font><font style="vertical-align: inherit;">Apr√®s tout, l'algorithme de tri ne conna√Ætra pas la n√©cessit√© d'unicit√© des objets et cr√©era des doublons lors du d√©placement des √©l√©ments dans la liste.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous supprimons l'unicit√©</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, compliquant encore les choses, gardons les m√™mes objets. De toute √©vidence, vous devez faire quelque chose avec la table. La premi√®re id√©e d'y stocker une liste de n≈ìuds ne semble pas tr√®s bonne: avec une augmentation de la longueur de la liste, les performances vont se d√©grader. Jusqu'√† O (n) si tous les √©l√©ments de la liste sont identiques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons ensuite de stocker un arbre tri√© de n≈ìuds dans une table au lieu d'une liste. Tri√© par position dans la liste.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, l'insertion / suppression vers / depuis le TreeSet &lt;Node&gt; de taille m se produira pendant les comparaisons log (m) des positions des n≈ìuds, et chaque comparaison se produira sur la dur√©e log (n). La complexit√© finale de l'insertion ou de la suppression dans une structure similaire se produira dans O (log (n) * (1 + log (m))), o√π n est le nombre total d'√©l√©ments dans la liste et m est le nombre d'√©l√©ments dans la liste √©gal √† l'ins√©r√© / supprim√©. Dans le pire des cas, lorsque tous les √©l√©ments sont √©gaux, on obtient la complexit√© O (log (n) ^ 2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un lecteur attentif objectera probablement: mais qu'en est-il de l'immuabilit√©? </font><font style="vertical-align: inherit;">Apr√®s tout, nous ne pouvons pas changer les objets s'ils sont des cl√©s de table? </font><font style="vertical-align: inherit;">En g√©n√©ral, c'est le cas. </font><font style="vertical-align: inherit;">Cependant, pour un arbre qui stocke des objets tri√©s dans des cl√©s, en plus des r√®gles standard de comparaison, il suffit de conserver l'invariant: si a &lt;b, alors cette propri√©t√© ne doit pas changer avec le temps. </font><font style="vertical-align: inherit;">C'est juste notre cas: si la position d'un n≈ìud est inf√©rieure √† la position d'un autre n≈ìud, alors cette propri√©t√© sera pr√©serv√©e quel que soit le nombre de n≈ìuds ajout√©s ou supprim√©s entre eux.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est-il possible de rendre la structure persistante?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R√©ponse courte: non, c'est impossible. </font><font style="vertical-align: inherit;">En raison de la biconnectivit√© de l'arbre, de la racine aux feuilles et en arri√®re, nous avons chaque n≈ìud d'arbre connect√© √† chacun. </font><font style="vertical-align: inherit;">La persistance ne peut pas √™tre effectu√©e de cette mani√®re; vous devez recr√©er la structure enti√®re avec n'importe quel changement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais j'ai une compr√©hension de la fa√ßon de mettre en ≈ìuvre une structure persistante pour les cas o√π nous n'avons pas besoin d'ins√©rer des √©l√©ments au milieu de la liste. </font><font style="vertical-align: inherit;">Vous pouvez ajouter des √©l√©ments au d√©but ou √† la fin, et vous pouvez supprimer du milieu. </font><font style="vertical-align: inherit;">Les propri√©t√©s restantes sont les m√™mes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cela vous int√©resse, je vais essayer d'√©crire un article sur cette structure. </font><font style="vertical-align: inherit;">Peut-√™tre m√™me que je l'impl√©mente en Java, Kotlin ou Scala. </font><font style="vertical-align: inherit;">Mais, tr√®s probablement, ce ne sera pas bient√¥t.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques fonctionnalit√©s d'impl√©mentation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, je veux d√©crire certaines caract√©ristiques auxquelles j'ai d√ª faire face. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä propos de l'une des optimisations concernant le stockage de la position du n≈ìud dans la liste, j'ai √©crit ci-dessus. Ici, la force de l'Open Source se manifeste: j'ai pris le code TreeList pr√™t √† l'emploi et je n'ai pas fouill√© les d√©tails de l'arborescence AVL, les rotations de n≈ìuds, les mises √† jour de position, etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre fonctionnalit√© h√©rit√©e de TreeList est les liens vers les sous-arbres dans les feuilles des arbres. Chaque n≈ìud stocke les bool√©ens leftIsPrevious et rightIsNext. Ces variables indiquent la pr√©sence ou l'absence d'un sous-arbre gauche / droit. S'il n'y a pas de sous-arbre, alors √† gauche / droite, au lieu d'un lien vers le sous-arbre, un lien vers le n≈ìud qui correspond √† l'√©l√©ment pr√©c√©dent ou suivant est stock√©. Dans notre exemple, ["q", "w", "e", "r", "t", "y", "u"] le n≈ìud "e" est feuillu, il n'a pas de sous-arbres. En cons√©quence, leftIsPrevious et rightIsNext sont vrais, et gauche et droite pointent vers les n≈ìuds "w" et "r", respectivement. Cette approche permet de parcourir la liste plus rapidement. Et cela interf√®re avec la programmation de nouvelles fonctionnalit√©s :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un peu sur l'utilisation de l'objet table ‚Üí n≈ìud. Id√©alement, vous devez placer un √©l√©ment dans le tableau une fois lors de son ajout √† la structure et le supprimer une fois lors de la suppression de la structure. En pratique, je n'ai pas pu y parvenir. Lorsque vous ajoutez un √©l√©ment, il est ajout√© au tableau, tout est comme il se doit. Cependant, lorsque vous supprimez un √©l√©ment, l'algorithme d'√©quilibrage d√©place parfois des √©l√©ments entre les n≈ìuds. Le r√©sultat est deux suppressions et un enregistrement dans la table au lieu d'une suppression. Cela peut √™tre r√©solu si vous supprimez l'optimisation de leftIsPrevious et rightIsNext. Et m√™me obtenir un petit gain de performances, et pas seulement lors de la suppression. Dans certains tests, l'augmentation √©tait de 10 √† 20%. Mais la vitesse d'it√©ration chute consid√©rablement, 1,5 √† 2,5 fois dans mes tests. J'ai d√©cid√© de laisser l'optimisation pour l'instant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java, les principaux types de tables sont HashMap et TreeMap. Pour une table, un objet ‚Üí un n≈ìud utilise HashMap par d√©faut. Cependant, vous pouvez utiliser TreeMap avec un comparateur sp√©cifique √† la t√¢che. Dans ce cas, indexOf (obj) et remove (obj) rechercheront / supprimeront l'objet qui est √©gal √† l'objet sp√©cifi√© selon le code du comparateur. Par exemple, nous stockons une liste d'utilisateurs et le comparateur compare les utilisateurs uniquement par leur nom. Ensuite, nous pouvons r√©pondre √† la question ¬´Quelles positions de la liste sont les utilisateurs avec le nom¬´ Napol√©on? ¬ª¬ª. Ou supprimez tous les Napol√©on de la liste :). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure ne prend pas en charge null. Vous pouvez le r√©parer, mais il n'y a aucun sentiment que c'est n√©cessaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ce qui concerne le fait que la structure ¬´sait tout¬ª, j'√©tais bien s√ªr un peu trompeur. </font><font style="vertical-align: inherit;">Bien s√ªr, lorsque vous travaillez avec des √©l√©ments uniques, tout va bien et dans certaines conditions, m√™me pour le logarithme. </font><font style="vertical-align: inherit;">Cependant, elle ne sait pas certaines choses que d'autres structures peuvent. </font><font style="vertical-align: inherit;">Par exemple, un arbre cart√©sien avec une cl√© implicite, il y avait des articles √† ce sujet sur le hub </font><font style="vertical-align: inherit;">Il ne sait pas comment faire rapidement indexOf, mais il peut faire une sous-liste et concat√©ner deux listes en une pour le logarithme (en moyenne, non garanti), en plus il peut √™tre rendu persistant.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java, les performances sont g√©n√©ralement mesur√©es √† l'aide du framework jmh. </font><font style="vertical-align: inherit;">Des tests ont √©t√© effectu√©s sur le MacBook Pro 2017 sous Java11. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai compar√© les performances de la ArrayList standard, TreeList de apache common-collections, et mes deux classes IndexedTreeList et IndexedTreeListSet dans plusieurs sc√©narios. </font><font style="vertical-align: inherit;">Dans chaque sc√©nario, 1000 op√©rations du m√™me type ont √©t√© effectu√©es, le r√©sultat doit donc √™tre multipli√© par 1000.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code sous le spoiler</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, j'ai compar√© la vitesse d'obtention d'un √©l√©ment al√©atoire dans une liste. </font><font style="vertical-align: inherit;">Je vous pr√©viens tout de suite que dans ce test, les frais g√©n√©raux sont tr√®s importants. </font><font style="vertical-align: inherit;">Les r√©sultats approchant 100 000 * 1 000 op√©rations par seconde sont gravement fauss√©s.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenez le r√©sultat du test</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ¬± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ¬±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ¬±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ¬±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ¬± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ¬±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ¬±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ¬±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ¬±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ¬±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ¬±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ¬±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ¬±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ¬±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ¬±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ¬±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ¬±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ¬±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ¬±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ¬±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ¬±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ¬±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ¬±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ¬±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, curieusement, le plus grand int√©r√™t est le ArrayList standard. Th√©oriquement, la vitesse de sortie devrait √™tre constante et ne pas d√©pendre du nombre d'√©l√©ments. En pratique, les performances d√©tiennent d'abord environ 90 000 * 1 000 op√©rations par seconde (rappelez-vous les frais g√©n√©raux), mais avec une longueur de liste de plusieurs milliers d'√©l√©ments, elles commencent √† s'affaisser. Cela est d√ª au manque de cache de plus en plus fr√©quent: le cache du processeur n'a pas les donn√©es n√©cessaires et de plus en plus souvent vous devez aller chercher des donn√©es dans la RAM. Avec un million d'√©l√©ments, la vitesse du test est 10 fois inf√©rieure, mais en pratique, le rabattement des performances est encore plus important.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList, IndexedTreeList et IndexedTreeListSet devraient afficher des r√©sultats similaires. </font><font style="vertical-align: inherit;">Attendu beaucoup plus lentement qu'ArrayList. </font><font style="vertical-align: inherit;">M√™me avec un petit nombre d'√©l√©ments, TreeList est plusieurs fois plus lent qu'ArrayList, bien que le test ne montre la diff√©rence que 2 fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le prochain test est addRemoveRandom. </font><font style="vertical-align: inherit;">Ici, dans chaque test, j'ins√®re un √©l√©ment dans une position al√©atoire et je supprime un √©l√©ment d'une position al√©atoire.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat du test AddRemoveRandom</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ¬±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ¬±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ¬±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ¬±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ¬±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ¬±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ¬±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ¬±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ¬±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ¬±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ¬±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ¬±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ¬±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ¬±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ¬±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ¬±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ¬±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ¬±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ¬±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ¬±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ¬±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ¬±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ¬±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ¬±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On pourrait supposer qu'ArrayList est plus rapide sur de petites listes. </font><font style="vertical-align: inherit;">Cependant, le fait qu'il gagne dans ce test sur des listes allant jusqu'√† 10 000 √©l√©ments semble int√©ressant. </font><font style="vertical-align: inherit;">Apparemment, System.arrayCopy est tr√®s bien optimis√© et utilise toutes les fonctionnalit√©s des processeurs modernes. </font><font style="vertical-align: inherit;">√Ä partir de 10 000 √©l√©ments, les structures de donn√©es sp√©cialis√©es commencent √† gagner. </font><font style="vertical-align: inherit;">Avec 1 000 000 d'√©l√©ments, la diff√©rence de vitesse est de 30 √† 50 fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IndexedTreeList et IndexedTreeListSet devraient √™tre plus lents que TreeList. </font><font style="vertical-align: inherit;">Environ 1,5 √† 2 fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les 2 tests restants indexOfKnown et indexOfUnknown devraient simplement d√©montrer la caract√©ristique principale de cette structure. </font><font style="vertical-align: inherit;">La diff√©rence entre les tests est que dans un cas, nous recherchons un √©l√©ment qui est dans la liste, et dans l'autre cas, nous recherchons un √©l√©ment qui n'est pas dans la liste.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat du test indexOfKnown et indexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ¬±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ¬±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ¬±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ¬±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ¬±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ¬±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ¬±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ¬±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ¬±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ¬±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ¬±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ¬±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ¬±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ¬±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ¬±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ¬±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ¬±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ¬±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ¬±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ¬±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ¬±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ¬±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ¬±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ¬±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ¬±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ¬±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ¬±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ¬±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ¬±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ¬±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ¬±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ¬±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ¬±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ¬±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ¬±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ¬±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ¬±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ¬±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ¬±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ¬±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ¬±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ¬±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ¬± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ¬±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ¬±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ¬±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ¬±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ¬±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, ArrayList et TreeList n'ont presque aucune surprise. Avec une taille croissante, la vitesse diminue presque lin√©airement. La recherche d'un √©l√©ment d'une non-liste devrait √™tre 2 fois plus lente que la recherche d'un √©l√©ment de la liste, car vous devez parcourir l'ensemble du tableau au lieu de la moiti√© en moyenne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais IndexedTreeList et IndexedTreeListSet montrent ici le bon r√©sultat attendu. Ces structures de donn√©es montrent une vitesse d'ex√©cution indexOf comparable √† ArrayList m√™me avec 10 √©l√©ments. Avec 1 000 √©l√©ments, ces structures sont 10 fois plus rapides, avec 1 000 000 plus rapides 1 000 fois. Lors de la recherche d'un √©l√©ment qui ne figure pas dans la liste, ils sont cens√©s donner une meilleure vitesse que lors de la recherche d'un √©l√©ment dans la liste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est √©galement int√©ressant de pr√™ter attention √† l'affaissement des performances d'IndexedTreeList et IndexedTreeListSet dans le test indexOfUnknown. </font><font style="vertical-align: inherit;">Ici, la situation est similaire √† celle du test avec ArrayList.get. </font><font style="vertical-align: inherit;">Th√©oriquement, nous n'aurions pas d√ª obtenir une baisse des performances, mais dans la pratique, en raison d'un √©chec de cache, nous l'avons obtenu, en outre, de mani√®re significative.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu d'une conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne sais toujours pas si la structure propos√©e a une nouveaut√© ou non. D'une part, l'id√©e n'est pas compliqu√©e si vous savez comment fonctionne l'arbre par une cl√© implicite. Par contre, je n'ai pas vu de description d'une structure avec de telles propri√©t√©s. Et si oui, alors il est logique de rendre la structure plus c√©l√®bre, cela pourrait √™tre utile √† quelqu'un. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais m√™me s'il s'agit d'un autre v√©lo, j'ai essay√© de le rendre utile. Une demande de tirage dans les collections communes a √©t√© cr√©√©e, mais au moment de la r√©daction de cet article, cet article n'est pas encore vers√©. Sachant √† quel point tout peut arriver lentement en open source, je ne serai pas surpris si le processus se prolonge pendant des mois.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un peu surpris par le r√©sultat de la comparaison des performances d'ArrayList et TreeList. </font><font style="vertical-align: inherit;">Les tests ont montr√© que TreeList n'a pas de sens d'utiliser jusqu'√† 10 000 √©l√©ments sur la taille de la liste. </font><font style="vertical-align: inherit;">Il serait int√©ressant d'essayer b-tree au lieu d'un arbre binaire. </font><font style="vertical-align: inherit;">Cette structure doit utiliser la m√©moire plus soigneusement et, tr√®s probablement, fonctionner plus rapidement. </font><font style="vertical-align: inherit;">Et pour cela, vous pouvez adapter l'id√©e avec l'indexation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans tous les cas, c'est amusant d'avoir un instrument dans l'arsenal qui peut (presque) tout faire avec une complexit√© pr√©visible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rences</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet original de </font></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demande de tirage dans Apache Common-Collections </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ticket √† Jira</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr488758/index.html">Conf√©rence DEFCON 27. Reconnaissance des escroqueries sur Internet</a></li>
<li><a href="../fr488762/index.html">Programmation asynchrone √©l√©gante avec des promesses</a></li>
<li><a href="../fr488766/index.html">Art et technologie: Universit√© du Massachusetts √† Lowell</a></li>
<li><a href="../fr488768/index.html">Enfer sanglant, ou Comment jurer en anglais pour √™tre confondu avec une personne cultiv√©e</a></li>
<li><a href="../fr488776/index.html">Am√©liorations de l'accessibilit√© dans Visual Studio 2019 pour Mac</a></li>
<li><a href="../fr488780/index.html">Mozilla a perdu dans la guerre des navigateurs, mais croit toujours qu'il pourrait sauver Internet</a></li>
<li><a href="../fr488782/index.html">Comment aimez-vous cette option de gestion des d√©pendances en Python?</a></li>
<li><a href="../fr488784/index.html">Commercialisation d'am√©liorations logicielles gratuites sous licences Copyleft</a></li>
<li><a href="../fr488786/index.html">Dans quelle mesure une user story doit-elle √™tre d√©taill√©e?</a></li>
<li><a href="../fr488792/index.html">Surveillance de la disponibilit√© des sites en Russie √† genoux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>