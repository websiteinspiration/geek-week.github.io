<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçö ü§±üèø üí¢ Smooth sorting üë¥ üîõ üõ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to dive into a variety of heaps. 
 
 Today we‚Äôll analyze an elegant ordering method that uses special heaps based on Leonardo‚Äôs numbers. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Smooth sorting</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We continue to dive into a variety of heaps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today we‚Äôll analyze an elegant ordering method that uses special heaps based on Leonardo‚Äôs numbers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many have heard about this sorting, but few people know exactly how it works. Today we will see that there is nothing complicated in it. </font><font style="vertical-align: inherit;">
The method was invented by the legendary Edsger Dijkstra. In addition to the many brightest achievements in the theory of algorithms, he is also the author of such a witty statement: </font><i><font style="vertical-align: inherit;">‚ÄúStudents who have previously studied Basic, it is almost impossible to teach good programming. As potential programmers, they have undergone irreversible mental degradation. ‚Äù</font></i><font style="vertical-align: inherit;"> 
I hope it‚Äôs not blasphemy that the animation in the article was created using VBA :-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" title="EDISON Software - web-development"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - web-development"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heap sorting in itself is very good, since its time complexity is </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> regardless of the data. In order to not be an array, the complexity of heapsort never degrades to </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which can happen, for example, with quick sorting. The flip side of the coin is that sorting by a binary heap cannot be accelerated, </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> complexity </font><font style="vertical-align: inherit;">can also not be expected (but the same quick sorting, under certain conditions, can reach such indicators). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, there was a question on the agenda: is it possible to contrive so that the time complexity of sorting by a heap, on the one hand, is no lower than</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but in a favorable scenario (in particular, if an almost sorted array is processed) increased to </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This issue was personally addressed by Edsger Dijkstra himself, who found out that yes, it is possible. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is assumed that those who read this article understand how sorting by heap works in general, they know what sorting tree is and why a sifting is needed. </font><font style="vertical-align: inherit;">If someone has gaps in this knowledge, then before continuing reading, I </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recommend</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">you read the previous article</font></a><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What's wrong with a binary heap</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take a look at how heapsort sorts an almost ordered array and see why this algorithm does not process such incoming data faster.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on the animation to go to the article ‚ÄúSorting by the n-pyramid‚Äù.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The first thing that catches your eye is that when sifting, the maxima are constantly pushed to the root of the heap, which corresponds to the first element of the array. If the input array is almost ordered, then for the algorithm this will only add a little work. Smaller elements will still first go down the tree, i.e. move closer to the end of the array, not to its beginning.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second slowing factor, which is not so obvious, is the standard binary heap itself is always a balanced tree. </font><font style="vertical-align: inherit;">In the case of initially ordered data, this plays a negative role. </font><font style="vertical-align: inherit;">If there is random data in the original array, then they are evenly distributed in a balanced tree, and multiple sifting passes through all branches approximately the same number of times. </font><font style="vertical-align: inherit;">For almost ordered data, an unbalanced tree is more preferable - in this case, the data on that part of the array that correspond to longer branches of the tree will be processed less often than others.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo numbers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve both problems, Dijkstra proposed using special binary heaps based on Leonardo numbers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leonardo numbers are almost like Fibonacci numbers, but only better. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A series of Leonardo numbers is given recursively: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first 20 Leonardo numbers: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1, 1, 3, 5, 9, 15, 25, 41, 67 , 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Absolutely any integer can be represented as the sum of Leonardo numbers having different serial numbers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is very useful in our case. Array of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elements can not always be represented as a single heap of Leonardo (if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not a Leonardo number). </font><font style="vertical-align: inherit;">But then, any array can always be divided into several subarrays that will correspond to different Leonardo numbers, i.e. </font><font style="vertical-align: inherit;">to be heaps of different order. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an example of an array of the 21st element, consisting of three Leonard heaps. </font><font style="vertical-align: inherit;">In each of the heaps, the number of nodes corresponds to any number of Leonardo.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Important points to know:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each Leonardov pile is an unbalanced binary tree.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The root of each heap is the last (and not the first, as in a regular binary heap) element of the corresponding subarray.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any node with all its descendants is also a Leonard heap of a smaller order.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build and dismantle heaps</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the recurrence formula for Leonardo numbers, </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 is </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
very pleased with the unit at the end. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And that's why. Suppose we have two adjacent subarrays in the array that correspond to heaps built on two adjacent Leonardo numbers. Using the element immediately after these subarrays, these subarrays can be combined into a common heap, which corresponds to the next Leonard number.</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Going through the elements in the array, we build a bunch of Leonard heaps. If using the element you can combine the two previous heaps (this is possible if and only if the two previous heaps correspond to two consecutive Leonardo numbers), then combine. If combining is not possible (the two previous heaps do not correspond to two consecutive Leonardo numbers), then the current element simply forms a new heap of one element corresponding to the first (or second, if the first is used before it) Leonardo number. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the second stage of the algorithm, the reverse process occurs - we parse the heaps. If we remove the root in the heap, then we get two smaller heaps corresponding to the two previous Leonardo numbers. This can be done because: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Fibonacci numbers there is no such useful unit, therefore we do not use the Fibonacci heap.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smooth Sort :: Smoothsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The final algorithm:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Create a bunch of Leonard heaps from the array, each of which is a sorting tree.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterate over the elements of the array from left to right.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We check whether using the current element it is possible to combine the two leftmost heaps in the existing heap of Leonard heaps:</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If yes, then we combine the two leftmost heaps into one, the current element becomes the root of this heap, we make a sift for the combined heap.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If not, then add the current element as a new heap (consisting of one node so far) to the existing heap of Leonard heaps.</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After moving the maximum element to the end, the sorted part of the array increased, and the unsorted part decreased. </font><font style="vertical-align: inherit;">Repeat steps II.1-II.4 for the remaining unsorted part of the array.</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python implementation example</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time complexity</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we take an almost ordered array as input, then the visualization shows why such an array is processed much faster.</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Savings occur only due to sifting. In almost ordered data, the sifting sinks shallow in the tree, including after the heaps are gradually disbanded in the second stage. In the initially random data, the sifting is more expensive, since it often drops in its heap to the very last level. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's estimate the total time complexity. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the first stage, we iterate over n elements, adding it to the heaps already existing on the left. Adding to the heap itself is bypassed in O (1), but then for the heap you need to make a sift. In ordered data, a shallow sifting often costs O (1) for one element added to the heap. In unordered data, the sifting for each addition is costed in </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since as a result of randomness a sifting has to go through the levels of the tree often to the very bottom. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, at the first stage, the best time complexity is: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for almost ordered data - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for random data - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the second stage, the situation is similar. When exchanging the next maximum, you again need to sift the heap at the root of which it was. And the sifting metrics for ordered and disordered data will be different. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the second stage, the best time complexity is the same as at the first: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for almost ordered data - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for random data - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adding time complexity for the first and second stages: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for almost ordered data - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
for random data - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the worst and average time complexity for smooth sorting is O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra in his calculations (which I will not bore you with) proved that the best complexity </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tends to </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> than the more ordered the incoming data. </font><font style="vertical-align: inherit;">Hence the name - smooth sorting.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extra memory complexity</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To decompose the data into a bunch of Leonard heaps, you just need to remember exactly which Leonardo numbers are involved at each step. </font><font style="vertical-align: inherit;">Knowing these numbers, the heaps themselves are aligned algorithmically. </font><font style="vertical-align: inherit;">This number series grows very quickly, so even for large arrays you will need a very small set of Leonard numbers.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial heap sort :: Binomial heap sort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a tree structure, very similar to the one that we sorted out - a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binomial heap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is also a bunch of heaps of different sizes, in each of which the number of nodes is a power of two. </font><font style="vertical-align: inherit;">Any array of any number of elements can be expanded into this heap, since any natural number is decomposed into the sum of twos of different degrees. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In principle, you can do a smooth sorting based on binomials:</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Will it work faster? </font><font style="vertical-align: inherit;">Hardly. </font><font style="vertical-align: inherit;">The binomial heap is not binary, and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the last article we found out that increasing the number of descendants does not accelerate, but slows the screen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In addition, you can notice that the binomial heap has longer branches, which is why neighboring ordered regions of the array will be slightly slower to connect to each other. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is not known whether the Dijkstra binomial heap was generally considered as a possible basis for its algorithm. </font><font style="vertical-align: inherit;">Be that as it may, the Leonardov heap is probably more optimal.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next Series Trailer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, even if a binomial pile is not the best option for smooth sorting, you should not completely discard it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the binomial tree is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slightly modified</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and completely different (very bold) ideas are used to go around it, we get an original and effective algorithm that has its own advantages. </font><font style="vertical-align: inherit;">What are we going to talk about next time?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on the animation to go to the article with the next sorting by heap.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Smooth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smooth </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo Number</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binomial heap</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Series Articles:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel application AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertion Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by selection</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramids</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap sort: weak heap</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bunch Sorts: Cartesian Tree</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other heap sortings: mirror heap, mini-heap, sifting bottom-up</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merge Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by distribution</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybrid Sorting</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today‚Äôs smooth sorting has been added to the AlgoLab app. </font><font style="vertical-align: inherit;">As well as a bonus - and sorting with a binomial pile. </font><font style="vertical-align: inherit;">So who wants to personally drive the data on the heap heaps - update the excel file with macros.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en496840/index.html">Musk believes that 12 thousand satellites will not interfere with astronomers. His opinion is not consistent with the model</a></li>
<li><a href="../en496842/index.html">A simple epidemic model with basic Python tools</a></li>
<li><a href="../en496846/index.html">Language mechanics of stacks and pointers</a></li>
<li><a href="../en496848/index.html">The digest of interesting materials for the mobile # 340 developer (on April 6 - 12)</a></li>
<li><a href="../en496850/index.html">Maven plugin for JPackage from Java 14</a></li>
<li><a href="../en496856/index.html">Smart home without remotes, but with a cube</a></li>
<li><a href="../en496858/index.html">FOSS News No. 11 - a review of free and open source software for April 6-12, 2020</a></li>
<li><a href="../en496860/index.html">First DI: First DI on Interfaces for Typescript Applications</a></li>
<li><a href="../en496862/index.html">Arduino Bubble Display</a></li>
<li><a href="../en496864/index.html">Audit Wallets in CryptoNote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>