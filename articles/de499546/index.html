<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üë©üèª‚Äç‚öñÔ∏è üö∂üèª Firmware-Entwicklung f√ºr eine analoge Videokamera EVR-Y2022F üñ•Ô∏è ü§òüèº üéå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel wurde das Ger√§t einer analogen Videokamera eingehend untersucht, um eine eigene Firmware zu erstellen. Wie bereits erw√§hnt, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Firmware-Entwicklung f√ºr eine analoge Videokamera EVR-Y2022F</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499546/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem fr√ºheren Artikel wurde das Ger√§t einer analogen Videokamera eingehend untersucht, um eine eigene Firmware zu erstellen. Wie bereits erw√§hnt, verf√ºgt die Kamera √ºber einen Mikrocontroller unbekannter Herkunft. Es ist viel reicher als die √ºblichen AVRs: Es hat zwei Versorgungsspannungen von 3,3 V und 1,8 V und eine DSP-Funktion. Zu diesem Schluss kam ich, als ich √ºber die Implementierung des Autofokus-Algorithmus nachdachte. Trotzdem habe ich komplexe MKs wie STM32 und andere nicht bevorzugt, schon weil ich nie mit ihnen gearbeitet habe. Ich habe definitiv die Entscheidung getroffen, einen der AVR MKs zur Implementierung meiner Firmware zu verwenden. Daher wurde mir bereits zu diesem Zeitpunkt klar, dass die Implementierung der Autofokusfunktion nicht sehr einfach oder eher unm√∂glich zu handhaben sein wird.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine Wahl fiel auf den ATmega128 MK, da er in meinen Arm fiel. Der ATmega8 MK wird in Bezug auf die Anzahl der Schlussfolgerungen offensichtlich nicht ausreichen, zumal ich f√ºr alle F√§lle beschlossen habe, einen ganzen MK-Port f√ºr den digitalen Videostream vom Videoprozessor zu reservieren. Zun√§chst habe ich herausgefunden, welche Funktionen in meiner eigenen Firmware enthalten sein werden, insbesondere Funktionen, die nicht in der urspr√ºnglichen Firmware enthalten sind, und welche Funktionen vernachl√§ssigt werden m√ºssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir eine Variante des Autofokus-Algorithmus zur Analyse eines digitalen Videostreams. Es gelang mir herauszufinden, dass die Videostreamdaten eine Abwechslung von Bytes sind, die mit den "CK" -Pulsen synchronisiert sind. Bytes des Videostreams codieren die Pegel der Y-, Cr-, Cb-Komponenten des Videosignals mit 8-Bit-Abstufung (256 Pegel). Das hei√üt, die digitale Videoausgabe vom Videoprozessor dieser Kamera wird komponentenmultiplexiert. Informationen zur Helligkeit (Y) sind in jedem zweiten Byte des Videostreams enthalten, und Informationen zur Farbe sind zweimal seltener. Das hei√üt, Informationen √ºber das Farbdifferenzsignal von Rot Cr sind in jedem vierten Byte enthalten, sowie Informationen √ºber das Farbdifferenzsignal von Blau. Somit repr√§sentiert der Strom die folgende Sequenz: Cb0, Y0, Cr0, Y1, Cb2, Y2, Cr2, Y3, Cb4, Y4, Cr4, Y5, .... Also,W√§hrend Informationen √ºber die Helligkeit jedes Pixels l√ºckenlos sind, werden Informationen √ºber die Farbe von Pixeln nacheinander komponentenweise eingegeben. Diese Ausd√ºnnung ist auf die Eigenschaften der Unempfindlichkeit gegen√ºber der Farbe kleiner Details und einer Verringerung des Farbbandes im Videosignal zur√ºckzuf√ºhren. Diese Eigenschaften werden bei der analogen Fernseh- und Videodigitalisierung verwendet. Die obige "Komprimierung" (Farbunterabtastung) hat ein Komponentenverh√§ltnis von 4: 2: 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit der Autofokus-Algorithmus funktioniert, reicht es aus, nur die Helligkeitskomponente zu analysieren. Dies ist auch leicht zu erreichen, wenn der Videostream ‚ÄûByte f√ºr Byte‚Äú abgefangen wird. Wenn die CK-Frequenz etwa 18 MHz betr√§gt, betr√§gt CK / 2 9 MHz, was f√ºr den ATmega128 MK durchaus erreichbar zu sein scheint. Die horizontalen und vertikalen Synchronisationsimpulse erm√∂glichen es der Steuerung, jeden Bereich des Bildes zu ‚Äûz√§hlen‚Äú und zu analysieren. F√ºr den Autofokus-Algorithmus reicht es m√∂glicherweise aus, nur die Mitte des Rasters zu analysieren. Je besser der Fokus, desto sch√§rfer das Bild und desto breiter das Frequenzband des Videosignals (mehr HF-Komponenten). Das hei√üt, es ist m√∂glich (sogar notwendig), den Fast Fourier Transform (FFT) -Algorithmus auf Fragmente eines digitalen Videostreams anzuwenden und die HF-Komponenten zu analysieren. In diesem Fall m√ºssen Sie den Fokusfokus jedes Mal drehen.Verwendung der Methode der ‚Äûhalben Teilung‚Äú als mathematische Optimierungsmethode. So k√∂nnen Sie das beste Ergebnis erzielen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich nicht um die Autofokusfunktion gek√ºmmert, da es auf MK mit einer einfachen Architektur unm√∂glich war, obwohl ich auf jeden Fall einen Port f√ºr digitales Video reserviert habe. Anstelle der Autofokussierung habe ich beschlossen, eine Reihe anderer Funktionen zu implementieren, die in der urspr√ºnglichen Firmware nicht verf√ºgbar waren. Dazu muss die Videokamera jedoch auf station√§re Bedingungen beschr√§nkt werden, was f√ºr die Video√ºberwachung typisch ist. Es wird davon ausgegangen, dass sich die Kamera anschlie√üend mithilfe spezieller Mechanismen automatisch und manuell in der horizontalen und vertikalen Ebene drehen kann. Wenn die Kamera automatisch auf ein bestimmtes Objekt gerichtet ist, dessen sph√§rische Koordinaten im Speicher des Steuerger√§ts vorgespeichert werden, √§ndern sich auch die ‚ÄûKoordinaten‚Äú von Zoom und Fokus, die ebenfalls vorgew√§hlt und im Speicher gespeichert werden.Das Management kann nach dem PELCO-D-Protokoll organisiert werden. Dar√ºber hinaus gibt es in der Spezifikation dieses Protokolls ein spezielles Team f√ºr dieses Unternehmen. Die Koordinaten von Zoom und Fokus werden nat√ºrlich f√ºr eine bestimmte Entfernung "gepaart". Das hei√üt, ein Objekt, das sich in einer bestimmten Entfernung befindet, wird scharfgestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit dem Schreiben eines Firmware-Programms beginnen, m√ºssen Sie sich √ºberlegen, welche Peripherieger√§te von MK und welche Schlussfolgerungen daraus entstehen. Dann m√ºssen Sie dar√ºber nachdenken, wie Sie das Board mit einem eigenen MK in der Kamera platzieren und befestigen k√∂nnen. Und damit es so bequem und wartbar wie m√∂glich war. Ich habe mich f√ºr ein Board mit MK entschieden, dessen Schlussfolgerungen vollst√§ndig nach links und rechts geleitet werden. Die Platine befindet sich an der Unterseite der Kamera, wo wenig Platz vorhanden ist, und wird an einer abnehmbaren Verbindung gehalten. Gleichzeitig befinden sich auf der Platine selbst ‚ÄûStifte‚Äú des Anschlusses und an den Seiten der Kamera befinden sich Steckdosen. F√ºr die Antwortbuchsen habe ich mich entschieden, zwei weitere Adapterplatinen herzustellen, die so gro√ü sind wie die Seite der Kamera. Die Lamellen dieser Karten befinden sich auf der Oberseite der Kamera direkt auf der Hauptplatine. Es wird davon ausgegangen, dass jede Lamelle an den gew√ºnschten Punkt auf der Hauptplatine der Kamera angeschlossen wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Entwicklung des Boards mit MK hatte ich die Idee, den Camcorder mit einer Uhr (RTC) zu erg√§nzen, und ich hob die I2C-Linie hervor, die auf dem RTC DS1307-Board (ich wei√ü schon was zum Teufel) mit Quarz und einer Batterie und f√ºr alle F√§lle mit dem EEPROM 24AA512 platziert war von Hand. Auf der Platine am oberen Rand befinden sich au√üerdem Anschl√ºsse zum Anschlie√üen von SPI- und JTAG-Programmierern. Auf dem Original-Motherboard wird MK mit 12-MHz-Quarz getaktet. Es ist f√ºr mich das gleiche. Im Allgemeinen ist es besser, dort Quarz auf 11,0592 MHz zu setzen, um einen klaren UART-Betrieb zu gew√§hrleisten. Die Abst√§nde zwischen den "K√§mmen" abnehmbarer Gelenke habe ich vorher sorgf√§ltig berechnet. Ich habe mich entschieden, MK aus dem F√ºnf-Volt-Krenka zu speisen, der auf den Rahmen unter der Hauptplatine geschraubt wird (er wird auch als K√ºhlk√∂rper dienen). Die Eingangsspannung 12V wird unmittelbar nach der Sicherung FB801 mit Strom versorgt, wie in der Abbildung gezeigt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/rs/q8/pkrsq8mtjjredo8w2mfne5goziy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 1. Energieverwaltung des Mikrocontrollers.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beim Zeichnen von Brettern in "SprintLayout" habe ich mich gefragt, welchen Zweck jeder Pin des MK hat, der "out" an den Anschluss ausgegeben wird. Das Ergebnis ist ein solches Bild. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/95/xg/bm95xgf-akgycofwc_mdsjp8rki.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 2. Skizzen zus√§tzlicher Leiterplatten.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Um die Wahrheit zu sagen, habe ich die Seitenbretter (entlang der Kanten) beim Schreiben dieses Artikels gezeichnet. Aber tats√§chlich habe ich sie mit einem Cutter gemacht. Es stellte sich heraus, dass dies nicht die erfolgreichste Option war. Und das Board selbst mit MK wurde schief gemacht. Ich habe irgendwie die seitlichen Hilfskarten an die Seiten des Kamerarahmens geschraubt und Flussmittelmuttern auf die Kupferoberfl√§che der Leiterplatte gel√∂tet. Tatsache ist, dass an den Seiten nur sehr wenig Platz ist und der Deckel der Kamera praktisch R√ºcken an R√ºcken ‚Äûfestgezogen‚Äú wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Abbildungen zeigen die Verteilung der Schlussfolgerungen des MK sowie deren Zweck.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cc/ry/d2/ccryd2b_viknimo-w0asy0j8fuy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 3. Der Zweck der Schlussfolgerungen des Mikrocontrollers.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es gibt viele Punkte zu kommentieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den SPI-Programmierer (STK200 +) war die Ausgabe ‚ÄûPEN‚Äú nicht erforderlich. Die Aktivierung erfolgt wie gewohnt durch ‚ÄûRESET‚Äú. Anstelle von ‚ÄûMISO‚Äú und ‚ÄûMOSI‚Äú verf√ºgt der MK jedoch √ºber eine separate Schnittstelle (PDI / PDO), und die Leitung ‚ÄûCLK‚Äú wird kombiniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Referenzspannung f√ºr den ADC habe ich die gleichen 5 V gew√§hlt, von denen der MK selbst gespeist wird. Ich habe versucht, separat 3,3 V zu bekommen (wie in der urspr√ºnglichen Schaltung), aber gleichzeitig gab es Fallstricke. Um auf die 5-V-Referenzspannung umzuschalten, m√ºssen Sie die Schaltung leicht √§ndern, wie in der Abbildung gezeigt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mn/od/wr/mnodwrbakf5xlxkq1qskzeuhmkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 4. √úbersetzung der Tasten auf die 5V Referenzspannung.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das hei√üt, Sie m√ºssen eine Seite des R505-Widerstands von der 3,3-V-Versorgungsseite abl√∂ten und stattdessen 5 V von der MK-Stromleitung an ihn anlegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von den Schlussfolgerungen von MK, die nur innerhalb des entworfenen Boards verwendet werden, sind nur drei beteiligt. Ein 1-Hz-Impulssignal mit RTC kommt bei PB7 an, um die Zeit zu aktualisieren. Die Pins PD0 und PD1 sind dem I2C-Bus zugeordnet. Es wird programmgesteuert unter Verwendung der CVAVR-Bibliothek ‚Äûi2c.h‚Äú implementiert, obwohl an diese Ausg√§nge eine Hardware-i2c-Schnittstelle (TWI) angeschlossen ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der MC-Pin ‚ÄûRESET‚Äú wird ausgegeben, aber der MK-Reset erfolgt von selbst ohne externe Reset-Kette. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde verstanden, dass die HD- und VD-Taktimpulse √ºber externe Interrupt-Ports zum MK gelangen w√ºrden, um das Videofeld genau lesen zu k√∂nnen. Ohne die Autofokusfunktion werden sie jedoch nicht mehr ben√∂tigt. Signale von den Zoom- und Fokus-Endschaltern kommen zu benachbarten Ports externer Interrupts.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Port "A" MK ist f√ºr den digitalen Videostream reserviert. Port "C" ist vollst√§ndig f√ºr SD reserviert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pin PD4 wird zum Umschalten von TX / RX RS-485 verwendet. In der urspr√ºnglichen Schaltung gab es kein Schalten: Der 2. und 3. Zweig des MAX485-Chips befanden sich am Boden. Der urspr√ºngliche MK konnte nur Daten zur Steuerung der Kamera √ºber PELCO-D empfangen. Ich entschied mich f√ºr ein kleines Upgrade. Die Idee war dies. Wenn der Camcorder hoch und in einem geschlossenen Geh√§use h√§ngt, ist es einfach unm√∂glich, die Firmware schnell zu aktualisieren. Und ein solches Bed√ºrfnis wird sich sicherlich ergeben: Die Beseitigung verschiedener Fehler und die Verbesserung der Funktionalit√§t werden zum ersten Mal zu einer regelm√§√üigen Praxis. Aus diesem Grund kam mir die Idee, einen Bootloader f√ºr MK zu implementieren und diesen bereits zu verwenden, um die Firmware √ºber RS-485 remote zu aktualisieren. In diesem Fall ist ein wechselseitiger Austausch sehr w√ºnschenswert. Informationen zum Bootloader finden Sie in diesem Artikel. Und um den MAX485 (2 und 3 Beine) an diesen MK-Pin anzuschlie√üen,Sie m√ºssen eine kleine √Ñnderung an der ersten und zweiten Karte vornehmen. Diese Karten sind √ºber ein Schleifenkabel verbunden, an dessen Anschl√ºssen sich ein nicht verwendeter ‚ÄûIRL‚Äú -Kontakt zur Steuerung der Hintergrundbeleuchtung befindet. Auf der zweiten (Haupt-) Karte m√ºssen Sie den Widerstand R520 abl√∂ten und stattdessen den Draht, der durch die Adapterplatine zum ATmega128 MK f√ºhrt, an den entsprechenden Ausgang l√∂ten. Und auf der ersten Platine m√ºssen Sie 2 und 3 Beine von U202 abl√∂ten und biegen, sie zusammenl√∂ten und von der Verkabelung zum freien Ausgang von 1 Stecker J302 ziehen. Diese Vorg√§nge zum √Ñndern der Schaltung sind in der Abbildung dargestellt.Das geht √ºber die Adapterplatine zum ATmega128 MK zum entsprechenden Ausgang. Und auf der ersten Platine m√ºssen Sie 2 und 3 Beine von U202 abl√∂ten und biegen, sie zusammenl√∂ten und von der Verkabelung zum freien Ausgang von 1 Stecker J302 ziehen. Diese Vorg√§nge zum √Ñndern der Schaltung sind in der Abbildung dargestellt.Das geht √ºber die Adapterplatine zum ATmega128 MK zum entsprechenden Ausgang. Und auf der ersten Platine m√ºssen Sie 2 und 3 Beine von U202 abl√∂ten und biegen, sie zusammenl√∂ten und von der Verkabelung zum freien Ausgang von 1 Stecker J302 ziehen. Diese Vorg√§nge zum √Ñndern der Schaltung sind in der Abbildung dargestellt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/20/oe/qu20oe_mzvupcc4mpsbtg4omwma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 5. Organisation der TRX-Leitung zur Steuerung des TX / RX MAX485.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
An Bord des ATmega128 befinden sich zwei UART-Schnittstellen. In diesem Fall m√ºssen Sie die zweite Schnittstelle (Pins 27, 28) verwenden, da die erste Schnittstelle an den Pins (Pins 2, 3) mit der Schnittstelle f√ºr den SPI-Programmierer kombiniert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Vorstand sind fast alle Schlussfolgerungen des MK involviert. Die Schlussfolgerungen von Port ‚ÄûG‚Äú erwiesen sich als ungenutzt. Die Uhr konnte √ºbrigens programmgesteuert auf Basis von MK implementiert werden. Es bietet einen Ruhemodus mit einer Batterie zum Z√§hlen der Zeit, wenn die Hauptstromversorgung ausgeschaltet ist. Es gibt sogar Schlussfolgerungen f√ºr den Anschluss eines separaten Niederfrequenzquarzes. Ich habe mich jedoch nicht darum gek√ºmmert und den DS1307 geschlagen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Abbildung zeigt den Zweck jedes Ausgangs der Karte mit MK. Au√üerdem ist bedingt markiert, auf welcher Seite der Hauptplatine die Dr√§hte von jedem Pin verl√∂tet werden. Es ist auch notwendig, einige Kommentare abzugeben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i0/fd/df/i0fddfrritx4bjzwqgsfl3bu1r4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 6. Abtretung von Schlussfolgerungen einer zus√§tzlichen Zahlung mit MK.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Signale von den Zoom- und Fokus-Endschaltern kommen nicht nur zu den Interrupt-Ports, sondern auch zu den ADC-Eing√§ngen. Tatsache ist, dass ich bereits in der Phase des SD-Studiums ein solches Merkmal bemerkt habe. Wenn der Zoom- oder Fokusmechanismus auf ‚ÄûNull‚Äú steht, kann das Ausgangssignal vom Anh√§nger einen ‚ÄûZwischenzustand‚Äú annehmen. Um solche seltenen F√§lle besser erfassen zu k√∂nnen, habe ich mich f√ºr den ADC entschieden. Nat√ºrlich ist dies kein sehr kompetenter Ansatz, aber auf diese Weise kam ich schnell aus dem Problem heraus, das manchmal in der Initialisierungsphase meiner Test-Firmware auftrat. Dadurch habe ich die Stabilit√§t des Algorithmus erh√∂ht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die SDA / SCL-Signale vom I2C werden nur f√ºr den Fall in den Anschluss eingesteckt und nicht au√üerhalb dieser Karte verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Namen der einzelnen Pins zur Steuerung der ID werden entsprechend der tats√§chlichen Verbindung signiert. Das Verbinden von Daten mit Blick auf die Zukunft wurde schlie√ülich in der Debugging-Phase korrigiert. Es gab viel Verwirrung, aber die Fehler waren nur im Wechsel der Phasen genau umgekehrt und nicht in ihrer Reihenfolge. Die Alternativen ‚Äû4-1-2-3‚Äú (f√ºr Zoom) und ‚Äû2-3-4-1‚Äú (f√ºr Fokus) sind ein und dieselbe sowie ‚Äû1-2-3-4‚Äú und wurde als Grundlage genommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Artikels </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(um nicht zu blamieren) werden</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwei Fotos pr√§sentiert. Die erste ist die Unteransicht des Camcorders mit Blick auf die zus√§tzliche Leiterplatte. Die zweite ist eine Ansicht von oben von oben auf die Hauptplatine einer Videokamera mit einem abgedichteten Standard-MK (genauer gesagt Mikroprozessor), einem B√ºndel Drahtbr√ºcken und anderem Rotz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe das Programm (Firmware) zusammen mit seinen vorl√§ufigen Tests im ISIS 7 Professional (Proteus) -Programm geschrieben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/qr/f7/mtqrf7iej-6e3adbtcg-bgghokq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 7. Ansicht des Projekts in Proteus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Anstelle der einzigartigen Chips des Zeichengenerators und des Videoprozessors (die nat√ºrlich nicht in Proteus enthalten sind) habe ich SPI-Debugger installiert. Mit ihrer Hilfe ist es bequem, die Bytes zu steuern, die MK per SPI sendet. Die tats√§chliche Reaktion auf diese Bytes wird jedoch direkt auf der Hardware gesteuert. Mit Proteus k√∂nnen Sie PELCO-D-Befehle von einem echten DVR √ºberwachen und debuggen. Zu diesem Zweck m√ºssen Sie den DVR optional √ºber den einfachsten Einwegadapter RS485-&gt; RS232 an den COM-Anschluss des Computers anschlie√üen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann begann ich zu entwickeln und zu modellieren. Excel hat dabei sehr geholfen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst m√ºssen Sie die Timer und ihre Konfiguration festlegen. Ein Timer - um die Drehung des Schrittmotors und die Ausf√ºhrung wiederholter Operationen der Tasten zu realisieren, w√§hrend sie gedr√ºckt gehalten werden. Wenn Sie diese oder jene Taste w√§hrend der Einstellungen √ºber das Men√º gedr√ºckt halten, wird der Betrieb der SD ausgeschlossen. Wenn Sie eine der Zoom- oder Fokussteuertasten au√üerhalb des Men√ºs gedr√ºckt halten, dreht sich die SD mit dem entsprechenden Zeitparameter. Somit gibt es keine Konflikte. Ich hatte vor, den zweiten Timer zu verwenden, um PWM f√ºr die SD zu implementieren, aber im Laufe der Zeit habe ich beschlossen, ihn aufzugeben. In meinem Fall ist PWM nicht erforderlich, wenn kein Autofokus vorhanden ist. Dar√ºber hinaus hat der √úbertragungsmechanismus eine helikale Struktur, daher k√∂nnen Sie im Ruhezustand die SD nicht durch Gleichstrom "halten", der Mechanismus kriecht nirgendwo hin.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anschlie√üend m√ºssen Sie das Zeichenalphabet des Zeichengenerators gem√§√ü Datenblatt √ºberarbeiten und mit dem Standardalphabet ASCII vergleichen. Das Alphabet des Zeichengenerators besteht aus 128 Zeichen, was der halben Gr√∂√üe des letzten entspricht. Zum Beispiel fehlen die kyrillischen Zeichen im Zeichengenerator vollst√§ndig, aber es gibt Sonderzeichen, die f√ºr seine Anwendung charakteristisch sind (Sonne, Sanduhr, kleiner Mann, Notiz, Telefon usw.). Ich habe ein Array von "smb [256]" aus 256 Elementen erstellt und es in das EEPROM MK eingef√ºgt. Die Notation smb [i] = adr bedeutet, dass sich an der Adresse adr im Zeichengenerator ein Zeichen mit dem ASCII-Code i befindet. Und wenn das Symbol i nicht im Alphabet des Zeichengenerators enthalten ist, bezieht sich der Wert des Array-Elements auf das "Leerzeichen" mit der Adresse 0x7E. Das hei√üt, fast die H√§lfte der Elemente im Array hat den Wert "0x7E". Dieses Array ist in der folgenden Abbildung in Tabellenform dargestellt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/_b/_g/yo_b_gqswkjfk1smuefynrwgs0e.png"><br>
<i>. 8.    ASCII    PD6464A.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes m√ºssen Sie √ºberlegen, wie Schaltfl√§chen √ºber den ADC verarbeitet werden. Nach dem Ohmschen Gesetz ist es einfach, die Spannungswerte am Eingang des ADC zu berechnen, wenn Sie auf eine Schaltfl√§che klicken. Danach ist es einfach, die Grenzen der Intervalle zu berechnen, deren Mitte die gleichen Spannungswerte aufweist. Insgesamt werden sechs Intervalle erhalten: f√ºnf davon entsprechen jeder Taste und eines dem Fehlen eines Drucks (es wird keine Taste gedr√ºckt). Auf Hardwareebene analysiert der ADC MK regelm√§√üig den Spannungswert √ºber die Tasten. Der Timer f√ºr Anti-Bounce kann basierend auf der Berechnung der ADC-Taktzyklen implementiert werden, was ich getan habe. In der Debugging-Phase hatte dieser Teil des Programms seine T√ºcken. Ich denke, dass es sich nicht lohnt, Details zu schreiben. Um die klare Arbeit dieser Funktionalit√§t zu erreichen, musste ich lange basteln. Die Tastenerkennungsfunktion befindet sich im ADC-Interrupt-Bereich, und an seinem Ausgang befindet sich die Tastennummer.Depressionsflagge und Freigabeflagge. Die Weiterverarbeitung der Tasten erfolgt im Hauptprogrammzyklus. Die Tastenabruffrequenz (ADC-Frequenz) betrug 12000/128 = 93,75 (kHz), wobei 128 der maximal m√∂gliche Teiler ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann habe ich ein Array von Werten des UART-Registers UBRR1 der UART-Konfiguration erstellt, abh√§ngig von dem einen oder anderen Bodyrate-Wert f√ºr PELCO-D, der aus der Liste in den Einstellungen √ºber das Men√º ausgew√§hlt werden kann. </font><font style="vertical-align: inherit;">Diese Werte k√∂nnen mithilfe der Formel aus dem Datenblatt des MK berechnet und auch mit dem automatischen Konfigurator des AVR-Assistenten abgerufen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann fing ich an, das Men√º zu modellieren. </font><font style="vertical-align: inherit;">Dies ist die wichtigste und zeitaufw√§ndige Phase beim Schreiben eines Programms. </font><font style="vertical-align: inherit;">Im Prinzip wollte ich das Men√º der Standard-Firmware nicht wiederholen, au√üer dass ich mich entschied, es zu einer hierarchischen Struktur zu komplizieren (Abschnitt im Abschnitt). </font><font style="vertical-align: inherit;">Unten finden Sie eine Beschreibung des Modells und die Definitionen des Men√ºs, das ich f√ºr mich selbst erstellt habe.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann nicht lesen</font></font></b>
                        <div class="spoiler_text">     .<br>
          .<br>
      .<br>
          .<br>
       ¬´MENU¬ª.<br>
<br>
    ¬´¬ª    .<br>
    ¬´¬ª  ¬´¬ª       .<br>
  ¬´¬ª       .<br>
  ¬´¬ª       .<br>
  (   )   ,         .<br>
   ¬´ ¬ª,     .<br>
<br>
   :<br>
 ‚Äî ;<br>
 ‚Äî ;<br>
 ‚Äî ;<br>
 ‚Äî .<br>
<br>
    ,   ,   .<br>
    &lt;&gt;.<br>
     .<br>
         "&lt;..&gt;".<br>
      ¬´¬ª.<br>
      ,   .<br>
        ( ) .<br>
    "&lt;..&gt;"      .<br>
        ,    .<br>
           .<br>
<br>
      .<br>
     .<br>
        .<br>
     "&lt;‚Ä¢&gt;" ( ).<br>
     "&lt; &gt;" ().<br>
      ¬´¬ª.<br>
<br>
    .<br>
           .<br>
     ¬´l*l¬ª (,   ¬´l¬ª).<br>
     ¬´l l¬ª (,   ¬´l¬ª).<br>
        ¬´¬ª.<br>
<br>
  ,       .<br>
     .<br>
           .<br>
            .<br>
       : ¬´000¬ª, ¬´00¬ª, ¬´0¬ª.<br>
        .<br>
         : ": ".<br>
  ‚Äî      (    )       .<br>
 ,   ,     ¬´¬ª  ¬´¬ª.<br>
    ¬´¬ª     1.<br>
    ¬´¬ª     1.<br>
<br>
         .<br>
         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher √§hnelt die Men√ºnavigation der Navigation durch Dateien und Ordner √ºber ‚ÄûTotal Commander‚Äú. Der Implementierungscode f√ºr dieses Men√ºmodell ist nicht sehr kompliziert, aber sehr umst√§ndlich. Es gibt zwei Schl√ºsselvariablen: die Nummer der aktiven Seite und die Nummer der aktiven Position auf der Seite. F√ºr beide Variablen arbeiten zwei "Switch-Case" -Funktionen ineinander. Dieses Funktionspaar ist am Dr√ºcken der Tasten "Links", "Rechts" und "Men√º" beteiligt. An jedem Ort (f√ºr jede Schaltfl√§che, Seite und jedes aktuelle Element) werden bestimmte Aktionen registriert. Jede Men√ºseite verf√ºgt √ºber eine Funktion, die die Anzeige der Seite auf dem Bildschirm mit allen Beschriftungen und Parametern implementiert. Bevor ich die Seitenausgabefunktionen implementierte, habe ich sie zuvor in Excel modelliert, wie sie "nach Zellen" sagen.So werden die Koordinaten der Zellen jedes Symbols auf dem Bildschirmfeld klarer dargestellt, und diese Informationen sind in der Programmierphase erforderlich. In der folgenden Abbildung habe ich als Beispiel die Ansicht von Seite 9 gegeben, auf der die PELCO-D-Baudrate aus der Liste ausgew√§hlt ist. Das Schnittstellenelement auf der Seite ist ein Optionsfeld. Dar√ºber hinaus soll der erste Absatz &lt;..&gt; diesen Abschnitt verlassen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/s1/uy/c0s1uyuaoh9dawm-bqpf5g4pmjg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 9. Modellieren des OSD in Excel.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ich habe auch ein Array erstellt, das die Anzahl der Punkte auf jeder Seite widerspiegelt. Es wird beim Dr√ºcken der Auf- und Ab-Tasten verwendet. Dies geschieht, um den Code zu reduzieren und die Verwendung der Switch-Case-Funktion zu vermeiden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wiederholtes virtuelles Dr√ºcken bei gedr√ºckter Taste wird im Hauptteil des Timer-Interrupts durch die Funktion ‚ÄûSwitch-Case‚Äú implementiert, die mit einer Ganzzahlvariablen arbeitet, die ein Flag ist. Der Flag-Wert ist f√ºr jede Aktion einer Schaltfl√§che auf einer bestimmten Seite und einem bestimmten Men√ºpunkt eindeutig. Es wird dem Flag nur an den Stellen als Seriennummer zugewiesen, an denen virtuelle Klicks erforderlich sind. Gleichzeitig werden innerhalb der Funktion ‚ÄûSwitch-Case‚Äú (im Hauptteil des Timer-Interrupts) Kopien von Funktionen platziert, die die Aktionen der Tasten implementieren. Um Speicherplatz zu sparen, konnten bei regelm√§√üigen Aufrufen der Tastenverarbeitungsfunktion Verkn√ºpfungen (Links) platziert werden. Es ist noch vern√ºnftiger, aber in diesem Moment hatte ich nicht die Geduld dar√ºber nachzudenken, wie ich es besser machen k√∂nnte, weil ich das Projekt so schnell wie m√∂glich abschlie√üen wollte. Und der Speicher in ATmega128 stellte sich als ziemlich viel heraus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlie√ülich habe ich ‚ÄûBibliotheken‚Äú f√ºr die Arbeit mit einem Videoprozessor, einem Zeichengenerator und einer RTC DS1307 mit den erforderlichen Funktionen implementiert. Danach habe ich die Adressen des EEPROM MK ermittelt, um diese oder jene Informationen zu speichern. Die ersten 32 Bytes sind zum Speichern von Men√ºeinstellungsinformationen reserviert. Die n√§chsten 32 Bytes sind f√ºr das Speichern von Text reserviert, der auf dem Bildschirm angezeigt oder mit dem Standardbefehl ‚ÄûPelco-D Write Char. Zum Bildschirm. " Die n√§chsten 256 Bytes des EEPROM-Bereichs sind f√ºr das Alphabet reserviert (Konvertierung eines Zeichens von ASCII in eine Adresse f√ºr einen Zeichengenerator, wie oben erw√§hnt). Schlie√ülich sind die n√§chsten 128 Bytes f√ºr das Speichern von ‚ÄûVoreinstellungen‚Äú (Vorlagen) f√ºr Zoom / Fokus reserviert. Ich habe diese Funktion aufgrund des fehlenden Autofokus eingef√ºhrt. Ich habe dar√ºber am Anfang des Artikels geschrieben. Insgesamt 32 Vorlagen. Die Koordinaten des Zooms oder Fokus werden in zwei Bytes codiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabh√§ngig davon lohnt es sich, √ºber die Implementierung des SD-Managements zu schreiben. Die Drehung der SD wird durch Aufrufen der Funktionen StepF () und StepZ () im Timer-Interrupt-Block erreicht. Die Drehzahl wird durch die Konfiguration dieses Timers bestimmt. Und die Implementierung der obigen Funktionen implementiert die F√∂rderung des Fokus bzw. des Zooms in einem minimalen Schritt. W√§hrend der Drehung des Zoomobjektivs und des Fokus werden ihre Endpositionen gesteuert. Die Position des maximalen Fokus und die Position des minimalen Zooms werden im Programm durch Konstanten (280 bzw. -600) dargestellt. Aber die Position des minimalen Fokus und die Position des maximalen Zooms - in Form der Variablen F_min und Z_max (genauer gesagt Funktionen). Dieser Ansatz wurde durch einen nicht rechteckigen Arbeitsbereich mit einer abgeschnittenen unteren rechten Ecke erleichtert. Zur Berechnung der Werte von F_min und Z_max werden st√ºckweise definierte Funktionen F_min (Z) und Z_max (F) verwendet. Au√üerdem,Wenn sich der SD-Zoom bei Z (Zoomkoordinate)&gt; 500 in die positive Richtung dreht, dreht sich der SD-Fokus gleichzeitig in die gleiche Richtung, wenn dieser Koordinaten &lt;(- 180) hat. Das hei√üt, die maximale Zoomposition ist im Prinzip nicht durch die aktuelle Fokusposition begrenzt, sondern auf 600. Es kommt einfach vor, dass sich zwei SDs gleichzeitig drehen, wenn der entsprechende Winkelrand des f√ºnfeckigen Bereichs erreicht ist, und die Bewegung in diesem Stadium entlang der ‚ÄûSchnittseite‚Äú erfolgt (wenn grafisch interpretiert). ) Aus mechanischer Sicht entspricht dies dem im vorherigen Artikel beschriebenen Prozess, wenn in Abwesenheit von SD und beim manuellen Verschieben der Zoom- und Fokusknoten der Zoomknoten am Ende des Pfads den Fokusknoten ‚Äûzieht‚Äú. Aufgrund der Tatsache, dass die Zoomkoordinate die Fokuskoordinate dominiert (weshalb ich die F (Z) -Abh√§ngigkeit betrachte,aber nicht umgekehrt), ich habe nicht begonnen, ein √§hnliches Zoom-Scrolling-Verfahren in der Funktion Step_F () zu implementieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der urspr√ºnglichen Firmware hatte die Geschwindigkeit zum √Ñndern von Zoom und Fokus feste Werte. Dies ist nicht immer bequem. In meiner Firmware habe ich vier Werte f√ºr die Zoom- und Fokusgeschwindigkeit (unabh√§ngig voneinander) angegeben, die sowohl √ºber das Men√º als auch mit dem dieser Funktion zugewiesenen PELCO-D-Befehl ausgew√§hlt werden k√∂nnen. Diese vier Werte werden in der Debugging-Phase nach Belieben vorgew√§hlt und dann in die Firmware eingegeben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die BD-Initialisierungsfunktion init_MR () wird ben√∂tigt, um die Mechanik des Zooms und des Fokus an das Koordinatensystem zu binden. Es wird jedes Mal einmal ausgef√ºhrt, wenn Sie den Camcorder einschalten. Der Algorithmus ihrer Arbeit ist ungef√§hr der folgende. Zun√§chst wird angenommen, dass sich der Zoom oder Fokus auf dem Nullpunkt befindet, und es wird versucht, den Abprall des Signals von den Endschaltern durch externe Interruptfunktionen zu erfassen. Ich werde sofort feststellen, dass das Signal am Ausgang des Anh√§ngers einen "Zwischen" -Zustand zwischen logischer "0" und "1" hat, wenn der Zoom oder Fokus auf "Null" (an der Grenze der Aufteilung des optischen Anh√§ngers) liegt. Solche F√§lle sind sehr unwahrscheinlich, k√∂nnen aber nicht ausgeschlossen werden. Die Interrupt-Funktion interpretiert jedoch kein Signal wie Bounce. Aus diesem Grund habe ich den ADC MK verwendet, der Signale von den End- und Zoom-Endschaltern auf seinen beiden freien Kan√§len ausl√∂st. Damit,Der erste Schritt ist die "Digitalisierung" der Signale von den Endschaltern mit 8-Bit-Genauigkeit. Dies erfolgt mit einer einzigen Analog-Digital-Wandlung. Es ist zu beachten, dass die Referenzspannung in unserem Fall 5 V betr√§gt und der logische Pegel ‚Äû1‚Äú vom Endschalter 3,3 V betr√§gt. F√ºr eine logische "0" ist der ADC-Wert Null und f√ºr eine "1" - 3,3 / 5 * 255 = 168. Wenn der Signalwert von dem einen oder anderen Trailer in den Bereich von beispielsweise 2 bis 165 f√§llt (ein Fuzzy-Intervall wird verwendet), bedeutet dies, dass der entsprechende Knoten bereits "auf Null" ist und der Initialisierungsvorgang f√ºr diesen Knoten gestoppt werden kann. Andernfalls m√ºssen Sie anhand des logischen Werts des Anh√§ngersignals (‚Äû0‚Äú oder ‚Äû1‚Äú) bestimmen, in welchem ‚Äã‚ÄãTeil (zur H√§lfte) sich der Knoten befindet. Die Drehrichtung des SD h√§ngt davon ab. Auf die eine oder andere Weise sollte der SD in diese Richtung gedreht werden.so dass sich der entsprechende Knoten in Richtung "Null" (Endschalter) bewegt. Somit wird die Drehung des Motorantriebs mit der gleichzeitigen Berechnung der Anzahl von Schritten gestartet, bis der Endschalter erreicht ist. Sobald der entsprechende Endschalter erreicht ist, der die Funktion der externen Unterbrechung entsprechend der Differenz der logischen Ebene bestimmt, erfolgt eine R√ºckw√§rtsdrehung des Motorantriebs. Es dreht sich in der gleichen Anzahl von Schritten in die entgegengesetzte Richtung und kehrt dadurch in seine urspr√ºngliche Position zur√ºck. Der Wert der Anzahl der Schritte f√ºr jede BD mit dem entsprechenden Vorzeichen wird vor dem Verlassen der Initialisierungsfunktion in die entsprechenden Variablen kopiert. Das oben beschriebene Verfahren erfolgt unabh√§ngig voneinander f√ºr Fokus und Zoom innerhalb derselben Funktion (nicht wiederum).Die Drehzahl des Motorantriebs in der Initialisierungsphase wird durch eine separate Konstante bestimmt und entspricht der maximalen Drehzahl f√ºr eine sichere korrekte Drehung des SM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich das Beispiel vor, in dem sich der Zoom vor dem Einschalten der Kamera im negativen Bereich und der Fokus im positiven Bereich befand. Die Abbildung zeigt schematisch die Flugbahn des Punktes (Z; F) w√§hrend des Initialisierungsvorgangs des Schrittmotors. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/59/6d/1p596dlrqriwqff1jh4jfrtvu-8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 10. Der Vorgang zum Initialisieren von Zoom und Fokus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Punkt A ist die Anfangsposition von Zoom und Fokus. Die Bewegung beider Knoten erfolgt in Richtung "Null" mit gleicher Geschwindigkeit (Initialisierungsgeschwindigkeit). Bei Punkt B erreicht der Fokus Null, da er n√§her an Null als der Zoom lag. Dann wird der Fokus umgekehrt. Bei Punkt C schlie√üt der Fokus den Initialisierungsprozess ab und kehrt zu seiner urspr√ºnglichen Position zur√ºck. Gleichzeitig bewegt sich der Zoom immer noch in Richtung seiner ‚ÄûNull‚Äú. Am Punkt D erreicht es seine ‚ÄûNull‚Äú und kehrt zu seiner urspr√ºnglichen Position zur√ºck (Punkt A).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zur Initialisierungsfunktion init_MR () gibt es eine Funktion goto_zf (z, f). </font><font style="vertical-align: inherit;">Basierend auf dem Namen soll von einem Preset zu einem anderen gewechselt werden, √ºber das ich am Anfang des Artikels geschrieben habe. </font><font style="vertical-align: inherit;">Die Drehzahl des Schrittmotors w√§hrend des √úbergangs ist dieselbe wie w√§hrend der Initialisierung. </font><font style="vertical-align: inherit;">Der √úbergangsprozess in Zoom und Fokus wird gleichzeitig ausgef√ºhrt. </font><font style="vertical-align: inherit;">Das hei√üt, wenn es erforderlich ist, vom Punkt (z1; f1) zum Punkt (z2; f2) zu gelangen, wird die gleichzeitige Drehung von zwei SDs gestartet. </font><font style="vertical-align: inherit;">Wenn zum Beispiel | f2-f1 | &lt;| z2-z1 |, wird die Fokus-SD fr√ºher gestoppt. </font><font style="vertical-align: inherit;">Dies ist in der folgenden Abbildung dargestellt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/-y/ya/fb-yyanbovlb6i3pe6rxsfh0ax8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">11. Der Vorgang zum √Ñndern des Zooms und des Fokus bei der Auswahl einer Voreinstellung.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der gesamten Betriebszeit des Schrittmotors w√§hrend des Durchlaufs des Nullmarkenbegrenzers wird die entsprechende Koordinate auf Null gesetzt. </font><font style="vertical-align: inherit;">Und das trotz der Tatsache, dass dies theoretisch nicht m√∂glich ist. </font><font style="vertical-align: inherit;">In der Praxis tritt jedoch immer noch ein Fehler von 1-2 Schritten der SD auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist erw√§hnenswert, dass ich im Gegensatz zur urspr√ºnglichen Firmware in meinem Fall bei der Steuerung von Zoom und Fokus (sowohl √ºber die Tasten als auch √ºber PELCO-D) die M√∂glichkeit einer schrittweisen Bewegung vorgesehen habe. Dies funktioniert wie folgt. Wenn Sie auf eine der 4 Schaltfl√§chen klicken, um den Zoom oder Fokus zu steuern, wird die entsprechende SD um einen Schritt gedreht, wodurch die Bewegung des Zoom- oder Fokusknotens minimiert wird. Wenn Sie die Taste nicht loslassen, beginnt nach kurzer Zeit die normale Drehung des Schrittmotors. Diese Verz√∂gerung wird empirisch im Voraus ausgew√§hlt. Diese Funktion √§hnelt virtuellen wiederholten Dr√ºcken, w√§hrend Sie die Taste gedr√ºckt halten. Dank dieser Funktion wird das Problem des ‚ÄûFesthaltens‚Äú der Taste beim Steuern des Zooms oder beim Fokussieren auf ein PELCO-D-Remote-Ger√§t √ºber eine schlechte Internetverbindung beseitigt. Genauer gesagt ergibt sich die Gelegenheit als unh√∂flich,und Feinabstimmung des Zooms oder Fokus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Interpreter der PELCO-D-Befehle erfolgt nach der gleichen Analogie wie im Ger√§t zum Lastschalten √ºber PTZ. Ich habe diesem einfachen Ger√§t zuvor einen separaten kleinen Artikel √ºber Habr√© gewidmet. Im Gegensatz zur urspr√ºnglichen Firmware beziehen sich Zoom- und Fokussteuerbefehle vollst√§ndig auf das Dr√ºcken der entsprechenden Tasten. Das hei√üt, es ist m√∂glich, das Men√º mit den PELCO-D-Zoom- und Fokustasten zu ‚Äûklettern‚Äú. Und um das Men√º √ºber PELCO-D aus der Ferne aufzurufen oder vielmehr die Taste ‚ÄûMENU‚Äú zu dr√ºcken, habe ich die Taste zum √ñffnen der Blende damit verglichen, da diese Funktion in diesem Kameramodell nicht verwendet wird. Somit gibt es f√ºnf grundlegende PELCO-D-Befehle zum Dr√ºcken sowie f√ºnf grundlegende Befehle zum Loslassen von Tasten. Dar√ºber hinaus werden, wie ich bereits beil√§ufig im gesamten Artikel geschrieben habe, zus√§tzliche Befehle verarbeitet: "Voreinstellung festlegen", "Voreinstellung l√∂schen","Gehe zu Preset", "Write Char. Zum Bildschirm ‚Äú,‚Äû Bildschirm l√∂schen ‚Äú,‚Äû Zoomgeschwindigkeit einstellen ‚Äú,‚Äû Fokusgeschwindigkeit einstellen ‚Äú.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datum und Uhrzeit mit RTC werden in Analogie zu alten VHS-Kameras in der unteren linken Ecke des Bildes angezeigt, wenn diese Option im Men√º aktiviert ist. Au√üerdem k√∂nnen Sie im Men√º das Ausgabeformat ausw√§hlen, das ich auch im Voraus angegeben habe. Auch auf dem Bildschirm neben Datum und Uhrzeit kann der Wochentag angezeigt werden. Zus√§tzlich zur Uhr werden die aktuellen Koordinaten von Zoom und Fokus als zus√§tzliche Informationen auf dem Bildschirm angezeigt. Diese Option wird haupts√§chlich in der Debugging-Phase ben√∂tigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Ihnen die Funktionen des von mir implementierten Men√ºs erl√§utern. Im Laufe der Zeit wird das Men√º bei Bedarf √ºberarbeitet: Einige Funktionen k√∂nnen entfernt und andere hinzugef√ºgt werden. Die Men√ºstruktur, die ich in SPlan mit Seitenaufrufen gezeichnet habe, ist in der folgenden Abbildung dargestellt. Rote Pfeile - betreten Sie den Abschnitt. Blaue Pfeile - Verlassen Sie den Abschnitt. Ich habe nicht auf jeder Seite des Men√ºs blaue Pfeile gezeichnet, sondern nur zwei. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/vs/mp/rlvsmpdeoixbmwlg-jmf2uwj51m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 12. Die Struktur des Bildschirmmen√ºs.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Abschnitte meines Men√ºs sind ein bisschen wie Abschnitte des Originals. Dies sind zun√§chst die ersten beiden Abschnitte: Wei√üabgleich und Belichtung. Im dritten Abschnitt k√∂nnen Sie die Adresse der PELCO-D-Kamera angeben und die Datenrate (Baudrate) aus der Liste ausw√§hlen. Der vierte Abschnitt ist Datum und Uhrzeit gewidmet. Sie k√∂nnen Datum, Uhrzeit und Wochentag einstellen, eines von vier Anzeigeformaten ausw√§hlen und eine Anzeigemethode ausw√§hlen. Der f√ºnfte Abschnitt - Arbeiten mit Voreinstellungen (Vorlagen) f√ºr Zoom und Fokus, wo Sie ihn nach Nummer aufrufen sowie l√∂schen oder √ºberschreiben k√∂nnen. Auch in diesem Abschnitt des Men√ºs k√∂nnen Sie eine von vier Geschwindigkeiten zum √Ñndern des Fokus oder des Zooms ausw√§hlen. Im f√ºnften Abschnitt k√∂nnen Sie die Parameter des Videoprozessors bearbeiten, der sich im Byte 9 der Kategorie 3 befindet. Dies ist der Pegel und die Inversion der Burst-Komponente des Videosignals sowie die Videospiegelung. Der letzte Abschnitt des Men√ºs dient zum Debuggen.Mit ihm k√∂nnen Sie einen beliebigen Wert eines beliebigen Bytes in einer beliebigen Kategorie in den Videoprozessor schreiben. Der Wert kann sowohl in Dezimal- als auch in Bin√§rform eingestellt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt werde ich ein paar Worte √ºber den Bootloader sagen. Wie ich bereits geschrieben habe, wird der Bootloader zum Remote-Flashen des Camcorders √ºber RS-485 ben√∂tigt. Anfangs dachte ich, den Bootloader selbst vollst√§ndig zu implementieren. Um Zeit zu sparen, habe ich mich jedoch f√ºr einen der bereits implementierten fertigen Downloader entschieden, die im Internet zu finden sind. Au√üerdem habe ich sie nie benutzt und nur auf theoretischer Ebene eine Vorstellung von ihnen gehabt. Eines der wichtigsten Kriterien f√ºr die Auswahl eines Bootloaders ist die RS-485-Unterst√ºtzung. Normalerweise arbeiten AVR-Downloader mit UART RS-232. Und der Bootloader mit RS-485-Unterst√ºtzung unterscheidet sich nur dadurch, dass auf der MK-Seite ein zus√§tzlicher Ausgang zum Umschalten des RS-485-Transceivers (z. B. MAX485) w√§hrend der Daten√ºbertragung vom MK zum PC zugewiesen wird. Beim Flashen von MK √ºbertr√§gt der Bootloader Informationen √ºber erfolgreiche oder nicht erfolgreiche Aufzeichnung an den Computer. Erster BootloaderMit dem, was ich gefunden habe, k√∂nnen Sie nicht nur den FLASH-Speicher von MK mit Firmware, sondern auch das EEPROM aufzeichnen. Neben dem Schreiben k√∂nnen Sie auch Daten lesen. Aber dieses Projekt mit Assembler-Quellcode war ziemlich verwirrend und ich habe es nicht verstanden. Dar√ºber hinaus lag der Schwerpunkt dieses Bootloaders auf der M√∂glichkeit, mehrere Ger√§te einzeln zu flashen, ohne sie vom RS-485-Netzwerk zu trennen, und auf jedes Ger√§t unter einer zuvor eingen√§hten Adresse zuzugreifen. Ich ben√∂tige solche Funktionsmerkmale nicht, da ich eine andere Topologie des RS-485-Netzwerks verwende und der Camcorder schnell vom DVR auf den PC umgeschaltet werden kann. Der zweite Bootloader ist der deutsche Chip45. Der Quellcode ist nicht gemeinfrei, er kann vom Autor gekauft werden. Stattdessen gibt es mehrere hundert HEX-Dateien f√ºr verschiedene AVR-MKs, verschiedene UART-Schnittstellen (wenn es mehrere gibt, wie in meinem Fall),RS-485 oder RS-232 zur Auswahl. Kurz gesagt, f√ºr alle Gelegenheiten. Gleichzeitig stellt der Autor fest, dass im Fall von RS-485 der TX / RX-Schaltstift fest ist und dem XCK-UART-Stift der Controller-Schnittstelle entspricht, der in UART praktisch nicht verwendet wird. In meinem Fall ist der 30. Pin des XCK der zweiten UART-Schnittstelle des Atmega128 MK PORTD.5 ‚Äã‚Äãund wird zum Aktivieren der Zoom- und Fokus-Endschalter verwendet. Im Prinzip wird diese Funktion nicht ben√∂tigt, da, wie Studien gezeigt haben, Endschalter immer aktiv sind, wie ich bereits geschrieben habe. Bei Bedarf k√∂nnen Sie diese Funktion auf jeden anderen freien Ausgang MK √ºbertragen. Aber dieser Bootloader hat mich auch nicht beeindruckt, zumal ich auf einen interessanteren Bootloader namens ‚ÄûAVR Universal Bootloader‚Äú mit chinesischem Design gesto√üen bin. Wie Chip45 kann es nur schreiben und nur im FLASH-Speicher von MK.Aber er hat eine Vielzahl von M√∂glichkeiten, und deshalb habe ich mich entschieden, daran festzuhalten. Es kommt als AVR Studio-Projekt mit C-Quellcode. Aufgrund der Tatsache, dass ich in CodeVisionAVR arbeite, musste ich AVR Studio zusammen mit WinAVR installieren. Um die HEX-Datei f√ºr die Bootloader-Firmware zu erhalten, m√ºssen Sie das Projekt kompilieren, indem Sie vorl√§ufige √Ñnderungen am Quellcode f√ºr die Konfiguration Ihres Ger√§ts vornehmen, und Sie ben√∂tigen Ihre eigene. Die Kompilierung des Projekts besteht darin, eine Bat-Datei (Batch-Datei) zu starten, in die die Kompilierungsbefehle geschrieben werden. Daher muss ein Projekt in AVR Studio nicht ge√∂ffnet werden. √Ñnderungen im Quellcode k√∂nnen entweder manuell (auf Programmiererebene) oder mithilfe des Konfigurators vorgenommen werden. Die Rolle des letzteren ist ein zus√§tzliches Fenster des Dienstprogramms, das mit dem ebenfalls angeh√§ngten Bootloader funktioniert.Im Konfigurator k√∂nnen Sie festlegen, dass der MK-Pin f√ºr die TX / RX RS-485-Umschaltung, der MK-Pin f√ºr die blinkende LED der Steuerung, der MK-Pin f√ºr die Eingabe des Bootloaders, die Art und Weise, wie der Bootloader eingegeben wird, der MK-Name und die Frequenz usw. nicht aufgef√ºhrt werden k√∂nnen. Dar√ºber hinaus kann das bekannte Standardprogramm ‚ÄûHyperTerminal‚Äú als Dienstprogramm zum Laden eines Benutzerprogramms in MK dienen, dh zum Arbeiten mit dem Bootloader. Es verwendet das Protokoll ‚ÄûXmodem‚Äú zum Herunterladen der Firmware. Und um bequem und visuell mit dem Bootloader √ºber das Textterminal arbeiten zu k√∂nnen, steht im Konfigurator die Sonderfunktion ‚ÄûAusf√ºhrlicher Modus‚Äú zur Verf√ºgung. Trotz der Attraktivit√§t des Hyperterminals habe ich mich f√ºr das Dienstprogramm entschieden, das mit dem Bootloader geliefert wurde. Tatsache ist, dass ich mit der im Konfigurator aktivierten praktischen Funktion Verbose, die √ºber das Terminal funktioniert, auf die folgende Situation gesto√üen bin.Manchmal passierte es, wenn der Datenverkehr in der Leitung ‚Äûkollidierte‚Äú (beide Ger√§te im TX-Modus), wodurch der MAX485 im Camcorder sehr hei√ü wurde und ausfiel, oder vielmehr nicht vollst√§ndig, sondern nur der RX-Bereich (Daten√ºbertragung √ºber RS-485 an die Kamera). . Aus diesem Grund habe ich HyperTerminal aufgegeben. Und es gibt noch eine weitere Unannehmlichkeit. HyperTerminal funktioniert nicht mit HEX-Textdateien und akzeptiert nur eine Bin√§rdatei. Daher m√ºsste ich eine zus√§tzliche Konvertierung von hex zu bin anwenden. Nachdem die Bootloader-HEX-Datei von mir generiert wurde, habe ich sie mit dem PonyProg-Programm und dem √ºblichen SPI-Programmierer in den MK eingen√§ht. Infolgedessen funktioniert der Bootloader wie folgt. Wenn Sie den Camcorder einschalten, wird der Bootloader sofort aktiviert. Er wartet eine Sekunde lang auf eine Verbindung vom Dienstprogramm, dann funktioniert die Hauptfirmware. Wenn die Verbindung erfolgreich hergestellt wurde,dann beginnt der Blinkvorgang. Gleichzeitig muss das andere Ende der RS-485-Leitung vorab vom DVR getrennt und √ºber den RS485 &lt;-&gt; RS232- oder RS485 &lt;-&gt; USB-Adapter mit dem PC verbunden werden. √úbrigens √ºber die Adapter. Es stellte sich die Frage, wie man einen solchen Adapter selbst herstellt, da gekaufte Adapter teuer sind. Beim St√∂bern im Internet fand ich eine einfache RS485 &lt;-&gt; RS232-Adapterschaltung. Es ist in der folgenden Abbildung dargestellt. Es besteht haupts√§chlich aus bekannten MAX232- und MAX485-Mikroschaltungen, und TX / RX wird durch das Signal vom 3. Ausgang des COM-Port-Anschlusses des Computers √ºber eine Zenerdiodenschaltung geschaltet. Das hei√üt, der MAX485 wird durch den vom PC √ºbertragenen Datenverkehr geschaltet. Alles ist einfach und genial.RS232 oder RS485 &lt;-&gt; USB. √úbrigens √ºber die Adapter. Es stellte sich die Frage, wie man einen solchen Adapter selbst herstellt, da gekaufte Adapter teuer sind. Beim St√∂bern im Internet fand ich eine einfache RS485 &lt;-&gt; RS232-Adapterschaltung. Es ist in der folgenden Abbildung dargestellt. Es besteht haupts√§chlich aus bekannten MAX232- und MAX485-Mikroschaltungen, und TX / RX wird durch das Signal vom 3. Ausgang des COM-Port-Anschlusses des Computers √ºber eine Zenerdiodenschaltung geschaltet. Das hei√üt, der MAX485 wird durch den vom PC √ºbertragenen Datenverkehr geschaltet. Alles ist einfach und genial.RS232 oder RS485 &lt;-&gt; USB. √úbrigens √ºber die Adapter. Es stellte sich die Frage, wie man einen solchen Adapter selbst herstellt, da gekaufte Adapter teuer sind. Beim St√∂bern im Internet fand ich eine einfache RS485 &lt;-&gt; RS232-Adapterschaltung. Es ist in der folgenden Abbildung dargestellt. Es besteht haupts√§chlich aus bekannten MAX232- und MAX485-Mikroschaltungen, und TX / RX wird durch das Signal vom 3. Ausgang des COM-Port-Anschlusses des Computers √ºber eine Zenerdiodenschaltung geschaltet. Das hei√üt, der MAX485 wird durch den vom PC √ºbertragenen Datenverkehr geschaltet. Alles ist einfach und genial.Es besteht haupts√§chlich aus bekannten MAX232- und MAX485-Mikroschaltungen, und TX / RX wird durch das Signal vom 3. Ausgang des COM-Port-Anschlusses des Computers √ºber eine Zenerdiodenschaltung geschaltet. Das hei√üt, der MAX485 wird durch den vom PC √ºbertragenen Datenverkehr geschaltet. Alles ist einfach und genial.Es besteht haupts√§chlich aus bekannten MAX232- und MAX485-Mikroschaltungen, und TX / RX wird durch das Signal vom 3. Ausgang des COM-Port-Anschlusses des Computers √ºber eine Zenerdiodenschaltung geschaltet. Das hei√üt, der MAX485 wird durch den vom PC √ºbertragenen Datenverkehr geschaltet. Alles ist einfach und genial.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/_j/xg/dg_jxg5vy5h-i32yee8szg8urho.png"><br>
<i>. 13.   RS-232 &lt;-&gt; RS-485.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich den Bootloader beherrscht hatte, beschloss ich in meiner Freizeit, die Optik des Camcorders zu erforschen. Genauer gesagt wurde es f√ºr mich interessant, welche Kombinationen von Zoom- und Fokuswerten fokussierte Bilder in unterschiedlichen Abst√§nden vom Objektiv zum Motiv erzeugen. Ich m√∂chte Sie daran erinnern, dass der Bereich verschiedener gegenseitiger Werte f√ºr Zoom und Fokus durch einen f√ºnfeckigen Bereich (fast rechteckig) beschrieben wird. Nehmen Sie beispielsweise den Abstand vom Objektiv zum Motiv 10 cm. Das Argument (entlang der Abszissenachse) des Zooms hat einen Wertebereich von -600 bis 600. Sie m√ºssen den Fokuswert bei jedem Zoomwert ausw√§hlen, bei dem das Motiv vor dem Objektiv im Videobild scharfgestellt wird. Dann m√ºssen Sie einen Tisch machen. Nat√ºrlich macht es keinen Sinn, alle 1200 Zoomwerte zu sortieren. Es reicht aus, ein paar Dutzend Werte mit einem bestimmten gleichen Schritt zu verwenden. Als solchen Schritt habe ich den Wert 50 gew√§hlt.Bei jedem Zoomwert mit diesem Schritt (-600, -550, -500, ...) habe ich den Fokuswert ausgew√§hlt und die Messergebnisse aufgezeichnet. Ich habe ein √§hnliches Verfahren mit anderen Abst√§nden vom Objektiv zum Motiv durchgef√ºhrt: 50 cm, 1 m, 10 m, 100 m. Das Ergebnis war eine Kurvenfamilie, die ich in Excel angezeigt habe.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/_4/qi/5o_4qikxragcwmdaeespjactaoi.png"><br>
<i>. 14.  Z-F   .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Blick auf die Grafiken m√∂chte ich viele Kommentare abgeben. Bei minimalem Zoom liegen die Fokuswerte f√ºr fast jede Entfernung etwas unter der ‚ÄûMitte‚Äú (Null). Die rosa Kurve f√ºr einen Abstand von 10 cm endet bei einem Zoomwert von ca. 250, was dem minimalen Fokuswert entspricht. Diese Kurve hat abnehmenden Charakter und ist nach oben konvex. Die rote Kurve f√ºr eine Entfernung von 1 m hat eine v√∂llig andere Form. Erstens ist es nicht eint√∂nig, und zweitens gibt es hinsichtlich der Konvexit√§tseigenschaft einen Wendepunkt. Die Kurven f√ºr Entfernungen von 10 m und 100 m sind von √§hnlicher Natur. Letztere stimmen √ºbrigens praktisch √ºberein, was ich bereits im Voraus wusste. Daher habe ich die gemessenen Entfernungen von 10 und 100 Metern nat√ºrlich ungef√§hr genommen. Was die blaue Kurve f√ºr einen halben Meter beeinflusst - anfangs wollte ich keine Messungen daran vornehmen.Ich habe diesen Abstand ungef√§hr nach dem Prinzip gew√§hlt, dass sich ein Fragment der entsprechenden Kurve so nah wie m√∂glich der Eckgrenze der Region n√§hert (Schnitt). Und so geschah es: Diese Grenze ber√ºhrt praktisch ein Fragment der Kurve. Im Allgemeinen ist anzumerken, dass die obere H√§lfte der Region (positive Fokuswerte) praktisch nicht verwendet wird. Die Ausnahme ist in gro√üer Entfernung vom Motiv zum Objektiv und beim gr√∂√üten Zoom. Bei fast allen Entfernungen (mit Ausnahme der n√§chsten, weniger als einem halben Meter) sind die Fokuswerte bei geringem Zoom (150 oder weniger) nahezu gleich. Im Allgemeinen sollten alle angegebenen Messdaten eine theoretische Interpretation haben, die auf den Gesetzen der Optik basiert. Gegenw√§rtig habe ich jedoch keine Ahnung von den Ger√§ten solcher Objektive. Maximal,Was mir auf dem Gebiet der Optik begegnet ist, ist der Aufbau eines einfachen Refraktorteleskops mit zwei Linsen. Und bei diesem Camcorder habe ich die Mechanik der Optik nicht verstanden. Am Ausgang sind nur zwei sich bewegende Knoten nicht verf√ºgbar: der Fokusknoten (verantwortlich f√ºr den Fokus) und der Zoomknoten. Und ich wei√ü nicht, wie viele Objektive sich insgesamt befinden. Ich nehme an, zwei, die mit diesen sich bewegenden Knoten verbunden sind. Es ist auch erw√§hnenswert, dass sich der Zoom beim Einstellen des Fokus auch optisch geringf√ºgig √§ndert, selbst wenn der entsprechende Knoten fest ist.verbunden mit diesen sich bewegenden Knoten. Es ist auch erw√§hnenswert, dass sich der Zoom beim Einstellen des Fokus auch optisch geringf√ºgig √§ndert, selbst wenn der entsprechende Knoten fest ist.verbunden mit diesen sich bewegenden Knoten. Es ist auch erw√§hnenswert, dass sich der Zoom beim Einstellen des Fokus auch optisch geringf√ºgig √§ndert, selbst wenn der entsprechende Knoten fest ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Artikels fahren wir mit dem praktischen Testen des Camcorders fort. Ich habe beschlossen, nicht viele Standbilder zu machen, sondern sofort das gesamte Video hochzuladen. Ich habe die Videoaufnahme √ºber das Ger√§t aufgenommen, der Ton wurde separat auf den Audiorecorder geschrieben. Die urspr√ºngliche Aufl√∂sung betr√§gt 720 x 576. Nach dem Hochladen des Videos auf YouTube hat sich die Qualit√§t merklich ge√§ndert.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/H4agAlZlWW8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Kamera einschalten, werden zun√§chst die Schrittmotoren des Zooms initialisiert und auf den Hintergrund des Videobilds fokussiert. Dieses Bild ist schwarzwei√ü und ohne AGC, da das Initialisierungsverfahren f√ºr den Videoprozessor noch nicht abgeschlossen ist. Unten links zeigen das aktuelle Datum und die aktuelle Uhrzeit das Datum und die Uhrzeit der Kompilierung der aktuellen Kamera-Firmware an. Im Firmware-Quellcode habe ich die entsprechenden Variablen erstellt, die sich an festen Adressen im HEX-Code befinden. Es wird davon ausgegangen, dass in der Kompilierungsphase, genauer danach, automatisch ein Programm ausgef√ºhrt wird, das die Werte der Variablen aus der Systemzeit entnimmt und an den gew√ºnschten Adressen in die HEX-Datei einf√ºgt. Dar√ºber hinaus m√ºssen die Pr√ºfsummen noch nachgez√§hlt werden. Vielleicht gibt es einen einfacheren Weg. Im Beispiel im Video sind diese Variablen gleich Null, da ich diese Funktion noch nicht implementiert habe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Initialisierung der SD wird der Videoprozessor initialisiert und sofort eine Begr√º√üung auf dem Hintergrund des Videobildes angezeigt. Beim Anpassen von Zoom und Fokus werden deren Koordinaten unten rechts angezeigt. Im Video zeige ich die Verwendung der Funktion zum Speichern und Abrufen von Vorlagen (Voreinstellungen) f√ºr Zoom und Fokus in verschiedenen Teilen des Bildes. Beim L√∂schen einer Voreinstellung erhalten die entsprechenden Variablen den Wert 0xFFFF, der einem Wert von -1 entspricht. Diese Funktion ist grunds√§tzlich √ºberfl√ºssig, sie kann ausgeschlossen werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im letzten Abschnitt des Men√ºs, der zum Debuggen verwendet wird, zeige ich den Datensatz von Byte 3 der Kategorie 9. Die diesem Byte entsprechenden Funktionen befinden sich im vorherigen Abschnitt des Men√ºs, √ºber den ich viele Male geschrieben habe. Aufgrund der Tatsache, dass der aktuelle Status des Bytes nicht vom Videoprozessor gelesen wird, habe ich ihn manuell auf ‚Äû48‚Äú als einen der akzeptablen Werte gesetzt. Danach √§ndere ich die einzelnen Bits dieses Bytes und zeige dabei die Funktionen "Mirror" und "Inverse Burst". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie den Burst-Pegel im vorletzten Abschnitt des Men√ºs anpassen, werden Sie einen kleinen Firmware-Fehler bemerken, der leicht zu beheben ist. Von den anderen M√§ngeln - manchmal treten beim Aktualisieren der Zeit L√ºcken in den Zeichen auf. Ich denke, das liegt an der ‚Äûkrummen‚Äú Installation der Elektronik im Camcorder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen wurden beim Bedienen der Kamera geringf√ºgige Unannehmlichkeiten im Zusammenhang mit der Men√ºnavigation festgestellt. </font><font style="vertical-align: inherit;">Daher ist es durchaus m√∂glich, dass die erforderliche √úberarbeitung im Laufe der Zeit vorgenommen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, ich h√§tte es fast vergessen. </font><font style="vertical-align: inherit;">Wie versprochen bringe ich zwei Fotos mit, wie sich die F√ºllung des Camcorders nach der Entwicklung entwickelt hat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/0-/ah/m-0-ahq2z2xqxpr988ndcfae5uu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">15. Eine aktualisierte Ansicht des Camcorders unten. </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/gs/8_/bw/gs8_bwxf2yy1mqyrt2gmbgzoyu8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">16. Eine aktualisierte Ansicht des Camcorders oben.</font></font></i><br>
<br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499534/index.html">Entwicklungshandbuch f√ºr Python-Backend-Dienste</a></li>
<li><a href="../de499536/index.html">Growbox als Methode, sich selbst zu kennen</a></li>
<li><a href="../de499540/index.html">So funktioniert das Rendern von 3D-Spielen: Texturierung und Texturfilterung</a></li>
<li><a href="../de499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../de499544/index.html">Lernen Sie neuronale Netze in Google Sheets</a></li>
<li><a href="../de499548/index.html">Maske - F√ºrsorge f√ºr andere oder eine Illusion von Sicherheit?</a></li>
<li><a href="../de499550/index.html">Low-Code-L√∂sungen f√ºr √ñkosysteme</a></li>
<li><a href="../de499556/index.html">Game Server auf MS Orleans - Teil 3: Zusammenfassung</a></li>
<li><a href="../de499560/index.html">Xswitcher Layout Corrector f√ºr Linux: Schritt zwei</a></li>
<li><a href="../de499562/index.html">Erfolgloser Artikel √ºber die Beschleunigung der Reflexion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>