<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗺️ 👩🏻‍⚖️ 🔀 Spark SQLを使用して練習する、またはレーキを踏まない方法 🔂 💅🏻 🌆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SQLを使用している場合は、すぐに必要になります。Apache Sparkは、Hadoopエコシステムに含まれるツールの1つで、RAM内のデータを処理します。その拡張機能の1つはSpark SQLです。これにより、データに対してSQLクエリを実行できます。Spark SQLは、大量のデータを含むSQ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Spark SQLを使用して練習する、またはレーキを踏まない方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/496310/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLを使用している場合は、すぐに必要になります。</font><font style="vertical-align: inherit;">Apache Sparkは、Hadoopエコシステムに含まれるツールの1つで、RAM内のデータを処理します。</font><font style="vertical-align: inherit;">その拡張機能の1つはSpark SQLです。これにより、データに対してSQLクエリを実行できます。</font><font style="vertical-align: inherit;">Spark SQLは、大量のデータを含むSQLクエリを処理する場合や、高負荷のシステムで使用する場合に便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、Spark SQLを操作するためのいくつかの簡単なトリックを示します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統計を収集し、ヒントを使用して、クエリ実行プランを最適化する方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLの範囲内にとどまりながら、値の不均一な分布を伴うキー結合（スキュー結合）を効率的に処理する方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロードキャスト結合テーブルのサイズが大きすぎる場合の編成方法。</font></font></li>
<li>  Spark SQL ,   Spark          .</li>
</ul><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、市場には多くのSQLアナリストや開発者がいます。これは、開発プロセスのすべての関係者が理解できる言語です。アナリストは、どのテーブルからどのデータを抽出し、特定の方法で接続するかを定式化します。開発者は必要に応じてファイナライズしてステージに分割し、受信したSQLクエリを最適化してから、それらからETLストリームを形成して通常のデータロードを行います。ビジネスニーズの拡大に伴い、数百万行のデータウェアハウスの時代が数十億のデータレイクの時代に置き換えられています。ビジネスはそのエコシステムを開発しており、ストレージエンティティをクラウドに変換するという目標を設定しています。そこでは、機械学習とデータサイエンスハンドラがデータを待っています。 ETL開発者はデータエンジニアとして再トレーニングを行っています。最も簡単な方法は、使い慣れたSQL言語を使用し、Sparkの機能を使用して、数十億の行をデータレイクにロードすることです。入力開発者がクラウドエンティティに具体化する必要があるSQLクエリが数百あり、開発時間が限られている場合、最も簡単な方法は、Spark SQLを使用し、SQL自体を使用してクエリを構成し、ダウンロード速度が許容できない場合にのみSparkエンコーディングを使用することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spark SQLは、グローバル100社の多くの企業がデータを処理するのに役立ちます。SparkSQLは、開発が容易なため、正しく使用すると高い出力を提供します。 Spark SQLは、データを処理およびロードするときに、さまざまなETLプロセスで使用できます。データを操作する場合のSpark SQLの代替には、Impala SQLまたはHive（mapreduceでのSQLクエリの処理）が含まれます。 SQLを超える場合、代替手段はSparkでDSLを使用することです。 10年以上存在し、何百万人ものユーザーがいるSQL言語の約束に疑いの余地はありません。 Spark SQLには、かなりの開発展望があります。たとえば、Sparkの新しいバージョンでは、新しい最適化のヒントを使用することが可能になり、データ処理メソッドがより効率的になります。Sparkは、改良されたデータ処理とDeepLearningとの統合を追求して、バージョンからバージョンへと進化しています。 RDD、DataFrame、DataSetなど、アプローチは改善に向かって変化しています。したがって、Spark SQLの調査と適用は関連性があり、有望です。企業にとって、Spark SQLの使用は、最終的には顧客に関する知識の蓄積、顧客の処理、および新しい知識に基づく新しいビジネスの構築につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sparkを介したデータロードの微調整を行うには、Spark SQLを超えて、DSLなどを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事ではApache Spark 2.3のバージョンを扱い、データはHadoopからHadoopにダウンロードされ、リソースはYarnを使用して管理され、Linuxオペレーティングシステムが使用され、Hive DBMSにデータが寄木細工の形式でhdfsに保存されていることが明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメーターとして渡されたSQLコマンドでファイルを開始するアプリケーションのコードは指定しません。転送されたファイルを開き、その内容をsqlStr変数にロードして呼び出す必要があることをアプリケーションに書き込むだけです。</font></font><br>
<br>
<pre><code class="java hljs">SparkSession spark = SparkSession<font></font>
        .builder()<font></font>
        .appName(<span class="hljs-string">""</span>)<font></font>
        .enableHiveSupport()<font></font>
        .getOrCreate();<font></font>
Dataset&lt;Row&gt; sql = spark.sql(sqlStr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、* .jarアプリケーションが作成され、SQLコマンドをパラメーターとして使用してファイルを転送し、spark-submitを使用してそれを実行できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">spark-submit --class &lt;…sqlrunner&gt; --name &lt;taskname&gt; --queue &lt;yarnqueue&gt; --executor-cores 1 --executor-memory 1g --driver-cores 1 --driver-memory 1g --num-executors 1 --master yarn --deploy-mode cluster &lt;hdfs://…sqlrunner.jar&gt; sqlFile=&lt;…sql&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、転送されたsqlFileでSQLコマンドを指定できます。次に例を示します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">insert</span> overwrite <span class="hljs-keyword">table</span> target_scheme.target_table
<span class="hljs-keyword">select</span> s.* <span class="hljs-keyword">from</span> source_scheme.source_table s;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sparkの統計の収集と表示、ヒントBROADCAST</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存じのとおり、Sparkの最も複雑な操作の1つは、テーブルまたはデータセットを結合（結合）することです。</font><font style="vertical-align: inherit;">同時に、Sparkにはさまざまな結合実装アルゴリズムがあります。SortMergeJoin、BroadcastHashJoin、CartesianProductなどです。Sparkが大きいテーブルと小さいテーブルのどちらを接続しているか、またどのタイプの接続が最適であるかを自動的に理解するには、これらのテーブルの統計を収集する必要があります。</font><font style="vertical-align: inherit;">これを行うには、spark-submitを使用して、次の形式のコマンドを呼び出します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ANALYZE</span> <span class="hljs-keyword">TABLE</span> scheme_name.table_name <span class="hljs-keyword">COMPUTE</span> <span class="hljs-keyword">STATISTICS</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この統計収集コマンドを、SQLコマンドではなくパラメーターとして上記のsqlrunner.jarモジュールに渡すことができます。</font><font style="vertical-align: inherit;">このコマンドを実行するには、統計が収集されるテーブルへの読み取りおよび書き込み権限が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の形式のコマンドを使用して、ハイブ環境で統計が収集されていることを確認できます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> scheme_name.table_name;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティ 'spark.sql.statistics.numRows'および 'spark.sql.statistics.totalSize'がTBLPROPERTIESブロックの説明の最後に表示されているかどうかを確認する必要があります。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTERNAL</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`scheme_name.table_name`</span>(<font></font>
…<font></font>
TBLPROPERTIES (<font></font>
…<font></font>
  <span class="hljs-string">'spark.sql.statistics.numRows'</span>=<span class="hljs-string">'363852167'</span>, 
  <span class="hljs-string">'spark.sql.statistics.totalSize'</span>=<span class="hljs-string">'82589603650'</span>, <font></font>
…</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ソーステーブル、計算で使用される中間テーブル、およびユーザークエリの接続でも使用できるショーケーステーブルで統計を収集することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Sparkのブロードキャストについて少し説明します。小さなテーブルを大きなデータセットにアタッチする場合、多くの場合、小さなテーブルをデータチャンクの形式の接続キーによって異なるノードに分散せず、アプリケーションで使用されるすべてのクラスターノードに全体を配置することが推奨されます。同時に、彼らは小さなテーブルがすべてのノードにブロードキャストされ、メインテーブルへの小さなテーブルの接続のタイプはブロードキャスト結合であると言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リレーショナルデータベースでネストされたループ結合が必要な場合、Spark SQLでブロードキャスト結合が必要になることがよくあります。ブロードキャストは、接続に参加しているキーのデータ分布の不均一な統計に特に必要です。たとえば、小さな通貨のディレクトリを大きなポスティングテーブルにアタッチすると、99％の行がルーブルに関連します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さなテーブルまたはデータセット（最大1Gbまで）をブロードキャストする必要があることをSparkに伝えるには、SQLクエリでヒント/ * + BROADCAST（t）* /を指定できます。ここで、tはテーブルまたはデータセットのエイリアスです。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">insert</span> overwrite <span class="hljs-keyword">table</span> target_scheme.target_table
<span class="hljs-keyword">select</span> <span class="hljs-comment">/*+ BROADCAST(t) */</span> big.field1,<font></font>
       big.field2,<font></font>
       t.field3<font></font>
  <span class="hljs-keyword">from</span> source_scheme.big_table <span class="hljs-keyword">as</span> <span class="hljs-keyword">big</span>
  <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> source_scheme.small_table <span class="hljs-keyword">as</span> t
    <span class="hljs-keyword">on</span> big.field1 = t.field1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、一部のテーブルの統計が収集されていない場合、またはサブクエリを処理している場合、その結果はその場で生成され、Sparkはそれが大きいかどうかを事前に知らないため、ヒント/ * + BROADCAST（t）* /が特に推奨されますテーブルまたはサブクエリにデータがほとんどない場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブクエリのブロードキャストがクエリの開始後5分より後に終了する場合は、次のパラメーターを指定してspark-submitを呼び出す必要があります（ここでは36000は秒単位の時間です）。デフォルトでは十分な5分が割り当てられていない可能性があるためです。</font></font><br>
<br>
<pre><code class="plaintext hljs">--conf spark.sql.broadcastTimeout=36000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、そのようなパラメーターは、サブクエリの結果のブロードキャスト/ * + BROADCAST（small）* /が行われる以下のクエリで役立ちます。これは、クエリの最初ではなく、後の段階で準備が整います。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> <span class="hljs-comment">/*+ BROADCAST(small) */</span><font></font>
 big.field3, small.field1, small.field2<font></font>
  <span class="hljs-keyword">from</span> source_scheme.big_table <span class="hljs-keyword">as</span> <span class="hljs-keyword">big</span>
 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> t1.field1, t2.field2
               <span class="hljs-keyword">from</span> source_scheme.table1 <span class="hljs-keyword">as</span> t1
              <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> source_scheme.table2 <span class="hljs-keyword">as</span> t2
                 <span class="hljs-keyword">on</span> t1.field1 = t2.field1) small
    <span class="hljs-keyword">on</span> big.field2 = small.field2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒントがオプティマイザによって考慮に入れられていること、およびブロードキャストが実際に可能であることを確認するには、SQLタブのクエリ実行プランのYarn内の対応するSparkアプリケーションの追跡UI列のリンクを確認します。SparkSQLには</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/iw/rd/csiwrd4ya3wh0so0r7cversdjl0.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、</font><font style="vertical-align: inherit;">バージョン2.4以降、ヒント/ * + COALESCE（n）* /が表示されます。nは結果が分割されるパーティションの数です。/* + REPARTITION（n）* /、ここでnは再パーティション化中のパーティションの数です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SKEWEDキーを明示的に指定してSKEWED JOINをバイパスする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのテーブルについて考えてみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AIDフィールドを持つテーブルA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIDフィールドを持つテーブルB</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーA.AID = B.BIDを使用してこれらのテーブルを結合する必要があります。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> A.*, B.* <span class="hljs-keyword">from</span> A <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.AID = B.BID;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルの1つで発生するキー値が均等に分散されていない場合を検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルBで、キー値BID 4089、4107、4468、および6802が行全体の70％を占め、BIDキーの残りの100万個の値が行の残りの30％だけを占めると仮定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、表Aでは、AIDキーの値は多かれ少なかれ均等に分散されているが、4089、4107、4468、および6802の値は1回発生していると想定しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、このテーブル結合はスキュー結合と呼ばれます。 「ゆがんだ接続」、および頻度が高すぎるキーは、ゆがんだキーと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、spark-submitによって実行される2つのテーブルを結合するタスクは、200のパーティションに分割されます。このデフォルト設定を変更するには、別のspark.sql.shuffle.partitions構成値を設定します。次に例を示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">--conf spark.sql.shuffle.partitions=1000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sparkはスキュー結合をどのように処理しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒントのないSparkは、データが不均等に分散されていることを認識せず、テーブルを結合するタスクを次のように分散します。ほとんどのキー値は、少量のデータをすばやく処理する「軽い」パーティションに分類されます。この場合、偏ったキーの処理は「重い」パーティションに分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の図は、このようなケースの例を示しています。1000個のパーティションのうち999個は迅速に動作し、少数の要約行が表示され、ほとんどすべてのデータを取得した一部が数時間動作しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l0/l7/ya/l0l7ya40dzuv05i8rytaqgr2gc4.png"><br>
<br>
<img src="https://habrastorage.org/webt/j_/we/vm/j_wevm3rpbgjjq2ie8g1fkp1prq.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティション間の接続されたデータの分散をより均一にする方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、1つのキーA.AID = B.BIDではなく、1組のキーでテーブルを結合し、1組のキー間のデータの分布をより均一にする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルBには数値フィールドBID2もあると仮定しましょう。データは（BIDとは異なり）均等に分散されます。均等に分散された数値フィールドがない場合は、他のフィールドの連結からハイブとスパークで機能するハッシュ（）関数によって生成できます。この場合、hash（）関数は均等に分散されたデータを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のスパークリクエストで問題が解決します。このクエリは、</font><i><font style="vertical-align: inherit;">「select A. *、B. * from A inner join B on A.AID = B.BID;」の</font></i><font style="vertical-align: inherit;">代わりに使用する必要があり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
withセクションは、テーブルAとBの上記のデータの例を示しています。BIDキーに偏ったデータがあります。 ANTISKEWサブクエリが生成され、キー4089、4107、4468、6802の歪んだ値がそれぞれ10コピーに乗算されます。テーブルAのデータはANTISKEWサブクエリに接続されているため、4089、4107、4468および6802に等しいAIDキーのA_配列に、0から9までの異なるANTISKEWKEY値を持つ10個のインスタンスが形成されます。同時に、A_配列の他のAID値については、 ANTISKEWKEY = 0の1つのコピー。次に、A_.AID = B.BIDの条件だけでなく、2番目のキーペアによってもA_配列がテーブルBに接続されます。つまり、偏ったBIDキー値の場合、BID2を10で割った残りの部分に応じて、テーブルBの多数のレコードが0から9のANTISKEWKEY値のいずれかに接続されます。歪んでいないBID値は、ANTISKEWKEY = 0で1対1でマージされます。これにより、パーティション全体で歪んだBIDキーの分布がより均等になり、1つではなく10個のパーティションに移動します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">with</span> A <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">4089</span> AID <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">4468</span> AID <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">6802</span> AID <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">5</span> AID <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span>    <span class="hljs-number">8</span> AID <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span>   <span class="hljs-number">14</span> AID),<font></font>
     B <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">4089</span> BID,  <span class="hljs-number">1</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">4089</span> BID,  <span class="hljs-number">2</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">4089</span> BID,  <span class="hljs-number">3</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> 
           <span class="hljs-keyword">select</span> <span class="hljs-number">4107</span> BID,  <span class="hljs-number">4</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">4107</span> BID,  <span class="hljs-number">5</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">4107</span> BID,  <span class="hljs-number">6</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> 
           <span class="hljs-keyword">select</span> <span class="hljs-number">4468</span> BID,  <span class="hljs-number">7</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">4468</span> BID,  <span class="hljs-number">8</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">4468</span> BID,  <span class="hljs-number">9</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> 
           <span class="hljs-keyword">select</span> <span class="hljs-number">6802</span> BID, <span class="hljs-number">10</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">6802</span> BID, <span class="hljs-number">11</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span> <span class="hljs-number">6802</span> BID, <span class="hljs-number">12</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">1</span> BID, <span class="hljs-number">13</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">2</span> BID, <span class="hljs-number">14</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">3</span> BID, <span class="hljs-number">15</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">4</span> BID, <span class="hljs-number">16</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">5</span> BID, <span class="hljs-number">17</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">6</span> BID, <span class="hljs-number">18</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">7</span> BID, <span class="hljs-number">19</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">8</span> BID, <span class="hljs-number">20</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>    <span class="hljs-number">9</span> BID, <span class="hljs-number">21</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>   <span class="hljs-number">10</span> BID, <span class="hljs-number">22</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>   <span class="hljs-number">11</span> BID, <span class="hljs-number">23</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>   <span class="hljs-number">12</span> BID, <span class="hljs-number">24</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>   <span class="hljs-number">13</span> BID, <span class="hljs-number">25</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>   <span class="hljs-number">14</span> BID, <span class="hljs-number">26</span> BID2 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
           <span class="hljs-keyword">select</span>   <span class="hljs-number">15</span> BID, <span class="hljs-number">27</span> BID2)
<span class="hljs-keyword">select</span> A_.*, B.*
  <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> A.*, <span class="hljs-keyword">coalesce</span>(ANTISKEW.ANTISKEWKEY, <span class="hljs-number">0</span>) ANTISKEWKEY
          <span class="hljs-keyword">from</span> A
          <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> Y.ID, Z.ANTISKEWKEY
                      <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">4089</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                            <span class="hljs-keyword">select</span> <span class="hljs-number">4107</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                            <span class="hljs-keyword">select</span> <span class="hljs-number">4468</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                            <span class="hljs-keyword">select</span> <span class="hljs-number">6802</span> <span class="hljs-keyword">ID</span>) Y
                     <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">0</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">2</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">3</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">4</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">5</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">6</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">7</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">8</span> ANTISKEWKEY <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>
                                 <span class="hljs-keyword">select</span> <span class="hljs-number">9</span> ANTISKEWKEY) Z) ANTISKEW
            <span class="hljs-keyword">on</span> A.AID = ANTISKEW.ID) A_
 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B
    <span class="hljs-keyword">on</span> A_.AID = B.BID
   <span class="hljs-keyword">and</span> A_.ANTISKEWKEY = <span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> A_.AID <span class="hljs-keyword">in</span> (<span class="hljs-number">4089</span>, <span class="hljs-number">4107</span>, <span class="hljs-number">4468</span>, <span class="hljs-number">6802</span>) <span class="hljs-keyword">then</span> B.BID2%<span class="hljs-number">10</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データをさらに均等に分散するには、ANTISKEWサブクエリで、各キーを分割するパーティションの数を正確に選択する必要があります。</font><font style="vertical-align: inherit;">説明されている方法は、統計の知識を必要とします-どの歪んだキーに対して、行の何パーセントが期待されるべきか。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティショニングはBROADCASTの作成に役立ちます</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、小さいテーブルのサイズがブロードキャストに対して大きすぎる場合に、シャッフル結合の代わりにSpark SQLでブロードキャスト結合を行う方法について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがbig_table（100Gb）に参加する必要があるとしましょう</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> big_table(
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>),<font></font>
  key1 <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>)<font></font>
) <span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
small_tableあり（4Gb）</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> small_table(
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>),<font></font>
  key2 <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>)<font></font>
) <span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
small_tableのサイズが大きすぎてブロードキャストできないと想定されているため、エラーが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目標は、結果のテーブルを作成することです。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> result_table;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> result_table
<span class="hljs-keyword">select</span> big_table.id,<font></font>
       big_table.key1,<font></font>
       small_table.key2<font></font>
  <span class="hljs-keyword">from</span> big_table
  <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> small_table
    <span class="hljs-keyword">on</span> big_table.id = small_table.id;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
idキーとの接続は、正常に配信されると想定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結合された両方のテーブルをパーティション化してみましょう：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> big_table(
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>),<font></font>
  key1 <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>)<font></font>
) partitioned <span class="hljs-keyword">by</span> (part_mod <span class="hljs-built_in">decimal</span>(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet;<font></font>
<font></font>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> small_table(
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>),<font></font>
  key2 <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>)<font></font>
) partitioned <span class="hljs-keyword">by</span> (part_mod <span class="hljs-built_in">decimal</span>(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティションテーブルbig_tableとsmall_tableの両方に入力するとき、パーティションキーpart_modをidを4で割った余りと等しくします</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。part_mod = id％4; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの場所big_table（part_mod = 0）を見る疑似テーブルを取得しましょう。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> big_table_0(
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>),<font></font>
  key1 <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>)<font></font>
) <span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet location <span class="hljs-string">'…/big_table/part_mod=0'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、1つの場所small_table（part_mod = 0）を参照する疑似テーブルを作成します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> small_table_0(
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>),<font></font>
  key1 <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">0</span>)<font></font>
) <span class="hljs-keyword">stored</span> <span class="hljs-keyword">as</span> parquet location <span class="hljs-string">'…/small_table/part_mod=0'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、上記の疑似テーブルの接続から必要なデータの4分の1を結果のテーブルに書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、BROADCASTヒントが正常に機能することが確認されました。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> result_table;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> result_table
<span class="hljs-keyword">select</span> <span class="hljs-comment">/*+ BROADCAST(small_table_0)*/</span> big_table_0.id,<font></font>
       big_table_0.key1,<font></font>
       small_table_0.key2<font></font>
  <span class="hljs-keyword">from</span> big_table_0
  <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> small_table_0
    <span class="hljs-keyword">on</span> big_table.id = small_table.id;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の3つのステップでは、データの残りの4分の3を同様に、part_mod = 1、part_mod = 2、part_mod = 3で結果のテーブルに追加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステップバイステップのブロードキャストパーティションメソッドを使用して結果のテーブルをロードする合計時間は、通常、シャッフル結合メソッドよりも少ない同じリソースで取得されます。</font><font style="vertical-align: inherit;">ただし、この方法では、初期データを含むテーブルを事前に同じ方法で分割する必要があります。</font><font style="vertical-align: inherit;">接続する任意の数でidを割った余り。</font><font style="vertical-align: inherit;">idが整数でない場合、ハッシュ（id）を任意の数で割った余りをとることができます。</font><font style="vertical-align: inherit;">中間（ステージング）テーブルを事前にパーティション分割して、開発者の裁量で設計することは特に簡単です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソース監視</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、データレイクを使用する場合、データ読み込みタスクにリソースを適切に割り当てることが重要です。</font><font style="vertical-align: inherit;">そうしないと、リソースの不足、タスクが長すぎる、または他のタスクを損なうためのリソースの不当に高い割り当てのために、タスクが落ちるリスクがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースを正しく割り当てる方法は別の問題です。</font><font style="vertical-align: inherit;">同じ記事で、理解方法について説明します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムスキャンでYarnがタスクまたはタスクグループに割り当てたリソースの数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムスキャンでYarnマネージャーによってSparkに割り当てられたリソースの数から、Sparkが実際にタスクに使用したリソースの数。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、グラファイト/グラファナなど、リソースを監視するための特別な方法がありますが、構成が必要です。以下に、コマンドライン、Spark SQL、Sparkログを使用して「ひざまずく」結果を取得する方法を示します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初に、最初のタイプの監視（「糸の監視」）について説明します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
親切なコマンド</font></font><br>
<br>
<pre><code class="plaintext hljs">while [ ! -f complete.flg ]; do for app in $(yarn application -list -appStates RUNNING | grep &lt;filter_for_app_names&gt; | awk '{print $1}'); do ( command1 () { date +"%Y-%m-%d %H:%M:%S"; }; command2 () { yarn application -status $app; }; x=&lt;loading_date&gt;"|"&lt;loading_id&gt;"|$(command1) $(command2)"; echo $x &gt;&gt; app.txt; ) &amp; done; wait; done</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下が実行されます。</font><font style="vertical-align: inherit;">監視期間中、フラグがcomplete.flgファイルの形式で設定されている場合、RUNNINGステータスにあり、名前にテンプレート&lt;filter_for_app_names&gt;があるYarnアプリケーションのリストを循環して、yarn application –status $ appコマンドの結果がテキストファイルに追加されます。 。</font><font style="vertical-align: inherit;">したがって、モニタリングの各瞬間のテキストファイルapp.txtには、各アプリケーションの動作中に累積されたメガバイト*秒（MB秒）およびカーネル*秒（vcore秒）に関する情報が含まれています。</font><font style="vertical-align: inherit;">モニタリングの最後に、complete.flg完了フラグが設定され、結果のapp.txtファイルが、yarn_monitoringテキストテーブルのhdfsに転送されます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTERNAL</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> scheme_name.yarn_monitoring(<font></font>
  loading_date <span class="hljs-keyword">string</span>,<font></font>
  loading_id <span class="hljs-keyword">string</span>,<font></font>
  txt <span class="hljs-keyword">string</span><font></font>
)<font></font>
<span class="hljs-keyword">ROW</span> <span class="hljs-keyword">FORMAT</span> SERDE
  <span class="hljs-string">'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'</span>
<span class="hljs-keyword">WITH</span> SERDEPROPERTIES (
  <span class="hljs-string">'field.delim'</span>=<span class="hljs-string">'|'</span>,
  <span class="hljs-string">'serialization.format'</span>=<span class="hljs-string">'|'</span>) 
<span class="hljs-keyword">STORED</span> <span class="hljs-keyword">AS</span> INPUTFORMAT
  <span class="hljs-string">'org.apache.hadoop.mapred.TextInputFormat'</span><font></font>
OUTPUTFORMAT<font></font>
  <span class="hljs-string">'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'</span><font></font>
LOCATION<font></font>
  <span class="hljs-string">'…/yarn_monitoring'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この表の行は次の形式です。</font></font><br>
<br>
<pre><code class="sql hljs">2020-02-18|2235599|2020-02-18 01:00:44 Application Report : Application-Id : application_1580486634374_3632578 Application-Name : &lt;app_name&gt; Application-Type : SPARK User : &lt;user&gt; Queue : &lt;yarnqueue&gt; <span class="hljs-keyword">Start</span>-<span class="hljs-built_in">Time</span> : <span class="hljs-number">1581976835176</span> <span class="hljs-keyword">Finish</span>-<span class="hljs-built_in">Time</span> : <span class="hljs-number">0</span> Progress : <span class="hljs-number">10</span>% State : RUNNING <span class="hljs-keyword">Final</span>-State : UNDEFINED <span class="hljs-keyword">Tracking</span>-<span class="hljs-keyword">URL</span> : &lt;<span class="hljs-keyword">url</span>&gt; RPC Port : <span class="hljs-number">0</span> AM Host : &lt;host&gt; <span class="hljs-keyword">Aggregate</span> <span class="hljs-keyword">Resource</span> Allocation : <span class="hljs-number">18663</span> MB-<span class="hljs-keyword">seconds</span>, <span class="hljs-number">9</span> vcore-<span class="hljs-keyword">seconds</span> <span class="hljs-keyword">Log</span> Aggregation <span class="hljs-keyword">Status</span> : NOT_START <span class="hljs-keyword">Diagnostics</span> :</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、同じSpark SQLで、このテキストテーブルにクエリを記述して、監視の各瞬間に使用されたリソースのインジケーターの値（MB秒、vcore秒）を解析することができます。さらにこのクエリでは、ベクトルグラフィック形式* .svgのグラフの形でこれらのインジケーターを視覚化できます。</font></font><br>
<br>
<pre><code class="sql hljs">…<font></font>
&lt;text x="101" y="21" font-size="10" fill="rgb(0,150,255)"&gt;13:47:48&lt;/text&gt;<font></font>
&lt;line x1="948" x2="949" y1="2041" y2="2041" style="stroke:rgb(255,0,0); stroke-width:1px"/&gt; <font></font>
…</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストの結果を* .svgファイルに保存して、ブラウザで表示できます。 Yarn監視対象アプリケーショングループが使用するリソースの監視結果の画像の例を以下に示します。使用済みメモリのダイナミクスは赤で表示され、使用済みプロセッサコアのダイナミクスは青で表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nn/yo/le/nnyole0wfcl1dxhctvm-bu4waf4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この視覚化に基づいて、特定のYarnアプリケーションの実行スケジュールの変更を決定し、日中のリソースをより均等に使用できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、2番目のタイプの監視（「スパーク監視」）について説明します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、興味深い状況は、YarnがSparkタスク（たとえば、200コア）に割り当てられていて、これらのリソースを他のタスクに割り当てていない場合です。ただし、実際には、Sparkアプリケーションでは200コアのうち199コアが使用されておらず、1つのコアのみが実際に機能し続けています。このタイプの監視は、とりわけ、そのような状況を見つけることを目的としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
監視されているSparkアプリケーションは、特定の制御メカニズムから呼び出されると考えています。 Sberbankの場合、これはたとえばOozieまたはInformatica BDMです。したがって、制御メカニズムは、Sparkアプリケーションの完了時に、ログをhdfsにコピーし、このログ（またはログのグループ）を解析して、実際に使用されているSparkカーネルのダイナミクスを* .svg形式で視覚化することにより、小さなSpark SQLアプリケーションを起動できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、以下のコマンドを使用して、次のことを行います。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、「application_1576046768499_16691」のように、アプリケーション識別子を変数$ appに保存します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">command1コマンドを使用して、$ app ".txt"ファイルに、完了したSparkアプリケーションのステータスを含むヘッダー行を書き込みます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンド「yarn logs -applicationId $ app」を使用して、Yarnから受信した完了したSparkアプリケーションのログをファイル$ app ".txt"に追加します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成された$ app ".txt"ファイルをステータスとともに転送し、hdfsにログを記録します。</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">'app=$(grep "(state: FINISHED)" /tmp/'&lt;spark_log_file&gt;' | grep -o "application_[^ ]*" | tee /tmp/applicationid_'&lt;yarn_task_name&gt;'.txt); command1 () { yarn application -status $app; }; x="'&lt;loading_date&gt;'|'&lt;loading_id&gt;'|$app|0|$(command1)"; echo $x &gt; "/tmp/"$app".txt"; yarn logs -applicationId $app | nl -ba -s"|" | sed "s/^/'&lt;loading_date&gt;'|'&lt;loading_id&gt;'|"$app"|/" &gt;&gt; "/tmp/"$app".txt"; hdfs dfs -copyFromLocal -f "/tmp/"$app".txt" …/spark_monitoring; rm "/tmp/"$app".txt"'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、hdfsでは次の形式の行が得られます。</font></font><br>
<br>
<pre><code class="sql hljs">2019-12-13|1227125|application_1576046768499_16691|0|Application Report : Application-Id : application_1576046768499_16691 Application-Name : &lt;app_name&gt; Application-Type : SPARK User : &lt;user&gt; Queue : &lt;yarnqueue&gt; <span class="hljs-keyword">Start</span>-<span class="hljs-built_in">Time</span> : <span class="hljs-number">1576229137128</span> <span class="hljs-keyword">Finish</span>-<span class="hljs-built_in">Time</span> : <span class="hljs-number">1576229189406</span> Progress : <span class="hljs-number">100</span>% State : FINISHED <span class="hljs-keyword">Final</span>-State : SUCCEEDED <span class="hljs-keyword">Tracking</span>-<span class="hljs-keyword">URL</span> : <span class="hljs-keyword">http</span>://...sbrf.ru:<span class="hljs-number">18089</span>/history/application_1576046768499_16691/<span class="hljs-number">1</span> RPC Port : <span class="hljs-number">0</span> AM Host : … <span class="hljs-keyword">Aggregate</span> <span class="hljs-keyword">Resource</span> Allocation : <span class="hljs-number">93763306</span> MB-<span class="hljs-keyword">seconds</span>, <span class="hljs-number">9957</span> vcore-<span class="hljs-keyword">seconds</span> <span class="hljs-keyword">Log</span> Aggregation <span class="hljs-keyword">Status</span> : NOT_START <span class="hljs-keyword">Diagnostics</span> :
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">1</span>|
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">2</span>|
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">3</span>|<span class="hljs-keyword">Container</span>: container_1576046768499_16691_01_000162 <span class="hljs-keyword">on</span> …sbrf.ru_8041
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">4</span>|===========================================================================================
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">5</span>|LogType:<span class="hljs-keyword">container</span>-localizer-syslog
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">6</span>|<span class="hljs-keyword">Log</span> Upload <span class="hljs-built_in">Time</span>:Fri <span class="hljs-built_in">Dec</span> <span class="hljs-number">13</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">32</span> +<span class="hljs-number">0300</span> <span class="hljs-number">2019</span>
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">7</span>|LogLength:<span class="hljs-number">0</span>
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">8</span>|<span class="hljs-keyword">Log</span> <span class="hljs-keyword">Contents</span>:
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|     <span class="hljs-number">9</span>|<font></font>
…<font></font>
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|    <span class="hljs-number">53</span>|<span class="hljs-number">19</span>/<span class="hljs-number">12</span>/<span class="hljs-number">13</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">02</span> INFO executor.Executor: Running task <span class="hljs-number">26.0</span> <span class="hljs-keyword">in</span> stage <span class="hljs-number">0.0</span> (TID <span class="hljs-number">19</span>)<font></font>
 …<font></font>
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|    <span class="hljs-number">82</span>|<span class="hljs-number">19</span>/<span class="hljs-number">12</span>/<span class="hljs-number">13</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">07</span> INFO executor.Executor: Finished task <span class="hljs-number">26.0</span> <span class="hljs-keyword">in</span> stage <span class="hljs-number">0.0</span> (TID <span class="hljs-number">19</span>). <span class="hljs-number">5735</span> <span class="hljs-keyword">bytes</span> <span class="hljs-keyword">result</span> sent <span class="hljs-keyword">to</span> driver<font></font>
 …<font></font>
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|    <span class="hljs-number">84</span>|<span class="hljs-number">19</span>/<span class="hljs-number">12</span>/<span class="hljs-number">13</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">07</span> INFO executor.Executor: Running task <span class="hljs-number">441.0</span> <span class="hljs-keyword">in</span> stage <span class="hljs-number">0.0</span> (TID <span class="hljs-number">364</span>)<font></font>
 …<font></font>
<span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span>|<span class="hljs-number">1227125</span>|application_1576046768499_16691|   <span class="hljs-number">102</span>|<span class="hljs-number">19</span>/<span class="hljs-number">12</span>/<span class="hljs-number">13</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08</span> INFO executor.Executor: Finished task <span class="hljs-number">441.0</span> <span class="hljs-keyword">in</span> stage <span class="hljs-number">0.0</span> (TID <span class="hljs-number">364</span>). <span class="hljs-number">5543</span> <span class="hljs-keyword">bytes</span> <span class="hljs-keyword">result</span> sent <span class="hljs-keyword">to</span> driver<font></font>
…</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解析時に、Sparkアプリケーションログは、特定のコンテナー、つまり、クラスターによるニュークリアスの使用と解放の開始のイベントを探します </font><font style="vertical-align: inherit;">次のパターンに従ってイベントログに書き込む時間を探しています。</font></font><br>
<br>
<pre><code class="sql hljs">INFO executor.Executor: Running task<font></font>
INFO executor.Executor: Finished task</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、任意の時点で、Sparkアプリケーションの動作中にアクティブだったプロセッサコアの数がわかります。</font><font style="vertical-align: inherit;">仕事を始めてまだ完了していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hdfsで収集されたログを解析するために、spark_monitoringテーブルがテキスト形式で生成されます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTERNAL</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> scheme_name.spark_monitoring(<font></font>
  loading_date <span class="hljs-keyword">string</span>,<font></font>
  loading_id <span class="hljs-keyword">string</span>,<font></font>
  applicationid <span class="hljs-keyword">string</span>,<font></font>
  rn <span class="hljs-keyword">string</span>,<font></font>
  txt <span class="hljs-keyword">string</span><font></font>
)<font></font>
<span class="hljs-keyword">ROW</span> <span class="hljs-keyword">FORMAT</span> SERDE
  <span class="hljs-string">'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'</span>
<span class="hljs-keyword">WITH</span> SERDEPROPERTIES (
  <span class="hljs-string">'field.delim'</span>=<span class="hljs-string">'|'</span>,
  <span class="hljs-string">'serialization.format'</span>=<span class="hljs-string">'|'</span>) 
<span class="hljs-keyword">STORED</span> <span class="hljs-keyword">AS</span> INPUTFORMAT
  <span class="hljs-string">'org.apache.hadoop.mapred.TextInputFormat'</span><font></font>
OUTPUTFORMAT<font></font>
  <span class="hljs-string">'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'</span><font></font>
LOCATION<font></font>
  <span class="hljs-string">'…/spark_monitoring'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、ログの解析はSpark SQLによって実行されます。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">クエリがこのテーブルspark_monitoringに書き込まれました。出力では、Sparkアプリケーションによるクラスターコアの実際の使用のダイナミクスを含む* .svg形式の画像が表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストの結果を* .svgファイルに保存して、ブラウザで表示できます。</font><font style="vertical-align: inherit;">画像の例を以下に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yu/vi/ie/yuviieatqcri0xusj62fxyykgp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのグラフに基づいて、Sparkアプリケーションが割り当てられたクラスターのプロセッサコアを効果的に使用しているかどうかを理解できます。アプリケーションをまとめて見ることができます。グラフに表示される上下の鋭いジャンプは、Sparkアプリケーションのステージ間の遷移です。データ配列の読み取りまたは接続のいくつかの段階が終了し、すべてのコアが一度に1つずつ解放されると、グラフはゼロに減少します。また、新しいステージの実装の初めに、使用済みコアが急激に増加しています。割り当てられたコアの最大数までスケジュールが引き出され、ステップ間のジャンプが急激である状況は、リソースの最適な使用の兆候です。緩やかな減少は、たとえば、上記のこの記事で説明したスキュー結合を示している可能性があります。</font></font><br>
<br>
<blockquote>:  ,     SberProfi DWH/BigData.<br>
<br>
  SberProfi DWH/BigData       ,   Hadoop, Teradata, Oracle DB, GreenPlum,   BI  Qlik, SAP BO, Tableau  .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496292/index.html">脊髄の神経刺激は、脊髄損傷後に麻痺した人々が歩くことを可能にします</a></li>
<li><a href="../ja496300/index.html">スタートアップASP.NETコアの非同期コード：GetAwaiter（）を回避する4つの方法GetResult（）</a></li>
<li><a href="../ja496302/index.html">ハッカーが不在の間にハッカーに会社を渡さない方法。SOCスペシャリストのためのヒント</a></li>
<li><a href="../ja496304/index.html">ゲームの作成中にUE4を学習し続ける方法</a></li>
<li><a href="../ja496308/index.html">シームレスなノイズマップを作成する</a></li>
<li><a href="../ja496312/index.html">CentOS 8にAIDE（Advanced Intrusion Detection Environment）をインストールして使用する方法</a></li>
<li><a href="../ja496316/index.html">Androidネイティブライブラリの機能リダイレクト</a></li>
<li><a href="../ja496320/index.html">Kaspersso Autotest Frameworkに関するオンラインQ＆Aセッション</a></li>
<li><a href="../ja496324/index.html">regtech企業が金融サービス部門がCOVID-19リスクを制御するのをどのように支援するか</a></li>
<li><a href="../ja496328/index.html">Mediastreamer2 VoIPエンジンを研究します。パート6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>