<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔑 🤛🏾 🌛 Linuxカーネルでの再配置について少し 🚵🏾 👨🏾‍🍳 ✳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="簡単な問題を解決します。Linuxカーネルのスペースでメモリブロックを選択し、そこにバイナリコードを挿入して実行します。これを行うには、カーネルモジュールを記述し、そこに関数fooを定義します。これは、必要なバイナリコードの役割を果たします。次に、module_alloc関数を使用して、メモリブロッ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Linuxカーネルでの再配置について少し</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な問題を解決します。Linuxカーネルのスペースでメモリブロックを選択し、そこにバイナリコードを挿入して実行します。</font><font style="vertical-align: inherit;">これを行うには、カーネルモジュールを記述し、そこに関数fooを定義します。これは、必要なバイナリコードの役割を果たします。次に、module_alloc関数を使用して、メモリブロックを選択し、この関数全体をmemcpyを通じてコピーして、制御を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは次のようになります。</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールがロードされると、exe_init関数が呼び出されます。</font><font style="vertical-align: inherit;">カーネルログで作業の結果を確認します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが正常に動作しています。</font><font style="vertical-align: inherit;">次に、printk関数をfooに追加して、引数を表示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、制御を渡す前にnew_foo（）関数の内容の25バイトをダンプします。</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダンプは次のように定義されます</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールをロードすると、ログに次のメッセージが表示されてクラッシュします。</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どういうわけか、私たちはirq_create_direct_mapping関数になりましたが、printkを呼び出す必要がありました。</font><font style="vertical-align: inherit;">何が起こったのか理解しよう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、foo関数の逆アセンブルされたリストを見てください。</font><font style="vertical-align: inherit;">objdump -dコマンドで取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
foo関数は、テキストセクションの先頭にあります。オフセット0xCには、near呼び出しコマンドe8のオペコードが配置されています。これは、現在のコードセグメントで実行されるため、セレクター値は変更されません。次の4バイトは、制御が転送されるRIPレジスタの値に関連するオフセットです。 RIP = RIP +オフセット、Intelのドキュメント（Intel 64およびIA-32アーキテクチャソフトウェア開発者マニュアル、命令セットリファレンスAZ）によると：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相対オフセット（rel16またはrel32）は、通常、アセンブリコードのラベルとして指定されます。</font><font style="vertical-align: inherit;">ただし、マシンコードレベルでは、符号付きの16ビットまたは32ビットの即値としてエンコードされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この値は、EIP（RIP）レジスタの値に追加されます。</font><font style="vertical-align: inherit;">64ビットモードでは、相対オフセットは常に32ビットの即値であり、ターゲット計算のためにRIPレジスタの値に追加される前に64ビットに符号拡張されます。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数fooのアドレスがわかっています。これは0xffffffffc0000000なので、RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011（0xcはe8命令へのオフセット、1バイトの命令と4バイトのオフセット）です。</font><font style="vertical-align: inherit;">私たちはオフセットを知っています、なぜなら </font><font style="vertical-align: inherit;">ダンプされたボディ関数。</font><font style="vertical-align: inherit;">関数fooに送信する呼び出しの送信先を計算してみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、printk関数のアドレスです。</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、アドレスが0xffffffffc0007000であるnew_fooにも同じことが言えます。</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
kallsymsにはそのようなアドレスはありませんが、0xffffffff810badf9-0x79 = 0xffffffff810bad80があります</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、クラッシュが発生したまさにその機能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラッシュを防ぐには、new_foo関数のアドレスを知って、オフセットを再計算します。</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この修正後、クラッシュは発生せず、new_foo関数は正常に実行され、制御を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は解決された。</font><font style="vertical-align: inherit;">逆アセンブラーでe8オペコードがゼロになった後のオフセットを一覧表示する理由を理解するだけですが、ダンプには機能がありません。</font><font style="vertical-align: inherit;">これを行うには、再配置とは何か、カーネルがそれらとどのように連携するかを検討します。</font><font style="vertical-align: inherit;">しかし、最初に、ELFフォーマットについて少し説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELFは、Executable and Linkable Format（実行可能で構成可能なファイルの形式）の略です。 ELFファイルはセクションのコレクションです。このセクションには、リンカが実行可能イメージを形成するために必要な一連のオブジェクト（命令、データ、シンボルテーブル、再配置のレコードなど）が格納されます。各セクションは見出しで説明されています。すべてのヘッダーはヘッダーのテーブルに収集され、基本的に各要素がインデックスを持つ配列です。セクションヘッダーには、セクションの先頭へのオフセットと、ヘッダーテーブルでインデックスを指定することによる他のセクションへのリンクなどの他のオーバーヘッド情報が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストケースを作成するとき、コンパイラーはprintk関数のアドレスを認識しないため、呼び出し位置にゼロ値を入力し、再配置レコードを使用して、この位置に有効な値を入力する必要があることをカーネルに通知します。再配置レコードには、変更を加える位置（再配置位置）へのオフセット、再配置のタイプ、およびシンボルテーブル内のシンボルのインデックスが含まれます。そのアドレスは、指定されたオフセットで置き換える必要があります。転勤のタイプは何ですか？以下を検討します。再配置レコードのセクションの見出しは、インデックスを介して、文字とセクションのテーブルを持つセクションの見出しを参照します。その先頭には、再配置の位置へのオフセットが指定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-rスイッチを指定したobjdumpユーティリティを使用して、再配置レコードの内容を確認できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆アセンブルされたリストから、オフセット0xDでprintk関数のアドレスを書き込む必要があることがわかっているため、次の位置のobjdump出力を探しています。</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、オフセット0xDでの位置と、この位置にアドレスを書き込む必要があるシンボルの名前を示す必要な再配置レコードがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値（-4）。</font><font style="vertical-align: inherit;">これは、printk関数のアドレスに追加されるものを追補といい、再配置の最終結果を計算するときに考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、printkシンボルを見てください。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンボルがあり、モジュール内で未定義（未定義）なので、カーネルで検索します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリ形式の再配置とシンボルの記録を確認すると、より有益になります。</font><font style="vertical-align: inherit;">これは、wiresharkを使用して行うことができ、ELF形式を解析できます。</font><font style="vertical-align: inherit;">これが私たちの再配置エントリです（writesharkからコピーペースト、左側のLSB）：</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このエントリを、&lt;linux / elf.h&gt;の対応する構造の定義と比較します。</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、8バイトのオフセット0x00000000d、4バイトのタイプ0x00000002、文字テーブルの4バイトのインデックス0x00000022（または10進数の34）と8バイトの補遺-4があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これが番号34のシンボルテーブルのエントリです。</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
および関連構造</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の4バイト0x00000101は、文字列.strtabのテーブル内のこの文字の名前へのインデックスです。 printk。 st_infoフィールドは、シンボルのタイプを定義します。これは、関数、データオブジェクトなどです。詳細については、ELF仕様を参照してください。 st_otherフィールドはスキップしますが、ここでは関係ありません。最後の3つのフィールドst_shndx、st_value、st_sizeを見てください。 st_shndx-文字が定義されているセクションのヘッダーインデックス。ここではゼロの値が表示されます。シンボルはモジュール内で定義されておらず、使用可能なセクションにはありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、そのst_value値とst_sizeサイズもゼロです。これらのフィールドは、モジュールのロード時にカーネルによって入力されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較のために、明らかに存在するシンボルfooを見てください。</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンボルは、0x00000000セクションの先頭を基準にしたアドレスの.textセクションにある関数を定義します。</font><font style="vertical-align: inherit;">セクションの冒頭では、逆アセンブルされたリストで見たように、関数のサイズは22バイトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objdumpはこれについて同じ情報を表示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネルがモジュールをロードすると、すべての未定義文字が検出され、st_valueおよびst_sizeフィールドに有効な値が入力されます。</font><font style="vertical-align: inherit;">これは、simply_symbols関数のkernel / module.cファイルで行われます。</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数のパラメーターでは、次の形式のload_info構造体が渡されます</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のフィールドは私たちにとって重要です：</font><font style="vertical-align: inherit;">
 -hdr </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ELFファイルヘッダー</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-sechdrs-セクションヘッダーテーブルへのポインター</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -strtab-シンボル名テーブル-ゼロで区切られた文字列のセット</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -index.sym-シンボルテーブルを含むセクションのヘッダーインデックス</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、関数がアクセスしますシンボルテーブルのあるセクションへ。</font><font style="vertical-align: inherit;">シンボルテーブルは、Elf64_Sym型の要素の配列です。</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ループで、テーブル内のすべての文字を調べ、それぞれの名前を決定します。</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
st_shndxフィールドには、この文字が定義されているセクションのヘッダーインデックスが含まれます。</font><font style="vertical-align: inherit;">ゼロの値（私たちの場合）がある場合、このシンボルはモジュール内にありません。カーネルでそれを探す必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、apply_relocations関数に再配置キューがあります。</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループでは、再配置セクションを探し、apply_relocate_add関数で見つかった各セクションのレコードを処理します。</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セクションヘッダーテーブルへのポインター、シンボル名テーブルへのポインター、シンボルテーブルを含むセクションヘッダーインデックス、および再配置セクションヘッダーインデックスは、apply_relocate_addに渡されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、再配置セクションについて説明します。</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ループで、そのエントリの配列をソートします。</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再配置のセクションとその中での位置を見つけます。</font><font style="vertical-align: inherit;">変更が必要な場所。</font><font style="vertical-align: inherit;">再配置セクションヘッダーのsh_infoフィールドは、再配置用のセクションヘッダーのインデックスです。再配置レコードのr_offsetフィールドは、再配置用のセクション内の位置へのオフセットです。</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補遺を考慮に入れて、この位置で置換される文字のアドレス。</font><font style="vertical-align: inherit;">再配置レコードのr_infoフィールドには、シンボルテーブル内のこのシンボルのインデックスが含まれています。</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再配置のタイプによって、計算の最終結果が決まります。この例では、R_X86_64_PLT32です。</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sym-&gt; st_valueがprintk関数0xffffffff810b3df9のアドレスであり、r_addendが（-4）であり、再配置の位置へのオフセットがモジュールテキストセクションの先頭から、またはfoo関数の先頭から0xdであることを知っているので、これで自分自身で最終的なvalを計算できます。</font><font style="vertical-align: inherit;">ffffffffc000000dになります。</font><font style="vertical-align: inherit;">これらのすべての値を置き換えて、以下を取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に取得したfoo関数のダンプを見てみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オフセット0xDで、値0xc10b3de8が見つかります。これは、計算した値と同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、カーネルが再配置を処理し、close callコマンドに必要なオフセットを取得する方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の作成では、Linuxカーネルバージョン5.4.27を使用しました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504420/index.html">同時移動を伴うターンベースのPvPアリーナの作成</a></li>
<li><a href="../ja504422/index.html">Kafka Streamsを使用したSpring Bootアプリケーション</a></li>
<li><a href="../ja504430/index.html">Everyday Life Tinkoff Security Operations Center：シングルブートローダー分析</a></li>
<li><a href="../ja504434/index.html">親のための教育プログラム：インターネットで子供を危険から守る方法</a></li>
<li><a href="../ja504438/index.html">1週間あたり30ミタップ。2020年夏シーズンオープン</a></li>
<li><a href="../ja504444/index.html">docker multi-stageを使用してWindowsイメージを構築する</a></li>
<li><a href="../ja504446/index.html">VLSI自動原価計算で行ったように</a></li>
<li><a href="../ja504448/index.html">ゲーマージェネレーションII</a></li>
<li><a href="../ja504450/index.html">最新のJavaScript：側面図</a></li>
<li><a href="../ja504452/index.html">オントロジーがレイヤー2を発表、より統合されたパブリックチェーンプラットフォームに貢献</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>