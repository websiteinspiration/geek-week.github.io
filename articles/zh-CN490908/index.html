<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐉 💰 👈🏿 区域数据存储 🤘🏽 🐱 🎥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Western Digital最近宣布了其区域存储计划，该计划旨在旨在利用区域存储设备的开放数据基础架构。
 
 分区存储是一种新的存储模式，其驱动力是不可思议的数据增长。我们的社会越来越依赖于日常生活中的数据，并且越来越需要大规模的数据管理。如今，在大规模数据处理基础架构中，已经使用了成千上万的硬...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>区域数据存储</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wd/blog/490908/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/3b/hz/nv3bhzqzmm1n2rhzvh1gqu4brng.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Western Digital最近宣布了其区域存储计划，该计划旨在旨在利用区域存储设备的开放数据基础架构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分区存储是一种新的存储模式，其驱动力是不可思议的数据增长。</font><font style="vertical-align: inherit;">我们的社会越来越依赖于日常生活中的数据，并且越来越需要大规模的数据管理。</font><font style="vertical-align: inherit;">如今，在大规模数据处理基础架构中，已经使用了成千上万的硬盘驱动器和固态驱动器。</font><font style="vertical-align: inherit;">但是，即使如此，在每年创建的30多个ZB数据中，仍不到20％的存储空间。</font><font style="vertical-align: inherit;">我们行业的目标是确保消费者负担得起不丢掉有益的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将讨论：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是区域存储设备以及为什么要实施该技术</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMR硬盘驱动器和ZNS固态驱动器</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据基础架构-实施区域数据存储需要什么</font></font></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是区域存储设备？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以其最简单的形式，区域存储设备是其地址空间分为区域的块存储设备。</font><font style="vertical-align: inherit;">ZSD施加了非常规的记录规则：只能从区域的开头开始顺序记录区域。</font><font style="vertical-align: inherit;">此外，区域内的数据不能任意覆盖。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fh/tu/ex/fhtuexqojzwesqou-bh6sy44cim.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覆盖已经记录的区域的唯一方法是重置区域记录指针，这将有效删除区域中的所有数据，并从区域的开头覆盖它。</font><font style="vertical-align: inherit;">另一方面，读取数据在很大程度上不受限制，并且可以通过与传统存储设备相同的方式进行读取。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区域存储设备的概念已标准化：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于具有SAS接口的设备，T10 ZBC标准中规定了使用区域的工作</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA也通过T13 ZAC标准化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于NVMe SSD，正在开发一项名为ZNS的技术建议。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么要分区存储？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应用分区存储技术的动机是存储基础架构的高效率。</font><font style="vertical-align: inherit;">由于有了这项技术，可以更经济地使用容量更大的设备。</font><font style="vertical-align: inherit;">有关每种类型的分区设备如何实现这种经济效率的更多详细信息，将在本文后面解释。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都始于SMR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在过去的几年中，在硬盘驱动器中引入了平铺磁记录（SMR）技术，这增加了记录密度，提高了硬盘驱动器的容量和成本效益。在SMR中，与常规记录不同，轨道的记录重叠，就像房屋屋顶上的瓷砖一样。这使您可以更密集地压缩轨道，因此可以提供更高的记录密度。实际上，使用SMR可以为我们提供“免费”的TB容量：在通常的12 TB磁盘的基础上，您可以制造14甚至15 TB SMR驱动器，而不会增加生产成本。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d2/gp/85/d2gp85zvtb68gyn1ulnnng-nbtc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该技术的主要局限性是无法以随机顺序将数据写入磁道。由于我们无法替换房屋屋顶上的任意瓷砖，因此使用SMR中的数据-我们不能在不钩住相邻轨道的情况下任意覆盖多个块。为了控制记录，将光盘表面分成多个区域，并在它们之间留有间隙。这使您可以彼此独立地记录和擦除每个区域（当前一代磁盘中区域的大小通常为256 MB）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用几种方法来控制记录限制。传统方法（驱动器管理-由驱动器本身控制）假定设备使用微码算法和缓冲区自行处理内部写限制，并提供正常的主机接口。这种SMR通常用于客户端设备（例如笔记本电脑HDD）中。但是，对于应该可预测性能和空间利用率的大型公司或云系统，不可能依靠光盘本身来控制顺序记录-性能“浮动”太多，取决于负载的结构和强度以及缓冲区的充满度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主机管理的SMR对大型数据存储系统几乎是强制性要求，并且是数据中心的首选选项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主机SMR控制已在INCITS T10 / T13中标准化，分别作为SAS和SATA的区域块命令（ZBC）和区域ATA（ZAC）设备标准的一部分。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固态驱动器中的NVMe和区域命名空间</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于固态驱动器（SSD），对只能顺序写入（NAND页面）并且必须在写入新数据（NAND块）之前必须删除的区域的存在限制是NAND闪存操作的一个固有属性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首次引入SSD时，他们引入了一个内部管理系统，称为Flash Translation Layer（FTL），它可以解决此记录限制。 FTL允许使用固态驱动器而不是硬盘驱动器，而无需立即重写软件堆栈。对于最终用户而言，SSD看起来像是具有快速随机访问信息的硬盘驱动器-这是FTL的优点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然而，就效率而言，固态驱动器内的本地控制远非理想。</font><font style="vertical-align: inherit;">特别是，有以下因素：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写放大：为了应对不覆盖数据的局限性，SSD必须自行移动数据以清理称为垃圾收集（GC）的未使用存储区域。</font><font style="vertical-align: inherit;">当FTL使用数据块“播放标签”时，垃圾收集过程会导致多次记录相同的信息（因此称为“多余的记录”），这会导致闪存的磨损增加，并缩短固态驱动器的寿命。</font><font style="vertical-align: inherit;">WA系数表示从主机接收到的一次写操作必须在驱动器内完成多少次写操作。</font></font></li>
</ul><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cj/2o/jt/cj2ojtou6g2sd22zje-vqdd0vra.png"></div><br>
<ul>
<li> (overprovisioning — OP):   (    28%   )             .</li>
<li>   DRAM :   FTL -         DRAM.  ,     DRAM     .        — 1      SSD.  ,    SSD  15.36  — 16 «» .  ,       !</li>
<li> QoS,               .  FTL   ,          , ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些缺点在第一波固态驱动器的引入中是可以接受的，因为软件堆栈和接口是为硬盘驱动器设计的，并且对HDD的响应时间更长。对于最终用户来说，从HDD切换到SSD仍然是明显的加速。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，随着时间的流逝，该行业转向创建更高效​​的界面和软件堆栈，从而可以利用更低的延迟和更高的闪存带宽。特别是，创建了NVMe（非易失性存储器Express）接口规范，并开发了相应的低成本软件堆栈。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前的行业状况是，FTL SSD中发生的本地优化现在不利于数据基础架构的部署。特别是，许多客户希望创建与NAND闪存块大小匹配的主机驱动顺序工作负载。作为响应，NVMe标准化了区域名称空间（ZNS），这使主机可以指示I / O共享工作负载，同时还可以通过将主控件移至主机来改善延迟，带宽和成本效益。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们谈论经济效率，则过渡到ZNS SSD将通过使用较少数量的NAND（减少冗余）来降低驱动器的成本（在服务器驱动器中使用QLC的可能性），从而减少SSD控制器中的DRAM数量。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据基础架构-实施区域数据仓库</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经发现分区块设备可以提高存储效率，但是，要利用这些新设备，需要付出一些努力，因为它们与常规块程序堆栈没有向后兼容性。传统存储设备没有记录限制，而区域块设备具有必须在区域内保持一致的记录限制。这样做的主要结果是需要更新软件堆栈。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要更新的第一个组件是操作系统。</font><font style="vertical-align: inherit;">在运行于数据中心典型的多核和多路服务器上的现代多任务操作系统中，这并不是一件容易的事。</font><font style="vertical-align: inherit;">Linux社区已经做出了巨大的努力来支持区域阻止设备，特别是SMR。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了支持Linux内核外，还有许多支持Zone Block设备的实用程序和应用程序，例如fio，Blktests和util-linux。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux内核和区域阻止设备</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux内核中对区域存储的支持工作始于2014年，当时3.18内核中内置的支持最少。具有ZBC / ZAC命令功能支持的第一个内核版本是2017年初的4.10内核。支持不断提高，最新的内核支持以块/ dev / sd的形式显示区域设备，以及对某些文件系统（f2fs，btrfs）的支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下图显示了Linux内核的结构以及如何将区域设备与传统块设备集成的高级示意图。通过修改一些现有组件，引入新接口（例如块级的ZBD接口）以及引入新组件（例如device-mapper dm-zoned）来实现对Linux内核的支持。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/k0/j5/tyk0j5jgjxt_-dzgsd480nibdvq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如图所示，数据基础结构的部署可以通过多种方式使用区域块设备。</font><font style="vertical-align: inherit;">例如（i）在dm分区的LVM卷上使用旧文件系统，（ii）使用启用ZBC的文件系统，（iii）使用启用ZBD的应用程序，这些应用程序通过libzbc等用户库与块设备直接交互，以及等等</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区域存储计划-促进更广泛的支持和应用技术的实施</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管开放源代码开发人员社区在支持Zone Block Devices方面取得了成功，但是信息技术工程师和应用程序开发人员仍在努力使用该技术，例如，找出每个Linux内核版本中存在哪些支持级别，哪些版本的应用程序具有必需的支持，以及哪个版本的内核对于它们的工作是必需的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
推出区域存储计划的部分原因是为了解决此问题并促进对区域存储技术的更广泛的应用程序支持。您可以访问网站</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZonedStorage.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关区域存储技术以及ZNS SSD和ZBC / ZAC SMR的使用的更多信息。</font><font style="vertical-align: inherit;">在那里，您可以找到有关以下问题的信息：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区域阻止设备</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入门指南</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux内核支持和功能</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序和库</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期对区域设备进行仿真</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能测试</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统符合性测试</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此平台，基础架构工程师和存储应用程序开发人员现在可以在一个集中的位置来获取使用区域存储技术所需的所有信息和资源。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你准备好了吗</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
访问</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZonedStorage.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，查看您的服务器是否准备好与区域驱动器一起使用。</font><font style="vertical-align: inherit;">尝试在常规设备上部署软件仿真，结果可能是您的应用程序的负载结构与分区存储的概念非常吻合，因此您应该考虑部署测试环境。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490890/index.html">Heroku和React：部署您的第一个应用程序</a></li>
<li><a href="../zh-CN490892/index.html">如何从YML文件免费为Yandex和Google生成密钥和广告</a></li>
<li><a href="../zh-CN490894/index.html">关于网站架构的微妙想法</a></li>
<li><a href="../zh-CN490896/index.html">儿童重症监护室的工作原理，以对“程序员，背包和约翰·斯坦贝克”的回应或</a></li>
<li><a href="../zh-CN490906/index.html">Yandex推出了独立Aura的beta-aura.top。是顶部吗？</a></li>
<li><a href="../zh-CN490912/index.html">Sportmaster我们如何选择缓存系统。第1部分</a></li>
<li><a href="../zh-CN490916/index.html">在大型项目上与外部团队互动的问题</a></li>
<li><a href="../zh-CN490918/index.html">亚历山大·特鲁汉诺夫（Alexander Trukhanov）安德烈·扎雷茨基（Andrei Zaretsky）（续）：“我们没有名字，但自大。”</a></li>
<li><a href="../zh-CN490920/index.html">在“我是否被伪装成49微秒（C ++）”中加速您的搜索</a></li>
<li><a href="../zh-CN490924/index.html">什么是Windows PowerShell？它吃什么？第2部分：编程语言简介</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>