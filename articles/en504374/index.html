<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 🍿 👊🏾 Simple graph traversal: depth and breadth-first search using JavaScript as an example 🧘🏽 👨🏼‍🎤 🤘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 
 
 I present to you the translation of the article “Algorithms on Graphs: Let's talk Depth-First Search (DFS) and Breadth-First Search (BFS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Simple graph traversal: depth and breadth-first search using JavaScript as an example</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504374/"><img src="https://habrastorage.org/webt/_f/kf/kl/_fkfkl3gfkmnwtes2eypbueifxe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Good day. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I present to you the translation of the article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Algorithms on Graphs: Let's talk Depth-First Search (DFS) and Breadth-First Search (BFS)”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by Try Khov.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is a graph traversal?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In simple words, a graph traversal is a transition from one of its vertices to another in search of the connection properties of these vertices. </font><font style="vertical-align: inherit;">Links (lines connecting vertices) are called directions, paths, faces, or edges of a graph. </font><font style="vertical-align: inherit;">The vertices of the graph are also referred to as nodes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The two main graph traversal algorithms are Depth-First Search, DFS and Breadth-First Search, BFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the fact that both algorithms are used to traverse the graph, they have some differences. </font><font style="vertical-align: inherit;">Let's start with DFS.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depth Search</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFS follows the concept of “go deep, head first”. The idea is that we move from the starting peak (point, place) in a certain direction (along a certain path) until we reach the end of the path or destination (desired peak). If we have reached the end of the path, but it is not a destination, then we go back (to the point of branching or diverging paths) and go along a different route. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at an example. Suppose we have a directed graph that looks like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are at point “s” and we need to find the vertex “t”. Using DFS, we investigate one of the possible paths, move along it to the end and, if we do not find t, go back and explore another path. Here's what the process looks like:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we move along the path (p1) to the nearest peak and see that this is not the end of the path. Therefore, we move on to the next peak. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We reached the end of p1, but did not find t, so we return to s and move along the second path. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having reached the top of the path “p2” closest to the point “s”, we see three possible directions for further movement. Since we have already visited the peak crowning the first direction, we are moving along the second. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We again reached the end of the path, but did not find t, so we go back. We follow the third path and, finally, we reach the desired peak "t". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how DFS works. We move along a certain path to the end. If the end of the path is the desired peak, we are done. If not, go back and move on a different path until we explore all the options.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We follow this algorithm for every vertex visited. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The need for repeated repetition of the procedure indicates the need to use recursion to implement the algorithm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the JavaScript code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A: [B,C], B:[D,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">adj, v, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// v -   ()</span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-comment">//    ,    </span>
	<span class="hljs-keyword">if</span>(v === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">if</span>(v.visited) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	v.visited = <span class="hljs-literal">true</span>
	<span class="hljs-comment">//    (  ) v</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">if</span>(!neighbor.visited) {
			<span class="hljs-comment">//     ,      </span>
			<span class="hljs-keyword">let</span> reached = dfs(adj, neighbor, t)
			<span class="hljs-comment">//  true,  </span>
			<span class="hljs-keyword">if</span>(reached) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-comment">//   v  t  </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: This special DFS algorithm allows you to check whether it is possible to get from one place to another. </font><font style="vertical-align: inherit;">DFS can be used for various purposes. </font><font style="vertical-align: inherit;">These goals will determine how the algorithm itself will look. </font><font style="vertical-align: inherit;">However, the general concept looks exactly like that.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS Analysis</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's analyze this algorithm. Since we go around each “neighbor” of each node, ignoring those that we visited earlier, we have a runtime equal to O (V + E). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A brief explanation of what V + E means: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V is the total number of vertices. E is the total number of faces (edges). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It might seem more appropriate to use V * E, but let's think about what V * E means. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * E means that with respect to each vertex, we must investigate all the faces of the graph regardless of whether these faces belong to a particular vertex.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, V + E means that for each vertex we evaluate only the edges adjacent to it. </font><font style="vertical-align: inherit;">Returning to the example, each vertex has a certain number of faces and, in the worst case, we go around all the vertices (O (V)) and examine all the faces (O (E)). </font><font style="vertical-align: inherit;">We have V vertices and E faces, so we get V + E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, since we use recursion to traverse each vertex, this means that a stack is used (infinite recursion leads to a stack overflow error). </font><font style="vertical-align: inherit;">Therefore, the spatial complexity is O (V). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now consider the BFS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wide search</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFS follows the concept of "expand wide, rising to the height of a bird's flight" ("go wide, bird's eye-view"). Instead of moving along a certain path to the end, BFS involves moving forward one neighbor at a time. This means the following: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of following the path, BFS means visiting the neighbors closest to s in a single action (step), then visiting neighbors' neighbors and so on until t is detected. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/vb/ny/1uvbnygi83vt6bxqnmv1hbwuzyq.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/en/jq/tgenjqvsz1zipcv3obsicrhq78a.png"><br>
<br>
<img src="https://habrastorage.org/webt/tf/j9/on/tfj9on04zudfmelpbn00xeh_tpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How is DFS different from BFS? I like to think that DFS goes ahead, and BFS is not in a hurry, but studies everything within one step. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The question then arises: how do you know which neighbors should be visited first?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, we can use the concept of "first in, first out" (first-in-first-out, FIFO) from the queue. </font><font style="vertical-align: inherit;">We queue first the peak closest to us, then its unvisited neighbors, and continue this process until the queue is empty or until we find the vertex we are looking for. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A:[B,C,D], B:[E,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">adj, s, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// s -  </span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">let</span> queue = []
	<span class="hljs-comment">//  s  </span><font></font>
	queue.push(s)<font></font>
	<span class="hljs-comment">//  s         </span>
	s.visited = <span class="hljs-literal">true</span>
	<span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-comment">//   ()   </span>
		<span class="hljs-keyword">let</span> v = queue.shift()
		<span class="hljs-comment">// abj[v] -  v</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
			<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span>(!neighbor.visited) {
				<span class="hljs-comment">//    </span><font></font>
				queue.push(neighbor)<font></font>
				<span class="hljs-comment">//    </span>
				neighbor.visited = <span class="hljs-literal">true</span>
				<span class="hljs-comment">//     ,  </span>
				<span class="hljs-keyword">if</span>(neighbor === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
			}<font></font>
		} <font></font>
	}<font></font>
	<span class="hljs-comment">//  t  ,     </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFS Analysis</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It might seem that BFS is slower. However, if you look closely at the visualizations, you can see that they have the same runtime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A queue involves processing each vertex before reaching a destination. This means that, in the worst case, BFS explores all vertices and faces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the fact that BFS may seem slower, it is actually faster, because when working with large graphs it is found that DFS spends a lot of time following paths that ultimately turn out to be false. BFS is often used to find the shortest path between two peaks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the BFS runtime is also O (V + E), and since we use a queue containing all the vertices, its spatial complexity is O (V).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real life analogies</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you give analogies from real life, then this is how I imagine the work of DFS and BFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I think of DFS, I imagine a mouse in a maze in search of food. </font><font style="vertical-align: inherit;">In order to get to the target, the mouse is forced to run into a dead end many times, return and move in a different way, and so on, until it finds a way out of the maze or food. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/f3/ji/-ef3ji72zi8egr3xa26zqvt1x4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simplified version looks like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/hb/dr/kqhbdrkv6xstug0ss3l5bpr1l9k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In turn, when I think about BFS, I imagine circles on the water. </font><font style="vertical-align: inherit;">The fall of a stone into water leads to the spread of disturbances (circles) in all directions from the center. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/lz/zp/pvlzzpnzfssjv8yzpkc49ovtsho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simplified version looks like this:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/w9/sc/s-w9scwvyp93tvyk2zwimmfc_um.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depth and breadth searches are used to traverse the graph.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS moves along the edges back and forth, and BFS spreads across neighbors in search of a target.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS uses the stack, and BFS the queue.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The runtime of both is O (V + E), and the spatial complexity is O (V).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These algorithms have a different philosophy, but are equally important for working with graphs.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note </font><font style="vertical-align: inherit;">Per .: I am not a specialist in algorithms and data structures, therefore, if errors, inaccuracies or incorrect formulations are found, please write in a personal letter for correction and clarification. </font><font style="vertical-align: inherit;">I will be grateful. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for attention.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en504354/index.html">Reduce the size of the ML model without registration and SMS</a></li>
<li><a href="../en504356/index.html">PHP 8 in eight pieces of code</a></li>
<li><a href="../en504358/index.html">PuppetConf 2016. Kubernetes for system administrators. Part 2</a></li>
<li><a href="../en504362/index.html">Quickly load large amounts of data in Google Colab</a></li>
<li><a href="../en504370/index.html">Office 365 & Microsoft Teams - Convenience of Collaboration and Impact on Security</a></li>
<li><a href="../en504382/index.html">How I (PhD Neurobiology) became a Data Scientist in 6 months</a></li>
<li><a href="../en504384/index.html">Gradually introduce TypeScript into your React project</a></li>
<li><a href="../en504386/index.html">Vassbotn H. Class Virtual Variables</a></li>
<li><a href="../en504392/index.html">How many programmers and words do you need to recognize a handwritten passport?</a></li>
<li><a href="../en504400/index.html">Caching. Part 2: 60 days before release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>