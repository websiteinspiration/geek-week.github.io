<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 👤 💉 DBA：负责组织同步和导入 ✊ 🚣🏾 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="随着大型数据集的复杂处理（不同的ETL过程：导入，转换和与外部源的同步），通常有必要临时“记住”并立即处理大量的事情。
 
 这种典型的任务通常听起来像这样：“ 会计部门在这里上载了从客户银行最后收到的付款，我们需要快速将它们上载到网站并将其链接到帐户”。
 
 但是当这种“某物”的容量开始以数百兆...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DBA：负责组织同步和导入</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/492464/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着大型数据集的复杂处理（不同的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETL过程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：导入，转换和与外部源的同步），通常有必要</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">临时“记住”并立即处理</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大量的事情。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种典型的任务通常听起来像这样：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会计部门</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里上</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">载了从客户银行</font></a><font style="vertical-align: inherit;">最后收到的付款，我们需要快速将它们上载到网站并将其链接到帐户”。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
但是当这种“某物”的容量开始以数百兆字节为单位进行测量时，该服务这应该可以在24x7模式下继续使用底座，但有许多副作用会破坏您的生活。</font></font><br>
<img src="https://habrastorage.org/webt/tl/g3/ff/tlg3ffjptyayqlu-5k06oonr_vi.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了在PostgreSQL中（而且不仅是在其中）应对它们，您可以使用一些优化选项，这些选项将使您能够更快地处理并且使用更少的资源。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.在哪里发货？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们决定在哪里可以上传我们要“处理”的数据。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1。</font><font style="vertical-align: inherit;">临时表（TEMPORARY TABLE）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原则上，对于PostgreSQL，临时表与其他表相同。</font><font style="vertical-align: inherit;">因此，诸如</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“所有内容仅存储在内存中，但它可以结束”之</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的迷信是不正确的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是有几个明显的不同。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到数据库的每个连接都有自己的名称空间</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果两个连接试图同时建立</font></font><code>CREATE TABLE x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么肯定有人会收到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非唯一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DB对象</font><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">错误</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果两个都尝试执行</font><font style="vertical-align: inherit;">，那么通常两个都可以执行，并且每个都将收到</font><b><font style="vertical-align: inherit;">自己的</font></b><font style="vertical-align: inherit;">表</font><b><font style="vertical-align: inherit;">副本</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他们之间没有任何共同点。</font></font><code>CREATE <b>TEMPORARY</b> TABLE x</code><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">断开连接的“自毁”</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您关闭连接时，所有临时表都会自动删除，因此“手动”执行</font></font><code>DROP TABLE x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有任何意义，除非... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在事务模式下</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font><b><font style="vertical-align: inherit;">pgbouncer进行</font></b><font style="vertical-align: inherit;">工作</font><font style="vertical-align: inherit;">，数据库将继续假定该连接仍然处于活动状态，并且该临时表该表仍然存在。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，尝试从另一个连接到pgbouncer重新创建它会导致错误。</font><font style="vertical-align: inherit;">但这可以通过利用来规避</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
没错，最好不要这样做，因为这样您就可以“突然”找出“前任所有者”留下的数据。</font><font style="vertical-align: inherit;">相反，最好阅读手册，并确保在创建表时有机会添加</font></font><code>CREATE TEMPORARY TABLE <b>IF NOT EXISTS</b> x</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>ON COMMIT <b>DROP</b></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -也就是说，交易完成后，表格将被自动删除。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非复制</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于仅属于特定联接，因此不会复制临时表。</font><font style="vertical-align: inherit;">但这</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除了</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在堆+ WAL中</font><b><font style="vertical-align: inherit;">双重写入数据的需要</font></b><font style="vertical-align: inherit;">，因此INSERT / UPDATE / DELETE的速度要快得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是由于临时表仍然是“几乎普通的”表，因此也不能在副本上创建它。</font><font style="vertical-align: inherit;">至少到目前为止，尽管相应的补丁已经存在很长时间了。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2。</font><font style="vertical-align: inherit;">未记录表（UNLOGGED TABLE）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，例如，如果您有某种繁琐的ETL流程无法在单个事务中实现，而您仍然有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgbouncer处于事务模式，该</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怎么办？.. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或数据流太大，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以至于每个连接没有足够的带宽</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据库（读取一个CPU上的进程）？.. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还是某些操作</font><font style="vertical-align: inherit;">在不同的连接中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行？.. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只有一个选择- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">临时创建一个非临时表</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">潘，是的 </font><font style="vertical-align: inherit;">即：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用最大随机名称创建“他”表，以免与任何人交叉</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提取</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：将来自外部源的数据倒入其中</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：转换后，填写关键绑定字段</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加载</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：将完成的数据倒入目标表</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除“我的”表</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而现在-美中不足的苍蝇。</font><font style="vertical-align: inherit;">实际上，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL中的所有编写都发生两次</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先在WAL中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后在表/索引的主体中。</font><font style="vertical-align: inherit;">所有这些都是为了支持ACID </font></font><code>COMMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><code>ROLLBACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嵌套事务</font><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">嵌套事务</font><font style="vertical-align: inherit;">之间数据的正确可见性</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我们不需要这个！</font><font style="vertical-align: inherit;">我们是否已</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过或未成功通过</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个过程</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它包含多少中间事务都没关系-我们对“从中间继续进行过程”不感兴趣，尤其是当不清楚它在哪里时。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，PostgreSQL开发人员引入了9.1版，例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非新闻稿（UNLOGGED）表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote>      . ,    ,      (.  29),      <b>   </b>. ,     ;         <b> </b>.  ,    <b> </b>   .  ,    ,   .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简而言之，它将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更快</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是如果数据库服务器“崩溃”，那将是令人不快的。</font><font style="vertical-align: inherit;">但如何经常会出现这种情况，与该数据库的“振兴规划”后，确实你的ETL过程中知道如何正确地修改它“从中间” ..？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果不是，和上面的情况类似，你的-使用</font></font><code>UNLOGGED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但从来没有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括在真实的表这个属性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲爱的数据。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3。</font><font style="vertical-align: inherit;">提交{删除行| </font><font style="vertical-align: inherit;">下降}</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种设计允许在创建表时设置事务结束时的自动行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于</font><font style="vertical-align: inherit;">我在上面已经写过的信息，它会生成</font><font style="vertical-align: inherit;">，但是</font><font style="vertical-align: inherit;">情况更有趣-在这里它生成了</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
由于用于存储临时表的meta描述整个基础设施是完全一样平常之一，</font><b><font style="vertical-align: inherit;">不断创建和删除临时表导致的一个强大的系统表的“肿胀”</font></b><font style="vertical-align: inherit;">的pg_class，pg_attribute里，pg_attrdef，pg_depend，...... </font><font style="vertical-align: inherit;">
现在，假设你有一个工人就行了连接到数据库，每秒打开一个新事务，创建，填充，处理和删除临时表...系统表中的垃圾会累积过多，这在每次操作过程中都是多余的刹车。</font></font><code>ON COMMIT <b>DROP</b></code><font style="vertical-align: inherit;"></font><code>DROP TABLE</code><font style="vertical-align: inherit;"></font><code>ON COMMIT <b>DELETE ROWS</b></code><font style="vertical-align: inherit;"></font><code>TRUNCATE TABLE</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，不要！</font><font style="vertical-align: inherit;">在这种情况下，</font></font><code>CREATE TEMPORARY TABLE x ... ON COMMIT DELETE ROWS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其从事务周期中删除</font><font style="vertical-align: inherit;">会更加有效</font><font style="vertical-align: inherit;">-然后在每个新事务开始之前，该表</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经</font><b><font style="vertical-align: inherit;">存在</font></b><font style="vertical-align: inherit;">（保存调用</font></font><code>CREATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但</font><font style="vertical-align: inherit;">由于</font><font style="vertical-align: inherit;">在上一个事务结束时（我们也保存了调用</font><font style="vertical-align: inherit;">），</font><font style="vertical-align: inherit;">该表</font><b><font style="vertical-align: inherit;">将为</font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></b><font style="vertical-align: inherit;"></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4。</font><font style="vertical-align: inherit;">喜欢...包括...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在一开始就提到临时表的典型用例之一是各种导入-开发人员很累地将目标表的字段列表复制粘贴到他的临时声明中…… </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是懒惰是进步的动力！</font><font style="vertical-align: inherit;">因此，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“在模型上”创建新表</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能会更加简单：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> import_table(
  <span class="hljs-keyword">LIKE</span> target_table<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于您可以在此表中添加大量数据，因此对其进行搜索将永远不会很快。但是有一个针对此的传统解决方案-索引！而且，是的，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">临时表也可以具有index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于所需的索引通常与目标表的索引一致，因此您只需编写即可</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
如果还需要</font><font style="vertical-align: inherit;">-values（例如，填写主键值），则可以使用</font><font style="vertical-align: inherit;">。好吧，或者干脆- </font><font style="vertical-align: inherit;">它会复制默认值，索引，约束... </font><font style="vertical-align: inherit;">
但是在这里您需要了解，如果您</font><b><font style="vertical-align: inherit;">立即使用索引</font></b><font style="vertical-align: inherit;">创建了</font><b><font style="vertical-align: inherit;">导入表，那么数据将被填充更长的时间</font></b></font><code>LIKE target_table <b>INCLUDING INDEXES</b></code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>DEFAULT</code><font style="vertical-align: inherit;"></font><code>LIKE target_table <b>INCLUDING DEFAULTS</b></code><font style="vertical-align: inherit;"></font><code>LIKE target_table <b>INCLUDING ALL</b></code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比起先填满所有内容然后滚动索引-就像</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_dump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做到这一点的示例</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总而言之，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTFM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.怎么写？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我会说简单地使用</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">COPY</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-stream而不是“ packs” </font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时会加速</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您甚至可以直接从预生成的文件中进行操作。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.如何处理？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，让我们的介绍看起来像这样：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的数据库中有一个包含100万</font><b><font style="vertical-align: inherit;">条记录的</font></b><font style="vertical-align: inherit;">客户数据的标牌</font></font><b><font style="vertical-align: inherit;"></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户每天都会向您发送新的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整“图片”</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据经验，您会不时</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改超过1万条记录</font></font></b></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种情况的一个典型例子是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KLADR数据库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -地址很多，但是每周一次上传更改（定居点重新命名，街道协会，新房子的出现）的数量很少，甚至在全国范围内。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1。</font><font style="vertical-align: inherit;">全同步算法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为简单起见，假设您甚至不需要重组数据-只需以正确的形式显示表格即可，即：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不再存在的所有内容</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有已存在的内容，您需要更新</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有尚未</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么按此顺序值得进行操作？</font><font style="vertical-align: inherit;">因为这是表格大小最小增长的方式（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请记住MVCC！</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从dst删除</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不，当然，您只能执行两个操作：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全删除</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>DELETE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粘贴</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新图像中的所有内容</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是同时，由于有了MVCC，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表格</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">大小将增加两倍</font></b><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">由于更新了10K，因此在表中获取+ 1M图像记录-超级冗余...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">截断dst</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经验更丰富的开发人员知道，整个印版可以很便宜地清洗：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清除</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）整个表</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粘贴</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新图像中的所有内容</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法有效，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时很适用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是存在一个问题……我们将注入1M条记录，因此我们不能一直将表留空（这不会发生在没有包装单个事务的情况下）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意思是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们开始</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长期交易</font></font></b></li>
<li><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">施加</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AccessExclusive</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Lock</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们做了很长时间的插入，此时其他所有人</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甚至无法</font></font><code>SELECT</code></b></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不好了...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALTER TABLE ...重命名... / DROP TABLE ...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为一种选择，将所有内容填充到单独的新表中，然后将其重命名为旧表。</font><font style="vertical-align: inherit;">一些讨厌的小事情：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AccessExclusive</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也是如此</font><font style="vertical-align: inherit;">，尽管时间大大减少了</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该表的所有查询计划/统计信息均已重置，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要驱动ANALYZE</font></font></a></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桌上的</font><b><font style="vertical-align: inherit;">所有外键</font></b><font style="vertical-align: inherit;">（FK）都</font><b><font style="vertical-align: inherit;">中断</font></b><font style="vertical-align: inherit;">了</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simon Riggs提供了一个WIP补丁程序，该补丁程序建议在</font></font><code>ALTER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不影响统计信息和FK的情况下，在文件级别</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">替换表主体</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">操作，但未收集仲裁。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除，更新，插入</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们停止了三个操作的非阻塞版本。</font><font style="vertical-align: inherit;">几乎三个……如何最有效地做到这一点？</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">--     ,     "" </span>
<span class="hljs-keyword">BEGIN</span>;<font></font>
<font></font>
<span class="hljs-comment">--      </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> tmp(
  <span class="hljs-keyword">LIKE</span> dst <span class="hljs-keyword">INCLUDING</span> <span class="hljs-keyword">INDEXES</span> <span class="hljs-comment">--    ,   </span>
) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">COMMIT</span> <span class="hljs-keyword">DROP</span>; <span class="hljs-comment">--       </span><font></font>
<font></font>
<span class="hljs-comment">-- -     COPY</span><font></font>
COPY tmp FROM STDIN;<font></font>
<span class="hljs-comment">-- ...</span>
<span class="hljs-comment">-- \.</span><font></font>
<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span><font></font>
  dst D<font></font>
<span class="hljs-keyword">USING</span><font></font>
  dst X<font></font>
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><font></font>
  tmp Y<font></font>
    <span class="hljs-keyword">USING</span>(pk1, pk2) <span class="hljs-comment">--   </span>
<span class="hljs-keyword">WHERE</span>
  (D.pk1, D.pk2) = (X.pk1, X.pk2) <span class="hljs-keyword">AND</span>
  Y <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">-- ""</span><font></font>
<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">UPDATE</span><font></font>
  dst D<font></font>
<span class="hljs-keyword">SET</span><font></font>
  (f1, f2, f3) = (T.f1, T.f2, T.f3)<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  tmp T<font></font>
<span class="hljs-keyword">WHERE</span>
  (D.pk1, D.pk2) = (T.pk1, T.pk2) <span class="hljs-keyword">AND</span>
  (D.f1, D.f2, D.f3) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> (T.f1, T.f2, T.f3); <span class="hljs-comment">--   </span><font></font>
<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span><font></font>
  dst<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  T.*<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  tmp T<font></font>
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><font></font>
  dst D<font></font>
    <span class="hljs-keyword">USING</span>(pk1, pk2)
<span class="hljs-keyword">WHERE</span>
  D <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-keyword">COMMIT</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2。</font><font style="vertical-align: inherit;">导入后处理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在同一个KLADER中，所有更改的记录都必须另外通过后期处理运行-规范化，突出显示关键字并带入必要的结构。</font><font style="vertical-align: inherit;">但是，您如何知道</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到底发生了什么变化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而又不使同步代码复杂化？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在同步时仅您的进程具有写访问权，则可以使用触发器来为我们收集所有更改：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">--  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr(...);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr_house(...);<font></font>
<font></font>
<span class="hljs-comment">--    </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr$<span class="hljs-keyword">log</span>(<font></font>
  ro kladr, <span class="hljs-comment">--      /</span><font></font>
  rn kladr<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> kladr_house$<span class="hljs-keyword">log</span>(<font></font>
  ro kladr_house,<font></font>
  rn kladr_house<font></font>
);<font></font>
<font></font>
<span class="hljs-comment">--    </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">FUNCTION</span> diff$<span class="hljs-keyword">log</span>() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">trigger</span> <span class="hljs-keyword">AS</span> $$
<span class="hljs-keyword">DECLARE</span>
  dst <span class="hljs-built_in">varchar</span> = TG_TABLE_NAME || <span class="hljs-string">'$log'</span>;<font></font>
  stmt text = '';<font></font>
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-comment">--      </span>
  <span class="hljs-keyword">IF</span> TG_OP = <span class="hljs-string">'UPDATE'</span> <span class="hljs-keyword">THEN</span>
    <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NEW</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">OLD</span> <span class="hljs-keyword">THEN</span>
      <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">NEW</span>;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;
  <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;
  <span class="hljs-comment">--   </span>
  stmt = '<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">' || dst::text || '</span>(ro,rn)<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">';
  CASE TG_OP
    WHEN '</span><span class="hljs-keyword">INSERT</span><span class="hljs-string">' THEN
      EXECUTE stmt || '</span><span class="hljs-literal">NULL</span>,$<span class="hljs-number">1</span>)<span class="hljs-string">' USING NEW;
    WHEN '</span><span class="hljs-keyword">UPDATE</span><span class="hljs-string">' THEN
      EXECUTE stmt || '</span>$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-string">' USING OLD, NEW;
    WHEN '</span><span class="hljs-keyword">DELETE</span><span class="hljs-string">' THEN
      EXECUTE stmt || '</span>$<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>)<span class="hljs-string">' USING OLD;
  END CASE;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以在开始同步之前强加触发器（或通过启用</font></font><code>ALTER TABLE ... ENABLE TRIGGER ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">log</span>
  <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">DELETE</span>
  <span class="hljs-keyword">ON</span> kladr
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>
      <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> diff$<span class="hljs-keyword">log</span>();<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">log</span>
  <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">DELETE</span>
  <span class="hljs-keyword">ON</span> kladr_house
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>
      <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> diff$<span class="hljs-keyword">log</span>();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后悄悄地从日志表中提取所需的所有更改，并通过其他处理程序运行它。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3。</font><font style="vertical-align: inherit;">导入相关集</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面，我们考虑了源和接收器的数据结构一致的情况。</font><font style="vertical-align: inherit;">但是，如果从外部系统卸载的格式与我们数据库中的存储结构不同，该怎么办？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以存储客户及其帐户为例，经典的多对一选项：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">client</span>(<font></font>
  client_id<font></font>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, inn<font></font>
    <span class="hljs-built_in">varchar</span>
      <span class="hljs-keyword">UNIQUE</span>
, <span class="hljs-keyword">name</span>
    <span class="hljs-built_in">varchar</span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> invoice(<font></font>
  invoice_id<font></font>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, client_id<font></font>
    <span class="hljs-built_in">integer</span>
      <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">client</span>(client_id)<font></font>
, <span class="hljs-built_in">number</span>
    <span class="hljs-built_in">varchar</span><font></font>
, dt<font></font>
    <span class="hljs-built_in">date</span>
, <span class="hljs-keyword">sum</span>
    <span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是从外部来源卸载以“多合一”的形式出现：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> invoice_import(<font></font>
  client_inn<font></font>
    <span class="hljs-built_in">varchar</span><font></font>
, client_name<font></font>
    <span class="hljs-built_in">varchar</span><font></font>
, invoice_number<font></font>
    <span class="hljs-built_in">varchar</span><font></font>
, invoice_dt<font></font>
    <span class="hljs-built_in">date</span><font></font>
, invoice_sum<font></font>
    <span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，客户数据可以通过这种方式进行复制，并且主要记录是“帐户”：</font></font><br>
<br>
<pre><code class="plaintext hljs">0123456789;;A-01;2020-03-16;1000.00<font></font>
9876543210;;A-02;2020-03-16;666.00<font></font>
0123456789;;B-03;2020-03-16;9999.00<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于模型，只需插入我们的测试数据，但请记住- </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更有效！</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> invoice_import
<span class="hljs-keyword">VALUES</span>
  (<span class="hljs-string">'0123456789'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'A-01'</span>, <span class="hljs-string">'2020-03-16'</span>, <span class="hljs-number">1000.00</span>)<font></font>
, (<span class="hljs-string">'9876543210'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'A-02'</span>, <span class="hljs-string">'2020-03-16'</span>, <span class="hljs-number">666.00</span>)<font></font>
, (<span class="hljs-string">'0123456789'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'B-03'</span>, <span class="hljs-string">'2020-03-16'</span>, <span class="hljs-number">9999.00</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们选择“事实”所指的“切工”。</font><font style="vertical-align: inherit;">在我们的案例中，帐户指的是客户：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TEMPORARY</span> <span class="hljs-keyword">TABLE</span> client_import <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>(client_inn)
<span class="hljs-comment">--   SELECT DISTINCT,    </span><font></font>
  client_inn inn<font></font>
, client_name <span class="hljs-string">"name"</span>
<span class="hljs-keyword">FROM</span>
  invoice_import;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了正确地将帐户与客户ID相关联，我们需要首先找出或生成这些标识符。</font><font style="vertical-align: inherit;">为他们添加字段：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> invoice_import <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> client_id <span class="hljs-built_in">integer</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> client_import <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> client_id <span class="hljs-built_in">integer</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用同步表的方法进行上述较小的修正-我们将不更新或删除目标表中的任何内容，因为导入客户端是“仅追加的”：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-comment">--     ID   </span>
<span class="hljs-keyword">UPDATE</span><font></font>
  client_import T<font></font>
<span class="hljs-keyword">SET</span><font></font>
  client_id = D.client_id<font></font>
<span class="hljs-keyword">FROM</span>
  <span class="hljs-keyword">client</span> D
<span class="hljs-keyword">WHERE</span>
  T.inn = D.inn; <span class="hljs-comment">-- unique key</span><font></font>
<font></font>
<span class="hljs-comment">--       ID</span>
<span class="hljs-keyword">WITH</span> ins <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">client</span>(<font></font>
    inn<font></font>
  , <span class="hljs-keyword">name</span><font></font>
  )<font></font>
  <span class="hljs-keyword">SELECT</span><font></font>
    inn<font></font>
  , <span class="hljs-keyword">name</span>
  <span class="hljs-keyword">FROM</span><font></font>
    client_import<font></font>
  <span class="hljs-keyword">WHERE</span>
    client_id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span> <span class="hljs-comment">--  ID  </span>
  <span class="hljs-keyword">RETURNING</span> *<font></font>
)<font></font>
<span class="hljs-keyword">UPDATE</span><font></font>
  client_import T<font></font>
<span class="hljs-keyword">SET</span><font></font>
  client_id = D.client_id<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  ins D<font></font>
<span class="hljs-keyword">WHERE</span>
  T.inn = D.inn; <span class="hljs-comment">-- unique key</span><font></font>
<font></font>
<span class="hljs-comment">--  ID    </span>
<span class="hljs-keyword">UPDATE</span><font></font>
  invoice_import T<font></font>
<span class="hljs-keyword">SET</span><font></font>
  client_id = D.client_id<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  client_import D<font></font>
<span class="hljs-keyword">WHERE</span>
  T.client_inn = D.inn; <span class="hljs-comment">--  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，所有内容- </font></font><code>invoice_import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们已经填写</font></font><code>client_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了用于插入帐户</font><font style="vertical-align: inherit;">的通讯字段</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492454/index.html">我们将架构重构出售给客户或开发人员的问题是什么</a></li>
<li><a href="../zh-CN492456/index.html">如何可视化和动画化（地球物理）模型。显示原始数据</a></li>
<li><a href="../zh-CN492458/index.html">M5Stack的简单GUI（Arduino）</a></li>
<li><a href="../zh-CN492460/index.html">Функциональное программирование — то, что вам (наверно) рассказывали. Если вы слушали</a></li>
<li><a href="../zh-CN492462/index.html">事实来源：分析师如何教经理和开发人员一起工作</a></li>
<li><a href="../zh-CN492466/index.html">只需五个步骤，如何从具有cPanel的任何主机提供程序迁移到Rusonix中的Plesk</a></li>
<li><a href="../zh-CN492468/index.html">联想Thinkserver SE350：外围英雄</a></li>
<li><a href="../zh-CN492474/index.html">我们在Android机顶盒上整理信息，并分析普通前缀应该能够执行的操作。</a></li>
<li><a href="../zh-CN492478/index.html">如果没有知识管理，那就很痛苦：缺乏系统的5个主要后果</a></li>
<li><a href="../zh-CN492480/index.html">我们以前如何应对流行病以及我们如何应对冠状病毒</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>