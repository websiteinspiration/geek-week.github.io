<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèª ‚èèÔ∏è üßïüèª Asynchrone Programmierung in .NET: Best Practices üòü üåä üïü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Aufkommen von async / await in C # hat zu einer Neudefinition des Schreibens von einfachem und korrektem Parallelcode gef√ºhrt. Mit der asynchronen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Programmierung in .NET: Best Practices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Aufkommen von async / await in C # hat zu einer Neudefinition des Schreibens von einfachem und korrektem Parallelcode gef√ºhrt. Mit der asynchronen Programmierung l√∂sen Programmierer h√§ufig nicht nur die Probleme mit den Threads, sondern f√ºhren auch neue ein. Deadlocks und Fl√ºge gehen nirgendwo hin - sie werden nur schwieriger zu diagnostizieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Software Analysis TeamLead bei Huawei, einem ehemaligen JetBrains Rider-Techniker und Entwickler des ReSharper-Kerns: Datenstrukturen, Caches, Multithreading und ein regelm√§√üiger Redner auf der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konferenz </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter der Zwischensequenz - Videoaufzeichnung und Texttranskription von Dmitrys Bericht von der DotNext 2019 Piter-Konferenz.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Erz√§hlung im Namen des Sprechers.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Multithread- oder asynchronem Code bricht h√§ufig etwas zusammen. Der Grund k√∂nnte sowohl Deadlock als auch Race sein. In der Regel st√ºrzt ein Rennen einmal von tausend ab, oft nicht lokal, sondern nur auf einem Build-Server, und es dauert mehrere Tage, bis es abgefangen wird. Ich bin mir sicher, dass dies f√ºr viele eine vertraute Situation ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich mir selbst von erfahrenen Entwicklern asynchronen Code anschaue, denke ich au√üerdem, dass einige Dinge dreimal k√ºrzer und korrekter aufgeschrieben werden k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies deutet darauf hin, dass das Problem nicht bei Menschen liegt, sondern beim Instrument. </font><font style="vertical-align: inherit;">Die Leute benutzen das Tool einfach und m√∂chten, dass es ihr Problem l√∂st. </font><font style="vertical-align: inherit;">Das Tool selbst verf√ºgt √ºber eine sehr gro√üe Anzahl von Funktionen (manchmal sogar √ºberfl√ºssig), Einstellungen und einen impliziten Kontext, was dazu f√ºhrt, dass es sehr einfach ist, es falsch zu verwenden. </font><font style="vertical-align: inherit;">Versuchen wir herauszufinden, wie Sie async / await verwenden und mit einer Klasse </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in .NET arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planen</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme mit Ans√§tzen, die mit async / await gel√∂st werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele f√ºr kontroverses Design.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Aufgabe aus dem wirklichen Leben, die wir asynchron l√∂sen werden.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / warte und zu l√∂sende Probleme</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum brauchen wir Async / Warten? Angenommen, wir haben Code, der mit Shared Shared Memory funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Beginn der Arbeit lesen wir die Anforderung, in diesem Fall die Datei aus der Blockierungswarteschlange (z. B. aus dem Internet oder von der Festplatte), unter Verwendung der Blockierungsanforderung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Blockierungsanforderungen werden in den Bildern mit Beispielen rot markiert). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz erfordert viele Threads, und jeder Thread ben√∂tigt Ressourcen, wodurch der </font><i><font style="vertical-align: inherit;">Scheduler</font></i><font style="vertical-align: inherit;"> belastet wird</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist jedoch nicht das Hauptproblem. Angenommen, Benutzer k√∂nnten Betriebssysteme so umschreiben, dass diese Systeme sowohl hunderttausend als auch eine Million Threads unterst√ºtzen. Das Hauptproblem ist jedoch, dass einige Threads einfach nicht genommen werden k√∂nnen. Sie haben beispielsweise einen Benutzeroberfl√§chenthread. Es gibt keine normalen ad√§quaten UI-Frameworks, bei denen der Zugriff auf Daten noch nicht nur von einem Thread aus erfolgt. UI-Thread kann nicht blockiert werden. Und um es nicht zu blockieren, ben√∂tigen wir asynchronen Code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun √ºber die zweite Aufgabe sprechen. Nachdem wir die Datei gelesen haben, muss sie irgendwie verarbeitet werden. Wir werden es parallel tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele von Ihnen haben geh√∂rt, dass Parallelit√§t nicht dasselbe ist wie Asynchronit√§t. In diesem Fall stellt sich die Frage: Kann Asynchronit√§t dazu beitragen, parallelen Code kompakter, sch√∂ner und schneller zu schreiben?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzte Aufgabe besteht darin, mit gemeinsam genutztem Speicher zu arbeiten. </font><font style="vertical-align: inherit;">M√ºssen wir diesen Mechanismus mit Sperren ziehen, mit asynchronem Code synchronisieren oder kann dies irgendwie vermieden werden? </font><font style="vertical-align: inherit;">Kann </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / warte dabei</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> helfen?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pfad zum Async / Warten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir die Entwicklung der asynchronen Programmierung im Allgemeinen in der Welt und in .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruf zur√ºck</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {‚Ä¶}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ‚Ä¶<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       ‚Ä¶<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die asynchrone Programmierung begann mit R√ºckrufen. </font><font style="vertical-align: inherit;">Das hei√üt, zuerst m√ºssen Sie einen Teil des Codes synchron aufrufen und den zweiten Teil - asynchron. </font><font style="vertical-align: inherit;">Sie lesen beispielsweise aus einer Datei und wenn die Daten fertig sind, werden sie Ihnen irgendwie zugestellt. </font><font style="vertical-align: inherit;">Dieser asynchrone Teil wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckruf √ºbergeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere R√ºckrufe</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So k√∂nnen Sie von einem R√ºckruf aus einen weiteren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckruf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> registrieren </font><font style="vertical-align: inherit;">, von dem aus Sie einen dritten R√ºckruf registrieren k√∂nnen, und am Ende wird alles zu einer R√ºckruf- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂lle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckruf: Ausnahmen</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie arbeite ich mit Ausnahmen? Zum Beispiel zeigt ReSharper, wenn es separat auf Ausnahmen und eine gute Ausf√ºhrung reagiert, nicht die sch√∂nsten Codeteile - es gibt separate R√ºckrufe f√ºr eine Ausnahmesituation und f√ºr eine erfolgreiche Fortsetzung. Das Ergebnis ist eine solche </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckrufh√∂lle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber nicht linear, sondern baumartig, was v√∂llig verwirrend sein kann. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET wird der erste R√ºckrufansatz als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous Programming Model</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM) bezeichnet. Die Methode wird aufgerufen </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was im Wesentlichen dieselbe ist wie </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber der Ansatz weist einige Merkmale auf. Zuallererst sollten Methoden mit dem Wort ‚ÄûBegin‚Äú beginnen (das Lesen aus einer Datei ist BeginRead), das einige zur√ºckgibt </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selbst</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein Handler, der wei√ü, dass der Vorgang abgeschlossen wurde und √ºber einen Mechanismus verf√ºgt </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen warten, bis der Vorgang asynchron abgeschlossen ist. Auf der anderen Seite k√∂nnen Sie aufrufen </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh synchron </font><font style="vertical-align: inherit;">machen </font><font style="vertical-align: inherit;">und h√§ngen (was einer Eigenschaft sehr √§hnlich ist </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz weist eine Reihe von Problemen auf. Erstens sch√ºtzt es uns nicht vor der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂lle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><i><font style="vertical-align: inherit;">R√ºckrufs</font></i><font style="vertical-align: inherit;"> . Zweitens bleibt v√∂llig unklar, was mit Ausnahmen zu tun ist. Drittens ist nicht klar, auf welchem ‚Äã‚ÄãThread dieser R√ºckruf aufgerufen wird - wir haben keine Kontrolle √ºber den Aufruf. Viertens stellt sich die Frage, wie Code mit R√ºckrufen kombiniert werden kann. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Modell hei√üt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ereignisbasiertes asynchrones Muster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist ein reaktiver R√ºckrufansatz. Die Idee der Methode ist, dass wir </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Objekt mit abgeschlossenem Ereignis </font><font style="vertical-align: inherit;">an die Methode √ºbergeben </font><font style="vertical-align: inherit;">und dieses Ereignis abonnieren. Wie Sie bemerkt haben, </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§ndert sich zu </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Verwirrung kann auftreten, wenn Sie in die Socket-Klasse gehen, in der zwei Muster gemischt werden: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass Sie anrufen m√ºssen, um abzubrechen </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Da dies in .NET nirgendwo anders zu finden ist, sendet normalerweise jeder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie also versehentlich auf eine Methode in der Bibliothek sto√üen, die mit endet </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, m√ºssen Sie verstehen, dass sie nicht unbedingt zur√ºckgegeben wird </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern eine √§hnliche Konstruktion zur√ºckgeben kann. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich ein Modell vor, das in Java als bekannt ist</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in JavaScript als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in .NET als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchrone</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabenmuster, mit anderen Worten als "Aufgaben". Bei dieser Methode wird davon ausgegangen, dass Sie √ºber ein Berechnungsobjekt verf√ºgen und den Status dieses Objekts (ausgef√ºhrt oder beendet) anzeigen k√∂nnen. In .NET gibt es eine sogenannte </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bequeme Trennung von zwei Status: dem Start der Aufgabe und dem Abschluss der Aufgabe. Ein h√§ufiger Fehler tritt auf, </font><font style="vertical-align: inherit;">wenn ein Verfahren auf einer Aufgabe aufgerufen wird , </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass die </font><font style="vertical-align: inherit;">Renditen nicht erfolgreiche Fortsetzung, aber </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher sollte sich das Ergebnis des Klickens auf "Abbrechen" in der UI-Anwendung von der R√ºckgabe von Ausnahmen (Ausf√ºhrungen) unterscheiden. In .NET wurde eine Unterscheidung getroffen: Wenn die Ausf√ºhrung Ihr Fehler ist, den Sie sichern m√∂chten, </font><i><font style="vertical-align: inherit;">klicken</font></i><font style="vertical-align: inherit;"> Sie auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbrechen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Zwangsbetrieb. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET wurde auch ein Konzept eingef√ºhrt </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- es ist eine Art Abstraktion √ºber Threads, die angibt, wo die Aufgabe ausgef√ºhrt werden soll. In diesem Fall wurde die Stornierungsunterst√ºtzung auf Entwurfsebene entworfen. Fast alle Vorg√§nge in der Bibliothek in .NET </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen √ºbergeben werden. Dies funktioniert nicht f√ºr alle Sprachen: In Kotlin k√∂nnen Sie beispielsweise Aufgaben r√ºckg√§ngig machen, in .NET jedoch nicht. Die L√∂sung kann die Aufteilung der Verantwortung zwischen denjenigen, die die Aufgabe stornieren, und der Aufgabe selbst sein. Wenn Sie eine Aufgabe erhalten, k√∂nnen Sie sie nur explizit abbrechen - Sie m√ºssen sie weitergeben </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem speziellen Objekt </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen Sie auf einfache Weise alte APIs anpassen, die dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ereignisbasierten asynchronen Muster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchronen Programmiermodell zugeordnet sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt ein Dokument, das Sie lesen m√ºssen, wenn Sie Aufgaben programmieren. </font><font style="vertical-align: inherit;">Es beschreibt alle Vereinbarungen in Bezug auf Tasas. </font><font style="vertical-align: inherit;">Beispielsweise sollte jede Methode, die die Aufgabe zur√ºckgibt, sie in einem laufenden Zustand zur√ºckgeben, was bedeutet, dass dies nicht m√∂glich ist </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, w√§hrend alle derartigen Vorg√§nge enden m√ºssen </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzungen kombinieren</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kombination kann unter Ber√ºcksichtigung der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckrufh√∂lle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in einer lineareren Form erscheinen, obwohl sich wiederholende Codeteile mit minimalen √Ñnderungen vorhanden sind. </font><font style="vertical-align: inherit;">Es scheint, dass sich der Code auf diese Weise verbessert, aber auch hier gibt es Fallstricke.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgaben starten und fortsetzen</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenden wir uns beim Start der Standardaufgabe drei Parametern zu: Der erste sind die Optionen zum Starten der Aufgabe, der zweite ist der </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auf dem die Aufgabe gestartet wird, und der dritte - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler gibt an, wo die Aufgabe beginnt, und ist ein Objekt, das Sie unabh√§ngig √ºberschreiben k√∂nnen. Sie k√∂nnen beispielsweise eine Methode √ºberschreiben </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie das </font><font style="vertical-align: inherit;">tun </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Verfahren </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nimmt einen Faden aus </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sendet Ihre Aufgabe dort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Hauptthread √ºbernehmen, wird alles in eine Warteschlange gestellt, und Aufgaben werden nacheinander im Hauptthread ausgef√ºhrt. Das Problem ist jedoch, dass Sie in .NET Aufgaben ausf√ºhren k√∂nnen, ohne sie zu √ºbergeben </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es stellt sich die Frage: Wie berechnet .NET dann, welche Aufgabe an es √ºbergeben wurde? Wenn die Aufgabe von </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innen </font><font style="vertical-align: inherit;">beginnt</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgestellt in dem </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, den wir ihr gegeben haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Design erscheint aufgrund des impliziten Kontexts eher kontrovers. Es gab F√§lle, in denen es </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchronen Code enthielt, der irgendwo sehr tief geerbt </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und mit einem anderen Scheduler √ºberlappt wurde, was zu Deadlocks f√ºhrte. In diesem Fall k√∂nnen Sie die Option verwenden </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist eine Alarmglocke, die besagt, dass wir eine Option haben, die die </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einstellung </font><font style="vertical-align: inherit;">√ºberschreibt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Fortsetzungen ist alles gleich. Es stellt sich die Frage: Woher kommt es </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Fortsetzungen? Zun√§chst wird die Methode verwendet, mit der Sie begonnen haben </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es stammt auch </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus ThreadStatic. Es ist wichtig, dass </font><font style="vertical-align: inherit;">Fortsetzungen </font><font style="vertical-align: inherit;">f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / Warten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehr unterschiedlich funktionieren.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wenden uns den Parametern </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zu </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ihr Hauptproblem ist, dass es viele von ihnen gibt. Einige dieser Parameter heben sich gegenseitig auf, andere schlie√üen sich gegenseitig aus. Alle diese Parameter k√∂nnen in allen m√∂glichen Kombinationen verwendet werden, daher ist es schwierig, alles im Auge zu behalten, was mit Sehnsucht passieren kann. Einige dieser Optionen funktionieren v√∂llig unverst√§ndlich. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel stellen die Parameter </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei m√∂gliche Anwendungsoptionen dar. Ob die Fortsetzung jedoch synchron oder asynchron gestartet wird, h√§ngt von so vielen Dingen ab, die Sie nicht kennen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel: Wir haben die Aufgabe gestartet, die Fortsetzung gestartet und gleichzeitig zwei Parameter angegeben</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach starteten sie die Fortsetzung asynchron. </font><font style="vertical-align: inherit;">Wird es auf demselben Stapel ausgef√ºhrt, auf dem die vorherige Aufgabe endet, oder wird es auf √ºbertragen </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">In diesem Fall gibt es eine dritte Option: es kommt darauf an.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberlegen Sie </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie eine Aufgabe erstellen, setzen Sie das Ergebnis durch </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die vorherigen asynchronen Muster an die Aufgabenwelt anzupassen. Sie </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen anfordern </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und diese Aufgabe wird </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Aufrufen </font><font style="vertical-align: inherit;">in einen Status versetzt </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie dies jedoch im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-Pool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausf√ºhren </font><font style="vertical-align: inherit;">, kommt es zu einem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Frage ist, warum, wenn wir nicht einmal synchron etwas geschrieben haben? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erstellen </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, starten eine neue Aufgabe und haben einen zweiten Thread, der etwas in dieser Aufgabe startet. Es geht √ºber und f√§llt f√ºr hundert Millisekunden in Erwartung. Dann </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wartet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unser Hauptfaden - gr√ºn - </font><font style="vertical-align: inherit;">und das wars. Er gibt den Stapel frei, der Stapel h√§ngt und wartet darauf, in einer Fortsetzung aufgerufen zu werden</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgesetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im blauen Faden kommen wir zu </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann zum interessantesten. </font><font style="vertical-align: inherit;">Basierend auf internen √úberlegungen von .NET </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glaubt </font><font style="vertical-align: inherit;">er </font><font style="vertical-align: inherit;">, dass die Fortsetzung </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchron durchgef√ºhrt werden kann, dh direkt auf demselben Stapel, dann </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchron auf demselben Stapel. </font><font style="vertical-align: inherit;">Das ist sehr seltsam, obwohl wir noch nirgendwo geschrieben haben </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist wahrscheinlich das Problem beim Mischen von synchronem und asynchronem Code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Problem dabei </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist, dass Sie beim Aufrufen </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unter der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sperre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keinen beliebigen Code aufrufen k√∂nnen, da Sie unter der Sperre nur einige kleine granulare Aktivit√§ten ausf√ºhren k√∂nnen. </font><font style="vertical-align: inherit;">Laufen Sie unter einigen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktionen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist unm√∂glich, von dort zu kommen, wo sie herkommen. </font><font style="vertical-align: inherit;">Wie kann man dieses Problem l√∂sen?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lohnt sich </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">nur zur Anpassung von nicht </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code in Bibliotheken zu verwenden. </font><font style="vertical-align: inherit;">Fast alles andere kann durch Warten gel√∂st werden. </font><font style="vertical-align: inherit;">In diesem Fall wird immer dringend empfohlen, den Parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously" vorzuschreiben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie m√ºssen fast immer eine Fortsetzung asynchron ausf√ºhren. </font><font style="vertical-align: inherit;">In diesem Fall haben Sie </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwas, unter dem nichts gestartet wird. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum sollte die Fortsetzung synchron erfolgen? </font><font style="vertical-align: inherit;">Weil es </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich auf Folgendes bezieht </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht auf unser. </font><font style="vertical-align: inherit;">Damit er sich auf unsere beziehen kann, m√ºssen Sie Folgendes schreiben: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Beispiel zeigt, wie Parameter nicht intuitiv sind, wie sie sich √ºberschneiden, wie sie kognitive Komplexit√§t einf√ºhren - es ist so schwierig zu schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eltern-Kind-Hierarchie</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere Optionen f√ºr die Verwendung von Parametern. Beispielsweise entsteht eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eltern-Kind-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hierarchie </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">wenn Sie eine Aufgabe starten und eine andere darunter ausf√ºhren. In diesem Fall, wenn Sie schreiben </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Sie </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden nicht f√ºr die Aufgabe innerhalb gestartet warten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie schreiben </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird es </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warten. Sie k√∂nnen diese Eigenschaft in Ihren Produkten verwenden. Ich denke, jeder kann sich ein Beispiel einfallen lassen, in dem es eine Hierarchie von Aufgaben gibt, wobei die Aufgabe auf die Unteraufgabe und die Unteraufgabe auf ihre Unteraufgaben wartet. Sie m√ºssen nirgendwo schreiben </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, diese Wartezeit erfolgt asynchron. Das hei√üt, der Hauptteil der √ºbergeordneten Aufgabe endet und danach beginnt die Fortsetzung der √ºbergeordneten Aufgabe erst, wenn die untergeordneten Aufgaben funktionieren.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√∂glicherweise liegt ein Problem vor, bei dem die Aufgabe irgendwo in √ºbertragen </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird. Dann wird alles, mit dem Sie begonnen </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben, zu dieser √ºbergeordneten Aufgabe hinzugef√ºgt, bei der es sich um eine Alarmglocke handelt.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite gibt es eine Option, die die vorherige Option aufhebt </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine solche Anwendung kommt ziemlich oft vor.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sei daran erinnert, dass </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies die Standardmethode f√ºr den Start ist, was standardm√§√üig impliziert </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der implizite Kontext, den Sie eingeben, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erh√∂ht die Komplexit√§t. Sie verstehen nicht, wie die Aufgabe funktioniert, da Sie den Kontext kennen m√ºssen. Ein weiteres Problem, das auftreten kann, h√§ngt mit dem Ruhezustand von async / await zusammen. Das liegt daran, dass Sie in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine Aufgaben, sondern Aktionen haben. Fortsetzung ist keine ehrliche Aufgabe, sondern Handeln. Wenn Sie asynchronen / wartenden Code schreiben, m√ºssen Sie ihn nicht verwenden </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da Sie die Aufgaben zum Warten auf warten explizit verkn√ºpfen. Dies ist der richtige Ansatz. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben sechs M√∂glichkeiten, wie Sie eine Fortsetzung starten k√∂nnen. Sie haben die Aufgabe gestartet, gestartet</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Frage: Welchen Status wird diese Fortsetzung haben? </font><font style="vertical-align: inherit;">Es gibt f√ºnf m√∂gliche Antworten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die allgemeine Fortsetzung wird erfolgreich abgeschlossen. RunToCompletion wird ausgef√ºhrt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufgabe ist fehlerhaft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stornierung erfolgt;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufgabe wird √ºberhaupt nicht abgeschlossen sein, sie wird in einer Art Schwebe sein.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option - "h√§ngt davon ab".</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall befindet sich die Aufgabe im Status "Abgebrochen", obwohl das Wort "Abgebrochen" nirgendwo ist. </font><font style="vertical-align: inherit;">Hier werfen wir die Rezeption und tun nichts. </font><font style="vertical-align: inherit;">Das Problem ist, dass Sie beim Lesen des Codes eines anderen mit vielen Optionen - auch wenn Sie vor 10 Minuten von diesen Optionen gewusst haben - immer noch vergessen, was hier passiert. </font><font style="vertical-align: inherit;">Also nicht schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stornierung</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der dritte Parameter beim Starten einer Aufgabe ist die Stornierung. </font><font style="vertical-align: inherit;">Sie schreiben </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dh eine spezielle Aktion, die die Aufgabe in den Status "Abgebrochen" versetzt. </font><font style="vertical-align: inherit;">In diesem Fall befindet sich die Aufgabe im Status "Fehlgeschlagen", da nicht alle </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich sind.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit die Aufgabe ausgef√ºhrt werden kann, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen Sie sie </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammen mit dem CancellationToken </font><font style="vertical-align: inherit;">werfen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In Wirklichkeit tun Sie dies niemals explizit, sondern auf folgende Weise:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es notwendig, CancellationToken zu unterscheiden? </font><font style="vertical-align: inherit;">Irgendwo innerhalb der Aufgabe √ºberpr√ºfen Sie, ob jemand Sie gel√∂scht hat: Wurfabbruch, dann wird die Aufgabe in den Status versetzt </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Oder jemand hat zur Laufzeit auf "Abbrechen" geklickt und die Aufgabe abgebrochen. </font><font style="vertical-align: inherit;">Unsere Praxis bei JetBrains legt nahe, dass Sie nicht zwischen diesen Token unterscheiden m√ºssen. </font><font style="vertical-align: inherit;">Wenn Sie eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException erhalten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - eine spezielle Art, die auftritt, wenn eine Stornierung erfolgt ist, k√∂nnen Sie sie unterscheiden. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen Sie die Aufgabe nur normal ausf√ºhren, sich nicht anmelden und sich nach Erhalt der Ausf√ºhrung anmelden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefer Stapel</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie haben einen tiefen Stapel. Dies </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist der einzige explizite Parameter, den wir besprochen haben. Es muss √ºberall durch absolut alle Hierarchien √ºbertragen werden. Was soll ich tun, wenn Sie bei einer tiefen Hierarchie Ihre Aufgabe irgendwo auf der untersten Ebene abbrechen m√ºssen, um den Empfang auszuschalten? Es gibt so einen besonderen Trick, den wir verwenden. Er hei√üt </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist dasselbe wie </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur das spezielle </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das asynchrone / wartende Code-Trips √ºberlebt. </font><font style="vertical-align: inherit;">Da Ihr Code asynchron ist und Sie diese Kancellation haben, geben Sie ihn ein </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und irgendwo auf einer tiefen Ebene k√∂nnen Sie " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">sagen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Auch dies ist der einzige Parameter </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der den gesamten Code vollst√§ndig verschmieren muss. Meiner Meinung nach m√ºssen Sie jedoch f√ºr die meisten Aufgaben nur wissen, was passiert ist </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und daraus eine Schlussfolgerung ziehen, die besagt: Abgebrochen oder fehlgeschlagen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kognitive Komplexit√§t</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je schwieriger der Code beim Starten der Aufgabe zu lesen ist, desto h√∂her ist das Fehlerrisiko. Wenn Sie sich den Code nach einem Jahr ansehen, werden Sie vergessen, was er tut, da es eine gro√üe Anzahl von Parametern gibt. Wir haben jedoch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">, die moderne Lebensdauern bietet, ein gut optimiertes CancellationToken, mit dem die Start-Methode neu geschrieben und das Problem mit sich wiederholenden Codeteilen wie mit </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">gel√∂st wurde </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine kleine Anzahl von Schedulern, mit denen Sie eine Aufgabe im Hauptthread mit Lesesperre planen k√∂nnen. Das hei√üt, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Lesesperre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird nicht explizit ausgew√§hlt, sondern ist ein spezieller Scheduler, der Ihren Code im Hauptthread mit der </font><i><font style="vertical-align: inherit;">Lesesperre</font></i><font style="vertical-align: inherit;"> plant</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sowie der Haupt-Thread mit Schreibsperre, Hintergrund-Thread - und jetzt werden die Methoden sehr einfach, um das Mischen zu starten. Gleichzeitig werden die Lebensdauern automatisch abgebrochen </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was den Code erheblich vereinfacht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Probleme l√∂st und welche Probleme sie verursachen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel wird ein Teil des Codes synchron ausgef√ºhrt und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wartet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann </font><i><font style="vertical-align: inherit;">auf</font></i><font style="vertical-align: inherit;"> asynchronen Code. Erstens ist es gut, dass es viel weniger sich wiederholende Codeteile gibt ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesselplatte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Zweitens ist es gut, dass asynchroner Code dem synchronen Code sehr √§hnlich ist. Genau daf√ºr ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await gedacht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie k√∂nnen asynchron genauso schreiben wie synchron, ohne Threads zu belegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wird der Compiler in diesem Fall bereitstellen? Der synchrone Code wird synchron ausgef√ºhrt. </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach wird </font><font style="vertical-align: inherit;">die Task synchron ausgef√ºhrt. </font><font style="vertical-align: inherit;">Woher kommt das spezielle GetAwaiter-Objekt? In diesem Fall sind wir interessiert </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie k√∂nnen Ihren Kellner f√ºr absolut jedes Objekt schreiben. Infolgedessen warten wir, bis die Aufgabe abgeschlossen ist, </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºhren sie synchron aus </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Aufgabe nicht abgeschlossen wurde, wird der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ContinuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontextplaner geplant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es kann sein, dass, obwohl Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warten geschrieben haben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , absolut alles synchron aufgerufen wird.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Trick </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- dies ist eine spezielle Aufgabe, die sicherstellt, dass der Kellner nicht immer zu Ihnen zur√ºckkehrt </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dementsprechend wird </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es an dieser Stelle nicht synchron aufgerufen. F√ºr einen UI-Thread kann dies wichtig sein, da Sie diesen Thread nicht lange verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie w√§hle ich einen Thread f√ºr die Fortsetzung aus? Die Philosophie von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lautet </font><font style="vertical-align: inherit;">: Sie schreiben asynchronen Code genauso wie synchron. Wenn Sie einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-Pool haben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , spielt </font><font style="vertical-align: inherit;">dies f√ºr Sie </font><font style="vertical-align: inherit;">keine Rolle - ContinuationCode wird auf einem anderen Thread ausgef√ºhrt. Unabh√§ngig davon, ob es </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abgeschlossen wurde, als Sie " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sagten </font><font style="vertical-align: inherit;">oder nicht, ben√∂tigen Sie alles, um auf dem UI-Thread ausgef√ºhrt zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Mechanismus f√ºr das Warten auf Aufgaben ist wie folgt: Es wird genommen </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es wird aufgerufen</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und daraus entsteht </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Sache mit der Post-Methode, die der Methode sehr √§hnlich ist </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der Tat </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was fr√ºher war, nimmt es einfach </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºhrt durch Post seine Aufgabe darauf aus.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine M√∂glichkeit, dieses Verhalten mithilfe eines Parameters zu √§ndern </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die ekelhafteste API in .NET hei√üt </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall erstellt die API einen speziellen Kellner, der sich von dem unterscheidet </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der die Fortsetzung verschiebt. Er wird auf demselben Thread ausgef√ºhrt, in demselben Kontext, in dem die Methode beendet wurde </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in dem die Aufgabe beendet wurde.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Internet gibt es eine wahnsinnige Menge an Ratschl√§gen: Wenn Sie einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlock haben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verschmieren Sie bitte Ihren gesamten ConfigureAwait-Code, und alles wird gut. </font><font style="vertical-align: inherit;">Das ist der falsche Weg. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann in F√§llen verwendet werden, in denen Sie die Leistung geringf√ºgig verbessern m√∂chten, oder am Ende der Methode in einigen Bibliotheksmethoden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlocks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein klassischer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Auf dem UI-Thread warteten sie zehn Sekunden und taten es </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aufgrund dessen, was Sie getan haben </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird es </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">niemals gestartet, </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daher </font><font style="vertical-align: inherit;">wird es </font><font style="vertical-align: inherit;">niemals zur√ºckkehren. </font><font style="vertical-align: inherit;">All dies findet ganz am Anfang statt.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, dies ist eine echte Aktivit√§t. Wir haben auf die Schaltfl√§che geklickt, sie genommen </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abgewartet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und geschrieben. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sagen: "Bitte schlie√üen Sie unseren UI-Stream nicht, f√ºhren Sie die Fortsetzung durch." Das Problem ist, dass der zweite Teil danach </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch auf dem UI-Thread ausgef√ºhrt werden soll, da dies die Philosophie des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wartens ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das hei√üt, Ihr asynchroner Code sieht genauso aus wie synchroner Code und wird im selben Kontext ausgef√ºhrt. In diesem Fall liegt nat√ºrlich ein Fehler vor. Und au√üerdem </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann eine beliebige Anzahl von Methodenaufrufen, die auch ihren Kontext √ºbernehmen. Was ist in dieser Situation zu tun? Du kannst das:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem UI-Thread m√ºssen Sie dies </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Threads mit einer gemeinsamen Nachrichtenwarteschlange </font><font style="vertical-align: inherit;">verbieten </font><font style="vertical-align: inherit;">. Anstatt zu tun </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zu schreiben </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen Sie diese Nachrichtenwarteschlange pumpen, und gleichzeitig wird auch das Kontinuum gepumpt. Wenn Sie synchronen und asynchronen Code nicht mischen k√∂nnen, sollten Sie sie nicht mischen. Aber manchmal kann dies nicht vermieden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel haben Sie alten Code und m√ºssen ihn mischen, dann pumpen Sie den UI-Stream. Visual Studio pumpt den UI-Thread auf Erwartungen, es hat sich sogar </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein wenig ge√§ndert. Wenn Sie bei einem beliebigen Vorgang in WaitHandle wechseln </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird Ihr UI-Stream beim Aufh√§ngen gepumpt. Daher w√§hlen sie zwischen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Rennen zugunsten von Rennen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pump bis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist eine nicht ideale API. Wenn Sie also eine zuf√§llige Kontinuit√§t an einem beliebigen Ort durchf√ºhren, kann es zu Nuancen kommen. </font><font style="vertical-align: inherit;">Es gibt leider keinen anderen Weg. </font><font style="vertical-align: inherit;">Mischen Sie synchrone und asynchrone Codes. </font><font style="vertical-align: inherit;">Wenn √ºberhaupt, ist der ganze Fahrer an den alten Orten so angeordnet, dass es manchmal auch Nuancen gibt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontext √§ndern</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt noch eine andere interessante M√∂glichkeit, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie k√∂nnen schreiben , </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber Themen und springen. </font><font style="vertical-align: inherit;">Ich habe Beitr√§ge in Visual Studio gelesen, sie haben sehr lange geschrieben, dass es nicht gut ist, mitten in der Methode hin und her zu springen, aber jetzt machen sie es selbst. </font><font style="vertical-align: inherit;">Visual Studio verf√ºgt √ºber eine API, die √ºber Scheduler auf Threads springt. </font><font style="vertical-align: inherit;">F√ºr den normalen Gebrauch ist dies nicht gut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturierte Parallelit√§t</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um bequem in den neuen Kontext einzutauchen und zum alten zur√ºckzukehren, sollte ein struktureller Wettbewerb oder eine strukturelle Parallelit√§t aufgebaut werden. </font><font style="vertical-align: inherit;">In den sechziger Jahren wurde der GoTo-Operator beispielsweise als sch√§dlich angesehen, weil er die Strukturalit√§t verletzte. </font><font style="vertical-align: inherit;">So ist es hier. </font><font style="vertical-align: inherit;">Das Springen auf F√§den verletzt die Struktur. </font><font style="vertical-align: inherit;">√úberraschenderweise scheint die Verwendung einer asynchronen Zustandsmaschine ein guter Ausweg zu sein. </font><font style="vertical-align: inherit;">Das hei√üt, wenn Ihre √ºbliche Struktur verletzt wird, Sie auf GoTo springen, k√∂nnen Sie die Thread-Struktur verletzen: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten Sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">mischen Sie </font><font style="vertical-align: inherit;">sie mit Tags. </font><font style="vertical-align: inherit;">Dies ist eine √§u√üerst seltsame und seltene Situation, wenn Sie dies tun m√ºssen. </font><font style="vertical-align: inherit;">Trotzdem ist es besser, wenn das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf den gleichen Kontext zur√ºckkehrt. </font><font style="vertical-align: inherit;">Daher hat der Thread-Pool nicht denselben Thread, sondern denselben Kontext wie urspr√ºnglich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequentielles Verhalten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht dasselbe wie parallele Ausf√ºhrung? </font><font style="vertical-align: inherit;">Warten auf Ausf√ºhrung ist sequentielle Ausf√ºhrung. </font><font style="vertical-align: inherit;">In diesem Fall starten wir die erste Aufgabe, warten darauf, starten die zweite Aufgabe - wir warten. </font><font style="vertical-align: inherit;">Wir haben keine Parallelit√§t. </font><font style="vertical-align: inherit;">F√ºr die meisten Anwendungen ist keine Parallelit√§t erforderlich. </font><font style="vertical-align: inherit;">Parallelit√§t selbst ist komplexer als Sequenz. </font><font style="vertical-align: inherit;">Seriencode ist einfacher als parallel, es ist ein Axiom. </font><font style="vertical-align: inherit;">Aber manchmal m√ºssen Sie etwas in parallelem Code ausf√ºhren, und Sie tun es so:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitiges Verhalten</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier beginnen die Aufgaben parallel. </font><font style="vertical-align: inherit;">Es ist klar, dass Methoden die Aufgabe sofort in einem laufenden Zustand zur√ºckgeben k√∂nnen, dann gibt es keine Parallelit√§t. </font><font style="vertical-align: inherit;">Nehmen wir an, beide Aufgaben werfen eine Hinrichtung. </font><font style="vertical-align: inherit;">Und Sie haben auf die erste Aufgabe gewartet und sind dann beim ersten Warten losgefahren. </font><font style="vertical-align: inherit;">Das hei√üt, sobald Sie geschrieben haben </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sind Sie gestartet und haben nicht verarbeitet </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Interessanterweise ist dies ein absolut g√ºltiger Code. </font><font style="vertical-align: inherit;">Und dieser Code hat .NET dazu gef√ºhrt, dass sich in Version 4.5 das Verhalten beim Arbeiten mit Ausf√ºhrungen ge√§ndert hat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmebehandlung</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1‚Äôs exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don‚Äôt crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben nicht behandelte Ausf√ºhrungen den Prozess einfach ausgel√∂st. Wenn Sie keine Ausf√ºhrung abgefangen haben </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dies ist auch eine </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Sie an Scheduler anh√§ngen k√∂nnen), wurde dieser Prozess nicht ausgef√ºhrt. Dies ist ein absolut g√ºltiger Code. Obwohl .NET sein Verhalten ge√§ndert hat, wurde die Einstellung beibehalten, um das Verhalten in die entgegengesetzte Richtung zur√ºckzugeben.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie, wie die Verarbeitung der Ausf√ºhrung verl√§uft. </font><font style="vertical-align: inherit;">CancellationToken-s muss √ºbertragen werden, es ist notwendig, CancellationToken-s den gesamten Code zu "verschmieren". </font><font style="vertical-align: inherit;">Das normale Verhalten von Async ist, dass Sie nirgendwo nachsehen, sondern </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit asynchronem Code genauso arbeiten wie mit synchronem. </font><font style="vertical-align: inherit;">Das hei√üt, im Falle einer Stornierung erhalten Sie eine Ausf√ºhrung, und in diesem Fall tun Sie nichts, wenn Sie sie erhalten </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen dem Status "Abgebrochen" und "Fehlerhaft" besteht darin, dass Sie nicht </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die √ºbliche Ausf√ºhrung erhalten haben. </font><font style="vertical-align: inherit;">Und in diesem Fall k√∂nnen wir es versprechen, Sie m√ºssen nur eine Ausf√ºhrung erhalten und daraus Schlussfolgerungen ziehen. </font><font style="vertical-align: inherit;">Wenn Sie die Aufgabe explizit √ºber Aufgabe gestartet h√§tten, w√§ren Sie geflogen </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und im asynchronen Fall </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werfen </font><font style="vertical-align: inherit;">sie </font><font style="vertical-align: inherit;">immer die allererste Ausf√ºhrung, die darin enthalten war (in diesem Fall - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Praxis</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchrone Methode</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel arbeitet ein D√§mon in ReSharper - einem Editor, der die Datei f√ºr Sie t√∂nt. </font><font style="vertical-align: inherit;">Wenn die Datei im Editor ge√∂ffnet wird, gibt es eine Aktivit√§t, die sie in eine Blockierungswarteschlange stellt. </font><font style="vertical-align: inherit;">Unser Prozess </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liest von dort aus, f√ºhrt dann eine Reihe verschiedener Aufgaben mit dieser Datei aus, f√§rbt sie, analysiert, erstellt und f√ºgt diese Dateien hinzu </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit einem </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schloss arbeiten bereits andere Mechanismen damit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Methode</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Code auf asynchrone Umschreiben, werden wir zun√§chst einmal ersetzen Sie </font><font style="vertical-align: inherit;">es </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Schreiben Sie am Ende unbedingt das Wort ‚ÄûAsync‚Äú. </font><font style="vertical-align: inherit;">Alle asynchronen Methoden m√ºssen mit Async enden - dies ist eine Konvention.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach m√ºssen Sie etwas mit unserem tun </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn es ein synchrones Grundelement gibt, muss es nat√ºrlich ein asynchrones Grundelement geben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Grundelement hei√üt Kanal: die Kan√§le, die im Paket leben </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie k√∂nnen begrenzte und unbegrenzte Kan√§le und Warteschlangen erstellen, auf die Sie asynchron warten k√∂nnen. Dar√ºber hinaus k√∂nnen Sie einen Kanal mit dem Wert "Null" erstellen, dh er hat √ºberhaupt keinen Puffer. Solche Kan√§le werden als Rendezvous-Kan√§le bezeichnet und in Go und Kotlin aktiv beworben. Und im Prinzip ist dies ein sehr gutes Muster, wenn es m√∂glich ist, Kan√§le in asynchronem Code zu verwenden. Das hei√üt, wir √§ndern die Warteschlange in den Kanal, in dem es Methoden </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gibt </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Reihe von parallelem Code, der die Verarbeitung einer Datei √ºbernimmt und in eine solche umwandelt</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kann uns Async helfen, nicht asynchronen, sondern parallelen Code kompakter zu schreiben?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachen Sie den parallelen Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code kann folgenderma√üen umgeschrieben werden:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie sehen sie aus </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Zum Beispiel haben wir eine Datei. Zuerst teilen wir es in Lexeme auf, und wir k√∂nnen zwei Aufgaben parallel ausf√ºhren: Erstellen von Suchcaches und Erstellen eines Syntaxbaums. Danach folgt die Aufgabe, nach semantischen Fehlern zu suchen. Hierbei ist es wichtig, dass alle diese Aufgaben einen gerichteten azyklischen Graphen bilden. Das hei√üt, Sie k√∂nnen einige Teile in parallelen Threads ausf√ºhren, andere nicht, und es gibt offensichtlich Abh√§ngigkeiten, welche Aufgabe auf andere Aufgaben warten soll. Sie erhalten ein Diagramm solcher Aufgaben, Sie m√∂chten sie irgendwie entlang der Threads verteilen. Ist es m√∂glich, es sch√∂n und fehlerfrei zu schreiben? In unserem Code wurde dieses Problem mehrmals auf unterschiedliche Weise gel√∂st. Es kommt selten vor, dass dieser Code fehlerfrei geschrieben wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir definieren dieses Aufgabendiagramm wie folgt: Nehmen wir an, dass jede Aufgabe andere Aufgaben hat, von denen sie abh√§ngt, und schreiben dann mithilfe des ExecuteBefore-W√∂rterbuchs das Grundger√ºst unserer Methode.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skelettl√∂sungen</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie dieses Problem direkt l√∂sen, m√ºssen Sie eine topologische Sortierung dieses Diagramms durchf√ºhren. </font><font style="vertical-align: inherit;">Nehmen Sie dann eine Aufgabe, die keine abh√§ngigen Aufgaben hat, f√ºhren Sie sie aus, analysieren Sie die Struktur unter einem Schloss und sehen Sie, welche Aufgaben keine abh√§ngigen Aufgaben haben. </font><font style="vertical-align: inherit;">Lauf, zerstreue sie irgendwie durch </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir schreiben es etwas kompakter: topologische Sortierung des Graphen + Ausf√ºhrung solcher Aufgaben auf verschiedenen Threads.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async faul</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Muster namens </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir erstellen unsere, </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf denen verschiedene Aktionen ausgef√ºhrt werden sollen. Erstellen wir ein W√∂rterbuch: Wir formatieren jede unserer Phasen (Action ProcessedFile) in eine Aufgabe oder besser gesagt in Lazy from Task und f√ºhren sie entlang des Originaldiagramms aus. Die Variable </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selbst </font><font style="vertical-align: inherit;">und in beforeList - die Aktionen, die vor unserer ausgef√ºhrt werden m√ºssen. Dann erstellen </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir schreiben in Aufgabe </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir warten also auf alle Aufgaben, die vorher erledigt werden m√ºssen. W√§hlen Sie in beforeList diejenige aus </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich in diesem W√∂rterbuch befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass hier nichts synchron ausgef√ºhrt wird, damit dieser Code nicht auff√§llt </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir f√ºhren alle Aufgaben aus, die vor uns lagen, und f√ºhren eine Suche nach Ma√ünahmen durch</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann f√ºhren wir unsere Aktion aus. </font><font style="vertical-align: inherit;">Am Ende m√ºssen Sie nur jede Aufgabe zum Starten auffordern, sonst wissen Sie nie, ob etwas nicht gestartet wurde. </font><font style="vertical-align: inherit;">In diesem Fall hat nichts begonnen. </font><font style="vertical-align: inherit;">Das ist die L√∂sung. </font><font style="vertical-align: inherit;">Diese Methode ist in 10 Minuten geschrieben, es ist absolut offensichtlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So traf asynchroner Code unsere Entscheidung, zun√§chst belegte er einige Bildschirme mit komplexem Konkurrenzcode. </font><font style="vertical-align: inherit;">Hier ist er absolut konsequent. </font><font style="vertical-align: inherit;">Ich benutze es nicht einmal </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ich benutze das √ºbliche </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, weil wir nichts wettbewerbsf√§hig darauf schreiben. </font><font style="vertical-align: inherit;">Es gibt einen konsistenten, konsistenten Code. </font><font style="vertical-align: inherit;">Wir l√∂sen das Problem, parallelen Code mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async-s zu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schreiben, </font><font style="vertical-align: inherit;">wunderbar, das hei√üt - ohne Fehler.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sperren loswerden</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lohnt es sich, Async und diese Sperren einzuschalten? Jetzt gibt es alle Arten von asynchronen Sperren, asynchrone Semaphoren, dh einen Versuch, die Grundelemente zu verwenden, die sich in synchronem und asynchronem Code befinden. Dieses Konzept scheint falsch zu sein, da Sie mit der Sperre etwas vor paralleler Ausf√ºhrung sch√ºtzen. Unsere Aufgabe ist es, die parallele Ausf√ºhrung in eine sequentielle zu √ºbersetzen, da dies einfacher ist. Und wenn es einfacher ist, gibt es weniger Fehler.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen einen Kanal erstellen und dort ein paar Datei- und Verarbeitungsdateien ablegen, und </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine andere Prozedur wird </font><font style="vertical-align: inherit;">diesen Kanal verarbeiten </font><font style="vertical-align: inherit;">und dies nacheinander tun. Lock selbst sch√ºtzt nicht nur die Struktur, sondern linearisiert im Wesentlichen den Zugriff, ein Ort, an dem alle Threads von aufeinanderfolgenden Threads parallel werden. Und wir ersetzen dies explizit durch den Kanal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Architektur ist wie folgt: Arbeiter empfangen Dateien von </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und senden sie irgendwo an den Prozessor, der auch alles nacheinander verarbeitet, es gibt keine Parallelit√§t. Der Code sieht viel einfacher aus. Ich verstehe, dass nicht alles auf diese Weise getan werden kann. Eine solche Architektur funktioniert nicht immer, wenn Sie Datenpipes erstellen k√∂nnen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann sein, dass Sie einen zweiten Kanal haben, der in Ihren Prozessor gelangt, und dass aus den Kan√§len kein azyklisch gerichteter Graph gebildet wird, sondern ein Graph mit Zyklen. </font><font style="vertical-align: inherit;">Dies ist ein Beispiel, das Roman Elizarov 2018 KotlinConf sagte. </font><font style="vertical-align: inherit;">Er schrieb ein Beispiel √ºber Kotlin mit diesen Kan√§len, und dort gab es Zyklen, und dieses Beispiel wurde heruntergefahren. </font><font style="vertical-align: inherit;">Das Problem war, dass in der asynchronen Welt alles komplizierter wird, wenn Sie solche Zyklen in einem Diagramm haben. </font><font style="vertical-align: inherit;">Asynchrone Deadlocks sind insofern schlecht, als sie viel schwieriger zu l√∂sen sind als synchron, wenn Sie einen Stapel von Threads haben, und es ist klar, woran sie h√§ngen. </font><font style="vertical-align: inherit;">Daher ist es ein Werkzeug, das korrekt verwendet werden muss.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie die Synchronisation in asynchronem Code.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seriencode ist einfacher als parallel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchroner Code kann einfach sein und ein Minimum an Parametern und einen impliziten Kontext verwenden, die sein Verhalten √§ndern.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Gewohnheit entwickelt haben, synchronen Code zu schreiben, und selbst wenn der asynchrone Code dem synchronen Code sehr √§hnlich ist, m√ºssen Sie keine Grundelemente dorthin ziehen, wie Sie es bei synchronem Code gewohnt sind </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Verwenden Sie nach M√∂glichkeit Feeds und andere Primitive f√ºr die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichten√ºbermittlung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seriencode ist einfacher als parallel. Wenn Sie Ihre Architektur so schreiben k√∂nnen, dass sie sequentiell aussieht, ohne parallelen Code auszuf√ºhren und zu sperren, schreiben Sie die Architektur sequentiell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das Letzte, was wir aus einer Vielzahl von Beispielen mit Aufgaben gesehen haben. </font><font style="vertical-align: inherit;">Versuchen Sie beim Entwerfen Ihres Systems, sich weniger auf den impliziten Kontext zu verlassen. </font><font style="vertical-align: inherit;">Der implizite Kontext f√ºhrt zu einem Missverst√§ndnis dessen, was im Code geschieht, und Sie k√∂nnen implizite Probleme in einem Jahr vergessen. </font><font style="vertical-align: inherit;">Und wenn eine andere Person an diesem Code arbeitet und etwas darin wiederholt, kann dies zu Schwierigkeiten f√ºhren, von denen Sie einmal wussten, und der neue Programmierer wei√ü es aufgrund des impliziten Kontexts nicht. </font><font style="vertical-align: inherit;">Infolgedessen ist ein schlechtes Design durch eine gro√üe Anzahl von Parametern, deren Kombination und impliziten Kontext gekennzeichnet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was zu lesen</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP-Dokument</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Anleitung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebenszeiten</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491218/index.html">Integration von PVS-Studio in PlatformIO</a></li>
<li><a href="../de491224/index.html">Automatisierung eines Versandservices oder Wie ein Serviceunternehmen die Transportkosten um 30% senken kann</a></li>
<li><a href="../de491230/index.html">Wie ich zur Schule 21 ging und die Enth√ºllung von Geheimnissen</a></li>
<li><a href="../de491232/index.html">RPA + Maschinelles Lernen = Intelligente Automatisierung</a></li>
<li><a href="../de491234/index.html">Drei Tricks f√ºr die Arbeit mit SOLIDWORKS zum Modellieren von Teilen f√ºr den 3D-Druck</a></li>
<li><a href="../de491238/index.html">Genetische Code-Analyse II</a></li>
<li><a href="../de491240/index.html">Der Weg zu den Wolken: gestern und heute Adobe</a></li>
<li><a href="../de491244/index.html">Ableton wird nicht ben√∂tigt: Verbinden Sie Ableton Push 2 mit dem VCV-Rack</a></li>
<li><a href="../de491246/index.html">DEFCON-Konferenz 27. Ihr Auto ist mein Auto. Teil 2</a></li>
<li><a href="../de491250/index.html">LED-Lampen Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>