<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌨️ 🏴‍☠️ 💓 Algoritmo de renderização de volume rápido e fácil 🧑🏾‍🤝‍🧑🏽 😑 😚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, escrevi um pequeno ShaderToy que faz renderização volumétrica simples e depois decidi publicar um post explicando seu trabalho. O própri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmo de renderização de volume rápido e fácil</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente, escrevi um pequeno ShaderToy que faz renderização volumétrica simples e depois decidi publicar um post explicando seu trabalho. </font><font style="vertical-align: inherit;">O próprio ShaderToy interativo pode ser visto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se você estiver lendo de um telefone ou laptop, recomendo assistir a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versão rápida. </font><font style="vertical-align: inherit;">Incluí trechos de código na postagem que ajudarão você a entender o desempenho do ShaderToy em alto nível, mas eles não têm todos os detalhes. </font><font style="vertical-align: inherit;">Se você quiser ir mais fundo, recomendo verificar com o código ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu ShaderToy tinha três tarefas principais:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execução em tempo real</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicidade</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correção física (... ou algo assim)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vou começar com esta cena de código em branco. </font><font style="vertical-align: inherit;">Não vou entrar em detalhes da implementação, porque não é muito interessante, mas vou lhe dizer brevemente por onde começar:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traçado de raio de objetos opacos. </font><font style="vertical-align: inherit;">Todos os objetos são primitivos com interseções simples com raios (1 plano e 3 esferas)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular a iluminação, o sombreamento Phong é usado e, em três fontes de luz esféricas, é usado um coeficiente de atenuação da luz personalizado. </font><font style="vertical-align: inherit;">Raios de sombras não são necessários, porque iluminamos apenas o plano.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está o que parece:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Imagem de ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renderizaremos o volume como uma passagem separada que se mistura com uma cena opaca; </font><font style="vertical-align: inherit;">isso é semelhante ao modo como todos os mecanismos de renderização em tempo real processam individualmente superfícies opacas e translúcidas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1: simular volume</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas primeiro, antes que possamos iniciar a renderização volumétrica, precisamos desse mesmo volume! Para simular o volume, decidi usar as funções de distância assinada (SDF). Por que precisamente as funções dos campos de distância? Porque eu não sou um artista, mas eles permitem que você crie formas muito orgânicas em apenas algumas linhas de código. Não falarei em detalhes sobre as funções das distâncias com um sinal, porque Inigo Kiles já as explicou maravilhosamente. Se você estiver curioso, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma ótima lista de funções diferentes de distâncias e modificadores de sinal. E </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está outro artigo sobre esses SDF raymarching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com um simples e adicionar uma esfera aqui:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos adicionar outra esfera e usar conjugação suave para mesclar as funções de distância das esferas. </font><font style="vertical-align: inherit;">Este código eu peguei diretamente da página do Inigo, mas para maior clareza, vou inseri-lo aqui:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O emparelhamento suave é uma ferramenta extremamente poderosa, porque você pode obter algo bastante interessante simplesmente combinando-o com algumas formas simples. </font><font style="vertical-align: inherit;">Veja como são minhas muitas esferas suavemente conjugadas:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, temos algo em forma de lágrima, mas precisamos de algo mais parecido com uma nuvem do que com uma gota. Um ótimo recurso do SDF é como é fácil distorcer a superfície simplesmente adicionando um pouco de ruído ao SDF. Então, vamos adicionar um movimento browniano fractal (fBM) sobre o ruído, usando a posição para indexar a função de ruído. Inigo Kiles também abordou esse tópico em um ótimo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre ruído fBM. Aqui está a aparência da imagem com ruído fBM sobreposta:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem! </font><font style="vertical-align: inherit;">Graças ao ruído fBM, o objeto de repente começou a parecer muito mais interessante! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos criar a ilusão de que o volume interage com o plano da terra. </font><font style="vertical-align: inherit;">Para fazer isso, adicionei uma distância do plano assinado ligeiramente abaixo do plano do solo e reutilizei a combinação de emparelhamento suave com um valor de emparelhamento muito agressivo (parâmetro k). </font><font style="vertical-align: inherit;">Depois disso, temos esta imagem:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O toque final será a alteração no índice xz do ruído fBM ao longo do tempo, para que o volume pareça uma névoa em turbilhão. </font><font style="vertical-align: inherit;">Em movimento, parece muito bom!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ótimo, conseguimos algo como uma nuvem! </font><font style="vertical-align: inherit;">O código de cálculo SDF também é bastante compacto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso está apenas renderizando um objeto opaco. Precisamos de uma bela névoa magnífica! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a renderizamos na forma de volume, e não em um objeto opaco? Vamos primeiro falar sobre a física que simulamos. O volume é um grande número de partículas em uma determinada área do espaço. E quando digo "enorme", quero dizer "ENORME". Tanto é que modelar cada uma dessas partículas hoje em dia é uma tarefa impossível, mesmo para renderização offline. Bons exemplos disso são fogo, nevoeiro e nuvens. A rigor, tudo é volume, mas, por uma questão de velocidade dos cálculos, é mais fácil fechar os olhos para isso e fingir que não é. Representamos o acúmulo dessas partículas como valores de densidade que geralmente são armazenados em algum tipo de grade 3D (ou algo mais complexo, por exemplo, no OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando a luz passa através de um volume, um par de fenômenos pode ocorrer quando a luz colide com uma partícula. </font><font style="vertical-align: inherit;">Ele pode se espalhar e seguir na outra direção, ou parte da luz pode ser absorvida pela partícula e dissolver-se. </font><font style="vertical-align: inherit;">Para cumprir o requisito de execução em tempo real, executaremos o que é chamado de dispersão única. </font><font style="vertical-align: inherit;">Isso significa o seguinte: assumiremos que a luz é dispersa apenas uma vez, quando a luz colide com uma partícula e voa em direção à câmera. </font><font style="vertical-align: inherit;">Ou seja, não seremos capazes de simular os efeitos da dispersão múltipla, por exemplo, neblina, na qual objetos à distância geralmente parecem mais vagos. </font><font style="vertical-align: inherit;">Mas para o nosso sistema, isso é suficiente. </font><font style="vertical-align: inherit;">Veja como é a dispersão única ao raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pseudocódigo para ele se parece com isso:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, estamos lidando com cálculos com complexidade O (n * m * k). </font><font style="vertical-align: inherit;">Portanto, a GPU terá que trabalhar duro.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós calculamos a absorção</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, vejamos a absorção de luz em volume ao longo do feixe da câmera (ou seja, ainda não realizamos marcações de raios na direção das fontes de luz). </font><font style="vertical-align: inherit;">Para fazer isso, precisamos de duas ações:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realize raymarching dentro do volume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcular a absorção / iluminação em cada etapa</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para calcular a quantidade de luz absorvida em cada ponto, usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a lei Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que descreve a atenuação da luz ao passar por um material. </font><font style="vertical-align: inherit;">Os cálculos são surpreendentemente simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O coeficiente de absorção é um parâmetro do material. </font><font style="vertical-align: inherit;">Por exemplo, em um volume transparente, por exemplo, em água, esse valor será baixo e, para algo mais espesso, por exemplo, leite, o coeficiente será maior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para realizar a marcação de raio de volume, simplesmente executamos etapas de tamanho fixo ao longo do feixe e obtemos absorção a cada etapa. </font><font style="vertical-align: inherit;">Você pode não entender por que executar etapas fixas em vez de algo mais rápido, por exemplo, rastrear uma esfera, mas se você lembrar que a densidade dentro do volume é heterogênea, tudo ficará claro. </font><font style="vertical-align: inherit;">Abaixo está o código de raymarching e absorção de acumulação. </font><font style="vertical-align: inherit;">Algumas variáveis ​​estão fora do escopo deste trecho de código, portanto, confira a implementação completa no ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui está o que obtemos com isso:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece algodão doce! </font><font style="vertical-align: inherit;">Talvez para alguns efeitos isso seja suficiente! </font><font style="vertical-align: inherit;">Mas não temos auto-sombra. </font><font style="vertical-align: inherit;">A luz atinge todas as partes do volume igualmente. </font><font style="vertical-align: inherit;">Mas isso não é fisicamente correto, dependendo do tamanho do volume entre o ponto renderizado e a fonte de luz, receberemos uma quantidade diferente de luz recebida.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-sombreamento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Já fizemos o mais difícil. </font><font style="vertical-align: inherit;">Precisamos fazer o mesmo que fizemos para calcular a absorção ao longo do feixe da câmera, mas apenas ao longo do feixe de luz. </font><font style="vertical-align: inherit;">O código para calcular a quantidade de luz que atinge cada ponto será essencialmente uma repetição do código, mas duplicá-lo é mais fácil do que invadir o HLSL para obter a recursão de que precisamos. </font><font style="vertical-align: inherit;">Então, aqui está como será:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicionar auto-sombreamento nos dá o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Imagem de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suavizar as bordas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No momento, eu já gosto bastante do nosso volume. </font><font style="vertical-align: inherit;">Eu o mostrei ao talentoso líder do departamento de efeitos visuais da The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Ele imediatamente notou que as margens do volume pareciam muito nítidas. </font><font style="vertical-align: inherit;">E isso é absolutamente verdade - objetos como nuvens estão constantemente espalhados no espaço ao seu redor, então suas bordas se misturam com o espaço vazio ao redor do volume, o que deve levar à criação de bordas muito suaves. </font><font style="vertical-align: inherit;">James me ofereceu uma ótima idéia - reduzir a densidade dependendo de quão perto estamos da borda. </font><font style="vertical-align: inherit;">E como estamos trabalhando com funções de distância com um sinal, é muito fácil de implementar! </font><font style="vertical-align: inherit;">Então, vamos adicionar uma função que pode ser usada para solicitar densidade em qualquer ponto do volume:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E então simplesmente reduzimos o valor de absorção:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui está o que parece:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Imagem de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Função de densidade</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que temos a função de densidade, você pode facilmente adicionar um pouco de ruído ao volume para fornecer detalhes e esplendor adicionais. </font><font style="vertical-align: inherit;">Nesse caso, apenas reutilizo a função fBM que usamos para ajustar a forma do volume.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E assim temos o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Imagem de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-sombreamento opaco</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O volume já parece bem bonito! </font><font style="vertical-align: inherit;">Mas um pouco de luz ainda vaza através dele. </font><font style="vertical-align: inherit;">Aqui vemos como a cor verde escoa onde o volume deve definitivamente absorvê-lo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso acontece porque objetos opacos são renderizados antes do volume ser processado, portanto, eles não levam em consideração o sombreamento causado pelo volume. </font><font style="vertical-align: inherit;">Isso é bastante simples de corrigir - temos uma função GetLightVisiblity que pode ser usada para calcular o sombreamento, portanto, basta chamá-lo para iluminar um objeto opaco. </font><font style="vertical-align: inherit;">Temos o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além de criar belas sombras multicoloridas, isso ajuda a melhorar as sombras e aumentar o volume da cena. </font><font style="vertical-align: inherit;">Além disso, graças às margens suaves do volume, obtemos sombras suaves, apesar de, a rigor, trabalharmos com fontes pontuais de iluminação. </font><font style="vertical-align: inherit;">Isso é tudo! </font><font style="vertical-align: inherit;">Muito mais pode ser feito aqui, mas parece-me que atingi a qualidade visual necessária, preservando a relativa simplicidade do exemplo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimizações</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, listarei brevemente algumas possíveis otimizações:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de realizar a marcação de raios na direção da fonte de luz, é necessário verificar pelo valor da extinção da luz se uma quantidade significativa dessa luz realmente atinge o ponto em questão. </font><font style="vertical-align: inherit;">Na minha implementação, observo o brilho da luz, multiplicado pelo albedo do material, e certifico-me de que o valor seja grande o suficiente para que o raymarching seja executado.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo! </font><font style="vertical-align: inherit;">Pessoalmente, fiquei surpreso que você possa criar algo fisicamente correto em uma quantidade tão pequena de código (cerca de 500 linhas). </font><font style="vertical-align: inherit;">Obrigado pela leitura, espero que tenha sido interessante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E mais uma observação: aqui está uma mudança divertida - adicionei emissão de luz com base na distância SDF para criar um efeito de explosão. </font><font style="vertical-align: inherit;">Afinal, as explosões nunca são muitas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Imagem de ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt500896/index.html">O que ver em quarentena? Uma seleção de materiais da Technostream (parte 3)</a></li>
<li><a href="../pt500898/index.html">Crazy SpaceX Moon Plan? Avaliação do programa por U / S_Hirangy (reddit)</a></li>
<li><a href="../pt500902/index.html">O resumo de materiais interessantes para o desenvolvedor móvel # 343 (27 de abril a 3 de maio)</a></li>
<li><a href="../pt500904/index.html">Quem é quem no ecossistema de pagamentos 2020. Parte 1</a></li>
<li><a href="../pt500910/index.html">Sistema de comunicações espaciais de longo alcance na China</a></li>
<li><a href="../pt500918/index.html">A que prestamos atenção ao calcular a significância estatística do teste A / B</a></li>
<li><a href="../pt500920/index.html">Antiguidades: ZX Spectrum e o antigo igrozhur</a></li>
<li><a href="../pt500922/index.html">Um lobo em pele de cordeiro: como capturar um hacker que se disfarça cuidadosamente como um usuário comum</a></li>
<li><a href="../pt500924/index.html">Reunião online JUG.ru "Spring-builder" com Evgeny Borisov</a></li>
<li><a href="../pt500926/index.html">A digitação dinâmica não é uma ferramenta de desenvolvimento. Isso é um absurdo (péssimo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>