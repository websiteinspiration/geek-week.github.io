<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚å®Ô∏è üè¥‚Äç‚ò†Ô∏è üíì Algoritmo de renderiza√ß√£o de volume r√°pido e f√°cil üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üòë üòö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, escrevi um pequeno ShaderToy que faz renderiza√ß√£o volum√©trica simples e depois decidi publicar um post explicando seu trabalho. O pr√≥pri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmo de renderiza√ß√£o de volume r√°pido e f√°cil</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente, escrevi um pequeno ShaderToy que faz renderiza√ß√£o volum√©trica simples e depois decidi publicar um post explicando seu trabalho. </font><font style="vertical-align: inherit;">O pr√≥prio ShaderToy interativo pode ser visto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se voc√™ estiver lendo de um telefone ou laptop, recomendo assistir a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers√£o r√°pida. </font><font style="vertical-align: inherit;">Inclu√≠ trechos de c√≥digo na postagem que ajudar√£o voc√™ a entender o desempenho do ShaderToy em alto n√≠vel, mas eles n√£o t√™m todos os detalhes. </font><font style="vertical-align: inherit;">Se voc√™ quiser ir mais fundo, recomendo verificar com o c√≥digo ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu ShaderToy tinha tr√™s tarefas principais:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execu√ß√£o em tempo real</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicidade</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corre√ß√£o f√≠sica (... ou algo assim)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vou come√ßar com esta cena de c√≥digo em branco. </font><font style="vertical-align: inherit;">N√£o vou entrar em detalhes da implementa√ß√£o, porque n√£o √© muito interessante, mas vou lhe dizer brevemente por onde come√ßar:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tra√ßado de raio de objetos opacos. </font><font style="vertical-align: inherit;">Todos os objetos s√£o primitivos com interse√ß√µes simples com raios (1 plano e 3 esferas)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular a ilumina√ß√£o, o sombreamento Phong √© usado e, em tr√™s fontes de luz esf√©ricas, √© usado um coeficiente de atenua√ß√£o da luz personalizado. </font><font style="vertical-align: inherit;">Raios de sombras n√£o s√£o necess√°rios, porque iluminamos apenas o plano.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° o que parece:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Imagem de ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renderizaremos o volume como uma passagem separada que se mistura com uma cena opaca; </font><font style="vertical-align: inherit;">isso √© semelhante ao modo como todos os mecanismos de renderiza√ß√£o em tempo real processam individualmente superf√≠cies opacas e transl√∫cidas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1: simular volume</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas primeiro, antes que possamos iniciar a renderiza√ß√£o volum√©trica, precisamos desse mesmo volume! Para simular o volume, decidi usar as fun√ß√µes de dist√¢ncia assinada (SDF). Por que precisamente as fun√ß√µes dos campos de dist√¢ncia? Porque eu n√£o sou um artista, mas eles permitem que voc√™ crie formas muito org√¢nicas em apenas algumas linhas de c√≥digo. N√£o falarei em detalhes sobre as fun√ß√µes das dist√¢ncias com um sinal, porque Inigo Kiles j√° as explicou maravilhosamente. Se voc√™ estiver curioso, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma √≥tima lista de fun√ß√µes diferentes de dist√¢ncias e modificadores de sinal. E </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est√° outro artigo sobre esses SDF raymarching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos come√ßar com um simples e adicionar uma esfera aqui:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos adicionar outra esfera e usar conjuga√ß√£o suave para mesclar as fun√ß√µes de dist√¢ncia das esferas. </font><font style="vertical-align: inherit;">Este c√≥digo eu peguei diretamente da p√°gina do Inigo, mas para maior clareza, vou inseri-lo aqui:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O emparelhamento suave √© uma ferramenta extremamente poderosa, porque voc√™ pode obter algo bastante interessante simplesmente combinando-o com algumas formas simples. </font><font style="vertical-align: inherit;">Veja como s√£o minhas muitas esferas suavemente conjugadas:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, temos algo em forma de l√°grima, mas precisamos de algo mais parecido com uma nuvem do que com uma gota. Um √≥timo recurso do SDF √© como √© f√°cil distorcer a superf√≠cie simplesmente adicionando um pouco de ru√≠do ao SDF. Ent√£o, vamos adicionar um movimento browniano fractal (fBM) sobre o ru√≠do, usando a posi√ß√£o para indexar a fun√ß√£o de ru√≠do. Inigo Kiles tamb√©m abordou esse t√≥pico em um √≥timo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre ru√≠do fBM. Aqui est√° a apar√™ncia da imagem com ru√≠do fBM sobreposta:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem! </font><font style="vertical-align: inherit;">Gra√ßas ao ru√≠do fBM, o objeto de repente come√ßou a parecer muito mais interessante! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos criar a ilus√£o de que o volume interage com o plano da terra. </font><font style="vertical-align: inherit;">Para fazer isso, adicionei uma dist√¢ncia do plano assinado ligeiramente abaixo do plano do solo e reutilizei a combina√ß√£o de emparelhamento suave com um valor de emparelhamento muito agressivo (par√¢metro k). </font><font style="vertical-align: inherit;">Depois disso, temos esta imagem:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O toque final ser√° a altera√ß√£o no √≠ndice xz do ru√≠do fBM ao longo do tempo, para que o volume pare√ßa uma n√©voa em turbilh√£o. </font><font style="vertical-align: inherit;">Em movimento, parece muito bom!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√ìtimo, conseguimos algo como uma nuvem! </font><font style="vertical-align: inherit;">O c√≥digo de c√°lculo SDF tamb√©m √© bastante compacto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso est√° apenas renderizando um objeto opaco. Precisamos de uma bela n√©voa magn√≠fica! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a renderizamos na forma de volume, e n√£o em um objeto opaco? Vamos primeiro falar sobre a f√≠sica que simulamos. O volume √© um grande n√∫mero de part√≠culas em uma determinada √°rea do espa√ßo. E quando digo "enorme", quero dizer "ENORME". Tanto √© que modelar cada uma dessas part√≠culas hoje em dia √© uma tarefa imposs√≠vel, mesmo para renderiza√ß√£o offline. Bons exemplos disso s√£o fogo, nevoeiro e nuvens. A rigor, tudo √© volume, mas, por uma quest√£o de velocidade dos c√°lculos, √© mais f√°cil fechar os olhos para isso e fingir que n√£o √©. Representamos o ac√∫mulo dessas part√≠culas como valores de densidade que geralmente s√£o armazenados em algum tipo de grade 3D (ou algo mais complexo, por exemplo, no OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando a luz passa atrav√©s de um volume, um par de fen√¥menos pode ocorrer quando a luz colide com uma part√≠cula. </font><font style="vertical-align: inherit;">Ele pode se espalhar e seguir na outra dire√ß√£o, ou parte da luz pode ser absorvida pela part√≠cula e dissolver-se. </font><font style="vertical-align: inherit;">Para cumprir o requisito de execu√ß√£o em tempo real, executaremos o que √© chamado de dispers√£o √∫nica. </font><font style="vertical-align: inherit;">Isso significa o seguinte: assumiremos que a luz √© dispersa apenas uma vez, quando a luz colide com uma part√≠cula e voa em dire√ß√£o √† c√¢mera. </font><font style="vertical-align: inherit;">Ou seja, n√£o seremos capazes de simular os efeitos da dispers√£o m√∫ltipla, por exemplo, neblina, na qual objetos √† dist√¢ncia geralmente parecem mais vagos. </font><font style="vertical-align: inherit;">Mas para o nosso sistema, isso √© suficiente. </font><font style="vertical-align: inherit;">Veja como √© a dispers√£o √∫nica ao raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pseudoc√≥digo para ele se parece com isso:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, estamos lidando com c√°lculos com complexidade O (n * m * k). </font><font style="vertical-align: inherit;">Portanto, a GPU ter√° que trabalhar duro.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s calculamos a absor√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, vejamos a absor√ß√£o de luz em volume ao longo do feixe da c√¢mera (ou seja, ainda n√£o realizamos marca√ß√µes de raios na dire√ß√£o das fontes de luz). </font><font style="vertical-align: inherit;">Para fazer isso, precisamos de duas a√ß√µes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realize raymarching dentro do volume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcular a absor√ß√£o / ilumina√ß√£o em cada etapa</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para calcular a quantidade de luz absorvida em cada ponto, usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a lei Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que descreve a atenua√ß√£o da luz ao passar por um material. </font><font style="vertical-align: inherit;">Os c√°lculos s√£o surpreendentemente simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O coeficiente de absor√ß√£o √© um par√¢metro do material. </font><font style="vertical-align: inherit;">Por exemplo, em um volume transparente, por exemplo, em √°gua, esse valor ser√° baixo e, para algo mais espesso, por exemplo, leite, o coeficiente ser√° maior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para realizar a marca√ß√£o de raio de volume, simplesmente executamos etapas de tamanho fixo ao longo do feixe e obtemos absor√ß√£o a cada etapa. </font><font style="vertical-align: inherit;">Voc√™ pode n√£o entender por que executar etapas fixas em vez de algo mais r√°pido, por exemplo, rastrear uma esfera, mas se voc√™ lembrar que a densidade dentro do volume √© heterog√™nea, tudo ficar√° claro. </font><font style="vertical-align: inherit;">Abaixo est√° o c√≥digo de raymarching e absor√ß√£o de acumula√ß√£o. </font><font style="vertical-align: inherit;">Algumas vari√°veis ‚Äã‚Äãest√£o fora do escopo deste trecho de c√≥digo, portanto, confira a implementa√ß√£o completa no ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui est√° o que obtemos com isso:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece algod√£o doce! </font><font style="vertical-align: inherit;">Talvez para alguns efeitos isso seja suficiente! </font><font style="vertical-align: inherit;">Mas n√£o temos auto-sombra. </font><font style="vertical-align: inherit;">A luz atinge todas as partes do volume igualmente. </font><font style="vertical-align: inherit;">Mas isso n√£o √© fisicamente correto, dependendo do tamanho do volume entre o ponto renderizado e a fonte de luz, receberemos uma quantidade diferente de luz recebida.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-sombreamento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J√° fizemos o mais dif√≠cil. </font><font style="vertical-align: inherit;">Precisamos fazer o mesmo que fizemos para calcular a absor√ß√£o ao longo do feixe da c√¢mera, mas apenas ao longo do feixe de luz. </font><font style="vertical-align: inherit;">O c√≥digo para calcular a quantidade de luz que atinge cada ponto ser√° essencialmente uma repeti√ß√£o do c√≥digo, mas duplic√°-lo √© mais f√°cil do que invadir o HLSL para obter a recurs√£o de que precisamos. </font><font style="vertical-align: inherit;">Ent√£o, aqui est√° como ser√°:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicionar auto-sombreamento nos d√° o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Imagem de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suavizar as bordas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No momento, eu j√° gosto bastante do nosso volume. </font><font style="vertical-align: inherit;">Eu o mostrei ao talentoso l√≠der do departamento de efeitos visuais da The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Ele imediatamente notou que as margens do volume pareciam muito n√≠tidas. </font><font style="vertical-align: inherit;">E isso √© absolutamente verdade - objetos como nuvens est√£o constantemente espalhados no espa√ßo ao seu redor, ent√£o suas bordas se misturam com o espa√ßo vazio ao redor do volume, o que deve levar √† cria√ß√£o de bordas muito suaves. </font><font style="vertical-align: inherit;">James me ofereceu uma √≥tima id√©ia - reduzir a densidade dependendo de qu√£o perto estamos da borda. </font><font style="vertical-align: inherit;">E como estamos trabalhando com fun√ß√µes de dist√¢ncia com um sinal, √© muito f√°cil de implementar! </font><font style="vertical-align: inherit;">Ent√£o, vamos adicionar uma fun√ß√£o que pode ser usada para solicitar densidade em qualquer ponto do volume:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E ent√£o simplesmente reduzimos o valor de absor√ß√£o:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui est√° o que parece:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Imagem de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fun√ß√£o de densidade</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que temos a fun√ß√£o de densidade, voc√™ pode facilmente adicionar um pouco de ru√≠do ao volume para fornecer detalhes e esplendor adicionais. </font><font style="vertical-align: inherit;">Nesse caso, apenas reutilizo a fun√ß√£o fBM que usamos para ajustar a forma do volume.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E assim temos o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Imagem de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-sombreamento opaco</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O volume j√° parece bem bonito! </font><font style="vertical-align: inherit;">Mas um pouco de luz ainda vaza atrav√©s dele. </font><font style="vertical-align: inherit;">Aqui vemos como a cor verde escoa onde o volume deve definitivamente absorv√™-lo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso acontece porque objetos opacos s√£o renderizados antes do volume ser processado, portanto, eles n√£o levam em considera√ß√£o o sombreamento causado pelo volume. </font><font style="vertical-align: inherit;">Isso √© bastante simples de corrigir - temos uma fun√ß√£o GetLightVisiblity que pode ser usada para calcular o sombreamento, portanto, basta cham√°-lo para iluminar um objeto opaco. </font><font style="vertical-align: inherit;">Temos o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Imagem de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m de criar belas sombras multicoloridas, isso ajuda a melhorar as sombras e aumentar o volume da cena. </font><font style="vertical-align: inherit;">Al√©m disso, gra√ßas √†s margens suaves do volume, obtemos sombras suaves, apesar de, a rigor, trabalharmos com fontes pontuais de ilumina√ß√£o. </font><font style="vertical-align: inherit;">Isso √© tudo! </font><font style="vertical-align: inherit;">Muito mais pode ser feito aqui, mas parece-me que atingi a qualidade visual necess√°ria, preservando a relativa simplicidade do exemplo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimiza√ß√µes</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, listarei brevemente algumas poss√≠veis otimiza√ß√µes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de realizar a marca√ß√£o de raios na dire√ß√£o da fonte de luz, √© necess√°rio verificar pelo valor da extin√ß√£o da luz se uma quantidade significativa dessa luz realmente atinge o ponto em quest√£o. </font><font style="vertical-align: inherit;">Na minha implementa√ß√£o, observo o brilho da luz, multiplicado pelo albedo do material, e certifico-me de que o valor seja grande o suficiente para que o raymarching seja executado.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© tudo! </font><font style="vertical-align: inherit;">Pessoalmente, fiquei surpreso que voc√™ possa criar algo fisicamente correto em uma quantidade t√£o pequena de c√≥digo (cerca de 500 linhas). </font><font style="vertical-align: inherit;">Obrigado pela leitura, espero que tenha sido interessante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E mais uma observa√ß√£o: aqui est√° uma mudan√ßa divertida - adicionei emiss√£o de luz com base na dist√¢ncia SDF para criar um efeito de explos√£o. </font><font style="vertical-align: inherit;">Afinal, as explos√µes nunca s√£o muitas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Imagem de ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt500896/index.html">O que ver em quarentena? Uma sele√ß√£o de materiais da Technostream (parte 3)</a></li>
<li><a href="../pt500898/index.html">Crazy SpaceX Moon Plan? Avalia√ß√£o do programa por U / S_Hirangy (reddit)</a></li>
<li><a href="../pt500902/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 343 (27 de abril a 3 de maio)</a></li>
<li><a href="../pt500904/index.html">Quem √© quem no ecossistema de pagamentos 2020. Parte 1</a></li>
<li><a href="../pt500910/index.html">Sistema de comunica√ß√µes espaciais de longo alcance na China</a></li>
<li><a href="../pt500918/index.html">A que prestamos aten√ß√£o ao calcular a signific√¢ncia estat√≠stica do teste A / B</a></li>
<li><a href="../pt500920/index.html">Antiguidades: ZX Spectrum e o antigo igrozhur</a></li>
<li><a href="../pt500922/index.html">Um lobo em pele de cordeiro: como capturar um hacker que se disfar√ßa cuidadosamente como um usu√°rio comum</a></li>
<li><a href="../pt500924/index.html">Reuni√£o online JUG.ru "Spring-builder" com Evgeny Borisov</a></li>
<li><a href="../pt500926/index.html">A digita√ß√£o din√¢mica n√£o √© uma ferramenta de desenvolvimento. Isso √© um absurdo (p√©ssimo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>