<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤺 ✌🏻 🙇🏻 使いやすさを向上させる新しいTypeScript機能 😐 🧗 🔆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScriptは、多くの点で、プログラミング言語に似ているわけではなく、より優れたJavaScriptプログラムを作成するのに役立つコードをリントおよび文書化するための強力なツールです。
 
 TypeScriptの最も注目すべき長所の1つは、ECMAScript仕様で説明されている最新機能の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使いやすさを向上させる新しいTypeScript機能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/493712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptは、多くの点で、プログラミング言語に似ているわけではなく、より優れたJavaScriptプログラムを作成するのに役立つコードをリントおよび文書化するための強力なツールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptの最も注目すべき長所の1つは、ECMAScript仕様で説明されている最新機能のいくつかをサポートしていることです。開発者がTypeScriptの新しいバージョンにアップグレードする場合、それは彼が新しいJavaScript機能を持っていることを意味します。さらに、これらの機能の使用は、潜在的な互換性の問題を意味するものではありません。 TypeScriptは、最新のJavaScript機能の導入に加えて、使いやすさを向上させるために設計されたTSプログラマーコミュニティに、言語の作成者が常に新しいものを提示しているという事実でも注目に値します。これには、たとえば、コードリファクタリングの補助ツール、エンティティの名前を変更するツール、およびエンティティがプログラムで使用されている場所を見つけるツールが含まれます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/ik/dc/io/ikdcio3bkdkuvgg4h-lplk9lvpm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本日の翻訳は、TypeScriptの興味深い新機能について説明します。</font><font style="vertical-align: inherit;">TypeScriptの革新の完全なリストについては、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不変オブジェクトと配列</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptでは、コンパイル時に通常の変数と関数パラメーターの形式で使用される不変の配列を作成するために、補助型</font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font><font style="vertical-align: inherit;">使用できます</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、それらを使用すると、特に</font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型を指定した後に</font><font style="vertical-align: inherit;">文字を使用して配列を宣言する場合に、型注釈に不均一性を感じる可能性があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">TypeScript 3.4では、読み取り専用の配列であるパラメーターにラベルを付ける新しい方法が導入されています。</font><font style="vertical-align: inherit;">すぐに、不変であるはずの変数を宣言する新しい方法が現れました。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取り専用パラメーターによる使いやすさの向上</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取り専用配列として使用する必要がある関数のパラメーターを宣言するときに、キーワードを使用できるようになりました</font></font><code>readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次の例では、2つのメソッドのシグネチャは同じです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: ReadonlyArray&lt;string&gt;</span>) </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: readonly string[]</span>) </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらの場合でも、配列を変更しようとすると（たとえば、そのメソッドを使用して</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、エラーが発生します。</font><font style="vertical-align: inherit;">この革新により、補助的なジェネリック型が不要になり、コードが読みやすくなります。</font><font style="vertical-align: inherit;">オブジェクトタイプは、読み取り専用エンティティとしてラベル付けすることもできますが、ヘルパータイプが必要</font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as constコンストラクトを使用した不変変数の使いやすさの向上</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワードを使用して宣言された変数のタイプは</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更できません。この概念はJavaScriptに存在します。 TypeScriptでも採用されており、型を使用したより厳密な作業を整理します。しかし、オブジェクトや配列などのオブジェクトデータ型を扱う場合、そのような構造は真に不変ではないことがわかります。キーワードを使用する</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、オブジェクトまたは配列の特定のインスタンスは定数を操作しても変更されませんが、このオブジェクトまたは配列の内容は簡単に変更できます。たとえば、constエンティティの操作に関するルールに違反せずに、メソッドを使用して配列に新しい値を追加し</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たり、オブジェクトのプロパティの値を変更したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用する</font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptに、システムがエンティティを真に不変であるかのように処理するように指示できます。</font><font style="vertical-align: inherit;">つまり、そのようなエンティティを変更するコードが試行されるたびに、エラーメッセージが発行されます。</font></font><br>
<br>
<pre><code class="javascript hljs">interface Person {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> Readonly&lt;Person&gt;;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript 3.4では、他の革新の中でも、構造の使用を提供するconstアサーション（定数ステートメント）の概念が登場しました</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、不変のオブジェクトと配列を含む定数を宣言するための簡略化された方法です。</font><font style="vertical-align: inherit;">このような宣言は</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、宣言の最後に定数を</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">すること</font><font style="vertical-align: inherit;">によって構築され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この方法には、ステートメントを使用して型を明示的に指定する必要がないという利点もあります</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
&nbsp;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span><font></font>
&nbsp;<font></font>
<span class="hljs-comment">//      as const</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;&nbsp;<font></font>
array.push(<span class="hljs-number">4</span>); <span class="hljs-comment">// !</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘルパー型省略</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptにはいくつかのヘルパータイプがあり、既存のタイプを新しいタイプに簡単にマッピングしたり、他のタイプに基づいて条件付きでタイプを設定したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補助型</font></font><code>Partial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、オブジェクトのすべてのプロパティをオプションとしてマークできます。</font><font style="vertical-align: inherit;">TypeScript 3.5がリリースされる前は、結局のところ、プロジェクトでは常に1つの興味深いメカニズムを使用していました。</font><font style="vertical-align: inherit;">これは、補助型を使用することで実現できるのと同じ</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">このタイプは、その名前が示すように、他のタイプから何かを除外することができます。</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーのタイプと組み合わせを受け入れ、キーによって記述されたプロパティが除外される新しいタイプを返します。</font><font style="vertical-align: inherit;">機能の独立した実装に</font></font><code>Pick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ</font><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">なければならなかった時代</font></font><code>Exclude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は過ぎ去りました</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     TypeScript 3.5</span><font></font>
type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;<font></font>
&nbsp;<font></font>
interface A {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propA?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propB?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propC?: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
type B = Omit&lt;A, <span class="hljs-string">'propA'</span> | <span class="hljs-string">'propC'</span>&gt;;&nbsp;
<span class="hljs-keyword">const</span> b: B = { <span class="hljs-attr">propA</span>: <span class="hljs-string">'hi'</span> }; <span class="hljs-comment">// ;</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptでサポートされる新しいJavaScript機能</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいJavaScript機能の提案が調整の4番目の段階に達すると、それらは言語の次のバージョンの一部と見なされます。</font><font style="vertical-align: inherit;">確かに、そのサポートは適切な環境に実装する必要があるため、このような機能をJavaScriptですぐに使用できるという意味ではありません。</font><font style="vertical-align: inherit;">アプリケーションは、通常の操作が想定される場所であればどこでも、このような機会にアクセスできる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptコンパイラには、新しいJavaScript機能のサポートが定期的に追加されています。</font><font style="vertical-align: inherit;">通常、これらの機能を実装するコードは、で指定されたプロジェクトのビルド目標をサポートするすべてのブラウザーと互換性のあるJavaScriptコードに変換できます</font></font><code>tsconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null nullおよび未定義をチェック</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript開発者は、真実と偽造の概念に精通しています。真実をチェックするときは常に偽である6つの値を、識別することができます：</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして、もちろん、</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ほとんどの場合、開発者は値がtrueまたはfalseであるかどうかを確認するだけで済みますが、調査する値が実際の値である</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">どうかを確認するだけでよい場合もあります</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、コード</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">を区別する必要がある場合</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ||     ,  index  0</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index || <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 1 &lt;-- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは</font><font style="vertical-align: inherit;">、値</font><font style="vertical-align: inherit;">が等しい</font><font style="vertical-align: inherit;">場合を除くすべての場合</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、に</font><font style="vertical-align: inherit;">書き込まれた値に</font><font style="vertical-align: inherit;">設定</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことで機能します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このコードをどのような状況でも正しく機能させるには、より複雑なテスト方式を使用してコードを書き直し、実際のタイプの値を見つける必要があります。</font></font><code>index</code><font style="vertical-align: inherit;"></font><code>0</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index !== <span class="hljs-literal">null</span> &amp;&amp; index !== <span class="hljs-literal">undefined</span> ? : <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでコードは機能しますが、より複雑なチェックを使用する必要があります。</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2つの疑問符-のように見える）の</font><font style="vertical-align: inherit;">値をチェックするための新しい演算子は、</font><font style="vertical-align: inherit;">andと</font></font><code>??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しくない場合、左側にある値を返すことにより、そのようなチェックを簡略化</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">それ以外の場合は、右側にあるものを返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// !</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index ?? <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
getValueOrOne(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
getValueOrOne(); <span class="hljs-comment">// 1</span>
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍オプションのシーケンス</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript 3.7で利用可能なもう1つの新しいJavaScript機能は、オプションのシーケンスを整理するための演算子です（</font></font><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。私は最初、Groovyプログラミング言語でこのような演算子に出会いました。それ以来、それをJavaScriptにも表示したかったのです。この演算子を使用すると、オブジェクトの存在を常にチェックする必要なく、オブジェクトの埋め込みプロパティへのアクセスを整理できます。プロパティにアクセスしているときにこの演算子が値を検出した場合</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、エラーをスローせずにこの値を返します</font></font><code>TypeError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz;<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo?.bar?.baz;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションのシーケンス演算子は、値をチェックする演算子と組み合わせて、</font><font style="vertical-align: inherit;">開発者にさらに多くの可能性</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与え、たとえば、オブジェクトのネストされたプロパティの値、またはそのようなプロパティが存在しない場合は、いくつかの標準値を変数に書き込むことができます。</font><font style="vertical-align: inherit;">これは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = foo?.bar?.baz ?? <span class="hljs-string">'default value'</span>;
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍プライベートクラスフィールド</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは、この言語の登場以来、アクセス修飾子で宣言されたプライベートクラスフィールドの独自の概念を持っています</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この概念は、クラスがECMAScript標準で記述される前でも、TypeScriptに登場しました。ただし、TypeScriptでは、この概念はコードのコンパイル中に機能するメカニズムを指します。クラスのプライベートフィールドがクラス自体のメソッドからではなくアクセスされる場合、コンパイラーはエラーをスローします。 JavaScriptでは、クラスのプライベートプロパティとメソッドを宣言する機会があります。ただし、この機能は、意味的にも構文的にもTypeScriptに存在していたものとは異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptのプライベートフィールドは、アクセス修飾子を使用して宣言されていません</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。代わりに、名前の先頭に記号を付けることで宣言されます</font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> </span>{&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#on = <span class="hljs-literal">false</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private name = <span class="hljs-string">'fan'</span>;<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;turnOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#on = <span class="hljs-literal">true</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;isTurnedOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#on;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> fan = <span class="hljs-keyword">new</span> Fan();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// false&nbsp;&nbsp;</span><font></font>
fan.turnOn();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// true</span><font></font>
&nbsp;<font></font>
fan.on; <span class="hljs-comment">//  </span>
fan.#on; <span class="hljs-comment">// </span>
fan.name; <span class="hljs-comment">//   ,    JS</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptはプライベートフィールドをサポートするようになり</font><font style="vertical-align: inherit;">、プライベートメソッド</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提案</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は承認の第3段階にあります。</font><font style="vertical-align: inherit;">現在、修飾子</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド名の</font><font style="vertical-align: inherit;">文字</font><font style="vertical-align: inherit;">を一緒に使用することはできません。</font><font style="vertical-align: inherit;">どちらのアプローチも開発中に便利です。どちらを選択するかはプログラマーによって異なります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プライベートフィールドを宣言するための新しい構文を説明</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">する</font></a><font style="vertical-align: inherit;">ポッドキャストです。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codeコードの最上位でawaitキーワードを使用する</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期プログラミングメカニズムは、JavaScriptとTypeScriptの機能を大幅に拡張します。最初にこの領域に約束が現れ、それから- </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりクリーンな非同期コードを記述できる</font><font style="vertical-align: inherit;">設計</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">非同期関数の外部での非同期メソッド呼び出しでは</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なく、promiseが使用されるケースの1つ</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、モジュールまたはアプリケーションコードのトップレベル。この状況での回避策として、非同期ですぐに呼び出される関数式（IIFE、即時に呼び出される関数式）を作成し、そのような式内で非同期コードを実行することを提案できます。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Check out the blog at <span class="hljs-subst">${data.blog}</span>`</span>);&nbsp;<font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コードの最上位レベルで</font><font style="vertical-align: inherit;">キーワードを使用するJavaScriptの機能をサポートするようになり</font><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">これは、awaitがキーワードで宣言された関数の外で使用できることを意味し</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、コンパクトで明確なコードを書くのに非常に適しています。</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確かに、コードのトップレベルの</font><font style="vertical-align: inherit;">式</font><font style="vertical-align: inherit;">は、システムが非同期操作の完了を待機してからモジュールのすべてのコードを実行する必要があるため、モジュールのロードが遅くなり、特定のモジュールがアプリケーション全体のロードを遅くする状況を作り出す可能性があるという事実が批判されています。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { ...data };
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript実験環境の強化</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは新しいTypeScript機能とは言えませんが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツールとして説明しているので、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">TypeScript Playground</font></a><font style="vertical-align: inherit;">は、TypeScript構成をすばやく確認し、これらの構成が変換するJavaScriptコードを表示するための効果的なツールと言えます。</font><font style="vertical-align: inherit;">ここでの例のほとんどは、TypeScript Playgroundで具体的にテストされています。</font><font style="vertical-align: inherit;">現在、この環境はTypeScriptの特定のバージョンを選択する機能をサポートしています（ベータバージョンのサポートを含む）。</font><font style="vertical-align: inherit;">初心者がTypeScriptを使い始めるのに役立ついくつかの例が含まれています。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは、より良く、より表現力のあるJavaScriptコードを作成するのに役立つツールです。</font><font style="vertical-align: inherit;">TypeScriptヘルパーツールを使用すると、エンティティのリファクタリングや名前の変更など、通常のJavaScriptでははるかに複雑な複雑なタスクを簡単に解決できます。</font><font style="vertical-align: inherit;">TypeScriptは、</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">などの新しいメカニズムを常に導入し</font><font style="vertical-align: inherit;">てい</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">言語では、複合型のサポートの継続的な改善を観察できます。</font><font style="vertical-align: inherit;">TypeScriptは最新のJavaScript機能をすばやく実装します。</font><font style="vertical-align: inherit;">そのため、多くの人々がTypeScriptを選択し、それをツール、言語、エコシステムとして認識しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptのどの新機能で最も興味深いと思いますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja493700/index.html">Azureでマルウェアを使用してMicrosoft 365テナントにアクセスする</a></li>
<li><a href="../ja493702/index.html">リモートワークへの大規模な移行：技術的な問題とセキュリティに対する脅威</a></li>
<li><a href="../ja493704/index.html">TypeScriptを記述せずにJavaScriptでTypeScriptを使用する</a></li>
<li><a href="../ja493706/index.html">敵を知る：Node.jsバックドアを作成する</a></li>
<li><a href="../ja493708/index.html">私のホームKubernetesクラスターの構造</a></li>
<li><a href="../ja493714/index.html">セキュリティに関するチートシート：Nodejs</a></li>
<li><a href="../ja493716/index.html">as constコンストラクトとinferキーワードを使用したTypeScriptによる型推論</a></li>
<li><a href="../ja493718/index.html">ディスカッション：使用したことがなく、現在使用している標準のUNIXユーティリティ</a></li>
<li><a href="../ja493720/index.html">完璧な嵐：テクノロジーが外食産業をどのように変えているか</a></li>
<li><a href="../ja493724/index.html">RPA | アナリストの目によるロボット化のプロセス</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>