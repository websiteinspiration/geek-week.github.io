<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüéì üñáÔ∏è üíñ GPU programming in Java ‚ôéÔ∏è üë©üèæ‚Äçüîß üê°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Accessing the GPU from Java reveals tremendous power. It describes how the GPU works and how to access from Java. 
 
 GPU programming is a sky-high wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPU programming in Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accessing the GPU from Java reveals tremendous power. </font><font style="vertical-align: inherit;">It describes how the GPU works and how to access from Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU programming is a sky-high world for Java programmers. </font><font style="vertical-align: inherit;">This is understandable since normal Java tasks are not suitable for the GPU. </font><font style="vertical-align: inherit;">However, GPUs have teraflops of performance, so let's explore their capabilities. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to make the topic accessible, I will spend some time explaining the architecture of the GPU along with a little history that will facilitate an immersion in iron programming.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once I was shown the differences between the GPU and the CPU computing, I will show how to use the GPU in the Java world. </font><font style="vertical-align: inherit;">Finally, I will describe the main frameworks and libraries available for writing Java code and running them on the GPU, and I will give some code examples.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of background</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The GPU was first popularized by NVIDIA in 1999. It is a special processor designed to process graphic data before it is transferred to the display. </font><font style="vertical-align: inherit;">In many cases, this allows some computation to offload the CPU, thereby freeing up CPU resources that speed up these unloaded computations. </font><font style="vertical-align: inherit;">The result is that large input can be processed and presented at a higher output resolution, making the visual presentation more attractive and the frame rate smoother. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The essence of 2D / 3D processing is mainly in the manipulation of matrices, this can be controlled using a distributed approach. </font><font style="vertical-align: inherit;">What will be an effective approach for image processing? </font><font style="vertical-align: inherit;">To answer this, let's compare the standard CPU architecture (shown in Figure 1.) and the GPU.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d6c/58e/c4c/d6c58ec4ccbec78f237d58a822f9ab92.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1. CPU Architecture Blocks</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In the CPU, the actual processing elements - registers, arithmetic logic unit (ALU) and execution contexts - are just small parts of the entire system. To speed up irregular payments coming in an unpredictable order, there is a large, fast, and expensive cache; various types of collectors; and branch predictors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You do not need all this on the GPU, because the data is received in a predictable manner, and the GPU performs a very limited set of operations on the data. Thus, it is possible to make them very small and an inexpensive processor with a block architecture similar to this one is shown in Fig. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/365/425/84c/36542584c2d34d817c48ca2cd0e8d433.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 2. Block architecture for a simple GPU core</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because such processors are cheaper and the processed data in them in parallel chunks, it is simple to make many of them work in parallel. It is designed with reference to multiple instructions, multiple data or MIMD (pronounced "mim-dee"). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second approach is based on the fact that often a single instruction is applied to multiple pieces of data. This is known as a single instruction, multiple data or SIMD (pronounced ‚Äúsim-dee‚Äù). In this design, a single GPU contains multiple ALUs and execution contexts, small areas transferred to shared context data, as shown in Figure 3. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/453/4cb/013/4534cb0135c6c5c3075594787c3266c6.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 3. Comparison of the MIMD-style architecture of the GPU blocks (from the left), with the SIMD design (from the right)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mixing SIMD and MIMD processing provides the maximum bandwidth that I will bypass. </font><font style="vertical-align: inherit;">In this design, you have multiple SIMD processors running in parallel, as in Figure </font><font style="vertical-align: inherit;">4. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d81/fc5/f10/d81fc5f10ab5cf27584669ab846b9836.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">4. Working multiple SIMD processors in parallel; </font><font style="vertical-align: inherit;">there are 16 cores with 128 ALUs</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Since you have a bunch of small, simple processors, you can program them to get a special effect in the output.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running programs on the GPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of the early graphic effects in games were really hard-coded small programs running on the GPU and applied to data streams from the CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This was obvious, even when hard-coded algorithms were insufficient, especially in game design, where visual effects are one of the main magical directions. In response, big sellers opened access to the GPU, and then third-party developers could program them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A typical approach was to write a small program called shaders in a special language (usually a subspecies of C) and compile them using special compilers for the desired architecture. </font><font style="vertical-align: inherit;">The term shaders was chosen because shaders are often used to control light and shadow effects, but this does not mean that they can control other special effects. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each GPU vendor had its own programming language and infrastructure to create shaders for their architecture. </font><font style="vertical-align: inherit;">On this approach, many platforms have been created. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main ones are:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectCompute: Microsoft's private shader language / API that are part of Direct3D, starting with DirectX 10.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD FireStream: Private ATI / Radeon technologies that are outdated by AMD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenACC: Multi-Vendor Consortium, Parallel Computing Solution</font></font></li>
<li>++ AMP:   Microsoft     C++</li>
<li>CUDA:   Nvidia,     </li>
<li>OpenL:  ,   Apple,      Khronos Group</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of the time, working with the GPU is low-level programming. </font><font style="vertical-align: inherit;">In order to make this a bit more understandable for developers, for coding, several abstractions were provided. </font><font style="vertical-align: inherit;">The most famous is DirectX, from Microsoft, and OpenGL, from the Khronos Group. </font><font style="vertical-align: inherit;">These are APIs for writing high-level code, which can then be simplified for the GPU, more semantically, for the programmer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As far as I know, there is no Java infrastructure for DirectX, but there is a good solution for OpenGL. </font><font style="vertical-align: inherit;">JSR 231 started in 2002 and is addressed to GPU programmers, but it was abandoned in 2008 and only supports OpenGL 2.0.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenGL support continues in the independent JOCL project (which also supports OpenCL) and is available to the audience. </font><font style="vertical-align: inherit;">Thus, the famous Minecraft game was written using JOCL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPGPU coming</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So far, Java and the GPU have had no common ground, although they should be. </font><font style="vertical-align: inherit;">Java is often used in enterprises, in data science, and in the financial sector, where there is a lot of computing and where a lot of computing power is needed. </font><font style="vertical-align: inherit;">This is how the idea of ‚Äã‚Äãgeneral-purpose GPU (GPGPU) is. </font><font style="vertical-align: inherit;">The idea of ‚Äã‚Äãusing the GPU along this path began when the manufacturers of video adapters began giving access to the program frame buffer, allowing developers to read the contents. </font><font style="vertical-align: inherit;">Some hackers have determined that they can use the full power of the GPU for universal computing. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The recipe was like this:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encode data as a raster array.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write shaders to handle them.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send them both to the graphics card.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get result from frame buffer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decode data from a raster array.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a very simple explanation. I'm not sure if this will work in production, but it really works. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, numerous studies from the Stanford Institute began to simplify the use of GPUs. In 2005, they made BrookGPU, which was a small ecosystem that included a programming language, compiler, and runtime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BrookGPU compiled programs written in the Brook thread programming language, which was an ANSI C variant. It can target OpenGL v1.3 +, DirectX v9 + or AMD Close to Metal for the server computing part, and it runs on Microsoft Windows and Linux. For debugging, BrookGPU can also simulate a virtual graphics card on the CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, this did not take off, due to the equipment available at that time. In the GPGPU world, you need to copy data to the device (in this context, the device refers to the GPU and the device on which it is located), wait for the GPU to calculate the data, and then copy the data back to the control program. This creates a lot of delays. And in the mid-2000s, when the project was under active development, these delays also excluded the intensive use of the GPU for basic computing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, many companies have seen the future in this technology. Several developers of video adapters began to provide GPGPUs with their proprietary technologies, and other formed alliances provided less basic, versatile programming models that worked on a large amount of hardware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that I‚Äôve told you everything, let's check out the two most successful GPU computing technologies - OpenCL and CUDA - see also how Java works with them. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL and Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like other infrastructure packages, OpenCL provides a basic implementation in C. This is technically available using the Java Native Interface (JNI) or Java Native Access (JNA), but this approach will be too difficult for most developers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, this work has already been done by several libraries: JOCL, JogAmp, and JavaCL. Unfortunately, JavaCL has become a dead project. But the JOCL project is alive and very adapted. I will use it for the following examples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But first I have to explain what OpenCL is. I mentioned earlier that OpenCL provides a very basic model suitable for programming all kinds of devices - not just GPUs and CPUs, but even DSP processors and FPGAs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the simplest example: folding vectors is probably the brightest and simplest example. You have two arrays of numbers for addition and one for the result. You take an element from the first array and an element from the second array, and then you put the sum into the array of results, as shown in Fig. 5. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fff/896/f1f/fff896f1feb607506f35dc8dcdce973b.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. Adding the elements of two arrays and storing the sum in the resulting array</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
As you can see, the operation is very consistent and nonetheless distributed. You can push each addition operation into different core GPUs. This means that if you have 2048 cores, like on the Nvidia 1080, you can perform 2048 addition operations at the same time. This means that here the potential teraflops of computer power are waiting for you. This code for an array of 10 million numbers is taken from the JOCL website:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayGPU</span> </span>{
    <span class="hljs-comment">/**
     * The source code of the OpenCL program 
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String programSource =
        <span class="hljs-string">"__kernel void "</span>+
        <span class="hljs-string">"sampleKernel(__global const float *a,"</span>+
        <span class="hljs-string">"             __global const float *b,"</span>+
        <span class="hljs-string">"             __global float *c)"</span>+
        <span class="hljs-string">"{"</span>+
        <span class="hljs-string">"    int gid = get_global_id(0);"</span>+
        <span class="hljs-string">"    c[gid] = a[gid] + b[gid];"</span>+
        <span class="hljs-string">"}"</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span>
    </span>{
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10_000_000</span>;
        <span class="hljs-keyword">float</span> srcArrayA[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> srcArrayB[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> dstArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<font></font>
        {<font></font>
            srcArrayA[i] = i;<font></font>
            srcArrayB[i] = i;<font></font>
        }<font></font>
        Pointer srcA = Pointer.to(srcArrayA);<font></font>
        Pointer srcB = Pointer.to(srcArrayB);<font></font>
        Pointer dst = Pointer.to(dstArray);<font></font>
<font></font>
<font></font>
        <span class="hljs-comment">// The platform, device type and device number</span>
        <span class="hljs-comment">// that will be used</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> platformIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deviceType = CL.CL_DEVICE_TYPE_ALL;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> deviceIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Enable exceptions and subsequently omit error checks in this sample</span>
        CL.setExceptionsEnabled(<span class="hljs-keyword">true</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the number of platforms</span>
        <span class="hljs-keyword">int</span> numPlatformsArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetPlatformIDs(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numPlatformsArray);
        <span class="hljs-keyword">int</span> numPlatforms = numPlatformsArray[<span class="hljs-number">0</span>];<font></font>
<font></font>
        <span class="hljs-comment">// Obtain a platform ID</span>
        cl_platform_id platforms[] = <span class="hljs-keyword">new</span> cl_platform_id[numPlatforms];<font></font>
        CL.clGetPlatformIDs(platforms.length, platforms, <span class="hljs-keyword">null</span>);<font></font>
        cl_platform_id platform = platforms[platformIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Initialize the context properties</span>
        cl_context_properties contextProperties = <span class="hljs-keyword">new</span> cl_context_properties();<font></font>
        contextProperties.addProperty(CL.CL_CONTEXT_PLATFORM, platform);<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain the number of devices for the platform</span>
        <span class="hljs-keyword">int</span> numDevicesArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numDevicesArray);
        <span class="hljs-keyword">int</span> numDevices = numDevicesArray[<span class="hljs-number">0</span>];<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain a device ID </span>
        cl_device_id devices[] = <span class="hljs-keyword">new</span> cl_device_id[numDevices];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, numDevices, devices, <span class="hljs-keyword">null</span>);<font></font>
        cl_device_id device = devices[deviceIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Create a context for the selected device</span><font></font>
        cl_context context = CL.clCreateContext(<font></font>
            contextProperties, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> cl_device_id[]{device}, 
            <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create a command-queue for the selected device</span><font></font>
        cl_command_queue commandQueue = <font></font>
            CL.clCreateCommandQueue(context, device, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Allocate the memory objects for the input and output data</span>
        cl_mem memObjects[] = <span class="hljs-keyword">new</span> cl_mem[<span class="hljs-number">3</span>];<font></font>
        memObjects[<span class="hljs-number">0</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcA, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">1</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcB, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">2</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_WRITE,<font></font>
            Sizeof.cl_float * n, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the program from the source code</span><font></font>
        cl_program program = CL.clCreateProgramWithSource(context,<font></font>
            <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> String[]{ programSource }, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Build the program</span>
        CL.clBuildProgram(program, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the kernel</span>
        cl_kernel kernel = CL.clCreateKernel(program, <span class="hljs-string">"sampleKernel"</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Set the arguments for the kernel</span>
        CL.clSetKernelArg(kernel, <span class="hljs-number">0</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">0</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">1</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">1</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">2</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">2</span>]));<font></font>
        <font></font>
        <span class="hljs-comment">// Set the work-item dimensions</span>
        <span class="hljs-keyword">long</span> global_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{n};
        <span class="hljs-keyword">long</span> local_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{<span class="hljs-number">1</span>};<font></font>
        <font></font>
        <span class="hljs-comment">// Execute the kernel</span>
        CL.clEnqueueNDRangeKernel(commandQueue, kernel, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>,<font></font>
            global_work_size, local_work_size, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Read the output data</span>
        CL.clEnqueueReadBuffer(commandQueue, memObjects[<span class="hljs-number">2</span>], CL.CL_TRUE, <span class="hljs-number">0</span>,<font></font>
            n * Sizeof.cl_float, dst, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Release kernel, program, and memory objects</span>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">0</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">1</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">2</span>]);<font></font>
        CL.clReleaseKernel(kernel);<font></font>
        CL.clReleaseProgram(program);<font></font>
        CL.clReleaseCommandQueue(commandQueue);<font></font>
        CL.clReleaseContext(context);<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getString</span><span class="hljs-params">(cl_device_id device, <span class="hljs-keyword">int</span> paramName)</span> </span>{
        <span class="hljs-comment">// Obtain the length of the string that will be queried</span>
        <span class="hljs-keyword">long</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceInfo(device, paramName, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, size);<font></font>
<font></font>
        <span class="hljs-comment">// Create a buffer of the appropriate size and fill it with the info</span>
        <span class="hljs-keyword">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)size[<span class="hljs-number">0</span>]];<font></font>
        CL.clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Create a string from the buffer (excluding the trailing \0 byte)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, buffer.length-<span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code is not like Java code, but it is. I will explain the code further; don't spend a lot of time on it now, because I will briefly discuss complex solutions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code will be documented, but let's do a little walkthrough. As you can see, the code is very similar to the code in C. This is normal because JOCL is just OpenCL. In the beginning, here is some code in the line, and this code is the most important part: It is compiled using OpenCL and then sent to the video card, where it is executed. This code is called Kernel. Do not confuse this term with OC Kernel; This is the device code. This code is written in a subset of C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After kernel comes Java code to install and configure the device, split the data, and create the appropriate memory buffers for the resulting data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To summarize: here is the ‚Äúhost code‚Äù, which is usually a language binding (in our case, in Java), and the ‚Äúdevice code‚Äù. You always highlight what will work on the host and what should work on the device, because the host controls the device. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The preceding code should show the GPU equivalent to "Hello World!" As you can see, most of it is huge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's not forget about SIMD features. If your device supports SIMD extension, you can make arithmetic code faster. For an example, let's take a look at kernel matrix multiplication code. This code is in a simple Java line in the application.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dim,
                  __global <span class="hljs-keyword">float</span> *A,
                  __global <span class="hljs-keyword">float</span> *B,
                  __global <span class="hljs-keyword">float</span> *C)</span></span>{<font></font>
<font></font>
    <span class="hljs-keyword">int</span> iCol = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> iRow = get_global_id(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">float</span> result = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; dim; ++i)<font></font>
    {<font></font>
          result +=<font></font>
          A[iRow*dim + i]*B[i*dim + iCol];<font></font>
    }<font></font>
    C[iRow*dim + iCol] = result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technically, this code will work on pieces of data that were installed for you by the OpenCL framework, with the instructions that you called in the preparatory part. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If your video card supports SIMD instructions and can process a vector of four floating-point numbers, small optimizations can turn the previous code into the following:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VECTOR_SIZE 4    </span>
<span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic_vector4</span><span class="hljs-params">(
    <span class="hljs-keyword">size_t</span> dim, <span class="hljs-comment">// dimension is in single floats</span>
    <span class="hljs-keyword">const</span> float4 *A,
    <span class="hljs-keyword">const</span> float4 *B,
    float4 *C)</span>
</span>{
    <span class="hljs-keyword">size_t</span> globalIdx = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">size_t</span> globalIdy = get_global_id(<span class="hljs-number">1</span>);<font></font>
    float4 resultVec = (float4){ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
    <span class="hljs-keyword">size_t</span> dimVec = dim / <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dimVec; ++i) {<font></font>
        float4 Avector = A[dimVec * globalIdy + i];<font></font>
        float4 Bvector[<span class="hljs-number">4</span>];<font></font>
        Bvector[<span class="hljs-number">0</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">0</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">1</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">2</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">3</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>) + globalIdx];<font></font>
        resultVec += Avector[<span class="hljs-number">0</span>] * Bvector[<span class="hljs-number">0</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">1</span>] * Bvector[<span class="hljs-number">1</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">2</span>] * Bvector[<span class="hljs-number">2</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">3</span>] * Bvector[<span class="hljs-number">3</span>];<font></font>
    }<font></font>
<font></font>
    C[dimVec * globalIdy + globalIdx] = resultVec;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this code you can double the performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">You have just opened the GPU for the Java world! </font><font style="vertical-align: inherit;">But as a Java developer, do you really want to do all this dirty work, with C code, and working with such low-level details? </font><font style="vertical-align: inherit;">I do not want. </font><font style="vertical-align: inherit;">But now that you have some knowledge of how the GPU is used, let's look at another solution that is different from the JOCL code that I just presented.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA and Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA is Nvidia's solution to this programming issue. </font><font style="vertical-align: inherit;">CUDA provides many more ready-to-use libraries for standard GPU operations, such as matrices, histograms, and even deep neural networks. </font><font style="vertical-align: inherit;">A list of libraries has already appeared with a bunch of ready-made solutions. </font><font style="vertical-align: inherit;">This is all from the JCuda project:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCublas: everything for matrices</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCufft: Fast Fourier Transform </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCurand: Everything for Random Numbers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusparse: rare matrices</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusolver: factorization of numbers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNvgraph: everything for graphs </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudpp: CUDA library of primitive parallel data and some sorting algorithms</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNpp: GPU image processing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudnn: deep neural network library</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am considering using JCurand, which generates random numbers. </font><font style="vertical-align: inherit;">You can use this from Java code without another special Kernel language. </font><font style="vertical-align: inherit;">For example:</font></font><br>
<br>
<pre><code class="java hljs">...
<span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>;<font></font>
curandGenerator generator = <span class="hljs-keyword">new</span> curandGenerator();
<span class="hljs-keyword">float</span> hostData[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<font></font>
Pointer deviceData = <span class="hljs-keyword">new</span> Pointer();<font></font>
cudaMalloc(deviceData, n * Sizeof.FLOAT);<font></font>
curandCreateGenerator(generator, CURAND_RNG_PSEUDO_DEFAULT); <font></font>
curandSetPseudoRandomGeneratorSeed(generator, <span class="hljs-number">1234</span>);<font></font>
curandGenerateUniform(generator, deviceData, n);<font></font>
cudaMemcpy(Pointer.to(hostData), deviceData, <font></font>
        n * Sizeof.FLOAT, cudaMemcpyDeviceToHost);<font></font>
System.out.println(Arrays.toString(hostData));<font></font>
curandDestroyGenerator(generator);<font></font>
cudaFree(deviceData);<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It uses a GPU to create a large number of random numbers of very high quality, based on very strong math. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JCuda, you can also write generic CUDA code and call it from Java by calling some JAR file in your classpath. </font><font style="vertical-align: inherit;">See the JCuda documentation for great examples.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stay above low level code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It all looks great, but there is too much code, too much installation, too many different languages ‚Äã‚Äãto run it all. Is there a way to use the GPU at least partially? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What if you don‚Äôt want to think about all this OpenCL, CUDA, and other unnecessary things? What if you only want to program in Java and not think about everything that is not obvious? Aparapi project can help. Aparapi is based on a "parallel API." I think of it as some part of Hibernate for GPU programming that uses OpenCL under the hood. Let's take a look at an example of vector addition.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] _args)</span> </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">512</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    <span class="hljs-comment">/* fill the arrays with random values */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<font></font>
        a[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
        b[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    Kernel kernel = <span class="hljs-keyword">new</span> Kernel(){
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
I           <span class="hljs-keyword">int</span> gid = getGlobalId();<font></font>
            sum[gid] = a[gid] + b[gid];<font></font>
        }<font></font>
    };<font></font>
<font></font>
    kernel.execute(Range.create(size));<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
        System.out.printf(<span class="hljs-string">"%6.2f + %6.2f = %8.2f\n"</span>, a[i], b[i], sum[i])<font></font>
    }<font></font>
    kernel.dispose();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is pure Java code (taken from the Aparapi documentation), also here and there, you can see a certain term Kernel and getGlobalId. </font><font style="vertical-align: inherit;">You still need to understand how to program the GPU, but you can use the GPGPU approach in a more Java-like manner. </font><font style="vertical-align: inherit;">Moreover, Aparapi provides an easy way to use OpenGL context to the OpenCL layer - thereby allowing the data to remain completely on the graphics card - and thereby avoid memory latency issues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you need to do a lot of independent calculations, look at Aparapi. </font><font style="vertical-align: inherit;">There are many examples of how to use parallel computing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, there is some project called TornadoVM - it automatically transfers the appropriate calculations from the CPU to the GPU, thus providing mass optimization out of the box.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many applications where GPUs can bring some advantages, but you could say that there are still some obstacles. </font><font style="vertical-align: inherit;">However, Java and the GPU can do great things together. </font><font style="vertical-align: inherit;">In this article, I only touched on this extensive topic. </font><font style="vertical-align: inherit;">I intended to show various high and low level options for accessing the GPU from Java. </font><font style="vertical-align: inherit;">Exploring this area will provide tremendous performance benefits, especially for complex tasks that require multiple calculations that can be performed in parallel. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Link</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en500086/index.html">Writing a javascript calculator</a></li>
<li><a href="../en500098/index.html">JavaScript Nehronical</a></li>
<li><a href="../en500100/index.html">TV first, responsive typography or how not to forget about all sizes of devices</a></li>
<li><a href="../en500102/index.html">Roslyn & EF Core: building a DbContext in runtime</a></li>
<li><a href="../en500104/index.html">Business process modeling, automatic diagram-text translation and CH-1 notation</a></li>
<li><a href="../en500108/index.html">(Spring) State in the (Spring) Shell: not production single</a></li>
<li><a href="../en500110/index.html">A word about the delivery of goods</a></li>
<li><a href="../en500114/index.html">Job search in Germany as a product manager and more. Part 2/5. The structure of the labor market. ATS. Job boards</a></li>
<li><a href="../en500116/index.html">The work of a distributed team in conditions of self-isolation: as we almost did not notice the difference</a></li>
<li><a href="../en500118/index.html">Five steps to making the inevitable, or a cross-selling referral system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>