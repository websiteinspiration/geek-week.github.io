<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗳️ 🧖🏼 ⚒️ Oxido. Verificador de préstamos a través de iteradores 👩🏻‍🎓 💅🏾 👃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 
 
 He estado estudiando durante aproximadamente un año y, en mi tiempo libre, escribo en el rast. Me gusta cómo sus autores resolvieron el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Oxido. Verificador de préstamos a través de iteradores</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499108/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He estado estudiando durante aproximadamente un año y, en mi tiempo libre, escribo en el rast. </font><font style="vertical-align: inherit;">Me gusta cómo sus autores resolvieron el problema de la gestión de la memoria y prescindieron del recolector de basura, a través del concepto de préstamo. </font><font style="vertical-align: inherit;">En este artículo abordaré esta idea a través de iteradores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Últimamente, scala es mi idioma principal, por lo que habrá comparaciones con él, pero no hay muchos y todo es intuitivo, sin magia :) El </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
artículo está diseñado para aquellos que escucharon algo sobre el óxido, pero no entraron en detalles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lu/ju/o1/lujuo1lkziqqcu6fpfxiuuuaquy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fotos tomadas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde aquí</font></font></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefacio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los idiomas jvm, se acostumbra ocultar el trabajo con enlaces, es decir, casi siempre trabajamos con tipos de datos de referencia, por lo que decidimos ocultar el ampersand (&amp;). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el rasta hay enlaces explícitos, por ejemplo, al número entero: `&amp; i32`, el enlace se puede desreferenciar a través de` * `, también puede haber un enlace al enlace y luego deberá desreferenciarse dos veces **.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterador</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al escribir código, muy a menudo necesita filtrar la colección por una condición (predicado). </font><font style="vertical-align: inherit;">En la roca, tomar elementos parecidos se vería así:</font></font><br>
<br>
<pre><code class="scala hljs">    <span class="hljs-keyword">val</span> vec = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
    <span class="hljs-keyword">val</span> result = vec.filter(e =&gt; e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos los tipos:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-keyword">private</span>[scala] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filterImpl</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>, isFlipped: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Repr</span> = {
    <span class="hljs-keyword">val</span> b = newBuilder
    <span class="hljs-keyword">for</span> (x &lt;- <span class="hljs-keyword">this</span>)
      <span class="hljs-keyword">if</span> (p(x) != isFlipped) b += x<font></font>
<font></font>
    b.result<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin entrar en los detalles de `newBuilder`, está claro que se está creando una nueva colección, iteramos sobre la anterior y si el predicado devuelve verdadero, entonces agregue un elemento. </font><font style="vertical-align: inherit;">A pesar de que la colección es nueva, sus elementos son en realidad enlaces a elementos de la primera colección, y si, de repente, estos elementos son mutables, entonces cambiarlos será común a ambas colecciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora intentemos hacer lo mismo en el rast. </font><font style="vertical-align: inherit;">Daré inmediatamente un ejemplo de trabajo y luego consideraré las diferencias.</font></font><br>
<br>
<pre><code class="rust hljs">    <span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">i32</span>&gt; = v.iter().filter(|e| **e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, wow que? </font><font style="vertical-align: inherit;">¿Doble referencia de puntero? </font><font style="vertical-align: inherit;">¿Solo para filtrar el vector? </font><font style="vertical-align: inherit;">Difícil :( Pero hay razones para esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Señalemos cómo este código difiere de la roca:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtener explícitamente el iterador en el vector (`iter ()`) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la función predicado, por alguna razón, desreferenciamos el puntero dos veces </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> llame a `collect ()` </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> también dio como resultado un vector de tipos de referencia Vec &lt;&amp; i32&gt;, y no ints ordinarios </font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificador de préstamos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué llamar explícitamente a `iter ()` en la colección? </font><font style="vertical-align: inherit;">Está claro para cualquier rockman que si llamas a `.filter (...)` entonces necesitas iterar sobre la colección. </font><font style="vertical-align: inherit;">¿Por qué en un rast escribe explícitamente lo que se puede hacer implícitamente? </font><font style="vertical-align: inherit;">¡Porque hay </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tres</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iteradores diferentes! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/vw/-m/6tvw-mzsdc6ce1caxkzl-custrw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para averiguar por qué tres? </font><font style="vertical-align: inherit;">es necesario tocar el </font><b><font style="vertical-align: inherit;">verificador de </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préstamo </font></font></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(préstamo, préstamo)</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 'a. </font><font style="vertical-align: inherit;">La razón por la cual el rast funciona sin un GC y sin asignación / desasignación de memoria explícita. </font><font style="vertical-align: inherit;">
¿Por qué es necesario?</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar situaciones en las que varios punteros apuntan a la misma área de memoria, lo que le permite cambiarla. </font><font style="vertical-align: inherit;">Esa es una condición de carrera.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para no desasignar la misma memoria varias veces.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo se logra esto? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido al concepto de propiedad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, el concepto de propiedad es simple: solo uno puede poseer algo (incluso la intuición). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El dueño puede cambiar, pero siempre está solo. Cuando escribimos `let x: i32 = 25`, esto significa que se asignó memoria para un int de 32 bits y que posee una cierta` x`. La idea de propiedad solo existe en la mente del compilador, en el verificador de préstamos. Cuando el propietario, en este caso, `x` abandona el alcance (queda fuera de alcance), se borrará la memoria de la que es propietario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un código que el verificador de préstamos no perderá:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; X {
    <span class="hljs-keyword">let</span> first = X; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second = first; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> third = first; <span class="hljs-comment">//   ,   first   </span>
<span class="hljs-comment">//    value used here after move</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
`struct X` es algo así como` case class X ()` - una estructura sin bordes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este comportamiento es súper contradictorio, creo, para todos. </font><font style="vertical-align: inherit;">No conozco otros idiomas en los que sería imposible "usar" la misma "variable" dos veces. </font><font style="vertical-align: inherit;">Es importante sentir este momento. </font><font style="vertical-align: inherit;">primero no es en absoluto una referencia a X, es su </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dueño</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cambiando el propietario, matamos al anterior, el verificador de préstamos no permitirá su uso.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué necesitabas crear tu propia estructura, por qué no usar un entero regular?</font></font></b>
                        <div class="spoiler_text">    —       (`struct X`),  , ,   integer.   ,     ,     :<br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> first = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> second = first; 
    <span class="hljs-keyword">let</span> third = first; <font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br>
  ,   borrow checker,            ,   .     Copy,      .      `i32` second     ,   (   ), -  third   .   X     Copy,      .<br>
<br>
     .   ,              ,      «»            .        Clone,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">copy</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">clone</a>.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De vuelta a los iteradores. </font><font style="vertical-align: inherit;">El concepto de "captura" entre ellos es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Él "traga" la colección, dando posesión de sus elementos. </font><font style="vertical-align: inherit;">En el código, esta idea se reflejará así:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">let</span> coll_1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> coll_2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = coll_1.into_iter().collect();
<span class="hljs-comment">//coll_1 doesn't exists anymore</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al llamar a `into_iter ()` en coll_1 lo "convertimos" en un iterador, absorbimos todos sus elementos, como en el ejemplo anterior, `second` absorbió` first`. </font><font style="vertical-align: inherit;">Después de eso, cualquier llamada a coll_1 será castigada por el verificador de préstamos durante la compilación. </font><font style="vertical-align: inherit;">Luego recolectamos estos elementos con la función `collect`, creando un nuevo vector. </font><font style="vertical-align: inherit;">La función `collect` es necesaria para recopilar una colección de un iterador, para esto debe especificar explícitamente el tipo de lo que queremos recopilar. </font><font style="vertical-align: inherit;">Por lo tanto, coll_2 indica claramente el tipo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acuerdo, en general, lo descrito anteriormente es suficiente para un lenguaje de programación, pero no será muy eficiente copiar / clonar estructuras de datos cada vez que queramos transferirlas, y también debe ser capaz de cambiar algo. </font><font style="vertical-align: inherit;">Así que vamos a los punteros.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punteros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El propietario, como hemos descubierto, puede ser solo uno. </font><font style="vertical-align: inherit;">Pero puedes tener cualquier cantidad de enlaces.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; Y {
    <span class="hljs-keyword">let</span> first = Y; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;Y = &amp;first; <span class="hljs-comment">//   ,     </span>
    <span class="hljs-keyword">let</span> third = &amp;first; <span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, second);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, third);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código ya es válido, porque el propietario sigue siendo uno. Toda la lógica de propiedad se verifica solo en la etapa de compilación, sin afectar la asignación / movimiento de memoria. ¡Además, puede ver que el tipo de segundo ha cambiado a `&amp; Y`! Es decir, la semántica de la propiedad y los enlaces se reflejan en los tipos, lo que le permite verificar durante la compilación, por ejemplo, la ausencia de una condición de carrera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo puedo proteger contra la condición de carrera en tiempo de compilación? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al establecer un límite en el número de enlaces mutables! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un enlace mutable en un momento puede ser uno y solo uno (sin inmutable). Es decir, uno / varios inmutables o uno mutable. El código se ve así:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-comment">// </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span> {<font></font>
    x: <span class="hljs-built_in">i32</span>,<font></font>
} <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; X {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first = X { x: <span class="hljs-number">20</span> }; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//    .        `second`        - .</span>
<span class="hljs-comment">//    second.x = 33;  //    ,             ,    </span>
    third.x = <span class="hljs-number">33</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Repasemos los cambios en el ejemplo anterior relativo. Primero, agregamos un campo a la estructura para que hubiera algo que cambiar, porque necesitamos mutabilidad. En segundo lugar, `mut` apareció en la declaración de la variable` let mut first = ...`, este es un marcador para el compilador sobre la mutabilidad, como `val` &amp;` var` en la roca. En tercer lugar, todos los enlaces han cambiado su tipo de `&amp; X` a` &amp; mut X` (parece, por supuesto, monstruoso. Y esto es sin tiempo de vida ...), ahora podemos cambiar el valor almacenado por el enlace.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero dije que no podemos crear varios enlaces mutables, dicen que el comprobador de préstamos no dará esto, ¡pero yo mismo creé dos! Sí, pero las comprobaciones allí son muy complicadas, por lo que a veces no es obvio por qué el compilador jura. Él está haciendo todo lo posible para que su programa se compile y si no hay absolutamente ninguna opción para cumplir con las reglas, entonces es un error, y tal vez no el que está esperando, sino el que viola su último intento, el más desesperado y no obvio para un principiante: ) Por ejemplo, se le informa que la estructura no implementa el rasgo Copiar, aunque no llamó a ninguna copia en ninguna parte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, se permite la existencia de dos enlaces mutables al mismo tiempo porque usamos solo uno, es decir, el segundo se puede tirar y nada cambiará. También `second` puede usarse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crear un 'tercero' y luego todo estará bien. </font><font style="vertical-align: inherit;">Pero, si descomenta `second.x = 33;`, resulta que existen dos enlaces mutables simultáneamente y no puede salir de aquí de todos modos: error de tiempo de compilación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteradores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos tres tipos de transmisión:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absorción, préstamo, mudanza.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace mutable</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada tipo necesita su propio iterador.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> absorbe objetos de la colección original.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ejecuta en enlaces de objetos</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IterMut se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ejecuta en referencias de objetos mutables</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surge la pregunta: cuándo usar cuál. </font><font style="vertical-align: inherit;">No hay una bala de plata: necesitas práctica, leer el código de otra persona, artículos. </font><font style="vertical-align: inherit;">Daré un ejemplo que demuestre la idea. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que hay una escuela, hay una clase en ella y estudiantes en la clase.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(PartialEq, Eq)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span></span> {<font></font>
    Male,<font></font>
    Female<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scholar</span></span> {<font></font>
    name: <span class="hljs-built_in">String</span>,<font></font>
    age: <span class="hljs-built_in">i32</span>,<font></font>
    sex: Sex<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = ...;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos el vector de escolares al consultar la base de datos, por ejemplo. </font><font style="vertical-align: inherit;">Luego, necesitaba contar la cantidad de chicas en la clase. </font><font style="vertical-align: inherit;">Si "tragamos" el vector a través de `into_iter ()`, luego de contar ya no podemos usar esta colección para contar a los niños:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bad_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars<font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Female)<font></font>
        .count();<font></font>
<font></font>
    <span class="hljs-keyword">let</span> boys_c = scholars <font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Male)<font></font>
        .count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habrá un error "valor utilizado aquí después del movimiento" en la línea para contar niños. </font><font style="vertical-align: inherit;">También es obvio que el iterador mutable no nos sirve de nada. </font><font style="vertical-align: inherit;">Es por eso que es solo `iter ()` y funciona con un doble enlace:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars.iter().filter(|s| (**s).sex == Sex::Female).count();
    <span class="hljs-keyword">let</span> boys_c = scholars.iter().filter(|s| (**s).sex == Sex::Male).count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, para aumentar el número de reclutas potenciales en el país, ya se requiere un iterador mutable:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">very_good_idea</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desarrollando la idea, podemos hacer soldados con los "muchachos" y demostrar el iterador "absorbente":</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">impl</span> Scholar {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_soldier</span></span>(<span class="hljs-keyword">self</span>) -&gt; Soldier {<font></font>
        Soldier { forgotten_name: <span class="hljs-keyword">self</span>.name, number: some_random_number_generator() }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Soldier</span></span> {<font></font>
    forgotten_name: <span class="hljs-built_in">String</span>,<font></font>
    number: <span class="hljs-built_in">i32</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_bright_future</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
    <span class="hljs-keyword">let</span> soldiers: <span class="hljs-built_in">Vec</span>&lt;Soldier&gt; = scholars.into_iter().map(|s| s.to_soldier()).collect();
    <span class="hljs-comment">//   scholars,    </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta maravillosa nota, tal vez eso es todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La última pregunta sigue siendo: ¿de dónde vino la doble desreferenciación de los enlaces en `filter`. </font><font style="vertical-align: inherit;">El hecho es que un predicado es una función que toma una referencia a un argumento (para no capturarlo):</font></font><br>
<br>
<pre><code class="rust hljs">
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt; <span class="hljs-keyword">where</span>
        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>, P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
el predicado es FnMut (más o menos una función), que toma una referencia a su elemento (self) y devuelve bool. </font><font style="vertical-align: inherit;">Como ya teníamos un enlace desde el iterador `.iter ()`, el segundo apareció en el filtro. </font><font style="vertical-align: inherit;">Cuando es absorbido por un iterador (`into_iter`), la doble desreferenciación del enlace se convirtió en una normal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuación</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No tengo mucha experiencia en la redacción de artículos, por lo que me complacerá criticar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si está interesado, puedo continuar. </font><font style="vertical-align: inherit;">Opciones para temas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cómo y cuándo ocurre la desasignación de memoria </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enlace de por vida </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programación asincrónica </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escribiendo un pequeño servicio web, incluso puedes ofrecer API </font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces</font></font></h3><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libro de óxido</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido al concepto de propiedad, la implementación de cosas básicas como, por ejemplo, una lista vinculada ya no es trivial. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> varias formas de implementarlas.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499092/index.html">Modelo de referencia BIAN. ¿Qué novedades y útiles para la arquitectura corporativa del banco ofrece?</a></li>
<li><a href="../es499096/index.html">Lógica difusa en bellas imágenes. Superficies de respuesta para diferentes funciones de membresía</a></li>
<li><a href="../es499102/index.html">Kubernetes, Microservicios, CI / CD y Dockers para Retrogrades: consejos de aprendizaje</a></li>
<li><a href="../es499104/index.html">IoT a tus heridas: por qué el Internet de las cosas es más bienvenido en la era del coronavirus</a></li>
<li><a href="../es499106/index.html">HTML avanzado</a></li>
<li><a href="../es499110/index.html">El Gran Hermano está tratando de servir al bien. Cómo participan los recolectores de datos y las compañías de programas en la lucha contra el coronavirus</a></li>
<li><a href="../es499112/index.html">Sistema avanzado de autorización de recursos en Laravel. Parte 3. Atributos de lectura / escritura, modelos propios</a></li>
<li><a href="../es499114/index.html">Exportación del plan de numeración de la Agencia Federal de Comunicaciones a una base de datos relacional</a></li>
<li><a href="../es499118/index.html">Cómo crear un video viral</a></li>
<li><a href="../es499120/index.html">[Marcador] CSS: uso de sangría y sangría</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>