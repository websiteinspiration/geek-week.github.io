<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍸 😜 🕴🏻 ESP32の組み込みデバイス用のゲームのプログラミング：ドライブ、バッテリー、サウンド 👩🏻‍⚕️ 👾 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="開始：アセンブリシステム、入力、表示。
 
 パート4：ドライブ
 Odroid GoにはmicroSDカードスロットがあり、リソース（スプライト、サウンドファイル、フォント）をダウンロードしたり、ゲームの状態を保存したりできます。
 
 カードリーダーはSPIを介して接続されますが、IDFを使用す...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ESP32の組み込みデバイス用のゲームのプログラミング：ドライブ、バッテリー、サウンド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="画像"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始：アセンブリシステム、入力、表示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート4：ドライブ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid GoにはmicroSDカードスロットがあり、リソース（スプライト、サウンドファイル、フォント）をダウンロードしたり、ゲームの状態を保存したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カードリーダーはSPIを介して接続されますが、IDFを使用すると、SPI呼び出しを抽象化し</font><font style="vertical-align: inherit;">、</font><strong><font style="vertical-align: inherit;">fopen</font></strong><font style="vertical-align: inherit;">、</font><strong><font style="vertical-align: inherit;">fread</font></strong><font style="vertical-align: inherit;">、</font><strong><font style="vertical-align: inherit;">fwrite</font></strong><font style="vertical-align: inherit;">などの</font><font style="vertical-align: inherit;">標準の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用してSDカードと簡単に対話でき</font><font style="vertical-align: inherit;">ます。これはすべて</font><strong><font style="vertical-align: inherit;">FatFs</font></strong><font style="vertical-align: inherit;">ライブラリに基づいている</font><font style="vertical-align: inherit;">ため、SDカードは標準のFAT形式でフォーマットする必要があります。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LCDと同じSPIバスに接続されていますが、異なるチップ選択ラインを使用しています。</font><font style="vertical-align: inherit;">SDカードの読み取りまたは書き込みが必要な場合（これはそれほど頻繁には発生しません）、SPIドライバーはCS信号をディスプレイからSDカードリーダーに切り替えてから、操作を実行します。</font><font style="vertical-align: inherit;">つまり、データをディスプレイに送信している間は、SDカードで操作を実行できません。その逆も同様です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、すべてを1つのスレッドで実行し、SPIを介してディスプレイへのブロッキング転送を使用しているため、SDカードとLCDディスプレイで同時にトランザクションを実行することはできません。</font><font style="vertical-align: inherit;">いずれの場合も、起動時にすべてのリソースをロードする可能性が高くなります。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDFの変更</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスプレイの初期化後にSDカードインターフェイスを初期化しようとすると、Odroid Goを起動できないという問題が発生します。</font><font style="vertical-align: inherit;">ESP-IDF v4.0は、SDカードと併用した場合、SPIバスへの共有アクセスをサポートしません。</font><font style="vertical-align: inherit;">最近、開発者がこの機能を追加しましたが、まだ安定版リリースではないため、IDFに小さな変更を加えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf / components / driver / sdspi_host.cをコメント化し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この変更を行った後も初期化中にエラーが発生しますが、エラーコードが上に伝播しないため、ESP32が再起動することはありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのESP32ピンがMicroSDリーダーに接続されているかをIDFに通知して、実際にリーダーと通信する基本的なSPIドライバーを正しく構成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なメモ</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><strong><font style="vertical-align: inherit;">図</font></strong><font style="vertical-align: inherit;">でも</font><font style="vertical-align: inherit;">使用され</font><font style="vertical-align: inherit;">ていますが、ESP32の実際の連絡先番号を確認することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化はLCDの初期化と似ていますが、一般的なSPI構成構造の代わりに</font><font style="vertical-align: inherit;">、SPIバス経由で接続されたSDカード用に設計された</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用します</font><font style="vertical-align: inherit;">。対応する連絡先番号とカードマウントプロパティをFatFSシステムで構成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDFのドキュメントでは、</font><strong><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></strong><font style="vertical-align: inherit;">関数の使用は推奨されていません</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成したプログラムのコードで。これは、多くの操作を実行するラッパー関数ですが、これまでのところ非常に正常に機能しており、おそらく何も変更されません。</font><font style="vertical-align: inherit;">この関数</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「/ sdcard」</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーターは</font><font style="vertical-align: inherit;">、SDカードの仮想マウントポイントを設定します。これは、ファイルを操作するときにプレフィックスとして使用します。 SDカードに「test.txt」という名前のファイルがある場合、そのファイルへのリンクに使用するパスは「/sdcard/test.txt」になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDカードのインターフェースの初期化後、ファイルとの対話は簡単です</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数への標準の呼び出しを使用するだけ</font><font style="vertical-align: inherit;">でよく、これは非常に便利です。</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ひどい）で、完全に黒（ピクセル無効）と完全に白（ピクセル有効）の2色のみを使用する64x64スプライト</font><font style="vertical-align: inherit;">
を作成しまし</font><font style="vertical-align: inherit;">た。 Asepriteには、RGB565カラーを保存したり、生のビットマップとしてエクスポートしたり（つまり、圧縮ヘッダーや画像ヘッダーなしで）オプションがないため、スプライトを一時的なPNG形式にエクスポートしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">、データをPPMファイル</font><strong><font style="vertical-align: inherit;">に</font></strong><font style="vertical-align: inherit;">変換しました。これにより、画像が単純なヘッダーを持つ未圧縮の生データ</font><strong><font style="vertical-align: inherit;">に</font></strong><font style="vertical-align: inherit;">変換されました。次に、画像を16進エディターで開き、ヘッダーを削除して24ビットの色を16ビットに変換し、すべての出現</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">箇所</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">0x000000</font></strong><font style="vertical-align: inherit;">から</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、すべての出現</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">箇所</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">0xFFFFFF</font></strong><font style="vertical-align: inherit;">から</font><strong><font style="vertical-align: inherit;">0xFFFF</font></strong><font style="vertical-align: inherit;">に削除しました。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バイトオーダーを</font><font style="vertical-align: inherit;">変更しても</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は変更されない</font><font style="vertical-align: inherit;">ため、ここでのバイトオーダーは問題ではありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生ファイルは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、</font><font style="vertical-align: inherit;">生のバイトを含む</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルを開き、</font><font style="vertical-align: inherit;">それをバッファーに読み込みます。</font><font style="vertical-align: inherit;">将来的には、スプライトリソースを別の方法でロードする予定ですが、デモではこれで十分です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スプライトを描画するには、その内容を繰り返し走査します。</font><font style="vertical-align: inherit;">ピクセルが白の場合、ボタンで選択した色で描画します。</font><font style="vertical-align: inherit;">黒の場合は背景とみなして描画しません。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スマートフォンのカメラで色が大きく歪む。</font><font style="vertical-align: inherit;">彼女を振ってごめんなさい。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像の記録をテストするには、キーを画面上のどこかに移動し、色を変更してから、フレームバッファーをSDカードに書き込んで、コンピューターで表示できるようにします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メニューキーを押すと、フレームバッファの内容が</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">というファイルに保存されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは生のフレームバッファになるため、ピクセルはバイト順が逆になったRGB565形式のままです。</font><font style="vertical-align: inherit;">再びImageMagickを使用してこの形式をPNGに変換し、コンピューターで表示できます。</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、BMP / PNG形式への読み取り/書き込みを実装して、ImageMagickでこの大騒ぎをすべて取り除くことができますが、これは単なるデモコードです。</font><font style="vertical-align: inherit;">これまでのところ、スプライトの保存に使用するファイル形式を決定していません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほら！</font><font style="vertical-align: inherit;">Odroid Goフレームバッファーがデスクトップコンピューターに表示されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go Schematic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDFドキュメント：SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート5：バッテリー</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Goにはリチウムイオンバッテリーが搭載されているので、外出先でもプレイできるゲームを作成できます。</font><font style="vertical-align: inherit;">これは、子供として最初のゲームボーイをプレイした人にとって魅力的なアイデアです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Odroid Goのバッテリーレベルをリクエストする方法が必要です。</font><font style="vertical-align: inherit;">バッテリーはESP32の接点に接続されているので、電圧を読み取って、残りの動作時間を概算できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキーム</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図は</font><font style="vertical-align: inherit;">、抵抗を介してグランドに引き下げられた後</font><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">VBAT</font></strong><font style="vertical-align: inherit;">電圧に</font><font style="vertical-align: inherit;">接続された</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示しています</font><font style="vertical-align: inherit;">。 2つの抵抗（</font><strong><font style="vertical-align: inherit;">R21</font></strong><font style="vertical-align: inherit;">と</font><strong><font style="vertical-align: inherit;">R23</font></strong><font style="vertical-align: inherit;">）は、ゲームパッドの十字で使用されるものと同様の分圧器を形成します。抵抗器は同じ抵抗を持ち、電圧は元の半分になります。</font><font style="vertical-align: inherit;">
分圧器により、</font><strong><font style="vertical-align: inherit;">IO36</font></strong><font style="vertical-align: inherit;">は</font><strong><font style="vertical-align: inherit;">VBATの</font></strong><font style="vertical-align: inherit;">半分に等しい電圧を読み取ります</font><font style="vertical-align: inherit;">。これはおそらく、ESP32のADC接点がリチウムイオンバッテリーの高電圧（最大充電時4.2 V）を読み取れないためです。つまり、真の電圧を得るには、ADC（ADC）から読み取った電圧を2倍にする必要があります。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の値を</font><strong><font style="vertical-align: inherit;">読み取ると</font></strong><font style="vertical-align: inherit;">、デジタル値が取得されますが、それが表すアナログ値は失われます。デジタル値をADCで物理的なアナログ電圧の形で解釈する方法が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDFを使用すると、基準電圧に基づいて電圧レベルを提供しようとするADCを較正できます。この基準電圧（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）はデフォルトで1100 mVですが、物理的特性により、各デバイスはわずかに異なります。 Odroid GoのESP32には、手動で定義されたVrefがあり、eFuseで「フラッシュ」されます。これをより正確なVrefとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手順は次のとおりです。最初に、ADCキャリブレーションを構成し、電圧を読み取る場合は、特定の数（たとえば、20）のサンプルを取得して平均読み取り値を計算します。次に、IDFを使用してこれらの読み取り値を電圧に変換します。平均の計算はノイズを除去し、より正確な測定値を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、電圧とバッテリー充電の間には線形の関係はありません。電荷が減少すると、電圧は低下し、増加すると上昇しますが、予測できない方法で発生します。つまり、電圧が約3.6 V未満の場合、バッテリーは放電されますが、電圧レベルをバッテリー充電のパーセンテージに正確に変換することは驚くほど困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロジェクトでは、これは特に重要ではありません。</font><font style="vertical-align: inherit;">おおよその概算を実装して、プレーヤーにデバイスをすばやく充電する必要があることを知らせることができますが、正確なパーセンテージを取得しようとして苦労することはありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスLED</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go画面のフロントパネルには、青色のLED（LED）があり、これをあらゆる目的に使用できます。デバイスの電源がオンになっていて機能していることを彼らに示すことができますが、この場合、暗闇でプレイすると、明るい青色のLEDがあなたの顔を照らします。したがって、バッテリーの残量が少ないことを示すために使用します（ただし、これには赤またはこはく色をお勧めします）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LEDを使用するには、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を出力として</font><font style="vertical-align: inherit;">設定し</font><font style="vertical-align: inherit;">、ハイまたはロー信号を適用してLEDをオン/オフする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2kΩの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抵抗</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><strong><font style="vertical-align: inherit;">電流制限抵抗</font></strong><font style="vertical-align: inherit;">）で十分だと思います。LEDを焼き付けたり、GPIOピンから過大な電流を供給したりしないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LEDの抵抗はやや低いため、3.3 Vが適用されている場合は、電流を変更してLEDを焼きます。</font><font style="vertical-align: inherit;">これを防ぐために、通常は抵抗がLEDと直列に接続されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、LEDの電流制限抵抗は通常2kΩよりはるかに小さいため、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抵抗</font><font style="vertical-align: inherit;">がこのような</font><font style="vertical-align: inherit;">抵抗で</font><font style="vertical-align: inherit;">ある</font><font style="vertical-align: inherit;">理由がわかりません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、必要に応じて切り替えることができるように、GPIO LEDを出力として設定します。</font><font style="vertical-align: inherit;">次に、クロスの場合と同様に、ビット幅12と最小の減衰でADCピンを構成します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ADCを特徴付けるための計算を実行して、後でデジタル測定値を物理的なストレスに変換できるようにします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッテリー読み取り</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADCの接触からADCの20個の未加工サンプルを取得し、それらを分割して平均値を取得します。上記のように、これは測定値のノイズを減らすのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、生の値を実際の電圧に変換します。上記の分圧器により、戻り値は2倍になります。読み取り値は実際のバッテリー電圧の半分になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この電圧をバッテリー充電のパーセンテージに変換するトリッキーな方法を考え出す代わりに、単純な電圧を返します。呼び出し側の関数に、電圧をどうするか（充電のパーセンテージに変換するか、単にそれを高い値または低い値として解釈するか）を決定させます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値はミリボルトで返されるため、呼び出し側の関数は適切な変換を実行する必要があります。</font><font style="vertical-align: inherit;">これにより、フロートのオーバーフローが防止されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED設定</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら2つのシンプルな機能でLEDを使用できます。</font><font style="vertical-align: inherit;">ライトをオンまたはオフにできます。</font><font style="vertical-align: inherit;">いつ呼び出すかは呼び出し側の関数に決定させます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定期的にバッテリー電圧を監視し、それに応じてLEDのステータスを切り替えるタスクを作成することもできますが、メインサイクルでバッテリー電圧を調べて、そこからバッテリー電圧を設定する方法を決定する方がよいでしょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモ</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインサイクルのバッテリーレベルを要求するだけで、電圧がしきい値を下回っている場合は、LEDをオンにして充電の必要性を示します。</font><font style="vertical-align: inherit;">調査した材料に基づいて、3600 mV（3.6 V）はリチウムイオンバッテリーの低充電の良い兆候であると言えますが、バッテリー自体は複雑です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go Schematic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDFドキュメント：ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッテリー特性</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート6：サウンド</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのOdroid Goハードウェアへの完全なインターフェースを取得するための最後のステップは、サウンドレイヤーを作成することです。これで終了すると、Odroidのプログラミングにあまり関係のない、より一般的なゲームのプログラミングに移行できます。周辺機器とのすべての相互作用は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を通じて実行されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サウンドプログラミングの経験が足りなかったため、IDFに関するドキュメントが不足していたため、プロジェクトで作業するときに、サウンドの実装に最も時間がかかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的には、サウンドを再生するためにそれほど多くのコードは必要ありませんでした。ほとんどの時間は、オーディオデータを目的のESP32に変換する方法と、ハードウェア構成と一致するようにESP32オーディオドライバーを構成する方法に費やされました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デジタルサウンドの基本</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デジタルサウンドは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">録音</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再生の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの部分で構成され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記録</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピューターでサウンドを録音するには、まずそれを連続（アナログ）信号の空間から離散（デジタル）信号の空間に変換する必要があります。</font><font style="vertical-align: inherit;">このタスクは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A / Dコンバーター（ADC）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して実行</font><strong><font style="vertical-align: inherit;">されます（ADC</font></strong><font style="vertical-align: inherit;">は、パート2で十字架を操作したときに説明しました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADCは</font><font style="vertical-align: inherit;">到来波の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプルを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け取り、</font><font style="vertical-align: inherit;">その値をデジタル化して、ファイルに保存できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演奏する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デジタルサウンドファイルは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digital-to-Analog Converter（DAC）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><strong><font style="vertical-align: inherit;">デジタル</font></strong><font style="vertical-align: inherit;">スペースからアナログスペースに戻すことができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">DACは特定の範囲でのみ値を再現できます。</font><font style="vertical-align: inherit;">たとえば、3.3 Vソースを備えた8ビットDACは、0〜3.3 mVの範囲のアナログ電圧を12.9 mVステップ（3.3 V / 256）で出力できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DACはデジタル値を取得し、それらを電圧に変換して戻します。この電圧は、アンプ、スピーカー、またはアナログオーディオ信号を受信できるその他のデバイスに送信できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリングレート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADCを介してアナログサウンドを録音する場合、サンプルは特定の周波数で取得され、各サンプルはある時点におけるサウンド信号の「スナップショット」です。このパラメータは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリング周波数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">呼ば</font><font style="vertical-align: inherit;">れ、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘルツ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で測定され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリング周波数が高いほど、元の信号の周波数をより正確に再現します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nyquist-Shannon（Kotelnikov）の定理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、サンプリング周波数は、記録したい最高の信号周波数の2倍にする必要が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ある</font></a><font style="vertical-align: inherit;">と（簡単な言葉で）述べています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人間の耳は約</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20 Hzから20 kHzの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲で聞こえる</font><font style="vertical-align: inherit;">ため、</font><strong><font style="vertical-align: inherit;">44.1 kHzの</font></strong><font style="vertical-align: inherit;">サンプリング周波数は高品質の音楽を再現するために最もよく使用されます</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これは人間の耳が認識できる最大周波数の2倍をわずかに超えています。これにより、楽器の周波数と声の完全なセットが確実に再現されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、各サンプルはファイル内のスペースを占有するため、最大サンプリングレートを選択することはできません。ただし、十分な速度でサンプリングしないと、重要な情報が失われる可能性があります。選択されるサンプリング周波数は、再現されたサウンドに存在する周波数に依存する必要があります。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再生はソースと同じサンプリング周波数で実行する必要があります。そうしないと、サウンドとその持続時間が異なります。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 kHzのサンプリング周波数で10秒の音が録音されたとします。</font><font style="vertical-align: inherit;">8 kHzの周波数で再生すると、トーンは低くなり、持続時間は20秒になります。</font><font style="vertical-align: inherit;">32 kHzのサンプリング周波数で再生すると、可聴音が高くなり、音自体が5秒間続きます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このビデオでは、サンプルレートの違いを例とともに示しています。</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビット深度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリング周波数は方程式の半分です。サウンドには、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビット深度</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまりサンプルあたりのビット数もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADCがオーディオ信号のサンプルをキャプチャする場合、ADCはこのアナログ値をデジタルに変換する必要があり、キャプチャされる値の範囲は使用されるビット数によって異なります。 8ビット（256値）、16ビット（65,526値）、32ビット（4,294,967,296値）など</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルあたりのビット数は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サウンドの</font><strong><font style="vertical-align: inherit;">ダイナミックレンジに</font></strong><font style="vertical-align: inherit;">関連してい</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。音が大きくて静かな部分があります。音楽の最も一般的なビット深度は16ビットです。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再生中、ソースと同じビット深度を提供する必要があります。そうしないと、サウンドとその持続時間が変化します。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、8ビットとして保存された4つのサンプル[0x25、0xAB、0x34、0x80]を含むオーディオファイルがあるとします。</font><font style="vertical-align: inherit;">それらを16ビットであるかのように再生しようとすると、[0x25AB、0x3480]の2つのサンプルしか取得できません。</font><font style="vertical-align: inherit;">これにより、サウンドサンプルの値が正しくなくなるだけでなく、サンプル数が半分になるため、サウンドの持続時間が短くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルのフォーマットを知ることも重要です。</font><font style="vertical-align: inherit;">8ビット符号なし、8ビット符号なし、16ビット符号なし、16ビット符号なしなど。</font><font style="vertical-align: inherit;">通常、8ビットは符号なし、16ビットは符号付きです。</font><font style="vertical-align: inherit;">混同すると音が大きく歪んでしまいます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このビデオでは、ビット深度の違いを例とともに示します。</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAVファイル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、コンピューター上の生のオーディオデータ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はWAV形式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">保存され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます。WAV形式</font></a><font style="vertical-align: inherit;">には、オーディオ形式（サンプリング周波数、ビット深度、サイズなど）を説明する単純なヘッダーがあり、その後にオーディオデータ自体が続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サウンドは（MP3などの形式とは異なり）圧縮されていないため、コーデックライブラリを必要とせずに簡単に再生できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WAVファイルの主な問題は、圧縮が行われていないため、非常に大きくなる可能性があることです。ファイルサイズは、継続時間、サンプリングレート、ビット深度に直接関係します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ=持続時間（秒単位）xサンプリングレート（サンプル/秒）xビット深度（ビット/サンプル）</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリング頻度はファイルサイズに最も影響を与えるため、スペースを節約する最も簡単な方法は、十分に低い値を選択することです。</font><font style="vertical-align: inherit;">オールドスクールなサウンドを作るので、サンプリング周波数が低い方がいいです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32には周辺機器があり、オーディオ機器とのインターフェースを提供するのは比較的簡単です：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound（I2S）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I2Sプロトコルは非常にシンプルで、クロック信号、チャネルの選択（左または右）、およびデータライン自体の3つの信号のみで構成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロック周波数は、サンプリング周波数、ビット深度、チャネル数に依存します。データのビットごとにビートが置き換えられるため、適切にサウンドを再生するには、それに応じてクロック周波数を設定する必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロック周波数=サンプリング周波数（サンプル/秒）xビット深度（ビット/サンプル）xチャネル数</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32マイクロコントローラーのI2Sドライバーには2つの可能なモードがあります。プロトコルをデコードしてデータをアンプに転送できる外部I2Sレシーバーに接続された接点にデータを出力するか、または送信可能なアナログ信号を出力する内部ESP32 DACにデータを転送できます増幅器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Goにはボード上にI2Sデコーダーがないため、内部8ビットESP32 DACを使用する必要があります。つまり、8ビットサウンドを使用する必要があります。</font><font style="vertical-align: inherit;">デバイスには2つのDACがあり、1つは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、もう</font><font style="vertical-align: inherit;">1つは</font><strong><font style="vertical-align: inherit;">IO26</font></strong><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">接続され</font><font style="vertical-align: inherit;">てい</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手順は次のようになります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオデータをI2Sドライバーに転送します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2Sドライバーがオーディオデータを8ビットの内部DACに送信</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部DACはアナログ信号を出力します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナログ信号はサウンドアンプに送信されます</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">Odroid </font></strong></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go回路</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
のオーディオ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">回路</font></a><font style="vertical-align: inherit;">を見ると、</font><font style="vertical-align: inherit;">2つのGPIOピン（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）がサウンドアンプ（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">入力に接続されていることが</font><strong><font style="vertical-align: inherit;">わかり</font></strong><font style="vertical-align: inherit;">ます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25は</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">、</font></strong><font style="vertical-align: inherit;">アンプの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信号</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまり、アンプをオンまたはオフにする接点に</font><font style="vertical-align: inherit;">も接続され</font><font style="vertical-align: inherit;">ます（信号が低いとシャットダウンを意味します）。アンプの出力は1つのスピーカー（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">接続され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ことを覚えておいて</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、1つのDACが接続されている8ビットESP32のDACの出力である</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および他の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サウンドアンプの</font><strong><font style="vertical-align: inherit;">差動入力</font></strong><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電磁干渉</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって引き起こされるノイズを低減するために、差動入力が使用され</font><font style="vertical-align: inherit;">ます。ある信号に存在するノイズは、別の信号にも存在します。 1つの信号が別の信号から差し引かれ、ノイズが除去されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが見れば</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音アンプの仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、それが持っている</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代表的なアプリケーション回路</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の増幅器を使用するには、製造元の推奨される方法です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をグラウンドに、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を入力信号に、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をオン/オフ信号に</font><font style="vertical-align: inherit;">
接続することをお勧め</font><font style="vertical-align: inherit;">します。 0.005 Vのノイズがある場合は、と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0.005Vが</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み込まれる</font><font style="vertical-align: inherit;">、として</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。入力信号を互いに差し引いて、</font><font style="vertical-align: inherit;">ノイズのない</font><font style="vertical-align: inherit;">真の信号値（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">取得する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Odroid Goの設計者は推奨構成を使用していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度Odroid Go回路を見ると、設計者がDAC出力を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続して</font><font style="vertical-align: inherit;">おり、同じDAC出力が</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SDに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続されている</font><font style="vertical-align: inherit;">ことがわかり</font><font style="vertical-align: inherit;">ます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これはアクティブローレベルのシャットダウン信号なので、アンプを動作させるには、ハイ信号を設定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、アンプを使用するには、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をDACとして</font><font style="vertical-align: inherit;">使用するのではなく</font><font style="vertical-align: inherit;">、常に高い信号を持つGPIO出力として</font><font style="vertical-align: inherit;">使用する必要があります</font><font style="vertical-align: inherit;">。ただし、この場合、ハイ信号は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">設定されます</font><font style="vertical-align: inherit;">。これは、アンプの仕様では推奨されていません（接地する必要があります）。次に</font><font style="vertical-align: inherit;">、I2S出力を</font><strong><font style="vertical-align: inherit;">IN +に</font></strong><font style="vertical-align: inherit;">供給する必要があるため、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">接続されたDACを使用する</font><font style="vertical-align: inherit;">必要があります</font><font style="vertical-align: inherit;">。これは、</font><strong><font style="vertical-align: inherit;">IN-が</font></strong><font style="vertical-align: inherit;">グラウンドに接続されて</font><font style="vertical-align: inherit;">いないため、必要なノイズ低減を実現できないことを意味し</font><font style="vertical-align: inherit;">ます。スピーカーからソフトノイズが常に発生します。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
接続されたDACのみを使用するため、I2Sドライバーの正しい構成を確認する必要があります</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">接続されたDACを使用すると</font><font style="vertical-align: inherit;">、アンプの信号が常にオフになり、音がひどくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この奇妙なことに加えて、8ビットの内部DACを使用する場合、ESP32のI2Sドライバーは16ビットのサンプルを送信する必要がありますが、8バイトのDACには上位バイトのみを送信します。</font><font style="vertical-align: inherit;">したがって、8ビットのサウンドを2倍の大きさのバッファーに貼り付ける必要がありますが、バッファーは半分空になります。</font><font style="vertical-align: inherit;">次に、それをI2Sドライバーに渡し、各サンプルの上位バイトをDACに渡します。</font><font style="vertical-align: inherit;">残念ながら、これは16ビットに対して「支払う」必要があることを意味しますが、8ビットしか使用できません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチタスク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、I2Sドライバーにバグがあるように思われるため、ゲームは最初に望んだように1つのコアで動作できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I2Sドライバーは（SPIドライバーのように）DMAを使用する必要があります。つまり、I2Sの転送を開始し、I2Sドライバーがオーディオデータを送信している間も作業を続けることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、代わりにサウンドの持続時間中はCPUがブロックされるため、ゲームにはまったく適していません。ジャンプボタンを押した後、ジャンプサウンドの再生中にプレーヤーのスプライトが100ミリ秒間動きを一時停止したとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、ESP32には2つのコアが搭載されているという事実を利用できます。</font><font style="vertical-align: inherit;">2番目のコアでタスク（つまり、スレッド）を作成できます。これは、サウンドの再生を処理します。</font><font style="vertical-align: inherit;">これにより、ゲームのメインタスクからサウンドタスクにサウンドバッファーへのポインターを転送でき、サウンドタスクはI2Sの転送を開始し、サウンドの再生中はブロックされます。</font><font style="vertical-align: inherit;">ただし、最初のコアのメインタスク（入力処理とレンダリングを使用）は、ブロックせずに実行し続けます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを知っていれば、I2Sドライバーを適切に開始できます。</font><font style="vertical-align: inherit;">これを行うには、ほんの数行のコードが必要ですが、適切なサウンド再生のために設定する必要があるパラメーターを見つけるのは困難です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（アンプのターンオフ信号に接続されている）を出力として構成して、サウンドアンプを制御し、ハイ信号を適用してアンプをオンにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、I2Sドライバー自体を構成してインストールします。</font><font style="vertical-align: inherit;">行ごとに説明が必要なため、構成の各部分を1行ずつ解析します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モード</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバーをマスター（バスを制御）、トランスミッター（受信者にデータを転送するため）として設定し、組み込みの8ビットDACを使用するようにドライバーを構成します（Odroid Goボードには外部DACがないため）。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプルレート</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   —  <strong>IO26</strong>,       «»   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、キューを作成します。これは、FreeRTOSがタスク間でデータを送信する方法です。データを1つのタスクのキューに入れ、別のタスクのキューから抽出します。</font><font style="vertical-align: inherit;">サウンドバッファへのポインタとバッファの長さを、キューに入れることができる単一の構造に結合する</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">呼ばれる構造体を作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2番目のコアで実行するタスクを作成します。</font><font style="vertical-align: inherit;">サウンドの再生を実行</font><font style="vertical-align: inherit;">する</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数に接続し</font><font style="vertical-align: inherit;">ます。タスク自体は、キューにデータがあるかどうかを常に確認する無限ループです。それらがある場合、彼女はそれらを再生できるようにI2Sドライバーに送信します。</font><strong><font style="vertical-align: inherit;">i2s_write</font></strong><font style="vertical-align: inherit;">呼び出しをブロックします</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これは私たちに適しています。タスクがゲームのメインスレッドとは別のカーネルで実行されるためです。</font><strong><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の呼び出し</font><font style="vertical-align: inherit;">は、再生が完了した後</font><font style="vertical-align: inherit;">に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スピーカー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><strong><font style="vertical-align: inherit;">音が出ない</font></strong><font style="vertical-align: inherit;">ようにするために必要です。</font><font style="vertical-align: inherit;">これがI2Sドライバーのバグなのか、予想される動作なのかはわかりませんが、それがなければ、サウンドバッファーの再生が終了した後、スピーカーがガベージシグナルを発します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音を出す</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての設定がすでに完了しているため、サウンドバッファ再生関数自体の呼び出しは、主な作業が別のタスクで行われるため、非常に簡単です。</font><font style="vertical-align: inherit;">バッファーへのポインターとバッファーの長さを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体</font><font style="vertical-align: inherit;">に入れ、それを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数が使用するキューに入れます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作パターンのため、1つのサウンドバッファは、2番目のバッファを開始する前に再生を完了する必要があります。</font><font style="vertical-align: inherit;">したがって、ジャンプと射撃が同時に発生した場合、最初のサウンドは2番目のサウンドの前に再生され、同時には再生されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、将来的には、I2Sドライバーに送信されるサウンドバッファーにさまざまなフレームサウンドをミックスする予定です。</font><font style="vertical-align: inherit;">これにより、複数のサウンドを同時に再生できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要な種類のゲームサウンドを生成するために特別に設計されたツールである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用して、独自のサウンドエフェクトを</font><font style="vertical-align: inherit;">生成します。</font><font style="vertical-align: inherit;">サンプリング周波数とビット深度を直接設定して、WAVファイルを出力できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マリオのジャンプ音に似たシンプルなジャンプ効果音を作りました。</font><font style="vertical-align: inherit;">サンプリング周波数は5012（初期化時に構成したとおり）で、ビット深度は8（DACが8ビットであるため）です。</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでWAVファイルを直接解析する代わりに、パート4のデモでスプライトをロードするために行ったのと同様のことを行い、16進エディターを使用してファイルからWAVヘッダーを削除します。これにより、SDカードから読み取ったファイルは生データのみになります。また、サウンドの継続時間を読み取るのではなく、コードに書き込みます。将来的にはサウンドリソースのロード方法が異なりますが、デモではこれで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生ファイルは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8ビットのデータを8ビットの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundEffect</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファーに読み込み</font><font style="vertical-align: inherit;">、このデータを16ビットの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファー</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">コピーします</font><font style="vertical-align: inherit;">。ここで、データは上位8ビットに格納されます。</font><font style="vertical-align: inherit;">繰り返しますが、これはIDF実装の機能のために必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16ビットのバッファーを作成したら、ボタンをクリックしたときのサウンドを再生できます。</font><font style="vertical-align: inherit;">これには音量ボタンを使用するのが理にかなっています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボタンの状態を監視して、ボタンを1回クリックするだけで、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誤ってOdroid_PlayAudioが</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何度も</font><strong><font style="vertical-align: inherit;">呼び出され</font></strong><font style="vertical-align: inherit;">ないようにします</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go Schematic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオアンプデータシート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDFドキュメント：DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDFドキュメント：I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAVEファイル形式</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオ：ビット深度の説明</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオ：サンプルレートの説明</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503860/index.html">ニューラルネットワーク環境の設定R-CNNマスク</a></li>
<li><a href="../ja503862/index.html">画期的な製品を生み出す成功への対価としての心理的問題</a></li>
<li><a href="../ja503864/index.html">Flutterのフレーバー組織</a></li>
<li><a href="../ja503866/index.html">2020年のロードマップ開発Zextras Suiteを公開</a></li>
<li><a href="../ja503868/index.html">ドメインモデルの輝きと貧困</a></li>
<li><a href="../ja503880/index.html">心配しないことを学び、マシンビジョンを愛した方法</a></li>
<li><a href="../ja503884/index.html">非同期で作業する方法を学ぶ方法</a></li>
<li><a href="../ja503888/index.html">AdaBoostアルゴリズム</a></li>
<li><a href="../ja503890/index.html">ReactおよびReact Nativeパート1でAzure AD B2Cを構成した方法の物語（チュートリアル）</a></li>
<li><a href="../ja503892/index.html">ミタップ：検疫、逃げる</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>