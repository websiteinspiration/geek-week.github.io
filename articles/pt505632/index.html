<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöï ‚ö°Ô∏è üïµüèΩ Alocadores de mem√≥ria ü•® üôçüèΩ üÄÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° a todos! N√£o faz muito tempo, depois de um estudo muito minucioso de alocadores e algoritmos de aloca√ß√£o de mem√≥ria, bem como de sua aplica√ß√£o sub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Alocadores de mem√≥ria</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√° a todos! </font><font style="vertical-align: inherit;">N√£o faz muito tempo, depois de um estudo muito minucioso de alocadores e algoritmos de aloca√ß√£o de mem√≥ria, bem como de sua aplica√ß√£o subsequente na pr√°tica, tive a id√©ia de escrever um artigo que os descrevesse com o m√°ximo de detalhes poss√≠vel. </font><font style="vertical-align: inherit;">Penso que este t√≥pico ser√° bastante popular, uma vez que existem muito poucas fontes na rede, especialmente na parte de l√≠ngua russa, dedicada a esse problema.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pref√°cio</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, gostaria de observar imediatamente que, se algu√©m ouvir os termos "alocador", "algoritmos de aloca√ß√£o de mem√≥ria" e n√£o entender por que tudo isso √© necess√°rio, antes de ler este artigo, recomendo que voc√™ se familiarize com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">essa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonte . </font><font style="vertical-align: inherit;">Este artigo descreve muito bem quais problemas existem nos alocadores de mem√≥ria padr√£o e para que fins vale a pena usar outros m√©todos de aloca√ß√£o de mem√≥ria, al√©m dos padr√µes. </font><font style="vertical-align: inherit;">Aqui, falarei apenas dos pr√≥prios algoritmos de distribui√ß√£o e, √© claro, no final darei uma implementa√ß√£o de um dos alocadores, que pode ser usado sem problemas em cont√™ineres C ++ padr√£o.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O b√°sico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cinco opera√ß√µes principais que podem ser executadas em um alocador s√£o destacadas conceitualmente (eu gostaria de observar que nem todos os alocadores podem corresponder explicitamente a essa interface):</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cria um alocador e fornece uma certa quantidade de mem√≥ria;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alocar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - seleciona um bloco de um determinado tamanho da √°rea de mem√≥ria que o alocador controla;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desalocar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - libera um bloco espec√≠fico;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">livres</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - libera todos os blocos alocados de alocador de mem√≥ria (mem√≥ria alocada para alocador n√£o √© liberado);</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destroy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - destr√≥i o alocador com a libera√ß√£o subsequente de mem√≥ria alocada para o alocador.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alocador linear</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alocador linear, tamb√©m √© "linear" - este √© o tipo mais simples de alocadores. A id√©ia √© salvar um ponteiro no in√≠cio do bloco de mem√≥ria para o alocador alocado e tamb√©m usar um ponteiro ou representa√ß√£o num√©rica diferente, que precisar√° ser movida toda vez que a aloca√ß√£o do alocador for conclu√≠da. Nesse alocador, a fragmenta√ß√£o interna √© minimizada, porque todos os elementos s√£o inseridos seq√ºencialmente (localidade espacial) e a √∫nica fragmenta√ß√£o entre eles √© o alinhamento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, proponho considerar v√°rios exemplos nos quais ser√£o claramente mostrados em detalhes como esse alocador funciona. Pegue um bloco de mem√≥ria igual a 14 bytes e d√™-o ao controle do alocador. Como pode ser visto na figura abaixo, salvamos um ponteiro no in√≠cio da mem√≥ria ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in√≠cio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e tamb√©m armazene dois ponteiros ou duas representa√ß√µes num√©ricas que cont√™m informa√ß√µes sobre os </font><font style="vertical-align: inherit;">tamanhos de mem√≥ria </font><font style="vertical-align: inherit;">total ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e usado ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine que o alocador recebeu uma solicita√ß√£o para alocar 4 bytes de mem√≥ria. </font><font style="vertical-align: inherit;">As a√ß√µes do alocador na execu√ß√£o desta solicita√ß√£o ser√£o as seguintes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verifique se h√° mem√≥ria suficiente para alocar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salve o ponteiro usado atualmente, que mais tarde ser√° fornecido ao usu√°rio como ponteiro para um bloco de mem√≥ria alocada do alocador;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desloque o ponteiro usado por uma quantidade igual ao tamanho do bloco de mem√≥ria alocado, ou seja, </font><font style="vertical-align: inherit;">por 4 bytes.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, por exemplo, vem uma solicita√ß√£o de aloca√ß√£o de 8 bytes e, portanto, as a√ß√µes do alocador ser√£o exatamente as mesmas, independentemente do tamanho do bloco de mem√≥ria alocado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas aqui j√° ser√° um pouco mais interessante, por exemplo, se houver uma solicita√ß√£o para alocar apenas 1 byte e se n√£o quisermos alinhar blocos na mem√≥ria (por exemplo, endere√ßos que s√£o m√∫ltiplos de 2, 4, ...), as a√ß√µes do alocador permanecer√£o exatamente as mesmas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, se precisarmos alocar blocos de mem√≥ria com um certo alinhamento (por exemplo, alinhamento de endere√ßos m√∫ltiplos de 2), a a√ß√£o do alocador mudar√° ligeiramente. Ele muda n√£o em termos de implementa√ß√£o, mas, al√©m dos dados em si iguais ao volume de um byte, tamb√©m extra√≠mos um byte adicional da mem√≥ria do alocador para alinhamento, o que n√£o tem nenhum significado. Essa √© precisamente a fragmenta√ß√£o m√≠nima poss√≠vel da mem√≥ria dentro de um alocador linear. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√ìtimo, agora √© a hora de conversar sobre como liberar mem√≥ria. Como observado anteriormente, esse tipo de alocotor n√£o suporta a libera√ß√£o seletiva de certos blocos de mem√≥ria. Ou seja, se </font><b><font style="vertical-align: inherit;">tra√ßarmos</font></b><font style="vertical-align: inherit;"> uma analogia sutil com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ter um ponteiro para, digamos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA00</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, poder√≠amos liberar esse bloco de mem√≥ria, mas um alocador linear n√£o pode permitir isso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo o que podemos fazer √© liberar toda a mem√≥ria ocupada inteiramente dentro do alocador e continuar trabalhando com ela como se estivesse completamente vazia.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alocador de pool</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A id√©ia de um alocador de bloco √© que ele divide uma grande parte da mem√≥ria em partes menores do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mesmo tamanho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Na sua ess√™ncia, tamb√©m √© um alocador muito simples, pois quando a aloca√ß√£o √© solicitada, ela simplesmente retorna um dos locais de mem√≥ria livre de tamanho fixo e, quando √© solicitada a libera√ß√£o, simplesmente salva essa √°rea de mem√≥ria para uso futuro. Assim, a distribui√ß√£o √© muito r√°pida e a fragmenta√ß√£o ainda √© muito pequena. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, assim como com um alocador linear, proponho considerar tudo com um exemplo, a fim de entender mais detalhadamente como funciona, ent√£o pegamos algum bloco de mem√≥ria igual a 12 bytes e o atribu√≠mos ao controle do alocador. Como voc√™ pode ver na figura abaixo, mantemos o ponteiro para o in√≠cio (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e o final ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) da mem√≥ria controlada pelo alocador, bem como uma lista ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocos livres</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dos endere√ßos dos blocos livres no alocador. Como um meio de armazenar dados de que o bloco est√° ocupado ou livre, voc√™ pode usar muitas ferramentas, por exemplo, uma matriz de valores booleanos, mas apenas decidi escolher uma lista simplesmente conectada, uma vez que mais simples e claramente caracteriza esse conceito (a prop√≥sito, os links da lista podem ser armazenados em blocos de mem√≥ria livres, removendo assim os custos adicionais de mem√≥ria).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se uma solicita√ß√£o vier para alocar um bloco de mem√≥ria, as a√ß√µes do alocador ser√£o muito primitivas. Primeiro, ele verifica se h√° links na lista de blocos livres, se n√£o houver, n√£o √© dif√≠cil adivinhar que a mem√≥ria no alocador j√° se esgotou. Se houver pelo menos um link l√°, ele simplesmente retira o link raiz ou final (nesta implementa√ß√£o s√£o fornecidos links finais) da lista e fornece seu endere√ßo ao usu√°rio. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se for solicitada a aloca√ß√£o de v√°rios blocos de mem√≥ria, o alocador da mesma maneira executar√° as mesmas a√ß√µes, por sua vez, descritas na etapa anterior.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto √† libera√ß√£o do bloco, se uma solicita√ß√£o de libera√ß√£o chegar, o alocador simplesmente adiciona esse endere√ßo a uma das extremidades de uma lista simplesmente conectada. Vale a pena notar em um momento que, por exemplo, um endere√ßo que n√£o corresponde ao endere√ßo de mem√≥ria do alocador, por exemplo, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xEFAB12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">pode vir como o endere√ßo do bloco a ser </font><b><font style="vertical-align: inherit;">liberado</font></b><font style="vertical-align: inherit;"> e, em seguida, ser√° poss√≠vel fornecer ao usu√°rio uma mem√≥ria que n√£o nos pertence (√© claro) , isso levar√° a um comportamento indefinido ou, se voc√™ tiver muita sorte, basta travar o programa). Para evitar esse poss√≠vel problema, apenas o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">come√ßo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fim s√£o usados</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que permite verificar se o usu√°rio se enganou com o endere√ßo durante a solicita√ß√£o da opera√ß√£o de libera√ß√£o.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m de ir al√©m da mem√≥ria que o alocador n√£o controla, h√° outro problema poss√≠vel. </font><font style="vertical-align: inherit;">Um usu√°rio pode apresentar uma solicita√ß√£o para liberar absolutamente qualquer endere√ßo localizado na √°rea de mem√≥ria do alocador, mas n√£o igual ao endere√ßo inicial de qualquer um dos blocos, digamos um bloco com o endere√ßo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA07</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Essa opera√ß√£o, √© claro, levar√° a um comportamento indefinido. </font><font style="vertical-align: inherit;">Se for necess√°rio verificar adicionalmente se o usu√°rio est√° fazendo tudo corretamente, √© poss√≠vel rastrear isso. </font><font style="vertical-align: inherit;">Para rastrear isso, existem muitas solu√ß√µes, por exemplo, para armazenar endere√ßos e blocos ocupados, ou at√© verificar o endere√ßo quanto √† multiplicidade de tamanhos de bloco no alocador (tudo depende da imagina√ß√£o e da situa√ß√£o espec√≠fica em que o alocador √© usado).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alocador de pilha</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, essa √© uma evolu√ß√£o inteligente de um alocador linear que permite gerenciar a mem√≥ria como uma pilha. Tudo est√° como antes, salvamos o ponteiro com o bloco ‚Äúheader‚Äù (a seguir ser√° usado como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cabe√ßalho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) no endere√ßo de mem√≥ria atual e o avan√ßamos para cada aloca√ß√£o. Ao contr√°rio de um alocador linear, tamb√©m podemos mov√™-lo de volta, ou seja, executar a opera√ß√£o de desaloca√ß√£o, que n√£o √© suportada por um alocador linear. Como antes, o princ√≠pio da localidade espacial √© mantido e a fragmenta√ß√£o ainda √© m√≠nima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proponho considerar v√°rios exemplos, todos com o mesmo bloco de mem√≥ria de 14 bytes. Como em um alocador linear, tamb√©m armazenamos ponteiros para o in√≠cio da mem√≥ria ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e end ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), bem como um ponteiro para o final da mem√≥ria </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">usada</font></i><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando chega uma solicita√ß√£o de aloca√ß√£o de mem√≥ria, al√©m de alocar uma certa quantidade de mem√≥ria solicitada pelo usu√°rio, alocamos adicionalmente um cabe√ßalho (o usu√°rio n√£o ir√° interagir com ele de forma alguma), no qual armazenamos informa√ß√µes sobre quantos bytes foram alocados (neste exemplo, o tamanho do cabe√ßalho √© 2 bytes). Por exemplo, se voc√™ recebeu uma solicita√ß√£o de aloca√ß√£o de 2 bytes, o estado do alocador ser√° exatamente o mesmo da figura abaixo. √â importante observar que o usu√°rio n√£o receber√° um ponteiro para o cabe√ßalho, mas para o bloco imediatamente ap√≥s o cabe√ßalho, ou seja, neste exemplo, este √© o bloco com o endere√ßo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA02</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma situa√ß√£o semelhante ser√°, por exemplo, com a aloca√ß√£o de 6 bytes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas com o lan√ßamento, tudo fica um pouco mais interessante (como discutido anteriormente, s√≥ podemos alocar e liberar mem√≥ria usando o algoritmo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Primeiro, a partir do ponteiro que o usu√°rio pede para ser liberado, voc√™ precisa subtrair o tamanho do cabe√ßalho, depois desreferenciar o valor e somente depois mover o ponteiro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o tamanho do cabe√ßalho, juntamente com o tamanho do bloco obtido do cabe√ßalho. </font><font style="vertical-align: inherit;">Aqui, assim como no alocador de blocos, √© poss√≠vel liberar blocos de mem√≥ria ‚Äúaleat√≥rios‚Äù, o que tamb√©m levar√° a um comportamento indefinido. </font><font style="vertical-align: inherit;">Cabe a todos suplementar os alocadores com verifica√ß√µes adicionais ou n√£o. </font><font style="vertical-align: inherit;">O mais importante √© n√£o esquecer esse momento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, depois de entender o b√°sico, √© hora de aprender algo mais s√©rio.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Alocador padr√£o primitivo"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, ser√° apresentada uma implementa√ß√£o do alocador, que pode ser usada sem problemas com o STL. O algoritmo de aloca√ß√£o de mem√≥ria neste alocador ser√° semelhante ao algoritmo usado pelo alocador padr√£o. Quero notar imediatamente que n√£o pretendo ser uma implementa√ß√£o completa do malloc, peguei apenas os conceitos b√°sicos com a adi√ß√£o da minha l√≥gica em alguns lugares. Todas as suas sutilezas e nuances, √© claro, n√£o foram levadas em considera√ß√£o nesta implementa√ß√£o ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O algoritmo √© baseado na intera√ß√£o com "peda√ßos" (a seguir ser√° usado como uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se√ß√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nesta implementa√ß√£o, seu tamanho √© est√°tico e deve ser um m√∫ltiplo de quatro, assim como todas as aloca√ß√µes de mem√≥ria da mem√≥ria do alocador s√£o alinhadas por um m√∫ltiplo de quatro), o que ser√° discutido posteriormente. Como exemplo, fa√ßa uma se√ß√£o com um tamanho de 16 bytes. Dentro dele, ele ir√° conter ponteiros para o in√≠cio ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e fim ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) da mem√≥ria, um ponteiro para o bloco de mem√≥ria m√°xima ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e muitos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freeblocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), em que cabe√ßalhos de blocos livres ser√£o armazenados. O tamanho do cabe√ßalho nesta implementa√ß√£o √© de 4 bytes, mas pode variar facilmente em tamanho para os fins que voc√™ precisa. Por exemplo, se voc√™ tiver certeza de que o tamanho dos blocos de mem√≥ria alocados n√£o exceder√° o valor num√©rico m√°ximo que pode ser representado em vari√°veis ‚Äã‚Äãde um ou dois bytes, poder√° usar um cabe√ßalho de 1 ou 2 bytes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na opera√ß√£o de aloca√ß√£o de mem√≥ria de uma se√ß√£o, voc√™ primeiro precisa verificar se h√° mem√≥ria suficiente (nesta implementa√ß√£o, essa √© uma opera√ß√£o constante, apenas a comparamos com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cabe√ßalho e, se o tamanho da mem√≥ria alocada for menor que o bloco m√°ximo, teremos mem√≥ria suficiente para essa aloca√ß√£o). Se houver mem√≥ria suficiente, simplesmente fornecemos o endere√ßo de mem√≥ria ap√≥s o cabe√ßalho, como no alocador de pilha, e tamb√©m exclu√≠mos o cabe√ßalho anterior do conjunto de blocos livres e somente depois disso adicionamos o novo cabe√ßalho ao novo bloco de mem√≥ria alocado. √â importante observar que, se alocamos mem√≥ria do bloco m√°ximo, precisaremos atualizar o valor do bloco m√°ximo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas sele√ß√µes subsequentes, tudo acontece exatamente da mesma maneira que na etapa anterior.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas agora, assim que a mem√≥ria da se√ß√£o termina, o alocador pega e simplesmente cria outra se√ß√£o do mesmo tamanho ou maior (nesta implementa√ß√£o, todas as se√ß√µes t√™m o mesmo tamanho). Tamb√©m vale a pena garantir que o tamanho do poss√≠vel bloco para aloca√ß√£o n√£o exceda o tamanho do gr√°fico menos o tamanho do cabe√ßalho. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, na nova se√ß√£o, voc√™ pode alocar facilmente os blocos de mem√≥ria necess√°rios. A aloca√ß√£o de mem√≥ria ocorrer√° exatamente no mesmo cen√°rio da se√ß√£o anterior.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, um pouco sobre por que nessa implementa√ß√£o o tamanho do gr√°fico deve ser m√∫ltiplo de quatro. A resposta √© muito simples - isso √© feito para facilitar a implementa√ß√£o e a percep√ß√£o do algoritmo. Como essa situa√ß√£o √© poss√≠vel, no final da se√ß√£o, pode haver alguma √°rea de mem√≥ria, que simplesmente n√£o cabe no cabe√ßalho (um exemplo disso √© mostrado na figura a seguir). Para resolver esse problema, ser√° poss√≠vel preencher essa mem√≥ria com alinhamento adicional, diminuir o tamanho do cabe√ßalho ou usar ferramentas adicionais para rastrear esse poss√≠vel problema; caso contr√°rio, essa mem√≥ria ser√° perdida e, o mais importante, no futuro, a mem√≥ria perdida poder√° se acumular!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de liberar mem√≥ria, √© necess√°rio determinar em qual se√ß√£o o bloco est√° localizado (na implementa√ß√£o atual, esta opera√ß√£o √© de complexidade linear em rela√ß√£o ao n√∫mero total de se√ß√µes, se for entendido que haver√° um grande n√∫mero de se√ß√µes, ser√° poss√≠vel tornar constante adicionando um √≠ndice de se√ß√£o ao cabe√ßalho, na qual a mem√≥ria foi alocada). A seguir, a opera√ß√£o de desaloca√ß√£o √© id√™ntica ao alocador de pilha, exceto que voc√™ precisar√° adicionar o endere√ßo do cabe√ßalho do bloco desalocado ao conjunto de blocos livres, bem como atualizar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se o tamanho do bloco rec√©m-lan√ßado for maior que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â importante observar que nesta implementa√ß√£o, a cada libera√ß√£o de mem√≥ria subsequente, √© feita uma tentativa de desfragmentar a √°rea da qual a mem√≥ria foi liberada. A desfragmenta√ß√£o √© necess√°ria para combinar blocos livres em blocos grandes. Por exemplo, nesta situa√ß√£o, como na figura abaixo, n√£o podemos alocar 6 bytes, mesmo que o tamanho da mem√≥ria livre nos permita fazer isso, mas a fragmenta√ß√£o nos diz um "n√£o" firme e decisivo! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A opera√ß√£o de desfragmenta√ß√£o √© muito primitiva. Sua ess√™ncia est√° no fato de que, ap√≥s a opera√ß√£o de liberar mem√≥ria, ele verifica se dois blocos vizinhos √† esquerda e √† direita dos liberados est√£o livres. Se dois blocos vizinhos estiverem livres, eles ser√£o combinados em uma √∫nica unidade.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gostaria tamb√©m de observar que esta implementa√ß√£o ser√° desastrosamente terr√≠vel para alocar pequenos blocos de mem√≥ria, por exemplo, iguais a 1 byte. </font><font style="vertical-align: inherit;">Nessa situa√ß√£o, obtemos +7 bytes extras para alocar apenas um byte de mem√≥ria devido ao fato de o tamanho do cabe√ßalho ser de 4 bytes e mais 3 bytes para separar endere√ßos que devem ser m√∫ltiplos de quatro. </font><font style="vertical-align: inherit;">Por isso, quero dizer que voc√™ n√£o deve usar cegamente nenhum algoritmo de aloca√ß√£o de mem√≥ria, pois, em vez da t√£o esperada otimiza√ß√£o, √†s vezes voc√™ pode obter apenas custos adicionais. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acho que a teoria ser√° suficiente e, portanto, como Linus Torvalds disse: ‚ÄúO </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chatter √© in√∫til. </font><font style="vertical-align: inherit;">Mostre-me o c√≥digo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Bem, vamos come√ßar ...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os requisitos para alocadores s√£o fornecidos no padr√£o C ++ no cap√≠tulo " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisitos do alocador [alocator.requirements]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Com base nesses requisitos, a interface do alocador mais primitiva que pode ser usada no STL deve se parecer com isso:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sup√µe-se que os cont√™ineres STL n√£o acessem o alocador diretamente, mas atrav√©s do modelo std :: alocator_traits, que fornece valores como:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
‚Ä¶ <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, n√≥s descobrimos os requisitos, agora finalmente estamos come√ßando a escrever um alocador. </font><font style="vertical-align: inherit;">Para come√ßar, escreveremos alguma interface ou adaptador; na verdade, √© dif√≠cil chamar uma ou outra, ent√£o seja uma esp√©cie de "camada" na qual, com a ajuda de estrat√©gias, possamos alterar facilmente o algoritmo de aloca√ß√£o de mem√≥ria para certos fins:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gra√ßas √† estrat√©gia de aloca√ß√£o de mem√≥ria, podemos fazer algo assim:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, podemos alterar com flexibilidade os algoritmos de distribui√ß√£o para os prop√≥sitos necess√°rios em uma determinada situa√ß√£o. </font><font style="vertical-align: inherit;">O √∫nico requisito para a AllocationStrategy √© que eles tenham que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alocar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desalocar opera√ß√µes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, s√£o utilizados recipientes padr√£o. </font><font style="vertical-align: inherit;">Concordo que haver√° muitas aloca√ß√µes do heap. </font><font style="vertical-align: inherit;">Eu acho que para quem escrever seus alocadores, isso ser√° inaceit√°vel. </font><font style="vertical-align: inherit;">Como alternativa, √© claro, voc√™ pode escrever seus pr√≥prios cont√™ineres ou usar os de outra pessoa, afiados para determinadas necessidades, mas nesta implementa√ß√£o, tentei apresentar o material o mais facilmente poss√≠vel, ent√£o minha escolha foi em cont√™ineres padr√£o.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, um pouco sobre como voc√™ pode decorar o uso de alocadores junto com cont√™ineres padr√£o: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ tamb√©m pode usar alocadores com ponteiros inteligentes, mas para isso precisar√° escrever uma pequena camada: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, e agora, finalmente, um exemplo de como usar tudo isso:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gostaria de focar no fato de que essa implementa√ß√£o √© a mais primitiva, mas pode ser facilmente expandida na dire√ß√£o que voc√™ precisa, para que tudo esteja em suas m√£os!</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obrigado por sua aten√ß√£o. Espero realmente que este artigo tenha sido √∫til para algu√©m. </font><font style="vertical-align: inherit;">Desejo tamb√©m sucesso a todos em sua estreita intera√ß√£o com a mem√≥ria e, o mais importante, n√£o se esque√ßa das palavras muito importantes de Donald Knuth: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A otimiza√ß√£o prematura √© a raiz de todos os males</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link para o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposit√≥rio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com a implementa√ß√£o completa do alocador.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fontes utilizadas</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt505614/index.html">As taxas de dep√≥sito dos maiores bancos ca√≠ram para um m√≠nimo hist√≥rico: como isso afeta a economia e onde ocorre a troca</a></li>
<li><a href="../pt505616/index.html">Reconhecimento do alfabeto russo: da coleta de um conjunto de dados √† cria√ß√£o de uma GUI</a></li>
<li><a href="../pt505618/index.html">Modelos GRASP: Criador</a></li>
<li><a href="../pt505620/index.html">HackTheBox. Ninho passo a passo. Fluxos NTFS, C # reverso e andador SMB</a></li>
<li><a href="../pt505624/index.html">Como processar um quadro de dados com bilh√µes de registros em segundos?</a></li>
<li><a href="../pt505634/index.html">Configura√ß√µes de proxy para WSL (Ubuntu)</a></li>
<li><a href="../pt505640/index.html">Objetividade da classifica√ß√£o da publica√ß√£o</a></li>
<li><a href="../pt505642/index.html">Corotinas transparentes</a></li>
<li><a href="../pt505644/index.html">Detentores de direitos autorais tentados: as li√ß√µes do videoclipe do YouTube com a an√°lise de m√∫sicas de outras pessoas podem desaparecer</a></li>
<li><a href="../pt505648/index.html">Os dois erros de Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>