<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 🧗🏽 ⛷️ 应对Web应用程序中的内存泄漏 👨🏽‍🤝‍👨🏼 🕵🏻 ☃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我们从在服务器上形成页面的网站的开发转移到在客户端上呈现的单页Web应用程序的创建时，我们采用了某些游戏规则。其中之一是准确处理用户设备上的资源。这意味着-不要阻塞主流，不要“旋转”笔记本电脑的风扇，不要放手机的电池。我们交换了Web项目交互性方面的一个改进，即它们的行为变得更像普通应用程序的行为...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>应对Web应用程序中的内存泄漏</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490622/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们从在服务器上形成页面的网站的开发转移到在客户端上呈现的单页Web应用程序的创建时，我们采用了某些游戏规则。其中之一是准确处理用户设备上的资源。这意味着-不要阻塞主流，不要“旋转”笔记本电脑的风扇，不要放手机的电池。我们交换了Web项目交互性方面的一个改进，即它们的行为变得更像普通应用程序的行为，这是服务器呈现世界中不存在的一类新问题。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/wv/_c/nl/wv_cnlo46dgs8op0yzhybzgkpw8.jpeg"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的问题之一就是内存泄漏。</font><font style="vertical-align: inherit;">设计不佳的一页应用程序可能会轻易吞噬兆字节甚至千兆字节的内存。</font><font style="vertical-align: inherit;">即使它安静地位于背景选项卡上，它也可以占用越来越多的资源。</font><font style="vertical-align: inherit;">在捕获了大量资源后，此类应用程序的页面可能开始大大“变慢”。</font><font style="vertical-align: inherit;">另外，浏览器可以简单地关闭选项卡并告诉用户：“出了点问题。”</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/e9d/da8/34be9dda87ca7f35d70a1a934816ce78.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出问题了</font></font></font></i><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，在服务器上呈现的站点也可能遭受内存泄漏问题。但是这里我们谈论的是服务器内存。同时，由于每个用户在页面之间切换之后浏览器都会清除内存，因此此类应用程序不太可能导致客户端发生内存泄漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web开发出版物中没有很好地讨论内存泄漏的主题。而且尽管如此，我几乎可以确定大多数非平凡的单页应用程序都会遭受内存泄漏的影响-除非处理它们的团队拥有可靠的工具来检测和修复此问题。这里的要点是，在JavaScript中，随机分配一定数量的内存，然后忘记释放该内存非常容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章的作者（我们今天将发表其翻译版本）将与读者分享他在解决Web应用程序中的内存泄漏方面的经验，并希望举例说明其有效检测。</font></font><br>
<cut></cut><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么这么少写？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我想谈谈为什么很少写关于内存泄漏的文章。</font><font style="vertical-align: inherit;">我想在这里您可以找到几个原因：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺乏用户抱怨：大多数用户在浏览Web时并不忙于密切监视任务管理器。</font><font style="vertical-align: inherit;">通常，在内存泄漏严重到导致无法工作或降低应用程序速度之前，开发人员不会遇到用户的抱怨。</font></font></li>
<li>  :   Chrome   -   ,     .          .</li>
<li> :            .</li>
<li>      :       «»     .   ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>,   -.</li>
</ul><br>
<h2><font color="#3AC1EF">  </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于开发Web应用程序的现代库和框架（例如React，Vue和Svelte）使用应用程序的组件模型。在此模型中，导致内存泄漏的最常见方法是这样的：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样。</font><font style="vertical-align: inherit;">这就是为项目“配备”内存泄漏所需的全部工具。</font><font style="vertical-align: inherit;">为此，只需调用</font><font style="vertical-align: inherit;">某些全局对象（例如</font><font style="vertical-align: inherit;">，或</font><font style="vertical-align: inherit;">或类似的东西）</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，然后在卸载组件时，忘记使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">removeEventListener</font></a><font style="vertical-align: inherit;">方法删除事件侦听</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">器</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
但是，这样做的后果甚至更糟，因为会发生整个组件的泄漏。</font><font style="vertical-align: inherit;">这是由于该方法已</font><font style="vertical-align: inherit;">附加到</font><font style="vertical-align: inherit;">的事实</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">与此组件一起，发生其子组件的泄漏。</font><font style="vertical-align: inherit;">与该组件关联的所有DOM节点很可能会泄漏。</font><font style="vertical-align: inherit;">结果，这种情况可能会很快失控，从而导致非常严重的后果。</font></font><code>window</code><font style="vertical-align: inherit;"></font><code>&lt;body&gt;</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>this.onMessage</code><font style="vertical-align: inherit;"></font><code>this</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决此问题的方法如下：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">this</span>.onMessage = <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存泄漏最常发生的情况</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经验告诉我，使用以下API时，内存泄漏最常发生：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是最经常发生内存泄漏的地方。</font><font style="vertical-align: inherit;">要解决该问题，在正确的时间打电话就足够了</font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">setTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">setInterval</a>.   ,        (,  30 ),  ,   ,      ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clearTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clearInterval</a>. ,    <code>setTimeout</code>,  «»   ,    ,     <code>setInterval</code>-.  ,    <code>setTimeout</code>       .</li>
<li>API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IntersectionObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ResizeObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MutationObserver</a>   .  ,  ,  .         .     -         ,  ,   ,     ,   ,   <code>disconnect</code>  .    ,     DOM    ,           ,  -.        -,     .  —  <code>&lt;body&gt;</code>,  <code>document</code>,   <code>header</code>  <code>footer</code>,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Promise-</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>      .   ,    ,     —   ,      . , ,  «»   ,        .    «»     <code>.then()</code>-.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由全局对象表示的存储库。</font><font style="vertical-align: inherit;">当您使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux之类的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">东西来控制应用程序</font><font style="vertical-align: inherit;">的状态时，状态存储由全局对象表示。</font><font style="vertical-align: inherit;">结果，如果您不小心处理此类存储，则不会从其中删除不必要的数据，结果，其大小将不断增加。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无限的DOM增长。</font><font style="vertical-align: inherit;">如果该页面在不使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟化的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况下实现了无限滚动</font><font style="vertical-align: inherit;">，则意味着该页面上的DOM节点数可以无限增加。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面，我们检查了内存泄漏最常发生的情况，但是，当然，还有许多其他情况导致我们感兴趣的问题。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存泄漏识别</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们进入了识别内存泄漏的挑战。首先，我认为任何现有工具都不适合于此。我尝试了Firefox内存分析工具，还尝试了Edge和IE中的工具。测试了Windows Performance Analyzer。但是，这些工具中最好的还是Chrome开发者工具。的确，在这些工具中有许多“尖角”，这是值得了解的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Chrome开发人员提供的工具中，我们最感兴趣</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的选项卡</font><font style="vertical-align: inherit;">是Profiler </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可让您创建堆快照。还有其他用于在Chrome中分析内存的工具，但我无法从中提取出检测内存泄漏的特殊好处。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/e42/63a/e7de4263abd59eecce420c4bcbfc55ea.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆快照工具可让您对主流，Web worker或iframe元素的内存进行快照。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果Chrome工具窗口类似于上图所示，则当您单击按钮时</font></font><code>Take snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将捕获有关所选虚拟机内存中所有对象的信息。被调查页面的JavaScript。这包括在中</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引用的对象，在调用中使用的回调引用的对象</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，等等。内存快照可被视为被调查实体工作的“冻结时刻”，代表有关该实体使用的所有内存的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拍照后，我们进入寻找泄漏的下一步。它在于重现一种场景，在这种场景下，根据开发人员的说法，可能发生内存泄漏。例如，它正在打开和关闭某个模式窗口。关闭类似的窗口后，预期分配的内存量将返回到打开窗口之前的水平。因此，他们会拍摄另一张照片，然后将其与之前拍摄的照片进行比较。实际上，图像比较是我们感兴趣的最重要的特征</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/776/4c7/92d7764c7fbe5d561032c3bc092e1541.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们拍摄第一个快照，然后执行可能导致内存泄漏的操作，然后拍摄另一个快照。</font><font style="vertical-align: inherit;">如果没有泄漏，分配的内存大小将是相等的，</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的确，这</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">远非理想的工具。</font><font style="vertical-align: inherit;">它有一些局限性值得了解：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使单击</font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始垃圾收集</font><font style="vertical-align: inherit;">的面板上的小按钮</font><font style="vertical-align: inherit;">（</font></font><code>Collect garbage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），也要确保确实清除了内存，您可能需要连续拍摄几张照片。</font><font style="vertical-align: inherit;">我通常有三枪。</font><font style="vertical-align: inherit;">这里值得关注每个图像的总大小-最后应该稳定下来。</font></font></li>
<li>    -, -,  <code>iframe</code>,      ,   ,          .   ,        JavaScript.   —      ,       ,    .</li>
<li>           «».             .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此时，如果您的应用程序非常复杂，则在比较快照时您可能会注意到很多“泄漏”对象。</font><font style="vertical-align: inherit;">这里的情况有些复杂，因为并非总是会被误认为是内存泄漏。</font><font style="vertical-align: inherit;">可疑的大部分只是用于处理对象的正常过程。</font><font style="vertical-align: inherit;">清除某些对象占用的内存，以将其他对象放置在此内存中，将某些内容刷新到缓存中，以便不会立即清除相应的内存，依此类推。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们克服信息噪音</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我发现突破信息噪声的最好方法是重复那些可能导致内存泄漏的操作。例如，代替在捕获第一张照片后仅打开和关闭模态窗口一次，这可以完成7次。为什么是7？是的，只是因为7是一个引人注目的素数。然后，您需要拍摄第二张照片，并将其与第一张照片进行比较，以确定某个物体是否“泄漏”了7次（或14次或21次）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/ac2/243/2a7ac2243dc82f0e7887b23098e7c893.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较堆快照。请注意，我们正在比较3号图和6号图。事实是，我连续拍摄了三张照片，这样Chrome会有更多的垃圾回收会话。此外，请注意，有些物体“泄漏”了7次，</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
另一个有用的窍门是，在研究开始时，在创建第一张图片之前，请执行一次该过程，然后按预期进行：内存泄漏。如果在项目中使用代码拆分，则特别推荐这样做。在这种情况下，很可能在首次执行可疑操作时，将加载必要的JavaScript模块，这将影响分配的内存量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可能有一个问题，为什么您应该特别注意对象的数量，而不是总的内存量。在这里我们可以说我们在直觉上努力减少“泄漏”内存的数量。在这方面，您可能认为应该监视所使用的内存总量。但是，由于一个重要原因，这种方法不太适合我们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果某事“泄漏”，是因为（拒绝</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joe Armstrong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）您需要一根香蕉，但最终得到的是香蕉，容纳它的大猩猩，以及整个丛林。如果我们专注于内存总量，那将与“测量”丛林相同，而不是让我们感兴趣的香蕉。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/af8/847/7e8af8847ab7e8689e1638ac218582d6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大猩猩在吃香蕉，</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
现在回到上面的例子</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。泄漏源是引用函数的事件侦听器。而此功能又是指可能会存储指向一堆好东西（例如数组，字符串和对象）的链接的组件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您分析图像之间的差异，并按照实体所占用的内存量对其进行排序，则可以查看许多阵列，线，对象，其中大多数与泄漏无关。毕竟，我们需要找到所有事件的监听器。与他所指的相比，他几乎没有记忆。为了修复泄漏，您需要找到一根香蕉，而不是丛林。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，如果按“泄漏”对象的数量对记录进行排序，则会发现7个事件侦听器。</font><font style="vertical-align: inherit;">也许有7个组件和14个子组件，也许还有其他类似的东西。</font><font style="vertical-align: inherit;">这个数字7应该从全局中脱颖而出，因为它仍然是一个相当引人注目的且不寻常的数字。</font><font style="vertical-align: inherit;">在这种情况下，重复可疑动作多少次并不重要。</font><font style="vertical-align: inherit;">检查图像时，如果怀疑是合理的，则将记录尽可能多的“泄漏”对象。</font><font style="vertical-align: inherit;">这样可以快速确定内存泄漏的来源。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接树分析</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于创建快照的工具提供了查看“链接链”的功能，这些链接可帮助您找出其他对象引用了哪些对象。</font><font style="vertical-align: inherit;">这就是允许应用程序运行的原因。</font><font style="vertical-align: inherit;">通过分析链接的“链”或“树”，您可以准确地找到为“泄漏”对象分配的内存。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/77a/07d/7bf77a07dd2d15e479f77c2279b9942d.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接链使您可以找出哪个对象引用了“泄漏”对象。</font><font style="vertical-align: inherit;">在阅读这些链时，有必要考虑位于它们下面的对象是指位于上面的对象，</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在上面的示例中，</font><font style="vertical-align: inherit;">事件侦听器引用</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的闭包（</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中</font><font style="vertical-align: inherit;">有一个称为</font><font style="vertical-align: inherit;">referenced</font><font style="vertical-align: inherit;">的变量</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果单击指向源代码的链接，将显示该程序相当容易理解的文本：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> () </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> someObject = <span class="hljs-keyword">new</span> SomeObject();
<span class="hljs-keyword">const</span> onMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, onMessage);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们将此代码与上一个图进行比较，结果发现</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该图是</font></font><code>onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引用</font><font style="vertical-align: inherit;">的闭包</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人为的例子</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际内存泄漏可能不那么明显。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得注意的是，堆快照工具有一些限制：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果保存快照文件然后再次上传，则带有代码的文件的链接将丢失。</font><font style="vertical-align: inherit;">也就是说，例如，下载了快照后，将不可能发现事件侦听器关闭代码在文件的第22行上</font></font><code>foo.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于此信息非常重要，因此保存堆快照文件或将其传输给某人几乎是无用的。</font></font></li>
<li>     <code>WeakMap</code>,  Chrome       ,      . ,   ,     ,    ,   .    <code>WeakMap</code> —     .</li>
<li>Chrome  ,    .  ,        ,     ,     ,     .      ,       <code>object</code>,    <code>EventListener</code>.   <code>object</code> —     ,  ,   ,  «»   7  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是对我识别内存泄漏的基本策略的描述。</font><font style="vertical-align: inherit;">我已经成功地使用了这种技术来检测许多泄漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没错，我必须说，这份查找内存泄漏的指南仅涵盖了现实中的一小部分。</font><font style="vertical-align: inherit;">这仅仅是工作的开始。</font><font style="vertical-align: inherit;">此外，您需要能够处理断点的安装，记录日志，测试更正，以确定它们是否解决了问题。</font><font style="vertical-align: inherit;">而且，不幸的是，从本质上讲，所有这些都转化为对时间的认真投入。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动内存泄漏分析</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想以无法自动检测内存泄漏的好方法开始这一部分。 Chrome拥有自己的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance.memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">，但出于隐私原因，它</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不允许您</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收集足够详细的数据。结果，该API不能用于生产中以检测泄漏。 W3C Web性能工作组先前讨论了</font><font style="vertical-align: inherit;">内存</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工具</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但其成员尚未就旨在替代该API的新标准达成共识。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在测试环境中，您可以</font></font><code>performance.memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Chrome标志</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">--enable-precise-memory-info</font></a><font style="vertical-align: inherit;">来增加数据输出的粒度</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。仍然可以使用Chromedriver自己的团队创建堆快照</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：takeHeapSnapshot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该团队具有我们已经讨论过的相同限制。如果您使用此命令，则由于上述原因，有可能要对其进行三次调用，然后仅取回最后一次调用所收到的内容，这很有可能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于事件侦听器是最常见的内存泄漏源，因此我将介绍我使用的另一种泄漏检测技术。它包括在创造的API猴子补丁</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在计数的链接，以检查他们的数量归零。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何完成此操作的示例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Chrome开发人员工具中，您还可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getEventListeners</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本机API </font><font style="vertical-align: inherit;">找出将哪些事件侦听器附加到特定元素。</font><font style="vertical-align: inherit;">但是，此命令仅在开发人员工具栏中可用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想补充一点，Matthias Binens告诉我了另一个有用的Chrome工具API。</font><font style="vertical-align: inherit;">这些是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queryObjects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用它，您可以获得有关使用特定构造函数创建的所有对象的信息。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关在Puppeteer中自动进行内存泄漏检测的一些很好的材料。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Web应用程序中搜索和修复内存泄漏仍处于起步阶段。在这里，我谈到了一些性能良好的技术。但是应该认识到，这些技术的应用仍然充满某些困难和耗时。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如他们所说的，与任何性能问题一样，提前捏值得一磅。也许有人会发现准备适当的综合测试而不是在泄漏发生后进行分析是有用的。如果不是一个泄漏而是多个泄漏，那么对问题的分析可能会变成洋葱剥皮：解决一个问题后，发现另一个问题，然后重复此过程（并且一直如此，就像洋葱一样） ，眼泪）。代码审查还可以帮助确定常见的泄漏模式。但这（如果您知道）在哪里看。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript是一种可以安全使用内存的语言。</font><font style="vertical-align: inherit;">因此，具有讽刺意味的是，Web应用程序中发生内存泄漏的难易程度。</font><font style="vertical-align: inherit;">没错，这部分是由于设备用户界面的功能。</font><font style="vertical-align: inherit;">您需要听很多事件：鼠标事件，滚动事件，键盘事件。</font><font style="vertical-align: inherit;">应用所有这些模式很容易导致内存泄漏。</font><font style="vertical-align: inherit;">但是，努力确保我们的Web应用程序可以节余地使用内存，我们可以提高其性能并保护它们免受“崩溃”的影响。</font><font style="vertical-align: inherit;">另外，我们由此证明了对用户设备资源限制的尊重。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲爱的读者们！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您是否在Web项目中遇到内存泄漏？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490610/index.html">百度在加利福尼亚机器人移动自主性评级中击败Waymo</a></li>
<li><a href="../zh-CN490612/index.html">在Scala上进行交易的实用方法或编写自己有用的monad</a></li>
<li><a href="../zh-CN490616/index.html">上周第404期（2020年2月24日至3月1日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN490618/index.html">Goroutine堆栈缓冲区</a></li>
<li><a href="../zh-CN490620/index.html">当我听到“恢复神经网络”一词时，我爬上去检查备份</a></li>
<li><a href="../zh-CN490624/index.html">功能策略HTTP标头和Web浏览器控件</a></li>
<li><a href="../zh-CN490626/index.html">有关数据的完整指南* HTML属性</a></li>
<li><a href="../zh-CN490628/index.html">CSS阻止页面解析时该怎么办？</a></li>
<li><a href="../zh-CN490630/index.html">从磁盘加载NumPy数组：比较memmap（）和Zarr / HDF5</a></li>
<li><a href="../zh-CN490634/index.html">3月2日至8日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>