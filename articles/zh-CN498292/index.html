<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏾 ⛳️ 👨🏻‍⚖️ 在PostgreSQL中节省大量资金 🐄 🌾 🤛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="继续上一章有关分区的文章中提出的记录大数据流的主题，在此，我们考虑减少 PostgreSQL中存储的“物理”大小的方法及其对服务器性能的影响。
 
 这与TOAST设置和数据对齐有关。“平均”而言，这些方法不会节省太多资源，但不会对应用程序代码进行任何修改。
 
 
 但是，事实证明，在这方面我们的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在PostgreSQL中节省大量资金</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498292/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续上一章</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关分区的文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出的记录大数据流的主题</font><font style="vertical-align: inherit;">，在此，我们考虑</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减少</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PostgreSQL中</font><b><font style="vertical-align: inherit;">存储的“物理”大小的方法</font></b><font style="vertical-align: inherit;">及其对服务器性能的影响。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TOAST设置和数据对齐有关</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">“平均”而言，这些方法不会节省太多资源，但不会对应用程序代码进行任何修改。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cj/c-/lx/cjc-lxht8brbyy9xif_sicdwk70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，事实证明，在这方面我们的经验非常有用，因为几乎所有监视的存储库本质上</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都只能</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在记录数据方面</font><b><font style="vertical-align: inherit;">追加</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且，如果您对如何教数据库写磁盘而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200MB / s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感兴趣，那么</font><font style="vertical-align: inherit;">我会要求削减。</font></font><br>
<a name="habracut"></a><br>
<font color="#4060a0"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大数据的小秘密</font></font></h2></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们服务</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的概况</font><font style="vertical-align: inherit;">，他定期从日志中接收</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文本包</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，由于</font><font style="vertical-align: inherit;">我们正在监控其数据库</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的VLSI复合体</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是具有复杂数据结构的多组件产品，</font><font style="vertical-align: inherit;">因此通过</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">具有复杂算法逻辑的“多卷”</font></a><font style="vertical-align: inherit;">即可获得</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现最高性能的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查询</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，到达我们的日志中的每个请求实例或生成的执行计划的数量实际上是“平均”的。</font><font style="vertical-align: inherit;">
让我们看一下其中写入“原始”数据的表的结构-即，这是日志条目中的原始文本：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> rawdata_orig(<font></font>
  pack <span class="hljs-comment">-- PK</span>
    <span class="hljs-keyword">uuid</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
, recno <span class="hljs-comment">-- PK</span>
    <span class="hljs-built_in">smallint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
, dt <span class="hljs-comment">--  </span>
    <span class="hljs-built_in">date</span>
, <span class="hljs-keyword">data</span> <span class="hljs-comment">--  </span>
    <span class="hljs-built_in">text</span>
, PRIMARY <span class="hljs-keyword">KEY</span>(pack, recno)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样一个典型的板块（当然已经分区了，因此它是一个节模板），其中最重要的是文本。有时相当庞大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回想一下，PG中一条记录的“物理”大小不能占用一页以上的数据，但是“逻辑”大小是完全不同的事情。要将体积值（varchar /文本/ bytea）写入字段，使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TOAST技术</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL使用固定的页面大小（通常为8 KB），并且不允许元组跨越多个页面。</font><font style="vertical-align: inherit;">因此，不可能直接存储非常大的字段值。</font><font style="vertical-align: inherit;">为了克服此限制，将大的字段值压缩和/或拆分为几条物理线。</font><font style="vertical-align: inherit;">用户不会注意到这种情况，并且会稍微影响大多数服务器代码。</font><font style="vertical-align: inherit;">这种方法被称为TOAST ...</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，对于具有“潜在大”字段的每个表</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">创建一个配对表，并将</font></a><font style="vertical-align: inherit;">每个“大”记录</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">“切片”</font></a><font style="vertical-align: inherit;">成2KB的段：</font></font><br>
<br>
<pre><code class="sql hljs">TOAST(<font></font>
  chunk_id<font></font>
    integer<font></font>
, chunk_seq<font></font>
    integer<font></font>
, chunk_data<font></font>
    bytea<font></font>
, PRIMARY KEY(chunk_id, chunk_seq)<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，如果我们必须写一个具有“大”值的行</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么实际记录</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会出现</font><b><font style="vertical-align: inherit;">在主表及其PK中，还会出现在TOAST及其PK中</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低TOAST效果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是这里的大多数记录仍然不是很大，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们应该适合8KB-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您将如何保存呢？.. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>STORAGE</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，表列</font><font style="vertical-align: inherit;">的属性对我们有帮助</font><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXTENDED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许压缩和单独存储。</font><font style="vertical-align: inherit;">这是</font><font style="vertical-align: inherit;">大多数与TOAST兼容的数据类型</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准选项</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先，尝试执行压缩，如果行仍然太大，则将其保存在表外。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAIN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许压缩，但不允许单独存储。</font><font style="vertical-align: inherit;">（但是，实际上，将为此类列执行单独的存储，但这只是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后的选择</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当没有其他方法可以减少该行以使其适合页面时。）</font></font></li>
</ul></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，这正是我们需要的文本- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽可能地</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对其进行</font><b><font style="vertical-align: inherit;">压缩，即使根本不合适，也可以将其放入TOAST中</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以使用以下命令直接“即时”执行此操作：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> rawdata_orig <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">STORAGE</span> <span class="hljs-keyword">MAIN</span>;</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何评估效果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于数据流每天都在变化，因此我们无法比较绝对数字，但是相对而言，</font><font style="vertical-align: inherit;">我们在TOAST中记录</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的比例越小</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">越好。</font><font style="vertical-align: inherit;">但是存在危险-每个记录的“物理”量越大，索引就越“宽”，因为必须覆盖更多的数据页。</font><b><font style="vertical-align: inherit;">更改前的</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
部分</font><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<pre><code class="plaintext hljs">heap  = 37GB (39%)<font></font>
TOAST = 54GB (57%)<font></font>
PK    =  4GB ( 4%)<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改后的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
部分</font><font style="vertical-align: inherit;">：</font></font><br>
<pre><code class="plaintext hljs">heap  = 37GB (67%)<font></font>
TOAST = 16GB (29%)<font></font>
PK    =  2GB ( 4%)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，我们</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始写TOAST的频率降低了2倍</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这不仅卸载了磁盘，还卸载了CPU：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/te/dr/jctedr4gcninasuw54qer9qu_8u.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/lj/wr/bpljwrysoy42rtnu3ds0btue7ka.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我注意到，我们还开始减少了对磁盘的“读取”，而不仅仅是“写入”了-因为在将记录插入某个表中时，还必须“减去”每个索引树的一部分，以确定其在索引中的未来位置。</font></font><br>
<br>
<font color="#4060a0"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁在PostgreSQL 11上过得很好</font></font></h2></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
升级到PG11后，我们决定继续“调整” TOAST，并注意到从该版本开始，该参数可用于配置</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>toast_tuple_target</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅当要存储在表中的行值大于TOAST_TUPLE_THRESHOLD字节（通常为2 Kb）时，才会触发TOAST处理代码。</font><font style="vertical-align: inherit;">TOAST代码将压缩和/或将字段值移出表，直到行值小于TOAST_TUPLE_TARGET字节（可变，通常也为2 KB）或无法减小大小为止。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们认为我们通常拥有的数据是“非常短”或立即“非常长”，因此我们决定将自己限制为尽可能低的值：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> rawplan_orig <span class="hljs-keyword">SET</span> (toast_tuple_target = <span class="hljs-number">128</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看新设置如何影响迁移后的磁盘加载：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/pp/cz/k7/ppczk7f8qj9cu_hixtltdk_wvo4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不错！</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磁盘</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的平均</font><b><font style="vertical-align: inherit;">队列减少了</font></b><font style="vertical-align: inherit;">约1.5倍，磁盘“占用率”降低了20％！</font><font style="vertical-align: inherit;">但是，也许这以某种方式影响了CPU？</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xa/vj/sq/xavjsqger1hmawiiidzngvzcff0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至少，它绝对没有恶化。</font><font style="vertical-align: inherit;">虽然，即使这样的卷仍然无法将平均CPU负载提高到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5％</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上，却很难判断</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<font color="#4060a0"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从位置改变，总和...改变！</font></font></h2></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所知，一分钱可以节省卢布，而且由于我们的存储量约为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10TB /月，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使是很小的优化也可以带来可观的利润。因此，我们提请注意数据的物理结构- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“字段”在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各表</font><b><font style="vertical-align: inherit;">的记录中的布局方式</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因为由于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据对齐，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这直接</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影响最终的体积</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多架构都提供跨机器字边界的数据对齐方式。</font><font style="vertical-align: inherit;">例如，在x86 32位系统上，整数（整数类型，占4个字节）将在4字节字的边界以及双精度浮点数（双精度类型，8字节）的边界对齐。</font><font style="vertical-align: inherit;">并且在64位系统上，双精度值将在8字节字的边界上对齐。</font><font style="vertical-align: inherit;">这是不兼容的另一个原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于对齐，表行的大小取决于字段的顺序。</font><font style="vertical-align: inherit;">通常，这种影响不是很明显，但是在某些情况下，可能会导致尺寸显着增加。</font><font style="vertical-align: inherit;">例如，如果将类型为char（1）和整数混合的字段放在它们之间，通常，将浪费3个字节而没有任何浪费。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从综合模型开始：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> pg_column_size(<span class="hljs-keyword">ROW</span>(
  <span class="hljs-string">'0000-0000-0000-0000-0000-0000-0000-0000'</span>::<span class="hljs-keyword">uuid</span>
, <span class="hljs-number">0</span>::<span class="hljs-built_in">smallint</span>
, <span class="hljs-string">'2019-01-01'</span>::<span class="hljs-built_in">date</span><font></font>
));<font></font>
<span class="hljs-comment">-- 48 </span><font></font>
<font></font>
<span class="hljs-keyword">SELECT</span> pg_column_size(<span class="hljs-keyword">ROW</span>(
  <span class="hljs-string">'2019-01-01'</span>::<span class="hljs-built_in">date</span>
, <span class="hljs-string">'0000-0000-0000-0000-0000-0000-0000-0000'</span>::<span class="hljs-keyword">uuid</span>
, <span class="hljs-number">0</span>::<span class="hljs-built_in">smallint</span><font></font>
));<font></font>
<span class="hljs-comment">-- 46 </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一种情况下，多余的一对字节来自哪里？</font><font style="vertical-align: inherit;">一切都很简单</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2字节smallint</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一个字段之前在</font><b><font style="vertical-align: inherit;">4字节边界上对齐</font></b><font style="vertical-align: inherit;">，当它是最后一个字段时，没有任何内容，也不需要对齐它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从理论上讲，一切都很好，您可以根据需要重新排列字段。</font><font style="vertical-align: inherit;">让我们在其中一个表的示例上检查真实数据，该表的每日部分占用10-15GB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
源结构：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> public.plan_20190220<font></font>
(<font></font>
<span class="hljs-comment">--  from table plan:  pack uuid NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  recno smallint NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  host uuid,</span>
<span class="hljs-comment">--  from table plan:  ts timestamp with time zone,</span>
<span class="hljs-comment">--  from table plan:  exectime numeric(32,3),</span>
<span class="hljs-comment">--  from table plan:  duration numeric(32,3),</span>
<span class="hljs-comment">--  from table plan:  bufint bigint,</span>
<span class="hljs-comment">--  from table plan:  bufmem bigint,</span>
<span class="hljs-comment">--  from table plan:  bufdsk bigint,</span>
<span class="hljs-comment">--  from table plan:  apn uuid,</span>
<span class="hljs-comment">--  from table plan:  ptr uuid,</span>
<span class="hljs-comment">--  from table plan:  dt date,</span>
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190220_pkey PRIMARY <span class="hljs-keyword">KEY</span> (pack, recno),
  <span class="hljs-keyword">CONSTRAINT</span> chck_ptr <span class="hljs-keyword">CHECK</span> (ptr <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>),
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190220_dt_check <span class="hljs-keyword">CHECK</span> (dt = <span class="hljs-string">'2019-02-20'</span>::<span class="hljs-built_in">date</span>)<font></font>
)<font></font>
INHERITS (public.plan)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更改列顺序之后的部分是完全相同</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的字段，只是顺序不同</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> public.plan_20190221<font></font>
(<font></font>
<span class="hljs-comment">--  from table plan:  dt date NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  ts timestamp with time zone,</span>
<span class="hljs-comment">--  from table plan:  pack uuid NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  recno smallint NOT NULL,</span>
<span class="hljs-comment">--  from table plan:  host uuid,</span>
<span class="hljs-comment">--  from table plan:  apn uuid,</span>
<span class="hljs-comment">--  from table plan:  ptr uuid,</span>
<span class="hljs-comment">--  from table plan:  bufint bigint,</span>
<span class="hljs-comment">--  from table plan:  bufmem bigint,</span>
<span class="hljs-comment">--  from table plan:  bufdsk bigint,</span>
<span class="hljs-comment">--  from table plan:  exectime numeric(32,3),</span>
<span class="hljs-comment">--  from table plan:  duration numeric(32,3),</span>
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190221_pkey PRIMARY <span class="hljs-keyword">KEY</span> (pack, recno),
  <span class="hljs-keyword">CONSTRAINT</span> chck_ptr <span class="hljs-keyword">CHECK</span> (ptr <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>),
  <span class="hljs-keyword">CONSTRAINT</span> plan_20190221_dt_check <span class="hljs-keyword">CHECK</span> (dt = <span class="hljs-string">'2019-02-21'</span>::<span class="hljs-built_in">date</span>)<font></font>
)<font></font>
INHERITS (public.plan)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该部分的总容量由“事实”的数量决定，并且仅取决于外部进程，因此我们将heap（</font></font><code>pg_relation_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的大小除以其中</font><font style="vertical-align: inherit;">的记录数，即得到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际存储记录</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">平均大小</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/6e/im/jx6eimznnvdqtrzp6aohdvxluzs.png"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减去6％的音量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，非常好！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，所有事情当然都不是那么乐观-因为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在索引中我们无法更改字段的顺序</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此“一般”（</font></font><code>pg_total_relation_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）...</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/az/3m/6z/az3m6zsyv47wtawrbk_tdmwdpfg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...毕竟，他们</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里节省了1.5％</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而无需更改任何代码行。</font><font style="vertical-align: inherit;">是的是的！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/dr/ps/gbdrpsonli0eclk4ozdjjtofnda.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我注意到上述领域的安排并不是最佳的事实。</font><font style="vertical-align: inherit;">因为某些字段块出于美学原因不希望被“撕开”，例如，一对</font></font><code>(pack, recno)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该表为PK。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，“最小”字段排列的定义是相当简单的“穷举”任务。</font><font style="vertical-align: inherit;">因此，您可以获得比我们的数据更好的结果-试试吧！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498280/index.html">凤凰属的渡渡鸟的故事。渡渡鸟大倒塌IS</a></li>
<li><a href="../zh-CN498282/index.html">[说明]在Google Site平台上创建帐户和网站</a></li>
<li><a href="../zh-CN498284/index.html">如何优化英语学习</a></li>
<li><a href="../zh-CN498288/index.html">您的城市需要地铁</a></li>
<li><a href="../zh-CN498290/index.html">程序水文学：河流和湖泊的动态模拟</a></li>
<li><a href="../zh-CN498294/index.html">物体检测 认识和统治。第1部分</a></li>
<li><a href="../zh-CN498296/index.html">在系统级别进行设计。第1部分。从概念到系统</a></li>
<li><a href="../zh-CN498298/index.html">公司利用漏洞赏金来购买黑客的沉默</a></li>
<li><a href="../zh-CN498300/index.html">Blitz.Engine：资产系统</a></li>
<li><a href="../zh-CN498302/index.html">国际劳工组织高级许可证。为什么现在需要它？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>