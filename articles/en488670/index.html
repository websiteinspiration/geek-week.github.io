<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏿 📭 🐴 About mask registers 👩🏻‍🤝‍👨🏽 💃🏼 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The AVX-512 instruction set included eight so-called mask registers [1] - from k0 [2] to k7 . They are suitable for use with most ALU operations and a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>About mask registers</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/488670/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The AVX-512 instruction set included eight so-called mask registers [1] - from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [2] to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . They are suitable for use with most ALU operations and allow you to perform mask operations on vector elements with zeroing or merging data in the destination register [3], thereby speeding up the work of the code, which would require additional merge operations in the AVX2 instruction set and earlier versions . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the above is not enough to make you a follower of the cult of mask registers, I will quote an excerpt from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which, I hope, will help you finally figure it out:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most AVX-512 commands can use the operand mask corresponding to one of 8 mask registers (k0 – k7). If the mask register is used as the mask of the operation, the register k0 behaves differently than the rest of the mask registers: in this case, it acts as a hard-coded constant indicating that the mask is not used with this operation. However, in arithmetic and logical operations and when writing values ​​to mask registers, k0 behaves like a normal working register. In most commands, mask registers are used as a mask that determines which items should be written to the output register. The behavior of the operand mask depends on the flag: if it is set, all unselected elements will be reset (“zeroing” mode, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), if not, all unselected elements retain their previous state ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merge</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mode, </font><i><font style="vertical-align: inherit;">merge</font></i><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Merge mode has the same effect as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blend instructions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, mask registers [4] are an important innovation, but they are rarely remembered in contrast to, say, general purpose registers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rsi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and others) or SIMD registers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xmm0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ymm5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc.). </font><font style="vertical-align: inherit;">In Intel presentations, which show the sizes of microarchitecture resources, mask registers are not mentioned:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xa/ty/eq/xatyeq9cozm0-7xfqmlxg4caffo.png" alt="image"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As far as I know, information about the size of the physical register file ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physical register file, PRF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of mask registers has also never been published. Now we will fix it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I used a modified version of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tool for measuring the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> size of the reordering buffer of commands ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROB</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), which was created and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">described by Henry Wong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [5] (hereinafter simply Henry). Using this tool, he calculated the size of documented and undocumented structures of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extraordinary execution</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in previous architectures. If you have not read Henry’s note, stop and return to it. And my article will wait. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, read? For harm, here is a summary of Henry's article:</font></font><br>
<br>
<h2>     ROB</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A number of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ballast instructions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are </font><font style="vertical-align: inherit;">inserted between two read instructions with a cache miss [6] </font><font style="vertical-align: inherit;">- their exact number will depend on what processor resource we want to measure. If there are not very many ballast commands, both cache misses will be processed in parallel, so their delays will overlap and the total execution time will be approximately [7] as much as it would take for one cache miss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, if the number of ballast teams exceeds a certain critical threshold, the corresponding resource will be completely exhausted and the placement of teams in the ROB will stop before the second command with a cache miss is issued. In this case, their parallel processing will be impossible and the total time will almost double the time of one such operation, which will be reflected in the graph as a sharp jump.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, the test is written so that the teams use exactly one unit of the resource being checked - in this case, the peak peak on the graph will indicate its total volume. </font><font style="vertical-align: inherit;">So, standard general-purpose commands, as a rule, use one physical register from general-purpose PRF registers and therefore are ideal for measuring the volume of a given resource.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Size of the physical register file of mask registers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this test, we will execute commands that write the value to mask registers to find out the PRF size of these registers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a series of teams </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd k1, k2, k3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (16 ballast teams shown):</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]  ;    -<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]  ;    -<font></font>
lfence                      ;      ,    <font></font>
                            ;   <font></font>
;     <span class="hljs-number">16</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">consumes one physical mask register. If the number of ballast commands is less than or equal to the number of mask registers, cache misses will be processed in parallel, otherwise in sequential mode. So, when switching from parallel to serial mode, we should see a sharp jump on the graph, indicating an increase in execution time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is exactly what we are observing: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/0u/0s/gu0u0s6phxsglrya170shjhls30.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let’s take a closer look at the rise: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ix/ve/yl/ixveylwsz7jjcbdwnoxcfqynjbu.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we now see, the jump is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not so sharp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : with the number of ballast commands from 130 to 134, the execution speed takes intermediate values ​​between the minimum and maximum levels. Henry calls this behavior </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imperfect</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; I observed it in many of these tests, although not in all. The fact is that the implementation of the hardware does not always allow a complete exhaustion of the resource as it approaches the limit [8] - in some cases this succeeds, in others there are only a few teams missing to a theoretical maximum. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this regard, we are interested in the penultimate ascent point, in which the speed is still higher than in slow mode. This point indicates the number of resource units available to us, which means that there are at least as many physical registers. As you can see, in this case it is at around 134. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, SKX </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has 134 physical registers capable of storing speculative (obtained with anticipatory execution) values ​​of mask registers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Henry suggests that 8 more are used to store the current architectural state of eight mask registers, so the full amount of their PRF can be estimated at 142. This is slightly smaller than the size of the files for general purpose registers (180) and SIMD registers (168), but still quite a lot (see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table of sizes of resources of extraordinary execution</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for other platforms). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say this file is large enough so that in practice we do not have time to completely occupy it: it is difficult to imagine real code in which almost 60% [9] of the commands write [10] to mask registers - namely, so many of them will be required to exhaust this resource .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Are these different registry files?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you must have noticed, so far I have </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assumed by default</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that mask register PRFs are a separate file that does not intersect other types of register files. I believe that this is very likely based on the principle of operation of mask registers and the fact that they are part of a separate domain for register renaming [11]. Another argument in favor of my assumption is the fact that the observed size of the PRF mask registers does not match the size of the general-purpose register file or the SIMD register file. Actually, we can take and test this with a test! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This test is similar to the previous one, but now </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd commands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will alternate with commands that use either general purpose registers or SIMD registers. If mask registers are combined with the first or second in the same register file, the jump in the graph should indicate the size of the corresponding PRF. If the register files are not combined, we will come across some other limit, which will not be equal to the size of either of the two register files, but will be equal, for example, to the size of ROB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test 29</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd commands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and scalar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commands </font><font style="vertical-align: inherit;">alternate </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]<font></font>
lfence</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We look at the graph: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vh/ew/hc/vhewhcthcquksk66f8wircsk6n4.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, the number of ballast teams, which accounts for the peak, is larger than the sizes of PRF general purpose registers and mask registers. </font><font style="vertical-align: inherit;">From this we conclude that mask registers are not included in the general-purpose register file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then maybe they are included in the SIMD register file? </font><font style="vertical-align: inherit;">After all, mask registers are more associated with SIMD commands than with general purpose commands. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To find out, we will use test 35, which is identical to test 29 with the difference that here the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd commands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alternate with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commands </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]<font></font>
vxorps ymm0,ymm0,ymm1<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm2,ymm2,ymm3<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm4,ymm4,ymm5<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm6,ymm6,ymm7<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm0,ymm0,ymm1<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm2,ymm2,ymm3<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm4,ymm4,ymm5<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]<font></font>
lfence</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Graph: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/66/r4/zj/66r4zjzixtvauqfascucqdqk5tq.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this test, the same behavior is observed as in the previous one, so we conclude that the register files of mask registers and SIMD registers are also separated.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsolved Mystery</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nevertheless, in both tests, the end of the peak falls at about 212 commands, while the ROB size for this microarchitecture is 224. Maybe this is just an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imperfect behavior</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that we already observed earlier? Well, let's check this: compare the results of these two tests with the results of test 4, in which only </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commands are used as ballast commands </font><font style="vertical-align: inherit;">: except for ROB, they should not consume any other resources. Compare the graphs of test 4 ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and test 29 ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and scalar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alternate </font><font style="vertical-align: inherit;">): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/1y/re/ch1yream9tyqh6opy8t2343ai0q.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the beginning of the slow mode falls exactly at the 224 mark (vector images, so you can increase them and see for yourself). It turns out that 212 (from this point the slow mode starts when alternating mask registers with general registers or SIMD registers) - this is the limit of some other resource. In fact, we encounter the same limitation even when we alternate general registers and SIMD registers - compare test 4 and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test 21</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (it combines the addition commands in general registers and SIMD </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps commands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fg/ha/2r/fgha2rlaljpa5z1qrazmq3eb8am.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In your </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , under with the same heading ("Unsolved Mystery") Henry describes the same effect, but even more pronounced:</font></font><br>
<blockquote>  ,     AVS  SSE  Sandy Bridge      147 ,       ROB.    (,     ,   AVX-   ,  NOP-),    ,    SSE/AVX,     ,   -   ,        147,        –  ,       .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For details, I refer you to Henry's article. </font><font style="vertical-align: inherit;">We observe a similar effect, but less pronounced: we at least manage to occupy 95% of the ROB volume, but we still do not exhaust it completely. </font><font style="vertical-align: inherit;">Perhaps that mysterious common pool of registers is associated with the mechanism of their release, for example, a PRRT table [12], which keeps track of the registers available for release after the command is completed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, let's talk about some more features of mask registers and check if the optimization mechanisms available to general purpose registers and SIMD registers are applicable to them.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy replacement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For general purpose or SIMD commands, so-called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move elimination</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be applied </font><font style="vertical-align: inherit;">. With this optimization, the register renaming mechanism allows not to execute commands that copy the value from one register to another, for example </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mov eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vmovdqu ymm1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ymm2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - instead </font><font style="vertical-align: inherit;">, the </font><i><font style="vertical-align: inherit;">destination</font></i><font style="vertical-align: inherit;"> register is “simply” [13] reassigned to the source register in RAT, which allows you to do without involving ALU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Check if the copy replacement is applicable to, say, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">. First, look at the graph of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test 28</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovd k1 is the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ballast team </font><font style="vertical-align: inherit;">,</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<img src="https://habrastorage.org/webt/wc/s3/jc/wcs3jcnzmjp4pffpopov47ybtg4.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This graph looks exactly the same as in test 27 discussed earlier with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commands </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Therefore, it is reasonable to assume that it is physical registers that are filled in, unless we accidentally exhausted some other resource used when replacing copy, which behaves the same and has the same size [14]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We find additional confirmation on the website uops.info: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it says</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that all variants of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copy </font><i><font style="vertical-align: inherit;">command</font></i><font style="vertical-align: inherit;"> between mask registers occupy one micro-operation executed on port </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If there was a replacement copy, we would not observe activity on the ports.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From this I conclude that copy commands that use mask registers [15] are not replaced.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addiction Idioms</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The best way to</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nullify the general-purpose register in x86 architecture is to use an exclusive OR idiom (xor): </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xor reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Its action is based on the fact that comparing any value with itself using this operation yields zero. </font><font style="vertical-align: inherit;">This command is shorter (takes less bytes) than the more obvious </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mov eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and also faster, because the processor understands that this is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reset idiom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and performs the necessary renaming of registers [16], which eliminates the need for ALU and port loading. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moreover, this idiom eliminates data dependencies: usually the result of the command </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xor reg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depends on the values ​​in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg2 registers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but in the special case when reg1 and reg2 contain the same value, there is no dependence, since for any input values ​​the output will be zero. All modern x86 processors recognize this [17] special case. The same is true for those versions of the xor idiom that use SIMD registers, namely </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vpxor</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operations </font><font style="vertical-align: inherit;">on integers and </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorpd operations</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on real numbers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, a curious reader may ask: does this idiom work with similar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variants</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor command</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? For example, would the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k1, k1, k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [18] </font><font style="vertical-align: inherit;">command </font><font style="vertical-align: inherit;">be considered a reset idiom?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, these are two different questions, since the effect of using a reset idiom is composed of two components:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero-delayed execution bypassing the execution module ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execution elimination</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependency Elimination</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will deal with each question separately.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replacement execution</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, can commands with xor, for example </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k1, k1, k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , be replaced by reassigning registers without being placed in the execution module? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I don’t even have to do anything myself to prove it: all the information is on the uops.info website, since they conducted </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">such a test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and showed that this command is executed with a delay of 1 clock cycle and takes one microoperation on the port </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It follows that xor reset idioms for mask registers do not work.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependency Elimination</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what if reset idioms with kxor still eliminate data dependencies, even if they require placement in the execution module? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here uops.info will not help us. The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">has a delay of 1 clock cycle and is executed on a single port ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), therefore there is an interesting (?) Situation in which the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><i><font style="vertical-align: inherit;">chain</font></i><font style="vertical-align: inherit;"> is executed at the same speed, regardless of whether there are dependencies between them or not: bandwidth ability 1 command / cycle gives the same performance decrease as delay 1 command / cycle! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nothing, we still have a couple of tricks in stock. The following test will help us answer this question. Embed </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a chain of commands, in which each subsequent command depends on the previous one, and the total execution time of this chain should be large enough to form a bottleneck. If the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><i><font style="vertical-align: inherit;">does</font></i><font style="vertical-align: inherit;"> not eliminate the dependency, the total execution time of the chain will be equal to the sum of the delays of its constituent commands. If the dependence disappears, the chain breaks into shorter sequences, the delays of which overlap, and then the speed of their execution will be limited by some limit value of throughput (associated, for example, with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">competition for ports</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). This could be clearly shown using the scheme, but I am not strong at this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All these tests can be found in the benchmark </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uarch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bench</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but the key points I will give below. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, measure the standard copy time from the general register and vice versa:</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pair of these commands is executed [19] in 4 measures. It is not known exactly how much time falls on each of them: 2 measures or one measure, and 3 measures on the other [20]? However, for our task this is irrelevant, because we are interested in the total time of copying back and forth. It is noteworthy that the bandwidth of this sequence is 1 clock cycle, which is 4 times faster than the delay, since each command is executed on its own port ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respectively). This means that we can separate the effect of delay from the effect of bandwidth. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, in our chain, we include the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">, which is guaranteed to not lead to a case reset:</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kxorb k0, k0, k1<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we know</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a delay of 1 clock cycle, the total execution time should increase to 5 cycles - this is what the test shows (the results of the first two tests are shown):</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                       <font></font>
mov  GP  kreg                    <span class="hljs-number">4.00</span>         <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                              <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, the main test:</font></font><br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kxorb k0, k0, k0<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This time we use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">with case reset: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k0, k0, k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If the dependence on the value in the register k0 disappears, this will mean that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovb eax, k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">no longer depends on the previous </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovb k0, eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">and that the chain has broken up and the total execution time should decrease. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drum roll ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We got all the same 5.0 measures - as in the previous example:</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                     <font></font>
mov  GP  kreg                   <span class="hljs-number">4.00</span>         <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The preliminary conclusion is this: reset idioms are not recognized by the processor if they are applied to mask registers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In conclusion, we will conduct another test to make sure our reasoning is correct: we replace the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">, which, as you know, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> removes the dependencies:</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kmovb k0, ecx<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The final answer is presented below. </font><font style="vertical-align: inherit;">The last test is much faster - only 2 clock cycles, and the bottleneck is port </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (both </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov k, r32 commands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are executed only on this port):</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                       <font></font>
mov  GP  kreg                   <span class="hljs-number">4.00</span>            <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>            <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>            <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
mov  GP                                  <span class="hljs-number">2.00</span>            <span class="hljs-number">0.63</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that our assumption is correct.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Playback Results</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can reproduce all the results presented in this article yourself by running the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">robsize</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> executable file </font><font style="vertical-align: inherit;">on Linux or Windows (under WSL). </font><font style="vertical-align: inherit;">They are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also available in the repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scripts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for collecting and plotting them.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SKX architecture mask registers are located in a separate physical register file; </font><font style="vertical-align: inherit;">134 of them are designed to store speculative values, the total number of mask registers is 142</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This number is comparable to the size of other types of register files, as well as the ROB buffer, and is large enough not to experience performance degradation when working with mask registers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy commands with mask registers are not replaced</font></font></li>
<li>  [21]               </li>
</ul><br>
<ol>
<li>   <i>k-</i>   <i>kregs</i> –  -. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">  </a>,  <i>k</i>     –           «» (<i>m</i>)   «» (<i>f</i>). </li>
<li>   (             AVX-512  ),  <i>k0</i> –     ,      , ,    .    : <i>k0</i> –   ,     ,     ,     <i>k</i>,   SIMD-,     (,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>   AVX-512).    SIMD-  <i>k0</i>    ,                . </li>
<li>        ,        -,        0,  ,          .  , ,    ,  ,  -   -      . </li>
<li>       « »,     <i>kreg</i> –        (  <i>k0</i>, <i>k1</i>  ..), –    «kreg»  « » ( ). </li>
<li>H. Wong, <i>Measuring Reorder Buffer Capacity</i>, May, 2013. [Online]. (. , «    »,  2013. -.) : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">blog.stuffedcow.net/2013/05/measuring-rob-capacity</a></li>
<li>        100  300 .     ,              -    2     50  100 ,     –   2,5 (,  2   5 ).     TLB-/               .</li>
<li> «»     .   ,       ,  .            . ,   29       104,    ,    –  ,     200.      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">  </a>)    –   ,   -           (         ),        . </li>
<li> , , ,                 (<i>register alias table, RAT</i>),      .  RAT  ,     ,        ,        ,       .     RAT      ,                ,    . </li>
<li> 60%   134  224, ..    PRF     ROB.   ,      ROB   224  ,        ,   ,      [10]   60% ,   ROB. ,       -  ,   60%   ,       ROB,    <i></i>.</li>
<li> ,        ,    . ,      (, SIMD-   ),     . [2]</li>
<li>    ,          .  ,   2      2  SIMD- (    ),  4   . </li>
<li>    <i>Physical Register Reclaim Table</i> (   )  <i>Post Retirement Reclaim Table</i> (     ).</li>
<li>        –   ,    «  », ..   ,        ,        .        ,    .     :       ,       . </li>
<li> ,        ( 7)   ,      PRF         ROB. </li>
<li> ,           ,     ,     .  ,             ( ,  ,      ,       –      ). </li>
<li>        RAT  ,           RAT  , ,     . </li>
<li>      <i>xor</i>,              ,  <i>sub reg,reg</i>   <i>sbb reg, reg</i>.     ,      <i>reg</i>  0  -1 (  )     .    ,     <i>reg</i>, –     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>           . </li>
<li> ,      :   <i>kxorb k1, k1, k1</i>   ,        <i>kxorb k1, k2, k2</i>. </li>
<li> ,    ,      <br>
<br>
<pre><code class="cpp hljs">./uarch-bench.sh --test-name=avx512<span class="hljs-comment">/*. </span></code></pre><br>
</li>
<li>  uops.info   <i>kmov r32, k,</i>   <i>kmov k, 32</i>    <i>&lt;= 3</i>.  ,       4 .          1 , ,         3 . </li>
<li>,      xor,      , , -, ,         .  ,    :     ,            . </li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488660/index.html">Is it time to forget about React and upgrade to Svelte?</a></li>
<li><a href="../en488662/index.html">Browser extensions required by every web developer</a></li>
<li><a href="../en488664/index.html">Finding the Perfect Toolkit: Analyzing Popular Python Project Templates</a></li>
<li><a href="../en488666/index.html">10 React Components for All Occasions</a></li>
<li><a href="../en488668/index.html">CI / CD chaining and Docker automation</a></li>
<li><a href="../en488672/index.html">Debugging ARM Cortex-M microcontrollers by UART</a></li>
<li><a href="../en488674/index.html">Infographic with Excel and PowerPoint</a></li>
<li><a href="../en488678/index.html">Big Appetites for Little Buffers at Node.js</a></li>
<li><a href="../en488682/index.html">How to test Python programming skills? Tasks from Yandex</a></li>
<li><a href="../en488686/index.html">Using Flowmon Networks to Monitor the Performance of Distributed Applications and Databases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>