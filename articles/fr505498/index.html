<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçà üçñ üë∑üèª Comment nous r√©solvons le probl√®me de la m√©moire de pile non initialis√©e dans Windows üèÅ üìâ üë®üèΩ‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cette note, je d√©crirai comment Microsoft √©limine les vuln√©rabilit√©s associ√©es √† la m√©moire de pile non initialis√©e et pourquoi nous le faisons d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment nous r√©solvons le probl√®me de la m√©moire de pile non initialis√©e dans Windows</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette note, je d√©crirai comment Microsoft √©limine les vuln√©rabilit√©s associ√©es √† la m√©moire de pile non initialis√©e et pourquoi nous le faisons du tout.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour faciliter la navigation, la note est divis√©e en sections:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec de la m√©moire non initialis√©e: historique des probl√®mes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rem√®de contre les vuln√©rabilit√©s de m√©moire non initialis√©es</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - initialisation automatique</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observations int√©ressantes li√©es √† l'utilisation d'InitAll</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisations des performances</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur utilisateur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plans futurs</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce travail n'aurait pas √©t√© possible sans une √©troite collaboration entre Visual Studio, Windows et MSRC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec de la m√©moire non initialis√©e: historique des probl√®mes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la cr√©ation des langages de programmation C et C ++, l'accent a √©t√© mis sur le contr√¥le rapide et flexible par le d√©veloppeur. </font><font style="vertical-align: inherit;">Pour cette raison, ces langages ne forcent pas l'initialisation des variables. </font><font style="vertical-align: inherit;">Travailler avec des variables non initialis√©es conduit √† un comportement non d√©fini, elles doivent donc √™tre initialis√©es avant utilisation, et la responsabilit√© d'observer cette r√®gle incombe enti√®rement au d√©veloppeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les vuln√©rabilit√©s associ√©es √† la m√©moire non initialis√©e sont r√©duites √† deux types:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgation de contenu: les donn√©es stock√©es dans des sections de m√©moire non initialis√©es sont copi√©es en dehors de la zone de confiance et deviennent connues des personnes qui n'ont pas l'autorit√© appropri√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation directe de la m√©moire non initialis√©e. </font><font style="vertical-align: inherit;">Exemple: √©criture par pointeur non initialis√©.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de comprendre que des probl√®mes peuvent survenir, que la m√©moire soit allou√©e sur la pile ou sur le tas. </font><font style="vertical-align: inherit;">Cet article concerne la m√©moire de la pile, et ensuite nous parlerons du tas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple d'utilisation de m√©moire non initialis√©e</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> size;  <font></font>
GetSize(&amp;size); <span class="hljs-comment">//       ?</span>
<span class="hljs-built_in">memcpy</span>(dest, src, size); <span class="hljs-comment">//  memcpy </span>
                         <span class="hljs-comment">//  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me ici est que si la fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSize n'attribue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas de valeur √† la variable ¬´taille¬ª dans toutes les branches du programme, une </font><font style="vertical-align: inherit;">taille non initialis√©e sera transmise √† l' </font><font style="vertical-align: inherit;">appel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pour cette raison, une erreur de lecture ou d'√©criture peut se produire en dehors du tampon si la valeur 'size' est sup√©rieure √† la taille du tampon 'src' ou 'dest'.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple d'extension de m√©moire non initialis√©e</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
      <span class="hljs-keyword">uint8_t</span> field1;
      <span class="hljs-keyword">uint64_t</span> field2;<font></font>
};<font></font>
mystruct s {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">memcpy</span>(dest, &amp;s, <span class="hljs-keyword">sizeof</span>(s));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que la fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copie une structure en dehors d'une zone de confiance (c'est-√†-dire du mode noyau au mode utilisateur). √Ä premi√®re vue, la structure semble √™tre enti√®rement initialis√©e, mais entre le ¬´champ1¬ª et le ¬´champ2¬ª, le compilateur a ins√©r√© des octets d'espace r√©serv√© qui n'ont pas √©t√© explicitement initialis√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä la suite de l'appel de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les octets d'espace r√©serv√© seront copi√©s en dehors de la zone de confiance avec leur contenu non initialis√© √©crit plus t√¥t dans ces adresses virtuelles. </font><font style="vertical-align: inherit;">Il peut s'agir, par exemple, d'un morceau d'une cl√© de chiffrement secr√®te (qui deviendra visible en mode utilisateur), d'un pointeur (qui cassera l'ASLR) ou autre chose. </font><font style="vertical-align: inherit;">Dans certains cas, il peut √™tre facilement prouv√© qu'aucune donn√©e particuli√®rement critique n'est transmise, dans d'autres, ce sera tr√®s difficile. </font><font style="vertical-align: inherit;">Mais dans tous les cas, d√©terminer la gravit√© du probl√®me de la m√©moire non initialis√©e est un travail ingrat, et nous ferions volontiers autre chose.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistiques sur les erreurs de m√©moire non initialis√©es</font></font></h3><br>
<p><img src="https://habrastorage.org/webt/hb/la/gn/hblagnxiqxpsgewdennaq6tx8o8.png" alt="Image 8"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: dans cette figure, l'utilisation de m√©moire non initialis√©e fait r√©f√©rence aux deux types de probl√®mes: utilisation directe et divulgation de contenu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces derni√®res ann√©es, le nombre de ces erreurs a augment√©. </font><font style="vertical-align: inherit;">Cela est probablement d√ª en partie √† l'int√©r√™t croissant des chercheurs pour eux et, par cons√©quent, √† l'√©mergence d'outils efficaces pour leur recherche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une classification plus d√©taill√©e de ces erreurs r√©v√®le des tendances plus int√©ressantes.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/od/bg/sq/odbgsqun-kof4vx6j8ws_v9d9f8.png" alt="Image 6"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: dans ce diagramme, l'utilisation d'une m√©moire non initialis√©e n'inclut PAS la divulgation de son contenu.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/rl/ql/ee/rlqleezbmgk3oeo-bxztqaaphry.png" alt="Image 5"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En regardant ces diagrammes, nous pouvons tirer les conclusions suivantes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre 2017 et 2018, les vuln√©rabilit√©s de m√©moire non initialis√©es repr√©sentaient environ 5 √† 10% de toutes les vuln√©rabilit√©s dans les rapports Microsoft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les vuln√©rabilit√©s associ√©es √† l'allocation de m√©moire sur la pile et les vuln√©rabilit√©s associ√©es √† l'allocation de m√©moire dans le tas / pool se sont av√©r√©es presque √©gales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a plus de cas de divulgation du contenu de la m√©moire non initialis√©e que de cas d'utilisation de la m√©moire non initialis√©e.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">litt√©rature suppl√©mentaire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une introduction plus compl√®te au sujet, consultez les ressources suivantes:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rem√®de contre les vuln√©rabilit√©s de m√©moire non initialis√©es</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ils ont essay√© de r√©soudre les probl√®mes d√©crits de plusieurs mani√®res.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse statique (√† la fois pendant la compilation et apr√®s)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examen du code</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation automatique</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse statique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft utilise de nombreux avertissements de l'analyseur statique pour intercepter les variables non initialis√©es (notamment C4700, C4701, C4703, C6001, C26494 et C26495). </font><font style="vertical-align: inherit;">Ces diagnostics sont conservateurs, c'est-√†-dire </font><font style="vertical-align: inherit;">Afin de r√©duire le bruit, ils ignorent certains mod√®les qui peuvent conduire √† une m√©moire non initialis√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un certain nombre de r√®gles strictes pour l'analyseur statique </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semmle ont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©galement √©t√© √©crites </font><font style="vertical-align: inherit;">, qui sont ex√©cut√©es sur certaines bases de code Windows. </font><font style="vertical-align: inherit;">Mais ces diagnostics g√©n√®rent beaucoup de bruit et il est difficile de v√©rifier de grandes quantit√©s de code. </font><font style="vertical-align: inherit;">De plus, le respect de ces r√®gles et la correction des erreurs prennent beaucoup de temps. </font><font style="vertical-align: inherit;">En cons√©quence, il s'est av√©r√© qu'il est difficile et co√ªteux de les utiliser.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fuzzing, comme vous le savez, est difficile √† mettre √† l'√©chelle. </font><font style="vertical-align: inherit;">Les bons fuzzers sont co√ªteux √† entretenir et n√©cessitent une personnalisation pour des t√¢ches sp√©cifiques. </font><font style="vertical-align: inherit;">Avec une base de code de tailles telles que Microsoft, il est tr√®s difficile d'assurer sa couverture compl√®te de fuzzing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√™me s'il √©tait possible de couvrir parfaitement tout le code avec eux, les fuzzers ne sont pas en mesure de d√©tecter la divulgation du contenu de la m√©moire non initialis√©e, car cela ne conduit pas √† un plantage du programme. </font><font style="vertical-align: inherit;">Pour d√©tecter de tels d√©fauts √† l'aide du fuzzing, l'une des deux solutions est requise:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazzer, qui comprend le protocole et est capable de d√©tecter le retour de m√©moire non initialis√©e (ou plut√¥t de donn√©es inattendues).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un analyseur dynamique capable de d√©tecter l'acc√®s √† la m√©moire non initialis√©e.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examen du code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'aper√ßu du code n'est pas √©volutif et est extr√™mement sujet aux erreurs. </font><font style="vertical-align: inherit;">Le code avec des vuln√©rabilit√©s est pass√© en revue, mais elles sont si bien d√©guis√©es que les programmeurs ne les remarquent pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie du code dans laquelle nous avons rencontr√© la divulgation du contenu de la m√©moire non initialis√©e a √©t√© r√©√©crite √† l'√©poque de Windows 32 bits, et il n'y avait pas de telles erreurs √† l'√©poque. </font><font style="vertical-align: inherit;">Lorsque la transition vers les architectures 64 bits s'est produite, la taille des pointeurs est pass√©e de 32 √† 64 bits, c'est pourquoi certaines structures ont des champs d'espace r√©serv√© non initialis√©s.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - Initialisation automatique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des approches mentionn√©es, Microsoft utilise depuis un certain temps un m√©canisme appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il initialise automatiquement les variables de pile au stade de la compilation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette section, je d√©crirai comment cette technologie est utilis√©e dans Windows et pourquoi de cette fa√ßon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres Windows actuels:</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les types suivants sont automatiquement initialis√©s:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scalaire (tableaux, pointeurs, nombres √† virgule flottante)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tableaux de pointeurs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structures (Structures de donn√©es simples - POD)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les types suivants ne sont pas automatiquement initialis√©s:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables volatiles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tableaux de types autres que des pointeurs (c'est-√†-dire des tableaux d'entiers, des tableaux de structures, etc.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes qui ne sont pas POD</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les ensembles de vente au d√©tail optimis√©s, les variables sont initialis√©es avec une valeur de 0. Pour les nombres √† virgule flottante, une valeur de 0,0 est utilis√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les assemblys de d√©bogage (CHK) ou les assemblages pour les d√©veloppeurs (c'est-√†-dire les d√©taillants non optimis√©s) utilisent la valeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xE2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">les nombres √† virgule flottante sont initialis√©s √† 1.0. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'applique aux composants suivants:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout le code du r√©f√©rentiel Windows s'ex√©cutant en mode noyau (c'est-√†-dire tout le code se compilant avec le commutateur / KERNEL) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les codes li√©s √† Hyper-V (hyperviseur, composants en mode noyau, composants en mode utilisateur)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un certain nombre d'autres projets, tels que les services r√©seau en mode utilisateur</font></font></li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> impl√©ment√© sur le frontal du compilateur. </font><font style="vertical-align: inherit;">Toutes les variables qui r√©pondent aux crit√®res √©num√©r√©s ci-dessus et qui ne sont pas initialis√©es par le programmeur seront initialis√©es par le frontend lors de la d√©claration. </font><font style="vertical-align: inherit;">L'un des avantages de cette approche est que, du point de vue de l'optimiseur, l'initialisation automatique n'est pas diff√©rente de l'initialisation par le d√©veloppeur. </font><font style="vertical-align: inherit;">Il en r√©sulte que les optimisations que nous ajoutons pour acc√©l√©rer le travail avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne sont pas uniquement li√©es √† cette fonction et fonctionneront dans ces cas lorsque vous initialisez vous-m√™me les variables lors de la d√©claration (ou avant l'utilisation).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment √©viter le probl√®me du fork linguistique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un hic avec l'initialisation automatique du z√©ro: z√©ro est une signification sp√©ciale dans un langage de programmation, en particulier pour les pointeurs. Et c'est peut-√™tre la valeur la plus courante qui initialise des variables individuelles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'il est initialis√© √† z√©ro, un pointeur qui n'a pas √©t√© correctement initialis√© par le programmeur peut tomber dans la branche de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointeur NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par cons√©quent, vous pouvez obtenir un programme qui ne se bloque pas, mais ne produit pas les r√©sultats souhait√©s. Si vous initialisez le pointeur avec une valeur de m√©moire, il ne tombera pas dans la branche de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointeur NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et, si vous essayez de l'utiliser, provoquera le plantage du programme.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous r√©solvons ce probl√®me en utilisant une valeur d'initialisation non nulle (0xE2) dans les versions CHK et les versions dites pour les d√©veloppeurs, qui sont souvent des versions non optimis√©es. De ce fait, d'une part, il est possible de maintenir des performances √©lev√©es du code livr√© aux clients, et d'autre part, d'obtenir un comportement dans les assemblys en cours de test qui facilite la d√©tection des initialisations manqu√©es.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je note que C ++ n√©cessite d√©j√† une initialisation z√©ro automatique de tous les membres statiques. </font><font style="vertical-align: inherit;">Cette s√©mantique aide les d√©veloppeurs. </font><font style="vertical-align: inherit;">Par exemple, lorsque vous voyez une variable statique avec une valeur nulle, vous saurez que vous devez l'initialiser, car c'est sa premi√®re utilisation. </font><font style="vertical-align: inherit;">InitAll introduit une s√©mantique similaire pour les variables automatiques (pile) avec une mise en garde importante: nous essayons de ne pas lier les d√©veloppeurs √† des valeurs initiales sp√©cifiques.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment nous choisissons pour quels composants utiliser InitAll</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pr√©voyait d'utiliser deux composants:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code en mode noyau - principalement en raison du grand nombre de vuln√©rabilit√©s observ√©es associ√©es √† la m√©moire du noyau non initialis√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code Hyper-V est principalement d√ª √† son importance pour Azure et √† des statistiques r√©centes d√©cevantes sur les cas de divulgation du contenu de la m√©moire de pile non initialis√©e.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains chez Microsoft ont d√©couvert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ont commenc√© √† l'utiliser activement sur leurs composants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison pour laquelle nous ne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©ployons</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas </font><i><font style="vertical-align: inherit;">InitAll</font></i><font style="vertical-align: inherit;"> tout de suite dans tout le code est parce que nous voulons d'abord faire au moins quelque chose de bien et ne pas √©chouer, en essayant de tout faire en m√™me temps. </font><font style="vertical-align: inherit;">Plus nous traitons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la fois, plus il est difficile de d√©boguer les baisses de performances, de r√©soudre les probl√®mes de compatibilit√©, etc. </font><font style="vertical-align: inherit;">Maintenant que nous avons r√©ussi √† d√©ployer la technologie sur les composants les plus importants, vous pouvez faire le reste du code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll rompt-il l'analyse statique?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'analyse statique est extr√™mement utile en ce qu'elle rappelle aux d√©veloppeurs les variables qu'ils ont oubli√© d'initialiser avant utilisation. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> notifie √† la fois l'analyseur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREfast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et le backend du compilateur (tous deux donnent des avertissements sur les variables non initialis√©es) des initialisations qu'il a ajout√©es. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, les analyseurs statiques peuvent ignorer de tels endroits et toujours donner leurs avertissements. </font><font style="vertical-align: inherit;">Lorsque </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll est activ√©,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous recevrez toujours des messages de l'analyseur statique sur les variables non initialis√©es - m√™me si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll les a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialis√©es pour vous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi nous n'initialisons pas tous les types</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors des tests pr√©liminaires, nous avons initialis√© avec force tous les types de donn√©es allou√©es sur la pile et observ√© des baisses de performances de plus de 10% dans plusieurs sc√©narios importants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si seules les structures POD √©taient initialis√©es, les performances ne chutaient pas autant et les optimisations du compilateur visant √† r√©duire le nombre d'op√©rations d'√©criture inutiles (√† la fois √† l'int√©rieur des unit√©s de base et entre elles) nous permettaient de r√©duire davantage le ralentissement de tout niveau notable au niveau d'erreur dans la plupart des tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pr√©voyons de revenir √† l'id√©e d'initialiser tous les types (surtout maintenant que nous avons des optimisations plus puissantes), nous n'avons tout simplement pas atteint ce point.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi initialisons-nous des variables avec z√©ro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation √† z√©ro donne les meilleurs r√©sultats en termes de performances (√† la fois en termes de vitesse et de taille binaire), ainsi qu'en termes de s√©curit√©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Du point de vue de la s√©curit√©</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation z√©ro pr√©sente les avantages suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un pointeur nul l√®vera une exception SEH lors du d√©r√©f√©rencement sous Windows (c'est-√†-dire que, dans le pire des cas, cela provoquera une erreur de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©ni de service</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais l'ex√©cution de code √† distance sera impossible), ce qui se termine g√©n√©ralement par un plantage du programme.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une variable sp√©cifiant une taille ou un index recevra une valeur nulle. </font><font style="vertical-align: inherit;">Cela devrait minimiser le risque de transmettre une taille non initialis√©e √† des fonctions comme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> travaillant avec un tampon dont la taille est donn√©e par la valeur de la variable transmise.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir v√©rifi√© le pointeur nul, le programme ex√©cutera la branche correspondante et n'essaiera pas de l'utiliser. </font><font style="vertical-align: inherit;">Ainsi, au moins, il sera possible de traiter correctement les pointeurs que le d√©veloppeur a oubli√© d'initialiser (car une tentative d'acc√®s √† la m√©moire √† l'aide d'un pointeur initialis√© automatiquement entra√Ænera toujours un plantage).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les variables de type bool√©en avec une valeur de 0 signifient ¬´faux¬ª, ce qui dans les tests peut indiquer un √©tat d'erreur.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation avec z√©ro pr√©sente √©galement quelques inconv√©nients:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La variable NTSTATUS aura la valeur STATUS_SUCCESS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HRESULT sera S_OK </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais les valeurs renvoy√©es peuvent √™tre tr√®s diff√©rentes, et il n'y a pas de valeur universelle unique avec laquelle toutes les initialiser, d'autant plus qu'elle doit √©galement √™tre utilis√©e pour les tailles, les index, les pointeurs, etc.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Du point de vue des performances</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vitesse du programme et la taille du code d√©pendent √©galement de la valeur d'initialisation s√©lectionn√©e. </font><font style="vertical-align: inherit;">Nous n'avons pas mesur√© l'aggravation des r√©sultats lors de l'utilisation d'une valeur non nulle, car nous √©tions principalement int√©ress√©s par les avantages de s√©curit√© que l'initialisation donne √† z√©ro, et nous savions qu'en m√™me temps, cela aurait un effet positif sur les performances (√† la fois la vitesse et la taille du code). </font><font style="vertical-align: inherit;">Nos coll√®gues de Google ont pris des mesures et montr√© que sur Clang, l'initialisation avec z√©ro pour le moment est beaucoup plus rentable que l'initialisation avec une valeur non nulle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessous, je vais montrer par des exemples pourquoi lors de l'initialisation avec z√©ro, moins de code est obtenu.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple 1: initialisation √† l'aide de registres √† usage g√©n√©ral</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation par z√©ro:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">31</span> c0                            <span class="hljs-keyword">xor</span>    eax,eax
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation avec une valeur non nulle:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> b8 e2 e2 e2 e2 e2 e2 e2 e2    movabs rax,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, nous nous int√©ressons √† deux points: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premi√®rement, la d√©finition du registre RAX √† z√©ro prend 2 octets de code contre 10 octets lorsqu'il est d√©fini sur une valeur non nulle. Il s'av√®re un gain √† la fois en taille de code et en vitesse. De nombreux processeurs lisent les instructions 16 octets √† la fois, donc l'√©criture d'une constante fixe dans le registre √† l'aide d'une instruction de 10 octets emp√™che l'√©mission des instructions suivantes qui pourraient √™tre ex√©cut√©es en parall√®le.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxi√®mement, avant qu'il ne devienne possible d'√©crire la valeur dans le registre RCX, vous devez attendre la fin de l'√©criture dans RAX, ce qui peut conduire au processeur inactif. </font><font style="vertical-align: inherit;">Les s√©quences comme ¬´xor eax, eax¬ª sont reconnues d√®s les premi√®res parties du pipeline, et l'ex√©cution r√©elle de la commande XOR n'est pas requise - les processeurs r√©initialisent simplement le registre RAX. </font><font style="vertical-align: inherit;">Par cons√©quent, le pipeline est inactif moins de temps et le programme s'ex√©cute plus rapidement.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple 2: initialisation √† l'aide de registres XMM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √©crire des valeurs plus grandes, le compilateur utilise g√©n√©ralement des registres XMM (ainsi que YMM ou ZMM, selon que la prise en charge des jeux d'instructions AVX ou AVX512 est activ√©e). </font><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, les processeurs ne peuvent pas ex√©cuter plus d'une commande d'√©criture dans un cycle d'horloge, il serait donc judicieux d'utiliser des commandes qui d√©finissent autant d'octets que possible. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation par z√©ro:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">0f</span> <span class="hljs-number">57</span> c0                         xorps  xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation avec une valeur non nulle (charg√©e √† partir d'une variable globale, ce que font g√©n√©ralement les compilateurs):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">66</span> <span class="hljs-number">0f</span> <span class="hljs-number">6f</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movdqa xmm0,XMMWORD PTR ds:<span class="hljs-number">0x0</span>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation avec une valeur non nulle (charg√©e √† partir d'une constante fixe dans le code, ce que les compilateurs ne font pas):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> ba e2 e2 e2 e2 e2 e2 e2 e2    movabs rdx,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">66</span> <span class="hljs-number">48</span> <span class="hljs-number">0f</span> <span class="hljs-number">6</span>e c2                   movq   xmm0,rdx
<span class="hljs-number">0f</span> <span class="hljs-number">16</span> c0                         movlhps xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, dans le cas des registres XMM, la m√™me image est observ√©e. Lorsqu'il est initialis√© √† z√©ro, le code est tr√®s petit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas possible d'√©crire une constante fixe directement dans le registre XMM. Vous devez d'abord l'enregistrer dans le registre g√©n√©ral, puis le d√©placer vers le registre XMM, puis copier les 64 bits bas du registre XMM sur ses 64 bits hauts. En cons√©quence, nous obtenons un code long et trois commandes, chacune devant attendre la fin de la pr√©c√©dente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √©viter cela, les compilateurs, en r√®gle g√©n√©rale, enregistrent une constante fixe sous la forme d'une variable globale, √† partir de laquelle ils peuvent ensuite lire la valeur - cela se traduit par beaucoup moins de code. Malheureusement, vous devez attendre la fin de l'√©criture dans le registre XMM avant qu'il ne soit disponible pour utilisation. Si une variable globale est d√©charg√©e de la m√©moire, l'op√©ration peut prendre plusieurs milliers de cycles d'horloge. Une op√©ration de lecture prend plusieurs cycles d'horloge, m√™me dans le meilleur des cas, lorsque les donn√©es sont stock√©es dans le cache L1. Et m√™me dans ce cas, le code est beaucoup plus long que si vous venez de r√©initialiser le registre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela r√©v√®le un autre avantage de l'initialisation z√©ro: des r√©sultats plus d√©terministes. Le temps d'initialisation ne d√©pend pas du fait que la variable globale se trouve dans le cache L1, L2 ou L3, qu'elle soit d√©charg√©e de la m√©moire, etc.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observations int√©ressantes li√©es √† l'utilisation d'InitAll</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows 10 1903 (sorti au printemps 2019) √©tait la premi√®re version dans laquelle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©tait activ√© par d√©faut. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous n'avons re√ßu aucune plainte concernant la d√©gradation des performances due √† cela.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compatibilit√©</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contre la triche</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peu de temps apr√®s avoir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activ√© InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sous Windows, nous avons commenc√© √† recevoir des plaintes concernant les plantages du noyau caus√©s par certains programmes anti-triche. </font><font style="vertical-align: inherit;">Apr√®s avoir √©tudi√© le probl√®me, nous avons d√©couvert que ces programmes contenaient des pilotes en mode noyau qui analysaient l'image du noyau NT en m√©moire et recherchaient des s√©quences d'octets sp√©cifiques indiquant le d√©but des fonctions non document√©es. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajout√© des initialisations suppl√©mentaires (dont la redondance n'a pas pu √™tre prouv√©e) au d√©but de ces fonctions, √† cause desquelles leurs signatures ont chang√©. </font><font style="vertical-align: inherit;">Nous avons contact√© les d√©veloppeurs de ces anti-cheats, et √† notre demande, ils ont mis √† jour leurs pilotes afin qu'ils ne provoquent plus de plantages du noyau.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de la m√©moire lib√©r√©e en FAT32</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peu de temps apr√®s avoir activ√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour les types de donn√©es scalaires (c'est-√†-dire les entiers, les nombres √† virgule flottante, etc.), nous avons rencontr√© un probl√®me int√©ressant dans le pilote du syst√®me de fichiers FAT, qui ne permettait pas la mise √† jour des assemblages Windows internes √† partir de lecteurs flash USB amor√ßables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code dans lequel le probl√®me s'est produit ressemblait √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
{<font></font>
      <span class="hljs-keyword">int</span> tmp;<font></font>
      DoStuff(&amp;tmp, i);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une boucle dans laquelle une variable est d√©clar√©e. A la premi√®re it√©ration de la boucle, la fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoStuff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialise la variable 'tmp', dont l'adresse lui est pass√©e en argument. √Ä chaque it√©ration suivante, la variable ¬´tmp¬ª est utilis√©e comme param√®tre d'entr√©e / sortie. En d'autres termes, sa valeur est d'abord lue puis mise √† jour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me est que la variable en question au d√©but de chaque it√©ration de la boucle entre dans sa port√©e, et la quitte √† la fin de l'it√©ration. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialise cette variable √† z√©ro avant chaque it√©ration. En fait, nous obtenons une vuln√©rabilit√© d' </font><i><font style="vertical-align: inherit;">utilisation apr√®s</font></i><font style="vertical-align: inherit;"> lib√©ration</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Pour un fonctionnement normal du code, il est n√©cessaire que la variable 'tmp' conserve sa valeur √† chaque it√©ration, m√™me si √† la fin de l'it√©ration elle sort du domaine. </font><font style="vertical-align: inherit;">Malheureusement, ce probl√®me n'a pas entra√Æn√© de plantage du pilote, mais une logique incorrecte de son fonctionnement et, par cons√©quent, un comportement impr√©visible du syst√®me de fichiers. </font><font style="vertical-align: inherit;">Pendant le d√©bogage, l'√©quipe du noyau a d√©termin√© la cause du probl√®me et l'a corrig√© en retirant la variable de la boucle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce cas est un bon exemple de la fa√ßon dont les am√©liorations de la s√©curit√© peuvent casser le code qui n'a pas √©t√© √©tudi√© depuis des ann√©es.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisations des performances</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
optimisations de performances </font><i><font style="vertical-align: inherit;">d'InitAll</font></i><font style="vertical-align: inherit;"> ont </font><font style="vertical-align: inherit;">trois objectifs:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donner aux d√©veloppeurs la possibilit√© de d√©sactiver </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le code critique</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si possible, supprimez les op√©rations d'√©criture inutiles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acc√©l√©rez autant que possible les op√©rations d'√©criture restantes</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactiver InitAll pour le code critique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les optimisations les plus √©videntes sont de laisser le code:</font></font><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactiver </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compl√®tement InitAll</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactiver </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour un type sp√©cifique (c'est-√†-dire la structure typedef)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactivez </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour toutes les op√©rations d'allocation de m√©moire dans la fonction</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactiver </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour une d√©claration de variable sp√©cifique dans une fonction</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
actuellement </font><font style="vertical-align: inherit;">d√©sactiv√© (pour des </font><i><font style="vertical-align: inherit;">raisons de</font></i><font style="vertical-align: inherit;"> performances) pour un seul type - la structure _CONTEXT, qui stocke les valeurs de tous les registres. L'initialisation forc√©e a entra√Æn√© une baisse des performances des tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a une taille de plus de 1000 octets, ce qui est suffisant pour stocker les valeurs de tous les registres. Lorsque la journalisation ETW est activ√©e pour suivre les changements de contexte, chaque fois que le contexte est modifi√©, les valeurs de tous les registres sont enregistr√©es. Dans </font><font style="vertical-align: inherit;">ce cas, la </font><font style="vertical-align: inherit;">structure </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera allou√©e sur la pile, remplie d'une fonction assembleur, puis transmise √† ETW. Du fait que la structure est initialis√©e par une fonction assembleur, le compilateur ne peut pas supprimer l'initialisation effectu√©e</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Comme cette structure contient d√©j√† des donn√©es critiques (√©tat de chaque registre), est volumineuse et est utilis√©e dans des branches extr√™mement exigeantes en performances, nous avons d√©cid√© de ne pas lui appliquer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tous les autres types, variables et fonctions, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll n'√©tait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas </font><i><font style="vertical-align: inherit;">d√©sactiv√©</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppression des op√©rations d'√©criture inutiles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La suppression des op√©rations d'√©criture inutiles est une optimisation effectu√©e par le compilateur Visual Studio, qui supprime les op√©rations d'√©criture qui peuvent se r√©v√©ler redondantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici des exemples de diff√©rents types d'optimisation utilis√©s par Visual Studio.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppression de plusieurs memsets</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lien vers Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/Ldu7AP</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le mod√®le de code suivant (avec diff√©rentes variantes) est extr√™mement courant. Les r√®gles de programmation NT initiales exigent que toutes les variables soient d√©clar√©es au d√©but de la fonction et initialis√©es le plus tard possible. Par cons√©quent, nous avons des cas o√π une variable est d√©clar√©e au d√©but d'une fonction et est initialis√©e uniquement dans une branche imm√©diatement avant son utilisation. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajoute son initialisation variable au d√©but de la fonction. Le compilateur peut supprimer le doublon, mais ce n'est pas toujours facile √† faire.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
  <font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/hq/dl/ee/hqdleeuo4icifkr9_ijrp0rt_ps.png" alt="Image 4"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semble que cet exemple simple devrait √™tre facilement optimis√©, cependant, GCC 9.3 et Clang 10.0.0 (les derni√®res versions disponibles sur Godbolt) ne sont pas en mesure dans ce cas de supprimer l'appel de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suppl√©mentaire </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Je ne parle pas de cela pour critiquer ces compilateurs - ils optimisent tous les deux tr√®s bien le code. </font><font style="vertical-align: inherit;">Je veux juste montrer que certains mod√®les peuvent causer des difficult√©s m√™me pour les compilateurs les plus puissants. </font><font style="vertical-align: inherit;">Avant l'av√®nement d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et des optimisations associ√©es, Visual Studio ne pouvait pas supprimer l'appel suppl√©mentaire. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple encore plus simple:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
entre deux appels </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il n'y a qu'un seul appel de fonction sans argument. </font><font style="vertical-align: inherit;">Ce mod√®le, comme le pr√©c√©dent, est tr√®s courant dans le code Microsoft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lien vers Godbolt:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/HqFMx_</font></font></a><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    Dummy();<font></font>
<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    DoStuff(&amp;s);<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fe/qo/7e/feqo7evdydknbjjwx9wwlvxt61a.png" alt="Image 3"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC supprime le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font><font style="vertical-align: inherit;">exc√®s </font><font style="vertical-align: inherit;">dans cet exemple. Clang 10.0.0 - aussi, mais GCC 9.3 √©choue toujours. Il semblerait que ce code puisse √™tre facilement optimis√©, mais pour cela, le compilateur doit effectuer une analyse non triviale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me ici (dans MSVC) est que le compilateur utilise l'analyse d'accessibilit√© des objets, ind√©pendamment de la ramification ou de l'ex√©cution des threads. Du point de vue du compilateur, la variable ¬´s'√©chappe¬ª de la fonction courante (en d'autres termes, son adresse est pass√©e quelque part en dehors de cette fonction), puisque son adresse est pass√©e √† la fonction ¬´DoStuff¬ª. Le compilateur voit √©galement un appel √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's', puis un appel √† 'Dummy', suivi d'un autre appel √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's'.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Du point de vue du compilateur, puisque la variable 's' s'est "√©chapp√©e" de la fonction, la fonction 'Dummy' pourrait th√©oriquement lire le contenu du 's' ou le modifier avant d'appeler la fonction 'DoStuff'. </font><font style="vertical-align: inherit;">Cela signifie qu'un appel √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut pas √™tre supprim√© avant ou apr√®s ¬´Dummy¬ª. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons voir que bien que la variable 's' et "s'√©chappe" de la fonction courante, cela ne se produit pas avant que la fonction 'DoStuff' soit appel√©e. </font><font style="vertical-align: inherit;">Le compilateur MSVC comprend d√©sormais √©galement cela (√† un degr√© ou √† un autre) et peut supprimer le premier appel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©duction de la taille du Memset</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lien vers Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/fyLVUF</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le sch√©ma suivant n'est pas rare non plus. </font><font style="vertical-align: inherit;">La structure est partiellement initialis√©e, puis transf√©r√©e vers une autre fonction. </font><font style="vertical-align: inherit;">Cette deuxi√®me fonction est susceptible d'initialiser le reste des donn√©es de structure (ou du moins de ne pas les lire), mais le compilateur ne peut pas le prouver.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">320</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s)<span class="hljs-number">-0x160</span>);<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/qv/zv/ix/qvzvix4pxzqvazgvfzafdg_zraa.png" alt="Image 2"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC peut d√©sormais d√©couper la taille du premier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'il initialise uniquement les √©l√©ments de la structure que le deuxi√®me </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset n'initialise</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Encore une fois, GCC 9.3 et Clang 10.0.0 ne savent pas encore comment faire cette optimisation dans cet exemple.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balayage de memset plus efficace</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lien vers Godbolt</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans l'exemple suivant, l'appel du </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut pas √™tre supprim√©. </font><font style="vertical-align: inherit;">Ainsi, il doit √™tre effectu√© le plus efficacement possible.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">12</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
    DoStuff(&amp;s);<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fm/yf/7v/fmyf7vxnqesyecgskxvarcbgyc4.png" alt="Image 1"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC (comme la plupart des compilateurs) peut ¬´d√©ployer¬ª de petits appels de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec une taille et une valeur de remplissage d√©finies statiquement. Autrement dit, l'appel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est remplac√© par une s√©quence de commandes d'√©criture directement en m√©moire. Gr√¢ce √† cette optimisation, le temps d'ex√©cution des petits appels </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (jusqu'√† 128 octets) est r√©duit au quart de l'habituel avec une plus petite quantit√© de code (il n'est pas n√©cessaire de sauvegarder les valeurs des registres sur la pile, d'appeler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis de restaurer l'√©tat des registres). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC utilis√© pour d√©ployer le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur AMD64 √† l'aide de registres √† usage g√©n√©ral. </font><font style="vertical-align: inherit;">Maintenant, il utilise des registres vectoriels, ce qui vous permet de d√©ployer des appels deux fois plus gros. </font><font style="vertical-align: inherit;">En cons√©quence, nous obtenons un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus rapide </font><font style="vertical-align: inherit;">et ne laissons pas le code cro√Ætre. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impl√©mentations de memsets plus productives</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. Nous </font><b><font style="vertical-align: inherit;">analyserons</font></b><font style="vertical-align: inherit;"> cet article en d√©tail une autre fois.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur utilisateur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis que nous avons publi√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de nombreuses vuln√©rabilit√©s signal√©es par les utilisateurs √† MSRC ont cess√© de jouer sur les versions r√©centes de Windows. Gr√¢ce √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces vuln√©rabilit√©s sont </font><i><font style="vertical-align: inherit;">pass√©es</font></i><font style="vertical-align: inherit;"> de ¬´probl√®mes de s√©curit√©¬ª √† des ¬´d√©fauts de code qui n'ont actuellement aucune cons√©quence n√©gative¬ª. Cela signifie que nous n'avons plus besoin de fournir des mises √† jour de s√©curit√© pour les syst√®mes d'exploitation d√©j√† publi√©s avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> install√© </font><font style="vertical-align: inherit;">, ce qui √©vite aux utilisateurs le mal de t√™te qui accompagne l'installation des correctifs et Microsoft du mal de t√™te qui accompagne leur d√©veloppement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans nos branches actives du r√©f√©rentiel, nous continuons d'am√©liorer le code et de corriger les erreurs, ainsi que d'apporter des modifications aux syst√®mes d'exploitation d√©j√† publi√©s dans lesquels </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disparus et qui sont donc encore vuln√©rables. </font><font style="vertical-align: inherit;">Au fil du temps, les versions sans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne seront plus prises en charge. </font><font style="vertical-align: inherit;">Lorsque cela se produit, les erreurs neutralis√©es avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seront corrig√©es uniquement dans les branches de d√©veloppement actives, et sur les syst√®mes actuels, ce type de d√©fauts n'aura plus √† √™tre corrig√©.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plans futurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le moment, nous pr√©voyons de traiter deux t√¢ches principales dans le contexte de probl√®mes avec des variables de pile non initialis√©es:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©tudier et utiliser la possibilit√© d'appliquer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† tous les types de donn√©es allou√©es (c'est-√†-dire les tableaux de tous les types et de toutes les classes, pas seulement POD)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©ployez </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur tout le code Windows.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'avenir, nous pr√©voyons de savoir s'il est possible de normaliser le processus d'√©limination des types de probl√®mes d√©crits en C et C ++. Il n'est pas n√©cessaire de laisser les variables non initialis√©es par d√©faut pour des raisons de performances (surtout si le compilateur peut bien optimiser les op√©rations d'√©criture redondantes). Au lieu de cela, il serait pr√©f√©rable d'exiger du d√©veloppeur qu'il initialise les variables avant utilisation, "si un tel besoin a √©t√© prouv√©", et de ne violer cette r√®gle que si un mot-cl√© sp√©cial est utilis√© pour les variables non initialis√©es. Une telle solution pr√©serverait des performances √©lev√©es et en m√™me temps √©viterait aux programmeurs des erreurs inutiles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pr√©voyons de publier une autre note sur les travaux en cours pour neutraliser les vuln√©rabilit√©s de m√©moire non initialis√©es dans le m√©canisme d'allocation d'un pool de m√©moire dans le noyau Windows.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commentaire du traducteur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article n'est presque pas li√© √† mon sujet natif d'analyse de code statique, mais il m'a sembl√© int√©ressant et je voulais partager la traduction avec un public russophone. </font><font style="vertical-align: inherit;">Pour ma part, je veux ajouter que les probl√®mes de s√©curit√© associ√©s √† la ¬´fuite¬ª de donn√©es priv√©es se composent g√©n√©ralement de deux √©l√©ments. </font><font style="vertical-align: inherit;">Premi√®rement: il y a un endroit o√π les donn√©es priv√©es devraient √™tre effac√©es, mais cela ne se produit pas ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Deuxi√®mement: les donn√©es priv√©es non nettoy√©es dans le cadre de la m√©moire non initialis√©e peuvent √™tre transf√©r√©es quelque part ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exemple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505476/index.html">API CRUD sur Deno et PostegreSQL: travailler avec un dinosaure</a></li>
<li><a href="../fr505478/index.html">Remplacement d'un syst√®me CRM par un syst√®me CRM</a></li>
<li><a href="../fr505488/index.html">12 conseils pour impl√©menter TypeScript dans les applications React</a></li>
<li><a href="../fr505494/index.html">Encadrement d√©veloppeur</a></li>
<li><a href="../fr505496/index.html">Flutter Dev Podcast avec CTO Meduza Boris Goryachev: l'essentiel de l'application Meduz et du d√©veloppement des m√©dias</a></li>
<li><a href="../fr505502/index.html">Omnicanal dans le service client: que rechercher et comment tout faire correctement?</a></li>
<li><a href="../fr505506/index.html">Il ne mord pas: comment rendre les robots industriels s√ªrs pour les travailleurs</a></li>
<li><a href="../fr505508/index.html">Non seulement la technologie sans pilote: l'avenir de l'industrie automobile</a></li>
<li><a href="../fr505510/index.html">Rationalisation de l'API Check Point avec le SDK Python</a></li>
<li><a href="../fr505516/index.html">Apprentissage automatique: par o√π commencer ou comment construire le premier mod√®le</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>