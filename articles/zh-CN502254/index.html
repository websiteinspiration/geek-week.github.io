<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗿 🏚️ 🤚🏿 PostgreSQL：以人为语言（PL / Perl，PL / Python，PL / v8）进行服务器端编程 🔢 🎒 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgres以其可扩展性而闻名，这也适用于对过程语言（PL）的支持。没有人能拥有这么长的语言列表来夸耀一门语言，并且这个列表可能根本不受限制：要将语言连接到服务器，不需要额外的工作。您甚至可以提出自己的语言，并使其成为服务器过程语言。 DBMS中的更改不需要这样做。如此之多，这种可扩展性从一开始...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL：以人为语言（PL / Perl，PL / Python，PL / v8）进行服务器端编程</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres以其可扩展性而闻名，这也适用于对过程语言（PL）的支持。没有人能拥有</font><font style="vertical-align: inherit;">这么长的语言列表</font><font style="vertical-align: inherit;">来夸耀一门</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语言</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且这个列表可能根本不受限制：要将语言连接到服务器，不需要额外的工作。您甚至可以提出自己的语言，并使其成为服务器过程语言。 DBMS中的更改不需要这样做。如此之多，这种可扩展性从一开始就已内置到Postgres架构中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为任务编写PL语言是可能的，有时甚至是必要的。更好的是，如果有人编写了这样的框架来编写语言，以便您不能用C语言编写，而是选择一种对语言开发人员来说更舒适的语言。与FDW一样，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以用Python编写</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文是根据作者在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会议上就此主题撰写的大量报告和大师班的基础上撰写的</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不是关于异国情调，而是关于最常见的过程语言PL / Perl，PL / Python和PL / V8（即JavaScript）并将它们的功能与PL / pgSQL进行比较。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些语言什么时候值得使用？</font><font style="vertical-align: inherit;">什么时候缺少SQL和PL / pgSQL？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，当您需要使用复杂的结构和算法时，例如：遍历树，或者需要进行HTML或XML解析时，尤其是从存档中提取树时；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当您需要动态生成复杂的SQL（报告，ORM）时。</font><font style="vertical-align: inherit;">在PL / pgSQL上，它不仅不方便，而且在某些情况下也会运行缓慢；</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   —    .   , ,   untrusted- (  — . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有一件事：如果您要用C编写东西，那么您可以用这些语言制作一个更适合快速开发的原型。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何在Postgres中嵌入语言</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要实现您需要的语言：用C编写一到三个函数：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER-将使用该语言执行功能的调用处理程序（这是必需的部分）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE-匿名块处理程序（如果您希望语言支持匿名块）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证程序-创建功能时的代码验证功能（如果要完成此验证）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的文档中对此进行了详细描述</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“开箱即用的语言”和其他语言</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开箱即用仅支持四种语言：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tcl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是挠痒痒是对历史的致敬：现在很少有人使用它，我们不再谈论它了。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres社区支持PL / Perl，PL / Python，当然还有PL / pgSQL。他们的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维护者</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（公司，社区或对DBMS内部使用该语言感兴趣的特定开发人员）可以</font><font style="vertical-align: inherit;">支持其他非盒装语言</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣传Google。但是有时</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会有原因</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怀疑PL / V8的万里无云的未来。 Google当前的PL / V8项目维护者Jerry Sievert正在考虑基于其他引擎（例如QuickJS）的基于Postgres服务器的JS支持，因为PL / V8难以构建，并且需要3-5 GB Linux在构建时会出现各种各样的东西，这通常会在不同的OS上引起问题。但是PL / V8被广泛使用并经过全面测试。 PL / JS可能会替代其他JS引擎出现，或者暂时只是一个名称，在过渡期间我们会习惯。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很少使用。我个人不需要用PL / Java编写，因为在PL / Perl和PL / V8中，几乎所有任务都有足够的功能。甚至Python也没有特别添加功能。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于喜欢统计数据并且喜欢这种语言的人很有用。我们也不会在这里谈论他。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流行的语言不一定会在编写存储时流行：有PL / PHP，但现在几乎没有任何人支持它-很少有人想要在上面编写服务器过程。对于PL / Ruby语言，情况似乎是相同的，尽管该语言似乎更现代。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正在开发一种基于Go的过程语言，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。有必要研究它们。对于顽固的外壳爱好者，甚至还有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，甚至很难想象它的用途。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至少有一种专门针对其任务的领域特定过程语言（DSL）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-PL / Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，过去在代理和平衡服务器负载方面非常流行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将介绍主要的，最常用的语言。当然，这是PL / PgSQL，PL / Perl，PL / Python和PL / V8，我们在下面将它们称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
``开箱即用''的语言实际上几乎是开箱即用地安装的-通常安装很轻松。但是要安装PL / V8，如果您没有在操作系统的存储库中找到具有必要版本的软件包，这几乎是一项壮举，因为为此您将必须实际构建整个V8，或者换句话说，构建Chromium。同时，整个开发基础架构将连同V8一起从google.com下载-数千兆字节的流量。对于Ubuntu下的Postgres 11，尚未出现PL / V8软件包，到目前为止，版本库中仅提供了适用于PG 10的V8，如果需要，请手工组装。同样重要的是，您将在存储库中找到的版本很可能很旧。在发布本文时，最新版本为2.3.14。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安装语言本身之后，还必须“创建”该语言-在系统目录中注册它。</font><font style="vertical-align: inherit;">这应该由团队来完成。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（代替plperl，您可以替换另一种语言的名称，有些细微差别，请参见下文）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看看发生了什么：</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL不需要专门创建；它始终已经存在于数据库中。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL不应与SQL混淆。</font><font style="vertical-align: inherit;">这是另一种语言。</font><font style="vertical-align: inherit;">但是，Postgres也可以用普通SQL编写函数。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准品</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在DBMS领域，他们经常谈论遵守SQL标准。</font><font style="vertical-align: inherit;">程序语言也有标准，尽管很少被谈论。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / PSM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准</font><font style="vertical-align: inherit;">与DB2过程语言高度兼容。</font><font style="vertical-align: inherit;">尽管从概念上讲它们很接近，但是它的实现与PL / pgSQL相比还很遥远。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Java过程的标准，而PL / Java是很好的匹配。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受信任和不受信任的语言</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres程序语言是受信任的（TRUSTED）和不受信任的（UNTRUSTED）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在TRUSTED语言中，不可能直接使用I / O（包括网络），甚至不能直接使用系统资源。因此，任何数据库用户都可以创建这样的功能，破坏某些东西，而他将无法学到太多。 UNTRUSTED语言的功能只能由主管创建。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果语言解释器支持此类限制，则可以将其用于创建TRUSTED和UNTRUSTED语言。因此，对于Perl，有多种语言</font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。给</font><i><font style="vertical-align: inherit;">你</font></i><font style="vertical-align: inherit;">写信</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，它给出了语言的不受信任的特征。</font><font style="vertical-align: inherit;">Python仅存在于不受信任的版本中。</font><font style="vertical-align: inherit;">PL / v8-相反，仅在受信任的情况下。</font><font style="vertical-align: inherit;">因此，PL / v8无法从磁盘加载任何模块或库，只能从数据库加载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用UNTRUSTED语言的功能可以执行任何操作：发送电子邮件，ping网站，登录外部数据库并执行HTTP请求。</font><font style="vertical-align: inherit;">受信任的语言仅限于处理数据库中的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信任包括：</font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由UNTRUSTED包括：</font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意：没有像TRUSTED这样的PL / Python（因为您不能在该处设置对资源的访问限制），而PLpgSQL和PL / V8则是相反的：它们不是未绑定的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是Perl和Java在这两个版本中都可用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL与PL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL代码本身可与Postgres具有的所有数据类型一起使用。其他语言没有很多Postgres类型，语言解释器负责将数据转换为语言的内部表示形式，用文本替换晦涩的类型。但是，可以在TRANSFORM的帮助下为他提供帮助，我将在本文结尾处详细讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL中的函数调用通常更昂贵。其他语言的函数无需查看系统目录即可访问其库。 PL / pgSQL不能那样工作。由于支持许多类型，PL / pgSQL中的某些查询工作了很长时间：要添加两个整数，解释器需要意识到他正在处理整数而不是其他一些奇异类型，然后决定如何折叠它们，然后才真正折叠它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于PL / pgSQL是Trusted，因此无法使用它处理网络和磁盘。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在处理嵌套数据结构时，PL / pgSQL仅具有用于JSON的Postgres工具，这些工具非常繁琐且无用，而在其他语言中，使用嵌套结构要简单得多且更经济。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / *具有其自己的内存管理，因此您需要监视内存或限制它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您应该仔细监视错误处理，这对于每个人也有所不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在PL / *中，存在一个全局解释器上下文，并且可以将其用于例如缓存数据（包括查询计划）。</font><font style="vertical-align: inherit;">如果语言为UNTRUSTED，则网络和驱动器可用。</font><font style="vertical-align: inherit;">所有这些语言通常都是通过SPI与数据库一起使用的，但稍后会介绍更多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们仔细看看PL / *语言的功能。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl解释器是内存中的大量代码，但是幸运的是，在打开连接时不会创建代码，而仅在启动第一个存储过程/函数PL / Perl时创建。</font><font style="vertical-align: inherit;">初始化后，将执行Postgres配置参数中指定的代码。</font><font style="vertical-align: inherit;">通常，将加载模块并进行预计算。</font><font style="vertical-align: inherit;">
如果您在数据库运行时将其添加到配置文件中，请使Postgres重新读取配置。</font><font style="vertical-align: inherit;">在本文中，示例使用一个模块</font><font style="vertical-align: inherit;">来可视化数据结构。</font><font style="vertical-align: inherit;">
有用于分别初始化TRUSTED和UNTRUSTED Perl的参数，当然还有参数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">那些用Perl编程的人知道，没有</font><font style="vertical-align: inherit;">它不是一种语言，而是一种误解。</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在其中，解释程序是在首次访问时以相同的方式创建的。在这里重要的是立即决定要使用哪个python：第二个还是第三个。如您所知，Python存在两种流行的版本（Python 2和Python 3），但问题在于它们的“笨拙”无法在一个过程中融洽相处：名称上存在冲突。如果您在一个会话中使用v2，然后调用v3，则Postgres将崩溃，对于服务器进程（后端），这将是一个致命错误。要访问其他版本，您需要打开另一个会话。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与Perl不同，无法告知python在初始化期间要做什么。另一个不便之处是：单班轮工作不便。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在所有Python函数中，定义了两个字典-static </font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和global </font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。全局</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个后端内与所有功能交换数据-同时具有吸引力和危险性。</font><font style="vertical-align: inherit;">每个函数都有一个静态字典。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PL / Python中，您可以进行子事务，我们将在下面进行讨论。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是仅受信任的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方便地，JSON数据会自动转换为JS结构。在PL / V8中，就像在PL / Python中一样，您可以进行子事务。有一个用于简化函数调用的接口。这是唯一</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以定义窗口函数的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序语言</font><font style="vertical-align: inherit;">。他们建议</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在PL / R上定义</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们</font><font style="vertical-align: inherit;">，但是这种语言不在本文的讨论范围之内。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且只有在PL / V8中，执行超时。的确，默认情况下未打开它，并且如果您手动构建PL / V8，则需要说它在组装期间已打开，然后可以使用配置参数为函数调用设置超时。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / V8中的初始化看起来很有趣：由于它是受信任的，因此无法从磁盘读取库，也无法从任何地方加载任何内容。</font><font style="vertical-align: inherit;">他只能从基地拿走他需要的一切。</font><font style="vertical-align: inherit;">因此，定义了一个存储的初始化函数，该函数在语言解释器启动时调用。</font><font style="vertical-align: inherit;">函数名称在特殊的配置参数中指定：</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在初始化期间，可以通过将全局变量和函数的值分配给此变量的属性来创建它们。</font><font style="vertical-align: inherit;">例如，像这样：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实践中PL / Perl与PL / Python与PL / V8的比较</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你好，世界！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们用这三种语言的输出执行一个简单的练习，首先是在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">并且让他做其他有用的事情，例如，告诉他的版本：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您也可以使用通常的Perl函数</font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。更确切地说，在PL / Python3u（不受信任）上-用于确定性。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用</font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以从Postgres消息中提取很多内容：它们包含提示，详细信息，行号和许多其他参数。</font><font style="vertical-align: inherit;">在PL / Python中可以传递它们，但不能在考虑中的其他语言中传递它们：它们的含义只能用纯文本行来诅咒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PL / Python中，每个postgres日志记录级别都有其自己的功能：NOTICE，WARNING，DEBUG，LOG，INFO，FATAL。</font><font style="vertical-align: inherit;">如果为ERROR，则表示事务已下降；如果为FATAL，则整个后端均下降。</font><font style="vertical-align: inherit;">幸运的是，此事尚未解决。</font><font style="vertical-align: inherit;">你可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里阅读</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这种语言中，Hello world与Pearl非常相似。</font><font style="vertical-align: inherit;">您可以退出</font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这也将是错误处理，尽管这些工具没有Python中的先进工具。</font><font style="vertical-align: inherit;">如果你写</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，顺便说一句，效果是一样的。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与基地合作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看如何使用存储过程中的数据库。 Postgres具有SPI（服务器编程接口）。这是一组C函数，所有扩展作者均可使用。几乎所有的PL语言都为SPI提供包装器，但是每种语言都有一些不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与PL / PgSQL和其他过程语言相比，用C编写但使用SPI的函数不太可能获得显着收益。但是，绕过SPI并在没有中介的情况下处理数据的C函数（例如</font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）将加快一个数量级。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Java也使用SPI。但是使用JDBC和JDBC标准仍然需要使用数据库。对于PL / Java中的代码创建者而言，一切都像在客户端应用程序上进行一样，但是JNI（Java本机接口）将对数据库的调用转换为相同的SPI函数。这很方便，并且没有将这个原理转换为PL / Perl和PL / Python的基本障碍，但是由于某种原因，这还没有完成，到目前为止，它在计划中是不可见的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，如果您愿意，可以按照通常的方式-通过DBI或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前往外国基地</font><font style="vertical-align: inherit;">。可以到本地数据库，但是为什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您没有进入整体主题“客户端上的基本流程还是客户端上的流程”，而是立即从最大程度地接近数据进行处理（至少是为了不通过网络驱动大量样本），那么使用存储在服务器上的功能的解决方案就可以了自然。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：请记住，SPI有一些开销，函数中的SQL查询可能比没有函数时要慢。第13个postgres包含</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Knizhnik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">补丁程序</font></a><font style="vertical-align: inherit;">，可降低这些成本。但是，当然，在存储的函数中查询结果的处理不需要将结果传输到客户端，因此在性能方面可能是有益的。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：一组经过调试和测试的功能可将数据库结构与用户隔离，防止SQL注入和其他恶作剧。</font><font style="vertical-align: inherit;">否则，这将使每个应用程序开发人员头疼。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重用：如果大量复杂的应用程序与数据库一起使用，则将有用的功能存储在服务器上很方便，而不是在每个应用程序中再次编写它们。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们如何以及以什么形式从数据库中获取数据</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，一切都很简单明了。</font><font style="vertical-align: inherit;">调用</font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回已处理的行数，状态和SQL查询选择的行数组：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查询和结果看起来像这样，但是这里的函数并不返回数据结构，而是一个可以用不同方式使用的特殊对象。</font><font style="vertical-align: inherit;">通常，它伪装成一个数组，因此，您可以从中提取字符串。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们走第一行，离开X并得到值-数字。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了查看结构，我们使用了库函数JSON.stringify，它不需要专门加载，默认情况下已经准备好用作PL / v8的一部分。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏蔽层</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为避免恶意SQL注入，必须对查询中的某些字符进行转义。为此，首先存在像SPI包装器一样工作的SPI函数和相应的函数（用C编写）。例如，在PL / Perl中：</font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-接受撇号并加倍'和\。设计用于筛选文本数据。</font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-相同，但</font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换为NULL。</font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-如有必要，引用表或字段的名称。在构造SQL查询并替换其中的数据库对象名称时很有用。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请记住：表名不能像文本行一样转义。</font><font style="vertical-align: inherit;">这就是为什么有一个功能</font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在PL / Perl中，还有其他函数可以屏蔽单个post-gres类型的数据：</font><font style="vertical-align: inherit;">
函数</font><font style="vertical-align: inherit;">应接受任何类型并将非典型可疑字符转换为显然安全的字符。</font><font style="vertical-align: inherit;">它适用于大量类型，但是，并非所有类型都适用。</font><font style="vertical-align: inherit;">例如，她不会理解</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">范围类型</font></a><font style="vertical-align: inherit;">，只会将</font><font style="vertical-align: inherit;">它们简单地</font><font style="vertical-align: inherit;">理解</font><font style="vertical-align: inherit;">为文本字符串。</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有</font><font style="vertical-align: inherit;">三个类似的功能</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，他们在几乎相同的方式工作：</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8中的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
功能是否相同</font><font style="vertical-align: inherit;">？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然！</font><font style="vertical-align: inherit;">一切都取决于语法功能。</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哪种语言最快？通常他们回答：C。但是正确的答案是C </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL。为什么要使用SQL？事实是这种语言的功能并非总是显式执行。它可以嵌入到请求中（调度程序会将功能嵌入主请求的主体中），可以根据请求进行优化，并且结果更快。但是在什么条件下可以将代码嵌入请求中？您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解一些简单的条件</font><font style="vertical-align: inherit;">。例如，不应以所有者的权利（为SECURITY DEFINER）执行功能。最简单的功能将适合这些条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将不认真地“量度”膝盖。我们需要一个粗略的比较。首先打开时间：</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试一下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以下命令的执行时间是作者在已卸载六岁的PC上获得的四舍五入的平均值。可以将它们相互比较，但它们并不声称是科学的）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它运作非常快。</font><font style="vertical-align: inherit;">在其他语言中，浪费时间从该语言调用函数。</font><font style="vertical-align: inherit;">当然，由于解释程序的初始化，第一次请求运行速度会变慢。</font><font style="vertical-align: inherit;">然后稳定下来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python：</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是Python2。现在是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请记住：Python2和Python3在同一个会话中不能和平共处，可能会导致名称冲突）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这是非常快的。</font><font style="vertical-align: inherit;">让我们尝试执行查询1000次或1百万次，突然之间的差异将更加明显：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，使用PL / V8，该实验以一千次而不是一百万次迭代完成。凭借适度的资源，PL / V8可以在一百万次操作中消耗掉所有内存并完全挂掉汽车。经过一千次迭代，postgres进程选择了3.5GB内存和100％写入磁盘。实际上，postgres启动了V8环境，并且当然会占用内存。执行完请求后，这个涡轮怪物将不会退还内存。要释放内存，您必须结束会话。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到PL / pgSQL已经比PL / Perl和PL / Python快2倍。 PL / V8仍然落后于他们，但在文章结尾时，他已部分康复。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，在这些实验中使用Python的Perl显示出大致相同的结果。</font><font style="vertical-align: inherit;">Perl过去不如Python；在现代版本中，它稍快一些。</font><font style="vertical-align: inherit;">第三个python慢​​于第二个。</font><font style="vertical-align: inherit;">整体差异在15％以内。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREPARE的性能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
认识的人会明白：出事了。</font><font style="vertical-align: inherit;">PL / pgSQL可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动缓存查询计划</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且在PL / *中，每次再次计划查询时。</font><font style="vertical-align: inherit;">以一种很好的方式，您需要准备请求，建立一个请求计划，然后根据该计划，它们应根据需要执行多次。</font><font style="vertical-align: inherit;">在PL / *中，您可以显式使用查询计划，我们将尝试从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl开始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的两种语言，我们几乎赶上了PL / pgSQL，而第三种语言也想要，但由于对内存的需求不断增长，未能达到终点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是如果您不考虑内存，那么很显然所有语言几乎都是正面交锋-并非偶然。</font><font style="vertical-align: inherit;">他们的瓶颈现在很常见-通过SPI使用数据库。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算性能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到语言的性能取决于使用数据库。</font><font style="vertical-align: inherit;">为了将语言相互比较，让我们尝试计算一些内容而不求助于数据库，例如平方和。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到PL / Perl和PL / Python超过并超过了PL / pgSQL，它们快了4倍。</font><font style="vertical-align: inherit;">八个人都在流泪！</font><font style="vertical-align: inherit;">但这真的是一无是处吗？</font><font style="vertical-align: inherit;">还是我们可以得到它？</font><font style="vertical-align: inherit;">是的，我们会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript中的数字是浮点数，结果很快，但不准确：333333833333127550而不是333333833333500000。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是用于计算确切结果的</font><font style="vertical-align: inherit;">公式</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">∑ = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为练习，您可以使用数学归纳法证明这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按照笑声的顺序</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Javascript中，</font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它仍然执行浮点运算，而不是Int。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管如此，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">于2018年出现在V8中</font><font style="vertical-align: inherit;">，现在可以确定地对其进行计数，但不利于速度，因为它不是64位整数，而是任意位深度的整数。</font><font style="vertical-align: inherit;">但是，在PL / V8中，这种创新尚未实现。</font><font style="vertical-align: inherit;">在其他过程语言中，</font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过特殊的库支持</font><font style="vertical-align: inherit;">任意位数（SQL的模拟</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Perl中，有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math :: BigFloat模块，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于以任意精度进行算术；在Python中，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bigfloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包</font><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">围绕</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">GNU MPFR</font></a><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装器</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能功能进行分类</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个实际示例，该示例显示了使用不同语言编写的函数按功能排序的性能差异。</font><font style="vertical-align: inherit;">任务：对包含日记帐发行编号的文本字段进行排序，可能如下：</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些。</font><font style="vertical-align: inherit;">它实际上是一个字符串，但它以数字开头，您需要按这些数字进行排序。</font><font style="vertical-align: inherit;">因此，为了正确地按字符串排序，我们在数字部分的左边加零以得到：</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，我知道这不是解决问题的唯一方法（甚至还不是很正确）。</font><font style="vertical-align: inherit;">但是，例如，它将做到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要请求类型，</font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在PL / Perl，SQL，PL / Python和PL / V8中编写了将日记帐号转换为以下形式的函数：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我的1.55万本期刊文章库中，使用PL / Perl中的函数进行查询大约需要64毫秒，而PL / Python中为120毫秒，而PL / PgSQL中为200毫秒。</font><font style="vertical-align: inherit;">但最快-PL / v8：54ms。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试排序时，请提供必要的工作内存量，以便排序进入内存（然后将显示“ EXPLAIN” </font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">内存量由参数设置</font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl不喜欢环状结构；他不知道如何清理它们。</font><font style="vertical-align: inherit;">如果您</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个指向</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和的</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则该参考计数器将永远不会被重置，并且内存也不会被释放。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
垃圾回收语言还有其他问题。</font><font style="vertical-align: inherit;">例如，何时释放内存还是根本不释放内存是未知的。</font><font style="vertical-align: inherit;">或者-如果您不小心处理此问题-收集者将在最不适当的时刻去收集垃圾。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，还有一些与Postgres直接相关的内存管理功能。</font><font style="vertical-align: inherit;">有SPI分配的结构，Perl并不总是意识到它们需要被释放。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
并非如此：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，它去了：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行后，处理程序</font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将保持活动状态，尽管事实上并没有与之保持任何联系的事实。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没关系，您只需要记住需要使用以下命令显式释放资源</font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永不流行</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该计划会自动发布：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
与Perl的故事相同。</font><font style="vertical-align: inherit;">它不会像这样流动：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‘
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，它去了：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再说一遍：不要忘记释放资源。</font><font style="vertical-align: inherit;">在这里它。</font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它不流：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参量</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是时候了解如何将参数传递给函数了。</font><font style="vertical-align: inherit;">在示例中，我们将4个带有类型的参数传递给函数：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytea和</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们</font><font style="vertical-align: inherit;">如何</font><font style="vertical-align: inherit;">进入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是JSON还是JSONB-在这种情况下，没有区别：它们仍然以字符串形式出现。这是多功能性的费用：Postgres有很多类型，不同程度的“嵌入”。要求开发人员立即使用新类型为所有PL / *提供转换功能，这将太多了。默认情况下，许多类型作为字符串传递。但这并不总是很方便，您必须解析这些术语。当然，我希望Postgres数据能立即变成适当的Perl结构。默认情况下不会发生这种情况，但是从9.6开始，出现了TRANSFORM机制-定义类型转换函数的能力：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要创建TRANSFORM，您需要用C编写两个函数：一个将某种类型的数据转换为一侧，另一侧转换为另一种。</font><font style="vertical-align: inherit;">请注意，TRANSFORM在四个地方起作用：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将参数传递给函数时；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回函数值时；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将参数传递给函数内部的SPI调用时；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到函数内部SPI调用的结果后。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由Anton Bykov开发的针对Perl和Python的TRANSFORM JSONB，出现在Postgres的第11版中。</font><font style="vertical-align: inherit;">现在，您无需解析JSONB，它就会作为相应的结构立即进入Perl。</font><font style="vertical-align: inherit;">您必须创建jsonb_plperl扩展，然后才能使用TRANSFORM：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以调用此函数来验证JSONB已变成珍珠哈希：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全不同的事情！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文的作者还参与了TRANSFORM的开发。原来，这种简单的数据类型</font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以不方便的形式传递给PL / Perl，例如文本字符串</font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是按照Perl的理解，字符串'f'是正确的。为了消除不便，发明</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">补丁</font></a><font style="vertical-align: inherit;">，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">补丁定义了Boolean类型的转换</font></a><font style="vertical-align: inherit;">。该补丁已在PostgreSQL 13上发布，即将发布。由于其简单性，bool_plperl可以用作编写任何其他转换的最小启动模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望有人能为其他数据类型（字节，数组，日期，数字）开发TRANSFORM。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看如何在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中传递参数</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将数组转换为数组-很好（因为PG10版本多维数组也已正确传输到python）。</font><font style="vertical-align: inherit;">在Perl中，数组被转换为特殊类的对象。</font><font style="vertical-align: inherit;">好吧，</font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变了。</font><font style="vertical-align: inherit;">如果没有TRANSFORM，则jsonb将作为字符串传递。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看参数以什么形式进入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONB无需任何转换即可转换为JavaScript对象！</font><font style="vertical-align: inherit;">临时Postgres类型也将转换为Date JS类型。</font><font style="vertical-align: inherit;">布尔值也一样。</font><font style="vertical-align: inherit;">所有转换都已内置到PL / V8中。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无限工作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INFINITY常量并不经常使用，但是随便使用它很危险。</font><font style="vertical-align: inherit;">在PostgreSQL中，对于某些临时和浮点类型，Infinity和-Infinity作为特殊值存在。</font><font style="vertical-align: inherit;">但是必须详细讨论将Infinity转换为过程语言的过程，反之亦然，因为使用它们不仅可以依赖于语言，还可以依赖于库，操作系统甚至是硬件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python有一个定义数字无穷大的Numpy模块：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl也具有无穷大，它使用</font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以缩短为</font><font style="vertical-align: inherit;">的字符串</font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，您可以说：</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要么</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PL / Perl，PL / Python，PL / v8中，可以正确传递Postgres的数值无穷大，但无限日期不太正确。</font><font style="vertical-align: inherit;">相反，在PL / Perl和PL / Python中，没有用于时间的内置数据类型，而是一个字符串。</font><font style="vertical-align: inherit;">在PL / V8中，有一个内置类型Date，而postgres中的通常日期变成了它。</font><font style="vertical-align: inherit;">但是V8不知道无休止的日期，当转移时，它变成</font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将参数传递给准备好的请求</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回</font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，考虑如何将参数传递到那里。</font><font style="vertical-align: inherit;">不同的语言有很多共同点，因为它们都是基于SPI的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备查询时</font><font style="vertical-align: inherit;">，需要确定要传递的参数的类型，并且在运行查询时，只需指定这些参数的值（这些参数以相同的方式传递给PL / pgSQL）。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本质是相同的，但是语法略有不同：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差异很小：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都不同。</font><font style="vertical-align: inherit;">在那里，显然不使用SPI，但是形成了到数据库的伪JDBC连接。</font><font style="vertical-align: inherit;">对于PL / Java程序员来说，一切都像他在创建客户端应用程序一样。</font><font style="vertical-align: inherit;">这很方便，也可以进行PL / Perl和PL / Python的设计，但是由于某种原因，它没有完成（但是，没有人禁止创建更多PL / Perl和PL / Python的实现）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用游标</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们进入数据库时​​使用的所有SPI函数</font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及其他函数都有一个参数，该参数限制返回的行数。</font><font style="vertical-align: inherit;">如果您需要大量返回的行，那么就不能没有光标将它们向上拉一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
游标使用所有这些语言。</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl中，</font></font></b> <br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回一个游标，您可以一次从中提取字符串。</font><font style="vertical-align: inherit;">不必关闭游标；它会自行关闭。</font><font style="vertical-align: inherit;">但是，如果要重新发现它，可以使用command显式关闭它</font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有内容都非常相似，但是将光标显示为可以循环浏览的对象：</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / v8中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有内容也非常相似，但不要忘记释放准备好的查询计划：</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8：快速访问功能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PL / V8中，您可以从常规SELECT中调用一个函数，而不必按名称查找它，然后立即使用启动它</font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是请记住，在JS中，函数不能像PostgreSQL中那样是多态的，在PostgreSQL中，具有相同名称但具有不同参数的函数可以共存。</font><font style="vertical-align: inherit;">当然，在PL / v8中，我们可以创建多态函数，但是在尝试使用</font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">会出错。</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果名称上的函数是明确的，则可以在不进行SPI和类型转换的情况下调用该函数，即 </font><font style="vertical-align: inherit;">快多了。</font><font style="vertical-align: inherit;">例如，像这样：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易次数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres 11有很多乐趣：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真正的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">已经出现</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Postgres过去仅具有功能。</font><font style="vertical-align: inherit;">快乐的原因不仅在于与SQL标准的兼容性和合规性，还在于原因：在过程中您可以提交和回滚事务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl和PL / Python已经具有用于管理事务的SPI功能，而PL / V8还没有。</font><font style="vertical-align: inherit;">在PL / Perl中，这些函数被称为</font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在文档中提供</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了使用示例</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在PL / Python中，这是</font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子交易</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子事务在复杂的多级逻辑中方便进行正确的错误处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font><font style="vertical-align: inherit;">事务内部的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，每个带有EXCEPTION关键字的块都是一个子事务。您可以阅读有关在这种情况下可能出现的一些性能和可靠性问题，例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">PL / Perl</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
中</font><font style="vertical-align: inherit;">没有显式的子事务，但是可以通过savaepoints模拟它们。显然，如果您愿意，可以很容易地编写一个Pearl模块，该模块以显式形式实现子事务。</font><font style="vertical-align: inherit;">
在</font><b><font style="vertical-align: inherit;">PL / Python中，</font></b><font style="vertical-align: inherit;">子交易早就出现了：从9.5 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">显式开始</font></a><font style="vertical-align: inherit;">，在此之前有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">隐式交易</font></a><font style="vertical-align: inherit;">。您可以定义一个事务，将其包装</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并执行。</font><font style="vertical-align: inherit;">如果子交易失败，那么我们就落入该区块</font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；如果它没有下跌，则就进入该区块</font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并继续前进。</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
存在类似的设计</font><font style="vertical-align: inherit;">，仅使用JS语法。</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尝试，但不要滥用:)了解PL / *可以带来一些好处。</font><font style="vertical-align: inherit;">像任何工具一样，他们喜欢被用于预期的目的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / v8非常有前景，但是有时它的行为异常并且存在许多问题。</font><font style="vertical-align: inherit;">因此，如果适合您的任务，最好将语言开箱即用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我要感谢Igor Levshin（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伊戈尔</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），他为我准备本文的材料提供了很多帮助，并提出了一些有用的想法，还有叶夫根尼·谢尔盖耶夫（Evgeny Sergeev）和阿列克谢·法德耶夫（Alexey Fadeev）提出了一些更正建议。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN502236/index.html">儿童飞机模型-体面的水平</a></li>
<li><a href="../zh-CN502246/index.html">爱丽丝的大胆回答与无人机有什么共同点？</a></li>
<li><a href="../zh-CN502248/index.html">新的数字资源GOST生效：残疾人应可使用所有平台</a></li>
<li><a href="../zh-CN502250/index.html">今日民航：培训的重要方面和挑战</a></li>
<li><a href="../zh-CN502252/index.html">遥控器和无人机</a></li>
<li><a href="../zh-CN502256/index.html">如何使用Neo4j可视化Spring Integration图？</a></li>
<li><a href="../zh-CN502260/index.html">ESP-NOW是ESP8266和ESP32的替代通信协议。基本概念</a></li>
<li><a href="../zh-CN502262/index.html">为什么要对银行进行AIOps和总体监控，或建立在什么客户关系上</a></li>
<li><a href="../zh-CN502264/index.html">公钥基础结构。在自我隔离的情况下签发证书</a></li>
<li><a href="../zh-CN502266/index.html">英特尔平台上的Aurora。Exaflops时代的黎明</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>