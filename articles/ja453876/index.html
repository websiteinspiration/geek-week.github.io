<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎭 🐦 ❕ Yandex.Practicumの場合と同様に、フロントエンドの非同期化が成功しました：Redux-Saga、postMessage、Jupyterによるアクロバティックな数値 🤦🏾 🤽🏽 👩🏽‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私の名前はArtyom Nesmiyanovです。Yandex.Practicumのフルスタック開発者です。主にフロントエンドを担当しています。私たちは、プログラミング、データ分析、その他のデジタルクラフトを楽しく研究することが可能であり、必要であると信じています。そして、学習を開始し、続けます。自...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Yandex.Practicumの場合と同様に、フロントエンドの非同期化が成功しました：Redux-Saga、postMessage、Jupyterによるアクロバティックな数値</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/453876/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の名前はArtyom Nesmiyanovです。Yandex.Practicumのフルスタック開発者です。主にフロントエンドを担当しています。</font><font style="vertical-align: inherit;">私たちは、プログラミング、データ分析、その他のデジタルクラフトを楽しく研究することが可能であり、必要であると信じています。</font><font style="vertical-align: inherit;">そして、学習を開始し、続けます。</font><font style="vertical-align: inherit;">自分をあきらめなかった開発者は、常に「継続」しています。</font><font style="vertical-align: inherit;">私達もです。</font><font style="vertical-align: inherit;">したがって、私たちは仕事のタスクを学習形式として認識します。</font><font style="vertical-align: inherit;">そして、最近の問題の1つは、フロントエンドスタックを開発する方向を理解するのに役立ちました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u2/uh/nx/u2uhnxzsc0hv3v7clkqskbzwnc0.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワークショップの構成者と構成者</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発チームは非常にコンパクトです。</font><font style="vertical-align: inherit;">バックエンドとフロントエンドには2人しかいません-私を考えると4人でフルスタックです。</font><font style="vertical-align: inherit;">時々、Yandex.Tutorialのメンバーが補強に加わります。</font><font style="vertical-align: inherit;">私たちは2週間のスプリントでスクラムに取り組んでいます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのフロントエンドはRedux / Redux-Sagaと連携したReact.jsに基づいており、Expressを使用してバックエンドと通信します。</font><font style="vertical-align: inherit;">スタックのバックエンド部分はPython（正確にはDjango）であり、データベースはPostgreSQL、一部のタスクではRedisです。</font><font style="vertical-align: inherit;">Reduxを使用して、情報ストレージを保存し、ReduxおよびRedux-Sagaによって処理されるアクションを送信します。</font><font style="vertical-align: inherit;">サーバー要求、Yandex.Metricaへの呼び出し、リダイレクトなどのすべての副作用は、Redux-Sagaでのみ処理されます。</font><font style="vertical-align: inherit;">そして、すべてのデータ変更はReduxレデューサーで行われます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iframeでログを見落とさないようにする方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、私たちのプラットフォームでは、トレーニングはフロントエンド開発者、Web開発者、データ分析者の3つの専門職で開かれています。また、各コースのツールを積極的に開発しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6か月コースの「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データアナリスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Jupyter Notebookの使用方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をユーザーに教えるインタラクティブシミュレーターを作成しました</font><font style="vertical-align: inherit;">。これは、データサイエンティストに愛されているインタラクティブコンピューティングのクールなシェルです。環境内のすべての操作はノートブック内で実行されますが、簡単な方法-ノートブック（後で呼び出します）で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経験のプロンプト、そして私達は確信しています：訓練タスクは実際に近いことが重要です。作業環境を含めて。したがって、レッスン内ですべてのコードをノートブックで直接記述、実行、およびチェックできることを確認する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
困難の基本的な実装では発生しませんでした。ノートブック自体を別のiframeにまとめ、バックエンドでの検証ロジックを規定しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2z/_9/iy/2z_9iyuj7pmha0ielvj4evuyhic.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学生のノートブック自体（右側）は、JupyterHubの特定のノートブックにリンクするURLの単なるiframeです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初の近似では、すべてが問題なく、問題なく機能しました。しかし、テスト中に不条理が出てきました。たとえば、正しいバージョンのコードをノートブックに取り込むことが保証されていますが、[テストタスク]ボタンをクリックした後、サーバーはおそらく答えが正しくないと応答します。そしてなぜ-謎。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、何が起こっているのか、バグを発見したのと同じ日に気づきました。飛行していないソリューションは、Jupyter Notebookフォームに入力されたばかりの現在のソリューションであることが判明しましたが、以前のソリューションはすでに消去されていました。ノートブック自体は存続する時間がないため、バックエンドの速度を下げて、バックエンドでタスクを確認しました。もちろん、彼ができなかったこと。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノートブックを保存してからサーバーにリクエストを送信してチェックするまでの間に、rassinhronを取り除く必要がありました。問題は、ノートブックのiframeを親ウィンドウ、つまりレッスン全体が回転しているフロントエンドと通信させる必要があることでした。もちろん、それらの間でイベントを直接転送することは不可能でした。彼らは異なるドメインに住んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策を探していたところ、Jupyter Notebookでプラグインを接続できることがわかりました。操作できるJupiterオブジェクト（ノートブック）があります。これを使用するには、ノートブックの保存や適切なアクションの呼び出しなどのイベントが必要です。 Jupyterの内部を理解した後（私はそれを行うための通常のドキュメントはありませんでした）、みんなと私はそれを行いました-私たちはそれのために独自のプラグインを構築し、postMessageメカニズムを使用して、ワークショップレッスンが組み立てられた要素の調整された作業を達成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのスタックには最初にすでに述べたRedux-Sagaが含まれているという事実を考慮して回避策を考えました-簡単に言えば、Reduxの上にミドルウェアを配置すると、副作用により柔軟に作業できるようになります。たとえば、ノートブックの保存は、このような副作用のようなものです。バックエンドに何かを送信し、何かを待って、何かを取得します。この動きはすべてRedux-Sagaによって内部的に処理されます。フロントエンドにイベントをスローし、UIに何を表示するかを指示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はどうですか？ PostMessageが作成され、ノートブックとともにiframeに送信されます。 iframeは、何かが外部からのものであることを検出すると、受信した文字列を解析します。ノートブックを保持する必要があることを認識して、彼はこのアクションを実行し、次に、要求の実行に関する応答postMessageを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「テストジョブ」ボタンをクリックすると、対応するイベントがReduxストアに送信されます。 Redux-Sagaはアクションが到着したことを確認し、iframeでpostMessageを実行します。今、彼女はiframeが答えるのを待っています。それまでの間、生徒は[タスクを確認]ボタンにダウンロードインジケーターを表示し、シミュレーターがハングしないで「考える」ことを理解しています。そして、保存が完了したとpostMessageが戻ってきたときのみ、Redux-Sagaは引き続き機能し、バックエンドにリクエストを送信します。タスクはサーバーでチェックされます-間違いがあった場合の正しい解決策かどうか、それから、など、そしてこの情報はReduxストアにきちんと保存されます。そして、そこから、フロントエンドスクリプトがそれをレッスンインターフェイスに取り込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の回路は次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/gc/eu/ksgceup6hokoh9jtvqoajegbjfc.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）「タスクを確認する」ボタンを押します（チェック）→（2）アクションCHECK_NOTEBOOK_REQUESTを送信します→（3）チェックのアクションを送信します→（2）アクションを送信しますSAVE_NOTEBOOK_REQUEST→（3）アクションをキャッチし、iframeでpostMessageを送信します→イベントを保存します（4）メッセージを受信する→（5）ノートブックが保存される→（4）ノートブックが保存されていることをJupyter APIからイベントを受信し、postMessage notebook-sa​​vedを送信する→（1）イベントを受信する→（2）アクションを送信するSAVE_NOTEBOOK_SUCCESS→（3）アクションをキャッチするノートブックのチェック要求を送信→（6）→（7）このノートブックがデータベースにあることを確認→（8）→（7）ノートブックコードを探す→（5）コードを返す→（7）コードチェックを実行→（9 ）→（7）検証結果を取得します→（6）→（3）アクションCHECK_NOTEBOOK_SUCCESSを送信します→（2）検証応答をパーティーに追加します→（1）結果を描画</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
しますコードのコンテキストですべてがどのように</font><i><font style="vertical-align: inherit;">機能</font></i><font style="vertical-align: inherit;">するかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドにtrainer_type_jupyter.jsx-ノートブックが描画されるページのスクリプトがあります。 </font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"trainer__right-column"</span>&gt;</span><font></font>
    {notebookLinkIsLoading<font></font>
        ? (<font></font>
            <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> 
                <span class="hljs-attr">className</span>=<span class="hljs-string">"trainer__jupiter-frame"</span>
                <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.onIframeRef}</span>
                <span class="hljs-attr">src</span>=<span class="hljs-string">{notebookLink}</span>
            /&gt;</span><font></font>
     ) : (<font></font>
         <span class="hljs-tag">&lt;<span class="hljs-name">Spin</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"l"</span> <span class="hljs-attr">mix</span>=<span class="hljs-string">"trainer__jupiter-spin"</span> /&gt;</span><font></font>
     )}<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ジョブのチェック」ボタンをクリックした後、handleCheckTasksメソッドが呼び出されます。</font></font><br>
<br>
<pre><code class="xml hljs">handleCheckTasks = () =&gt; {<font></font>
       const {checkNotebook, lesson} = this.props;<font></font>
<font></font>
       checkNotebook({id: lesson.id, iframe: this.iframeRef});<font></font>
   };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、handleCheckTasksは、渡されたパラメーターを使用してReduxアクションを呼び出す役割を果たします。</font></font><br>
<br>
<pre><code class="xml hljs">export const checkNotebook =   getAsyncActionsFactory(CHECK_NOTEBOOK).request;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Redux-Sagaおよび非同期メソッド用に設計された一般的なアクションです。</font><font style="vertical-align: inherit;">ここでgetAsyncActionsFactoryは3つのアクションを生成します：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// utils / store-helpers / async.js</font></font><br>
<br>
<pre><code class="xml hljs">export function getAsyncActionsFactory(type) {<font></font>
   const ASYNC_CONSTANTS = getAsyncConstants(type);<font></font>
<font></font>
   return {<font></font>
       request: payload =&gt; ({type: ASYNC_CONSTANTS.REQUEST, payload}),<font></font>
       error: (response, request) =&gt; ({type: ASYNC_CONSTANTS.ERROR, response, request}),<font></font>
       success: (response, request) =&gt; ({type: ASYNC_CONSTANTS.SUCCESS, response, request}),<font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、getAsyncConstantsは* _REQUEST、* _SUCCESS、および* _ERRORの形式の3つの定数を生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このエコノミーがRedux-Sagaをどのように処理するかを見てみましょう：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// trainer.saga.js</font></font><br>
<br>
<pre><code class="xml hljs">function* watchCheckNotebook() {<font></font>
   const watcher = createAsyncActionSagaWatcher({<font></font>
       type: CHECK_NOTEBOOK,<font></font>
       apiMethod: Api.checkNotebook,<font></font>
       preprocessRequestGenerator: function* ({id, iframe}) {<font></font>
           yield put(trainerActions.saveNotebook({iframe}));<font></font>
<font></font>
           yield take(getAsyncConstants(SAVE_NOTEBOOK).SUCCESS);<font></font>
<font></font>
           return {id};<font></font>
       },<font></font>
       successHandlerGenerator: function* ({response}) {<font></font>
           const {completed_tests: completedTests} = response;<font></font>
<font></font>
           for (let id of completedTests) {<font></font>
               yield put(trainerActions.setTaskSolved(id));<font></font>
           }<font></font>
       },<font></font>
       errorHandlerGenerator: function* ({response: error}) {<font></font>
           yield put(appActions.setNetworkError(error));        <font></font>
       }<font></font>
   });<font></font>
<font></font>
   yield watcher();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マジック？特別なことはありません。ご覧のとおり、createAsyncActionSagaWatcherは、アクションに入るデータを前処理し、特定のURLでリクエストを作成し、* _REQUESTアクションをディスパッチし、サーバーからの正常な応答に対して* _SUCCESSおよび* _ERRORをディスパッチするウォーターマークを作成するだけです。さらに、当然のことながら、オプションごとに、ハンドラーが時計の内部に提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データプリプロセッサで別のRedux-Sagaを呼び出し、SUCCESSで終了するまで待ってから、作業を続けることに気づいたと思います。もちろん、iframeをサーバーに送信する必要はないので、IDのみを指定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
saveNotebook関数を詳しく見てみましょう。</font></font><br>
<br>
<pre><code class="xml hljs">function* saveNotebook({payload: {iframe}}) {<font></font>
   iframe.contentWindow.postMessage(JSON.stringify({<font></font>
       type: 'save-notebook'<font></font>
   }), '*');<font></font>
<font></font>
   yield;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iframeとフロントエンドの相互作用で最も重要なメカニズムであるpostMessageに到達しました。</font><font style="vertical-align: inherit;">指定されたコードフラグメントは、iframe内で処理されるsave-notebookタイプのアクションを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノートブック内に読み込まれるJupyter Notebookのプラグインを作成する必要があることはすでに述べました。</font><font style="vertical-align: inherit;">これらのプラグインは次のようになります。</font></font><br>
<br>
<pre><code class="xml hljs">define([<font></font>
   'base/js/namespace',<font></font>
   'base/js/events'<font></font>
], function(<font></font>
   Jupyter,<font></font>
   events<font></font>
) {...});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような拡張機能を作成するには、Jupyter Notebook API自体を処理する必要があります。</font><font style="vertical-align: inherit;">残念ながら、それに関する明確な文書はありません。</font><font style="vertical-align: inherit;">しかし、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は入手可能</font><font style="vertical-align: inherit;">であり、私はそれらを掘り下げました。</font><font style="vertical-align: inherit;">そこでコードが読めるのは良いことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラグインは、レッスンのフロントエンドで親ウィンドウと通信するように教えられる必要があります。結局のところ、それらの間の非同期はタスク検証でのバグの原因です。</font><font style="vertical-align: inherit;">まず、受信したすべてのメッセージをサブスクライブします。</font></font><br>
<br>
<pre><code class="xml hljs">window.addEventListener('message', actionListener);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、それらの処理を提供します。</font></font><br>
<br>
<pre><code class="xml hljs">function actionListener({data: eventString}) {<font></font>
       let event = '';<font></font>
<font></font>
       try {<font></font>
           event = JSON.parse(eventString);<font></font>
       } catch(e) {<font></font>
	return;<font></font>
       }<font></font>
<font></font>
       switch (event.type) {<font></font>
           case 'save-notebook':<font></font>
               Jupyter.actions.call('jupyter-notebook:save-notebook');<font></font>
<font></font>
               Break;<font></font>
           ...<font></font>
           default:<font></font>
               break;<font></font>
       }<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
形式に適合しないすべてのイベントは、大胆に無視されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
save-bookbookイベントが到着し、ノートブックを保存するアクションを呼び出します。</font><font style="vertical-align: inherit;">ノートブックが保存されたというメッセージを送り返すだけです。</font></font><br>
<br>
<pre><code class="xml hljs">events.on('notebook_saved.Notebook', actionDispatcher);<font></font>
<font></font>
function actionDispatcher(event) {<font></font>
       switch (event.type) {<font></font>
           case 'select':<font></font>
               const selectedCell = Jupyter.notebook.get_selected_cell();<font></font>
<font></font>
               dispatchEvent({<font></font>
                   type: event.type,<font></font>
                   data: {taskId: getCellTaskId(selectedCell)}<font></font>
               });<font></font>
<font></font>
               return;<font></font>
           case 'notebook_saved':<font></font>
           default:<font></font>
               dispatchEvent({type: event.type});<font></font>
       }<font></font>
   }<font></font>
<font></font>
function dispatchEvent(event) {<font></font>
        return window.parent.postMessage(<font></font>
            typeof event === 'string'<font></font>
                ? event<font></font>
                : JSON.stringify(event),<font></font>
            '*'<font></font>
        );<font></font>
   }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、{type： 'notebook_saved'}を上に送信するだけです。</font><font style="vertical-align: inherit;">これは、ノートブックが保存されていることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントに戻りましょう：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//trainer_type_jupyter.jsx</font></font><br>
<br>
<pre><code class="xml hljs">componentDidMount() {<font></font>
       const {getNotebookLink, lesson} = this.props;<font></font>
<font></font>
       getNotebookLink({id: lesson.id});<font></font>
<font></font>
       window.addEventListener('message', this.handleWindowMessage);<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントをマウントするとき、サーバーにノートブックへのリンクを要求し、私たちに飛ぶことができるすべてのアクションをサブスクライブします。</font></font><br>
<br>
<pre><code class="xml hljs">handleWindowMessage = ({data: eventString}) =&gt; {<font></font>
       const {activeTaskId, history, match: {params}, setNotebookSaved, tasks} = this.props;<font></font>
<font></font>
       let event = null;<font></font>
<font></font>
       try {<font></font>
           event = JSON.parse(eventString);<font></font>
       } catch(e) {<font></font>
           return;<font></font>
       }<font></font>
<font></font>
       const {type, data} = event;<font></font>
<font></font>
       switch (type) {<font></font>
           case 'app_initialized':<font></font>
               this.selectTaskCell({taskId: activeTaskId})<font></font>
<font></font>
               return;<font></font>
           case 'notebook_saved':<font></font>
               setNotebookSaved();<font></font>
<font></font>
               return;<font></font>
           case 'select': {<font></font>
               const taskId = data &amp;&amp; data.taskId;<font></font>
<font></font>
               if (!taskId) {<font></font>
                   return<font></font>
               }<font></font>
              <font></font>
               const task = tasks.find(({id}) =&gt; taskId === id);<font></font>
<font></font>
               if (task &amp;&amp; task.status === TASK_STATUSES.DISABLED) {<font></font>
                   this.selectTaskCell({taskId: null})<font></font>
<font></font>
                   return;<font></font>
               }<font></font>
<font></font>
               history.push(reversePath(urls.trainerTask, {...params, taskId}));<font></font>
<font></font>
               return;<font></font>
           }<font></font>
           default:<font></font>
               break;<font></font>
       }<font></font>
   };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでsetNotebookSavedアクションディスパッチが呼び出され、Redux-Sagaが作業を続行してノートブックを保存できるようになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択したグリッチ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノートブックを保存するバグに対処しました。そしてすぐに新しい問題に切り替えました。生徒がまだ到達していないタスク（タスク）をブロックすることを学ぶ必要がありました。言い換えると、インタラクティブシミュレータとJupyter Notebookの間のナビゲーションを同期する必要がありました。1つのレッスン内に、iframeにいくつかのタスクが置かれた1つのノートブックがあり、その遷移は、レッスンのインターフェース全体の変更と調整する必要がありました。たとえば、ノートブックのレッスンのインターフェイスで2番目のタスクをクリックすると、2番目のタスクに対応するセルに切り替わります。逆もまた同様です。JupyterNotebookフレームで3番目のタスクに関連付けられたセルを選択すると、ブラウザーのアドレスバーのURLがすぐに変化し、それに応じてレッスンのインターフェイスでは、理論を伴う付随するテキストは、3番目のタスクに正確に表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もっと難しい仕事がありました。事実、私たちのトレーニングプログラムは、レッスンと課題の一貫した通過のために設計されています。一方、デフォルトでは、Jupiterノートブックでは、ユーザーがセルを開くことを妨げるものはありません。私たちの場合、各セルは個別のタスクです。最初と3番目のタスクを解決し、2番目のタスクをスキップできることがわかりました。レッスンの非線形の通過のリスクを排除する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションは同じpostMessageに基づいていました。私たちは、Jupyter Notebook API、より具体的には、Jupiterオブジェクト自体が何ができるかをさらに深く調査する必要がありました。そして、セルが接続されているタスクをチェックするメカニズムを考え出します。最も一般的な形では、次のようになります。ノートブックの構造では、セルは次々に順番に表示されます。それらはメタデータを持っているかもしれません。 「タグ」フィールドはメタデータで提供され、タグはレッスン内のタスクの識別子にすぎません。さらに、タグ付けセルを使用して、これまでに学生がセルをブロックする必要があるかどうかを判断できます。結果として、シミュレーターの現在のモデルに従って、セルをクリックすることにより、iframeからフロントエンドにpostMessageの送信を開始します。フロントエンドはフロントエンドに移動し、タスクのプロパティに基づいて、現在使用可能かどうかをチェックします。利用できない場合、前のアクティブセルに切り替えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、トレーニングタイムラインからアクセスできないようにする必要があるノートブックのセルを選択することは不可能です。確かに、これは重大ではないがバグを引き起こしました。アクセスできないタスクのあるセルをクリックしようとすると、すぐに「点滅」します。それが一瞬アクティブになったのは明らかですが、すぐにブロックされました。この荒れは解消していませんが、レッスンの邪魔にはなりませんが、その背景にはどう対処するかを考え続けています（ちなみに、何か考えはありますか？）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を解決するためにフロントエンドをどのように変更したかについて少し。もう一度trainer_type_jupyter.jsxを見てみましょう。app_initializedとselectに焦点を当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
app_initializedを使用すると、すべてが初歩的なものになります。ノートブックが読み込まれ、何かを実行したいと考えています。</font><font style="vertical-align: inherit;">たとえば、選択したタスクに応じて現在のセルを選択します。</font><font style="vertical-align: inherit;">プラグインはtaskIdを渡し、このtaskIdに対応する最初のセルに切り替えることができるように記述されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すなわち：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// trainer_type_jupyter.jsx</font></font><br>
<br>
<pre><code class="xml hljs">selectTaskCell = ({taskId}) =&gt; {<font></font>
       const {selectCell} = this.props;<font></font>
<font></font>
       if (!this.iframeRef) {<font></font>
           return;<font></font>
       }<font></font>
<font></font>
       selectCell({iframe: this.iframeRef, taskId});<font></font>
   };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// trainer.actions.js</font></font><br>
<br>
<pre><code class="xml hljs">export const selectCell = ({iframe, taskId}) =&gt; ({<font></font>
   type: SELECT_CELL,<font></font>
   iframe,<font></font>
   taskId<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// trainer.saga.js</font></font><br>
<br>
<pre><code class="xml hljs">function* selectCell({iframe, taskId}) {<font></font>
   iframe.contentWindow.postMessage(JSON.stringify({<font></font>
       type: 'select-cell',<font></font>
       data: {taskId}<font></font>
   }), '*');<font></font>
<font></font>
   yield;<font></font>
}<font></font>
<font></font>
function* watchSelectCell() {<font></font>
   yield takeEvery(SELECT_CELL, selectCell);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// custom.js（Jupyterプラグイン）</font></font><br>
<br>
<pre><code class="xml hljs">function getCellTaskId(cell) {<font></font>
       const notebook = Jupyter.notebook;<font></font>
<font></font>
       while (cell) {<font></font>
           const tags = cell.metadata.tags;<font></font>
           const taskId = tags &amp;&amp; tags[0];<font></font>
<font></font>
           if (taskId) {<font></font>
               return taskId;<font></font>
           }<font></font>
<font></font>
           cell = notebook.get_prev_cell(cell);<font></font>
       }<font></font>
<font></font>
       return null;<font></font>
   }<font></font>
<font></font>
 function selectCell({taskId}) {<font></font>
       const notebook = Jupyter.notebook;<font></font>
       const selectedCell = notebook.get_selected_cell();<font></font>
<font></font>
       if (!taskId) {<font></font>
           selectedCell.unselect();<font></font>
<font></font>
           return;<font></font>
       }<font></font>
<font></font>
       if (selectedCell &amp;&amp; selectedCell.selected &amp;&amp; getCellTaskId(selectedCell) === taskId) {<font></font>
           return;<font></font>
       }<font></font>
<font></font>
       const index = notebook.get_cells()<font></font>
           .findIndex(cell =&gt; getCellTaskId(cell) === taskId);<font></font>
<font></font>
<font></font>
       if (index <span class="hljs-tag">&lt; <span class="hljs-attr">0</span>) {
           <span class="hljs-attr">return</span>;
       }

       <span class="hljs-attr">notebook.select</span>(<span class="hljs-attr">index</span>);

       <span class="hljs-attr">const</span> <span class="hljs-attr">cell</span> = <span class="hljs-string">notebook.get_cell(index);</span>

       <span class="hljs-attr">cell.element</span>[<span class="hljs-attr">0</span>]<span class="hljs-attr">.scrollIntoView</span>({
           <span class="hljs-attr">behavior:</span> '<span class="hljs-attr">smooth</span>',
           <span class="hljs-attr">block:</span> '<span class="hljs-attr">start</span>'
       });
   }

    
<span class="hljs-attr">function</span> <span class="hljs-attr">actionListener</span>({<span class="hljs-attr">data:</span> <span class="hljs-attr">eventString</span>}) {        
         <span class="hljs-attr">...</span>
            <span class="hljs-attr">case</span> '<span class="hljs-attr">select-cell</span>'<span class="hljs-attr">:</span>
               <span class="hljs-attr">selectCell</span>(<span class="hljs-attr">event.data</span>);

               <span class="hljs-attr">break</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、セルを切り替えて、iframeからセルが切り替えられたことを知ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルを切り替えると、URLが変更され、別のタスクに分類されます。</font><font style="vertical-align: inherit;">逆の操作を行うだけです。インターフェイスで別のタスクを選択した場合は、セルを切り替えます。</font><font style="vertical-align: inherit;">簡単：</font></font><br>
<br>
<pre><code class="xml hljs">componentDidUpdate({match: {params: {prevTaskId}}) {<font></font>
       const {match: {params: {taskId}}} = this.props;<font></font>
<font></font>
       if (taskId !== prevTaskId) {<font></font>
           this.selectTaskCell({taskId});</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完璧主義者のための個別のボイラー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちがどれだけうまくやったかを自慢するだけでもかっこいいでしょう。少し厄介に見えますが、一番下の行のソリューションは効果的です。要約すると、外部（この場合はiframeから）からのメッセージを処理するメソッドがあります。しかし、私たち自身が構築したシステムでは、私や同僚が本当に気に入らないことがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•要素の相互作用に柔軟性はありません。新しい機能を追加する場合は常に、古い通信形式と新しい通信形式の両方をサポートするようにプラグインを変更する必要があります。 iframeとフロントエンドコンポーネント間で動作するための単一の分離メカニズムはありません。これにより、Jupyter Notebookがレッスンインターフェイスにレンダリングされ、タスクで機能します。グローバルに-将来的に新しいアクション、イベントを追加して処理するのが簡単になるように、より柔軟なシステムを作りたいという要望があります。また、Jupiterノートブックだけでなく、シミュレーターのiframeの場合も同様です。したがって、プラグインコードをpostMessageを介して渡し、プラグイン内にレンダリング（評価）しようとしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•問題を解決するコードフラグメントがプロジェクト全体に散在しています。 iframeとの通信はRedux-Sagaとコンポーネントの両方から実行されますが、これは確かに最適ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•Jupyter Notebookレンダリングを備えたiframe自体が別のサービス上にあります。編集は、特に下位互換性の原則に準拠しているため、少し問題があります。たとえば、フロントエンドとノートブック自体のある種のロジックを変更したい場合、二重の作業を行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•多くの人がより簡単に実装したいと考えています。</font><font style="vertical-align: inherit;">少なくとも反応を取る。</font><font style="vertical-align: inherit;">彼には多くのライフサイクルメソッドがあり、それぞれを処理する必要があります。</font><font style="vertical-align: inherit;">さらに、React自体へのバインドに混乱しています。</font><font style="vertical-align: inherit;">理想的には、フロントエンドフレームワークが何であれ、iframeを操作できるようにしたいと考えています。</font><font style="vertical-align: inherit;">一般に、私たちが選択したテクノロジーの共通部分は制限を課します。同じRedux-Sagaは、postMessageではなくReduxアクションを私たちに期待します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから私たちは間違いなく達成されたものに止まりません。</font><font style="vertical-align: inherit;">教科書のジレンマ：美しさの側に行くことができますが、パフォーマンスの最適性を犠牲にするか、またはその逆です。</font><font style="vertical-align: inherit;">最適な解決策はまだ見つかっていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たぶん、アイデアが思い浮かびますか？</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja453866/index.html">React Hooks、HOC、またはRender Propを使用したAPIリクエスト</a></li>
<li><a href="../ja453868/index.html">nRF52832のガラスパネル付きタッチミニスイッチ</a></li>
<li><a href="../ja453870/index.html">PowerShellでReverse socks5プロキシを記述します（パート1）</a></li>
<li><a href="../ja453872/index.html">ニューラルネットワークを使用した写真の復元</a></li>
<li><a href="../ja453874/index.html">ロシアンルーレットから安全なLOTOへ：データセンターの担当者を保護する方法</a></li>
<li><a href="../ja453882/index.html">ソリューションアーキテクトの職業に関する優れたガイド（+役立つリンクのリスト）</a></li>
<li><a href="../ja453884/index.html">誇大広告または再フラッシュカメラ？</a></li>
<li><a href="../ja453886/index.html">プログラム作品</a></li>
<li><a href="../ja453888/index.html">最高速の機械学習：4か月の予測メンテナンス</a></li>
<li><a href="../ja453890/index.html">ソビエトの未来の夢</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>