<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💌 💆 🏠 Membuat roguelike di Unity dari awal: generator penjara bawah tanah 🍲 🕗 👹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kali ini kita akan terjun ke dalam penerapan algoritma generator penjara bawah tanah. Di artikel terakhir, kami menciptakan ruang pertama, dan sekaran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Membuat roguelike di Unity dari awal: generator penjara bawah tanah</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kali ini kita akan terjun ke dalam penerapan algoritma generator penjara bawah tanah. Di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel terakhir,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami menciptakan ruang pertama, dan sekarang kami akan menghasilkan sisa tingkat bawah tanah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sebelum kita mulai, saya ingin memperbaiki kesalahan dari posting sebelumnya. Bahkan, dalam beberapa minggu terakhir saya telah belajar sesuatu yang baru, itulah sebabnya beberapa pekerjaan yang saya lakukan sudah ketinggalan zaman, dan saya ingin membicarakannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingat kelas Posisi yang kita buat? Faktanya, Unity sudah memiliki kelas bawaan yang melakukan fungsi yang persis sama, tetapi dengan kontrol yang sedikit lebih baik - lebih mudah untuk mendeklarasikan dan memproses. Kelas ini disebut Vector2Int. Oleh karena itu, sebelum memulai, kami akan menghapus kelas Posisi dari MapManager.cs dan mengganti setiap variabel Posisi dengan variabel Vector2Int.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal yang sama perlu dilakukan di beberapa tempat di skrip DungeonGenerator.cs. </font><font style="vertical-align: inherit;">Sekarang mari kita lanjutkan ke sisa algoritma.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 7 - generasi kamar / aula</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan mulai dengan perubahan kecil ke fungsi FirstRoom () dibuat terakhir kali. </font><font style="vertical-align: inherit;">Alih-alih membuat fungsi lain untuk menghasilkan semua elemen lain dari peta dan menduplikasi banyak kode, kami hanya mengubah fungsi ini, mengubahnya menjadi GenerateFeature umum (). </font><font style="vertical-align: inherit;">Oleh karena itu, ubah nama dari FirstRoom ke GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita perlu memberikan parameter ke fungsi ini. </font><font style="vertical-align: inherit;">Pertama-tama, Anda perlu tahu fungsi apa yang dihasilkannya - ruangan atau koridor. </font><font style="vertical-align: inherit;">Kami hanya bisa meneruskan string yang disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selanjutnya, fungsi perlu mengetahui titik awal elemen, yaitu darimana dinding itu berasal (karena kita selalu membuat elemen baru dari dinding elemen yang lebih lama), dan untuk ini, lewat karena argumen Dinding sudah cukup. </font><font style="vertical-align: inherit;">Akhirnya, ruang pertama yang akan dibuat memiliki karakteristik khusus, jadi kita memerlukan variabel bool opsional yang memberi tahu apakah item tersebut adalah ruang pertama. </font><font style="vertical-align: inherit;">Secara default, itu salah: bool isFirst = false. </font><font style="vertical-align: inherit;">Jadi judul fungsi akan berubah dari ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hal ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik. </font><font style="vertical-align: inherit;">Langkah selanjutnya adalah mengubah cara Anda menghitung lebar dan tinggi elemen. </font><font style="vertical-align: inherit;">Sementara kami menghitungnya, mendapatkan nilai acak antara nilai minimum dan tinggi dari tinggi dan lebar kamar - ini ideal untuk kamar, tetapi tidak akan berfungsi untuk koridor. </font><font style="vertical-align: inherit;">Sejauh ini, kami memiliki yang berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi koridor akan memiliki ukuran konstan 3 lebar atau tinggi, tergantung pada orientasinya. </font><font style="vertical-align: inherit;">Karena itu, kita perlu memeriksa apa elemennya - ruangan atau koridor, dan kemudian melakukan perhitungan yang sesuai.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begitu. </font><font style="vertical-align: inherit;">kami memeriksa apakah barang itu sebuah ruangan. </font><font style="vertical-align: inherit;">Jika ya, maka kita melakukan hal yang sama seperti sebelumnya </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - kita mendapatkan angka acak dalam interval antara min dan max tinggi dan lebar. </font><font style="vertical-align: inherit;">Tetapi sekarang di tempat </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang sama jika Anda perlu melakukan sesuatu yang sedikit berbeda. </font><font style="vertical-align: inherit;">Kita perlu memeriksa orientasi koridor. </font><font style="vertical-align: inherit;">Untungnya, ketika membuat dinding, kami menyimpan informasi tentang arah mana yang diarahkan, jadi kami menggunakannya untuk mendapatkan orientasi koridor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi kami belum mendeklarasikan minCorridorLength variabel. </font><font style="vertical-align: inherit;">Anda harus kembali ke deklarasi variabel dan mendeklarasikannya, tepat di atas maxCorridorLength.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kembali ke pernyataan peralihan bersyarat kami. </font><font style="vertical-align: inherit;">Apa yang kita lakukan di sini: kita mendapatkan nilai dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arah</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dinding, yaitu, di mana dinding itu memandang, dari mana koridor akan pergi. </font><font style="vertical-align: inherit;">Arah hanya dapat memiliki empat nilai yang mungkin: Selatan, Utara, Barat dan Timur. </font><font style="vertical-align: inherit;">Dalam kasus Selatan dan Utara, koridor akan memiliki lebar 3 (dua dinding dan lantai di tengah) dan tinggi variabel (panjang). </font><font style="vertical-align: inherit;">Untuk Barat dan Timur, semuanya akan sebaliknya: tingginya akan sama dengan 3, dan lebarnya akan memiliki panjang variabel. </font><font style="vertical-align: inherit;">Jadi mari kita lakukan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow. </font><font style="vertical-align: inherit;">Dan di situlah kami berakhir dengan mengukur item baru. </font><font style="vertical-align: inherit;">Sekarang Anda harus memutuskan di mana harus meletakkannya. </font><font style="vertical-align: inherit;">Kami menempatkan ruangan pertama di tempat acak di dalam nilai ambang relatif terhadap pusat peta.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi untuk semua elemen lain, ini tidak akan berhasil. Mereka harus mulai di sebelah titik acak di dinding dari mana elemen dihasilkan. Jadi mari kita ubah kodenya. Pertama, kita perlu memeriksa apakah elemennya adalah ruang pertama. Jika ini adalah ruang pertama, maka kita mendefinisikan titik awal dengan cara yang sama seperti sebelumnya - setengah dari lebar dan tinggi peta.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di tempat </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika elemen tersebut bukan ruangan pertama, maka kita mendapatkan titik acak di dinding dari mana elemen tersebut dihasilkan. Pertama, kita perlu memeriksa apakah dinding memiliki ukuran 3 (ini berarti bahwa itu adalah titik akhir koridor), dan jika demikian, maka titik tengah akan selalu dipilih, yaitu, indeks 1 dari susunan dinding (dengan 3 elemen, array memiliki indeks 0, 1, 2). Tetapi jika ukurannya tidak sama dengan 3 (dinding bukanlah titik akhir koridor), maka kita mengambil titik acak antara titik 1 dan panjang dinding minus 2. Ini diperlukan untuk menghindari lorong yang dibuat di sudut. Misalnya, pada dinding dengan panjang 6, kami mengecualikan indeks 0 dan 5 (pertama dan terakhir), dan memilih titik acak di antara titik 1, 2, 3 dan 4.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita memiliki posisi titik di dinding di mana elemen baru akan dibuat. Tapi kita tidak bisa mulai membuat elemen dari sana, karena cara ini akan terhalang oleh dinding yang sudah ditempatkan. Penting juga untuk dicatat bahwa elemen mulai dihasilkan dari sudut kiri bawahnya, dan kemudian kenaikan dilakukan ke kanan dan atas, jadi kita harus mengatur posisi awal di tempat yang berbeda, tergantung pada arah di mana dinding terlihat. Selain itu, kolom pertama x dan baris pertama y akan menjadi dinding, dan jika kita memulai elemen baru tepat di sebelah titik di dinding, kita dapat membuat koridor yang berakhir di sudut ruangan, dan bukan di tempat yang cocok di dinding.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, jika dinding diarahkan ke utara, maka elemen tersebut perlu dimulai pada satu posisi utara pada sumbu y, tetapi dalam jumlah acak posisi barat pada sumbu x, dalam kisaran dari 1 hingga lebar ruangan-2. </font><font style="vertical-align: inherit;">Di arah selatan, sumbu x bertindak sama, tetapi posisi awal pada sumbu y adalah posisi titik di dinding dikurangi ketinggian ruangan. </font><font style="vertical-align: inherit;">Dinding barat dan timur mengikuti logika yang sama, hanya dengan sumbu terbalik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sebelum melakukan semua ini, kita perlu menyimpan posisi titik dinding dalam variabel Vector2Int sehingga kita dapat memanipulasinya nanti.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagus. </font><font style="vertical-align: inherit;">Ayo lakukan itu.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami membuat elemen dengan ukuran dan posisi, dan langkah selanjutnya adalah menempatkan elemen di peta. </font><font style="vertical-align: inherit;">Tapi pertama-tama, kita perlu mencari tahu apakah memang ada ruang di peta untuk elemen ini di posisi ini. </font><font style="vertical-align: inherit;">Untuk saat ini, kami hanya memanggil fungsi CheckIfHasSpace (). </font><font style="vertical-align: inherit;">Ini akan disorot dengan warna merah, karena kami belum mengimplementasikannya. </font><font style="vertical-align: inherit;">Kami akan melakukan ini dengan benar setelah kami menyelesaikan apa yang perlu dilakukan di sini di fungsi GenerateFeature (). </font><font style="vertical-align: inherit;">Oleh karena itu, abaikan garis bawah merah dan lanjutkan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian selanjutnya, dinding dibuat. </font><font style="vertical-align: inherit;">Sampai kita menyentuhnya, dengan pengecualian fragmen di kedua </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loop </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menulis posting ini, saya perhatikan bahwa konstruksi if-else ini benar-benar salah. Misalnya, beberapa dinding di dalamnya akan menerima panjang 1. Ini terjadi karena ketika posisi akan ditambahkan, katakanlah, ke dinding utara, maka jika berada di sudut dengan dinding timur, itu tidak akan ditambahkan ke dinding timur, sebagaimana mestinya. Ini menyebabkan bug yang mengganggu dalam algoritma pembuatan. Mari kita hilangkan mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memperbaikinya cukup sederhana. Cukup menghapus semua yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga posisi melewati semua konstruksi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan tidak berhenti pada awalnya jika itu mengembalikan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kemudian yang terakhir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (salah satu yang tidak </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain jika</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) berubah menjadi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang memeriksa bahwa posisi telah ditambahkan sebagai Wall, dan jika tidak, tambahkan sebagai Floor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luar biasa, kita hampir selesai di sini. </font><font style="vertical-align: inherit;">Sekarang kita memiliki elemen yang sama sekali baru, dibuat di tempat yang tepat, tetapi itu sama dengan ruangan pertama kita: itu benar-benar tertutup oleh dinding. </font><font style="vertical-align: inherit;">Ini berarti bahwa pemain tidak akan dapat mencapai tempat baru ini. </font><font style="vertical-align: inherit;">Artinya, kita perlu mengkonversi titik di dinding (yang, seingat kita, disimpan dalam variabel tipe Vector2Int) dan titik yang sesuai di dinding elemen baru di Lantai. </font><font style="vertical-align: inherit;">Tapi hanya saat elemennya bukan ruangan pertama.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Potongan kode ini memeriksa apakah item baru adalah ruang pertama. </font><font style="vertical-align: inherit;">Jika tidak, itu mengubah posisi terakhir dinding ke lantai, dan kemudian memeriksa arah dinding mencari untuk memeriksa ubin elemen mana yang harus berubah menjadi lantai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami telah mencapai bagian terakhir dari fungsi GenerateFeature (). </font><font style="vertical-align: inherit;">Itu sudah memiliki garis yang menambahkan informasi tentang elemen yang membuat fungsi.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita perlu mengubah sesuatu. </font><font style="vertical-align: inherit;">Pertama, tipe elemen tidak selalu sama dengan Kamar. </font><font style="vertical-align: inherit;">Untungnya, variabel yang diperlukan diteruskan ke fungsi sebagai parameter, yaitu tipe string. </font><font style="vertical-align: inherit;">Jadi mari kita ganti "Kamar" di sini dengan tipe.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik. </font><font style="vertical-align: inherit;">Sekarang, agar algoritme menghasilkan semua elemen permainan agar berfungsi dengan benar, kita perlu menambahkan data baru di sini. </font><font style="vertical-align: inherit;">Yaitu, int yang menghitung jumlah item yang dibuat dan daftar semua item yang dibuat. </font><font style="vertical-align: inherit;">Kami pergi ke tempat di mana kami mendeklarasikan semua variabel dan mendeklarasikan int dengan nama countFeatures, serta Daftar elemen dengan nama allFeatures. </font><font style="vertical-align: inherit;">Daftar semua elemen harus publik, dan penghitung int bisa bersifat pribadi.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kembali ke fungsi GenerateFeature () dan tambahkan beberapa baris ke akhir: menambah variabel countFeatures dan menambahkan elemen baru ke daftar allFeatures.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, GenerateFeature () kami hampir selesai. </font><font style="vertical-align: inherit;">Nanti kita harus kembali ke sana untuk mengisi fungsi CheckIfHasSpace yang kosong, tetapi pertama-tama kita harus membuatnya. </font><font style="vertical-align: inherit;">Itu yang akan kita lakukan sekarang.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 8 - periksa apakah ada tempat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita membuat fungsi baru tepat setelah fungsi GenerateFeature () selesai. Dia membutuhkan dua argumen: posisi di mana elemen dimulai, dan posisi di mana elemen itu berakhir. Anda dapat menggunakan dua variabel Vector2Int sebagai mereka. Fungsi harus mengembalikan nilai bool sehingga dapat digunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memeriksa ruang.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu digarisbawahi dalam warna merah, karena sejauh ini belum mengembalikan apa pun. Kami akan segera memperbaikinya, tetapi untuk saat ini kami tidak akan memperhatikannya. Dalam fungsi ini, kita akan mengulang semua posisi antara awal dan akhir elemen, dan memeriksa apakah posisi saat ini di MapManager.map adalah nol atau sesuatu sudah ada di sana. Jika ada sesuatu di sana, maka kita menghentikan fungsinya dan mengembalikan false. Jika tidak, maka lanjutkan. Jika fungsi mencapai akhir loop tanpa memenuhi tempat yang diisi, maka kembalikan true. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, sebelum memeriksa posisi untuk null, kita perlu garis untuk memeriksa apakah posisi itu di dalam peta. Karena jika tidak, kita mungkin mendapatkan kesalahan indeks array dan crash game.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik. </font><font style="vertical-align: inherit;">Sekarang kembali ke tempat kita memasukkan fungsi ini di dalam fungsi GenerateFeature (). </font><font style="vertical-align: inherit;">Kami perlu memperbaiki panggilan ini karena tidak melewati argumen yang diperlukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita ingin menyisipkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pernyataan if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memeriksa apakah ada cukup ruang untuk elemen. </font><font style="vertical-align: inherit;">Jika hasilnya salah, maka kita mengakhiri fungsi tanpa memasukkan elemen baru ke MapManager.map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita perlu memberikan argumen yang diperlukan, yaitu dua variabel Vector2Int. </font><font style="vertical-align: inherit;">Dengan yang pertama, semuanya sederhana, ini adalah posisi dengan koordinat x dan y dari titik awal elemen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang kedua lebih sulit, tetapi tidak banyak. </font><font style="vertical-align: inherit;">Ini adalah titik awal plus tinggi untuk y dan lebar untuk x, mengurangi 1 dari keduanya (karena awal sudah diperhitungkan).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita beralih ke langkah berikutnya - membuat algoritma untuk memanggil fungsi GenerateFeature ().</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 9 - panggilan elemen yang dihasilkan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali ke fungsi GenerateDungeon () yang dibuat di bagian artikel sebelumnya. </font><font style="vertical-align: inherit;">Sekarang akan terlihat seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panggilan ke FirstRoom () digarisbawahi dengan warna merah karena kami mengubah nama fungsi ini. </font><font style="vertical-align: inherit;">Jadi mari kita panggil generasi kamar pertama.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melewati argumen yang diperlukan: "Kamar" sebagai tipe, karena ruangan pertama akan selalu menjadi Kamar, Dinding baru (), karena ruangan pertama tidak akan dibuat dari yang lain, jadi kami hanya melewati nol, dan ini cukup normal. Alih-alih Wall baru (), Anda dapat mengganti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ini adalah masalah preferensi pribadi. Argumen terakhir menentukan apakah elemen baru adalah ruang pertama, jadi dalam kasus kami, kami </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita sampai pada poin utama. Kami menggunakan loop for yang akan berjalan 500 kali - ya, kami akan mencoba menambahkan elemen 500 kali. Tetapi jika jumlah elemen yang dibuat (variabel countFeatures) sama dengan jumlah maksimum elemen yang ditentukan (variabel maxFeatures), maka kami menghentikan siklus ini.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah pertama dalam loop ini adalah mendeklarasikan elemen dari mana elemen baru akan dibuat. </font><font style="vertical-align: inherit;">Jika kita hanya membuat satu elemen (ruang pertama), maka itu akan menjadi yang asli. </font><font style="vertical-align: inherit;">Jika tidak, kami secara acak memilih salah satu elemen yang sudah dibuat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akan memilih dinding elemen mana yang akan digunakan untuk membuat elemen baru.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap perhatikan bahwa kami belum memiliki fungsi ChoseWall () ini. </font><font style="vertical-align: inherit;">Mari kita menulisnya dengan cepat. </font><font style="vertical-align: inherit;">Turun ke akhir fungsi dan buat itu. </font><font style="vertical-align: inherit;">Ini harus mengembalikan dinding, dan menggunakan elemen sebagai argumen, sehingga fungsinya dapat memilih dinding elemen ini.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuatnya antara fungsi CheckIfHasSpace () dan DrawMap (). </font><font style="vertical-align: inherit;">Perhatikan bahwa jika Anda bekerja di Visual Studio, yang diinstal dengan Unity, Anda dapat menggunakan bidang - / + di sebelah kiri untuk menutup / memperluas bagian kode untuk menyederhanakan pekerjaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam fungsi ini kita akan menemukan dinding dari mana elemen belum dibuat. </font><font style="vertical-align: inherit;">Kadang-kadang kita akan mendapatkan elemen dengan satu atau lebih dinding yang elemen lainnya sudah terpasang, jadi kita perlu memeriksa lagi dan lagi apakah ada dinding acak yang bebas. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami menggunakan loop for diulang sepuluh kali - jika setelah sepuluh kali ini dinding bebas tidak ditemukan, maka fungsi mengembalikan nol.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kembali ke fungsi GenerateDungeon () dan meneruskan elemen asli sebagai parameter ke fungsi ChoseWall ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Garis </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti bahwa jika fungsi pencarian dinding mengembalikan false, maka elemen asli tidak dapat menghasilkan elemen baru, oleh karena itu fungsi akan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melanjutkan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siklus, yaitu, ia tidak dapat membuat elemen baru dan melanjutkan ke iterasi siklus berikutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita perlu memilih jenis untuk item selanjutnya. </font><font style="vertical-align: inherit;">Jika elemen sumbernya adalah sebuah ruangan, maka yang berikutnya haruslah koridor (kita tidak ingin ruangan mengarah langsung ke ruangan lain tanpa koridor di antara mereka). </font><font style="vertical-align: inherit;">Tetapi jika ini adalah koridor, maka kita perlu membuat kemungkinan bahwa koridor atau ruangan lain akan menjadi yang berikutnya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik. </font><font style="vertical-align: inherit;">Sekarang kita hanya perlu memanggil fungsi GenerateFeature (), melewatinya dinding dan ketik sebagai parameter.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terakhir, buka inspektur Persatuan, pilih objek GameManager dan ubah nilainya sebagai berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika sekarang Anda mengklik tombol putar, maka Anda sudah akan melihat hasilnya!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya katakan, ini bukan penjara bawah tanah terbaik. </font><font style="vertical-align: inherit;">Kami punya banyak jalan buntu. </font><font style="vertical-align: inherit;">Tapi itu berfungsi penuh, dan itu menjamin bahwa Anda tidak akan memiliki ruangan yang tidak terhubung ke yang lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harap Anda menikmatinya! </font><font style="vertical-align: inherit;">Di posting berikutnya, kita akan membuat pemain yang akan bergerak melalui ruang bawah tanah, dan kemudian kita akan mengubah peta dari ASCII menjadi sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id495554/index.html">Program untuk mencari VKontakte yang berpikiran sama [Sumber terbuka]</a></li>
<li><a href="../id495556/index.html">Fortinet - pilihan bahan yang berguna</a></li>
<li><a href="../id495560/index.html">Tren Internet of Things: AI Menjawab Panggilan, Awan, dan 5G Data Besar yang Jinak, Perumahan, dan Utilitas - Pemimpin dalam Inovasi</a></li>
<li><a href="../id495576/index.html">Platform self-propelled pada esp8266 MK dengan micropython</a></li>
<li><a href="../id495580/index.html">Mentimun JVM - Bukan Hanya BDD</a></li>
<li><a href="../id495592/index.html">Cara menggunakan kamus (dan tidak hanya)</a></li>
<li><a href="../id495594/index.html">Mulailah menghasilkan uang dari perangkat lunak: menciptakan bisnis mini-digital</a></li>
<li><a href="../id495596/index.html">Pekerjaan jauh di kantor. RDP, Port Knocking, Mikrotik: sederhana dan aman</a></li>
<li><a href="../id495602/index.html">Dimulai dengan Data Inti! Sulit dalam kata-kata sederhana [Bagian 2]</a></li>
<li><a href="../id495604/index.html">Lokalisasi sementara pada Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>