<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛈️ 👳🏿 🍴 Funktionszeitgeber für Simatic S7-1200 Industriesteuerung 🌷 🗺️ 👉🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selbst für die Serien S7-300 und S7-400 waren unter Schritt 7 die klassischen Versionen der dem Entwickler angebotenen Timer völlig ausreichend - dies...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Funktionszeitgeber für Simatic S7-1200 Industriesteuerung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491200/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst für die Serien S7-300 und S7-400 waren unter Schritt 7 die klassischen Versionen der dem Entwickler angebotenen Timer völlig ausreichend - dies sind Standard-IEC-Timer, die als Funktionsblöcke implementiert sind, und S5-Timer (die übrigens für die S7-Serie noch existieren) 1500). In einigen Fällen verwendete der Entwickler jedoch keine Standardtools und implementierte seine eigenen Timer, meist in Form von Funktionen. Solche Timer-Funktionen waren bei einem „IT“ -Ansatz für die Programmierung erforderlich, bei dem sie nicht mit getrennten Instanzen der Funktionsblöcke technologischer Geräte, mit der entsprechenden Bindung von Ein- und Ausgängen, sondern mit Arrays von Strukturen arbeiteten. Zum Beispiel ein Array einer diskreten Eingabetypstruktur. Oder ein Array einer Aggregatstruktur. Dieser Ansatz zur Programmierung hat ein Existenzrecht, da Sie damit den Arbeitsspeicher der CPU ernsthaft sparen können, aberAuf der anderen Seite ist der Programmcode schwer zu lesen. Ein Programmierer von Drittanbietern und mit einem einfachen Blick auf ein LAD-Programm kann es kaum sofort herausfinden, aber jede Menge Indizes, Arrays und Funktionen zu ihrer Verarbeitung kommen nicht in Frage - hier ohne Dokumentation für die Software (und natürlich ohne einen halben Liter) nirgendwo.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Arrays von Strukturen wurden typischerweise in Funktionen verarbeitet. Im Prinzip hat nichts die Verarbeitung von Funktionsblöcken verhindert, aber es gab immer eine wichtige Frage - wie man in diesen Fällen mit Timern arbeitet? Standard-Timer nehmen entweder eine Nummer (S5) oder eine Instanz eines Funktionsblocks (IEC) an. Ich erinnere Sie daran, dass es darum geht, Arrays von Strukturen für klassische Simatic-SPS zu verarbeiten und Timer-Nummern in diese Strukturen zu „verdrehen“, und noch mehr, Instanzen sind entweder schwierig oder einfach unmöglich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund haben wir als Funktion unsere eigene Timer-Funktionalität erstellt. Grundsätzlich müssen Sie für den Betrieb eines Timers nur wenige Dinge wissen - den Status der Eingabe, die Zeiteinstellung und wie viel Zeit seit der Aktivierung vergangen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Serien 300 und 400 gab es zwei Möglichkeiten, diese Zeit zu bestimmen. </font><font style="vertical-align: inherit;">Die erste besteht darin, die Laufzeit des Haupt-OB1 (es gibt eine entsprechende Variable in OB1 selbst) oder der zyklischen OBs zu betrachten und den internen Zeitakkumulator bei jedem Timer-Aufruf zu erhöhen, vorausgesetzt, die „Wahrheit“ wird eingegeben. </font><font style="vertical-align: inherit;">Keine gute Option, da diese Zeit für OB1 und zyklische OBs unterschiedlich ist. </font><font style="vertical-align: inherit;">Die zweite Methode ist die Systemfunktion TIME_TCK, die bei jedem Aufruf einen einzelnen Wert zurückgibt - den internen Millisekundenzähler des Zentralprozessors. </font></font><br>
<br>
<img src="https://sun9-40.userapi.com/c855036/v855036198/1f8065/UwCQvxh507k.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit war für einen Zeitgeber vom TON-Typ (bei Verzögerung) der Operationsalgorithmus wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie bei steigender Flanke der Antwortanforderung den Ausgang zurück und merken Sie sich den aktuellen Wert des System-Timers TIME_TCK</font></font></li>
<li>       «»          ,        (   ,  TIME_TCK    0  (2 ^ 31 — 1),          ).   ,        .    ,    «»,    — «»</li>
<li>      «»,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Aufkommen der "tausendsten" Serie hat sich die Situation ein wenig geändert. Tatsache ist, dass die S7-1500-Leitung die Unterstützung für den Systemaufruf TIME_TCK und Liebhaber des Ansatzes „Stehen und in einer Hängematte“ geerbt hat (wie kann man sonst ein Programm aufrufen, das nur Arrays von Strukturen verarbeitet, während es mit gruseligen Indizes arbeitet?) Verwenden Sie ruhig weiterhin ihre Best Practices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Basissteuerungen der S7-1200-Serie basieren auf einer anderen Architektur und weisen eine Reihe von Unterschieden zur S7-1500 auf. Einschließlich des Fehlens eines TIME_TCK-Systemaufrufs. In den Reihen der Entwickler, die nicht genügend Flexibilität beim Denken haben, ist die Unzufriedenheit verschwunden - es ist unmöglich, Kopien / Pasten alter Programme auszuführen. Die Aufgabe, zu bestimmen, wie viel Zeit seit dem vorherigen Aufruf vergangen ist, kann jedoch mithilfe der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Laufzeitfunktion ausgeführt</font></a><font style="vertical-align: inherit;"> werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion gibt die seit ihrem vorherigen Aufruf verstrichene Zeit in Sekunden als reelle Zahl LREAL mit doppelter Genauigkeit zurück. Details sind in der Hilfe beschrieben. Für interne Zwecke ist eine zusätzliche MEM-Variable (ebenfalls vom Typ LREAL) erforderlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde die Quellen der ersten Annäherung der Funktion angeben und einige Anmerkungen machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionsdeklaration:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_OUTPUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Ein- / Ausgängen ist alles klar: IN, Q und PT. Ich stelle die Zeiteinstellung in Form einer echten ein, es sind Sekunden. Ich wollte nur (aber vergebens, aber mehr dazu weiter unten). Weitere Informationen zu Variablen des InOut-Bereichs. Da wir eine Funktion haben, haben wir keinen STAT-Bereich, es gibt keine Variablen, die ihren Wert beim nächsten Funktionsaufruf beibehalten, und solche Variablen werden benötigt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPrv - um die positive Flanke der Anforderung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEM </font><font style="vertical-align: inherit;">zu bestimmen </font><font style="vertical-align: inherit;">- Hilfsvariable für den Systemaufruf zur Laufzeit </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RuntimeACC - Zeitakkumulator , die die Anzahl der Mikrosekunden der aktuell laufenden Verzögerung speichert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variablen TimeACC, udiCycle und udiPT werden im UDINT-Format angegeben, einer vorzeichenlosen Ganzzahl mit 4 Bytes. </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass ich die Zeit als real angegeben habe und die Laufzeitfunktion real bis zur doppelten Genauigkeit zurückgibt, bevorzuge ich einfache Operationen zum Summieren und Vergleichen mit ganzzahligen Operanden, um Prozessorzeit zu sparen. </font><font style="vertical-align: inherit;">Die Zeit in meinem Fall wird in Mikrosekunden berücksichtigt. </font><font style="vertical-align: inherit;">Der Grund ist einfach: Wenn Sie die Zeit auf Millisekunden vergröbern, ist bei fast leerem OB1 (z. B. wenn nur ein Timer im gesamten Steuerungsprogramm aufgerufen wird und nichts weiter) ein „Überspringen“ von Zyklen möglich, das Programm läuft manchmal für 250 μs. </font><font style="vertical-align: inherit;">In diesem Fall beträgt der maximal zulässige Wert des Zeitakkumulators 4.294 Sekunden, fast 4.295 (2 ^ 32 - 1 = 4.294.967.295). </font><font style="vertical-align: inherit;">Es gibt nichts zu tun, eine solche „Optimierung“ erfordert Opfer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionstext.</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
    #Q := FALSE;<font></font>
ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
    #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
    <span class="hljs-keyword">IF</span> #TimeACC &gt;=  #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
        #Q := TRUE; <span class="hljs-comment">//  ""</span>
        #TimeACC := #udiPT; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//      </span>
        #Q := FALSE; <span class="hljs-comment">// </span><font></font>
    END_IF;<font></font>
<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
    #Q := FALSE;<font></font>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
END_IF;<font></font>
<font></font>
#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
<font></font>
ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten beiden Zeilen sind die Neuberechnung der Timer-Einstellung von der im REAL-Format angegebenen Anzahl von Sekunden auf die Anzahl von Mikrosekunden. </font><font style="vertical-align: inherit;">Die Zeit in Mikrosekunden, die seit dem vorherigen Programmblockaufruf vergangen ist, wird ebenfalls bestimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner ist der Algorithmus wie folgt und ich habe ihn bereits gegeben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie bei steigender Flanke des Eingangs IN den Ausgang Q zurück und setzen Sie den Zeitspeicher zurück</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die „Wahrheit“ weiterhin eingegeben wird, erhöhen wir den Zeitakkumulator um den bereits bekannten udiCycle-Wert und vergleichen ihn mit der Zeiteinstellung. </font><font style="vertical-align: inherit;">Wenn die Zeiteinstellung überschritten wird, hat der Timer funktioniert, geben Sie die Ausgabe "wahr", andernfalls geben Sie die Ausgabe "falsch".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen falschen Eingang an den IN-Eingang anlegen, setzen Sie den Q-Ausgang zurück und setzen Sie den Zeitspeicher zurück.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich am Ende der Funktion an den vorherigen Wert, um die Flanke des Eingangs IN zu bestimmen. </font><font style="vertical-align: inherit;">Geben Sie der Ausgabe ENO (bei Verwendung einer Funktion in grafischen Sprachen wie LAD) auch den Wert der Ausgabe Q an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir stellen sicher, dass die Funktion funktioniert. Danach wird es interessant, ihre Geschwindigkeit zu bewerten und gegebenenfalls zu verbessern (es scheint bereits auf den ersten Blick, dass eine Reihe von Berechnungen durchgeführt werden) Leerlauf und vergebliche Verschwendung von CPU-Zeit). </font><font style="vertical-align: inherit;">Um die Leistung zu bewerten, deklariere ich ein Array von 1000 Timer-Datenstrukturen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erklärung der Struktur. </font><font style="vertical-align: inherit;">Seine Felder duplizieren die Eingabe- und Ausgabevariablen der Timerfunktion.</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">TYPE</span> "typePervTONdata"<font></font>
VERSION : <span class="hljs-number">0.1</span><font></font>
   STRUCT<font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//   </span>
      Q : Bool;   <span class="hljs-comment">//  </span>
      INPrv : Bool;   <span class="hljs-comment">//    </span>
      MEM : LReal;   <span class="hljs-comment">//    </span>
      TimeACC : UDInt;   <span class="hljs-comment">//  </span><font></font>
   END_STRUCT;<font></font>
<font></font>
END_TYPE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im globalen Datenblock TortureTON wird ein Array von Strukturen deklariert:</font></font><br>
<br>
<pre><code class="delphi hljs">TONs : <span class="hljs-keyword">Array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">999</span>] <span class="hljs-keyword">of</span> "typePervTONdata";
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der folgende Code wird im Organisationsblock OB1 ausgeführt:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">FOR</span> #i := <span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">999</span> <span class="hljs-keyword">DO</span>
    "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span> := "startton";<font></font>
    "PerversionTON"(<span class="hljs-keyword">IN</span> := "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span>,<font></font>
                    PT := "TortureTON".TONs[#i].PT,<font></font>
                    Q := "TortureTON".TONs[#i].Q,<font></font>
                    INPrv := "TortureTON".TONs[#i].INPrv,<font></font>
                    MEM := "TortureTON".TONs[#i].MEM,<font></font>
                    TimeACC := "TortureTON".TONs[#i].TimeACC);<font></font>
END_FOR;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ankündigung von 1000 "Instanzen" von Timern, die jeweils eine Zeit von 10 Sekunden einstellen. Alle 1000 Timer beginnen, die Zeit nach dem Wert der Startton-Markierungsvariablen zu zählen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich starte die Diagnosefunktionen der Steuerung (S7-1214C DC / DC / DC, Version FW 4.4, Version Step7 - V16) und beobachte die Scan-Zykluszeit der Steuerung. Bei "Leerlauf" (wenn "Falsch" am Eingang der Timer eintrifft) werden die gesamten Tausend durchschnittlich 36-42 Millisekunden lang verarbeitet. Während des Countdowns von zehn Sekunden wächst dieser Messwert um etwa 6-8 Millisekunden und rollt manchmal für 50 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schauen uns an, was im Funktionscode verbessert werden kann. Erstens die Zeilen ganz am Anfang des Programmblocks:</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden immer aufgerufen, unabhängig davon, ob der Timer die Zeit zählt, nicht zählt oder bereits gezählt hat. Eine große Geldverschwendung besteht darin, die nicht sehr leistungsstarke CPU der 1200er-Serie mit Berechnungen zu beladen, bei denen Materialien mit doppelter Genauigkeit verwendet werden. Es ist sinnvoll, beide Zeilen auf den Teil des Codes zu übertragen, der den Countdown verarbeitet (wenn die „Wahrheit“ weiterhin eingeht). Es ist auch erforderlich, die udiCycle-Berechnung in einen Code zu duplizieren, der eine positive Flanke am Eingang des Timers verarbeitet. Dies sollte den "Leerlaufbetrieb" des Timers entlasten, wenn der Eingabewert falsch ist. In der Praxis arbeiten Timer in speicherprogrammierbaren Steuerungen meistens im Leerlauf. Beispielsweise beträgt die Filterzeit des Kontaktsprungs einige zehn Millisekunden. Der Steuerimpuls eines diskreten Ausgangs beträgt einige hundert Millisekunden, normalerweise 0,5 bis 1,0 Sekunden.Die Zeit für die Überwachung der Ausführung des Einheitenbefehls (z. B. die Zeit, in der das Ventil vollständig geöffnet wird) beträgt einige zehn Sekunden bis einige Minuten. SPS in der Produktion arbeitet 24 Stunden am Tag und 365 (und manchmal mehr!) Tage im Jahr. Das heißt, meistens ist die Eingabe des Timers entweder "Null" und der Timer zählt nichts oder eine "Einheit" kommt für eine lange Zeit an und der Timer hat bereits alles gezählt. Um den CPU-Leerlauf der zweiten Stufe zu entladen (der Timer hat bereits gezählt), muss in der Stufe überprüft werden, ob der Eingang weiterhin die Wahrheit empfängt. Wenn der Timer bereits die ganze Zeit gezählt hat, muss der Ausgang auf true gesetzt werden. In diesem Fall sollten keine Berechnungen durchgeführt werden.Meistens ist der Eingang des Timers entweder "Null" und der Timer zählt nichts oder eine "Einheit" kommt für eine lange Zeit an und der Timer hat bereits alles gezählt. Um den CPU-Leerlauf der zweiten Stufe zu entladen (der Timer hat bereits gezählt), muss in der Phase überprüft werden, ob die Wahrheit weiterhin eingeht. Wenn der Timer bereits die ganze Zeit gezählt hat, muss der Ausgang auf true gesetzt werden. In diesem Fall sollten keine Berechnungen durchgeführt werden.Meistens ist der Eingang des Timers entweder "Null" und der Timer zählt nichts oder eine "Einheit" kommt für eine lange Zeit an und der Timer hat bereits alles berechnet. Um den CPU-Leerlauf der zweiten Stufe zu entladen (der Timer hat bereits gezählt), muss in der Stufe überprüft werden, ob der Eingang weiterhin die Wahrheit empfängt. Wenn der Timer bereits die ganze Zeit gezählt hat, muss der Ausgang auf true gesetzt werden. In diesem Fall sollten keine Berechnungen durchgeführt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Änderungen vorzunehmen, muss die Ausgabe des Q-Timers vom OUTPUT-Bereich in den IN_OUT-Bereich übertragen werden, und der Ausgabewert wird in externen Variablen gespeichert (in diesem Beispiel in einem Array von Strukturen). Nach der Verfeinerung lautet der gesamte Funktionscode einschließlich der Deklaration wie folgt:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">BEGIN</span>
	<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	    #Q := FALSE;<font></font>
	    #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">// " "  </span>
	ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
	    <span class="hljs-keyword">IF</span> (<span class="hljs-keyword">NOT</span> #Q) <span class="hljs-keyword">THEN</span>
	        #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
	        #udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span>
	        #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
	        <span class="hljs-keyword">IF</span> #TimeACC &gt;= #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
	            #Q := TRUE; <span class="hljs-comment">//  ""</span>
	            #TimeACC := #udiPT; <span class="hljs-comment">//  </span><font></font>
	        END_IF;<font></font>
	    END_IF;<font></font>
	<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
	    #Q := FALSE;<font></font>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	END_IF;<font></font>
	<font></font>
	#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
	<font></font>
	ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span><font></font>
END_FUNCTION<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach verbessert sich die Ausführungszeit: Die Leerlaufzeitverarbeitung der Timer beträgt 23 ms bei einer Arbeitsfilterzeit von 37-40 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Funktionscode prüft nicht auf einen ungültigen Wert der Timer-Einstellung - einen negativen Wert (wenn das Material in eine vorzeichenlose Ganzzahl konvertiert wird, wird die Einstellung verzerrt) oder einen Wert größer als 4294,9 Sekunden (die Zeiteinstellung läuft über und verzerrt sich). Sie müssen entweder den Wert des PT-Werts im Code steuern oder die Aufgabe, den Bereich der Zeiteinstellung (von 0 bis 4294,9 Sekunden) zu überprüfen, dem Betriebssystem der obersten Ebene übertragen. Das Überprüfen des Bereichs mit dem SPS-Programm erhöht die Verarbeitungszeit auf ungefähr 45-46 ms (und im Allgemeinen ist es am korrektesten, die Timerzeit nicht im REAL-Format, sondern im UDINT-Format in Millisekunden einzustellen und Unsinn zu machen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anwendungsprojekt mit einem Timer für die Umgebung von TIA Portal Step 7 Version 16 finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491188/index.html">Was der Backend-Tester wissen sollte</a></li>
<li><a href="../de491190/index.html">Erstellen eines Online-Shops auf Nuxt.js 2 Exemplarische Vorgehensweise Teil 3</a></li>
<li><a href="../de491192/index.html">Figmiro. Ein Plugin für Figma erstellen (und ein bisschen für Miro)</a></li>
<li><a href="../de491194/index.html">Genetik des Ursprungs. Bevölkerungszusammensetzung</a></li>
<li><a href="../de491198/index.html">Sechs Tipps für das richtige Spiel-Tutorial</a></li>
<li><a href="../de491202/index.html">Ingenieure gegen Designer</a></li>
<li><a href="../de491208/index.html">7 Gewohnheiten, die jeden Introvertierten zum Meister der Kommunikation machen</a></li>
<li><a href="../de491210/index.html">Mini-Videoserie mit Charakteranimation zum Mobbing-Spiel Monster Hustle</a></li>
<li><a href="../de491212/index.html">Öl und Wodka: Wie werden wir Aufkleber von Laptops entfernen?</a></li>
<li><a href="../de491214/index.html">9 Strategien zur Vermarktung von Handyspielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>