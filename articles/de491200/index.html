<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õàÔ∏è üë≥üèø üç¥ Funktionszeitgeber f√ºr Simatic S7-1200 Industriesteuerung üå∑ üó∫Ô∏è üëâüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selbst f√ºr die Serien S7-300 und S7-400 waren unter Schritt 7 die klassischen Versionen der dem Entwickler angebotenen Timer v√∂llig ausreichend - dies...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Funktionszeitgeber f√ºr Simatic S7-1200 Industriesteuerung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491200/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst f√ºr die Serien S7-300 und S7-400 waren unter Schritt 7 die klassischen Versionen der dem Entwickler angebotenen Timer v√∂llig ausreichend - dies sind Standard-IEC-Timer, die als Funktionsbl√∂cke implementiert sind, und S5-Timer (die √ºbrigens f√ºr die S7-Serie noch existieren) 1500). In einigen F√§llen verwendete der Entwickler jedoch keine Standardtools und implementierte seine eigenen Timer, meist in Form von Funktionen. Solche Timer-Funktionen waren bei einem ‚ÄûIT‚Äú -Ansatz f√ºr die Programmierung erforderlich, bei dem sie nicht mit getrennten Instanzen der Funktionsbl√∂cke technologischer Ger√§te, mit der entsprechenden Bindung von Ein- und Ausg√§ngen, sondern mit Arrays von Strukturen arbeiteten. Zum Beispiel ein Array einer diskreten Eingabetypstruktur. Oder ein Array einer Aggregatstruktur. Dieser Ansatz zur Programmierung hat ein Existenzrecht, da Sie damit den Arbeitsspeicher der CPU ernsthaft sparen k√∂nnen, aberAuf der anderen Seite ist der Programmcode schwer zu lesen. Ein Programmierer von Drittanbietern und mit einem einfachen Blick auf ein LAD-Programm kann es kaum sofort herausfinden, aber jede Menge Indizes, Arrays und Funktionen zu ihrer Verarbeitung kommen nicht in Frage - hier ohne Dokumentation f√ºr die Software (und nat√ºrlich ohne einen halben Liter) nirgendwo.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Arrays von Strukturen wurden typischerweise in Funktionen verarbeitet. Im Prinzip hat nichts die Verarbeitung von Funktionsbl√∂cken verhindert, aber es gab immer eine wichtige Frage - wie man in diesen F√§llen mit Timern arbeitet? Standard-Timer nehmen entweder eine Nummer (S5) oder eine Instanz eines Funktionsblocks (IEC) an. Ich erinnere Sie daran, dass es darum geht, Arrays von Strukturen f√ºr klassische Simatic-SPS zu verarbeiten und Timer-Nummern in diese Strukturen zu ‚Äûverdrehen‚Äú, und noch mehr, Instanzen sind entweder schwierig oder einfach unm√∂glich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund haben wir als Funktion unsere eigene Timer-Funktionalit√§t erstellt. Grunds√§tzlich m√ºssen Sie f√ºr den Betrieb eines Timers nur wenige Dinge wissen - den Status der Eingabe, die Zeiteinstellung und wie viel Zeit seit der Aktivierung vergangen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die Serien 300 und 400 gab es zwei M√∂glichkeiten, diese Zeit zu bestimmen. </font><font style="vertical-align: inherit;">Die erste besteht darin, die Laufzeit des Haupt-OB1 (es gibt eine entsprechende Variable in OB1 selbst) oder der zyklischen OBs zu betrachten und den internen Zeitakkumulator bei jedem Timer-Aufruf zu erh√∂hen, vorausgesetzt, die ‚ÄûWahrheit‚Äú wird eingegeben. </font><font style="vertical-align: inherit;">Keine gute Option, da diese Zeit f√ºr OB1 und zyklische OBs unterschiedlich ist. </font><font style="vertical-align: inherit;">Die zweite Methode ist die Systemfunktion TIME_TCK, die bei jedem Aufruf einen einzelnen Wert zur√ºckgibt - den internen Millisekundenz√§hler des Zentralprozessors. </font></font><br>
<br>
<img src="https://sun9-40.userapi.com/c855036/v855036198/1f8065/UwCQvxh507k.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit war f√ºr einen Zeitgeber vom TON-Typ (bei Verz√∂gerung) der Operationsalgorithmus wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie bei steigender Flanke der Antwortanforderung den Ausgang zur√ºck und merken Sie sich den aktuellen Wert des System-Timers TIME_TCK</font></font></li>
<li>       ¬´¬ª          ,        (   ,  TIME_TCK    0  (2 ^ 31 ‚Äî 1),          ).   ,        .    ,    ¬´¬ª,    ‚Äî ¬´¬ª</li>
<li>      ¬´¬ª,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Aufkommen der "tausendsten" Serie hat sich die Situation ein wenig ge√§ndert. Tatsache ist, dass die S7-1500-Leitung die Unterst√ºtzung f√ºr den Systemaufruf TIME_TCK und Liebhaber des Ansatzes ‚ÄûStehen und in einer H√§ngematte‚Äú geerbt hat (wie kann man sonst ein Programm aufrufen, das nur Arrays von Strukturen verarbeitet, w√§hrend es mit gruseligen Indizes arbeitet?) Verwenden Sie ruhig weiterhin ihre Best Practices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Basissteuerungen der S7-1200-Serie basieren auf einer anderen Architektur und weisen eine Reihe von Unterschieden zur S7-1500 auf. Einschlie√ülich des Fehlens eines TIME_TCK-Systemaufrufs. In den Reihen der Entwickler, die nicht gen√ºgend Flexibilit√§t beim Denken haben, ist die Unzufriedenheit verschwunden - es ist unm√∂glich, Kopien / Pasten alter Programme auszuf√ºhren. Die Aufgabe, zu bestimmen, wie viel Zeit seit dem vorherigen Aufruf vergangen ist, kann jedoch mithilfe der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Laufzeitfunktion ausgef√ºhrt</font></a><font style="vertical-align: inherit;"> werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion gibt die seit ihrem vorherigen Aufruf verstrichene Zeit in Sekunden als reelle Zahl LREAL mit doppelter Genauigkeit zur√ºck. Details sind in der Hilfe beschrieben. F√ºr interne Zwecke ist eine zus√§tzliche MEM-Variable (ebenfalls vom Typ LREAL) erforderlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde die Quellen der ersten Ann√§herung der Funktion angeben und einige Anmerkungen machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionsdeklaration:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_OUTPUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Ein- / Ausg√§ngen ist alles klar: IN, Q und PT. Ich stelle die Zeiteinstellung in Form einer echten ein, es sind Sekunden. Ich wollte nur (aber vergebens, aber mehr dazu weiter unten). Weitere Informationen zu Variablen des InOut-Bereichs. Da wir eine Funktion haben, haben wir keinen STAT-Bereich, es gibt keine Variablen, die ihren Wert beim n√§chsten Funktionsaufruf beibehalten, und solche Variablen werden ben√∂tigt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPrv - um die positive Flanke der Anforderung </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEM </font><font style="vertical-align: inherit;">zu bestimmen </font><font style="vertical-align: inherit;">- Hilfsvariable f√ºr den Systemaufruf zur Laufzeit </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RuntimeACC - Zeitakkumulator , die die Anzahl der Mikrosekunden der aktuell laufenden Verz√∂gerung speichert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variablen TimeACC, udiCycle und udiPT werden im UDINT-Format angegeben, einer vorzeichenlosen Ganzzahl mit 4 Bytes. </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass ich die Zeit als real angegeben habe und die Laufzeitfunktion real bis zur doppelten Genauigkeit zur√ºckgibt, bevorzuge ich einfache Operationen zum Summieren und Vergleichen mit ganzzahligen Operanden, um Prozessorzeit zu sparen. </font><font style="vertical-align: inherit;">Die Zeit in meinem Fall wird in Mikrosekunden ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Der Grund ist einfach: Wenn Sie die Zeit auf Millisekunden vergr√∂bern, ist bei fast leerem OB1 (z. B. wenn nur ein Timer im gesamten Steuerungsprogramm aufgerufen wird und nichts weiter) ein ‚Äû√úberspringen‚Äú von Zyklen m√∂glich, das Programm l√§uft manchmal f√ºr 250 Œºs. </font><font style="vertical-align: inherit;">In diesem Fall betr√§gt der maximal zul√§ssige Wert des Zeitakkumulators 4.294 Sekunden, fast 4.295 (2 ^ 32 - 1 = 4.294.967.295). </font><font style="vertical-align: inherit;">Es gibt nichts zu tun, eine solche ‚ÄûOptimierung‚Äú erfordert Opfer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionstext.</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
    #Q := FALSE;<font></font>
ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
    #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
    <span class="hljs-keyword">IF</span> #TimeACC &gt;=  #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
        #Q := TRUE; <span class="hljs-comment">//  ""</span>
        #TimeACC := #udiPT; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//      </span>
        #Q := FALSE; <span class="hljs-comment">// </span><font></font>
    END_IF;<font></font>
<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
    #Q := FALSE;<font></font>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
END_IF;<font></font>
<font></font>
#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
<font></font>
ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten beiden Zeilen sind die Neuberechnung der Timer-Einstellung von der im REAL-Format angegebenen Anzahl von Sekunden auf die Anzahl von Mikrosekunden. </font><font style="vertical-align: inherit;">Die Zeit in Mikrosekunden, die seit dem vorherigen Programmblockaufruf vergangen ist, wird ebenfalls bestimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner ist der Algorithmus wie folgt und ich habe ihn bereits gegeben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie bei steigender Flanke des Eingangs IN den Ausgang Q zur√ºck und setzen Sie den Zeitspeicher zur√ºck</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die ‚ÄûWahrheit‚Äú weiterhin eingegeben wird, erh√∂hen wir den Zeitakkumulator um den bereits bekannten udiCycle-Wert und vergleichen ihn mit der Zeiteinstellung. </font><font style="vertical-align: inherit;">Wenn die Zeiteinstellung √ºberschritten wird, hat der Timer funktioniert, geben Sie die Ausgabe "wahr", andernfalls geben Sie die Ausgabe "falsch".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen falschen Eingang an den IN-Eingang anlegen, setzen Sie den Q-Ausgang zur√ºck und setzen Sie den Zeitspeicher zur√ºck.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich am Ende der Funktion an den vorherigen Wert, um die Flanke des Eingangs IN zu bestimmen. </font><font style="vertical-align: inherit;">Geben Sie der Ausgabe ENO (bei Verwendung einer Funktion in grafischen Sprachen wie LAD) auch den Wert der Ausgabe Q an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir stellen sicher, dass die Funktion funktioniert. Danach wird es interessant, ihre Geschwindigkeit zu bewerten und gegebenenfalls zu verbessern (es scheint bereits auf den ersten Blick, dass eine Reihe von Berechnungen durchgef√ºhrt werden) Leerlauf und vergebliche Verschwendung von CPU-Zeit). </font><font style="vertical-align: inherit;">Um die Leistung zu bewerten, deklariere ich ein Array von 1000 Timer-Datenstrukturen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erkl√§rung der Struktur. </font><font style="vertical-align: inherit;">Seine Felder duplizieren die Eingabe- und Ausgabevariablen der Timerfunktion.</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">TYPE</span> "typePervTONdata"<font></font>
VERSION : <span class="hljs-number">0.1</span><font></font>
   STRUCT<font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//   </span>
      Q : Bool;   <span class="hljs-comment">//  </span>
      INPrv : Bool;   <span class="hljs-comment">//    </span>
      MEM : LReal;   <span class="hljs-comment">//    </span>
      TimeACC : UDInt;   <span class="hljs-comment">//  </span><font></font>
   END_STRUCT;<font></font>
<font></font>
END_TYPE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im globalen Datenblock TortureTON wird ein Array von Strukturen deklariert:</font></font><br>
<br>
<pre><code class="delphi hljs">TONs : <span class="hljs-keyword">Array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">999</span>] <span class="hljs-keyword">of</span> "typePervTONdata";
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der folgende Code wird im Organisationsblock OB1 ausgef√ºhrt:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">FOR</span> #i := <span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">999</span> <span class="hljs-keyword">DO</span>
    "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span> := "startton";<font></font>
    "PerversionTON"(<span class="hljs-keyword">IN</span> := "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span>,<font></font>
                    PT := "TortureTON".TONs[#i].PT,<font></font>
                    Q := "TortureTON".TONs[#i].Q,<font></font>
                    INPrv := "TortureTON".TONs[#i].INPrv,<font></font>
                    MEM := "TortureTON".TONs[#i].MEM,<font></font>
                    TimeACC := "TortureTON".TONs[#i].TimeACC);<font></font>
END_FOR;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ank√ºndigung von 1000 "Instanzen" von Timern, die jeweils eine Zeit von 10 Sekunden einstellen. Alle 1000 Timer beginnen, die Zeit nach dem Wert der Startton-Markierungsvariablen zu z√§hlen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich starte die Diagnosefunktionen der Steuerung (S7-1214C DC / DC / DC, Version FW 4.4, Version Step7 - V16) und beobachte die Scan-Zykluszeit der Steuerung. Bei "Leerlauf" (wenn "Falsch" am Eingang der Timer eintrifft) werden die gesamten Tausend durchschnittlich 36-42 Millisekunden lang verarbeitet. W√§hrend des Countdowns von zehn Sekunden w√§chst dieser Messwert um etwa 6-8 Millisekunden und rollt manchmal f√ºr 50 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schauen uns an, was im Funktionscode verbessert werden kann. Erstens die Zeilen ganz am Anfang des Programmblocks:</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden immer aufgerufen, unabh√§ngig davon, ob der Timer die Zeit z√§hlt, nicht z√§hlt oder bereits gez√§hlt hat. Eine gro√üe Geldverschwendung besteht darin, die nicht sehr leistungsstarke CPU der 1200er-Serie mit Berechnungen zu beladen, bei denen Materialien mit doppelter Genauigkeit verwendet werden. Es ist sinnvoll, beide Zeilen auf den Teil des Codes zu √ºbertragen, der den Countdown verarbeitet (wenn die ‚ÄûWahrheit‚Äú weiterhin eingeht). Es ist auch erforderlich, die udiCycle-Berechnung in einen Code zu duplizieren, der eine positive Flanke am Eingang des Timers verarbeitet. Dies sollte den "Leerlaufbetrieb" des Timers entlasten, wenn der Eingabewert falsch ist. In der Praxis arbeiten Timer in speicherprogrammierbaren Steuerungen meistens im Leerlauf. Beispielsweise betr√§gt die Filterzeit des Kontaktsprungs einige zehn Millisekunden. Der Steuerimpuls eines diskreten Ausgangs betr√§gt einige hundert Millisekunden, normalerweise 0,5 bis 1,0 Sekunden.Die Zeit f√ºr die √úberwachung der Ausf√ºhrung des Einheitenbefehls (z. B. die Zeit, in der das Ventil vollst√§ndig ge√∂ffnet wird) betr√§gt einige zehn Sekunden bis einige Minuten. SPS in der Produktion arbeitet 24 Stunden am Tag und 365 (und manchmal mehr!) Tage im Jahr. Das hei√üt, meistens ist die Eingabe des Timers entweder "Null" und der Timer z√§hlt nichts oder eine "Einheit" kommt f√ºr eine lange Zeit an und der Timer hat bereits alles gez√§hlt. Um den CPU-Leerlauf der zweiten Stufe zu entladen (der Timer hat bereits gez√§hlt), muss in der Stufe √ºberpr√ºft werden, ob der Eingang weiterhin die Wahrheit empf√§ngt. Wenn der Timer bereits die ganze Zeit gez√§hlt hat, muss der Ausgang auf true gesetzt werden. In diesem Fall sollten keine Berechnungen durchgef√ºhrt werden.Meistens ist der Eingang des Timers entweder "Null" und der Timer z√§hlt nichts oder eine "Einheit" kommt f√ºr eine lange Zeit an und der Timer hat bereits alles gez√§hlt. Um den CPU-Leerlauf der zweiten Stufe zu entladen (der Timer hat bereits gez√§hlt), muss in der Phase √ºberpr√ºft werden, ob die Wahrheit weiterhin eingeht. Wenn der Timer bereits die ganze Zeit gez√§hlt hat, muss der Ausgang auf true gesetzt werden. In diesem Fall sollten keine Berechnungen durchgef√ºhrt werden.Meistens ist der Eingang des Timers entweder "Null" und der Timer z√§hlt nichts oder eine "Einheit" kommt f√ºr eine lange Zeit an und der Timer hat bereits alles berechnet. Um den CPU-Leerlauf der zweiten Stufe zu entladen (der Timer hat bereits gez√§hlt), muss in der Stufe √ºberpr√ºft werden, ob der Eingang weiterhin die Wahrheit empf√§ngt. Wenn der Timer bereits die ganze Zeit gez√§hlt hat, muss der Ausgang auf true gesetzt werden. In diesem Fall sollten keine Berechnungen durchgef√ºhrt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese √Ñnderungen vorzunehmen, muss die Ausgabe des Q-Timers vom OUTPUT-Bereich in den IN_OUT-Bereich √ºbertragen werden, und der Ausgabewert wird in externen Variablen gespeichert (in diesem Beispiel in einem Array von Strukturen). Nach der Verfeinerung lautet der gesamte Funktionscode einschlie√ülich der Deklaration wie folgt:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">BEGIN</span>
	<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	    #Q := FALSE;<font></font>
	    #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">// " "  </span>
	ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
	    <span class="hljs-keyword">IF</span> (<span class="hljs-keyword">NOT</span> #Q) <span class="hljs-keyword">THEN</span>
	        #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
	        #udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span>
	        #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
	        <span class="hljs-keyword">IF</span> #TimeACC &gt;= #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
	            #Q := TRUE; <span class="hljs-comment">//  ""</span>
	            #TimeACC := #udiPT; <span class="hljs-comment">//  </span><font></font>
	        END_IF;<font></font>
	    END_IF;<font></font>
	<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
	    #Q := FALSE;<font></font>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	END_IF;<font></font>
	<font></font>
	#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
	<font></font>
	ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span><font></font>
END_FUNCTION<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach verbessert sich die Ausf√ºhrungszeit: Die Leerlaufzeitverarbeitung der Timer betr√§gt 23 ms bei einer Arbeitsfilterzeit von 37-40 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Funktionscode pr√ºft nicht auf einen ung√ºltigen Wert der Timer-Einstellung - einen negativen Wert (wenn das Material in eine vorzeichenlose Ganzzahl konvertiert wird, wird die Einstellung verzerrt) oder einen Wert gr√∂√üer als 4294,9 Sekunden (die Zeiteinstellung l√§uft √ºber und verzerrt sich). Sie m√ºssen entweder den Wert des PT-Werts im Code steuern oder die Aufgabe, den Bereich der Zeiteinstellung (von 0 bis 4294,9 Sekunden) zu √ºberpr√ºfen, dem Betriebssystem der obersten Ebene √ºbertragen. Das √úberpr√ºfen des Bereichs mit dem SPS-Programm erh√∂ht die Verarbeitungszeit auf ungef√§hr 45-46 ms (und im Allgemeinen ist es am korrektesten, die Timerzeit nicht im REAL-Format, sondern im UDINT-Format in Millisekunden einzustellen und Unsinn zu machen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anwendungsprojekt mit einem Timer f√ºr die Umgebung von TIA Portal Step 7 Version 16 finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491188/index.html">Was der Backend-Tester wissen sollte</a></li>
<li><a href="../de491190/index.html">Erstellen eines Online-Shops auf Nuxt.js 2 Exemplarische Vorgehensweise Teil 3</a></li>
<li><a href="../de491192/index.html">Figmiro. Ein Plugin f√ºr Figma erstellen (und ein bisschen f√ºr Miro)</a></li>
<li><a href="../de491194/index.html">Genetik des Ursprungs. Bev√∂lkerungszusammensetzung</a></li>
<li><a href="../de491198/index.html">Sechs Tipps f√ºr das richtige Spiel-Tutorial</a></li>
<li><a href="../de491202/index.html">Ingenieure gegen Designer</a></li>
<li><a href="../de491208/index.html">7 Gewohnheiten, die jeden Introvertierten zum Meister der Kommunikation machen</a></li>
<li><a href="../de491210/index.html">Mini-Videoserie mit Charakteranimation zum Mobbing-Spiel Monster Hustle</a></li>
<li><a href="../de491212/index.html">√ñl und Wodka: Wie werden wir Aufkleber von Laptops entfernen?</a></li>
<li><a href="../de491214/index.html">9 Strategien zur Vermarktung von Handyspielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>