<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏽 🤟 ⏪ Criação de Minecraft em uma semana em C ++ e Vulkan 🙋🏽 👩🏽 🕹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu me propus a recriar o Minecraft do zero em uma semana usando meu próprio mecanismo em C ++ e Vulkan. Fui inspirado por Hopson , que fez o mesmo com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Criação de Minecraft em uma semana em C ++ e Vulkan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487832/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu me propus a recriar o Minecraft do zero em uma semana usando meu próprio mecanismo em C ++ e Vulkan. </font><font style="vertical-align: inherit;">Fui inspirado por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hopson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que fez o mesmo com C ++ e OpenGL. </font><font style="vertical-align: inherit;">Por sua vez, ele foi inspirado por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shane Beck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , inspirado em Minecraft, cuja fonte de inspiração era Infiniminer, cuja criação, presumivelmente, foi inspirada em mineração real.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/8b2/50c/aa18b250ce4120bd3a0dc94c01a63621.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O repositório GitHub para este projeto está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cada dia tem sua própria tag git. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, eu não planejava recriar literalmente o Minecraft. </font><font style="vertical-align: inherit;">Este projeto deveria ser educacional. </font><font style="vertical-align: inherit;">Eu queria aprender sobre o uso do Vulkan em algo mais complicado do que o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulkan-tutorial.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou a demonstração de Sasha Willem. </font><font style="vertical-align: inherit;">Portanto, a ênfase principal está no design do mecanismo Vulkan, e não no design do jogo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarefas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O desenvolvimento no Vulkan é muito mais lento que no OpenGL, então não pude incorporar muitos dos recursos deste Minecraft no jogo. </font><font style="vertical-align: inherit;">Não há multidões, artesanato, pedra vermelha, física de blocos, etc. </font><font style="vertical-align: inherit;">Desde o início, os objetivos do projeto foram os seguintes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criando um sistema de renderização de terreno</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mashing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iluminação</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criando um sistema gerador de terreno</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alívio</font></font></li>
</ul><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árvores</font></font></li>
</ul><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionando a capacidade de mudar de terreno e mover blocos</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu precisava encontrar uma maneira de implementar tudo isso sem adicionar uma GUI ao jogo, porque não consegui encontrar nenhuma biblioteca de GUI que funcionasse com o Vulkan e fosse fácil de integrar.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotecas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, eu não ia escrever um aplicativo Vulkan do zero. </font><font style="vertical-align: inherit;">Para acelerar o processo de desenvolvimento, usarei bibliotecas prontas sempre que possível. </font><font style="vertical-align: inherit;">Nomeadamente:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VulkanWrapper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - meu próprio wrapper C ++ para a API Vulkan</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLFW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para janelas e entrada do usuário</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VulkanMemoryAllocator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para alocar memória Vulkan</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para vetores e matrizes matemáticos</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para sinais / slots e ECS</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para utilitários de carregamento de imagens</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FastNoise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para gerar ruído 3D</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No primeiro dia, preparei um clichê Vulkan e um esqueleto do motor. </font><font style="vertical-align: inherit;">A maior parte do código era um clichê e eu podia copiá-lo do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulkan-tutorial.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Também incluiu um truque para armazenar dados de vértices como parte de um sombreador de vértices. </font><font style="vertical-align: inherit;">Isso significava que nem precisava ajustar a alocação de memória. </font><font style="vertical-align: inherit;">Apenas um transportador simples que pode fazer apenas uma coisa: desenhar um triângulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mecanismo é simples o suficiente para suportar o renderizador de triângulos. </font><font style="vertical-align: inherit;">Possui uma janela e um ciclo de jogo aos quais os sistemas podem ser conectados. </font><font style="vertical-align: inherit;">A GUI é limitada pela taxa de quadros exibida no título da janela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O projeto está dividido em duas partes: </font></font><code>VoxelEngine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>VoxelGame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/3cd/190/8753cd190975239ad550e8c0c8b27d00.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Integrei a biblioteca do Vulkan Memory Allocator. </font><font style="vertical-align: inherit;">Esta biblioteca cuida da maior parte do padrão da alocação de memória da Vulkan: tipos de memória, pilhas de memória do dispositivo e alocação secundária. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que eu tinha uma alocação de memória, criei classes para malhas e buffers de vértice. </font><font style="vertical-align: inherit;">Mudei o renderizador dos triângulos para que ele use a classe de malhas, e não as matrizes embutidas no shader. </font><font style="vertical-align: inherit;">Atualmente, os dados de malha são transferidos para a GPU renderizando manualmente os triângulos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/28d/0fc/62728d0fce9015f2be4dad88f18c7b7a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pouco mudou</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 3</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu adicionei um sistema de renderização gráfica. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta postagem foi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tomada como base para a criação desta classe </font><font style="vertical-align: inherit;">, mas a classe é muito simplificada. Meu gráfico de renderização contém apenas o essencial para lidar com a sincronização com o Vulkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O gráfico de renderização permite definir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arestas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nós são o trabalho realizado pela GPU. Nervuras são dependências de dados entre nós. Cada nó recebe seu próprio buffer de instruções, no qual escreve. O gráfico está envolvido em buffers de comando com buffer duplo e sincronizando-os com quadros anteriores. As arestas são usadas para inserir automaticamente barreiras do transportador antes e depois que um nó grava em cada buffer de instruções. As barreiras de pipeline sincronizam o uso de todos os recursos e transferem a propriedade entre filas. Além disso, as arestas inserem semáforos entre os nós. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós e arestas formam um </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gráfico acíclico direcionado</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em seguida, o gráfico de renderização executa a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classificação topológica.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós, o que leva à criação de uma lista simples de nós classificados para que cada nó siga todos os nós dos quais depende. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mecanismo possui três tipos de nós. </font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recebe uma imagem de uma cadeia de buffer (swapchain), </font></font><code>TransferNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfere dados da CPU para a GPU e </font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma imagem de uma cadeia de buffer a ser exibida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada nó pode implementar </font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>postRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que são executados em cada quadro. </font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtém uma imagem de uma cadeia de buffers durante </font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece esta imagem a tempo </font></font><code>postRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Refatorei o renderizador de triângulo para que ele usasse um sistema de gráficos de renderização, em vez de processar tudo sozinho. Há uma vantagem entre </font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bem como entre </font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso garante que a imagem da cadeia de buffer seja sincronizada corretamente durante seu uso durante o quadro.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/d88/6ba/12bd886ba9b41891ae1e2d0ff47b9929.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu juro que dentro do motor mudou</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 4</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Criei uma câmera e um sistema de renderização em 3D. Até agora, a câmera recebe seu próprio buffer persistente e conjunto de descritores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu diminuí a velocidade naquele dia porque estava tentando encontrar a configuração correta para renderização em 3D com o Vulkan. A maioria dos materiais on-line se concentra na renderização usando o OpenGL, que usa sistemas de coordenadas um pouco diferentes do Vulkan. No OpenGL, o eixo Z do espaço do clipe é especificado como </font></font><code>[-1, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a borda superior da tela está em </font></font><code>Y = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No Vulkan, o eixo Z é especificado como </font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a borda superior da tela está em </font></font><code>Y = -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Devido a essas pequenas diferenças, as matrizes de projeção GLM padrão não funcionam corretamente porque foram projetadas para o OpenGL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GLM tem uma opção</font></font><code>GLM_FORCE_DEPTH_ZERO_TO_ONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eliminando o problema com o eixo Z. Depois disso, o problema com o eixo Y pode ser eliminado simplesmente alterando o sinal do elemento da </font></font><code>(1, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz de projeção (o GLM usa a indexação de 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se invertermos o eixo Y, precisamos inverter os dados do vértice, porque antes disso, a direção negativa do eixo Y apontava para cima.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/05d/464/8d905d4643a189400471c7e8d4fbd3f6.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora em 3D!</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 5</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu adicionei a entrada do usuário e a capacidade de mover a câmera com o mouse. </font><font style="vertical-align: inherit;">O sistema de entrada é muito sofisticado, mas elimina as esquisitices da entrada GLFW. </font><font style="vertical-align: inherit;">Em particular, tive o problema de alterar a posição do mouse enquanto o bloqueava. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A entrada do teclado e do mouse é essencialmente um invólucro fino no GLFW, aberto por meio de manipuladores de sinal </font></font><code>entt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apenas para comparação - sobre a mesma coisa que Hopson fez no primeiro dia de seu projeto.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu navegador não suporta vídeo HTML5.</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels.webm" type="video/webm"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 6</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comecei a adicionar código para gerar e renderizar blocos voxel. </font><font style="vertical-align: inherit;">Escrever o código da malha foi fácil, porque eu fiz isso antes e conhecia abstrações que me permitiam cometer menos erros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma das abstrações era uma classe de modelo </font></font><code>ChunkData&lt;T, chunkSize&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que define um cubo do tipo o </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamanho </font></font><code>chunkSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cada lado. </font><font style="vertical-align: inherit;">Esta classe armazena dados em uma matriz 1D e processa dados de indexação com uma coordenada 3D. </font><font style="vertical-align: inherit;">O tamanho de cada bloco é 16 x 16 x 16, portanto, os dados internos são uma matriz simples com um comprimento de 4096. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra abstração é criar um iterador de posições que gera coordenadas de </font></font><code>(0, 0, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font><code>(15, 15, 15)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essas duas classes garantem que as iterações com os dados do bloco sejam executadas em uma ordem linear para aumentar a localidade do cache. </font><font style="vertical-align: inherit;">A coordenada 3D ainda está disponível para outras operações que precisam. </font><font style="vertical-align: inherit;">Por exemplo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (glm::ivec3 pos : Chunk::Positions()) {
    <span class="hljs-keyword">auto</span>&amp; data = chunkData[pos];<font></font>
    glm::ivec3 offset = ...;<font></font>
    <span class="hljs-keyword">auto</span>&amp; neighborData = chunkData[pos + offset];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu tenho várias matrizes estáticas que especificam as compensações que são comumente usadas no jogo. </font><font style="vertical-align: inherit;">Por exemplo, </font></font><code>Neighbors6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define 6 vizinhos com os quais o cubo tem faces comuns.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;glm::ivec3, 6&gt; Neighbors6 = {<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),    <span class="hljs-comment">//right</span>
        glm::ivec3(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),   <span class="hljs-comment">//left</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),    <span class="hljs-comment">//top</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>),   <span class="hljs-comment">//bottom</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),    <span class="hljs-comment">//front</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)    <span class="hljs-comment">//back</span>
    };</code></pre><br>
<code>Neighbors26</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- são todos os vizinhos com quem o cubo tem uma face, aresta ou vértice comum. </font><font style="vertical-align: inherit;">Ou seja, é uma grade 3x3x3 sem um cubo central. </font><font style="vertical-align: inherit;">Também existem matrizes semelhantes para outros conjuntos de vizinhos e para conjuntos 2D de vizinhos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma matriz que define os dados necessários para criar uma face do cubo. </font><font style="vertical-align: inherit;">As direções de cada face nesta matriz correspondem às direções na matriz </font></font><code>Neighbors6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;FaceArray, 6&gt; NeighborFaces = {
    <span class="hljs-comment">//right face</span><font></font>
    FaceArray {<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<font></font>
    },<font></font>
    ...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Graças a isso, o código de criação da malha é muito simples. Ele simplesmente ignora os dados dos blocos e adiciona uma face quando o bloco é sólido, mas seu vizinho não. O código simplesmente verifica todas as faces de cada cubo em um bloco. Isso é semelhante ao método "ingênuo" descrito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (glm::ivec3 pos : Chunk::Positions()) {<font></font>
    Block block = chunk.blocks()[pos];<font></font>
    <span class="hljs-keyword">if</span> (block.type == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; Chunk::Neighbors6.size(); i++) {<font></font>
        glm::ivec3 offset = Chunk::Neighbors6[i];<font></font>
        glm::ivec3 neighborPos = pos + offset;<font></font>
<font></font>
        <span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> bounds checking omitted</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> (chunk.blocks()[neighborPos].type == <span class="hljs-number">0</span>) {<font></font>
            Chunk::FaceArray&amp; faceArray = Chunk::NeighborFaces[i];<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; faceArray.size(); j++) {<font></font>
                m_vertexData.push_back(pos + faceArray[j]);<font></font>
                m_colorData.push_back(glm::i8vec4(pos.x * <span class="hljs-number">16</span>, pos.y * <span class="hljs-number">16</span>, pos.z * <span class="hljs-number">16</span>, <span class="hljs-number">0</span>));<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu substituí </font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>ChunkRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Também adicionei um buffer de profundidade para que a malha do bloco possa renderizar corretamente. Foi necessário adicionar mais uma aresta ao gráfico de renderização entre </font></font><code>TransferNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>ChunkRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Essa borda transfere a propriedade dos recursos da família de filas entre a fila de transferência e a fila de gráficos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então mudei o mecanismo para que ele pudesse manipular corretamente os eventos de alteração de janela. No OpenGL, isso é feito de forma simples, mas bastante confusa no Vulkan. Como a cadeia de buffers deve ser criada explicitamente e ter um tamanho constante, quando você redimensiona a janela, é necessário recriá-la. Você deve recriar todos os recursos que dependem da cadeia de buffers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos os comandos que dependem da cadeia de buffers (e agora todos são comandos de desenho) devem concluir a execução antes de destruir a antiga cadeia de buffers. </font><font style="vertical-align: inherit;">Isso significa que a GPU inteira ficará ociosa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você precisa alterar o pipeline de gráficos para fornecer uma viewport e redimensionamento dinâmicos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma cadeia de buffers não pode ser criada se o tamanho da janela for 0 no eixo X ou Y. Incluindo quando a janela é minimizada. </font><font style="vertical-align: inherit;">Ou seja, quando isso acontece, o jogo inteiro é pausado e continua apenas quando a janela se abre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora a malha é um simples tabuleiro de xadrez tridimensional. </font><font style="vertical-align: inherit;">As cores RGB da malha são definidas de acordo com sua posição XYZ multiplicada por 16.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu navegador não suporta vídeo HTML5.</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels2.webm" type="video/webm"></video></div></div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia 7</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu fiz o processo do jogo não um, mas vários blocos de cada vez. Vários blocos e suas malhas são gerenciados pela biblioteca do ECS </font></font><code>entt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em seguida, refatorei o renderizador de blocos para renderizar todos os blocos que estão no ECS. Ainda tenho apenas um bloco, mas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poderia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicionar novos, se necessário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Refatorei a malha para que seus dados pudessem ser atualizados após a criação. Isso permitirá que eu atualize a malha do bloco no futuro quando adicionar a capacidade de adicionar e remover cubos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você adiciona ou remove um cubo, o número de vértices na malha pode aumentar ou diminuir potencialmente. O buffer de vértice selecionado anteriormente pode ser usado apenas se a nova malha for do mesmo tamanho ou menor. Mas se a malha for maior, novos buffers de vértice deverão ser criados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O buffer de vértice anterior não pode ser excluído imediatamente. Pode haver buffers de instruções executados a partir de quadros anteriores que são específicos para um objeto específico </font></font><code>VkBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O mecanismo deve manter um buffer até que esses buffers de comando estejam completos. Ou seja, se desenharmos uma malha em um quadro </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a GPU poderá usar esse buffer antes do início do quadro </font></font><code>i + 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O buffer não pode ser removido da CPU até que a GPU termine de usá-lo. Então, mudei o gráfico de renderização para acompanhar o tempo de vida dos recursos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o nó do gráfico de renderização quiser usar um recurso (buffer ou imagem), deverá chamar o método </font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro do método </font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este método obtém um ponteiro </font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para um recurso. este</font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garante que o recurso não seja excluído enquanto os buffers de comando forem executados. </font><font style="vertical-align: inherit;">(Em termos de desempenho, esta solução não é muito boa. Mais sobre isso mais adiante.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora a malha do bloco é regenerada em cada quadro.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu navegador não suporta vídeo HTML5.</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels3.webm" type="video/webm"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi tudo o que fiz em uma semana - preparei o básico para renderizar o mundo com vários blocos de voxel e continuará a funcionar na segunda semana.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt487812/index.html">O teste de espectro LED polonês levou E27</a></li>
<li><a href="../pt487814/index.html">Velocidade e confiabilidade são mais altas e o preço é mais baixo. Novas unidades de estado sólido Kingston KC2000</a></li>
<li><a href="../pt487822/index.html">AvitoTech On Tour: encontro com o Android em Nizhny Novgorod</a></li>
<li><a href="../pt487824/index.html">Visão geral das lâmpadas LED Spectrum Led GU10 da Europa</a></li>
<li><a href="../pt487826/index.html">Visão geral das lâmpadas LED da Polônia Spectrum Led E14</a></li>
<li><a href="../pt487834/index.html">Semana de Segurança 07: Vulnerabilidade de pilha Bluetooth do Android</a></li>
<li><a href="../pt487836/index.html">Upload interativo de arquivos para o servidor usando RxJS</a></li>
<li><a href="../pt487838/index.html">Validação de dados: uma abordagem diferente</a></li>
<li><a href="../pt487842/index.html">2 SIM para um roteador de país - é muito ou pouco?</a></li>
<li><a href="../pt487844/index.html">O cheiro revela</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>