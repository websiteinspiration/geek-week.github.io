<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèΩ üòµ üë©üèª‚Äçü§ù‚Äçüë®üèΩ GO Scheduler: Now Not Cooperative? ‚öóÔ∏è üå¨Ô∏è ‚ùå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you read the release notes for version GO 1.14, you probably noticed some pretty interesting changes in the runtime of the language. So I was very ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GO Scheduler: Now Not Cooperative?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you read the release notes for version GO 1.14, you probably noticed some pretty interesting changes in the runtime of the language. </font><font style="vertical-align: inherit;">So I was very interested in the item: "Goroutines are now asynchronously preemptible." </font><font style="vertical-align: inherit;">It turns out that GO scheduler (scheduler) is now not cooperative? </font><font style="vertical-align: inherit;">Well, after reading the corresponding </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagonally, </font><font style="vertical-align: inherit;">curiosity was satisfied. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, after a while I decided to research the innovations in more detail. </font><font style="vertical-align: inherit;">I would like to share the results of these studies.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/ur/hn/s0urhnlqgwhwtkwumpnyd2hfmyy.png" alt="image"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System requirements</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The things described below require from the reader, in addition to knowledge of the GO language, additional knowledge, namely:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> understanding of the principles of the scheduler (although I will try to explain below, ‚Äúon the fingers‚Äù)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> understanding how the garbage collector works</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> understanding what GO assembler is </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, I will leave a couple of links that, in my opinion, cover these topics well.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly about the planner</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, let me remind you what cooperative and non-cooperative multitasking is. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With non-cooperative (crowding out) multitasking, we are all familiar with the example of the OS scheduler. This scheduler works in the background, unloads threads based on various heuristics, and instead of unloaded CPU time, other threads begin to receive. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The cooperative planner is characterized by a different behavior - he sleeps until one of the goroutines clearly wakes him up with a hint of readiness to give his place to another. The planner will then decide for himself whether it is necessary to remove the current goroutine from the context, and if so, whom to put in its place. That‚Äôs how the GO scheduler worked. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, we consider the cornerstones that the scheduler operates with:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P - logical processors (we can change their number with the runtime.GOMAXPROCS function), on each logical processor one goroutine can be executed independently at one time. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M - OS threads. </font><font style="vertical-align: inherit;">Each P runs on a thread from M. Note that P is not always equal to M, for example, a thread can be blocked by syscall and then another thread will be allocated for its P. </font><font style="vertical-align: inherit;">And there is CGO and other and other nuances.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G - gorutins. </font><font style="vertical-align: inherit;">Well here it is clear, G must be executed on each P and scheduler monitors this.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last thing you need to know, and when does the scheduler actually call goroutine? </font><font style="vertical-align: inherit;">It's simple, usually instructions for calling are inserted by the compiler at the beginning of the body (prologue) of the function (a little later we will talk about this in more detail).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what is the problem actually?</font></font></h3><br>
<img src="https://habrastorage.org/webt/8o/fa/qt/8ofaqt_aquvkvzoskizadsuzfyw.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the beginning of the article, you already understood that the principle of the scheduler‚Äôs work has changed in GO, let‚Äôs look at the reasons why these changes were made. </font><font style="vertical-align: inherit;">Take a look at the code:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">under the spoiler</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
		<span class="hljs-keyword">for</span> {<font></font>
			u -= <span class="hljs-number">2</span>
			<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
				<span class="hljs-keyword">break</span><font></font>
			}<font></font>
		}<font></font>
	}()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>) <span class="hljs-comment">//    main   ,         </span><font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you compile it with version GO &lt;1.14, then the line ‚Äúgo 1.13 has never been here‚Äù you will not see on the screen. </font><font style="vertical-align: inherit;">This happens because, as soon as the scheduler gives processor time to the goroutine with an infinite loop, it completely captures P, no function calls occur inside this goroutine, which means we will not wake the scheduler anymore. </font><font style="vertical-align: inherit;">And only an explicit call to runtime.Gosched () will let our program terminate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is just one example where goroutine captures P and for a long time prevents other goroutines from executing on this P. More options when this behavior causes problems can be found by reading the proposal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parse proposal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution to this problem is quite simple. Let's do the same as in the OS scheduler! Just let GO run out the goroutine from P and put another one there, and for this we will use the OS tools. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, how to implement this? We will allow the runtime to send a signal to the flow on which goroutine works. We will register the processor of this signal on each stream from M, the task of the processor is to determine whether the current goroutine can be supplanted. If so, we will save its current state (registers and the state of the stack) and give resources to another one, otherwise we will continue to execute the current goroutine. It is worth noting that the concept with a signal is a solution for UNIX-base systems, while, for example, the implementation for Windows is slightly different. By the way, SIGURG was selected as a signal for sending.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most difficult part of this implementation is determining whether goroutine can be forced out. </font><font style="vertical-align: inherit;">The fact is that some places in our code should be atomic, from the point of view of the garbage collector. </font><font style="vertical-align: inherit;">We call such places unsafe-points. </font><font style="vertical-align: inherit;">If we squeeze goroutine at the moment of code execution from unsafe-point, and then GC starts up, then it will replace the state of our goroutine, taken in unsafe-point'e, and can do things. </font><font style="vertical-align: inherit;">Let's take a closer look at the safe / unsafe concept.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Did you go there, GC?</font></font></h3><br>
<img src="https://habrastorage.org/webt/yw/ao/mw/ywaomwcstazbytzl9gwewm9agy8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In versions prior to 1.12, runtime Gosched used safe-points in places where you can definitely call the scheduler without fear that we would end up in the atomic section of the code for GC. </font><font style="vertical-align: inherit;">As we have already said, safe-points data are located in the prologue of a function (but not of every function, mind you). </font><font style="vertical-align: inherit;">If you disassembled the go-shn assembler, you could object - no obvious scheduler calls are visible there. </font><font style="vertical-align: inherit;">Yes it is, but you can find the runtime.morestack call instruction there, and if you look inside this function, a scheduler call will be found. </font><font style="vertical-align: inherit;">Under the spoiler, I will hide the comment from the GO sources, or you can find the assembler for morestack yourself.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">found in source</font></font></b>
                        <div class="spoiler_text">Synchronous safe-points are implemented by overloading the stack bound check in function prologues. To preempt a goroutine at the next synchronous safe-point, the runtime poisons the goroutine's stack bound to a value that will cause the next stack bound check to fail and enter the stack growth implementation, which will detect that it was actually a preemption and redirect to preemption handling.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, when switching to a crowding-out concept, a crowding-out signal can catch our gorutin anywhere. But the GO authors decided not to leave safe-points, but declare safe-points everywhere! Well, of course, there is a catch, almost averywhere in fact. As mentioned above, there are some unsafe-points where we will not force out anyone. Let's write a simple unsafe-point.</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
j := &amp;someStruct{}<font></font>
p := unsafe.Pointer(j)<font></font>
<span class="hljs-comment">// unsafe-point start</span>
u := <span class="hljs-keyword">uintptr</span>(p)
<span class="hljs-comment">//do some stuff here</span><font></font>
p = unsafe.Pointer(u)<font></font>
<span class="hljs-comment">// unsafe-point end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand what the problem is, let's try on the skin of a garbage collector. Each time we go to work, we need to find out the root nodes (pointers on the stack and in the registers), with which we will begin marking. Since it is impossible to say in runtime whether 64 bytes in memory are a pointer or just a number, we turn to the stack and register cards (some cache with meta information), kindly provided to us by the GO compiler. The information in these maps allows us to find pointers. So, we were woken up and sent to work when GO performed line number 4. Arriving at the place and looking at the cards, we found that it was empty (and this is true, because uintptr from the point of view of GC is a number and not a pointer). Well, yesterday we heard about the allocation of memory for j, since now we can‚Äôt get to this memory - we need to clean it up, and after removing the memory we go to sleep.What's next? Well, the authorities woke up, at night, shouting, well, you yourself understood.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all with theory, I propose to consider in practice how all these signals, unsafe points and register cards and stacks work.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's move on to practice</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I double-ran (go 1.14 and go 1.13) an example from the beginning of the article by the perf profiler in order to see what system calls are happening and compare them. </font><font style="vertical-align: inherit;">The required syscall in the 14th version was found quite quickly:</font></font><br>
<br>
<pre><code class="plaintext hljs">15.652 ( 0.003 ms): main/29614 tgkill(tgid: 29613 (main), pid: 29613 (main), sig: URG                ) = 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, obviously the runtime sent SIGURG to the thread on which goroutine is spinning. </font><font style="vertical-align: inherit;">Taking this knowledge as a starting point, I went to look at the commits in GO to find where and for what reason this signal is sent, and also to find the place where the signal handler is installed. </font><font style="vertical-align: inherit;">Let's start with sending, we will find the signal sending function in runtime / os_linux.go</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">signalM</span><span class="hljs-params">(mp *m, sig <span class="hljs-keyword">int</span>)</span></span> {<font></font>
	tgkill(getpid(), <span class="hljs-keyword">int</span>(mp.procid), sig)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we find places in the runtime code, from where we send the signal:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when goroutine is suspend, if it is in a running state. </font><font style="vertical-align: inherit;">The suspend request comes from the garbage collector. </font><font style="vertical-align: inherit;">Here, perhaps, I will not add code, but it can be found in the file runtime / preempt.go (suspendG)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if the scheduler decides that goroutine is working too long, runtime / proc.go (retake)</font></font><br>
<pre><code class="go hljs">
<span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now {<font></font>
	signalM(_p_)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
forcePreemptNS - constant equal to 10ms, pd.schedwhen - time when the scheduler for the pd stream was called last time</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as well as all streams this signal is sent during a panic, StopTheWorld (GC) and a few more cases (which I have to bypass, because the size of the article will already go beyond the bounds)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We figured out how and when the runtime sends a signal to M. </font><font style="vertical-align: inherit;">Now let's find the handler for this signal and see what the stream does when it is received.</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> {
	<span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) {
		<span class="hljs-comment">// Inject a call to asyncPreempt.</span><font></font>
		ctxt.pushCall(funcPC(asyncPreempt))<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From this function it is clear that in order to ‚Äúlock in‚Äù you need to go through 2 checks:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wantAsyncPreempt - we check whether G wants to be forced out, here, for example, the validity of the current goroutine status will be checked.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint - check if it can be crowded out right now. </font><font style="vertical-align: inherit;">The most interesting of the checks here is whether G is in a safe or unsafe point. </font><font style="vertical-align: inherit;">In addition, we must be sure that the thread on which G is running is also ready to preempt G.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If both checks are passed, instructions will be called from the executable code that save state G and call the scheduler.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And more about unsafe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I propose to analyze a new example, it will illustrate another case with unsafe-point:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another endless program</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">infiniteLoop</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> {<font></font>
		u -= <span class="hljs-number">2</span>
		<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
			<span class="hljs-keyword">break</span><font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> infiniteLoop()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>)<font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 and 1.14 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you might guess, the inscription ‚Äúgo 1.13 and 1.14 never been here‚Äù we will not see in GO 1.14. </font><font style="vertical-align: inherit;">This is because we have explicitly forbidden to interrupt the infiniteLoop (go: nosplit) function. </font><font style="vertical-align: inherit;">Such a ban is implemented just using unsafe-point, which is the entire body of the function. </font><font style="vertical-align: inherit;">Let's see what the compiler generated for the infiniteLoop function.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caution Assembler</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   TEXT    <span class="hljs-string">""</span>.infiniteLoop(SB), NOSPLIT|ABIInternal, $<span class="hljs-number">0</span><span class="hljs-number">-0</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">0</span>, gclocals¬∑<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">1</span>, gclocals¬∑<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">2</span>, gclocals¬∑<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   XORL    AX, AX
        <span class="hljs-number">0x0002</span> <span class="hljs-number">00002</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">12</span>)   JMP     <span class="hljs-number">8</span>
        <span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>)   ADDQ    $<span class="hljs-number">-2</span>, AX
        <span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   CMPQ    AX, $<span class="hljs-number">3</span>
        <span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   JNE     <span class="hljs-number">4</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   RET
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the PCDATA instruction is of interest. </font><font style="vertical-align: inherit;">When the linker sees this instruction, it does not convert it to a "real" assembler. </font><font style="vertical-align: inherit;">Instead, the value of the 2nd argument with the key equal to the corresponding programm counter (the number that can be observed to the left of the function name + line) will be placed in the register or stack map (determined by the 1st argument). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we see on lines 10 and 15, we put the values ‚Äã‚Äã$ 2 and -1 in the map $ 0 and $ 1, respectively. </font><font style="vertical-align: inherit;">Let's remember this moment and take a look inside the isAsyncSafePoint function, to which I have already drawn your attention. </font><font style="vertical-align: inherit;">There we will see the following lines:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
	smi := pcdatavalue(f, _PCDATA_RegMapIndex, pc, <span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> smi == <span class="hljs-number">-2</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
	}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is in this place that we check whether goroutine is currently in the safe-point. </font><font style="vertical-align: inherit;">We turn to the map of registers (_PCDATA_RegMapIndex = 0), and passing it the current pc we check the value, if -2 then G is not in a safe-point'e, which means it cannot be crowded out.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I stopped my ‚Äúresearch‚Äù on this, I hope the article was useful for you too. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I post the promised links, but please be careful, because some of the information in these articles could be outdated. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GO scheduler - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twice</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler GO.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502494/index.html">7 mistakes of one Black Friday and how Magento Cloud works - video</a></li>
<li><a href="../en502496/index.html">Easy Web Access to LabVIEW VI PHP Applications via ActiveX Server</a></li>
<li><a href="../en502498/index.html">Best practices for improving performance in C #</a></li>
<li><a href="../en502500/index.html">The evolution of a passport scanner: from plywood crafts to real business</a></li>
<li><a href="../en502504/index.html">Surround the user digit</a></li>
<li><a href="../en502508/index.html">Trolley Robot 2.0. Part 2. Management in rviz and without. Elements of beauty in rviz</a></li>
<li><a href="../en502510/index.html">What to save in the cloud</a></li>
<li><a href="../en502512/index.html">Results of the contest of sofa experts: the rules of scientific poking</a></li>
<li><a href="../en502518/index.html">How to climb a tree</a></li>
<li><a href="../en502520/index.html">Video reports of mitap reports on product analytics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>