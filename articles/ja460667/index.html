<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏾 👃🏿 🐟 iOSでの有料サービスのテストの自動化 👈🏻 🧙🏻 🧦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="iOSでの自動化のトピックに興味がある人には、良いニュースと悪いニュースの2つがあります。良い例：有料サービス用のiOSアプリケーションでは、1つの統合ポイントのみが使用されます-アプリ内購入（アプリケーションの組み込み購入）。悪い例：Appleは、購入のテストを自動化するツールを提供していません。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>iOSでの有料サービスのテストの自動化</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/460667/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOSでの自動化のトピックに興味がある人には、良いニュースと悪いニュースの2つがあります。良い例：有料サービス用のiOSアプリケーションでは、1つの統合ポイントのみが使用されます-アプリ内購入（アプリケーションの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込み購入</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。悪い例：Appleは、購入のテストを自動化するツールを提供していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、あなたと私がAppleの善悪を超えた普遍的な自動化方法を探すことをお勧めします。この記事は、「ブラックボックス」であるサードパーティのサービスをアプリケーション（広告、ストリーミング、位置管理など）に統合するすべての人に役立ちます。通常、このような統合は、サードパーティのサービスを柔軟に構成してアプリケーションをテストする方法がないため、テストが非常に困難です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fg/if/j3/fgifj3qfcwf_98iuebxjx-fxrka.jpeg"><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の名前はビクターコロネビッチです。私はBadooのシニアテストオートメーションエンジニアです。</font><font style="vertical-align: inherit;">10年以上モバイルオートメーションに従事。</font><font style="vertical-align: inherit;">私は同僚のウラジミール・ソロドフと一緒</font><font style="vertical-align: inherit;">に、ハイゼンバグ会議で</font><font style="vertical-align: inherit;">この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">報告を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しました。</font><font style="vertical-align: inherit;">彼はまた私がこのテキストを準備するのを助けました。&nbsp;</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、</font></a><font style="vertical-align: inherit;"> Badooが70を超える支払いプロバイダーとの統合をテストするために使用する方法について説明しました。この記事では、iOSアプリケーションでの有料サービスのテストを安定的かつ安価に自動化する方法について詳しく説明します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの研究の一般的な説明から始めましょう：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定義</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューション番号1。</font><font style="vertical-align: inherit;">アップルサンドボックス</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定番号2。</font><font style="vertical-align: inherit;">関数モックメソッドと偽オブジェクトの使用</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの評価：主なリスク</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定義</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然なニーズが生じたときに自動化を行う必要があります。</font><font style="vertical-align: inherit;">この瞬間はいつ来ましたか？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Badooアプリには無料の機能がたくさんありますが、有料の機能はユーザーにより多くのオプションを提供します。</font><font style="vertical-align: inherit;">彼らは2つの方法でそれらを得ます：ローン-Badooの内部通貨-またはプレミアムサブスクリプションを購入することによって。</font><font style="vertical-align: inherit;">特定の数のクレジットについて、検索結果のプロフィールを最初に上げたり、別のユーザーにギフトを贈ったりすることができます。</font><font style="vertical-align: inherit;">プレミアムサブスクリプションは一定の期間有効で、一度にいくつかのオプションが提供されます。非表示モードをオンにする、共感を示した人を見る、投票の結果をキャンセルするなど。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの機能はBadooに徐々に登場しました。そして数年前、私たちはiOSアプリケーションの有料サービスを手動でのみテストしました。しかし、機能と新しい画面が表示されるにつれて、手動テストはますます時間がかかりました。アプリケーションの変更に対する要件は、クライアント側の開発者、サーバー側の開発者、さらにはAppleプロバイダー自体からと、さまざまな側から来ました。 1人のテスターの場合、1回のテストで約8時間かかりました。 30分以内にブランチの開発者に迅速なフィードバックを得ることができなくなり、最終的には製品の競争力に悪影響を与える可能性がありました。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト結果をできるだけ早く取得したかったのです。</font><font style="vertical-align: inherit;">そして、彼らは問題にぶつかりました：高速で安定した結果を得るために、iOSアプリケーションの有料サービスの回帰テストを安価に整理する方法は？&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最終製品の配信プロセスの詳細とチームの規模を考慮して、次のことを望みます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントアプリケーション内での購入をテストします（1回限りの支払いとサブスクリプション）。</font></font><br>
</li>
</ul><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストを1日に10〜20回繰り返します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30分未満でテスト結果を得る〜150のテストスクリプト;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノイズを取り除く。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の実行の結果に関係なく、開発者コードの特定のブランチでテストを実行できる。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクを定式化したので、エンジニアとそのソリューションの素晴らしい世界への旅を始める時が来ました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューション番号1。</font><font style="vertical-align: inherit;">アップルサンドボックス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Appleのドキュメントで有料サービスの自動テストの組織化に関する情報を探し始めました。そして、何も見つかりませんでした。自動化サポートは非​​常に貧弱に見えます。何かが表示された場合、提案されたツールを使用して自動化を設定するのは難しく（少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIAutomationと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">iOSシミュレーターの</font><font style="vertical-align: inherit;">最初の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xcrun simctl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティ</font><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">表示さ</font></a><font style="vertical-align: inherit;">れたときを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">思い出してください</font></a><font style="vertical-align: inherit;">）、オープンソースセグメントを含むエンジニアリングソリューションを探す必要があります。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有料サービスのテストに関するAppleのドキュメントでは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Apple Sandbox</font></a><font style="vertical-align: inherit;">のみを見つけることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このサンドボックスを自動化に関連付ける方法は明確ではありませんでしたが、このソリューションを真剣に研究することにしました。</font><font style="vertical-align: inherit;">Androidサンドボックスが安定していたという事実は私たちに自信を与えてくれました。</font><font style="vertical-align: inherit;">たぶん、Appleサンドボックスも同じくらい良いでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このサンドボックスを使用して自動テストを実装したとき、私たちは完全に飲みました。</font><font style="vertical-align: inherit;">主な問題について簡単に説明しましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.テストユーザーのプール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動化の主な制限は、テストユーザーのプールのコンテンツの機能になりました。これにより、自動テストの起動の独立性が保証されます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクリプション購入の自動購入を1つだけ実行するには、次のものが必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンドボックスで承認のために新しいユーザーを取得します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シミュレータで現在リンクされているApple IDを変更します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BadooアプリでBadooアプリにログイン</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクリプションの購入画面に移動し、製品を選択します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">購入を確認し、Apple ID経由でログインします。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">購入が成功したことを確認してください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Badooユーザーにクリーニングを依頼してください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクリプションからサンドボックスのユーザーをクリアします。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のテストで同じユーザーをすぐに使用しようとすると、2番目のサブスクリプションを購入することはできません。</font><font style="vertical-align: inherit;">最初のサブスクリプションが「悪くなる」まで待つか、設定でサブスクリプションを解除する必要があります。</font><font style="vertical-align: inherit;">最初の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">述べたように</font><font style="vertical-align: inherit;">、サンドボックスには特定のサブスクリプション有効期間があります。</font><font style="vertical-align: inherit;">サブスクリプションを「1か月間」購入した場合、5分間待って自動的にクローズする必要があります。</font><font style="vertical-align: inherit;">登録解除プロセス自体も高速ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、同じテストを新たに実行するには、サブスクリプションが終了するまで待つか、別の「クリーン」ユーザーを取得する必要があります。</font><font style="vertical-align: inherit;">2つのテストを互いに独立して同時に実行する場合は、プールに少なくとも2人のサンドボックスユーザーが必要です。</font><font style="vertical-align: inherit;">したがって、100のスレッドで100の自動テストを並行して実行するには、100人の異なるユーザーが必要です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2つのエージェントでセルフテスト実行を行っているとします。各エージェントは100スレッドで実行できます。</font><font style="vertical-align: inherit;">この場合、少なくとも200人のユーザーが必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.「悪い」通知</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、地獄は冗談ではありません！ユーザープールを編成し、テストの実行方法を監視し始めました。彼らは道に沿って落ちましたが、ほとんど-私たちには未知の新しい理由のために。サンドボックスで承認、購入、ユーザーとしての作業を行うと、App Storeがアラートを送信することを理解し始めました。たとえば、新しいユーザー名とパスワードを要求し、「OK」ボタンをクリックして承認を確認し、「OK」ボタンで内部エラーに関する情報を提供します。時々現れたり、現れなかったりします。そして、それらが表示された場合、常に異なる順序で表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sq/tu/1j/sqtu1ja-altpboz3pcudwnz8flm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑わしいエラーが自動テストで単に無視される可能性はありますか？</font><font style="vertical-align: inherit;">そして、もし本当のミスがやって来たら、どうすればいいですか？</font><font style="vertical-align: inherit;">この領域は自動的に「ブラインドゾーン」になり、App Storeから届く可能性のあるすべてのアラートに対して特別なハンドラーを作成する必要がありました。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべてがテストを遅くしました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アラートがテストシナリオのさまざまなステップに到達し、テストの主な概念を破壊する可能性があります-予測可能なテストシナリオ; </font><font style="vertical-align: inherit;">一連の既知の無視されたアラートが表示される可能性があることを期待するエラーハンドラを追加する必要がありました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時々、アラートの新しいバリエーションが到着したり、他のエラーが発生したりしたため、フォールテストを再開する必要がありました。</font><font style="vertical-align: inherit;">これにより、すべてのテストの実行時間が増加しました。</font></font><br>
</li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.テストはありましたか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、プール内のユーザーはブロックされ、n分間クリアされます。</font><font style="vertical-align: inherit;">テストは120スレッドで実行され、プールには既にかなりの数のユーザーがいますが、これでは十分ではありません。</font><font style="vertical-align: inherit;">ユーザー管理システムを作成し、アラートハンドラーを作成した後、ITが発生しました。</font><font style="vertical-align: inherit;">サンドボックスは、テストユーザーが数日間利用できなくなりました。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もこれを期待していませんでした。</font><font style="vertical-align: inherit;">そして、これが我が忍耐の聖杯の最後のわらであり、ついにアップルサンドボックスへの愛を殺し、善と悪の向こう側への道に乗り出しました。</font><font style="vertical-align: inherit;">そのような自動化は必要ないこと、そしてこの危険な決定でもう苦しむことを望まないことに気づきました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定番号2。</font><font style="vertical-align: inherit;">関数モックメソッドと偽オブジェクトの使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、Appleのサンドボックスでの自動化の問題を飲みました。しかし、モバイルの世界ではすべてが完全に悪いとは思わないでください。 Androidでは、サンドボックスの方がはるかに安定しています。そこでオートテストを実行できます。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOS用の別のソリューションを見つけてみましょう。しかし、どのように見ますか？どこを見ますか？テストとソフトウェア開発の歴史を見てみましょう：Appleのクレイジーな世界はどうなりましたか？自動化とソフトウェア開発の世界でたくさんの本を書き、権威を得た人々は何と言っていますか？&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gerard Mesarocheが書いた「xUnit Test Patterns：Refactoring Test Code」という作品をすぐに思い出しました（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">review</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Martin Fowler）--私の意見では、少なくとも1つの高水準プログラミング言語を知っており、自動化を望んでいるテスターに​​とって最高の本の1つです。</font><font style="vertical-align: inherit;">この本のいくつかの章は、アプリケーションの他のコンポーネント（私たちの「ブラックボックス」）から切り離してSUTをテストすることに専念しています。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.モカと偽物の紹介</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テストの世界では、テストダブル、テストスタブ、テストスパイ、モックオブジェクト、フェイクオブジェクト、ダミーオブジェクトの概念の間に一般に認められた境界はありません。</font><font style="vertical-align: inherit;">常に著者の用語を考慮する必要があります。</font><font style="vertical-align: inherit;">テストダブルの大きな世界からの2つの概念、モック関数と偽のオブジェクトだけが必要です。</font><font style="vertical-align: inherit;">それは何ですか？</font><font style="vertical-align: inherit;">そして、なぜこれが必要なのでしょうか？</font><font style="vertical-align: inherit;">これらの概念を簡単に定義して、意見の相違がないようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションとそれに組み込まれたコンポーネントがあるとします。これは私たちにとって「ブラックボックス」です。アプリケーション内で、このコンポーネントにアクセスして関数を呼び出し、これらの関数の結果を取得できます。結果に応じて、アプリケーションは特定の方法で反応します。関数実行の結果は、実際のユーザーデータを反映する一連のフィールドを持つエンティティ全体になる場合があります。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目的の結果を返す他の関数の代わりに、関数のモック、または単にモックを呼び出しましょう。これらの関数は同じシグネチャを持つ場合がありますが、これらは2つの異なる関数です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、関数の結果として得られたエンティティの置換（フィールドに必要なデータが含まれ、場合によっては破損したデータも含まれる）は、偽のオブジェクトの実装と呼ばれます。</font><font style="vertical-align: inherit;">これについては、上記の本や、テストおよびソフトウェア開発に関するその他の概要で詳しく読むことができます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを完了するために、モック関数と偽のオブジェクトを使用するいくつかの機能を強調しましょう：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数をウェットにするには、ソースコードにアクセスし、アプリケーションがコンポーネントを内部から開発者レベルでどのように処理するかを知る必要があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽のオブジェクトを実装するには、実際のオブジェクトの構造を知る必要があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モック機能を使用すると、コンポーネントを使用してアプリケーションを柔軟に構成できます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽のオブジェクトを使用すると、エンティティに任意のプロパティを付与できます。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mokiおよびfakeオブジェクトメソッドは、アプリケーション内のコンポーネントの操作を分離するのに理想的です。</font><font style="vertical-align: inherit;">App Storeがコンポーネントになる問題を解決するために、この方法をどのように適用できるかを見てみましょう。</font><font style="vertical-align: inherit;">この方法を使用する特殊性のため、最初にコンポーネントを使用したアプリケーションの作業の性質を調査し、次に特定のmokeyと偽のオブジェクトを作成するための技術的な実装に移る必要があります。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.実際の購入はどのように行われますか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムのすべての部分の相互作用について説明する前に、主な俳優を強調しておきましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションユーザー-アプリケーションでアクションを実行する任意のアクター。人である場合もあれば、必要な指示を実行するスクリプトがある場合もあります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション（この場合、iOSシミュレーターにインストールされているBadoo iOSアプリケーションを使用します）;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー-アプリケーションからの要求を処理し、クライアント要求なしで応答または非同期通知を送信するアクター（この場合、構造を単純化するための1つの抽象的なBadooサーバーを意味します）;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App Storeは、私たちにとって「ブラックボックス」である俳優です。内部でどのように配置されているかはわかりませんが、アプリケーション内で購入を処理するためのパブリックインターフェイス（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StoreKitフレームワーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を知っており、Appleサーバーでデータを確認する方法も知っています。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
購入がどのように行われるかを見てみましょう。</font><font style="vertical-align: inherit;">プロセス全体を図で見ることができます：&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/1l/tg/kw1ltgj7slrlftse7zykm-hrlec.png" width="600"></div><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1. App Storeでの支払いスキーム。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アクターの主なアクションを段階的に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.開始点は、製品のリストが表示された画面を開く前のすべての俳優の状態です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この画面とは何ですか？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが興味深い人物を見つけ、自分のプロフィールを開き、メッセージを1つ書き込んで、ギフトを送信したいとします。贈り物は有料サービスです。ユーザーはプロフィールをスクロールしてギフトを送信するセクションに移動するか、チャットからギフトをすぐに選択できます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーがギフトを選択し、アカウントにお金がない場合は、購入用のさまざまなローンのパッケージ（Payments Wizard）のリストが表示されます。この例の出発点は、贈り物のリストです。図では、ローンまたはサブスクリプションの購入用の製品のリストを表示する前に、どのような画面でもこのような点を考慮することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.製品のリストを開きます。&nbsp;</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hn/9y/e-/hn9ye-ipwd_pblpxfgbawcpebok.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、例えばギフトリストの出発点にいます。</font><font style="vertical-align: inherit;">ユーザーはアプリケーションでギフトの1つを選択します。</font><font style="vertical-align: inherit;">アプリケーションはサーバーにリクエストを送信して、可能な商品IDローンパッケージ（100、550、2000、5000）のリストを取得します。</font><font style="vertical-align: inherit;">サーバーはこのリストをアプリケーションに返します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アプリケーションは受け取った製品IDリストを検証のためにApp Storeアクター（Appleサーバーに送信されるStoreKit iOSシステムフレームワーク）に送信します。</font><font style="vertical-align: inherit;">これは、実績のある製品のリストを返します-その結果、アプリケーションは、アイコンと価格を含むローンパッケージの最終リストをユーザーに表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.製品の選択とレシートの生成。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/3j/jd/ua3jjdi5ifqqc0n6fiaqmg3elvq.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーは有料の製品を選択します。 App Storeには、購入証明とApple IDによる認証が必要です。ユーザー認証が成功すると、制御がアプリケーションに移ります。アプリケーションは、独自のパッケージ内でレシートが生成されるのを待っています。この時点でユーザーは太陽を見ているため、画面がロックされています。生成されたレシートは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bundle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスのappStoreReceiptURLメソッドを使用して理解できます</font><font style="vertical-align: inherit;">。 App Storeによってチェックが生成された後、アプリケーションはパッケージからチェックを選択し、チェックとユーザーデータを含むリクエストをBadooサーバーに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Badooサーバーのチェックをチェックします。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/4l/ag/qw4laggdbnz4zswxh-b6eopdk-y.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Badooサーバーはチェックとユーザーデータを受け取るとすぐに、それらをAppleサーバー側に送り返し、最初の検証サイクルを実行します。</font><font style="vertical-align: inherit;">これはAppleの推奨事項の1つです。</font><font style="vertical-align: inherit;">次に、この最初の検証サイクルで、サーバーはサブスクリプションの現在のステータスに関する情報を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.サーバーからプッシュ通知（プッシュ通知）を送信します。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/ne/ou/yqneoujlb2271__24hinousfjz8.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Badooサーバーは、Appleによる検証後、受信した情報を再度処理し、プッシュ通知と共に応答をアプリケーションに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6.アプリケーションでプッシュ通知。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/mx/vq/mwmxvqn6zutjpg45rmcq6tibudc.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それがローンの購入だった場合、すぐにアプリケーションのユーザーの残高が変更され、送信されたギフトがチャットに表示されます。</font><font style="vertical-align: inherit;">これがサブスクリプションの購入であった場合、ユーザーはサブスクリプションがアクティブ化されたことを示す最後のプッシュ通知を待つ必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.依存関係とテストループの決定</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細については、外部依存とテスト回路という2つの概念を紹介します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部依存</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部依存関係とは、コンポーネントとの相互作用を意味します。これは、私たちにとって「ブラックボックス」です。</font><font style="vertical-align: inherit;">この場合、App Storeは、iOSシステムフレームワーク（StoreKit）の形式のコンポーネントとして機能します。これにより、iOSアプリケーションが動作し、検証要求が送信されるAppleサーバーが動作します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの依存関係を実際の状況で管理することは不可能であり、アプリケーションはブラックボックスからの出力信号に応答する必要があります（図2を参照）。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つの外部依存関係があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StoreKit製品の確認。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">購入領収書を受け取り、交換する。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Badooサーバーでチェックをチェックする。</font></font><br>
</li>
</ol><br>
<img src="https://habrastorage.org/webt/ix/dd/mr/ixddmrcv7pwgene4fw12269cfeg.jpeg"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2.外部依存関係</font></font></font></i>&nbsp;<br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試験回路</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト回路-これらは、テストプロセス中に確認および確認するパスのセクションです。&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/webt/26/m3/_u/26m3_uxzsdcrewtozcmgqihwbyu.jpeg"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3.テストループ</font></font></font></i>&nbsp;<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
依存関係の削除に関する私たちの作業の目標は、実際のパスにできる限り近いテストループを構築し、すべての外部依存関係を除外して、制御をユーザーの側に移すことです。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各依存関係を順番に検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.依存関係の分離：技術的な実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弊社では、支払いの実装のために、支払いプロバイダーのインターフェースに基づくPPPの概念が採用されました。</font><font style="vertical-align: inherit;">これは、アプリケーション内のApp Storeアクター（StoreKit）と対話するためのメインインターフェイスであり、2つのメインメソッドがあります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備は、製品のチェックを担当する方法です。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">makePaymentは、アプリ内購入を処理するメソッドです。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSでのすべての支払いはこの概念に従ってリファクタリングされたため、シンプルで便利なクラスのモック支払いプロバイダーを取得できました。</font><font style="vertical-align: inherit;">これは、アプリケーション内のStoreKit動作の便利なコピーと対話するためのメインインターフェースです。</font><font style="vertical-align: inherit;">「便利なコピー」とはどういう意味ですか？</font><font style="vertical-align: inherit;">このプロバイダーには、私たちが望むことを行うprepareメソッドとmakePaymentメソッドのモックがあります。</font><font style="vertical-align: inherit;">コードの例、mokiの統合方法を見てみましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存No.1 </font><font style="vertical-align: inherit;">StoreKit製品の確認</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
製品のリストを確認するには、チェックされた製品のリストを返すprepare関数を使用します。チェックをオフにし、完全に検証された製品の受信リストを返すモックを使用できます。したがって、依存関係は解消されます。&nbsp; </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/nd/xj/nrndxjbquf5uuddom1zw4pcwkky.jpeg"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4.最初の依存関係を排除するためのスキーム</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アプリケーションのアーキテクチャーの最上部にあるのが決済プロバイダーです。これは、アプリケーションで使用可能なプロバイダーのインターフェースを反映しています。 mokを実装するためのコードは、Mock Payment Providerクラスにあります。&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPaymentProvider</span>: <span class="hljs-title">PaymentProvider</span> </span>{
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> receipt: <span class="hljs-type">String?</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> storeKitTransactionID: <span class="hljs-type">String?</span><font></font>
<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepare</span><span class="hljs-params">(products: [BMProduct])</span></span> -&gt; [<span class="hljs-type">BMProduct</span>] {
      <span class="hljs-keyword">return</span> products<font></font>
   }<font></font>
   ...<font></font>
}<font></font>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト1.モッククライアントのチェック</font></font></font></i>&nbsp;<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
モック決済プロバイダーで、prepareメソッドの実装を確認できます。</font><font style="vertical-align: inherit;">mochaの魔法は非常に単純であることが判明しました。このメソッドはStoreKit側での製品のチェックをスキップし、単純に製品の着信リストを返します。</font><font style="vertical-align: inherit;">prepareの実際の実装は次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepare</span><span class="hljs-params">(products: [BMProduct])</span></span> -&gt; [<span class="hljs-type">BMProduct</span>] {
   <span class="hljs-keyword">let</span> validatedProducts = <span class="hljs-keyword">self</span>.productsSource.validate(products: products)
   <span class="hljs-keyword">return</span> validatedProducts<font></font>
}<font></font>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト2.実店舗決済プロバイダー</font></font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存番号2。</font><font style="vertical-align: inherit;">購入領収書を受け取って交換する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の中毒はもう少し複雑です。ユーザーアカウントのプールを保持しないように、最初に承認を削除してから、何らかの形でチェック自体を取得する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ir/zr/ak/irzrakxn_kx2ylzcdaudvux5pv4.jpeg"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">承認フォーム</font></font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は簡単に削除でき</font><i><font color="gray"><font style="vertical-align: inherit;">ます。図5.支払い時に承認フォームを削除</font></font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
するチェックを使用すると、すべてがそれほど単純ではありません。</font><font style="vertical-align: inherit;">多くの質問があります：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切な製品のレシートを事前に取得するにはどうすればよいですか？</font></font><br>
</li>
<li>     ,        ?<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、俳優「ユーザー」は新しい役割-QAを持っています。テストを実行するとき、インターフェイスのボタンをクリックするだけでなく、テストフレームワークのAPIメソッド（ユーザーアクションをシミュレートするメソッド）とREST APIサービス（内部のBadooサービスから魔法をかけることができるメソッド）を呼び出すこともできます。 Badooには非常に強力なQA APIツールがあります（その機能はすべて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vimeo.com/116931200にあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。テストで私たちを助け、Badooのサーバー側で目的の製品をチェックするのは彼です。 Badooサーバーはチェックを生成するのに最適な場所です。チェックには暗号化と復号化があるため、サーバーはこのデータ構造に関するすべてを知っています。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
偽の小切手を受け取ったら、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">バックドア</font></a><font style="vertical-align: inherit;">に通すことができます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション側。</font><font style="vertical-align: inherit;">次に、アプリケーションはユーザーデータと共に偽のチェックをサーバーに送信します。&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uu/h5/03/uuh503gnoqehjqguhzjhydujvs8.jpeg"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図6.レシート受領のスキーム</font></font></font></i>&nbsp;<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これはどのようにして技術的に可能になったのですか？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.アプリケーションで偽のチェックを設定するために、レシートのMockPaymentProviderフィールドに偽のチェックを保存するバックドアを使用することができました。</font></font><br>
<br>
<pre><code class="swift hljs">#<span class="hljs-keyword">if</span> <span class="hljs-type">BUILD_FOR_AUTOMATION</span><font></font>
<font></font>
<span class="hljs-meta">@objc</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BadooAppDelegate</span> </span>{<font></font>
    <font></font>
   <span class="hljs-meta">@objc</span>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setMockPurchaseReceipt</span><span class="hljs-params">(<span class="hljs-number">_</span> receipt: String?)</span></span> {
      <span class="hljs-type">PaymentProvidersFactory</span>.useMockPaymentProviderForITunesPayments = <span class="hljs-literal">true</span>
      <span class="hljs-type">MockPaymentProvider</span>.receipt = receipt<font></font>
   }<font></font>
   ...<font></font>
}<font></font>
<font></font>
#endif</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト3.偽のチェックバックドア</font></font></font></i>&nbsp;<br>
&nbsp;<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2.アプリケーションはMockPaymentProviderのおかげで小切手を受け取ることができました。ここでは、makePaymentモックとMockPaymentProvider.receiptに保存された小切手を使用しました。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPaymentProvider</span>: <span class="hljs-title">PaymentProvider</span> </span>{<font></font>
   ...<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makePayment</span><span class="hljs-params">(<span class="hljs-number">_</span> transaction: BPDPaymentTransactionContext)</span></span> {<font></font>
      ...<font></font>
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> receiptData = <span class="hljs-type">MockPaymentProvider</span>.receipt?.data(using: .utf8) {
         <span class="hljs-keyword">let</span> request = <span class="hljs-type">BPDPurchaseReceiptRequest</span>(...)
         <span class="hljs-keyword">self</span>.networkService.send(request, completion: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (<span class="hljs-number">_</span>) <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> sSelf = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> receipt = request.responsePayload() {<font></font>
               sSelf.delegate?.paymentProvider(sSelf, didReceiveReceipt: receipt)<font></font>
            }<font></font>
         })<font></font>
      } <span class="hljs-keyword">else</span> {
         <span class="hljs-keyword">self</span>.delegate?.paymentProvider(<span class="hljs-keyword">self</span>, didFailTransaction: transaction)<font></font>
      }<font></font>
   }<font></font>
}</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト4.</font></font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
偽のチェックを使用し</font><i><font color="gray"><font style="vertical-align: inherit;">て購入処理mokaを呼び出す</font></font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
3.偽のチェック</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取得する偽のチェックを取得するために、サーバーでメソッドを使用しました（リスト5を参照）。</font><font style="vertical-align: inherit;">チェックデータを生成するデータを含むデフォルトの配列を取得し、特定の製品に必要なデータを追加します。</font></font><br>
<br>
<pre><code class="php hljs">$new_receipt_model = array_replace_recursive(
   <span class="hljs-comment">//      </span>
   <span class="hljs-keyword">$this</span>-&gt;getDefaultModel(),<font></font>
     <font></font>
   <span class="hljs-comment">//      </span>
   <span class="hljs-comment">//,     </span>
   <span class="hljs-keyword">$this</span>-&gt;enrichModelUsingSubscription($nr),<font></font>
     <font></font>
   <span class="hljs-comment">//       </span>
   <span class="hljs-keyword">$this</span>-&gt;enrichModelUsingInput($input)<font></font>
);<font></font>
<font></font>
<span class="hljs-comment">// </span>
$new_receipt = <span class="hljs-keyword">$this</span>-&gt;signReceipt(<font></font>
   json_encode($new_receipt_model, <span class="hljs-literal">true</span>),<font></font>
   $new_receipt_model<font></font>
);<font></font>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト5.チェック生成のサーバー部分</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
実際のチェックの構造を繰り返すには、アプリケーションから送信されるカスタムチェックを、証明書を使用して暗号化する必要があります。</font><font style="vertical-align: inherit;">Apple証明書の代わりに仕事用証明書を使用します。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">signReceipt</span>(<span class="hljs-params">$receipt, $response</span>)  </span>{
   <span class="hljs-comment">//     base64</span> 
   $receipt = <span class="hljs-string">'Subject: '</span> . base64_encode(json_encode($response)) . PHP_EOL .  PHP_EOL . $receipt; <font></font>
   file_put_contents($receipt_file, $receipt);<font></font>
   ...<font></font>
   <font></font>
   <span class="hljs-comment">//   </span>
   $sign_result = openssl_pkcs7_sign( $receipt_file, $signed_receipt_file, <span class="hljs-string">'file://'</span>.$path_cert, <span class="hljs-string">'file://'</span>.$path_key, [], PKCS7_BINARY); <font></font>
   ... <font></font>
   <font></font>
   <span class="hljs-comment">// </span> <font></font>
   $signed_content_with_headers = file_get_contents($signed_receipt_file); <font></font>
   <span class="hljs-keyword">list</span>($headers, $signed_content) = explode(PHP_EOL . PHP_EOL, $signed_content_with_headers);     <font></font>
   <font></font>
   <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">return</span> str_replace([<span class="hljs-string">"\r\n"</span>, <span class="hljs-string">"\r"</span>, <span class="hljs-string">"\n"</span>], <span class="hljs-string">''</span>, $signed_content);<font></font>
 }<font></font>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト6.証明書を使用して小切手に署名する方法</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
4.結果として、テストでは次のようになります。</font></font><br>
<br>
<pre><code class="ruby hljs">(<span class="hljs-regexp">/       "((\d+) |  (\d+) ?/</span>) <span class="hljs-keyword">do</span> <span class="hljs-params">|service_type|</span>
  <span class="hljs-comment">#   </span><font></font>
  service_details = parse_options(service_type)<font></font>
<font></font>
  <span class="hljs-comment">#  QA API (  Badoo)</span><font></font>
  receipt = QaApi::Billing.order_get_app_store_receipt(service_details)<font></font>
<font></font>
  <span class="hljs-comment">#  </span><font></font>
  Backdoors.set_fake_receipt(receipt)<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト7. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Cucumber</font></a><font style="vertical-align: inherit;">フレームワークの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガーキン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ステップ</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a>&nbsp;</font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存No.3 </font><font style="vertical-align: inherit;">Badooサーバーでチェックをチェックする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の依存関係を削除するには、サーバー上のチェック検証を取り除く必要があります。検証は2つの段階で行われることを覚えておくことが重要です。最初の段階では、チェックは署名と証明書に基づいて認証されます。 2番目に-小切手はApp Storeに送信されます。この段階で検証が成功した場合は、処理可能な復号化された小切手を受け取ります。&nbsp;&nbsp; </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pd/9g/p_/pd9gp_uz1kjnsb9rsk9weczdngw.jpeg"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7.サーバー検証の削除</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、サーバーは親クラスのverifyReceiptByCertメソッドでチェックの初期検証を実行します。ここでは、署名はApp Store証明書によって検証されます。偽のチェックの場合、この検証は証明書によって署名されているため失敗し、ローカル証明書verifyReceiptByLocalCertを使用して検証メソッドを呼び出します。このメソッドでは、ローカル証明書を使用してチェックの復号化を試み、成功した場合は、復号化の結果を子クラスのlocal_receipt内部フィールドに配置します（addLocallyVerifiedReceiptメソッド）。</font></font><br>
<br>
<pre><code class="php hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Engine</span> 
   <span class="hljs-title">function</span> <span class="hljs-title">verifyReceiptByCert</span>($<span class="hljs-title">receipt</span>)  </span>{<font></font>
      $result = <span class="hljs-built_in">parent</span>::verifyReceiptByCert($receipt); 
      <span class="hljs-keyword">if</span> ($result === <span class="hljs-number">-1</span> || <span class="hljs-keyword">empty</span>($result)) {<font></font>
         $result = <span class="hljs-keyword">$this</span>-&gt;verifyReceiptByLocalCert($receipt); <font></font>
      } <font></font>
      <span class="hljs-keyword">return</span> $result;<font></font>
    }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">verifyReceiptByLocalCert</span>(<span class="hljs-params">$receipt</span>) </span>{<font></font>
      $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string">'rcp'</span>);<font></font>
      file_put_contents($receipt_file, base64_decode($receipt));<font></font>
      $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string">'/dev/null'</span>, [$DIR]);
      <span class="hljs-keyword">if</span> ($result) {
         <span class="hljs-keyword">$this</span>-&gt;addLocallyVerifiedReceipt($receipt, base64_decode($response));<font></font>
      }<font></font>
      unlink($receipt_file);<font></font>
      <span class="hljs-keyword">return</span> $result;<font></font>
   }<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> 
   <span class="hljs-title">function</span> <span class="hljs-title">verifyReceiptByCert</span>($<span class="hljs-title">receipt</span>) </span>{<font></font>
      $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string">'rcp'</span>);<font></font>
      file_put_contents($receipt_file, base64_decode($receipt));<font></font>
      $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string">'/dev/null'</span>, [$DIR]);<font></font>
      unlink($receipt_file);<font></font>
      <span class="hljs-keyword">return</span> $result;<font></font>
   }<font></font>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト8. 1次検証</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2次検証（verifyReceipt）中に、getLocallyVerifiedReceipt子クラスのlocal_receiptフィールドの値を取得します。</font><font style="vertical-align: inherit;">空でない場合は、検証の結果としてその値を使用します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールドが空の場合、親クラス（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :: verifyReceipt）</font><font style="vertical-align: inherit;">から2次検証を呼び出します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そこで、App Storeに確認のためのリクエストを出します。</font><font style="vertical-align: inherit;">どちらの場合も、検証結果は復号化されたチェックです。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Engine</span>
   <span class="hljs-title">function</span> <span class="hljs-title">verifyReceipt</span>($<span class="hljs-title">receipt_encoded</span>, $<span class="hljs-title">shared_secret</span>, $<span class="hljs-title">env</span>) </span>{<font></font>
      $response = <span class="hljs-keyword">$this</span>-&gt;getLocallyVerifiedReceipt($receipt_encoded);
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>($response)) {
          <span class="hljs-keyword">return</span> json_decode($response, <span class="hljs-literal">true</span>);<font></font>
      }<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parent</span>::verifyReceipt($receipt_encoded, $shared_secret, $env);<font></font>
   }<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span>
   <span class="hljs-title">function</span> <span class="hljs-title">verifyReceipt</span>($<span class="hljs-title">receipt_encoded</span>, $<span class="hljs-title">shared_secret</span>, $<span class="hljs-title">env</span>) </span>{<font></font>
      $response = <span class="hljs-keyword">$this</span>-&gt;_sendRequest($receipt_encoded, $shared_secret, $env);
      <span class="hljs-keyword">return</span> $response;<font></font>
   }</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト9.二次検証</font></font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.ビデオのテスト実行：ローンとサブスクリプションの購入</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト番号1。</font><font style="vertical-align: inherit;">定期購入</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつ</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真で新しいユーザーとしてアプリケーションにログインしています</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい1か月のサブスクリプション請求チェックを生成します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のプロフィールに行きます</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクリプションが無効になっていることを確認します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつ</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">商品一覧を開く</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1か月のサブスクリプションパッケージを購入します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">購入成功通知を確認します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクリプションがアクティブになっていることを確認します</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト実行ビデオ： </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xc/ut/ag/xcutagbl8qmu9wzgva0zop2xqg0.gif"><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト番号2。</font><font style="vertical-align: inherit;">ローンの購入と贈り物</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつ</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真で新しいユーザーとしてアプリケーションにログインしています</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロフィールに10クレジットを追加します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">550クレジットの新しい信用調査を生成します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいユーザーLeelaを作成します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーラが「はい」と投票しました</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">People Peopleに移動し、Leelaプロファイルを開きます</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はリーラに「はい」と投票します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試合ページをチェック</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつ</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期的な贈り物を選ぶ</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">荷物の一覧でお支払い画面を確認&nbsp;</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつ</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">550クレジットを購入することにしました</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">購入成功通知を確認します</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーラがチャットギフトを受け取ったことを確認します</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト実行ビデオ：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jb/dl/oj/jbdlojncgj656usnr5bsylaese4.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの評価：主なリスク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部依存関係を削除すると、特定のリスクが伴います。</font></font><br>
&nbsp;<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.構成が正しくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検証は弊社側ではないため、アップル側で製品を誤って設定する場合があります。エラーから保護するために、Apple側で実行するすべての製品が構成内にある製品と一致することを確認する別のサーバー側ユニットテストを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.ボーダーラインケース。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、支払いが完全に完了すると、ユーザーは完了したという通知を受け取りますが、このアプリケーションでは、この支払いを行った結果として偽造されるべき小切手を見つけることができません。私たち自身がバックドアの助けを借りて小切手を取り付けるというリスクがあり、そのようなケースを当然追跡することはできません。このリスクを何らかの形で補償するために、リリース後はサンドボックスまたは実際の支払いを使用してエンドツーエンドのチェックを実施します。</font></font><br>
&nbsp;<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.不当な偽物または詐欺。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を読んだ後、Badooは偽のチェックを使用しているため、偽物を添付して無料でサービスを使用できると思うかもしれません。このリスクが発生しないように、すべてに独自の証明書で署名し、モックと偽のチェックの使用を、開発環境でのみ実行される機能テストに制限します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.チェックの形式を変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが最も深刻なリスクです。 Appleが警告せずに何かを変更した場合、チェック形式の変更が可能です。そのようなケースがありました。iOS11に切り替えると、チェックの形式が完全に変更されました。サーバーで偽のチェックを生成し、テストで使用しました。すべてが順調で、すべてのフィールドが整っており、すべてが素晴らしく、すべてが処理されています。しかし、実際のシステムに切り替えたとき、何も機能しませんでした。チェックで重要なフィールドは存在しなくなりました。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリスクを補う方法は？</font><font style="vertical-align: inherit;">まず、リリース前のサンドボックスのエンドツーエンドのテストとリリース後の実際の支払いを除外しません。</font><font style="vertical-align: inherit;">現在、通知をチェックするプロジェクトのアクティブな段階にあります。生産について受け取ったすべてのチェックを、それが何であるかを理解しているかどうかに基づいて分類しようとするときです。</font><font style="vertical-align: inherit;">答えが「いいえ」の場合、すべてを手動で処理し始め、変更点、問題点、システムで変更が必要な点を確認します。&nbsp;</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">危険</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原因</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補償する方法</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間違った設定</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックを削除</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーでの単体テスト</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エッジケース</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（小切手は配達されません）</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックドアを使用する</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E2Eチェック（サンドボックスと実際の支払い）</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不正な偽物、詐欺</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーでの通知とチェックの生成</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自身の証明書</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェック形式を変更する</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーでの通知とチェックの生成</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の通知の検証と製品のチェック（新しいプロジェクト）、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E2Eチェック（サンドボックスと実際の支払い）</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mokiメソッドと偽のオブジェクトを使用した結果として得られた主な利点を検討してください。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOS上の有料サービスの安価で高速かつ安定した自動化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSの手動テストチーム（特にColin Chanのおかげ）と合わせて、支払いに対して150以上の自動テストを作成することができました。これは、アプリケーションの1つの領域をカバーするかなりの量です。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列化のおかげで、iOSクライアント開発者または課金サーバー開発者のどのブランチでも15〜20分で結果を得ることができます。自動化する前は、この領域を1人で手動でテストするのに8時間かかりました。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、モキを通じて必要な方法でモック決済プロバイダーをセットアップすることにより、テストケースの大部分をテストできます。 mokiの助けを借りて、製品チェックをオフにし、チェックが部分的に実行された場合のケースをシミュレートする方法を学びました。そのため、以前は原則としてテストできなかったケースをオープンしました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新機能の開発における機能回帰</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい機能に取り組んでいる開発者が古い機能に影響を与えた場合、自動化は非常にうまく機能しました。</font><font style="vertical-align: inherit;">開発者がキャッシングで複雑な機能を実行し、自動テストを実行した例がありました。</font><font style="vertical-align: inherit;">それらのいくつかは誤って落ちた。</font><font style="vertical-align: inherit;">彼はそれを見て修正しました。</font><font style="vertical-align: inherit;">それから彼は自動テストを再開しました-そして再び、何かが落ちました。</font><font style="vertical-align: inherit;">その結果、すべてがアプリケーション側で正常に機能し始めるまで、一連の繰り返しを行いました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支払いリファクタリングの機能回帰</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、唯一可能な唯一の最も成功した効率的な自動化は、コードのリファクタリングの分野で正確に発生します。</font><font style="vertical-align: inherit;">この場合、内部実装のみが変更されます。自動テストコードを変更する必要はありません。</font><font style="vertical-align: inherit;">UIはまったく変更されず、自動テストを効率的に実行できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appleの実験的機能のテスト：猶予期間</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンドボックスにまだ実装されていない新しい統合をテストする場合、同様のシステムは完全に交換可能です。</font><font style="vertical-align: inherit;">つまり、猶予期間がありました。</font><font style="vertical-align: inherit;">この機能はサンドボックスにはありません。</font><font style="vertical-align: inherit;">Appleの猶予期間はまだ誰もが利用できるわけではありません。</font><font style="vertical-align: inherit;">これは、BadooがAppleと実装しているパイロットプロジェクトです。</font><font style="vertical-align: inherit;">猶予期間で確認するために、そのようなJSONコードを追加する必要がありました。</font></font><br>
<br>
<pre><code class="json hljs">pending_renewal_info:[<font></font>
{<font></font>
      expiration_intent: <span class="hljs-number">2</span>
      grace_period_expires_date: <span class="hljs-number">2019</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">57</span> Etc/GMT<font></font>
      auto_renew_product_id: badoo.productId<font></font>
      original_transaction_id: <span class="hljs-number">560000361869085</span>
      is_in_billing_retry_period: <span class="hljs-number">1</span>
      grace_period_expires_date_pst: <span class="hljs-number">2019</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">08</span>:<span class="hljs-number">50</span>:<span class="hljs-number">57</span> America/Los_Angeles<font></font>
      product_id: badoo.productId<font></font>
      grace_period_expires_date_ms: <span class="hljs-number">1556207457000</span>
      auto_renew_status: <span class="hljs-number">1</span><font></font>
}]<font></font>
</code></pre><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト10.サブスクリプションの猶予期間</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これを数秒で非常に簡単に実行しました。</font><font style="vertical-align: inherit;">私たちのシステムでは、新しい機能に対する反応をテストすることができました。</font><font style="vertical-align: inherit;">現在、この機能を製品で実行しています。&nbsp;</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合成方法での製品品質のテスト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査の結果、外部依存からのノイズを除去する方法を説明することができました。</font><font style="vertical-align: inherit;">これは、機能開発の過程でクライアント開発者が初期段階でバグを発見するのに役立ちました。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この方法ですべてをテストできたとは思わないでください。</font><font style="vertical-align: inherit;">すべてをテストするには、メソッドの組み合わせを使用することをお勧めします。製品の実際のカードでテストする、サンドボックスでテストする、モークと偽のオブジェクトのメソッド、ユニットテストと統合テスト。</font><font style="vertical-align: inherit;">テストピラミッドのバランスを思い出してください。1つの方法ですべての問題を解決しようとしないでください。</font><font style="vertical-align: inherit;">これは、サンドボックスでの悲しい自動化、すべてのケースの実際のカードを使用した悲しい手動テスト、および外観が最も痛む場所でのその他の多くの重大なエラーにつながる可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査の結果、iOSの有料サービスだけでなく、「ブラックボックス」としてアプリケーションに組み込まれているコンポーネントもテストする、安価で高速かつ安定した方法が得られました。現在Badooでは、不安定なサンドボックスやその他の制限があるAndroid有料プロバイダー（Global Charge、Boku、Centili）でテストするためにこのメソッドを実装しています。また、広告、ストリーミング、ジオロケーションのテストにもmokiメソッドを使用しています。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい方法を導入するプロセスが速くなかったことは言うまでもありません。私は、iOS QA、iOS Dev、Billing QA、Billing Devの4つのチームと交渉する必要がありました。誰もがリスクを恐れて、新しい方法に切り替えたいと思ったわけではありません。時にはそれは独断的な追随だった：私たちが長年にわたってサンドボックスでテストし、ドグマを破壊する可能性のある主な力は、課金のテスターと状況を変えて苦痛を取り除くためのiOSプラットフォームの欲望でした。その後、開発者はこの方法の利点を正確な診断（サンドボックスでバグを見つけることができなかったが、クライアントまたはサーバーのバグを見つけることができた）、コンポーネントを構成する柔軟性（統合レベルで否定的なケースを簡単にテストすることができた）、そしてもちろん、答えは開発したコードを使用してブランチで30分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後まで読んでくださった皆さんに感謝します。</font><font style="vertical-align: inherit;">このプロジェクトを支援し、参加してくれたすべての人に感謝します。</font><font style="vertical-align: inherit;">これらの人々に感謝します：&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peter Kolpashchikovは、クライアント側でmokiを作成するのを助け、PPPコンセプトを開発したiOS開発者です。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Solodov-Billing QA。課金サーバーからの偽のチェックとチェックアウトを生成するためのQA APIを支援しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim FilatovとVasily Stepanov-Billing Dev Team。課金サーバーのコードを手伝いました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOS Dev Team-mokasの使用を可能にする新しい概念で支払いをリファクタリングできた開発者。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOS QAチームは、一連の自動テストを作成した素晴らしいテストチームです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">課金QAチーム-問題の調査を支援したテスター。</font></font><br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460651/index.html">匿名テスター協会の会議：TMS、モニタリングモニタリング、検索品質評価、ネイティブiOSテスト</a></li>
<li><a href="../ja460655/index.html">電報を壊した方法</a></li>
<li><a href="../ja460659/index.html">パイプを使用したピボット</a></li>
<li><a href="../ja460661/index.html">Node.jsについて知っておくべきこと</a></li>
<li><a href="../ja460665/index.html">ドラフトFAQ：C ++標準が3年ごとに出てくるのはなぜですか？</a></li>
<li><a href="../ja460669/index.html">開発の安全を確保し、時間と神経を節約する方法</a></li>
<li><a href="../ja460671/index.html">Dでの所有権と借用</a></li>
<li><a href="../ja460673/index.html">DiffUtilの魔法を明らかにする</a></li>
<li><a href="../ja460675/index.html">機械学習データの抽出</a></li>
<li><a href="../ja460683/index.html">Laravelイベントプロジェクターとイベント生成の概念</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>