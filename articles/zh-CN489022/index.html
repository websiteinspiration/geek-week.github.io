<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✡️ 👈🏿 😬 将RabbitMQ与MonsterMQ结合使用第2部分 🚺 👩‍👧‍👧 😌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（图片取自RabbitMQ官方网站）
 
 在第一篇文章中，我们编写了两个使用RabbitMQ的PHP程序：一个发送消息，第二个接收消息。在本文中，我们将讨论如何创建一个队列，该队列将在许多工作人员（消息处理程序）之间分配消耗大量时间的任务。
 
 主要思想不是立即完成消耗大量时间的任务，而是以消息...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>将RabbitMQ与MonsterMQ结合使用第2部分</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489022/"><img src="https://habrastorage.org/getpro/habr/post_images/640/66e/579/64066e579d113ef3373c9a3c2c3e75ce.png" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（图片取自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RabbitMQ官方网站</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一篇文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们编写了两个使用RabbitMQ的PHP程序：一个发送消息，第二个接收消息。</font><font style="vertical-align: inherit;">在本文中，我们将讨论如何创建一个队列，该队列将在许多工作人员（消息处理程序）之间分配消耗大量时间的任务。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要思想不是立即完成消耗大量时间的任务，而是以消息的形式将它们添加到队列中。</font><font style="vertical-align: inherit;">后来，工作人员从队列中接收到一条消息，他使用该消息并像在后台一样执行任务。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个概念与Web应用程序非常相关，例如，您可能需要执行一些耗时的任务，而这些任务的结果并不需要立即执行，例如，向第三方应用程序发送电子邮件或发出HTTP请求（例如，通过libcurl到PHP）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">烹饪</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一部分中，我们将发送代表工人任务的消息。由于我们没有诸如处理图像或生成pdf文件之类的实际任务，因此我们会假装我们正忙于使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。我们将消息中的点数视为任务的复杂性。每个点表示工作需要一秒钟，例如，消息</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello ...</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将需要三秒钟的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一课中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将稍微</font><b><font style="vertical-align: inherit;">修改send.php</font></b><font style="vertical-align: inherit;">脚本</font><font style="vertical-align: inherit;">，以便它可以发送任意消息。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">try</span> {<font></font>
   $producer = \MonsterMQ\Client\Producer();<font></font>
<font></font>
   $producer-&gt;connect(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">5672</span>);<font></font>
   $producer-&gt;logIn(<span class="hljs-string">'guest'</span>, <span class="hljs-string">'guest'</span>);<font></font>
<font></font>
   $producer-&gt;queue(<span class="hljs-string">'test-queue'</span>)-&gt;declare();<font></font>
<font></font>
   $message = implode(<span class="hljs-string">' '</span>, array_slice($argv, <span class="hljs-number">1</span>));<font></font>
   $message = <span class="hljs-keyword">empty</span>($message) ? <span class="hljs-string">'Hello world!'</span> : $message;<font></font>
<font></font>
   $producer-&gt;publish($message, <span class="hljs-string">'test-queue'</span>);<font></font>
<font></font>
   <span class="hljs-keyword">echo</span> <span class="hljs-string">"\n Sent {$message} \n"</span>;<font></font>
} <span class="hljs-keyword">catch</span>(\<span class="hljs-built_in">Exception</span> $e) {<font></font>
   var_dump($e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receive.php</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚本</font><font style="vertical-align: inherit;">也需要更改。</font><font style="vertical-align: inherit;">它应该为接收到的消息中的每个点模拟一秒钟的操作。</font><font style="vertical-align: inherit;">让我们将文件重命名为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worker.php</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在其中编写以下代码：</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">try</span> {<font></font>
   $consumer = \MonsterMQ\Client\Consumer();<font></font>
<font></font>
   $consumer-&gt;connect(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">5672</span>);<font></font>
   $consumer-&gt;logIn(<span class="hljs-string">'guest'</span>, <span class="hljs-string">'guest'</span>);<font></font>
<font></font>
   $consumer-&gt;queue(<span class="hljs-string">'test-queue'</span>)-&gt;declare();<font></font>
<font></font>
   $consumer-&gt;consume(<span class="hljs-string">'test-queue'</span>);<font></font>
<font></font>
   $consumer-&gt;wait(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$message, $channelNumber</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$consumer</span>)</span>{
      <span class="hljs-keyword">echo</span> <span class="hljs-string">"\n Received: {$message}"</span>;<font></font>
      sleep(substr_count($message, <span class="hljs-string">'.'</span>));
      <span class="hljs-keyword">echo</span> <span class="hljs-string">"\n Done"</span>;<font></font>
   });<font></font>
} <span class="hljs-keyword">catch</span>(\<span class="hljs-built_in">Exception</span> $e) {<font></font>
   var_dump($e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，在不同的终端上运行两个脚本：</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment"># Shell 1</span><font></font>
php worker.php <font></font>
</code></pre><br>
<pre><code class="bash hljs"><span class="hljs-comment"># Shell 2</span>
php send.php <span class="hljs-string">"A very hard task which takes two seconds.."</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用任务队列的优点之一是能够在许多工作人员之间分配工作。</font><font style="vertical-align: inherit;">让我们尝试</font><font style="vertical-align: inherit;">在两个不同的终端</font><font style="vertical-align: inherit;">中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一次</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行两个</font><b><font style="vertical-align: inherit;">worker.php</font></b><font style="vertical-align: inherit;">脚本</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">第三，我们将使用</font><b><font style="vertical-align: inherit;">send.php</font></b><font style="vertical-align: inherit;">脚本发送消息</font></font><b><font style="vertical-align: inherit;"></font></b><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment"># Shell 1</span><font></font>
php worker.php <font></font>
</code></pre><br>
<pre><code class="bash hljs"><span class="hljs-comment"># Shell 2</span><font></font>
php worker.php <font></font>
</code></pre><br>
<pre><code class="php hljs"><span class="hljs-comment"># Shell 3</span><font></font>
php new_task.php First message.<font></font>
php new_task.php Second message..<font></font>
php new_task.php Third message...<font></font>
php new_task.php Fourth message....<font></font>
php new_task.php Fifth message.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，让我们看看我们的工人带来了什么：</font></font><br>
<pre><code class="php hljs"><span class="hljs-comment"># shell 1</span><font></font>
php worker.php<font></font>
<span class="hljs-comment"># Received: First message.</span>
<span class="hljs-comment"># Done</span>
<span class="hljs-comment"># Received: Third message...</span>
<span class="hljs-comment"># Done</span>
<span class="hljs-comment"># Received: Fifth message.....</span>
<span class="hljs-comment"># Done</span>
</code></pre><br>
<pre><code class="php hljs"><span class="hljs-comment"># shell 2</span><font></font>
php worker.php<font></font>
<span class="hljs-comment"># Received: Second message..</span>
<span class="hljs-comment"># Done</span>
<span class="hljs-comment"># Received: Fourth message....</span>
<span class="hljs-comment"># Done</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，RabbitMQ会将每个后续消息依次发送给下一个使用方。</font><font style="vertical-align: inherit;">平均而言，每个收件人将收到相同数量的消息，这种分发消息的方法称为循环（循环）。</font><font style="vertical-align: inherit;">与三个或更多工人一起尝试。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">留言确认</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任务可能需要一定的时间。</font><font style="vertical-align: inherit;">如果您完成了未能成功处理此消息的收件人的工作，那么您可能会对消息会发生什么感兴趣。</font><font style="vertical-align: inherit;">使用我们当前的代码，由于MonsterMQ中默认启用了消息确认，因此消息将返回队列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们使用消息确认时，我们告诉RabbitMQ消息已被处理，他有权将其从队列中删除。如果接收者在未发送确认的情况下完成了工作（例如，由于TCP连接的意外终止），RabbitMQ将理解该消息未得到处理，并将其返回到队列，尝试将其传递给其他可用的工作程序。因此，即使在任何工作程序意外关闭的情况下，您也可以确保不会丢失消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要在MonsterMQ中禁用消息确认，您可以将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为第二个参数</font><font style="vertical-align: inherit;">传递</font><font style="vertical-align: inherit;">给</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消耗（）</font></font></b><br>
<br>
<pre><code class="php hljs">$consumer-&gt;consume(<span class="hljs-string">'test-queue'</span>, <span class="hljs-literal">true</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
忘记确认收到的消息是一个相当普遍的，容易容忍的错误，它可能导致严重的后果。</font><font style="vertical-align: inherit;">如果发生这种情况，则消息将一次又一次地传递，并且还将累积在队列中，从而占用越来越多的内存。</font><font style="vertical-align: inherit;">要调试此错误，请使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rabbitmqctl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示</font><b><font style="vertical-align: inherit;">messages_unacknowledged</font></b><font style="vertical-align: inherit;">字段</font></font><b><font style="vertical-align: inherit;"></font></b><br>
<br>
<pre><code class="bash hljs">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Windows上，放下sudo</font></font><br>
<br>
<pre><code class="bash hljs">rabbitmqctl.bat list_queues name messages_ready messages_unacknowledged</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列安全</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管事实上，如果有任何一个工人意外终止他们的工作，我们的消息也不会丢失，但是，如果RabbitMQ关闭，我们仍然会丢失创建的队列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了防止丢失队列，您需要将队列声明为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持久</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（持久，持久）。</font><font style="vertical-align: inherit;">由于队列是幂等的，也就是说，我们无法通过调用具有相同名称的声明方法来更改或重新创建它，因此我们必须声明一个新队列。</font><font style="vertical-align: inherit;">让我们做如下</font></font><br>
<br>
<pre><code class="php hljs">$consumer-&gt;queue(<span class="hljs-string">'new-queue'</span>)-&gt;setDurable()-&gt;declare();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请记住，还要在发送者代码中更改队列公告代码。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息的公平分配</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能已经注意到，我们两个工作人员之间的消息仍然没有诚实地分发。例如，如果每条偶数消息都很耗时，并且每条奇数消息都得到了快速处理，则接收耗时消息的一个工作人员将总是很忙，而第二个工作人员将处于空闲状态。为避免这种情况，您可以使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务质量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。让我们在代码中添加以下行</font></font><br>
<br>
<pre><code class="php hljs">$consumer-&gt;qos()-&gt;prefetchCount(<span class="hljs-number">1</span>)-&gt;perConsumer()-&gt;apply();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此行告诉RabbitMQ在处理并确认当前消息之前不要将消息发送给收件人。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perConsumer（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将服务质量应用于接收者的所有通道，</font><font style="vertical-align: inherit;">如果只想将服务质量应用于当前通道</font><font style="vertical-align: inherit;">，请使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perChannel（）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/270/e31/4b5/270e314b59a085e186e46b28e2593613.png" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（图片取自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RabbitMQ官方网站</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将整个代码放在一起</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这看起来像我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">send.php</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（发送方）</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">try</span> {<font></font>
   $producer = \MonsterMQ\Client\Producer();<font></font>
<font></font>
   $producer-&gt;connect(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">5672</span>);<font></font>
   $producer-&gt;logIn(<span class="hljs-string">'guest'</span>, <span class="hljs-string">'guest'</span>);<font></font>
<font></font>
   $consumer-&gt;queue(<span class="hljs-string">'new-queue'</span>)-&gt;setDurable()-&gt;declare();<font></font>
<font></font>
   $message = implode(<span class="hljs-string">' '</span>, array_slice($argv, <span class="hljs-number">1</span>));<font></font>
   $message = <span class="hljs-keyword">empty</span>($message) ? <span class="hljs-string">'Hello world!'</span> : $message;<font></font>
<font></font>
   $producer-&gt;publish($message, <span class="hljs-string">'test-queue'</span>);<font></font>
<font></font>
   <span class="hljs-keyword">echo</span> <span class="hljs-string">"\n Sent {$message} \n"</span>;<font></font>
} <span class="hljs-keyword">catch</span>(\<span class="hljs-built_in">Exception</span> $e) {<font></font>
   var_dump($e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以接收者</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worker.php</font></font></b><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">try</span> {<font></font>
   $consumer = \MonsterMQ\Client\Consumer();<font></font>
<font></font>
   $consumer-&gt;connect(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">5672</span>);<font></font>
   $consumer-&gt;logIn(<span class="hljs-string">'guest'</span>, <span class="hljs-string">'guest'</span>);<font></font>
<font></font>
   $consumer-&gt;queue(<span class="hljs-string">'new-queue'</span>)-&gt;setDurable()-&gt;declare();<font></font>
<font></font>
   $consumer-&gt;qos()-&gt;prefetchCount(<span class="hljs-number">1</span>)-&gt;perConsumer()-&gt;apply();<font></font>
<font></font>
   $consumer-&gt;consume(<span class="hljs-string">'test-queue'</span>);<font></font>
<font></font>
   $consumer-&gt;wait(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$message, $channelNumber</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$consumer</span>)</span>{
      <span class="hljs-keyword">echo</span> <span class="hljs-string">"\n Received: {$message}"</span>;<font></font>
      sleep(substr_count($message, <span class="hljs-string">'.'</span>));
      <span class="hljs-keyword">echo</span> <span class="hljs-string">"\n Done"</span>;<font></font>
   });<font></font>
} <span class="hljs-keyword">catch</span>(\<span class="hljs-built_in">Exception</span> $e) {<font></font>
   var_dump($e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就是这样，在下一课中，我们将学习如何从同一队列将消息发送给许多收件人。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489010/index.html">我们与语言学，个性化，peddesign，ML等项目共享俄罗斯最大的在线培训数据层</a></li>
<li><a href="../zh-CN489012/index.html">Google Cloud Spanner：好，坏，邪恶</a></li>
<li><a href="../zh-CN489014/index.html">《完美算法》一书。贪婪算法和动态规划»</a></li>
<li><a href="../zh-CN489016/index.html">德国格里夫·格里夫（German Gref）：“我们试图组织有关AGI的讨论，但没有一个自尊的科学家来参加”</a></li>
<li><a href="../zh-CN489020/index.html">一种恶意研究</a></li>
<li><a href="../zh-CN489024/index.html">Webix JavaScript库通过初学者的眼光。第5部分。在用户端使用数据</a></li>
<li><a href="../zh-CN489026/index.html">更改Google AdSense算法可能会导致网站所有者和网站管理员</a></li>
<li><a href="../zh-CN489028/index.html">关于远程工作</a></li>
<li><a href="../zh-CN489034/index.html">新的UIS移动应用程序-为寻求公共采购的人们提供折磨还是救赎？</a></li>
<li><a href="../zh-CN489038/index.html">《 Java并发实践》一书</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>