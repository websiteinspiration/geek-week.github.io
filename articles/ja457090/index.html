<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌂 🤟🏿 ✳️ 安全ベビーベッド：JWT ✊ 🕵🏻 🧑🏼‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="多くのアプリケーションはJSON Web Token（JWT）を使用して、クライアントが認証後にさらに情報交換するために自分自身を識別できるようにします。
 
 JSON Web Tokenは、JSONオブジェクトとしてパーティ間で情報を安全に転送するコンパクトでスタンドアロンの方法を定義するオープ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>安全ベビーベッド：JWT</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/457090/"><img src="https://habrastorage.org/webt/db/hk/3r/dbhk3r8z4e24imgvw6mjwyuat4m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのアプリケーションはJSON Web Token（JWT）を使用して、クライアントが認証後にさらに情報交換するために自分自身を識別できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSON Web Tokenは、JSONオブジェクトとしてパーティ間で情報を安全に転送するコンパクトでスタンドアロンの方法を定義するオープンスタンダード（RFC 7519）です。</font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/oq/x9/6o/oqx96ozecxiq4qbsrzrk-dw7n5u.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報はデジタル署名されているため、検証され、信頼できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JWTは、シークレット（HMACアルゴリズムを使用）を使用して署名することも、RSAまたはECDSAを使用して公開鍵と秘密鍵のペアを署名することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSON Web Tokenは、クライアントのIDと特性に関する情報を送信するために使用されます。この「コンテナ」はサーバーによって署名されているため、クライアントはサーバーに干渉せず、識別データやその他の特性（たとえば、単純なユーザーから管理者への役割やクライアントのログインを変更するなど）を変更できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトークンは、認証が成功した場合に作成され、各クライアント要求の実行を開始する前にサーバーによってチェックされます。</font><font style="vertical-align: inherit;">トークンは、クライアント（クライアントに関するすべての情報を含むコンテナー）の「IDカード」としてアプリケーションによって使用されます。</font><font style="vertical-align: inherit;">サーバーには、安全な方法でトークンの有効性と整合性を検証する機能があります。</font><font style="vertical-align: inherit;">これにより、アプリケーションはステートレスになり（ステートレスアプリケーションは、このクライアントとの次のセッションで使用するために1つのセッションで生成されたクライアントデータを保存しません（各セッションは独立しています））、認証プロセスは（クライアントとサーバーのテクノロジーという意味で）使用されるサービスから独立していますHTTPが最も一般的に使用されますが、トランスポートチャネルも含めて異なる場合があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWTの使用に関する考慮事項</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JWTトークンが使いやすく、ステートフル性（ステートレス）なしでサービス（主にREST）を提供できる場合でも、このソリューションには、トークンの格納の問題などの注意事項がいくつかあるため、すべてのアプリケーションに適しているわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションが完全にステートレスである必要がない場合は、すべてのWebプラットフォームが提供する従来のセッションシステムの使用を検討できます。</font><font style="vertical-align: inherit;">ただし、ステートレスアプリケーションの場合、正しく実装されていればJWTは適切なオプションです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWTの問題と攻撃</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NONEハッシュアルゴリズムの使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の攻撃は、攻撃者がトークンを変更し、ハッシュアルゴリズム（「alg」フィールド）も変更するときに発生し、トークンの整合性がすでに検証されていることをnoneキーワードを通じて示します。</font><font style="vertical-align: inherit;">一部のライブラリは、noneアルゴリズムを使用して署名されたトークンを検証済みの署名付きの有効なトークンと見なしたため、攻撃者はトークンのペイロードを変更でき、アプリケーションはトークンを信頼していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃を防ぐには、この脆弱性の影響を受けないJWTライブラリを使用する必要があります。</font><font style="vertical-align: inherit;">また、トークンの検証中に、予期されるアルゴリズムの使用を明示的に要求する必要があります。</font></font><br>
<br>
<b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装例：</font></font></u></b><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//  HMAC   String   JVM</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">byte</span>[] keyHMAC = ...;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-comment">//    HMAC-256 -</span><font></font>
JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build();<font></font>
<font></font>
<span class="hljs-comment">//  </span>
DecodedJWT decodedToken = verifier.verify(token);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークン傍受</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃者がトークンを傍受または盗んだときに攻撃が発生し、特定のユーザーの資格情報を使用してシステムにアクセスするためにトークンを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保護は、トークンに「ユーザーコンテキスト」を追加することです。</font><font style="vertical-align: inherit;">ユーザーコンテキストは次の情報で構成されます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認証段階で生成され、トークンに含まれ、さらに安全なCookieとしてクライアントに送信されるランダムな文字列（フラグ：HttpOnly + Secure + SameSite + Cookieプレフィックス）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムな文字列からのSHA256ハッシュはトークンに格納されるため、XSSの問題が発生しても、攻撃者はランダムな文字列の値を読み取って予期されるCookieを設定することはできません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが携帯電話からアプリケーションにアクセスする場合など、1つのセッション中にIPアドレスが変更される可能性があるため、IPアドレスはコンテキストでは使用されません。</font><font style="vertical-align: inherit;">その後、IPアドレスは常に正当に変更されます。</font><font style="vertical-align: inherit;">さらに、IPアドレスを使用すると、ヨーロッパのGDPRへの準拠レベルで問題が発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンの検証中に、受信したトークンに正しいコンテキストが含まれていない場合は、拒否する必要があります。</font></font><br>
<b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装例：</font></font></u></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認証成功後にトークンを作成するためのコード：</font></font></i><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//  HMAC   String   JVM</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">byte</span>[] keyHMAC = ...;
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">private</span> SecureRandom secureRandom = <span class="hljs-keyword">new</span> SecureRandom();<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">byte</span>[] randomFgp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">50</span>];<font></font>
secureRandom.nextBytes(randomFgp);<font></font>
String userFingerprint = DatatypeConverter.printHexBinary(randomFgp);<font></font>
<font></font>
<span class="hljs-comment">//    cookie</span>
String fingerprintCookie = <span class="hljs-string">"__Secure-Fgp="</span> + userFingerprint<font></font>
                           + <span class="hljs-string">"; SameSite=Strict; HttpOnly; Secure"</span>;<font></font>
response.addHeader(<span class="hljs-string">"Set-Cookie"</span>, fingerprintCookie);<font></font>
<font></font>
<span class="hljs-comment">// SHA256         </span>
<span class="hljs-comment">// (  )  XSS     </span>
<span class="hljs-comment">//     cookie</span>
MessageDigest digest = MessageDigest.getInstance(<span class="hljs-string">"SHA-256"</span>);
<span class="hljs-keyword">byte</span>[] userFingerprintDigest = digest.digest(userFingerprint.getBytes(<span class="hljs-string">"utf-8"</span>));<font></font>
String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest);<font></font>
<font></font>
<span class="hljs-comment">//      15    </span><font></font>
Calendar c = Calendar.getInstance();<font></font>
Date now = c.getTime();<font></font>
c.add(Calendar.MINUTE, <span class="hljs-number">15</span>);<font></font>
Date expirationDate = c.getTime();<font></font>
Map&lt;String, Object&gt; headerClaims = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
headerClaims.put(<span class="hljs-string">"typ"</span>, <span class="hljs-string">"JWT"</span>);<font></font>
String token = JWT.create().withSubject(login)<font></font>
   .withExpiresAt(expirationDate)<font></font>
   .withIssuer(<span class="hljs-keyword">this</span>.issuerID)<font></font>
   .withIssuedAt(now)<font></font>
   .withNotBefore(now)<font></font>
   .withClaim(<span class="hljs-string">"userFingerprint"</span>, userFingerprintHash)<font></font>
   .withHeader(headerClaims)<font></font>
   .sign(Algorithm.HMAC256(<span class="hljs-keyword">this</span>.keyHMAC));</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンの有効性を確認するコード：</font></font></i><br>
<pre><code class="java hljs">
<span class="hljs-comment">//  HMAC   String   JVM</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">byte</span>[] keyHMAC = ...;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">//     cookie</span>
String userFingerprint = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">if</span> (request.getCookies() != <span class="hljs-keyword">null</span> &amp;&amp; request.getCookies().length &gt; <span class="hljs-number">0</span>) {<font></font>
 List&lt;Cookie&gt; cookies = Arrays.stream(request.getCookies()).collect(Collectors.toList());<font></font>
 Optional&lt;Cookie&gt; cookie = cookies.stream().filter(c -&gt; <span class="hljs-string">"__Secure-Fgp"</span><font></font>
                                            .equals(c.getName())).findFirst();<font></font>
 <span class="hljs-keyword">if</span> (cookie.isPresent()) {<font></font>
   userFingerprint = cookie.get().getValue();<font></font>
 }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  SHA256      cookie </span>
<span class="hljs-comment">//      </span>
MessageDigest digest = MessageDigest.getInstance(<span class="hljs-string">"SHA-256"</span>);
<span class="hljs-keyword">byte</span>[] userFingerprintDigest = digest.digest(userFingerprint.getBytes(<span class="hljs-string">"utf-8"</span>));<font></font>
String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest);<font></font>
<font></font>
<span class="hljs-comment">//     </span><font></font>
JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC))<font></font>
                              .withIssuer(issuerID)<font></font>
                              .withClaim(<span class="hljs-string">"userFingerprint"</span>, userFingerprintHash)<font></font>
                              .build();<font></font>
<font></font>
<span class="hljs-comment">//  </span>
DecodedJWT decodedToken = verifier.verify(token);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーによる明示的なトークンのキャンセル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンは有効期限が切れた後にのみ無効になるため、ユーザーには、トークンを明示的にキャンセルできる組み込み関数がありません。したがって、盗難が発生した場合、ユーザーは自分でトークンを引き出し、攻撃者をブロックすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保護の方法の1つは、トークンのブラックリストの導入です。これは、従来のセッションシステムに存在する「ログアウト」機能をシミュレートするのに適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発行されたトークンの有効期間を超えているはずのキャンセル日付のあるトークンのコレクション（HEXではSHA-256エンコーディング）は、ブラックリストに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが「ログアウト」する場合、提供されたユーザートークンをブラックリストに追加する特別なサービスを呼び出します。これにより、アプリケーションでさらに使用するためにトークンが即座にキャンセルされます。</font></font><br>
<br>
<u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装例：</font></font></b></u><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラックリストストレージ</font></font></i><font style="vertical-align: inherit;"><u><b><font style="vertical-align: inherit;">：</font></b></u><i><font style="vertical-align: inherit;">ブラックリストの</font></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
集中ストレージには、次の構造のデータベースが使用されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">create table <span class="hljs-keyword">if</span> not exists <span class="hljs-title">revoked_token</span><span class="hljs-params">(jwt_token_digest varchar(<span class="hljs-number">255</span>)</span> primary key,
revokation_date timestamp <span class="hljs-keyword">default</span> <span class="hljs-title">now</span><span class="hljs-params">()</span>)</span>;</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークン失効管理：</font></font></i><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//    (logout).</span>
<span class="hljs-comment">//  ,     </span>
<span class="hljs-comment">//         .</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenRevoker</span> </span>{<font></font>
<font></font>
 <span class="hljs-comment">//   </span>
 <span class="hljs-meta">@Resource("jdbc/storeDS")</span>
 <span class="hljs-keyword">private</span> DataSource storeDS;<font></font>
<font></font>
 <span class="hljs-comment">//     </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isTokenRevoked</span><span class="hljs-params">(String jwtInHex)</span> <span class="hljs-keyword">throws</span> Exception </span>{
     <span class="hljs-keyword">boolean</span> tokenIsPresent = <span class="hljs-keyword">false</span>;
     <span class="hljs-keyword">if</span> (jwtInHex != <span class="hljs-keyword">null</span> &amp;&amp; !jwtInHex.trim().isEmpty()) {
         <span class="hljs-comment">//  </span>
         <span class="hljs-keyword">byte</span>[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex);<font></font>
<font></font>
         <span class="hljs-comment">//  SHA256  </span>
         MessageDigest digest = MessageDigest.getInstance(<span class="hljs-string">"SHA-256"</span>);
         <span class="hljs-keyword">byte</span>[] cipheredTokenDigest = digest.digest(cipheredToken);<font></font>
         String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest);<font></font>
<font></font>
         <span class="hljs-comment">//    </span>
         <span class="hljs-keyword">try</span> (Connection con = <span class="hljs-keyword">this</span>.storeDS.getConnection()) {<font></font>
             String query = <span class="hljs-string">"select jwt_token_digest from revoked_token where jwt_token_digest = ?"</span>;
             <span class="hljs-keyword">try</span> (PreparedStatement pStatement = con.prepareStatement(query)) {<font></font>
                 pStatement.setString(<span class="hljs-number">1</span>, jwtTokenDigestInHex);
                 <span class="hljs-keyword">try</span> (ResultSet rSet = pStatement.executeQuery()) {<font></font>
                     tokenIsPresent = rSet.next();<font></font>
                 }<font></font>
             }<font></font>
         }<font></font>
     }<font></font>
<font></font>
     <span class="hljs-keyword">return</span> tokenIsPresent;<font></font>
 }<font></font>
<font></font>
<span class="hljs-comment">//    HEX     </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revokeToken</span><span class="hljs-params">(String jwtInHex)</span> <span class="hljs-keyword">throws</span> Exception </span>{
     <span class="hljs-keyword">if</span> (jwtInHex != <span class="hljs-keyword">null</span> &amp;&amp; !jwtInHex.trim().isEmpty()) {
         <span class="hljs-comment">//  </span>
         <span class="hljs-keyword">byte</span>[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex);<font></font>
<font></font>
         <span class="hljs-comment">//  SHA256  </span>
         MessageDigest digest = MessageDigest.getInstance(<span class="hljs-string">"SHA-256"</span>);
         <span class="hljs-keyword">byte</span>[] cipheredTokenDigest = digest.digest(cipheredToken);<font></font>
         String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest);<font></font>
<font></font>
         <span class="hljs-comment">//            </span>
	   <span class="hljs-comment">//  </span>
         <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isTokenRevoked(jwtInHex)) {
             <span class="hljs-keyword">try</span> (Connection con = <span class="hljs-keyword">this</span>.storeDS.getConnection()) {<font></font>
                 String query = <span class="hljs-string">"insert into revoked_token(jwt_token_digest) values(?)"</span>;
                 <span class="hljs-keyword">int</span> insertedRecordCount;
                 <span class="hljs-keyword">try</span> (PreparedStatement pStatement = con.prepareStatement(query)) {<font></font>
                     pStatement.setString(<span class="hljs-number">1</span>, jwtTokenDigestInHex);<font></font>
                     insertedRecordCount = pStatement.executeUpdate();<font></font>
                 }<font></font>
                 <span class="hljs-keyword">if</span> (insertedRecordCount != <span class="hljs-number">1</span>) {
                     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Number of inserted record is invalid,"</span> + <span class="hljs-string">" 1 expected but is "</span> + insertedRecordCount);<font></font>
                 }<font></font>
             }<font></font>
         }<font></font>
<font></font>
     }<font></font>
 }<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンの開示</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この攻撃は、攻撃者がトークン（または一連のトークン）にアクセスし、そこに格納されている情報（JWTトークンに関する情報はbase64を使用してエンコードされています）を抽出してシステムに関する情報を取得すると発生します。</font><font style="vertical-align: inherit;">たとえば、セキュリティロール、ログイン形式などの情報を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保護方法は非常に明白で、トークンの暗号化にあります。暗号解読を使用して、暗号化されたデータを攻撃から保護することも重要です。これらすべての目標を達成するために、AES-GCMアルゴリズムが使用されます。これは、関連データ付き認証暗号化（AEAD）を提供します。 AEADプリミティブは、対称認証された暗号化機能を提供します。このプリミティブの実装は、選択された暗号文に基づく適応型攻撃から保護されています。平文を暗号化するとき、認証する必要があるが暗号化しない関連データをオプションで指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、関連データを使用した暗号化により、データの信頼性と整合性が保証されますが、機密性は保証されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、暗号化は主に内部情報を隠すために追加されますが、JWTトークンの偽造に対する最初の保護は署名であることを覚えておくことが非常に重要です。したがって、トークンの署名とその検証を常に使用する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント側のトークンストレージ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の1つ以上の状況が発生するようにアプリケーションがトークンを保存する場合：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンはブラウザーによって自動的に送信されます（Cookieストレージ）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラウザーが再起動された場合でも（ブラウザーのlocalStorageコンテナーを使用して）トークンが取得されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンは、XSS攻撃（JavaScriptコードで使用可能なCookie、またはlocalStorageまたはsessionStorageに格納されているトークン）のイベントで取得されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃を防ぐには：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sessionStorageコンテナを使用して、トークンをブラウザに保存します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearerスキームを使用して、Authorizationヘッダーに追加します。</font><font style="vertical-align: inherit;">タイトルは次のようになります。</font></font><br>
<br>
<pre><code class="xml hljs">Authorization: Bearer <span class="hljs-tag">&lt;<span class="hljs-name">token</span>&gt;</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンに指紋情報を追加します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンをsessionStorageコンテナに格納することで、XSSの場合の盗難用のトークンを提供します。</font><font style="vertical-align: inherit;">ただし、トークンに追加された指紋は、攻撃者が盗んだトークンをコンピューターで再利用することを防ぎます。</font><font style="vertical-align: inherit;">攻撃者の最大使用領域を閉じるには、実行コンテキストを制限するコンテンツセキュリティポリシーを追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
攻撃者が正当なユーザーを介してターゲットアプリケーションを使用するプロキシサーバーとしてユーザーのブラウジングコンテキストを使用するケースは依然として残っていますが、コンテンツセキュリティポリシーは予期しないドメインとの通信を防ぐことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンが安全なCookie内で発行されるように認証サービスを実装することも可能ですが、この場合、CSRFに対する保護を実装する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱いキーを使用してトークンを作成する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンの署名に必要なHMAC-SHA256アルゴリズムの場合に使用されるシークレットが弱い場合、ハッキングされる可能性があります（ブルートフォース攻撃を使用して取得）。</font><font style="vertical-align: inherit;">その結果、攻撃者は署名に関して任意の有効なトークンを偽造することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を回避するには、複雑な秘密鍵を使用する必要があります：英数字（大/小文字混合）+特殊文字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーはコンピュータの計算にのみ必要なので、秘密キーのサイズは50桁を超える場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば：</font></font><br>
<br>
<pre><code class="plaintext hljs">A&amp;'/}Z57M(2hNg=;LE?~]YtRMS5(yZ&lt;vcZTA3N-($&gt;2j:ZeX-BGftaVk`)jKP~q?,jk)EMbgt*kW'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンの署名に使用される秘密鍵の複雑さを評価するために、JWT APIと組み合わせてパスワード攻撃の辞書をトークンに適用できます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457072/index.html">Pythonと.NetでMLを使用して古い問題を解決する方法</a></li>
<li><a href="../ja457074/index.html">開発者の進化：将来どのようなゲームが期待できるか</a></li>
<li><a href="../ja457078/index.html">テレグラムアバターを時計に変える方法</a></li>
<li><a href="../ja457082/index.html">管理者権限のサイレント付与</a></li>
<li><a href="../ja457086/index.html">「Swift」と「iOS」/「macOS」の世界における建築パターン「ビルダー」</a></li>
<li><a href="../ja457092/index.html">MITER ATT＆CKを勉強しています。モバイルマトリックス：デバイスアクセス。パート5</a></li>
<li><a href="../ja457094/index.html">キューブを操作するときにフィルターを簡単に設定できるExcelアドイン（VBA）</a></li>
<li><a href="../ja457096/index.html">いくつかのアナリストに手を貸します：典型的な銀行業務の自動化のためのAPI Livy</a></li>
<li><a href="../ja457098/index.html">EitherモナドでのエレガントなJavaScriptエラー処理</a></li>
<li><a href="../ja457100/index.html">AWS Lambda-理論、知人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>