<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏿 💒 🌩️ オートマトンはイベントですか？ 📩 👷🏼 👨🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.はじめに
 権威ある唇から「オートマトンはイベントのこと」[3]だと聞いて、有限オートマトンは完全にブランド化されていることに気付きました。自分で判断してください：Qtライブラリでは、オートマトンのイベントモデル[1]が実装されています。UMLではこれらも[2]であり、MATLABシステムのSi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>オートマトンはイベントですか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483610/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
権威ある唇から「オートマトンはイベントのこと」[3]だと聞いて、有限オートマトンは完全にブランド化されていることに気付きました。</font><font style="vertical-align: inherit;">自分で判断してください：Qtライブラリでは、オートマトンのイベントモデル[1]が実装されています。UMLではこれらも[2]であり、MATLABシステムのSimulink-Stateflow拡張パッケージ（以下、単にStateflow）のオートマトンと、イベントなどについて調べます。</font><font style="vertical-align: inherit;">等 </font><font style="vertical-align: inherit;">この文脈では、技術科学博士の声明 </font><font style="vertical-align: inherit;">A.A. </font><font style="vertical-align: inherit;">別の方法で解釈するのはいたずらです、なぜなら </font><font style="vertical-align: inherit;">それはあり得ないからである。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、有限オートマトン（TCA）の理論を思い出すと、その中にイベントオートマトンについての言葉はありません！しかし、理論に矛盾するためには、重要な議論が必要です。 UML言語であるStateflowパッケージがそのアイデアのベースとなっている表記法の作成者として、D。ハレルの専門性を疑う理由はありますか？いたずら？実際、UML、Stateflow、SWITCHプログラミング、およびその他の自動プログラミングオプションが存在し、ある程度は正常に機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、「カツレツからハエ」を分離することで、有限状態機械モデルから「イベントのスティグマ」を取り除くことは可能でしょうか。それら。 D.ハレルのモデルと同様に、オートマトンの理論と計算モデルを分離します。そして、後者は、オートマトンの理論の用語を使用していますが、それらの実装から判断すると、プログラムのブロック図のモデルの開発を表していると考えます。</font></font><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備考1.ここでは、プログラムモデル自体ではなく、プログラム管理モデルについて説明しています（モデルの詳細については、[5]を参照してください）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
したがって、Qtライブラリは、UMLから借用した有限状態マシンのイベントモデルを実装していることを思い出します。同じモデルがStateflowによって実装されています。それら。イベントのソースはUMLであり、オートマトンはD. Harelによって提案された表記法に基づいています。しかし、そのような自動プログラミングを作成したことで後者を非難することも真実ではないでしょう。 「イベントフルネス」は、ソフトウェアモデルの実装に対する現代的なアプローチの傾向です。これは、前述の「マシンはイベントである」などの信頼できる意見と、言語やUMLなどのテクノロジーの高い人気に基づいています。疑いもなく、これはオペレーティングシステムの動作の既存の原則に基づくマシンの模倣の結果です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、奇妙に思えないので繰り返しますが、ニュースになることさえあるオートマトンの理論では、有限オートマトンのイベントモデルはありません。少なくとも、クラシックと見なされるその部分では（たとえば、[6]または[7]のように、詳細を参照してください）。理論と実践の間には明確な矛盾があります。そのような状況では、理論を使って何かをするか、何らかの形で実践に影響を与える必要があります。しかし、おそらく、「イベント」の概念をそこに含めることによって有限状態マシンのモデルを完成させたいというプログラマーの望みは正しいでしょう[8、9]？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、プログラマーの欲望と「オートマトンアプローチを使用する上での最大の困難は、イベントシステムにおけるオートマトンの機能の特徴を理解することに関連している」という事実とどのように結びつけるか（[8]を参照）。そのような問題の原因を理解し、この状況で、イベントマシンやそのアナログを実装したいと思います。この目的のために、詳細については、Qtでオートマトンの実装を採用し、古典的な有限オートマトンのモデルを使用してそれらを繰り返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述の「機能」を評価および/または克服するには、イベントオートマトンの同様の実装が必要です。古典的なモデルを使用すると、オートマトンの理論が「イベントプログラミング」の実践にも拡張されます。そして、結局、別のモデルに基づくアナログは、有限状態機械モデルの適用範囲を拡大するだけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.オートマトンのイベント、シグナル、性同一性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UMLでは、イベントは「時間と空間で特定の位置にあり、特定の結果を伴う重要な現象」です[10]。</font><font style="vertical-align: inherit;">オートマトン理論におけるイベントは、出力アルファベットの文字によって表される入力文字のサブセットです（TCAにはイベント代数の概念さえあります[6]。</font><font style="vertical-align: inherit;">オートマトンの遷移を引き起こす同じものは、オートマトンの理論では入力信号と呼ばれます。</font><font style="vertical-align: inherit;">それらは結果であり、「オートマトンが1つの状態から別の状態に移行する理由です。</font><font style="vertical-align: inherit;">この場合、出力信号は「オートマトンの入力信号に対する応答」です。どちらも「オートマトンの対応する遷移によって決定される時刻を参照する」[6]。UMLでは、信号（信号）は「通信手段として機能する名前付きエンティティオブジェクト間」[10]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、用語の名前は同じですが、それらに投資された意味は異なります。ただし、それらを並べ替えると、類似点が見つかるはずです。UMLのイベントが、TCAの有限状態マシンの信号に対応していることが明らかになります。しかし、おそらく、異なるエンティティも「有限状態機械」という用語の下に隠されているのでしょうか？イベントから始めて、これに対処してみましょう... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントオートマトンはパッシブオートマトンです。イベントの到着時にのみ機能します。対照的に、古典的なオートマトンはアクティブなモデルを表します。何も参照せずに機能します（パッシブおよびアクティブオートマトンの詳細については、[9]を参照してください）。これは2人のランナーとの関連性を懇願します。最初のランナーはキック（イベント）によって駆動され、2番目のランナーは単独で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[8]とは異なり、最初にイベントの発生の瞬間をオートマトンの開始に関連付けません。したがって、外部環境に対するオートマトンの機能の非同期の性質を決定するオートマトンの理論の枠組みに留まります。それは、状態の変化がゼロのリアルタイム期間ではなく、任意に小さい間実行される離散時間についてのみ話します。そして遷移の理由は、マシンの現在の状態と入力信号であり、結果は新しい状態のインストールとマシンの出力信号の値です（マシンの定義の詳細については、[6]を参照してください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトン理論は、リアルタイムモデルである離散時間の決定に柔軟性があります。したがって、離散時間サイクルはリアルタイム間隔の固定値または浮動値を持つことができ、オートマトンはこれに従って同期または非同期と呼ばれます。同時に、クロックに関連付けられた時間間隔は、ゼロではないが、非常に小さい値を含む任意の値を持つことができます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備考2.有限状態機械モデルは、その定義に明示的な形式のリアルタイムモデルを含む数少ない正式モデルの1つです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、アクティブなオートマトンの正式な「無限」の速度により、あらゆるイベントを潜在的な入力信号として解釈できます（UMLに関しては、条件[11]がそれに対応します）。マシンは、そのようなイベント/シグナルを「キャッチ」し、それらの間で一時停止するだけで済みます。これはすべて、媒体と機械の共同作業のプロトコルを実際に定義します。プロトコルは、連続して受信された同一のイベントの認識の問題も解決する必要があります。これがなければ、たとえば、次々と受信される2つの同一のシンボルが1つとして認識されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正式には、イベント処理のニュアンスは重要ではありませんが（同じ抽象オートマトンを参照）、イベントモデルのタイプによって構築されたアルゴリズムの実際の実装では、それらを考慮する必要があります。</font><font style="vertical-align: inherit;">Qtライブラリの場合、それらのアカウンティングはオートマトンの実装クラスに隠されています。</font><font style="vertical-align: inherit;">次に、[1]の最も単純な計算機の実装例を使用して、イベントオートマトンと古典的なオートマトンの違いを考慮します。</font><font style="vertical-align: inherit;">このソリューションとは対照的に、同等のモデルは、古典的な有限状態機械に基づいて作成されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.電卓モデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、始めましょう...イベントシグナル、通常のオートマトンイベントと呼びます...または逆の順序でおよび/またはその逆ですか？</font><font style="vertical-align: inherit;">うわっ！</font><font style="vertical-align: inherit;">混乱しています。</font><font style="vertical-align: inherit;">要するに、完全な「グロッキーなクズドラシュテコブドラヌラ」と何か「カール」です。</font><font style="vertical-align: inherit;">誰が、何を、何を呼び出すのかを理解するための最も確実な方法は、特定の「ボクラ」を選択して「バンプ」することです。「自動計算機」プログラムは、このような「側面」であり続けます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1。</font><font style="vertical-align: inherit;">アクティブ計算機モデル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では1は、[1]のCalculatorクラスの初期モデルを示しています。見た目は、出口のない古典的な抽象機械のように見えます。違いは、Qtが状態に出入りするときにアクションをフックすることです。出力では、exited（）シグナルによってトリガーされ、状態に入ると、entered（）シグナルによってトリガーされます。ただし、これらのアクションはグラフには表示されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図のモデルを比較すると、 1抽象状態のオートマトン（他の名前は構造的、論理的オートマトン）を使用すると、状態からの出口でのアクションがMealyオートマトンの信号に対応し、入口へのアクションがMooreオートマトンの信号に対応していることが簡単にわかります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
備考3.さらに、モデルのソフトウェア実装を考慮して、信号、イベント、条件などについてではなく、プログラムレベルで特定のプログラムアクションに関連付けられていると仮定して、オートマトンのアクションについて説明します。ソフトウェア機能で表されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図1のオートマトンと同等の、いわゆる複合ミリムーアオートマトン（または異なる混合オートマトン[12]）図1を図2に示します。オートマトンの入力信号と出力信号に対応する関数もグラフの右側に表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dq/ki/ps/dqkipszttmbkgyexe9labqsio9e.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1。クラスCalculatorのイベントオートマトンの</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/c3/la/ue/c3laueqyd9oiwdf9aiu5gpyi_yk.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図図2。クラスCalculatorのMily-Mooreオートマトンを数える</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図2のオートマトンに似たモデルの場合、入力/出力アクションは、述語とアクションを意味します。これらは、プログラム関数であり、[オートマトン]クラスのメソッドです。述語は、メモリ要素（変数、クラスプロパティ）の現在の状態をまったく分析しません（これは重要です）。それらに影響を与えることなく、値に応じてブール値を返します。値のアクションは戻りませんが、メモリ要素を変更します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図から2つまり、「ブラックボックス」のような計算機モデルには、述語とアクションの数に応じて、4つの入力チャネルと7つの出力チャネルがあります。定義上、入力チャネルと出力チャネルが1つしかない抽象オートマトンと比較して、多くのチャネルを持つ構造オートマトンは、より汎用的で柔軟性があり便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図のモデル2は、状態1と2を「接着」することで簡略化できます。これを行うには、最初に元のオートマトンをMealyオートマトンに変換する必要があります。これは、信号の状態に入る弧に、ムーアオートマトンの頂点の信号によって表される信号をロードすることによって取得します。この後、接着操作が明らかになります。状態を状態2に接着した結果、現在は初期状態になり、図2に示されています。 3. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qa/en/yw/qaenywlioaky3gizvfju27faxmm.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3。図2のオートマトンの状態の変換と接着の結果</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションy1と変数nTypeButtonsについて説明します。</font><font style="vertical-align: inherit;">全体として、イベントをシミュレートするプロトコルを実装しています。</font><font style="vertical-align: inherit;">変数nTypeButtonsは、マシンの入力シンボルのタイプを決定し、それらをデジタルシンボル、操作シンボル、「リセット」シンボル、および「等しい」シンボルに分割します。</font><font style="vertical-align: inherit;">ゼロに等しい値は、入力文字がないことを意味します（計算機キーの1つが押されていません）。</font><font style="vertical-align: inherit;">シンボルの処理後、これは入力シンボルが自動的に認識されることも意味します。</font><font style="vertical-align: inherit;">これにより、入力文字に対する応答がブロックされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動ビジュアルコンポーネントプログラミング（VKPa）環境[5]のフレームワークで作成された計算機のクラスのコードをリスト1、2に示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト1. FCalculatorクラスのヘッダー</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">enum</span> Buttons {<font></font>
    digit0 = <span class="hljs-number">0</span>,<font></font>
    digit1,<font></font>
    digit2,<font></font>
    digit3,<font></font>
    digit4,<font></font>
    digit5,<font></font>
    digit6,<font></font>
    digit7,<font></font>
    digit8,<font></font>
    digit9,<font></font>
    opPlus,<font></font>
    opMinus,<font></font>
    opCancel,<font></font>
    opEqual,<font></font>
    opNone<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCalculator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MooreAction</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FCalculator(pTAppCore, nameFsa, pCVarFsaLibrary); }<font></font>
    FCalculator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FCalculator(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">digitButtonPressed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> button)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operationButtonPressed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> button)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s1Entered</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s2Entered</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s3Entered</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s3Exited</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s5Entered</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s5Exited</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> Rf, Rb;<font></font>
    Buttons transitionButton, Op;<font></font>
    <span class="hljs-keyword">int</span> nTypeButtons;               <span class="hljs-comment">// 0 - none; 1 - digit button; 2 - operation button;</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doOp</span><span class="hljs-params">(Buttons op)</span></span>;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x4</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y3</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y5</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y6</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y7</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y8</span><span class="hljs-params">()</span></span>; 
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y9</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y10</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">int</span> nState{<span class="hljs-number">2</span>};<font></font>
};<font></font>
</code></pre><br>
<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明しましょう。</font><font style="vertical-align: inherit;">VKPaでは、すべてのオートマトンクラスは、基本オートマトンクラスLFsaApplのプロパティを継承します。</font><font style="vertical-align: inherit;">Create（）メソッドは、自動プロセスの動的ライブラリに含まれるクラスのコピーを作成します。</font><font style="vertical-align: inherit;">ムーアのオートマトンモデルを選択する場合、仮想MooreAction（）メソッドは重複し、オートマトンの状態に関連付けられたアクションを定義します。</font><font style="vertical-align: inherit;">メソッドx [n]およびy [n]は、オートマトンの入力/出力チャネルに関連付けられた述語とアクションです。</font><font style="vertical-align: inherit;">[自動]クラスの動作アルゴリズムは、LArcタイプの文字列の配列で構成される遷移表（リスト2を参照）によって表されます。</font><font style="vertical-align: inherit;">コードの残りの部分は、ソースクラスCalculatorのコードを繰り返します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト2. FCalculatorクラスの実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FCalculator.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"DlgCalculator.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"ui_cdlgcalculator.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">static</span> LArc TBL_Calculator[] = {
<span class="hljs-comment">//*</span>
    LArc(<span class="hljs-string">"1"</span>,   <span class="hljs-string">"2"</span>,<span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [0-9]</span>
    LArc(<span class="hljs-string">"2"</span>,	<span class="hljs-string">"1"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [c]</span>
    LArc(<span class="hljs-string">"2"</span>,	<span class="hljs-string">"2"</span>,<span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [0-9]</span>
    LArc(<span class="hljs-string">"2"</span>,	<span class="hljs-string">"3"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [+][-]</span>
    LArc(<span class="hljs-string">"3"</span>,	<span class="hljs-string">"1"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"y3"</span>),			<span class="hljs-comment">// [c]</span>
    LArc(<span class="hljs-string">"3"</span>,	<span class="hljs-string">"3"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"y3"</span>),			<span class="hljs-comment">// [+][-]</span>
    LArc(<span class="hljs-string">"3"</span>,	<span class="hljs-string">"4"</span>,<span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y3"</span>),			<span class="hljs-comment">// [0-9]</span>
    LArc(<span class="hljs-string">"3"</span>,	<span class="hljs-string">"5"</span>,<span class="hljs-string">"x4"</span>,	<span class="hljs-string">"y3"</span>),			<span class="hljs-comment">// [=]</span>
    LArc(<span class="hljs-string">"4"</span>,	<span class="hljs-string">"1"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [c]</span>
    LArc(<span class="hljs-string">"4"</span>,	<span class="hljs-string">"3"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [+][-]</span>
    LArc(<span class="hljs-string">"4"</span>,	<span class="hljs-string">"4"</span>,<span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [0-9]</span>
    LArc(<span class="hljs-string">"4"</span>,	<span class="hljs-string">"5"</span>,<span class="hljs-string">"x4"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">// [=]</span>
    LArc(<span class="hljs-string">"5"</span>,	<span class="hljs-string">"1"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"y5"</span>),			<span class="hljs-comment">// [c]</span>
    LArc(<span class="hljs-string">"5"</span>,	<span class="hljs-string">"2"</span>,<span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y5"</span>),			<span class="hljs-comment">// [0-9]</span>
    LArc(<span class="hljs-string">"5"</span>,	<span class="hljs-string">"3"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"y5"</span>),			<span class="hljs-comment">// [+][-]</span>
<span class="hljs-comment">//*/</span>
<span class="hljs-comment">/*
    LArc("2",   "2","x1",	"y1y7"),			// [0-9]
    LArc("2",	"2","x3",	"y1y6"),			// [c]
    LArc("2",	"3","x2",	"y1y8"),			// [+][-]
    LArc("3",	"2","x3",	"y3y6"),			// [c]
    LArc("3",	"3","x2",	"y3y8"),			// [+][-]
    LArc("3",	"4","x1",	"y3y7"),			// [0-9]
    LArc("3",	"5","x4",	"y3y9"),			// [=]
    LArc("4",	"2","x3",	"y1y6"),			// [c]
    LArc("4",	"3","x2",	"y1y8"),			// [+][-]
    LArc("4",	"4","x1",	"y1y7"),			// [0-9]
    LArc("4",	"5","x4",	"y1y9"),			// [=]
    LArc("5",	"2","x3",	"y5y6"),			// [c]
    LArc("5",	"2","x1",	"y5y7"),			// [0-9]
    LArc("5",	"3","x2",	"y5y8"),			// [+][-]
*/</span>
<span class="hljs-comment">//    LArc("1",   "1","--",	"y10"),             // SWITCH</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FCalculator::FCalculator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Calculator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
    Rf= <span class="hljs-number">0</span>;<font></font>
    Rb = <span class="hljs-number">0</span>;<font></font>
    Op = opNone;<font></font>
}<font></font>
<font></font>
FCalculator::~FCalculator(<span class="hljs-keyword">void</span>) { }
<span class="hljs-comment">//  </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCalculator::x1</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (nTypeButtons != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">//   +, -</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCalculator::x2</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (nTypeButtons == <span class="hljs-number">0</span> || nTypeButtons != <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (transitionButton != opCancel &amp;&amp; transitionButton != opEqual ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<span class="hljs-comment">//  Cancel</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCalculator::x3</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (nTypeButtons == <span class="hljs-number">0</span> || nTypeButtons != <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (transitionButton == opCancel) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<span class="hljs-comment">//  opEqual</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCalculator::x4</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (nTypeButtons == <span class="hljs-number">0</span> || nTypeButtons != <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (transitionButton == opEqual) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y1</span><span class="hljs-params">()</span> </span>{ nTypeButtons = <span class="hljs-number">0</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y3</span><span class="hljs-params">()</span> </span>{ s3Exited(); }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y5</span><span class="hljs-params">()</span> </span>{ s5Exited(); }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y6</span><span class="hljs-params">()</span> </span>{ s1Entered(); }     <span class="hljs-comment">// 1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y7</span><span class="hljs-params">()</span> </span>{ s2Entered(); }     <span class="hljs-comment">// 2, 4</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y8</span><span class="hljs-params">()</span> </span>{ s3Entered(); }     <span class="hljs-comment">// 3</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y9</span><span class="hljs-params">()</span> </span>{ s5Entered(); }     <span class="hljs-comment">// 5</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y10</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">switch</span>(nState) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
        <span class="hljs-keyword">if</span> (x1()) { y1();y7(); }
        <span class="hljs-keyword">if</span> (x3()) { y1();y6(); }
        <span class="hljs-keyword">if</span> (x2()) { y1();y8(); nState = <span class="hljs-number">3</span>; }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> (x3()) { y3();y6(); nState = <span class="hljs-number">2</span>; }
        <span class="hljs-keyword">if</span> (x2()) { y3();y8(); }
        <span class="hljs-keyword">if</span> (x1()) { y3();y7(); nState = <span class="hljs-number">4</span>; }
        <span class="hljs-keyword">if</span> (x4()) { y3();y9(); nState = <span class="hljs-number">5</span>; }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
        <span class="hljs-keyword">if</span> (x3()) { y1();y6(); nState = <span class="hljs-number">2</span>; }
        <span class="hljs-keyword">if</span> (x2()) { y1();y8(); nState = <span class="hljs-number">3</span>; }
        <span class="hljs-keyword">if</span> (x1()) { y1();y7(); }
        <span class="hljs-keyword">if</span> (x4()) { y1();y9(); nState = <span class="hljs-number">5</span>; }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
        <span class="hljs-keyword">if</span> (x3()) { y5();y6(); nState = <span class="hljs-number">2</span>; }
        <span class="hljs-keyword">if</span> (x1()) { y5();y7(); nState = <span class="hljs-number">2</span>; }
        <span class="hljs-keyword">if</span> (x2()) { y5();y8(); nState = <span class="hljs-number">3</span>; }
        <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::MooreAction</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">//    return;</span>
    <span class="hljs-built_in">string</span> strState = FGetState();
    <span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"1"</span>)	{ y6(); }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"2"</span>)	{ y7(); }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"3"</span>)	{ y8(); }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"4"</span>)	{ y7(); }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"5"</span>)	{ y9(); }<font></font>
}<font></font>
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::digitButtonPressed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> button)</span>
</span>{<font></font>
    transitionButton = <span class="hljs-keyword">static_cast</span>&lt;Buttons&gt;(button); nTypeButtons = <span class="hljs-number">1</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::operationButtonPressed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> button)</span>
</span>{<font></font>
    transitionButton = <span class="hljs-keyword">static_cast</span>&lt;Buttons&gt;(button); nTypeButtons = <span class="hljs-number">2</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::s1Entered</span><span class="hljs-params">()</span>
</span>{<font></font>
    Rf = <span class="hljs-number">0</span>; Rb = <span class="hljs-number">0</span>; Op =  opNone;
    <span class="hljs-keyword">static_cast</span>&lt;CDlgCalculator*&gt;(<span class="hljs-keyword">this</span>-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::s2Entered</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">if</span> (Rf &lt; <span class="hljs-number">9999999</span>) {<font></font>
        Rf = Rf*<span class="hljs-number">10</span> + transitionButton;
        <span class="hljs-keyword">static_cast</span>&lt;CDlgCalculator*&gt;(<span class="hljs-keyword">this</span>-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf);<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::s3Entered</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">if</span> (Rb != <span class="hljs-number">0</span>) {<font></font>
        doOp(Op);<font></font>
        <span class="hljs-keyword">static_cast</span>&lt;CDlgCalculator*&gt;(<span class="hljs-keyword">this</span>-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf);<font></font>
    }<font></font>
    Rb = Rf;<font></font>
    Op = transitionButton;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::s3Exited</span><span class="hljs-params">()</span>
</span>{<font></font>
    nTypeButtons = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (transitionButton &gt; digit9 &amp;&amp; transitionButton &lt; opCancel ) {<font></font>
        doOp(transitionButton);<font></font>
        Rb = <span class="hljs-number">0</span>;<font></font>
        Op = transitionButton;<font></font>
        <span class="hljs-keyword">static_cast</span>&lt;CDlgCalculator*&gt;(<span class="hljs-keyword">this</span>-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf);<font></font>
    } <span class="hljs-keyword">else</span>  {<font></font>
        Rf = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::s5Entered</span><span class="hljs-params">()</span>
</span>{<font></font>
    doOp(Op);<font></font>
    Op = opNone;<font></font>
    Rb = Rf;                <span class="hljs-comment">// added by me</span>
    <span class="hljs-keyword">static_cast</span>&lt;CDlgCalculator*&gt;(<span class="hljs-keyword">this</span>-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::s5Exited</span><span class="hljs-params">()</span>
</span>{<font></font>
    nTypeButtons = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (transitionButton &lt;= <span class="hljs-number">9</span>) {<font></font>
        Rb = <span class="hljs-number">0</span>;<font></font>
        Rf = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::doOp</span><span class="hljs-params">(Buttons op)</span>
</span>{
    <span class="hljs-keyword">switch</span> (op) {
    <span class="hljs-keyword">case</span> opPlus:<font></font>
        Rf = Rf + Rb;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> opMinus:<font></font>
        Rf = Rb - Rf;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2には3つの変換テーブルが含まれています（2つはコメント化されています）。</font><font style="vertical-align: inherit;">これは、コメントを削除したクラスの動作を、メソッドやプロパティに影響を与えずに「クリック」で変更できる場合に、専用コントロールの機能が実現される方法です。</font><font style="vertical-align: inherit;">y10メソッドと遷移表の対応する行（コメントSWICHでマークされた行を参照）は、VKPAテクノロジーのフレームワーク内でSWITCHテクノロジー（詳細は[9]を参照）をモデリングするために導入されました。</font><font style="vertical-align: inherit;">この場合、オートマトンの動作は、オートマトンの動作を模倣するSWITCHオペレーターの循環呼び出しによってモデル化されます（ここでは、VKPaオートマトンは外部環境として機能します）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2。</font><font style="vertical-align: inherit;">パッシブ計算機モデル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクティブな計算機モデルは、常に入力チャネルをスキャンします。変数nTypeButtonsの値がゼロ以外になるとすぐに、これはオートマトンの入力への次のシンボルの到着の印として機能します。その結果、遷移とアクションy1がトリガーされ、nTypeButtons変数がリセットされ、同じシンボルによるマシンの自動再トリガーがブロックされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「アクティブ計算機」モデルとは異なり、イベントマシンは、定義上、入力シンボルを再処理できません。 「オートマトンアプローチをイベントシステムで使用する際の最大の困難」は、アクティブなオートマトンのアクティビティを抑制し、その機能をイベントにリンクすることに帰着しているように見えることは明らかです。作成したばかりの「アクティブ計算機」の例を使用して、パッシブオートマトンに切り替える手順を示します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VKPa環境には、自動プロセスのデバッグのために導入された段階的な操作モードが含まれています。</font><font style="vertical-align: inherit;">ただし、イベントマシンのシミュレーションに使用できます。</font><font style="vertical-align: inherit;">これを行うには、1）オートマトンが配置されるオートマトンスペースを操作のステップバイステップモードに設定します（個別のオートマトンではなく、オートマトンを含むオートマトンスペース全体に注意してください）、および2）イベントの発生の瞬間をスペースの操作の1つの個別のステップの実行に関連付けます。</font><font style="vertical-align: inherit;">リスト3はこれを行う方法を示しており、モデルに加えられた変更のみを反映しています（クラスヘッダーは変更されません）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト3. FCalculatorクラスの最終的なバリアント</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">static</span> LArc TBL_Calculator[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,	<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,	<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,	<span class="hljs-string">"1"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y11"</span>),			<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span><font></font>
...<font></font>
};<font></font>
...<font></font>
<span class="hljs-comment">//  </span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCalculator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{<font></font>
    pNet = GetPointerToNet();           <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (pNet) {
        <span class="hljs-built_in">string</span> str = pNet-&gt;strName;     <span class="hljs-comment">//   </span>
        <span class="hljs-comment">//  - </span>
        pSV = <span class="hljs-keyword">this</span>-&gt;pTAppCore-&gt;pSetVarSetting-&gt;GetAddressVar(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(str.c_str()));<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
...<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCalculator::x12</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!pNet) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (!pSV) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
...<font></font>
<span class="hljs-comment">//    step-by-step</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y11</span><span class="hljs-params">()</span> </span>{ pSV-&gt;bIfStepByStep = <span class="hljs-literal">true</span>; }
<span class="hljs-comment">//  </span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::y12</span><span class="hljs-params">()</span> </span>{ FCreationOfLinksForVariables(); }        <span class="hljs-comment">//</span><font></font>
...<font></font>
<span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::digitButtonPressed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> button)</span>
</span>{<font></font>
...<font></font>
    pSV-&gt;bIfStopAllTasks = <span class="hljs-literal">false</span>;   <span class="hljs-comment">//     </span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCalculator::operationButtonPressed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> button)</span>
</span>{<font></font>
...<font></font>
    pSV-&gt;bIfStopAllTasks = <span class="hljs-literal">false</span>;   <span class="hljs-comment">//     </span><font></font>
}<font></font>
...<font></font>
</code></pre><br>
<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、最初に、追加の[初期]状態が導入されます。この状態では、マシンが配置されているスペースへのリンクと、スペースのプロパティ（動作モードを含む）を決定するオブジェクトへのリンクがチェックされます。</font><font style="vertical-align: inherit;">Ehはy12のアクションを形成します。</font><font style="vertical-align: inherit;">リンクが設定されると、オートマトンスペースの段階的な操作モードがインストールされ、計算機モデルの[以前の]初期状態に移行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、モデルは、空間操作の段階的なモードで動作します。</font><font style="vertical-align: inherit;">1つのステップの起動により、次の文字の入力に関連付けられたイベントハンドラーに挿入されたコードが実装されます（digitButtonPressedメソッドとoperationButtonPressedメソッドに加えられた変更については、リスト3を参照してください）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.なぜですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D.ハレルのより高度なイベントモデルがあるとしたら、なぜそれを発明するのか。そして、それがUML、Stateflow、Qtライブラリなどで実行された場合、どのように異なる考え方をするか。等その欠陥についてはそれほどパニックはありません。さて、彼らは信号イベントを呼び出して、アクティブマシンをパッシブマシンに変えました...そして、彼らの言うように、モデルが古典的なミリ/ムーアマシンと正式に同等である場合、どうやってそれを信じないのですか？そして、そうです、これらすべての陳述が信仰に基づいてのみ取られれば...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの開始に取り掛かります（これはまさに上記で行ったものです）。古典的な構造オートマトンには、たとえば、多くの入力チャネルがあり、それぞれに信号が関連付けられており、同時に/並列に処理できます。しかしUMLは、「各オブジェクトは一度に1つのイベントしか処理できない」と述べ、「2つのイベントが同時に発生した場合でも、オブジェクトは一度に1つずつ処理する」と述べています[10]。したがって、定義レベルでは、信号とイベントは同等ですが、モデルの遷移を実装する過程でのどかな状態が崩れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語やテクノロジーをテスト/学習し始める例を考えてみましょう。</font><font style="vertical-align: inherit;">それは要素モデルのソフトウェア実装に関するものであり、そうではありません。</font><font style="vertical-align: inherit;">構造レベルでは、2つの入力チャネルと1つの出力を持つ「ブラックボックス」に対応し、アルゴリズムレベルでは、図1に示すオートマトンに対応します。</font><font style="vertical-align: inherit;">4. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/7d/ve/6q7dve1toup6onrda9kkjsqzg2u.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図 </font><font style="vertical-align: inherit;">4. AND-NOT要素のオートマトンモデル</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
通常の手続き型モデルの作成方法（リスト4を参照）またはCPSUでオートマトンを実装する方法（リスト5を参照）は理解できますが、Qtライブラリのイベントオートマトンに基づいてこれを繰り返す方法はあまり明確ではないため、状態「1」から状態「0」への遷移を実装する際の問題。複数のイベントを同時に分析する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト4. AND-NOT手続きモデルのオブジェクト実装</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト4. AND-NOT手続きモデルのオブジェクト実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">INE</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	INE() {}<font></font>
	~INE(<span class="hljs-keyword">void</span>);
	<span class="hljs-keyword">bool</span> bX1, bX2, bY;
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> bY = !(bX1&amp;&amp;bX2); }<font></font>
};<font></font>
</code></pre><br>
<br>
</div></div><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト5. AND-NOTオートマトンモデルのオブジェクト実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">LArc T_INE[] = {<font></font>
	LArc(<span class="hljs-string">"s1"</span>, <span class="hljs-string">"s0"</span>, <span class="hljs-string">"x1x2"</span>, <span class="hljs-string">"y1"</span>),		<font></font>
	LArc(<span class="hljs-string">"s0"</span>, <span class="hljs-string">"s1"</span>, <span class="hljs-string">"^x1"</span>,  <span class="hljs-string">"y2"</span>),		<font></font>
	LArc(<span class="hljs-string">"s0"</span>, <span class="hljs-string">"s1"</span>, <span class="hljs-string">"^x2"</span>,  <span class="hljs-string">"y2"</span>),		<font></font>
};												<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ine</span> :</span>	<span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	Ine(<span class="hljs-built_in">string</span> strNam = <span class="hljs-string">"-"</span>): LFsaAppl(T_INE, strNam)<font></font>
    {}<font></font>
	~Ine(<span class="hljs-keyword">void</span>);
	<span class="hljs-keyword">bool</span> bX1, bX2;
<span class="hljs-keyword">protected</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> bX1; }
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> bX2; }<font></font>
};<font></font>
</code></pre><br>
<br>
</div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、オートマトンクラスQtのフレームワーク内のAND-NOT要素のイベントモデルの実装が、Habrovitesの「宿題」になるようにします。 Stateflowでの彼女の決定は、「ケーキのチェリー」としてのみ引用できます。それは図に示されています。 5.ここではStateflowリリーフが使用され、イベントで遷移をマークできません。イベントの名前が指定されていない場合、イベントが発生すると遷移が発生します（[13]の遷移ラベルの例を参照）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_9/j7/4e/_9j74efmsk0ema7itfdezvpmfca.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 5. StateflowのAND-NOT要素のオートマトンモデル</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Stateflowのオートマトンはハイブリッド（アクティブ-パッシブ）オートマトンモデルです。</font><font style="vertical-align: inherit;">確かに、イベントがない場合にマシンがどのように動作するかは明らかではありません。</font><font style="vertical-align: inherit;">イベントを見越して「フリーズ」すると想定できます。</font><font style="vertical-align: inherit;">そして、そうでない場合はどうなりますか？</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">最終的には、オートマトンのアクティブモデルよりもパッシブである可能性が高くなります。</font><font style="vertical-align: inherit;">見た目だけでは後者と区別するのは難しいですが。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5。結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントに関しては、アクティビティにより、従来のオートマトンモデルの実装は、同期オートマトンモデルよりも好ましいように見えます。自動プログラミング全般について話す場合、Stateflow拡張パッケージは、まったく異なる種類のプログラミングが何であるかを示しています。しかし、残念ながら、これまでのところ、 Stateflow計算モデルが原因で問題が残っていますが、これは基本的にブロック図のままです。これらの理由から、オートマトンとともに、Statefowのビジュアルプログラミングもフローチャートの表記法で表されているようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際の自動プログラミングがどこにあり、どこがその模倣であるかを理解することは、私たちの主な目標の1つです。前回の記事[5]では、提起された基本的なタスクの1つを解決しました。オートマトンプログラムの概念を定式化しました。次に、プログラム管理モデルの定義に対処する必要があります。これは有限オートマトンであり、プログラマーにとって効果的で便利なものでなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントを扱って、私たちはそのような仕事の基礎を築きました。</font><font style="vertical-align: inherit;">今後の記事では、D。Harelによって提案されたモデルの詳細をすでに理解しているでしょう。</font><font style="vertical-align: inherit;">少し前に進むと、端的に言えば、彼女はオートマトンの理解を歪めました。</font><font style="vertical-align: inherit;">しかし、その一方で、当然のことながら、プログラマーを引き付ける古典的なモデルの枠組みの中で効果的な自動プログラミングを形成することができなかった問題を明らかにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以上のことから、少なくともイベントのレベルでは、古典的なオートマトンには問題がないことがわかりました。</font><font style="vertical-align: inherit;">さらに理解します...とりあえず、これはほんの始まりにすぎません。</font><font style="vertical-align: inherit;">私たちは多くの興味深いことを待っています。そして、オートマトンの古典的な理論を超えないように注意してください。</font><font style="vertical-align: inherit;">真に自動化されたプログラミングが必要な場合、これは非常に重要です。</font><font style="vertical-align: inherit;">成功をお祈りします！</font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Borovsky A.N. Qt4.7。実用的なC ++プログラミング。 -SPb。：BHV-Petersburg、2012。-496 p。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. BUCH G.、RAMBO J.、JACOBSON I. UML。ユーザーマニュアル。第二版。赤出宮IT：モスクワ、2007。-493 p。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Shalyto A. A.自動プログラミングに関する新しい講義。 2019、[電子リソース]、アクセス</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</font></a><font style="vertical-align: inherit;">、無料。ヤズ。ロシア（治療日2019年12月5日）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Stateflow。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.mathworks.com/products/stateflow.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、無料。ヤズ。英語（発行日7.01.2020）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.オートマトンプログラムのモデルとしてのチューリングマシン。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/481998</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、無料。ヤズ。ロシア（発行日7.01.2020）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. Melikhov A.N.指向グラフと有限状態機械。 -M。：1971年、ナウカ。-416ページ。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. KUDRYAVTSEV VB、Aleshin S.V.、PODKOLZIN A.S.オートマトンの理論の紹介-M：科学。 Ch。 ed。物理演算lit.、1985。-320 s。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8. Tukkel N.I.、Shalyto A.A.イベントシステムのプログラミング時のオートマトンの実装。 「プログラマー」、2002年。 C.74-80。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9. Polikarpova N.、A。Shalyto A. Automatonプログラミング。第二版、サンクトペテルブルグ：ピーター、2011。-176 p。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10. Rambo J.、Jacobson A.、Butt G. UML：特別な参照。 -サンクトペテルブルグ：ピーター、2002。-656 p。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11.ゴマH. UML。リアルタイムシステム、並列および分散アプリケーションの設計：あたり。英語から-M。：DMK Press、2002.-2002.-704 p。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
12. SHALYTO A.A. </font><font style="vertical-align: inherit;">SWITCHテクノロジー。</font><font style="vertical-align: inherit;">ロジック制御タスクのアルゴリズム化とプログラミング。</font><font style="vertical-align: inherit;">サンクトペテルブルク：ナウカ、1998.628 s。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13. Rogachev G.N. </font><font style="vertical-align: inherit;">Stateflow表記。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bourabai.kz/cm/stateflow13.htm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、無料。</font><font style="vertical-align: inherit;">ヤズ。</font><font style="vertical-align: inherit;">ロシア </font><font style="vertical-align: inherit;">（上訴日01.10.2020）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja483598/index.html">さらに音楽的なイースターエッグ：注意深いリスナーへのプレゼントについて話し続けます</a></li>
<li><a href="../ja483600/index.html">Androidを解放する</a></li>
<li><a href="../ja483602/index.html">DefCon 27カンファレンス：電子バッジ作成の舞台裏。パート2</a></li>
<li><a href="../ja483604/index.html">イリジウム：家庭で衛星コンステレーション信号を受信して​​デコード</a></li>
<li><a href="../ja483608/index.html">画像ベースの分類器ソリューションの境界の視覚化</a></li>
<li><a href="../ja483612/index.html">テスラのドライバーがオートパイロットで運転中に歯を磨いたとして罰金を科された</a></li>
<li><a href="../ja483614/index.html">ロボット工学クラブでの盗難と戦う方法</a></li>
<li><a href="../ja483616/index.html">Lacmusプロジェクト：コンピュータービジョンが失われた人々を救う方法</a></li>
<li><a href="../ja483618/index.html">WIMPインターフェイスとは何ですか？なぜそれがまだ残っているのですか？</a></li>
<li><a href="../ja483624/index.html">Yandex.Taxiとの競争：プログラミング選手権のバックエンドトラックの分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>