<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏻 🙅🏾 👏🏿 Lista linear multithread: problema de existência de elemento, aprimoramento de produtividade e relação STL ✳️ 😪 🚛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá queridos visitantes de Habr! 
 
 Este artigo focará em uma lista vinculada, multithreading e C ++. Percebo imediatamente que havia toda a chance d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lista linear multithread: problema de existência de elemento, aprimoramento de produtividade e relação STL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá queridos visitantes de Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo focará em uma lista vinculada, multithreading e C ++. Percebo imediatamente que havia toda a chance de colocar esse trabalho na prateleira e usá-lo em um pequeno número de projetos pessoais. Em vez disso, ainda decidi colocá-lo na corte do público - de repente, parece realmente útil ou interessante para alguém. Além disso, se alguém já conseguiu fazer algo assim, indique esses materiais para mim, por favor. No entanto, não importa como eu tentei pesquisar neste tópico, todas as tentativas foram malsucedidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também observo que não se trata da lista vinculada clássica, mas do meu repensar criativo do uso dessa estrutura de dados em um ambiente com vários segmentos. Eu estava pensando em um cenário de acesso intensivo desordenado a listas multithread. Isso significa que qualquer thread a qualquer momento, independentemente de outras, pode acessar a lista e executar as operações necessárias. Se ele apenas adiciona ou altera elementos, isso não é tão ruim. Se ele também remover os elementos, várias características interessantes podem surgir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este projeto, no qual eu participei como hobby e autodesenvolvimento, por várias razões, durou muito tempo. </font><font style="vertical-align: inherit;">Além disso, enquanto eu trabalhava nele, estudei intensamente: o projeto começou sem o conhecimento e a compreensão do STL e foi projetado de acordo, usando apenas os meios internos da própria linguagem C ++. </font><font style="vertical-align: inherit;">No entanto, eu o modifiquei seriamente, levando em consideração o STL e até o STL. </font><font style="vertical-align: inherit;">O que eu consegui com isso, julgue você, queridos leitores.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para uma compreensão mais completa do material descrito aqui, você precisará ler os seguintes livros:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - "Design Moderno em C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - “Windows via C / C ++, Programação Visual C ++”.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - “Biblioteca Padrão C ++. </font><font style="vertical-align: inherit;">Guia de referência. </font><font style="vertical-align: inherit;">Segunda Edição ”ou livro similar no STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de linhas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma lista linear é uma estrutura de dados conhecida que tem sido usada desde a época da linguagem C e anterior. Seu elemento é um determinado objeto na memória que possui conexões com um ou dois elementos semelhantes vizinhos - eis um exemplo para uma lista duplamente vinculada:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;…   …&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consequentemente, a lista em si é um certo (sub) programa que executa manipulações com esses elementos. </font><font style="vertical-align: inherit;">Como regra, é conhecido um ponteiro para o início e, opcionalmente, para o final da lista: basta, a partir do primeiro elemento, passar por todos os seus elementos até o fim. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, estou descrevendo informações já bem estudadas e conhecidas: era um programa educacional para aqueles que desconheciam completamente. </font><font style="vertical-align: inherit;">Para detalhes, por exemplo, você pode entrar em contato aqui: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista linear (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A biblioteca STL possui um contêiner maravilhoso std :: list (lista duplamente vinculada), bem como seu twin-std :: forward_list (lista vinculada unicamente). </font><font style="vertical-align: inherit;">Ou seja, se você não está interessado em como a lista é organizada e funciona, e deseja usá-la apenas para suas tarefas, os contêineres propostos são sua opção.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas há uma coisa, mas ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Repito que, quando comecei a analisar esse tópico, eu faria tudo, contando apenas com as ferramentas internas do C ++ sem nenhum suporte ao STL. </font><font style="vertical-align: inherit;">O valor do que aconteceria seria menor se eu ainda decidisse falar sobre isso aqui. </font><font style="vertical-align: inherit;">Mas, por outro lado, eu estava completamente livre de quaisquer conceitos ou limitações da biblioteca e, portanto, não estava vinculado a nada e procurei abordagens com mente aberta e independência.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, em um passado distante, a grande maioria dos computadores era de núcleo único e processador único. A lista linear era uma estrutura de dados relativamente simples e transparente, e trabalhar com ela não causou nenhuma dificuldade específica. Agora, mesmo os smartphones se tornaram multi-core. Sob condições de multithreading, mesmo uma estrutura tão simples como uma lista vinculada é seriamente complicada. Garantir que a operação correta no modo multithread geralmente complique seriamente qualquer programa, isso é um fato conhecido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tome um cenário abstrato de trabalho intensivo com uma lista de threads diferentes: cada um deles pode adicionar, excluir, alterar elementos etc. em um momento completamente arbitrário. Por um lado, o trabalho com a lista nesse caso deve ser principalmente seguro: se houver alguma violação de dados e comportamento indefinido do programa, essa será uma solução completamente inadequada. Por outro lado, gostaria muito de trabalhar com ele o mais rápido possível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver o primeiro problema, a lista obviamente terá que ser bloqueada de alguma forma, além de sincronizar o acesso a ela. O segundo problema - desempenho - é adiado por enquanto.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo considera apenas o bloqueio da lista inteira por um fluxo para acesso exclusivo do fluxo a ele. Outras opções pareciam duvidosas, por exemplo, pelos seguintes motivos. Suponha que tenhamos uma lista duplamente vinculada e decidimos remover o item dela. Para fazer isso, você deve bloquear o próprio nó, bem como o anterior e o próximo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exato momento, antes do início da operação, outro encadeamento exclui apenas, por exemplo, o nó anterior. Bloqueamos o removido e paramos de aguardar o lançamento do nó anterior bloqueado por outro encadeamento. E ele está impedido de esperar o próximo por ele, ou seja, nosso nó excluído. É isso, é um impasse. Portanto, esse método não é confiável.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se seus encadeamentos não armazenam ponteiros (ou iteradores) para nós específicos, a tarefa é extremamente simplificada. De fato, você só pode fazer com ferramentas STL. O fluxo bloqueia a lista, refere-se a qualquer elemento nela (por exemplo, do início, do fim ou pesquisando nela de acordo com alguns critérios), processa ou remove esse elemento, adiciona novos elementos sem salvar links para eles, e depois completa a lista. Tudo isso - bloqueando exclusivamente o acesso à lista em um encadeamento, possuindo-o para a duração das operações necessárias. Nesse caso, é perfeitamente lógico usar std :: list e recursos de bloqueio de biblioteca. Por tudo isso, deve-se observar que, enquanto seu thread faz todo o trabalho necessário, outros threads param de esperar, ou seja, o trabalho com a lista será realizado no modo de thread único.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu considerei outro cenário mais complexo, quando um thread armazena um ponteiro ou iterador no elemento de que precisa. </font><font style="vertical-align: inherit;">Por exemplo, seu programa trabalha em alguns cálculos complexos, obtendo os dados iniciais do item da lista e, após o processamento, atualiza seu valor, adicionando os resultados do cálculo. </font><font style="vertical-align: inherit;">No entanto, outros threads também têm acesso à mesma lista. </font><font style="vertical-align: inherit;">Não fiz suposições sobre a natureza do aplicativo: outro thread pode excluir facilmente esse elemento por algum motivo. </font><font style="vertical-align: inherit;">Ou mova-o para outro lugar. </font><font style="vertical-align: inherit;">Portanto, trabalhar com uma lista se torna problemático não apenas pelos motivos usuais de multithreading e sincronização.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema da existência de um elemento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual é a diferença fundamental entre uma lista e, digamos, uma matriz? Em um </font><font style="vertical-align: inherit;">arranjo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distribuído</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de itens da lista. Todos os elementos da matriz estão localizados em uma única área de memória. Mesmo que você armazene um ponteiro em alguns de seus elementos, você tem certeza de que o acesso ao endereço estará correto (é claro, se a matriz não foi movida na memória para outro local com uma extensão de seu tamanho, por exemplo). Se o elemento que você precisa for excluído ou movido para outro encadeamento, basta ir para o endereço anterior, você entenderá por alguns sinais que o elemento que você precisa não está aqui, tente procurá-lo etc. Obviamente, o programa deve apoiar essa oportunidade com antecedência. Mas, em qualquer caso, seu funcionamento permanecerá correto enquanto você estiver nos limites de memória corretos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma situação completamente diferente ocorre no caso de uma lista (assim como no caso de uma árvore, gráfico - qualquer estrutura de dados com elementos distribuídos). Se um elemento de acordo com o seu ponteiro foi excluído em outro segmento, você nem saberá sobre ele e, se tentar acessar o endereço, receberá uma violação de acesso (na melhor das hipóteses). Mesmo que não seja realmente excluído da memória (por exemplo, se ponteiros inteligentes forem usados), ele será excluído da lista, ou seja, não fará parte disso. Você também não saberá disso. O trabalho correto com a lista está quebrado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao mesmo tempo, um intenso trabalho multithread com a lista cria cenários absolutamente fantásticos. Você pode até ter certeza de que está tudo bem com seu elemento e um ponteiro para ele - até acessar alguma função de lista para trabalhar com ele.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemplo. Deixe que haja uma parte da lista e um ponteiro para o nó, que denominamos (#), seja transferido para algum método da lista de funções, enquanto os nós associados a ela serão indicados por números relativos a ele. No momento em que a função é chamada, sabe-se que esse elemento existe e o ponteiro para ele está correto, ou seja, o estado da lista nessa área é: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, deixe o nó (#) ser passado como parâmetro para alguma função da lista. Essa função, como sempre, é bloqueada enquanto aguarda o acesso a ela. Enquanto ela esperava, três threads trabalharam à sua frente, excluindo o nó (#) junto com os adjacentes para que isso acontecesse: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, outros 5 threads inseriram mais 5 elementos na lista, começando com (-2). Denotamos os novos elementos como (nN), onde N é o número relativo entre os cinco, começando do zero:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, nosso fluxo é chamado, que foi chamado com (#). A questão é: o que ele deve fazer nesse caso, depois que tudo (#) se foi? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resposta: tudo depende da operação, bem como do cenário para o uso da lista. No entanto, como estamos considerando o caso mais geral sem restrições, algumas suposições gerais podem ser feitas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se esta for uma operação de exclusão, basta verificar se o item especificado está presente na lista. Caso contrário, ele já foi excluído e nada mais precisa ser feito. Se sim, exclua. Da mesma forma, para a operação de ler / alterar o conteúdo do nó: se o nó for excluído, já não há nada para ler / modificar. Mas os maiores problemas surgem com as operações de inserção de um novo nó, bem como com a mudança para o próximo / anterior. Por um lado, o nó especificado não está mais lá e a falha pode ser retornada. Por outro lado, o nó deve ser inserido e essa situação pode ocorrer a qualquer momento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a prioridade (para o caso geral) ainda é a segurança e a confiabilidade, e somente a velocidade, então, obviamente, quando o thread finalmente conseguiu o tempo de operação dentro da função, é necessário estabelecer o fato da presença de um elemento na lista: ele existe ou não existe? Isso resolve um problema: pelo menos, não interromperemos a lista inteira se não houver um nó solicitado e evitaremos erros de acesso à memória a esse respeito. Mas isso não resolve o problema de inserção e transições: não está claro onde inserir um novo nó e sair de um já excluído.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução para o problema da existência do elemento será discutida em detalhes abaixo. </font><font style="vertical-align: inherit;">A questão do que fazer quando descobrimos que o elemento não está mais lá, mas é muito necessário, está além do escopo deste artigo, pois depende inteiramente do algoritmo do trabalho usando o programa list. </font><font style="vertical-align: inherit;">Obviamente, ele deve incluir esses cenários e as reações correspondentes a eles: por exemplo, se não houver elemento, vá para o topo da lista ou execute outra operação. </font><font style="vertical-align: inherit;">A principal coisa que precisa ser garantida nessa situação é a operação correta e segura da lista, bem como a notificação de tais situações.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa direta de itens</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem mais simples e direta é verificar a presença de um elemento na lista passando por ele sequencialmente em busca de um determinado elemento. Essa. apenas procurando o elemento fornecido. Se ele estiver na lista, trabalhamos com ele. Caso contrário, dependendo da função, saímos com sucesso ou fracasso e deixamos o programa de chamada decidir o que fazer nessa situação. O principal é que o trabalho com a lista, em qualquer caso, estará correto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse método é seguro e totalmente funcional, mas, especialmente para listas grandes, leva a uma queda catastrófica no desempenho. De fato, trabalhar com uma lista acaba sendo de thread único: a lista fica bloqueada durante a pesquisa de um determinado elemento e outros threads não podem acessá-lo. Em segundo lugar, as despesas gerais aumentam acentuadamente - em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as operações com a lista precisam ser verificadas para ver se há um elemento necessário no momento da operação e uma grande parte do tempo é gasta não em trabalho útil, mas na verificação da presença de um elemento. </font><font style="vertical-align: inherit;">No entanto, essa abordagem simples e direta é bastante adequada para listas de pequeno volume e operações não muito intensivas, além de uma primeira aproximação para resolver o problema da existência de um elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas e se tivermos uma lista com um grande número de elementos, e trabalhar com ela for muito intenso: muitos threads constantemente adicionam, alteram e excluem elementos dela? </font><font style="vertical-align: inherit;">Existe alguma maneira de acelerar isso de alguma forma?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memória ou desempenho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há um fato bem conhecido de que um aumento na memória usada pelo programa pode aumentar a velocidade do programa. Por exemplo, um programa faz uso pesado dos resultados de alguns cálculos. Em vez de executá-los novamente, você pode calcular tudo antecipadamente e salvar seus resultados em alguma tabela ou matriz. Em seguida, o programa simplesmente acessa a célula desejada na tabela e recebe imediatamente o valor desejado, o que acelera significativamente seu trabalho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É essa abordagem que eu usei no caso da lista. Crie um bitmap. Adicione às informações de serviço de cada um de seus elementos, além do ponteiro necessário para o próximo e, opcionalmente, o elemento anterior, mais dois campos novos: o primeiro é seu número exclusivo nessa lista e o segundo é um ponteiro para a própria lista. Agora, quando um elemento é criado, ele recebe um número único e define a unidade no bitmap no índice correspondente. Quando um elemento é excluído, esse bit é redefinido. O número do elemento criado está aumentando constantemente cada vez que um novo elemento é criado - os bits zerados já utilizados não são reutilizados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, quando é necessário verificar a presença de um determinado elemento, em vez de procurá-lo linearmente em toda a lista, um bitmap é simplesmente acessado pelo índice desse elemento, e o fato de sua presença é imediatamente estabelecido e por um tempo constante, independentemente do tamanho da lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este método permite alcançar o desempenho máximo, no entanto, possui sérias desvantagens. Primeiro, você precisará alocar memória para toda a matriz de uma só vez, parte dos bits que podem não ser necessários durante o programa, mas essa memória pode ser usada para outras necessidades. Esse problema e uma maneira de suavizar as excedências de memória serão discutidos abaixo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda desvantagem é mais séria e interessante - cada novo item da lista é criado por um número crescente e monótono. Isso significa que mais cedo ou mais tarde os bits livres da matriz serão esgotados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste ponto, infelizmente, você precisa parar, bloquear a lista e começar a servi-la. Essa. comprima os bits desta matriz, removendo todos os zero bits dos elementos intermediários da lista excluídos anteriormente, deixando apenas bits para os elementos que realmente existem no momento, mudando todos esses bits para o início da matriz. Teremos que percorrer a lista inteira novamente e, no modo de thread único, reescrevendo todos os índices para cada elemento. O benefício óbvio disso em comparação com a abordagem anterior é que, neste caso, apenas </font><b><font style="vertical-align: inherit;">uma</font></b><font style="vertical-align: inherit;"> será feita.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vezes por um longo período de tempo. </font><font style="vertical-align: inherit;">Além disso, a lista pode continuar funcionando como antes no modo extremamente rápido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, não quero dizer que os nós foram adicionados apenas à lista, porque </font><font style="vertical-align: inherit;">neste caso, todos os bits da matriz serão únicos. </font><font style="vertical-align: inherit;">Estou considerando um cenário em que itens são intensa e arbitrariamente excluídos e adicionados. </font><font style="vertical-align: inherit;">Essa. </font><font style="vertical-align: inherit;">o número total de itens da lista desde o início de seu trabalho pode mudar um pouco. </font><font style="vertical-align: inherit;">Naturalmente, a questão de escolher o tamanho da matriz depende da natureza do programa. </font><font style="vertical-align: inherit;">Você também pode sempre criar uma nova matriz de um volume maior se o tamanho da atual não for suficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando zero bits de elementos excluídos anteriormente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode fazer outra coisa: ao criar um elemento, procure o primeiro bit zero desde o início do bitmap. Isso otimiza o consumo de memória, mas leva a uma queda no desempenho: agora, novamente, toda vez que você cria um novo elemento, você terá que fazer um trabalho adicional - examine a matriz em busca de um bit livre. Mas, em comparação com a verificação da presença de um elemento, visualizando diretamente a lista, o ganho é óbvio: veremos a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos adjacentes e cada elemento dessa matriz contém muitos bits, isto é, </font><font style="vertical-align: inherit;">processamos muitos nós de lista por vez (64 bits para sistemas modernos ou até 128/256/512 se estiver usando SSE / AVX). </font><font style="vertical-align: inherit;">Estamos procurando a primeira palavra que não seja igual à palavra com todos os bits de unidade; depois, procuramos o primeiro bit zero nessa palavra. </font><font style="vertical-align: inherit;">De fato, esse método tem velocidade intermediária entre o anterior e o método de visualização direta.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimização do consumo de memória para bits de matriz desocupados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que assumamos um trabalho longo e intensivo com a lista, alocando uma enorme variedade de bits para ela. Mas aconteceu que, de fato, o programa funcionou de maneira diferente: acessou a lista raramente, executou outras operações que também exigiam memória. Como resultado, obtemos uma matriz quase não utilizada de bits de enormes problemas de volume e memória em outras partes do programa. Pura inconveniência! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Linux, até onde eu sei, resolve automaticamente esse problema (embora desenvolvedores experientes do Linux me permitam corrigi-lo, se houver). Você aloca memória para a matriz, mas, na verdade, o sistema </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não transfere</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essa memória para a matriz </font><font style="vertical-align: inherit;">até que seja realmente necessário. Há uma otimização do uso da memória. O Windows não permite isso. Em vez disso, permite, mas você precisa fazer isso sozinho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aqueles que não estão atualizados, explicarei: sua aplicação (mais precisamente, o processo correspondente a ela), o sistema aloca um </font><font style="vertical-align: inherit;">grande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espaço de endereço virtual</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - até 8 TB para o Windows de 64 bits. A memória física no sistema pode ser muito menor - 8 ou 16 GB no momento para computadores em massa. </font><b><font style="vertical-align: inherit;">Telas do</font></b><font style="vertical-align: inherit;"> sistema operacional</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">endereços de seu espaço de processo virtual para endereços de memória física, fazendo isso de maneira transparente sem o seu envolvimento direto. Naturalmente, a maior parte da memória virtual livre de um processo geralmente está desocupada. Portanto, quando você solicita ao Windows que aloque memória por meios convencionais, ele aloca essa memória simultaneamente no espaço virtual e na memória física. Se você alocar um bitmap de grande volume, corre o risco de ocupar imediatamente toda a memória disponível em sua máquina, sem garantir que essa memória possa ser necessária.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, pode-se agir de maneira diferente: marcar uma grande parte da memória no espaço virtual do processo, mas transferir física para ela somente quando for realmente necessário. </font><font style="vertical-align: inherit;">Isso pode ser feito através do tratamento estrutural de exceções no Windows; para detalhes, consulte o livro de Richter D., Nazar K. - “Windows via C / C ++, Programação Visual C ++”.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seria apenas uma idéia e uma teoria, se eu não tivesse colocado todas essas idéias em prática, e não na forma de um programa experimental simples: eu o fiz o mais cuidadosamente possível para a produção, pretendendo usá-lo em meus projetos reais; portanto, é dessa forma que você precisa e imagine. </font><font style="vertical-align: inherit;">Eu pensei que seria injusto e muito egoísta aplicar o que foi feito no meu número limitado de projetos, se isso pudesse ser útil ou, pelo menos, apenas interessante para um amplo círculo de desenvolvedores. </font><font style="vertical-align: inherit;">Por outro lado, os criadores da biblioteca Boost e outras bibliotecas mais especializadas oferecem seu trabalho a todos de forma absolutamente gratuita. </font><font style="vertical-align: inherit;">Por que não posso fazer o mesmo?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstração - uma lista sem dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividi a lista em dois níveis lógicos. O primeiro nível é uma lista, cada elemento que não contém dados úteis, mas contém apenas informações auxiliares: ponteiros para elementos vizinhos e, opcionalmente, esses dois campos adicionais para acelerar a verificação da presença de um elemento na lista. No entanto, já nesse nível é possível executar todas as operações básicas em uma lista: adicionando e excluindo elementos, dividindo e mesclando listas, etc. De fato, concentrei-me principalmente neste nível. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo nível é adicionar dados reais ao item da lista, além de adicionar novas operações à lista para trabalhar com esses dados. Tudo isso é fornecido em C ++ por herança. Mas os detalhes serão discutidos abaixo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa divisão da implementação em dois níveis fazia sentido: por que levar em conta a disponibilidade de dados específicos se várias operações são completamente independentes desses dados? Para qualquer item da lista, você ainda precisa excluí-los e adicionar novos à lista, além de executar outras operações típicas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comecei com um conceito extremamente simples e descomplicado, retirado da construção da linguagem C. No início do artigo, os ponteiros internos C e C ++ são usados ​​dentro e fora da lista. A única diferença foi que a adição de dados, conforme indicado acima, foi adiada para uma data posterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe existir um elemento da lista sem dados, contendo apenas um ponteiro (ou ponteiros) para o (s) elemento (s) vizinho (s). Em seguida, o código correspondente para ele pode ser representado esquematicamente da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;…m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um elemento para uma lista vinculada individualmente contém em si um ponteiro para o próximo elemento e nada mais. A classe de lista é parametrizada pelo tipo desse elemento, o que implica que esse tipo será alterado no estágio de adição de dados. Ele contém ponteiros para o primeiro e o último elementos internos. Como originalmente eu direcionei esse projeto apenas para Windows, uma seção crítica como SRWLock também foi incluída para bloquear a lista. Em seguida, são definidos os construtores, o destruidor e todas as funções necessárias para trabalhar com a lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta implementação contém dois problemas ao mesmo tempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro é o acesso aberto ao conteúdo das informações de serviço do elemento. Isso significa que, tendo obtido acesso a algum nó, ou seja, tendo um ponteiro para este nó, podemos nos referir diretamente ao elemento seguinte ou anterior.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é inaceitável principalmente porque essa transição está ignorando o bloqueio e, portanto, protegendo a lista. De fato, suponha que, tendo um ponteiro para algum elemento pCurr, salvemos o valor para o próximo elemento relativo a ele no ponteiro pNext da seguinte maneira: pNext = pCurr-&gt; pNext. Depois disso, realizamos algumas operações longas nesse nó pCurr. Ao mesmo tempo, outros threads removeram os seguintes itens da lista relacionados ao pCurr. Após terminar de trabalhar com pCurr, o encadeamento atual passa para o próximo elemento usando o valor antigo armazenado no pNext local e recebe um erro de acesso ou comportamento indefinido, pois o elemento no endereço pNext local não existe mais e você precisa acessar o valor atualizado pCurr-&gt; pNext, se o item atual em pCurr, por sua vez,ainda existe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duas conclusões podem ser tiradas deste exemplo para evitar essa situação:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de fora da lista, vá para o nó próximo / anterior e geralmente faça qualquer trabalho com elementos da lista apenas através de funções (métodos) da classe list que bloqueiam a lista e tornam o acesso à lista seguro;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obter acesso aos elementos o mais rápido possível imediatamente antes de acessá-los (por exemplo, para obter um ponteiro para o próximo elemento pNext = list.GetNext (pCurr) não antecipadamente, mas imediatamente antes que a necessidade de passar para o próximo nó apareça).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É por isso que, para implementar a conclusão do primeiro parágrafo, o acesso a ponteiros para elementos adjacentes a partir do exterior deve ser proibido:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo problema é um pouco mais delicado. Para entendê-lo, a estrutura das classes deve ser descrita em mais detalhes. A classe list é definida como modelo e não funciona com elementos do tipo ListElement_OneLinked, mas com o tipo ListElement, passado como um parâmetro de modelo. Isso é feito para poder criar novos nós com dados dentro da classe. Para fazer isso, você precisa saber o tipo exato de nó que está sendo criado. O tipo exato do nó da lista ainda não é conhecido: ele será determinado posteriormente, juntamente com os dados. A função de criação de elemento aloca memória para ele, inicializa ponteiros e, em seguida, retorna um ponteiro para o elemento criado na função de chamada. Portanto, na função de chamada da classe derivada, será possível inicializar outras propriedades do elemento que são específicas para essa classe e são definidas posteriormente. Em outras palavras,uma definição exata do tipo do nó da lista é deixada para o futuro e, para que a lista funcione corretamente, é importante que seus elementos contenham o ponteiro pNext, o restante não importa até o momento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, com base em ListElement_OneLinked, posteriormente por herança, uma nova classe será criada para o elemento com dados específicos e transmitida para a classe List_OneLinked por meio do parâmetro template. Ao mesmo tempo, uma nova classe derivada será criada com base em List_OneLinked que define ainda mais as operações com esses novos dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, mesmo essa opção não está totalmente correta. Nas versões anteriores da classe list, uma operação de conversão explícita do tipo reinterpret_cast &lt;ListElement *&gt; (...) era usada várias vezes. O fato é que a classe de modelo trabalha com o tipo de parâmetro do modelo ListElement, derivado de ListElement_OneLinked / ListElement_TwoLinked. E nas funções de classe, as variáveis ​​são criadas em expressões do tipo: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E pCurr-&gt; pNext aqui é um ponteiro para ListElement_OneLinked / ListElement_TwoLinked, como membros das classes base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saída: declare uma variável indicando o tipo base explícito ListElement_OneLinked / ListElement_TwoLinked ou faça a conversão explícita no tipo derivado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, mesmo uma definição explícita do tipo de base não está correta, por exemplo, na função de exclusão de lista (limpeza):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você alterar o tipo de ponteiros:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
isso significa que eles serão excluídos pela operação</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
apenas as partes básicas de cada nó da lista, o que está errado. </font><font style="vertical-align: inherit;">Ou, como opção, o ponteiro pCurr precisará ser convertido em seu tipo derivado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, em qualquer caso, não se pode se livrar da transformação explícita reinterpret_cast com uma estrutura de classes, que não é a melhor solução (mais precisamente, o que é realmente ruim). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por esse motivo, para se livrar de tais transformações explícitas, foi decidido alterar a classe base do elemento (para uma lista duplamente vinculada - da mesma forma):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumidamente, isso pode ser descrito da seguinte maneira: o elemento básico da lista contém um ponteiro para outro elemento, mas o tipo desse ponteiro ainda não é conhecido, porque é passado pelo parâmetro do modelo (uma definição exata desse tipo é deixada para o futuro). Em outras palavras: nesta fase, o tipo de nó da lista (ou seja, o que será no final) ainda não foi determinado, será determinado posteriormente. Mas agora mantemos o ponteiro para um elemento do tipo futuro, ainda não conhecido. O tipo resultante do nó da lista é passado aqui como um parâmetro de modelo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, nenhuma conversão é necessária, já que ponteiros do mesmo tipo ListElement são usados ​​em todos os lugares - na classe list e na classe para nós. O ListElement aqui e na classe list é a classe final do item com dados específicos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que agora a classe list tornou-se o mais abstrata possível a partir de seu conteúdo específico: sabe-se apenas que seus nós contêm ponteiros para outros nós e, usando essas informações, todas as operações básicas sobre eles com o bloqueio multithread correspondente são executadas na classe list.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolvendo o problema da existência de um elemento - uma pesquisa simples (versão 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira versão foi extremamente simples e direta e não foi além da estrutura descrita acima. </font><font style="vertical-align: inherit;">Foram utilizados ponteiros internos em C ++, a memória dos elementos foi alocada usando a nova operação e excluída com a exclusão, a lista foi bloqueada na seção crítica contida nela. </font><font style="vertical-align: inherit;">Eu não sabia ou suspeitava sobre os meios da biblioteca STL e também sobre o nível em que eles trazem a programação em C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Já nesta fase, na prática, me deparei com o problema da existência de um elemento descrito anteriormente e percebi que simplesmente bloquear a lista não é suficiente. </font><font style="vertical-align: inherit;">Naveguei pela lista usando as funções apropriadas com todas as precauções, a lista foi bloqueada corretamente, mas o programa ainda travava com êxito em diferentes intervalos. </font><font style="vertical-align: inherit;">Foi então que descobri que a presença de um elemento teria que ser verificada, o que levou a uma mudança na lógica das funções principais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me dar um exemplo da função de adicionar um elemento após um determinado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observa-se que antes de criar um novo elemento, ele verifica se o elemento especificado está presente na lista chamando a função FindElement (...):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complicações adicionais de classes de lista multithread - classes de estratégia (versão 18.02.2019, 27.11.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, o projeto visava estritamente ao Windows. Mas em algum momento pensei: por que não adicionar flexibilidade a ele? Por que apenas janelas? Afinal, a lista foi implementada essencialmente em C ++ puro; no Windows, havia apenas uma coisa: a seção crítica do SRWLock. Naquela época, eu já havia me familiarizado com o conceito de classes de estratégia. Você pode ler sobre isso em detalhes no livro Alexandrescu A. - "Design moderno em C ++". Ele descreve muitas coisas incomuns e surpreendentes que podem ser úteis até agora, apesar do livro já ter 12 anos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma delas são as classes de estratégias. Classes de estratégias, de fato, são mudanças no comportamento de uma classe através de modelos, como B. Straustrup mencionou em seu famoso livro. Somente no livro de Alexandrescu, esse tópico é amplamente divulgado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que sua classe execute uma ação específica. </font><font style="vertical-align: inherit;">Você pode tomar a definição desta ação fora da classe, criar uma classe separada com base nessa ação e passá-la para sua classe de origem como um parâmetro de modelo. </font><font style="vertical-align: inherit;">Isso complica o código, sua leitura e compreensão, mas adiciona flexibilidade à sua classe: para substituir essa ação específica por outra similar, basta escrever outra estratégia semelhante e passá-la à sua classe como parâmetro de modelo. </font><font style="vertical-align: inherit;">O restante do trabalho será realizado pelo compilador.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estratégia de bloqueio</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicando isso à lista descrita, peguei o bloqueio do SRWLock em uma estratégia separada e, em seguida, escrevi várias outras estratégias: na seção crítica usual do Windows, nos mutexes do C ++ STL, etc. </font><font style="vertical-align: inherit;">Então será possível adicionar métodos puramente específicos do Linux. </font><font style="vertical-align: inherit;">Assim, a classe tornou-se adequada não apenas para o Windows, mas eu sempre posso reconfigurá-la rapidamente para o Windows da maneira ideal, apenas especificando a estratégia desejada.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estratégia de memória</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse ponto, também comecei a estudar seriamente o STL e, entre as primeiras ferramentas desta biblioteca, me familiarizei com indicadores inteligentes. </font><font style="vertical-align: inherit;">E então pensei: por que não consigo adicionar suporte a ponteiro inteligente à minha lista? </font><font style="vertical-align: inherit;">Depois, retirei o tipo de ponteiro, além de criar e excluir os dados do item da lista em uma estratégia separada:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma estratégia semelhante para ponteiros inteligentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estratégia de memória utiliza três parâmetros: o tipo do objeto Type, assim como um alocador e removedor de memória. Com base no tipo do objeto, a estratégia cria um tipo de ponteiro para esse tipo - Type * ou std :: shared_ptr, dependendo da estratégia, e também oferece as funções correspondentes para criar e excluir o objeto. Essas funções, se falarmos sobre distribuidores e eliminadores por padrão, criam um objeto através da nova operação Type ou através da função std :: make_shared (...). Tudo isso funciona devido ao fato de a desreferenciação de ponteiro ser a mesma para o ponteiro interno do C ++ e para o std :: shared_ptr inteligente. Obviamente, no caso de uma lista duplamente vinculada e ponteiros inteligentes, para evitar o recurso desagradável dos ponteiros em loop, std :: weak_ptr é usado para ponteiros para o elemento anterior,e no momento da compilação de uma lista duplamente vinculada, dependendo da estratégia de memória selecionada, você escolhe como desreferenciá-la (esse é um novo recurso do C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, agora a lista não cria seus próprios elementos: ela redireciona a chamada para a estratégia correspondente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estratégia de disponibilidade de itens</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, resolvi o problema da existência de um elemento em uma estratégia separada: se a lista precisar verificar a presença de alguns de seus elementos, ela simplesmente redirecionará a chamada para a estratégia correspondente. A primeira abordagem direta e desajeitada se tornou uma estratégia de pesquisa direta do DirectSearch. Em seguida, desenvolvi mais duas estratégias baseadas nas duas abordagens descritas anteriormente com um bitmap na ordem de descrição: SearchByIndex_BitArray e SearchByIndex_BitArray2. Para o Windows, para a possibilidade de ocupar gradualmente a memória com um bitmap enquanto ele é preenchido, ele também adicionou mais duas estratégias: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal e SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como observado anteriormente, para que essas estratégias avançadas funcionem, o item da lista deve conter um índice em um bitmap e um ponteiro para a classe base da lista (veja abaixo), ou seja, </font><font style="vertical-align: inherit;">foi definido da seguinte forma:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlação entre estratégias de memória e estratégias de verificação de elementos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após um exame detalhado, verificou-se que há uma armadilha na relação entre estratégias de memória e estratégias para verificar a presença de um elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que você use ponteiros inteligentes como estratégia de memória, bem como uma estratégia usando um bitmap para verificar rapidamente um item em uma lista. Você exclui um item, a estratégia de memória redefine seu ponteiro. No entanto, esse elemento não é realmente excluído da memória, pois você possui outro ponteiro inteligente em seu programa de chamada. No futuro, você passará para a lista com esse elemento e ela fará a verificação corretamente, referindo-se a seus dados - o índice no bitmap e o ponteiro para a lista. Na verdade, um elemento é excluído da memória apenas quando não há mais nenhum link para ele.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este não é o caso ao usar ponteiros internos do C ++. Nesse caso, a estratégia de memória </font><font style="vertical-align: inherit;">excluirá </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esse item da memória usando a operação de exclusão. No futuro, como no caso anterior, consulte a lista com esse elemento e ele tentará </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acessar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o elemento nesse endereço para ler o índice do bitmap e um ponteiro para a lista. Mas você não pode fazer isso: um elemento já foi excluído da memória! No melhor dos casos, você receberá uma violação de acesso, no pior comportamento indefinido, quando a biblioteca C ++, a biblioteca de tempo de execução ou apenas o sistema operacional gravar lá um valor completamente arbitrário que a lista considera e tenta estabelecer a partir deles o fato da presença de um elemento na lista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, verifica-se que os ponteiros internos são compatíveis apenas com a estratégia de verificação direta do DirectSearch e, nesse caso, os ponteiros inteligentes oferecem não apenas sua segurança inerente, mas também um aumento de desempenho: somente com seu uso podem ser usadas matrizes de bits que aumentam significativamente o trabalho da lista. modo multithread! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantir consistência e eliminar configurações de estratégia incompatíveis, incluí a seguinte verificação em cada classe de lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele compara as classes de estratégia passadas para a lista e, se forem incompatíveis, interrompe a compilação com a saída da mensagem de erro correspondente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceções ou devoluções de erros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, o tratamento de erros da lista era realizado apenas por meio de exceções. </font><font style="vertical-align: inherit;">Mas de alguma forma, em alguns fóruns que não me lembro, li que as exceções tornam o programa mais lento e, para obter o máximo desempenho, você deve usar o retorno de erro tradicional. </font><font style="vertical-align: inherit;">Ele fez isso criando duas novas classes baseadas nas originais, reescrevendo-as para retornar erros.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe base da lista</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A implementação das estratégias acima para verificar a presença de elementos revelou um problema importante. O elemento list, como lembramos, contém, além do número exclusivo nesta lista, também um ponteiro para esta lista: afinal, podemos ter duas ou mais listas no programa, cada uma das quais contém sua própria matriz de bits de sinalizadores para a presença do elemento. Como garantir que esse elemento pertença a essa lista específica e não a outro? Somente armazenando um ponteiro para a lista inteira dentro de cada elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema é que agora, adicionando uma variedade de estratégias à nossa classe de lista, complicamos significativamente seu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Suponha que tenhamos duas listas diferentes com o mesmo tipo de elemento e as mesmas estratégias de memória, mas com estratégias diferentes para bloquear e verificar a presença de elementos nelas. Para o compilador, esses serão dois </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferentes </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> listas. Ponteiro para qual tipo armazenar no elemento? Além disso, a classe para o elemento não sabe de antemão qual estratégia será aplicada; ela deve levar em consideração </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elas </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se também de que a estratégia de bloqueio, a estratégia para verificar a presença de um elemento e até a conectividade (simplesmente conectada ou duplamente conectada) da lista referem-se apenas ao comportamento da própria lista, mas de forma alguma se relacionam aos </font><b><font style="vertical-align: inherit;">dados que</font></b><font style="vertical-align: inherit;"> ela armazena</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas nós, como usuários finais desta classe, estamos interessados ​​nos dados! </font><font style="vertical-align: inherit;">Então, por um lado, usando as classes de estratégias, acrescentamos flexibilidade a nós mesmos e, por outro, complicamos nossas vidas e acrescentamos problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É possível de alguma forma tornar os lobos cheios e as ovelhas seguras? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode. </font><font style="vertical-align: inherit;">Você pode deduzir ponteiros para dados de uma classe (ou seja, de um tipo) de uma lista. </font><font style="vertical-align: inherit;">Além dos dois níveis acima de organização da lista, outro apareceu - zero:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora porque </font><font style="vertical-align: inherit;">são herdadas classes reais de listas; se quisermos acessar os dados da lista, independentemente de seu tipo real, devemos nos referir à sua classe base ListBase. </font><font style="vertical-align: inherit;">Temos acesso ao início e ao fim da lista e, em seguida, trabalhamos com os dados conforme desejamos. </font><font style="vertical-align: inherit;">O tipo específico de lista, bem como a combinação de estratégias usadas nela, não importa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteradores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Já em pleno andamento, trabalhando em estreita colaboração com a STL em um projeto real (não o meu :)), além de continuar estudando em livros, chamei a atenção para o loop for da coleção. </font><font style="vertical-align: inherit;">Afinal, esse ciclo não é apenas parte do STL, ele já se tornou uma parte interna da linguagem. </font><font style="vertical-align: inherit;">Eu pensei que também poderia adicionar suporte para isso no meu projeto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, você precisa adicionar suporte para iteradores, abstraindo da maneira específica de trabalhar com ponteiros e navegando pela lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um exemplo de iterador:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora tornou-se possível escrever da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(…)<font></font>
{<font></font>
      …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O leValue possui um tipo de ponteiro para um item da lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, incluí o suporte ao iterador apenas em listas suportadas por exceção. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O motivo era simples: como o código dentro do loop não está disponível, não é possível lidar corretamente com os erros. </font><font style="vertical-align: inherit;">Tudo o que resta é lidar com as exceções envolvendo o loop em um bloco try. </font><font style="vertical-align: inherit;">Em geral, andar na lista de maneira que outros threads estejam trabalhando intensamente não é uma boa idéia: é melhor bloquear a lista por conta própria e depois passá-la com calma no modo de thread único. </font><font style="vertical-align: inherit;">Mas ainda assim, se por algum motivo você deseja fazer exatamente o mesmo que no exemplo acima, então agora há uma oportunidade para isso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma generalização da estratégia para verificar a presença de um elemento em um contêiner arbitrário; </font><font style="vertical-align: inherit;">iteradores para listas sem exceções</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, eu originalmente planejei (e ainda planejo) criar não apenas uma lista multithread, mas também uma árvore. Para algumas de suas necessidades. O gráfico também é possível, mas, em primeiro lugar, eu não precisava dele e, em segundo lugar, o gráfico é uma coisa complicada com algoritmos muito não triviais, e eu não queria mergulhar nele sem necessidade especial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na versão inicial, a estratégia para verificar a presença de um elemento era orientada apenas para a lista, e suas funções aceitavam um ponteiro para um elemento e um ponteiro para a classe base da lista (ListBase *). Posteriormente, pensei: mas no caso de uma árvore, você precisa fazer exatamente a mesma coisa! Faça uma estratégia separada, mas essencialmente a mesma exatamente?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução foi simples: ignore a lista. </font><font style="vertical-align: inherit;">Isso significava que agora a entrada seria recebida não por ponteiros para elementos, mas por iteradores. </font><font style="vertical-align: inherit;">E as funções se tornarão padronizadas para aceitar ponteiros para um contêiner de qualquer tipo adequado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então agora a função original, por exemplo, registrando uma lista em um bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transformado em uma função de registro de contêiner:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A transição através da lista por ponteiros foi transformada em uma transição através de um contêiner abstrato usando iteradores. </font><font style="vertical-align: inherit;">Agora será suficiente para a árvore implementar seus iteradores, e seu suporte com essas estratégias já será fornecido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso exigia o retorno de iteradores para as listas sem exceções, mas tornando-os inacessíveis do lado de fora e destinados apenas para uso interno.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptador de dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo trabalhado intensivamente com STL, além de digitar, iniciar e estudar programas de treinamento de livros, chamei a atenção para a simplicidade de trabalhar com contêineres STL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, preste atenção ao seguinte código:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu crio um vetor passando o tipo int de que preciso, e é isso! O contêiner está imediatamente pronto para funcionar, se eu não precisar alterar alguns parâmetros adicionais definidos por padrão, o que geralmente não acontece! Para mim, procedendo da organização de três níveis da lista, em cada caso eu precisaria primeiro criar uma nova classe para o item e depois escrever uma classe para a lista com dados, implementando operações específicas para a lista final. Imagine quanto trabalho! E se você precisar criar outra lista para outros dados, precisará fazer tudo novamente ou, em casos extremos, copiar o código anterior, alterando-o levemente. Isso já se assemelha à mesma confusão com a linguagem C e a API do Windows, onde para cada ação elementar você precisa preencher todos os dados necessários para a estrutura e, em seguida, chamar a função desejada. E mantenha tudo isso em menteOu também leia constantemente o MSDN, estudando os argumentos de cada nova função! Rotina e terrivelmente desconfortável!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comecei a procurar maneiras de obter a oportunidade de criar minha lista por analogia com os contêineres STL, para que eu não tivesse que fazer sempre a mesma tarefa: criar uma classe separada para qualquer novo item e, em seguida, uma classe separada para trabalhar com elementos tipo. </font><font style="vertical-align: inherit;">Portanto, havia um adaptador para uma lista com dados de dados. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um adaptador para uma lista com dados é uma classe, nos parâmetros do modelo dos quais você passa imediatamente o tipo de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dados</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> necessário </font><font style="vertical-align: inherit;">, e não o elemento. </font><font style="vertical-align: inherit;">O tipo de elemento, que chamei de tipo composto do elemento, com base nesses dados que ele cria </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sozinho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ponto separado que vale a pena mencionar é o acesso aos dados do item. </font><font style="vertical-align: inherit;">O tipo de elemento contém a operação "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que, se houver um ponteiro para o elemento pElement, para acessar os dados armazenados nele, ele deve ser desreferenciado duas vezes:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once - para acessar um objeto do tipo ListElementCompound_OneLinked pelo ponteiro: ListElementCompound_OneLinked &amp; le = * pCurrElement e uma segunda vez - para acessar dados através da operação '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece muito estranho e atípico, mas supõe-se que você trabalhará não através de ponteiros (para isso você já tinha uma versão inicial pronta), mas através de iteradores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, ao criar uma lista baseada no adaptador, você especifica as estratégias necessárias, como antes. </font><font style="vertical-align: inherit;">Com base em todos os seus parâmetros, o adaptador cria automaticamente os tipos necessários e os passa para a lista interna básica, da qual é herdada. </font><font style="vertical-align: inherit;">Definição geral de classe:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Especialização para a lista com exceções:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece muito volumoso, com vários andares e feio. Eu sei. Mas então essa definição faz automaticamente tudo o que é necessário, sem a participação direta do programador que planeja usá-la. Com a ajuda de std :: conditional_t ​​e std :: is_same_v, a estratégia de verificar a presença de um elemento que você transmitiu é comparada com estratégias de pesquisa direta e, dependendo do resultado, o tipo correspondente do elemento da lista é selecionado: com um índice no bitmap e um ponteiro para a lista ou sem . Isso economizará memória devido a dados adicionais desnecessários dentro de cada nó, se você usar uma estratégia de pesquisa direta.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro da classe, os iteradores específicos a ela são implementados apenas, assim como as funções push_back () / push_front () exigidas por analogia com o STL, que redirecionam as chamadas para a lista multithread de base. </font><font style="vertical-align: inherit;">Você pode adicionar outras funções posteriormente, para que a lista se torne muito semelhante às STLs. </font><font style="vertical-align: inherit;">Mas, ao mesmo tempo, estará com todas as proteções e opções necessárias para aumentar a produtividade em um ambiente multithread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhar com um adaptador de dados começou a se parecer com isso. </font><font style="vertical-align: inherit;">Criando objetos de lista:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você estiver satisfeito com todas as estratégias e parâmetros padrão, a criação de uma lista se tornará muito breve:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, externamente não há absolutamente nenhuma diferença em relação ao STL, exceto que o nome da classe da lista é diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você pode trabalhar com ele da maneira antiga, através das funções da classe base:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, os números de 0 a 3. são adicionados seqüencialmente ao final da lista.Para chegar ao argumento passado ao construtor do tipo criado quando ele é criado, você deve colocar explicitamente os valores dos três primeiros argumentos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, há um certo inconveniente em indicar explicitamente o tipo, mas isso é consequência de uma tentativa de acessar a lista novamente através da função anterior para trabalhar com ponteiros. </font><font style="vertical-align: inherit;">Se você adicionar a função back () ao adaptador, que retorna um iterador, o trabalho com ele não terá esse problema:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após ajustar os iteradores aos requisitos de STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
torna-se possível usar a lista em algoritmos de biblioteca:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
…<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, você terá que organizar a interceptação e o tratamento de exceções: todos os exemplos acima são para trabalhar em um encadeamento para testar a compatibilidade com o STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O uso de algoritmos STL torna possível um ponto interessante: você pode usar vários algoritmos ao mesmo tempo, executando-os em vários threads em paralelo. Isso não pode ser feito por meios convencionais (por exemplo, usando std :: list e meios de bloqueio) sem ter acesso ao conteúdo interno da classe list. Só foi possível bloquear a lista inteira durante todo o algoritmo. Obviamente, isso acelerará o trabalho do thread que está executando o algoritmo, mas tornará a lista inacessível para outros threads. No entanto, se você aplicar o mesmo bloqueio SRWLock "fino", poderá executar vários algoritmos na lista ao mesmo tempo, se eles não modificarem essa lista. Mas o primeiro thread a ser gravado permanecerá aguardando a conclusão da operação de leitura da lista por todos os outros threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A opção de lista proposta permite organizar o trabalho com mais flexibilidade. </font><font style="vertical-align: inherit;">Por exemplo, você pode organizar o trabalho com uma lista de forma a executar algoritmos não modificáveis ​​na primeira metade da lista por vários threads ao mesmo tempo, enquanto vários outros threads podem adicionar ou alterar algo na segunda metade da lista. </font><font style="vertical-align: inherit;">O fato de a lista estar bloqueada durante a duração de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operação, e não o algoritmo inteiro, permitirá a "gravação" das operações de gravação através da sequência de operações de leitura da lista, o que tornará o trabalho com ela mais flexível, produtivo e eficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinando duas variantes de classes de lista com e sem suporte a exceção em uma com um parâmetro booleano</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, as listas eram apenas com exceções. </font><font style="vertical-align: inherit;">Em seguida, adicionei novos - sem exceção de retorno de erro e renomeei os antigos com a adição da letra "E" no nome da classe: List_OneLinked_E e List_TwoLinked_E. </font><font style="vertical-align: inherit;">Isso é necessário para indicar quatro declarações da classe list em todos os lugares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então decidi que isso era inconveniente por vários motivos. </font><font style="vertical-align: inherit;">Por que precisamos de duas classes completamente diferentes se esta é a mesma lista com ou sem suporte a exceção? </font><font style="vertical-align: inherit;">Combinei as duas listas de cada tipo em uma única classe com um parâmetro booleano adicional, e sua implementação específica com e sem exceções são duas especializações de uma única classe para o parâmetro booleano especificado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operação de mesclagem da lista de modelos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A operação de modelo de combinação de listas funcionava anteriormente apenas com listas do mesmo tipo. Combinava apenas listas conectadas individualmente ou apenas listas duplamente conectadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, se você pensar sobre isso, não importa realmente que tipo de lista está envolvido na operação: simplesmente conectado ou duplamente conectado. Suas estratégias de bloqueio também não são importantes, qual é sua estratégia para verificar a existência de elementos e se eles suportam o tratamento de exceções ou não. Tudo isso se aplica apenas à organização da lista, mas não aos dados nela contidos. É importante que apenas o tipo de dados e a estratégia de memória dos elementos correspondam. Portanto, agora, depois de combinar listas com um parâmetro booleano em relação a exceções, a operação de entrada aceita listas de qualquer tipo com todas as variantes de seus parâmetros:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, como resultado do tipo de lista, o compilador seleciona, dependendo da configuração do parâmetro externo ce_bGetMinLinksList, uma lista com conectividade mínima ou máxima e, dependendo desta solução, seus parâmetros correspondentes são usados:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com base nos parâmetros selecionados, uma lista de resultados é criada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, nesta lista, os ponteiros são configurados para o início da primeira e o final da segunda lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, as listas anteriores são limpas e a função sai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ponto fraco dessa função é o bloqueio duplo de listas com possíveis conflitos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode introduzir alguma função para bloquear simultaneamente duas listas em uma única operação atômica, como std :: lock (mutex1, mutex2), no entanto, nem todas as estratégias de bloqueio suportam o bloqueio simultâneo de dois objetos de sincronização, como std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, duas listas podem ter diferentes estratégias de bloqueio. </font><font style="vertical-align: inherit;">A solução para esse problema (se houver) é deixada para o futuro.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilação Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A compilação foi verificada através do projeto ListDataAdapterTest, originalmente escrito em C ++ puro, sem recursos específicos do Windows, no Linux Ubuntu 16.04 LTS, o compilador g ++ 8.2.0. A maioria das pequenas nuances foi fácil de corrigir, e o projeto foi compilado com êxito, e a saída do programa coincidiu com a mesma saída no Windows. No entanto, este é o caso se você comentar a linha de combinação de listas através da operação "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você deixar como está, ocorrerá um erro de compilação na operação “+” descrita acima, como se não tivesse sido declarado privilegiado na classe do elemento composto da lista. Um erro semelhante ocorre na estratégia de verificação direta para a presença do elemento DirectSearch. No Visual C ++, tudo está bem aqui, no entanto, esses mesmos erros aparecem se na classe de elemento composto e na classe de lista o comentário sobre a declaração da operação de combinar listas e o DirectSearch como privilegiado for comentado. Parece que o g ++ simplesmente pula essas declarações e reclama dos membros privados / protegidos das classes correspondentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Na versão 9 do g ++ 9 (Ubuntu 20.04), os mesmos erros.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que os anúncios de privilégios são ignorados e como corrigi-lo, eu não entendi. </font><font style="vertical-align: inherit;">Eu não sou bom nos recursos do compilador GCC. </font><font style="vertical-align: inherit;">Deixou esse momento também para o futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exceto por essa nuance, não há outros erros graves de compilação.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descrição da estrutura do arquivo de cabeçalho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caros leitores, publiquei o projeto completo sob a licença LGPL 3.0 no GitHub em: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esta é uma solução que consiste em vários projetos de teste. </font><font style="vertical-align: inherit;">O código principal de uma lista multithread, em virtude de sua implementação por meio de modelos, está localizado em vários arquivos de cabeçalho:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - a classe base de uma lista sem dados, que implementa todas as operações básicas com uma lista, possível sem definir dados específicos, bem como adaptadores STL semelhantes para dados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - versões da lista com suporte a exceção.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - definição de classes base para um item da lista.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - definição de códigos e classes de erro para exceções.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além dos arquivos principais listados, também são implementados:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - estratégias para trabalhar com memória;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - estratégias de bloqueio.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - estratégias para verificar a presença de um elemento na lista, descritas abstratamente para qualquer contêiner com iteradores.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além do projeto final, também adicionei três versões antigas na pasta "Versões antigas", para que você possa avaliar brevemente como o projeto mudou conforme foi desenvolvido.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O projeto principal, chamado List, é um programa com uma interface para o Windows implementada de maneira explícita por meio da API do Windows (não sei mais o que fazer). Neste programa, você seleciona o tipo de lista (simplesmente conectado ou duplamente conectado) e também indica o número inicial de elementos e o número desejado de threads. Os itens da lista contêm um único valor de 64 bits. Após criar uma lista, o programa em cada thread no loop avança ou retrocede na lista para um número aleatório de elementos e, em seguida, adiciona ou remove um elemento. Nenhum trabalho realmente útil é feito nesta lista e toda a energia é gasta no aquecimento da atmosfera, mas isso não é necessário: precisamos apenas avaliar a operacionalidade e o desempenho da lista em um ambiente intensivo de vários segmentos.A medida de desempenho é o número de iterações do ciclo acima por segundo, executadas por todos os encadeamentos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista é configurada indicando as estratégias apropriadas no código do programa e recompilando. Todas as estratégias para o programa principal são especificadas no módulo principal ListMain.cpp, a estratégia de memória é selecionada em ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De um modo geral, experimentei um pouco com experimentos. Eu honestamente admito. Principalmente porque, em vários casos, a lista de itens muda significativamente. Para que a pureza do experimento avalie o desempenho, seria necessário fazer um teste de forma que o número de elementos, em média, não se modifique durante o período do estudo ou mude de maneira extremamente insignificante. Somente sob tais condições seria justo avaliar o valor da produtividade com base no valor médio. Se alguém estiver interessado, proponho organizar esses experimentos por conta própria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não corrigi a organização inicial dos testes pelos seguintes motivos. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro de tudo, eu era apenas preguiçoso.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em primeiro lugar, na minha opinião, ninguém está interessado nos valores quantitativos exatos do desempenho</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com erro calculado</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : é importante avaliar o desempenho e o desempenho da lista de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maneira qualitativa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em segundo lugar, isso permite avaliar a alteração no desempenho da lista com o crescimento de seu volume, o que também é uma informação bastante importante e interessante. </font><font style="vertical-align: inherit;">Por esses motivos, não alterei os experimentos originais. </font><font style="vertical-align: inherit;">Em terceiro lugar, o mesmo código de teste é executado em todas as variantes da lista, o que, nesse sentido, as coloca nas mesmas condições: o fato de se comportarem de maneira diferente nesse caso nos permite julgar a qualidade das alterações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para habilitar a medição de desempenho, defina o sinalizador ce_bPerformanceMeasure no módulo ListMain.cpp como true. </font><font style="vertical-align: inherit;">O programa criará um arquivo "PerformanceMeasure.txt" com pares "número de elementos - número de ciclos / s", separados por um símbolo ":".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de Medição de Desempenho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, não realizei testes para todas as configurações possíveis da lista, porque existem muitas. </font><font style="vertical-align: inherit;">Eu me concentrei apenas nos principais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os testes foram realizados no meu pedido da configuração de memória de 4 canais Intel Core i7-3930K, DDR3-1333, 4 canais, já desatualizada, mas ainda assim muito animada. </font><font style="vertical-align: inherit;">A compilação foi realizada no Visual Studio 2019 para o modo Release x64, o sistema operacional Windows 7 x64. </font><font style="vertical-align: inherit;">Eu não brinquei com o número de threads, portanto, em todos os testes, o máximo de 12 threads disponíveis neste sistema sempre foram usados. </font><font style="vertical-align: inherit;">Sempre foi criada uma lista com 10.000 itens selecionados aleatoriamente, com exceção do último teste.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste de Estratégia de Memória</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando ponteiros internos, como mencionei anteriormente, apenas uma estratégia de pesquisa direta pode ser usada para verificar a presença de um item na lista. Dessa forma, para que a comparação seja correta e, para indicadores inteligentes, apenas essa estratégia será aplicada neste teste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como estratégia de bloqueio, uma seção crítica com um bloqueio fino foi selecionada como a mais produtiva no Windows (veja abaixo): ThreadLockingWin_SRWLock. O tratamento de erros é realizado retornando um código de erro, ou seja, opção sem exceções. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este gráfico mostra o número de ciclos executados por todos os encadeamentos no total por segundo, dependendo da duração do teste (em segundos). Obviamente, o desempenho é inconsistente devido à natureza aleatória dos threads que acessam a lista.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo gráfico mostra como o número de itens da lista muda durante o teste. Não farei nenhuma declaração ponderada sobre esse cronograma, exceto o óbvio: é claro que eles funcionam de maneiras ligeiramente diferentes, e a conectividade da lista junto com a estratégia de memória tem efeito. Uma lista duplamente vinculada com ponteiros internos é a única que inesperadamente não muda no tamanho médio durante toda a duração do teste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Produtividade média (ciclos / s) para o período medido:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelo menos, pode-se argumentar que a opção de lista com ponteiros inteligentes é mais lenta que a versão com ponteiros internos, o que é esperado. </font><font style="vertical-align: inherit;">Nos dois casos, de alguma forma, verifica-se que um conectado individualmente é mais rápido que um conectado duplamente, o que mostra mais uma vez que no modo multithread, muitas coisas familiares podem mudar.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testando estratégias de disponibilidade de itens</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mais interessante é testar estratégias para verificar a presença de um elemento. Como estratégia de memória, ponteiros inteligentes são naturalmente indicados pelos motivos descritos anteriormente. O restante é o mesmo: travando com ThreadLockingWin_SRWLock e manipulando erros retornando um código de erro. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos dizer com certeza que todas as estratégias funcionam aproximadamente da mesma maneira. Isso é compreensível: em uma lista com vínculo único, quando você exclui seu item, é necessário examinar a lista todas as vezes para o item que indica o item a ser excluído. Isso anula todos os esforços para otimizar o acesso à lista e acelerar a verificação da presença de um elemento nela. Portanto, uma lista isolada não é a melhor opção para um trabalho multithread desordenado intensivo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não vou dar um gráfico sobre o número de elementos: não há nada interessante lá. Observo apenas que agora o número de elementos em todas as listas está aumentando. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma situação completamente diferente surge para uma lista duplamente vinculada. Para deixar os gráficos bonitos, eu até excluí a estratégia de visualização direta da lista do DirectSearch, porque pelos resultados ela claramente “cai” do resto. Além disso, aumentei o número limite de elementos em 4 vezes, atingindo o qual o teste é interrompido.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, o desempenho do acesso à lista (assim como a carga do processador, passando de 99 a 100%) aumentou drasticamente e significativamente! Em segundo lugar, um par de estratégias com preenchimento seqüencial de bits de matriz tem aproximadamente o mesmo desempenho que não muda durante o teste. A velocidade do segundo par de estratégias diminui de maneira não linear. Por que é assim, ficará claro no gráfico o número de nós na lista.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As listas com o primeiro par de estratégias aumentam o número de elementos e linearmente. O segundo par fornece um crescimento significativamente não linear e, quanto maior o número de elementos tiver uma lista, mais lento ele cresce. Isso é compreensível, pois com um aumento no número de elementos ao criar um novo, é necessário, em média, examinar um número maior de bits da matriz em busca de graça. O primeiro par de estratégias não lida com isso, usa um novo bit para cada novo elemento. Assim, uma lista com essa estratégia tem desempenho máximo de acesso e fica mais próxima da lista clássica: tanto a criação quanto a exclusão de elementos são executadas em um tempo constante, independentemente do número de elementos. No entanto, fornece algumas garantias de integridade e segurança em um ambiente multithread, embora ao custo de uma certa quantidade de memória.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista com o segundo par de estratégias, é claro, é visivelmente mais lenta. No entanto, ainda é significativamente mais rápido que as opções de verificação direta. Portanto, você pode realmente recomendá-lo como um intermediário no desempenho, mas mais ideal em termos de consumo de memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, as listas com uma estratégia de pesquisa direta também funcionarão mais lentamente com um aumento no número de elementos: um número maior de elementos precisará ser visualizado a cada vez. Só que durante o teste a lista não consegue crescer tanto que se torna perceptível, apesar das flutuações caóticas no desempenho.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os valores médios de desempenho mostram que estratégias com um bitmap durante o preenchimento sequencial permitiram aumentar a produtividade de acessar a lista em cerca de 200 vezes, ou seja, </font><font style="vertical-align: inherit;">2 ordens de magnitude em comparação com estratégias de pesquisa direta. </font><font style="vertical-align: inherit;">Esta é uma mudança muito radical. </font><font style="vertical-align: inherit;">O desempenho das opções com preenchimento de bits ideal para a memória, como observado acima, é obviamente mais lento, mas ainda muito mais rápido que as opções com verificação direta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também é importante notar que o uso de um mecanismo de transferência de memória sob demanda diminui um pouco o acesso à lista. </font><font style="vertical-align: inherit;">Não é muito crítico, mas o efeito está presente e perceptível, especialmente - na variante com uso econômico de memória (linha amarela nos gráficos).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste de estratégia de bloqueio</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como o desempenho da lista mudará ao escolher diferentes estratégias de bloqueio. </font><font style="vertical-align: inherit;">Usei três tipos de bloqueios: bloqueio "fino" do SRWLock, seção crítica regular do Windows e mutex STL. </font><font style="vertical-align: inherit;">Para o restante das configurações, foi utilizada a versão mais rápida da lista: ponteiros inteligentes biconetados, a estratégia para verificar a presença de um elemento - SearchByIndex_BitArray, uma variante sem exceções. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como seria de esperar, um bloqueio "fino" aumenta o desempenho em quase 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A velocidade do trabalho com a seção crítica do Windows e o mutex STL é praticamente a mesma.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceções</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para avaliar o impacto das exceções no desempenho, realizei três testes. </font><font style="vertical-align: inherit;">Os dois primeiros usaram uma lista duplamente vinculada, ponteiros inteligentes, uma estratégia de verificação de presença de elementos - SearchByIndex_BitArray e uma seção crítica do SRWLock. </font><font style="vertical-align: inherit;">O mesmo teste foi usado para o último teste, apenas a trava foi substituída pela seção crítica usual para comparação. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode-se observar que o suporte a exceções pode realmente reduzir a velocidade do trabalho, especialmente se você usar uma opção de bloqueio mais "bruta". </font><font style="vertical-align: inherit;">No entanto, lembre-se de que, nesse caso, o suporte para STL e loops na coleção não estará disponível.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi um experimento em grande escala para mim. Não quero dizer os testes acima, mas todo o projeto. Ele não esperava ser tão arrastado. No entanto, eu a realizei completamente e na medida em que planejei. Obviamente, no final, essa ainda não é a versão final, mas apenas um protótipo funcional, a implementação das idéias descritas no início do artigo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com os resultados do teste, é claro que, no Windows, ela se tornou a lista duplamente vinculada mais rápida com ponteiros inteligentes, uma estratégia para verificar a presença do elemento SearchByIndex_BitArray, uma seção crítica do SRWLock e sem exceções. Nesta configuração, a lista fornece desempenho máximo com acesso caótico intensivo a partir de vários fluxos e o comportamento é o mais próximo da lista clássica, com garantias de segurança no modo multithread. A opção com um consumo de memória mais econômico também é muito produtiva (em comparação com a verificação direta do DirectSearch), mas ainda é visivelmente mais lenta que a anterior, e seu desempenho diminui com o aumento do número de elementos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você acha que vou fazer campanha aqui pelo que é legal e por que é ótimo usá-lo, então não: na verdade, começarei desencorajando você. </font><font style="vertical-align: inherit;">De fato:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pense se é possível usar um contêiner com um arranjo diferente de elementos: por exemplo, uma matriz. </font><font style="vertical-align: inherit;">Não tem problemas como uma lista.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    –       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   –     .    . ,   –          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As estratégias de transferência de memória para uma matriz de bits sob demanda também aproximam pelo menos parcialmente uma lista multithread da clássica: pelo menos até que a matriz de memória esteja completamente cheia, será preciso exatamente o necessário. </font><font style="vertical-align: inherit;">No entanto, isso implica uma redução no desempenho.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Desvantagens do projeto:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A possibilidade observada anteriormente de bloqueio mútuo na operação de listas combinadas.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que isso tenha sido interessante. Iniciantes podem ser úteis, porque tudo é considerado do simples ao complexo. Peço aos profissionais que digam quanto, na sua opinião, as idéias descritas aqui são aplicáveis ​​na prática em projetos reais? Houve um caso em sua atividade quando, de acordo com o significado, você precisava de uma lista ou árvore, e não de outro contêiner, mas isso se tornou um gargalo no seu programa devido aos problemas descritos aqui? Ou você teve que mudar ou complicar bastante o programa. Se você já encontrou isso antes, como resolveu isso?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, em essência, este projeto é apenas a realização de minha própria visão sobre a solução desse problema. </font><font style="vertical-align: inherit;">É provável que exista alguma opção melhor. </font><font style="vertical-align: inherit;">Repito o pensamento desde o início de que o fiz inicialmente e não planejei colocá-lo em exibição pública. </font><font style="vertical-align: inherit;">Ainda assim, fiz isso pelas razões descritas lá, por isso terei prazer em receber críticas construtivas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com uma revisão cuidadosa do código, você pode encontrar um design como esse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa magia negra merece um artigo separado. </font><font style="vertical-align: inherit;">É verdade que isso é ainda menos prático do que a lista multithread descrita aqui, mas tem seus próprios recursos curiosos. </font><font style="vertical-align: inherit;">Se você está interessado em saber de onde veio e por que apareceu, e deseja que eu fale sobre isso mais tarde em detalhes, escreva nos comentários.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt506702/index.html">Os HDDs mais confiáveis ​​de acordo com o Backblaze Q1 2020</a></li>
<li><a href="../pt506704/index.html">Por que escrever em PHP em 2020? Holivarim é um podcast interativo no Youtube nesta quinta-feira</a></li>
<li><a href="../pt506706/index.html">O desempenho do Java moderno ao trabalhar com grandes quantidades de dados, parte 1</a></li>
<li><a href="../pt506708/index.html">Autenticação de dois fatores VPN / Mikrotik - simples e escalável</a></li>
<li><a href="../pt506710/index.html">Gerenciar vários catálogos de endereços no Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../pt506726/index.html">Experiência no uso da tecnologia Rutoken para registro e autorização de usuários no sistema (parte 2)</a></li>
<li><a href="../pt506730/index.html">Bufo ou Suricata. Parte 1: escolha um IDS / IPS gratuito para proteger a rede corporativa</a></li>
<li><a href="../pt506732/index.html">Reutilização em toda a organização de componentes da interface do usuário</a></li>
<li><a href="../pt506734/index.html">Cálculos transitórios em redes elétricas</a></li>
<li><a href="../pt506736/index.html">Quantos métodos devem estar em uma classe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>