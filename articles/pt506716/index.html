<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèª üôÖüèæ üëèüèø Lista linear multithread: problema de exist√™ncia de elemento, aprimoramento de produtividade e rela√ß√£o STL ‚ú≥Ô∏è üò™ üöõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° queridos visitantes de Habr! 
 
 Este artigo focar√° em uma lista vinculada, multithreading e C ++. Percebo imediatamente que havia toda a chance d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lista linear multithread: problema de exist√™ncia de elemento, aprimoramento de produtividade e rela√ß√£o STL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√° queridos visitantes de Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo focar√° em uma lista vinculada, multithreading e C ++. Percebo imediatamente que havia toda a chance de colocar esse trabalho na prateleira e us√°-lo em um pequeno n√∫mero de projetos pessoais. Em vez disso, ainda decidi coloc√°-lo na corte do p√∫blico - de repente, parece realmente √∫til ou interessante para algu√©m. Al√©m disso, se algu√©m j√° conseguiu fazer algo assim, indique esses materiais para mim, por favor. No entanto, n√£o importa como eu tentei pesquisar neste t√≥pico, todas as tentativas foram malsucedidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m observo que n√£o se trata da lista vinculada cl√°ssica, mas do meu repensar criativo do uso dessa estrutura de dados em um ambiente com v√°rios segmentos. Eu estava pensando em um cen√°rio de acesso intensivo desordenado a listas multithread. Isso significa que qualquer thread a qualquer momento, independentemente de outras, pode acessar a lista e executar as opera√ß√µes necess√°rias. Se ele apenas adiciona ou altera elementos, isso n√£o √© t√£o ruim. Se ele tamb√©m remover os elementos, v√°rias caracter√≠sticas interessantes podem surgir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este projeto, no qual eu participei como hobby e autodesenvolvimento, por v√°rias raz√µes, durou muito tempo. </font><font style="vertical-align: inherit;">Al√©m disso, enquanto eu trabalhava nele, estudei intensamente: o projeto come√ßou sem o conhecimento e a compreens√£o do STL e foi projetado de acordo, usando apenas os meios internos da pr√≥pria linguagem C ++. </font><font style="vertical-align: inherit;">No entanto, eu o modifiquei seriamente, levando em considera√ß√£o o STL e at√© o STL. </font><font style="vertical-align: inherit;">O que eu consegui com isso, julgue voc√™, queridos leitores.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para uma compreens√£o mais completa do material descrito aqui, voc√™ precisar√° ler os seguintes livros:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - "Design Moderno em C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - ‚ÄúWindows via C / C ++, Programa√ß√£o Visual C ++‚Äù.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - ‚ÄúBiblioteca Padr√£o C ++. </font><font style="vertical-align: inherit;">Guia de refer√™ncia. </font><font style="vertical-align: inherit;">Segunda Edi√ß√£o ‚Äùou livro similar no STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de linhas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma lista linear √© uma estrutura de dados conhecida que tem sido usada desde a √©poca da linguagem C e anterior. Seu elemento √© um determinado objeto na mem√≥ria que possui conex√µes com um ou dois elementos semelhantes vizinhos - eis um exemplo para uma lista duplamente vinculada:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;‚Ä¶   ‚Ä¶&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consequentemente, a lista em si √© um certo (sub) programa que executa manipula√ß√µes com esses elementos. </font><font style="vertical-align: inherit;">Como regra, √© conhecido um ponteiro para o in√≠cio e, opcionalmente, para o final da lista: basta, a partir do primeiro elemento, passar por todos os seus elementos at√© o fim. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, estou descrevendo informa√ß√µes j√° bem estudadas e conhecidas: era um programa educacional para aqueles que desconheciam completamente. </font><font style="vertical-align: inherit;">Para detalhes, por exemplo, voc√™ pode entrar em contato aqui: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista linear (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A biblioteca STL possui um cont√™iner maravilhoso std :: list (lista duplamente vinculada), bem como seu twin-std :: forward_list (lista vinculada unicamente). </font><font style="vertical-align: inherit;">Ou seja, se voc√™ n√£o est√° interessado em como a lista √© organizada e funciona, e deseja us√°-la apenas para suas tarefas, os cont√™ineres propostos s√£o sua op√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas h√° uma coisa, mas ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Repito que, quando comecei a analisar esse t√≥pico, eu faria tudo, contando apenas com as ferramentas internas do C ++ sem nenhum suporte ao STL. </font><font style="vertical-align: inherit;">O valor do que aconteceria seria menor se eu ainda decidisse falar sobre isso aqui. </font><font style="vertical-align: inherit;">Mas, por outro lado, eu estava completamente livre de quaisquer conceitos ou limita√ß√µes da biblioteca e, portanto, n√£o estava vinculado a nada e procurei abordagens com mente aberta e independ√™ncia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, em um passado distante, a grande maioria dos computadores era de n√∫cleo √∫nico e processador √∫nico. A lista linear era uma estrutura de dados relativamente simples e transparente, e trabalhar com ela n√£o causou nenhuma dificuldade espec√≠fica. Agora, mesmo os smartphones se tornaram multi-core. Sob condi√ß√µes de multithreading, mesmo uma estrutura t√£o simples como uma lista vinculada √© seriamente complicada. Garantir que a opera√ß√£o correta no modo multithread geralmente complique seriamente qualquer programa, isso √© um fato conhecido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tome um cen√°rio abstrato de trabalho intensivo com uma lista de threads diferentes: cada um deles pode adicionar, excluir, alterar elementos etc. em um momento completamente arbitr√°rio. Por um lado, o trabalho com a lista nesse caso deve ser principalmente seguro: se houver alguma viola√ß√£o de dados e comportamento indefinido do programa, essa ser√° uma solu√ß√£o completamente inadequada. Por outro lado, gostaria muito de trabalhar com ele o mais r√°pido poss√≠vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver o primeiro problema, a lista obviamente ter√° que ser bloqueada de alguma forma, al√©m de sincronizar o acesso a ela. O segundo problema - desempenho - √© adiado por enquanto.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo considera apenas o bloqueio da lista inteira por um fluxo para acesso exclusivo do fluxo a ele. Outras op√ß√µes pareciam duvidosas, por exemplo, pelos seguintes motivos. Suponha que tenhamos uma lista duplamente vinculada e decidimos remover o item dela. Para fazer isso, voc√™ deve bloquear o pr√≥prio n√≥, bem como o anterior e o pr√≥ximo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exato momento, antes do in√≠cio da opera√ß√£o, outro encadeamento exclui apenas, por exemplo, o n√≥ anterior. Bloqueamos o removido e paramos de aguardar o lan√ßamento do n√≥ anterior bloqueado por outro encadeamento. E ele est√° impedido de esperar o pr√≥ximo por ele, ou seja, nosso n√≥ exclu√≠do. √â isso, √© um impasse. Portanto, esse m√©todo n√£o √© confi√°vel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se seus encadeamentos n√£o armazenam ponteiros (ou iteradores) para n√≥s espec√≠ficos, a tarefa √© extremamente simplificada. De fato, voc√™ s√≥ pode fazer com ferramentas STL. O fluxo bloqueia a lista, refere-se a qualquer elemento nela (por exemplo, do in√≠cio, do fim ou pesquisando nela de acordo com alguns crit√©rios), processa ou remove esse elemento, adiciona novos elementos sem salvar links para eles, e depois completa a lista. Tudo isso - bloqueando exclusivamente o acesso √† lista em um encadeamento, possuindo-o para a dura√ß√£o das opera√ß√µes necess√°rias. Nesse caso, √© perfeitamente l√≥gico usar std :: list e recursos de bloqueio de biblioteca. Por tudo isso, deve-se observar que, enquanto seu thread faz todo o trabalho necess√°rio, outros threads param de esperar, ou seja, o trabalho com a lista ser√° realizado no modo de thread √∫nico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu considerei outro cen√°rio mais complexo, quando um thread armazena um ponteiro ou iterador no elemento de que precisa. </font><font style="vertical-align: inherit;">Por exemplo, seu programa trabalha em alguns c√°lculos complexos, obtendo os dados iniciais do item da lista e, ap√≥s o processamento, atualiza seu valor, adicionando os resultados do c√°lculo. </font><font style="vertical-align: inherit;">No entanto, outros threads tamb√©m t√™m acesso √† mesma lista. </font><font style="vertical-align: inherit;">N√£o fiz suposi√ß√µes sobre a natureza do aplicativo: outro thread pode excluir facilmente esse elemento por algum motivo. </font><font style="vertical-align: inherit;">Ou mova-o para outro lugar. </font><font style="vertical-align: inherit;">Portanto, trabalhar com uma lista se torna problem√°tico n√£o apenas pelos motivos usuais de multithreading e sincroniza√ß√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema da exist√™ncia de um elemento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual √© a diferen√ßa fundamental entre uma lista e, digamos, uma matriz? Em um </font><font style="vertical-align: inherit;">arranjo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distribu√≠do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de itens da lista. Todos os elementos da matriz est√£o localizados em uma √∫nica √°rea de mem√≥ria. Mesmo que voc√™ armazene um ponteiro em alguns de seus elementos, voc√™ tem certeza de que o acesso ao endere√ßo estar√° correto (√© claro, se a matriz n√£o foi movida na mem√≥ria para outro local com uma extens√£o de seu tamanho, por exemplo). Se o elemento que voc√™ precisa for exclu√≠do ou movido para outro encadeamento, basta ir para o endere√ßo anterior, voc√™ entender√° por alguns sinais que o elemento que voc√™ precisa n√£o est√° aqui, tente procur√°-lo etc. Obviamente, o programa deve apoiar essa oportunidade com anteced√™ncia. Mas, em qualquer caso, seu funcionamento permanecer√° correto enquanto voc√™ estiver nos limites de mem√≥ria corretos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma situa√ß√£o completamente diferente ocorre no caso de uma lista (assim como no caso de uma √°rvore, gr√°fico - qualquer estrutura de dados com elementos distribu√≠dos). Se um elemento de acordo com o seu ponteiro foi exclu√≠do em outro segmento, voc√™ nem saber√° sobre ele e, se tentar acessar o endere√ßo, receber√° uma viola√ß√£o de acesso (na melhor das hip√≥teses). Mesmo que n√£o seja realmente exclu√≠do da mem√≥ria (por exemplo, se ponteiros inteligentes forem usados), ele ser√° exclu√≠do da lista, ou seja, n√£o far√° parte disso. Voc√™ tamb√©m n√£o saber√° disso. O trabalho correto com a lista est√° quebrado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao mesmo tempo, um intenso trabalho multithread com a lista cria cen√°rios absolutamente fant√°sticos. Voc√™ pode at√© ter certeza de que est√° tudo bem com seu elemento e um ponteiro para ele - at√© acessar alguma fun√ß√£o de lista para trabalhar com ele.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemplo. Deixe que haja uma parte da lista e um ponteiro para o n√≥, que denominamos (#), seja transferido para algum m√©todo da lista de fun√ß√µes, enquanto os n√≥s associados a ela ser√£o indicados por n√∫meros relativos a ele. No momento em que a fun√ß√£o √© chamada, sabe-se que esse elemento existe e o ponteiro para ele est√° correto, ou seja, o estado da lista nessa √°rea √©: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, deixe o n√≥ (#) ser passado como par√¢metro para alguma fun√ß√£o da lista. Essa fun√ß√£o, como sempre, √© bloqueada enquanto aguarda o acesso a ela. Enquanto ela esperava, tr√™s threads trabalharam √† sua frente, excluindo o n√≥ (#) junto com os adjacentes para que isso acontecesse: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, outros 5 threads inseriram mais 5 elementos na lista, come√ßando com (-2). Denotamos os novos elementos como (nN), onde N √© o n√∫mero relativo entre os cinco, come√ßando do zero:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, nosso fluxo √© chamado, que foi chamado com (#). A quest√£o √©: o que ele deve fazer nesse caso, depois que tudo (#) se foi? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resposta: tudo depende da opera√ß√£o, bem como do cen√°rio para o uso da lista. No entanto, como estamos considerando o caso mais geral sem restri√ß√µes, algumas suposi√ß√µes gerais podem ser feitas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se esta for uma opera√ß√£o de exclus√£o, basta verificar se o item especificado est√° presente na lista. Caso contr√°rio, ele j√° foi exclu√≠do e nada mais precisa ser feito. Se sim, exclua. Da mesma forma, para a opera√ß√£o de ler / alterar o conte√∫do do n√≥: se o n√≥ for exclu√≠do, j√° n√£o h√° nada para ler / modificar. Mas os maiores problemas surgem com as opera√ß√µes de inser√ß√£o de um novo n√≥, bem como com a mudan√ßa para o pr√≥ximo / anterior. Por um lado, o n√≥ especificado n√£o est√° mais l√° e a falha pode ser retornada. Por outro lado, o n√≥ deve ser inserido e essa situa√ß√£o pode ocorrer a qualquer momento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a prioridade (para o caso geral) ainda √© a seguran√ßa e a confiabilidade, e somente a velocidade, ent√£o, obviamente, quando o thread finalmente conseguiu o tempo de opera√ß√£o dentro da fun√ß√£o, √© necess√°rio estabelecer o fato da presen√ßa de um elemento na lista: ele existe ou n√£o existe? Isso resolve um problema: pelo menos, n√£o interromperemos a lista inteira se n√£o houver um n√≥ solicitado e evitaremos erros de acesso √† mem√≥ria a esse respeito. Mas isso n√£o resolve o problema de inser√ß√£o e transi√ß√µes: n√£o est√° claro onde inserir um novo n√≥ e sair de um j√° exclu√≠do.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solu√ß√£o para o problema da exist√™ncia do elemento ser√° discutida em detalhes abaixo. </font><font style="vertical-align: inherit;">A quest√£o do que fazer quando descobrimos que o elemento n√£o est√° mais l√°, mas √© muito necess√°rio, est√° al√©m do escopo deste artigo, pois depende inteiramente do algoritmo do trabalho usando o programa list. </font><font style="vertical-align: inherit;">Obviamente, ele deve incluir esses cen√°rios e as rea√ß√µes correspondentes a eles: por exemplo, se n√£o houver elemento, v√° para o topo da lista ou execute outra opera√ß√£o. </font><font style="vertical-align: inherit;">A principal coisa que precisa ser garantida nessa situa√ß√£o √© a opera√ß√£o correta e segura da lista, bem como a notifica√ß√£o de tais situa√ß√µes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa direta de itens</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem mais simples e direta √© verificar a presen√ßa de um elemento na lista passando por ele sequencialmente em busca de um determinado elemento. Essa. apenas procurando o elemento fornecido. Se ele estiver na lista, trabalhamos com ele. Caso contr√°rio, dependendo da fun√ß√£o, sa√≠mos com sucesso ou fracasso e deixamos o programa de chamada decidir o que fazer nessa situa√ß√£o. O principal √© que o trabalho com a lista, em qualquer caso, estar√° correto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse m√©todo √© seguro e totalmente funcional, mas, especialmente para listas grandes, leva a uma queda catastr√≥fica no desempenho. De fato, trabalhar com uma lista acaba sendo de thread √∫nico: a lista fica bloqueada durante a pesquisa de um determinado elemento e outros threads n√£o podem acess√°-lo. Em segundo lugar, as despesas gerais aumentam acentuadamente - em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as opera√ß√µes com a lista precisam ser verificadas para ver se h√° um elemento necess√°rio no momento da opera√ß√£o e uma grande parte do tempo √© gasta n√£o em trabalho √∫til, mas na verifica√ß√£o da presen√ßa de um elemento. </font><font style="vertical-align: inherit;">No entanto, essa abordagem simples e direta √© bastante adequada para listas de pequeno volume e opera√ß√µes n√£o muito intensivas, al√©m de uma primeira aproxima√ß√£o para resolver o problema da exist√™ncia de um elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas e se tivermos uma lista com um grande n√∫mero de elementos, e trabalhar com ela for muito intenso: muitos threads constantemente adicionam, alteram e excluem elementos dela? </font><font style="vertical-align: inherit;">Existe alguma maneira de acelerar isso de alguma forma?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mem√≥ria ou desempenho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um fato bem conhecido de que um aumento na mem√≥ria usada pelo programa pode aumentar a velocidade do programa. Por exemplo, um programa faz uso pesado dos resultados de alguns c√°lculos. Em vez de execut√°-los novamente, voc√™ pode calcular tudo antecipadamente e salvar seus resultados em alguma tabela ou matriz. Em seguida, o programa simplesmente acessa a c√©lula desejada na tabela e recebe imediatamente o valor desejado, o que acelera significativamente seu trabalho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â essa abordagem que eu usei no caso da lista. Crie um bitmap. Adicione √†s informa√ß√µes de servi√ßo de cada um de seus elementos, al√©m do ponteiro necess√°rio para o pr√≥ximo e, opcionalmente, o elemento anterior, mais dois campos novos: o primeiro √© seu n√∫mero exclusivo nessa lista e o segundo √© um ponteiro para a pr√≥pria lista. Agora, quando um elemento √© criado, ele recebe um n√∫mero √∫nico e define a unidade no bitmap no √≠ndice correspondente. Quando um elemento √© exclu√≠do, esse bit √© redefinido. O n√∫mero do elemento criado est√° aumentando constantemente cada vez que um novo elemento √© criado - os bits zerados j√° utilizados n√£o s√£o reutilizados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, quando √© necess√°rio verificar a presen√ßa de um determinado elemento, em vez de procur√°-lo linearmente em toda a lista, um bitmap √© simplesmente acessado pelo √≠ndice desse elemento, e o fato de sua presen√ßa √© imediatamente estabelecido e por um tempo constante, independentemente do tamanho da lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este m√©todo permite alcan√ßar o desempenho m√°ximo, no entanto, possui s√©rias desvantagens. Primeiro, voc√™ precisar√° alocar mem√≥ria para toda a matriz de uma s√≥ vez, parte dos bits que podem n√£o ser necess√°rios durante o programa, mas essa mem√≥ria pode ser usada para outras necessidades. Esse problema e uma maneira de suavizar as exced√™ncias de mem√≥ria ser√£o discutidos abaixo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda desvantagem √© mais s√©ria e interessante - cada novo item da lista √© criado por um n√∫mero crescente e mon√≥tono. Isso significa que mais cedo ou mais tarde os bits livres da matriz ser√£o esgotados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste ponto, infelizmente, voc√™ precisa parar, bloquear a lista e come√ßar a servi-la. Essa. comprima os bits desta matriz, removendo todos os zero bits dos elementos intermedi√°rios da lista exclu√≠dos anteriormente, deixando apenas bits para os elementos que realmente existem no momento, mudando todos esses bits para o in√≠cio da matriz. Teremos que percorrer a lista inteira novamente e, no modo de thread √∫nico, reescrevendo todos os √≠ndices para cada elemento. O benef√≠cio √≥bvio disso em compara√ß√£o com a abordagem anterior √© que, neste caso, apenas </font><b><font style="vertical-align: inherit;">uma</font></b><font style="vertical-align: inherit;"> ser√° feita.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vezes por um longo per√≠odo de tempo. </font><font style="vertical-align: inherit;">Al√©m disso, a lista pode continuar funcionando como antes no modo extremamente r√°pido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, n√£o quero dizer que os n√≥s foram adicionados apenas √† lista, porque </font><font style="vertical-align: inherit;">neste caso, todos os bits da matriz ser√£o √∫nicos. </font><font style="vertical-align: inherit;">Estou considerando um cen√°rio em que itens s√£o intensa e arbitrariamente exclu√≠dos e adicionados. </font><font style="vertical-align: inherit;">Essa. </font><font style="vertical-align: inherit;">o n√∫mero total de itens da lista desde o in√≠cio de seu trabalho pode mudar um pouco. </font><font style="vertical-align: inherit;">Naturalmente, a quest√£o de escolher o tamanho da matriz depende da natureza do programa. </font><font style="vertical-align: inherit;">Voc√™ tamb√©m pode sempre criar uma nova matriz de um volume maior se o tamanho da atual n√£o for suficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando zero bits de elementos exclu√≠dos anteriormente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode fazer outra coisa: ao criar um elemento, procure o primeiro bit zero desde o in√≠cio do bitmap. Isso otimiza o consumo de mem√≥ria, mas leva a uma queda no desempenho: agora, novamente, toda vez que voc√™ cria um novo elemento, voc√™ ter√° que fazer um trabalho adicional - examine a matriz em busca de um bit livre. Mas, em compara√ß√£o com a verifica√ß√£o da presen√ßa de um elemento, visualizando diretamente a lista, o ganho √© √≥bvio: veremos a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos adjacentes e cada elemento dessa matriz cont√©m muitos bits, isto √©, </font><font style="vertical-align: inherit;">processamos muitos n√≥s de lista por vez (64 bits para sistemas modernos ou at√© 128/256/512 se estiver usando SSE / AVX). </font><font style="vertical-align: inherit;">Estamos procurando a primeira palavra que n√£o seja igual √† palavra com todos os bits de unidade; depois, procuramos o primeiro bit zero nessa palavra. </font><font style="vertical-align: inherit;">De fato, esse m√©todo tem velocidade intermedi√°ria entre o anterior e o m√©todo de visualiza√ß√£o direta.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimiza√ß√£o do consumo de mem√≥ria para bits de matriz desocupados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que assumamos um trabalho longo e intensivo com a lista, alocando uma enorme variedade de bits para ela. Mas aconteceu que, de fato, o programa funcionou de maneira diferente: acessou a lista raramente, executou outras opera√ß√µes que tamb√©m exigiam mem√≥ria. Como resultado, obtemos uma matriz quase n√£o utilizada de bits de enormes problemas de volume e mem√≥ria em outras partes do programa. Pura inconveni√™ncia! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Linux, at√© onde eu sei, resolve automaticamente esse problema (embora desenvolvedores experientes do Linux me permitam corrigi-lo, se houver). Voc√™ aloca mem√≥ria para a matriz, mas, na verdade, o sistema </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o transfere</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essa mem√≥ria para a matriz </font><font style="vertical-align: inherit;">at√© que seja realmente necess√°rio. H√° uma otimiza√ß√£o do uso da mem√≥ria. O Windows n√£o permite isso. Em vez disso, permite, mas voc√™ precisa fazer isso sozinho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aqueles que n√£o est√£o atualizados, explicarei: sua aplica√ß√£o (mais precisamente, o processo correspondente a ela), o sistema aloca um </font><font style="vertical-align: inherit;">grande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espa√ßo de endere√ßo virtual</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - at√© 8 TB para o Windows de 64 bits. A mem√≥ria f√≠sica no sistema pode ser muito menor - 8 ou 16 GB no momento para computadores em massa. </font><b><font style="vertical-align: inherit;">Telas do</font></b><font style="vertical-align: inherit;"> sistema operacional</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">endere√ßos de seu espa√ßo de processo virtual para endere√ßos de mem√≥ria f√≠sica, fazendo isso de maneira transparente sem o seu envolvimento direto. Naturalmente, a maior parte da mem√≥ria virtual livre de um processo geralmente est√° desocupada. Portanto, quando voc√™ solicita ao Windows que aloque mem√≥ria por meios convencionais, ele aloca essa mem√≥ria simultaneamente no espa√ßo virtual e na mem√≥ria f√≠sica. Se voc√™ alocar um bitmap de grande volume, corre o risco de ocupar imediatamente toda a mem√≥ria dispon√≠vel em sua m√°quina, sem garantir que essa mem√≥ria possa ser necess√°ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, pode-se agir de maneira diferente: marcar uma grande parte da mem√≥ria no espa√ßo virtual do processo, mas transferir f√≠sica para ela somente quando for realmente necess√°rio. </font><font style="vertical-align: inherit;">Isso pode ser feito atrav√©s do tratamento estrutural de exce√ß√µes no Windows; para detalhes, consulte o livro de Richter D., Nazar K. - ‚ÄúWindows via C / C ++, Programa√ß√£o Visual C ++‚Äù.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seria apenas uma id√©ia e uma teoria, se eu n√£o tivesse colocado todas essas id√©ias em pr√°tica, e n√£o na forma de um programa experimental simples: eu o fiz o mais cuidadosamente poss√≠vel para a produ√ß√£o, pretendendo us√°-lo em meus projetos reais; portanto, √© dessa forma que voc√™ precisa e imagine. </font><font style="vertical-align: inherit;">Eu pensei que seria injusto e muito ego√≠sta aplicar o que foi feito no meu n√∫mero limitado de projetos, se isso pudesse ser √∫til ou, pelo menos, apenas interessante para um amplo c√≠rculo de desenvolvedores. </font><font style="vertical-align: inherit;">Por outro lado, os criadores da biblioteca Boost e outras bibliotecas mais especializadas oferecem seu trabalho a todos de forma absolutamente gratuita. </font><font style="vertical-align: inherit;">Por que n√£o posso fazer o mesmo?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstra√ß√£o - uma lista sem dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividi a lista em dois n√≠veis l√≥gicos. O primeiro n√≠vel √© uma lista, cada elemento que n√£o cont√©m dados √∫teis, mas cont√©m apenas informa√ß√µes auxiliares: ponteiros para elementos vizinhos e, opcionalmente, esses dois campos adicionais para acelerar a verifica√ß√£o da presen√ßa de um elemento na lista. No entanto, j√° nesse n√≠vel √© poss√≠vel executar todas as opera√ß√µes b√°sicas em uma lista: adicionando e excluindo elementos, dividindo e mesclando listas, etc. De fato, concentrei-me principalmente neste n√≠vel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo n√≠vel √© adicionar dados reais ao item da lista, al√©m de adicionar novas opera√ß√µes √† lista para trabalhar com esses dados. Tudo isso √© fornecido em C ++ por heran√ßa. Mas os detalhes ser√£o discutidos abaixo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa divis√£o da implementa√ß√£o em dois n√≠veis fazia sentido: por que levar em conta a disponibilidade de dados espec√≠ficos se v√°rias opera√ß√µes s√£o completamente independentes desses dados? Para qualquer item da lista, voc√™ ainda precisa exclu√≠-los e adicionar novos √† lista, al√©m de executar outras opera√ß√µes t√≠picas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comecei com um conceito extremamente simples e descomplicado, retirado da constru√ß√£o da linguagem C. No in√≠cio do artigo, os ponteiros internos C e C ++ s√£o usados ‚Äã‚Äãdentro e fora da lista. A √∫nica diferen√ßa foi que a adi√ß√£o de dados, conforme indicado acima, foi adiada para uma data posterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe existir um elemento da lista sem dados, contendo apenas um ponteiro (ou ponteiros) para o (s) elemento (s) vizinho (s). Em seguida, o c√≥digo correspondente para ele pode ser representado esquematicamente da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;‚Ä¶m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um elemento para uma lista vinculada individualmente cont√©m em si um ponteiro para o pr√≥ximo elemento e nada mais. A classe de lista √© parametrizada pelo tipo desse elemento, o que implica que esse tipo ser√° alterado no est√°gio de adi√ß√£o de dados. Ele cont√©m ponteiros para o primeiro e o √∫ltimo elementos internos. Como originalmente eu direcionei esse projeto apenas para Windows, uma se√ß√£o cr√≠tica como SRWLock tamb√©m foi inclu√≠da para bloquear a lista. Em seguida, s√£o definidos os construtores, o destruidor e todas as fun√ß√µes necess√°rias para trabalhar com a lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta implementa√ß√£o cont√©m dois problemas ao mesmo tempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro √© o acesso aberto ao conte√∫do das informa√ß√µes de servi√ßo do elemento. Isso significa que, tendo obtido acesso a algum n√≥, ou seja, tendo um ponteiro para este n√≥, podemos nos referir diretamente ao elemento seguinte ou anterior.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© inaceit√°vel principalmente porque essa transi√ß√£o est√° ignorando o bloqueio e, portanto, protegendo a lista. De fato, suponha que, tendo um ponteiro para algum elemento pCurr, salvemos o valor para o pr√≥ximo elemento relativo a ele no ponteiro pNext da seguinte maneira: pNext = pCurr-&gt; pNext. Depois disso, realizamos algumas opera√ß√µes longas nesse n√≥ pCurr. Ao mesmo tempo, outros threads removeram os seguintes itens da lista relacionados ao pCurr. Ap√≥s terminar de trabalhar com pCurr, o encadeamento atual passa para o pr√≥ximo elemento usando o valor antigo armazenado no pNext local e recebe um erro de acesso ou comportamento indefinido, pois o elemento no endere√ßo pNext local n√£o existe mais e voc√™ precisa acessar o valor atualizado pCurr-&gt; pNext, se o item atual em pCurr, por sua vez,ainda existe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duas conclus√µes podem ser tiradas deste exemplo para evitar essa situa√ß√£o:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de fora da lista, v√° para o n√≥ pr√≥ximo / anterior e geralmente fa√ßa qualquer trabalho com elementos da lista apenas atrav√©s de fun√ß√µes (m√©todos) da classe list que bloqueiam a lista e tornam o acesso √† lista seguro;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obter acesso aos elementos o mais r√°pido poss√≠vel imediatamente antes de acess√°-los (por exemplo, para obter um ponteiro para o pr√≥ximo elemento pNext = list.GetNext (pCurr) n√£o antecipadamente, mas imediatamente antes que a necessidade de passar para o pr√≥ximo n√≥ apare√ßa).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â por isso que, para implementar a conclus√£o do primeiro par√°grafo, o acesso a ponteiros para elementos adjacentes a partir do exterior deve ser proibido:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo problema √© um pouco mais delicado. Para entend√™-lo, a estrutura das classes deve ser descrita em mais detalhes. A classe list √© definida como modelo e n√£o funciona com elementos do tipo ListElement_OneLinked, mas com o tipo ListElement, passado como um par√¢metro de modelo. Isso √© feito para poder criar novos n√≥s com dados dentro da classe. Para fazer isso, voc√™ precisa saber o tipo exato de n√≥ que est√° sendo criado. O tipo exato do n√≥ da lista ainda n√£o √© conhecido: ele ser√° determinado posteriormente, juntamente com os dados. A fun√ß√£o de cria√ß√£o de elemento aloca mem√≥ria para ele, inicializa ponteiros e, em seguida, retorna um ponteiro para o elemento criado na fun√ß√£o de chamada. Portanto, na fun√ß√£o de chamada da classe derivada, ser√° poss√≠vel inicializar outras propriedades do elemento que s√£o espec√≠ficas para essa classe e s√£o definidas posteriormente. Em outras palavras,uma defini√ß√£o exata do tipo do n√≥ da lista √© deixada para o futuro e, para que a lista funcione corretamente, √© importante que seus elementos contenham o ponteiro pNext, o restante n√£o importa at√© o momento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, com base em ListElement_OneLinked, posteriormente por heran√ßa, uma nova classe ser√° criada para o elemento com dados espec√≠ficos e transmitida para a classe List_OneLinked por meio do par√¢metro template. Ao mesmo tempo, uma nova classe derivada ser√° criada com base em List_OneLinked que define ainda mais as opera√ß√µes com esses novos dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, mesmo essa op√ß√£o n√£o est√° totalmente correta. Nas vers√µes anteriores da classe list, uma opera√ß√£o de convers√£o expl√≠cita do tipo reinterpret_cast &lt;ListElement *&gt; (...) era usada v√°rias vezes. O fato √© que a classe de modelo trabalha com o tipo de par√¢metro do modelo ListElement, derivado de ListElement_OneLinked / ListElement_TwoLinked. E nas fun√ß√µes de classe, as vari√°veis ‚Äã‚Äãs√£o criadas em express√µes do tipo: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E pCurr-&gt; pNext aqui √© um ponteiro para ListElement_OneLinked / ListElement_TwoLinked, como membros das classes base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sa√≠da: declare uma vari√°vel indicando o tipo base expl√≠cito ListElement_OneLinked / ListElement_TwoLinked ou fa√ßa a convers√£o expl√≠cita no tipo derivado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, mesmo uma defini√ß√£o expl√≠cita do tipo de base n√£o est√° correta, por exemplo, na fun√ß√£o de exclus√£o de lista (limpeza):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ alterar o tipo de ponteiros:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
isso significa que eles ser√£o exclu√≠dos pela opera√ß√£o</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
apenas as partes b√°sicas de cada n√≥ da lista, o que est√° errado. </font><font style="vertical-align: inherit;">Ou, como op√ß√£o, o ponteiro pCurr precisar√° ser convertido em seu tipo derivado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, em qualquer caso, n√£o se pode se livrar da transforma√ß√£o expl√≠cita reinterpret_cast com uma estrutura de classes, que n√£o √© a melhor solu√ß√£o (mais precisamente, o que √© realmente ruim). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por esse motivo, para se livrar de tais transforma√ß√µes expl√≠citas, foi decidido alterar a classe base do elemento (para uma lista duplamente vinculada - da mesma forma):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumidamente, isso pode ser descrito da seguinte maneira: o elemento b√°sico da lista cont√©m um ponteiro para outro elemento, mas o tipo desse ponteiro ainda n√£o √© conhecido, porque √© passado pelo par√¢metro do modelo (uma defini√ß√£o exata desse tipo √© deixada para o futuro). Em outras palavras: nesta fase, o tipo de n√≥ da lista (ou seja, o que ser√° no final) ainda n√£o foi determinado, ser√° determinado posteriormente. Mas agora mantemos o ponteiro para um elemento do tipo futuro, ainda n√£o conhecido. O tipo resultante do n√≥ da lista √© passado aqui como um par√¢metro de modelo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, nenhuma convers√£o √© necess√°ria, j√° que ponteiros do mesmo tipo ListElement s√£o usados ‚Äã‚Äãem todos os lugares - na classe list e na classe para n√≥s. O ListElement aqui e na classe list √© a classe final do item com dados espec√≠ficos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que agora a classe list tornou-se o mais abstrata poss√≠vel a partir de seu conte√∫do espec√≠fico: sabe-se apenas que seus n√≥s cont√™m ponteiros para outros n√≥s e, usando essas informa√ß√µes, todas as opera√ß√µes b√°sicas sobre eles com o bloqueio multithread correspondente s√£o executadas na classe list.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolvendo o problema da exist√™ncia de um elemento - uma pesquisa simples (vers√£o 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira vers√£o foi extremamente simples e direta e n√£o foi al√©m da estrutura descrita acima. </font><font style="vertical-align: inherit;">Foram utilizados ponteiros internos em C ++, a mem√≥ria dos elementos foi alocada usando a nova opera√ß√£o e exclu√≠da com a exclus√£o, a lista foi bloqueada na se√ß√£o cr√≠tica contida nela. </font><font style="vertical-align: inherit;">Eu n√£o sabia ou suspeitava sobre os meios da biblioteca STL e tamb√©m sobre o n√≠vel em que eles trazem a programa√ß√£o em C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J√° nesta fase, na pr√°tica, me deparei com o problema da exist√™ncia de um elemento descrito anteriormente e percebi que simplesmente bloquear a lista n√£o √© suficiente. </font><font style="vertical-align: inherit;">Naveguei pela lista usando as fun√ß√µes apropriadas com todas as precau√ß√µes, a lista foi bloqueada corretamente, mas o programa ainda travava com √™xito em diferentes intervalos. </font><font style="vertical-align: inherit;">Foi ent√£o que descobri que a presen√ßa de um elemento teria que ser verificada, o que levou a uma mudan√ßa na l√≥gica das fun√ß√µes principais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me dar um exemplo da fun√ß√£o de adicionar um elemento ap√≥s um determinado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observa-se que antes de criar um novo elemento, ele verifica se o elemento especificado est√° presente na lista chamando a fun√ß√£o FindElement (...):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complica√ß√µes adicionais de classes de lista multithread - classes de estrat√©gia (vers√£o 18.02.2019, 27.11.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, o projeto visava estritamente ao Windows. Mas em algum momento pensei: por que n√£o adicionar flexibilidade a ele? Por que apenas janelas? Afinal, a lista foi implementada essencialmente em C ++ puro; no Windows, havia apenas uma coisa: a se√ß√£o cr√≠tica do SRWLock. Naquela √©poca, eu j√° havia me familiarizado com o conceito de classes de estrat√©gia. Voc√™ pode ler sobre isso em detalhes no livro Alexandrescu A. - "Design moderno em C ++". Ele descreve muitas coisas incomuns e surpreendentes que podem ser √∫teis at√© agora, apesar do livro j√° ter 12 anos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma delas s√£o as classes de estrat√©gias. Classes de estrat√©gias, de fato, s√£o mudan√ßas no comportamento de uma classe atrav√©s de modelos, como B. Straustrup mencionou em seu famoso livro. Somente no livro de Alexandrescu, esse t√≥pico √© amplamente divulgado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que sua classe execute uma a√ß√£o espec√≠fica. </font><font style="vertical-align: inherit;">Voc√™ pode tomar a defini√ß√£o desta a√ß√£o fora da classe, criar uma classe separada com base nessa a√ß√£o e pass√°-la para sua classe de origem como um par√¢metro de modelo. </font><font style="vertical-align: inherit;">Isso complica o c√≥digo, sua leitura e compreens√£o, mas adiciona flexibilidade √† sua classe: para substituir essa a√ß√£o espec√≠fica por outra similar, basta escrever outra estrat√©gia semelhante e pass√°-la √† sua classe como par√¢metro de modelo. </font><font style="vertical-align: inherit;">O restante do trabalho ser√° realizado pelo compilador.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrat√©gia de bloqueio</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicando isso √† lista descrita, peguei o bloqueio do SRWLock em uma estrat√©gia separada e, em seguida, escrevi v√°rias outras estrat√©gias: na se√ß√£o cr√≠tica usual do Windows, nos mutexes do C ++ STL, etc. </font><font style="vertical-align: inherit;">Ent√£o ser√° poss√≠vel adicionar m√©todos puramente espec√≠ficos do Linux. </font><font style="vertical-align: inherit;">Assim, a classe tornou-se adequada n√£o apenas para o Windows, mas eu sempre posso reconfigur√°-la rapidamente para o Windows da maneira ideal, apenas especificando a estrat√©gia desejada.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrat√©gia de mem√≥ria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse ponto, tamb√©m comecei a estudar seriamente o STL e, entre as primeiras ferramentas desta biblioteca, me familiarizei com indicadores inteligentes. </font><font style="vertical-align: inherit;">E ent√£o pensei: por que n√£o consigo adicionar suporte a ponteiro inteligente √† minha lista? </font><font style="vertical-align: inherit;">Depois, retirei o tipo de ponteiro, al√©m de criar e excluir os dados do item da lista em uma estrat√©gia separada:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma estrat√©gia semelhante para ponteiros inteligentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrat√©gia de mem√≥ria utiliza tr√™s par√¢metros: o tipo do objeto Type, assim como um alocador e removedor de mem√≥ria. Com base no tipo do objeto, a estrat√©gia cria um tipo de ponteiro para esse tipo - Type * ou std :: shared_ptr, dependendo da estrat√©gia, e tamb√©m oferece as fun√ß√µes correspondentes para criar e excluir o objeto. Essas fun√ß√µes, se falarmos sobre distribuidores e eliminadores por padr√£o, criam um objeto atrav√©s da nova opera√ß√£o Type ou atrav√©s da fun√ß√£o std :: make_shared (...). Tudo isso funciona devido ao fato de a desreferencia√ß√£o de ponteiro ser a mesma para o ponteiro interno do C ++ e para o std :: shared_ptr inteligente. Obviamente, no caso de uma lista duplamente vinculada e ponteiros inteligentes, para evitar o recurso desagrad√°vel dos ponteiros em loop, std :: weak_ptr √© usado para ponteiros para o elemento anterior,e no momento da compila√ß√£o de uma lista duplamente vinculada, dependendo da estrat√©gia de mem√≥ria selecionada, voc√™ escolhe como desreferenci√°-la (esse √© um novo recurso do C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, agora a lista n√£o cria seus pr√≥prios elementos: ela redireciona a chamada para a estrat√©gia correspondente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrat√©gia de disponibilidade de itens</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, resolvi o problema da exist√™ncia de um elemento em uma estrat√©gia separada: se a lista precisar verificar a presen√ßa de alguns de seus elementos, ela simplesmente redirecionar√° a chamada para a estrat√©gia correspondente. A primeira abordagem direta e desajeitada se tornou uma estrat√©gia de pesquisa direta do DirectSearch. Em seguida, desenvolvi mais duas estrat√©gias baseadas nas duas abordagens descritas anteriormente com um bitmap na ordem de descri√ß√£o: SearchByIndex_BitArray e SearchByIndex_BitArray2. Para o Windows, para a possibilidade de ocupar gradualmente a mem√≥ria com um bitmap enquanto ele √© preenchido, ele tamb√©m adicionou mais duas estrat√©gias: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal e SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como observado anteriormente, para que essas estrat√©gias avan√ßadas funcionem, o item da lista deve conter um √≠ndice em um bitmap e um ponteiro para a classe base da lista (veja abaixo), ou seja, </font><font style="vertical-align: inherit;">foi definido da seguinte forma:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correla√ß√£o entre estrat√©gias de mem√≥ria e estrat√©gias de verifica√ß√£o de elementos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ap√≥s um exame detalhado, verificou-se que h√° uma armadilha na rela√ß√£o entre estrat√©gias de mem√≥ria e estrat√©gias para verificar a presen√ßa de um elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que voc√™ use ponteiros inteligentes como estrat√©gia de mem√≥ria, bem como uma estrat√©gia usando um bitmap para verificar rapidamente um item em uma lista. Voc√™ exclui um item, a estrat√©gia de mem√≥ria redefine seu ponteiro. No entanto, esse elemento n√£o √© realmente exclu√≠do da mem√≥ria, pois voc√™ possui outro ponteiro inteligente em seu programa de chamada. No futuro, voc√™ passar√° para a lista com esse elemento e ela far√° a verifica√ß√£o corretamente, referindo-se a seus dados - o √≠ndice no bitmap e o ponteiro para a lista. Na verdade, um elemento √© exclu√≠do da mem√≥ria apenas quando n√£o h√° mais nenhum link para ele.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este n√£o √© o caso ao usar ponteiros internos do C ++. Nesse caso, a estrat√©gia de mem√≥ria </font><font style="vertical-align: inherit;">excluir√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esse item da mem√≥ria usando a opera√ß√£o de exclus√£o. No futuro, como no caso anterior, consulte a lista com esse elemento e ele tentar√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acessar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o elemento nesse endere√ßo para ler o √≠ndice do bitmap e um ponteiro para a lista. Mas voc√™ n√£o pode fazer isso: um elemento j√° foi exclu√≠do da mem√≥ria! No melhor dos casos, voc√™ receber√° uma viola√ß√£o de acesso, no pior comportamento indefinido, quando a biblioteca C ++, a biblioteca de tempo de execu√ß√£o ou apenas o sistema operacional gravar l√° um valor completamente arbitr√°rio que a lista considera e tenta estabelecer a partir deles o fato da presen√ßa de um elemento na lista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, verifica-se que os ponteiros internos s√£o compat√≠veis apenas com a estrat√©gia de verifica√ß√£o direta do DirectSearch e, nesse caso, os ponteiros inteligentes oferecem n√£o apenas sua seguran√ßa inerente, mas tamb√©m um aumento de desempenho: somente com seu uso podem ser usadas matrizes de bits que aumentam significativamente o trabalho da lista. modo multithread! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantir consist√™ncia e eliminar configura√ß√µes de estrat√©gia incompat√≠veis, inclu√≠ a seguinte verifica√ß√£o em cada classe de lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele compara as classes de estrat√©gia passadas para a lista e, se forem incompat√≠veis, interrompe a compila√ß√£o com a sa√≠da da mensagem de erro correspondente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exce√ß√µes ou devolu√ß√µes de erros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, o tratamento de erros da lista era realizado apenas por meio de exce√ß√µes. </font><font style="vertical-align: inherit;">Mas de alguma forma, em alguns f√≥runs que n√£o me lembro, li que as exce√ß√µes tornam o programa mais lento e, para obter o m√°ximo desempenho, voc√™ deve usar o retorno de erro tradicional. </font><font style="vertical-align: inherit;">Ele fez isso criando duas novas classes baseadas nas originais, reescrevendo-as para retornar erros.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe base da lista</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A implementa√ß√£o das estrat√©gias acima para verificar a presen√ßa de elementos revelou um problema importante. O elemento list, como lembramos, cont√©m, al√©m do n√∫mero exclusivo nesta lista, tamb√©m um ponteiro para esta lista: afinal, podemos ter duas ou mais listas no programa, cada uma das quais cont√©m sua pr√≥pria matriz de bits de sinalizadores para a presen√ßa do elemento. Como garantir que esse elemento perten√ßa a essa lista espec√≠fica e n√£o a outro? Somente armazenando um ponteiro para a lista inteira dentro de cada elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema √© que agora, adicionando uma variedade de estrat√©gias √† nossa classe de lista, complicamos significativamente seu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Suponha que tenhamos duas listas diferentes com o mesmo tipo de elemento e as mesmas estrat√©gias de mem√≥ria, mas com estrat√©gias diferentes para bloquear e verificar a presen√ßa de elementos nelas. Para o compilador, esses ser√£o dois </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferentes </font><b><font style="vertical-align: inherit;">de</font></b><font style="vertical-align: inherit;"> listas. Ponteiro para qual tipo armazenar no elemento? Al√©m disso, a classe para o elemento n√£o sabe de antem√£o qual estrat√©gia ser√° aplicada; ela deve levar em considera√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elas </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se tamb√©m de que a estrat√©gia de bloqueio, a estrat√©gia para verificar a presen√ßa de um elemento e at√© a conectividade (simplesmente conectada ou duplamente conectada) da lista referem-se apenas ao comportamento da pr√≥pria lista, mas de forma alguma se relacionam aos </font><b><font style="vertical-align: inherit;">dados que</font></b><font style="vertical-align: inherit;"> ela armazena</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas n√≥s, como usu√°rios finais desta classe, estamos interessados ‚Äã‚Äãnos dados! </font><font style="vertical-align: inherit;">Ent√£o, por um lado, usando as classes de estrat√©gias, acrescentamos flexibilidade a n√≥s mesmos e, por outro, complicamos nossas vidas e acrescentamos problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â poss√≠vel de alguma forma tornar os lobos cheios e as ovelhas seguras? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode. </font><font style="vertical-align: inherit;">Voc√™ pode deduzir ponteiros para dados de uma classe (ou seja, de um tipo) de uma lista. </font><font style="vertical-align: inherit;">Al√©m dos dois n√≠veis acima de organiza√ß√£o da lista, outro apareceu - zero:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora porque </font><font style="vertical-align: inherit;">s√£o herdadas classes reais de listas; se quisermos acessar os dados da lista, independentemente de seu tipo real, devemos nos referir √† sua classe base ListBase. </font><font style="vertical-align: inherit;">Temos acesso ao in√≠cio e ao fim da lista e, em seguida, trabalhamos com os dados conforme desejamos. </font><font style="vertical-align: inherit;">O tipo espec√≠fico de lista, bem como a combina√ß√£o de estrat√©gias usadas nela, n√£o importa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteradores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J√° em pleno andamento, trabalhando em estreita colabora√ß√£o com a STL em um projeto real (n√£o o meu :)), al√©m de continuar estudando em livros, chamei a aten√ß√£o para o loop for da cole√ß√£o. </font><font style="vertical-align: inherit;">Afinal, esse ciclo n√£o √© apenas parte do STL, ele j√° se tornou uma parte interna da linguagem. </font><font style="vertical-align: inherit;">Eu pensei que tamb√©m poderia adicionar suporte para isso no meu projeto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, voc√™ precisa adicionar suporte para iteradores, abstraindo da maneira espec√≠fica de trabalhar com ponteiros e navegando pela lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um exemplo de iterador:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora tornou-se poss√≠vel escrever da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(‚Ä¶)<font></font>
{<font></font>
      ‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O leValue possui um tipo de ponteiro para um item da lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, inclu√≠ o suporte ao iterador apenas em listas suportadas por exce√ß√£o. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O motivo era simples: como o c√≥digo dentro do loop n√£o est√° dispon√≠vel, n√£o √© poss√≠vel lidar corretamente com os erros. </font><font style="vertical-align: inherit;">Tudo o que resta √© lidar com as exce√ß√µes envolvendo o loop em um bloco try. </font><font style="vertical-align: inherit;">Em geral, andar na lista de maneira que outros threads estejam trabalhando intensamente n√£o √© uma boa id√©ia: √© melhor bloquear a lista por conta pr√≥pria e depois pass√°-la com calma no modo de thread √∫nico. </font><font style="vertical-align: inherit;">Mas ainda assim, se por algum motivo voc√™ deseja fazer exatamente o mesmo que no exemplo acima, ent√£o agora h√° uma oportunidade para isso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma generaliza√ß√£o da estrat√©gia para verificar a presen√ßa de um elemento em um cont√™iner arbitr√°rio; </font><font style="vertical-align: inherit;">iteradores para listas sem exce√ß√µes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, eu originalmente planejei (e ainda planejo) criar n√£o apenas uma lista multithread, mas tamb√©m uma √°rvore. Para algumas de suas necessidades. O gr√°fico tamb√©m √© poss√≠vel, mas, em primeiro lugar, eu n√£o precisava dele e, em segundo lugar, o gr√°fico √© uma coisa complicada com algoritmos muito n√£o triviais, e eu n√£o queria mergulhar nele sem necessidade especial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na vers√£o inicial, a estrat√©gia para verificar a presen√ßa de um elemento era orientada apenas para a lista, e suas fun√ß√µes aceitavam um ponteiro para um elemento e um ponteiro para a classe base da lista (ListBase *). Posteriormente, pensei: mas no caso de uma √°rvore, voc√™ precisa fazer exatamente a mesma coisa! Fa√ßa uma estrat√©gia separada, mas essencialmente a mesma exatamente?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solu√ß√£o foi simples: ignore a lista. </font><font style="vertical-align: inherit;">Isso significava que agora a entrada seria recebida n√£o por ponteiros para elementos, mas por iteradores. </font><font style="vertical-align: inherit;">E as fun√ß√µes se tornar√£o padronizadas para aceitar ponteiros para um cont√™iner de qualquer tipo adequado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o agora a fun√ß√£o original, por exemplo, registrando uma lista em um bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transformado em uma fun√ß√£o de registro de cont√™iner:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A transi√ß√£o atrav√©s da lista por ponteiros foi transformada em uma transi√ß√£o atrav√©s de um cont√™iner abstrato usando iteradores. </font><font style="vertical-align: inherit;">Agora ser√° suficiente para a √°rvore implementar seus iteradores, e seu suporte com essas estrat√©gias j√° ser√° fornecido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso exigia o retorno de iteradores para as listas sem exce√ß√µes, mas tornando-os inacess√≠veis do lado de fora e destinados apenas para uso interno.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptador de dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo trabalhado intensivamente com STL, al√©m de digitar, iniciar e estudar programas de treinamento de livros, chamei a aten√ß√£o para a simplicidade de trabalhar com cont√™ineres STL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, preste aten√ß√£o ao seguinte c√≥digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu crio um vetor passando o tipo int de que preciso, e √© isso! O cont√™iner est√° imediatamente pronto para funcionar, se eu n√£o precisar alterar alguns par√¢metros adicionais definidos por padr√£o, o que geralmente n√£o acontece! Para mim, procedendo da organiza√ß√£o de tr√™s n√≠veis da lista, em cada caso eu precisaria primeiro criar uma nova classe para o item e depois escrever uma classe para a lista com dados, implementando opera√ß√µes espec√≠ficas para a lista final. Imagine quanto trabalho! E se voc√™ precisar criar outra lista para outros dados, precisar√° fazer tudo novamente ou, em casos extremos, copiar o c√≥digo anterior, alterando-o levemente. Isso j√° se assemelha √† mesma confus√£o com a linguagem C e a API do Windows, onde para cada a√ß√£o elementar voc√™ precisa preencher todos os dados necess√°rios para a estrutura e, em seguida, chamar a fun√ß√£o desejada. E mantenha tudo isso em menteOu tamb√©m leia constantemente o MSDN, estudando os argumentos de cada nova fun√ß√£o! Rotina e terrivelmente desconfort√°vel!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comecei a procurar maneiras de obter a oportunidade de criar minha lista por analogia com os cont√™ineres STL, para que eu n√£o tivesse que fazer sempre a mesma tarefa: criar uma classe separada para qualquer novo item e, em seguida, uma classe separada para trabalhar com elementos tipo. </font><font style="vertical-align: inherit;">Portanto, havia um adaptador para uma lista com dados de dados. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um adaptador para uma lista com dados √© uma classe, nos par√¢metros do modelo dos quais voc√™ passa imediatamente o tipo de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dados</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> necess√°rio </font><font style="vertical-align: inherit;">, e n√£o o elemento. </font><font style="vertical-align: inherit;">O tipo de elemento, que chamei de tipo composto do elemento, com base nesses dados que ele cria </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sozinho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ponto separado que vale a pena mencionar √© o acesso aos dados do item. </font><font style="vertical-align: inherit;">O tipo de elemento cont√©m a opera√ß√£o "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que, se houver um ponteiro para o elemento pElement, para acessar os dados armazenados nele, ele deve ser desreferenciado duas vezes:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once - para acessar um objeto do tipo ListElementCompound_OneLinked pelo ponteiro: ListElementCompound_OneLinked &amp; le = * pCurrElement e uma segunda vez - para acessar dados atrav√©s da opera√ß√£o '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece muito estranho e at√≠pico, mas sup√µe-se que voc√™ trabalhar√° n√£o atrav√©s de ponteiros (para isso voc√™ j√° tinha uma vers√£o inicial pronta), mas atrav√©s de iteradores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, ao criar uma lista baseada no adaptador, voc√™ especifica as estrat√©gias necess√°rias, como antes. </font><font style="vertical-align: inherit;">Com base em todos os seus par√¢metros, o adaptador cria automaticamente os tipos necess√°rios e os passa para a lista interna b√°sica, da qual √© herdada. </font><font style="vertical-align: inherit;">Defini√ß√£o geral de classe:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Especializa√ß√£o para a lista com exce√ß√µes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece muito volumoso, com v√°rios andares e feio. Eu sei. Mas ent√£o essa defini√ß√£o faz automaticamente tudo o que √© necess√°rio, sem a participa√ß√£o direta do programador que planeja us√°-la. Com a ajuda de std :: conditional_t ‚Äã‚Äãe std :: is_same_v, a estrat√©gia de verificar a presen√ßa de um elemento que voc√™ transmitiu √© comparada com estrat√©gias de pesquisa direta e, dependendo do resultado, o tipo correspondente do elemento da lista √© selecionado: com um √≠ndice no bitmap e um ponteiro para a lista ou sem . Isso economizar√° mem√≥ria devido a dados adicionais desnecess√°rios dentro de cada n√≥, se voc√™ usar uma estrat√©gia de pesquisa direta.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro da classe, os iteradores espec√≠ficos a ela s√£o implementados apenas, assim como as fun√ß√µes push_back () / push_front () exigidas por analogia com o STL, que redirecionam as chamadas para a lista multithread de base. </font><font style="vertical-align: inherit;">Voc√™ pode adicionar outras fun√ß√µes posteriormente, para que a lista se torne muito semelhante √†s STLs. </font><font style="vertical-align: inherit;">Mas, ao mesmo tempo, estar√° com todas as prote√ß√µes e op√ß√µes necess√°rias para aumentar a produtividade em um ambiente multithread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhar com um adaptador de dados come√ßou a se parecer com isso. </font><font style="vertical-align: inherit;">Criando objetos de lista:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ estiver satisfeito com todas as estrat√©gias e par√¢metros padr√£o, a cria√ß√£o de uma lista se tornar√° muito breve:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, externamente n√£o h√° absolutamente nenhuma diferen√ßa em rela√ß√£o ao STL, exceto que o nome da classe da lista √© diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora voc√™ pode trabalhar com ele da maneira antiga, atrav√©s das fun√ß√µes da classe base:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, os n√∫meros de 0 a 3. s√£o adicionados seq√ºencialmente ao final da lista.Para chegar ao argumento passado ao construtor do tipo criado quando ele √© criado, voc√™ deve colocar explicitamente os valores dos tr√™s primeiros argumentos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, h√° um certo inconveniente em indicar explicitamente o tipo, mas isso √© consequ√™ncia de uma tentativa de acessar a lista novamente atrav√©s da fun√ß√£o anterior para trabalhar com ponteiros. </font><font style="vertical-align: inherit;">Se voc√™ adicionar a fun√ß√£o back () ao adaptador, que retorna um iterador, o trabalho com ele n√£o ter√° esse problema:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ap√≥s ajustar os iteradores aos requisitos de STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
torna-se poss√≠vel usar a lista em algoritmos de biblioteca:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
‚Ä¶<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, voc√™ ter√° que organizar a intercepta√ß√£o e o tratamento de exce√ß√µes: todos os exemplos acima s√£o para trabalhar em um encadeamento para testar a compatibilidade com o STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O uso de algoritmos STL torna poss√≠vel um ponto interessante: voc√™ pode usar v√°rios algoritmos ao mesmo tempo, executando-os em v√°rios threads em paralelo. Isso n√£o pode ser feito por meios convencionais (por exemplo, usando std :: list e meios de bloqueio) sem ter acesso ao conte√∫do interno da classe list. S√≥ foi poss√≠vel bloquear a lista inteira durante todo o algoritmo. Obviamente, isso acelerar√° o trabalho do thread que est√° executando o algoritmo, mas tornar√° a lista inacess√≠vel para outros threads. No entanto, se voc√™ aplicar o mesmo bloqueio SRWLock "fino", poder√° executar v√°rios algoritmos na lista ao mesmo tempo, se eles n√£o modificarem essa lista. Mas o primeiro thread a ser gravado permanecer√° aguardando a conclus√£o da opera√ß√£o de leitura da lista por todos os outros threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A op√ß√£o de lista proposta permite organizar o trabalho com mais flexibilidade. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ pode organizar o trabalho com uma lista de forma a executar algoritmos n√£o modific√°veis ‚Äã‚Äãna primeira metade da lista por v√°rios threads ao mesmo tempo, enquanto v√°rios outros threads podem adicionar ou alterar algo na segunda metade da lista. </font><font style="vertical-align: inherit;">O fato de a lista estar bloqueada durante a dura√ß√£o de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opera√ß√£o, e n√£o o algoritmo inteiro, permitir√° a "grava√ß√£o" das opera√ß√µes de grava√ß√£o atrav√©s da sequ√™ncia de opera√ß√µes de leitura da lista, o que tornar√° o trabalho com ela mais flex√≠vel, produtivo e eficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinando duas variantes de classes de lista com e sem suporte a exce√ß√£o em uma com um par√¢metro booleano</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, as listas eram apenas com exce√ß√µes. </font><font style="vertical-align: inherit;">Em seguida, adicionei novos - sem exce√ß√£o de retorno de erro e renomeei os antigos com a adi√ß√£o da letra "E" no nome da classe: List_OneLinked_E e List_TwoLinked_E. </font><font style="vertical-align: inherit;">Isso √© necess√°rio para indicar quatro declara√ß√µes da classe list em todos os lugares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o decidi que isso era inconveniente por v√°rios motivos. </font><font style="vertical-align: inherit;">Por que precisamos de duas classes completamente diferentes se esta √© a mesma lista com ou sem suporte a exce√ß√£o? </font><font style="vertical-align: inherit;">Combinei as duas listas de cada tipo em uma √∫nica classe com um par√¢metro booleano adicional, e sua implementa√ß√£o espec√≠fica com e sem exce√ß√µes s√£o duas especializa√ß√µes de uma √∫nica classe para o par√¢metro booleano especificado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opera√ß√£o de mesclagem da lista de modelos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A opera√ß√£o de modelo de combina√ß√£o de listas funcionava anteriormente apenas com listas do mesmo tipo. Combinava apenas listas conectadas individualmente ou apenas listas duplamente conectadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, se voc√™ pensar sobre isso, n√£o importa realmente que tipo de lista est√° envolvido na opera√ß√£o: simplesmente conectado ou duplamente conectado. Suas estrat√©gias de bloqueio tamb√©m n√£o s√£o importantes, qual √© sua estrat√©gia para verificar a exist√™ncia de elementos e se eles suportam o tratamento de exce√ß√µes ou n√£o. Tudo isso se aplica apenas √† organiza√ß√£o da lista, mas n√£o aos dados nela contidos. √â importante que apenas o tipo de dados e a estrat√©gia de mem√≥ria dos elementos correspondam. Portanto, agora, depois de combinar listas com um par√¢metro booleano em rela√ß√£o a exce√ß√µes, a opera√ß√£o de entrada aceita listas de qualquer tipo com todas as variantes de seus par√¢metros:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, como resultado do tipo de lista, o compilador seleciona, dependendo da configura√ß√£o do par√¢metro externo ce_bGetMinLinksList, uma lista com conectividade m√≠nima ou m√°xima e, dependendo desta solu√ß√£o, seus par√¢metros correspondentes s√£o usados:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com base nos par√¢metros selecionados, uma lista de resultados √© criada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, nesta lista, os ponteiros s√£o configurados para o in√≠cio da primeira e o final da segunda lista:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, as listas anteriores s√£o limpas e a fun√ß√£o sai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ponto fraco dessa fun√ß√£o √© o bloqueio duplo de listas com poss√≠veis conflitos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode introduzir alguma fun√ß√£o para bloquear simultaneamente duas listas em uma √∫nica opera√ß√£o at√¥mica, como std :: lock (mutex1, mutex2), no entanto, nem todas as estrat√©gias de bloqueio suportam o bloqueio simult√¢neo de dois objetos de sincroniza√ß√£o, como std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, duas listas podem ter diferentes estrat√©gias de bloqueio. </font><font style="vertical-align: inherit;">A solu√ß√£o para esse problema (se houver) √© deixada para o futuro.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compila√ß√£o Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A compila√ß√£o foi verificada atrav√©s do projeto ListDataAdapterTest, originalmente escrito em C ++ puro, sem recursos espec√≠ficos do Windows, no Linux Ubuntu 16.04 LTS, o compilador g ++ 8.2.0. A maioria das pequenas nuances foi f√°cil de corrigir, e o projeto foi compilado com √™xito, e a sa√≠da do programa coincidiu com a mesma sa√≠da no Windows. No entanto, este √© o caso se voc√™ comentar a linha de combina√ß√£o de listas atrav√©s da opera√ß√£o "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ deixar como est√°, ocorrer√° um erro de compila√ß√£o na opera√ß√£o ‚Äú+‚Äù descrita acima, como se n√£o tivesse sido declarado privilegiado na classe do elemento composto da lista. Um erro semelhante ocorre na estrat√©gia de verifica√ß√£o direta para a presen√ßa do elemento DirectSearch. No Visual C ++, tudo est√° bem aqui, no entanto, esses mesmos erros aparecem se na classe de elemento composto e na classe de lista o coment√°rio sobre a declara√ß√£o da opera√ß√£o de combinar listas e o DirectSearch como privilegiado for comentado. Parece que o g ++ simplesmente pula essas declara√ß√µes e reclama dos membros privados / protegidos das classes correspondentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Na vers√£o 9 do g ++ 9 (Ubuntu 20.04), os mesmos erros.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que os an√∫ncios de privil√©gios s√£o ignorados e como corrigi-lo, eu n√£o entendi. </font><font style="vertical-align: inherit;">Eu n√£o sou bom nos recursos do compilador GCC. </font><font style="vertical-align: inherit;">Deixou esse momento tamb√©m para o futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exceto por essa nuance, n√£o h√° outros erros graves de compila√ß√£o.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descri√ß√£o da estrutura do arquivo de cabe√ßalho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caros leitores, publiquei o projeto completo sob a licen√ßa LGPL 3.0 no GitHub em: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esta √© uma solu√ß√£o que consiste em v√°rios projetos de teste. </font><font style="vertical-align: inherit;">O c√≥digo principal de uma lista multithread, em virtude de sua implementa√ß√£o por meio de modelos, est√° localizado em v√°rios arquivos de cabe√ßalho:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - a classe base de uma lista sem dados, que implementa todas as opera√ß√µes b√°sicas com uma lista, poss√≠vel sem definir dados espec√≠ficos, bem como adaptadores STL semelhantes para dados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - vers√µes da lista com suporte a exce√ß√£o.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - defini√ß√£o de classes base para um item da lista.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - defini√ß√£o de c√≥digos e classes de erro para exce√ß√µes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m dos arquivos principais listados, tamb√©m s√£o implementados:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - estrat√©gias para trabalhar com mem√≥ria;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - estrat√©gias de bloqueio.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - estrat√©gias para verificar a presen√ßa de um elemento na lista, descritas abstratamente para qualquer cont√™iner com iteradores.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m do projeto final, tamb√©m adicionei tr√™s vers√µes antigas na pasta "Vers√µes antigas", para que voc√™ possa avaliar brevemente como o projeto mudou conforme foi desenvolvido.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O projeto principal, chamado List, √© um programa com uma interface para o Windows implementada de maneira expl√≠cita por meio da API do Windows (n√£o sei mais o que fazer). Neste programa, voc√™ seleciona o tipo de lista (simplesmente conectado ou duplamente conectado) e tamb√©m indica o n√∫mero inicial de elementos e o n√∫mero desejado de threads. Os itens da lista cont√™m um √∫nico valor de 64 bits. Ap√≥s criar uma lista, o programa em cada thread no loop avan√ßa ou retrocede na lista para um n√∫mero aleat√≥rio de elementos e, em seguida, adiciona ou remove um elemento. Nenhum trabalho realmente √∫til √© feito nesta lista e toda a energia √© gasta no aquecimento da atmosfera, mas isso n√£o √© necess√°rio: precisamos apenas avaliar a operacionalidade e o desempenho da lista em um ambiente intensivo de v√°rios segmentos.A medida de desempenho √© o n√∫mero de itera√ß√µes do ciclo acima por segundo, executadas por todos os encadeamentos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista √© configurada indicando as estrat√©gias apropriadas no c√≥digo do programa e recompilando. Todas as estrat√©gias para o programa principal s√£o especificadas no m√≥dulo principal ListMain.cpp, a estrat√©gia de mem√≥ria √© selecionada em ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De um modo geral, experimentei um pouco com experimentos. Eu honestamente admito. Principalmente porque, em v√°rios casos, a lista de itens muda significativamente. Para que a pureza do experimento avalie o desempenho, seria necess√°rio fazer um teste de forma que o n√∫mero de elementos, em m√©dia, n√£o se modifique durante o per√≠odo do estudo ou mude de maneira extremamente insignificante. Somente sob tais condi√ß√µes seria justo avaliar o valor da produtividade com base no valor m√©dio. Se algu√©m estiver interessado, proponho organizar esses experimentos por conta pr√≥pria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o corrigi a organiza√ß√£o inicial dos testes pelos seguintes motivos. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro de tudo, eu era apenas pregui√ßoso.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em primeiro lugar, na minha opini√£o, ningu√©m est√° interessado nos valores quantitativos exatos do desempenho</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com erro calculado</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : √© importante avaliar o desempenho e o desempenho da lista de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maneira qualitativa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em segundo lugar, isso permite avaliar a altera√ß√£o no desempenho da lista com o crescimento de seu volume, o que tamb√©m √© uma informa√ß√£o bastante importante e interessante. </font><font style="vertical-align: inherit;">Por esses motivos, n√£o alterei os experimentos originais. </font><font style="vertical-align: inherit;">Em terceiro lugar, o mesmo c√≥digo de teste √© executado em todas as variantes da lista, o que, nesse sentido, as coloca nas mesmas condi√ß√µes: o fato de se comportarem de maneira diferente nesse caso nos permite julgar a qualidade das altera√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para habilitar a medi√ß√£o de desempenho, defina o sinalizador ce_bPerformanceMeasure no m√≥dulo ListMain.cpp como true. </font><font style="vertical-align: inherit;">O programa criar√° um arquivo "PerformanceMeasure.txt" com pares "n√∫mero de elementos - n√∫mero de ciclos / s", separados por um s√≠mbolo ":".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de Medi√ß√£o de Desempenho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, n√£o realizei testes para todas as configura√ß√µes poss√≠veis da lista, porque existem muitas. </font><font style="vertical-align: inherit;">Eu me concentrei apenas nos principais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os testes foram realizados no meu pedido da configura√ß√£o de mem√≥ria de 4 canais Intel Core i7-3930K, DDR3-1333, 4 canais, j√° desatualizada, mas ainda assim muito animada. </font><font style="vertical-align: inherit;">A compila√ß√£o foi realizada no Visual Studio 2019 para o modo Release x64, o sistema operacional Windows 7 x64. </font><font style="vertical-align: inherit;">Eu n√£o brinquei com o n√∫mero de threads, portanto, em todos os testes, o m√°ximo de 12 threads dispon√≠veis neste sistema sempre foram usados. </font><font style="vertical-align: inherit;">Sempre foi criada uma lista com 10.000 itens selecionados aleatoriamente, com exce√ß√£o do √∫ltimo teste.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste de Estrat√©gia de Mem√≥ria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando ponteiros internos, como mencionei anteriormente, apenas uma estrat√©gia de pesquisa direta pode ser usada para verificar a presen√ßa de um item na lista. Dessa forma, para que a compara√ß√£o seja correta e, para indicadores inteligentes, apenas essa estrat√©gia ser√° aplicada neste teste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como estrat√©gia de bloqueio, uma se√ß√£o cr√≠tica com um bloqueio fino foi selecionada como a mais produtiva no Windows (veja abaixo): ThreadLockingWin_SRWLock. O tratamento de erros √© realizado retornando um c√≥digo de erro, ou seja, op√ß√£o sem exce√ß√µes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este gr√°fico mostra o n√∫mero de ciclos executados por todos os encadeamentos no total por segundo, dependendo da dura√ß√£o do teste (em segundos). Obviamente, o desempenho √© inconsistente devido √† natureza aleat√≥ria dos threads que acessam a lista.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo gr√°fico mostra como o n√∫mero de itens da lista muda durante o teste. N√£o farei nenhuma declara√ß√£o ponderada sobre esse cronograma, exceto o √≥bvio: √© claro que eles funcionam de maneiras ligeiramente diferentes, e a conectividade da lista junto com a estrat√©gia de mem√≥ria tem efeito. Uma lista duplamente vinculada com ponteiros internos √© a √∫nica que inesperadamente n√£o muda no tamanho m√©dio durante toda a dura√ß√£o do teste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Produtividade m√©dia (ciclos / s) para o per√≠odo medido:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelo menos, pode-se argumentar que a op√ß√£o de lista com ponteiros inteligentes √© mais lenta que a vers√£o com ponteiros internos, o que √© esperado. </font><font style="vertical-align: inherit;">Nos dois casos, de alguma forma, verifica-se que um conectado individualmente √© mais r√°pido que um conectado duplamente, o que mostra mais uma vez que no modo multithread, muitas coisas familiares podem mudar.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testando estrat√©gias de disponibilidade de itens</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mais interessante √© testar estrat√©gias para verificar a presen√ßa de um elemento. Como estrat√©gia de mem√≥ria, ponteiros inteligentes s√£o naturalmente indicados pelos motivos descritos anteriormente. O restante √© o mesmo: travando com ThreadLockingWin_SRWLock e manipulando erros retornando um c√≥digo de erro. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos dizer com certeza que todas as estrat√©gias funcionam aproximadamente da mesma maneira. Isso √© compreens√≠vel: em uma lista com v√≠nculo √∫nico, quando voc√™ exclui seu item, √© necess√°rio examinar a lista todas as vezes para o item que indica o item a ser exclu√≠do. Isso anula todos os esfor√ßos para otimizar o acesso √† lista e acelerar a verifica√ß√£o da presen√ßa de um elemento nela. Portanto, uma lista isolada n√£o √© a melhor op√ß√£o para um trabalho multithread desordenado intensivo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o vou dar um gr√°fico sobre o n√∫mero de elementos: n√£o h√° nada interessante l√°. Observo apenas que agora o n√∫mero de elementos em todas as listas est√° aumentando. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma situa√ß√£o completamente diferente surge para uma lista duplamente vinculada. Para deixar os gr√°ficos bonitos, eu at√© exclu√≠ a estrat√©gia de visualiza√ß√£o direta da lista do DirectSearch, porque pelos resultados ela claramente ‚Äúcai‚Äù do resto. Al√©m disso, aumentei o n√∫mero limite de elementos em 4 vezes, atingindo o qual o teste √© interrompido.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, o desempenho do acesso √† lista (assim como a carga do processador, passando de 99 a 100%) aumentou drasticamente e significativamente! Em segundo lugar, um par de estrat√©gias com preenchimento seq√ºencial de bits de matriz tem aproximadamente o mesmo desempenho que n√£o muda durante o teste. A velocidade do segundo par de estrat√©gias diminui de maneira n√£o linear. Por que √© assim, ficar√° claro no gr√°fico o n√∫mero de n√≥s na lista.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As listas com o primeiro par de estrat√©gias aumentam o n√∫mero de elementos e linearmente. O segundo par fornece um crescimento significativamente n√£o linear e, quanto maior o n√∫mero de elementos tiver uma lista, mais lento ele cresce. Isso √© compreens√≠vel, pois com um aumento no n√∫mero de elementos ao criar um novo, √© necess√°rio, em m√©dia, examinar um n√∫mero maior de bits da matriz em busca de gra√ßa. O primeiro par de estrat√©gias n√£o lida com isso, usa um novo bit para cada novo elemento. Assim, uma lista com essa estrat√©gia tem desempenho m√°ximo de acesso e fica mais pr√≥xima da lista cl√°ssica: tanto a cria√ß√£o quanto a exclus√£o de elementos s√£o executadas em um tempo constante, independentemente do n√∫mero de elementos. No entanto, fornece algumas garantias de integridade e seguran√ßa em um ambiente multithread, embora ao custo de uma certa quantidade de mem√≥ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista com o segundo par de estrat√©gias, √© claro, √© visivelmente mais lenta. No entanto, ainda √© significativamente mais r√°pido que as op√ß√µes de verifica√ß√£o direta. Portanto, voc√™ pode realmente recomend√°-lo como um intermedi√°rio no desempenho, mas mais ideal em termos de consumo de mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, as listas com uma estrat√©gia de pesquisa direta tamb√©m funcionar√£o mais lentamente com um aumento no n√∫mero de elementos: um n√∫mero maior de elementos precisar√° ser visualizado a cada vez. S√≥ que durante o teste a lista n√£o consegue crescer tanto que se torna percept√≠vel, apesar das flutua√ß√µes ca√≥ticas no desempenho.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os valores m√©dios de desempenho mostram que estrat√©gias com um bitmap durante o preenchimento sequencial permitiram aumentar a produtividade de acessar a lista em cerca de 200 vezes, ou seja, </font><font style="vertical-align: inherit;">2 ordens de magnitude em compara√ß√£o com estrat√©gias de pesquisa direta. </font><font style="vertical-align: inherit;">Esta √© uma mudan√ßa muito radical. </font><font style="vertical-align: inherit;">O desempenho das op√ß√µes com preenchimento de bits ideal para a mem√≥ria, como observado acima, √© obviamente mais lento, mas ainda muito mais r√°pido que as op√ß√µes com verifica√ß√£o direta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m √© importante notar que o uso de um mecanismo de transfer√™ncia de mem√≥ria sob demanda diminui um pouco o acesso √† lista. </font><font style="vertical-align: inherit;">N√£o √© muito cr√≠tico, mas o efeito est√° presente e percept√≠vel, especialmente - na variante com uso econ√¥mico de mem√≥ria (linha amarela nos gr√°ficos).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste de estrat√©gia de bloqueio</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como o desempenho da lista mudar√° ao escolher diferentes estrat√©gias de bloqueio. </font><font style="vertical-align: inherit;">Usei tr√™s tipos de bloqueios: bloqueio "fino" do SRWLock, se√ß√£o cr√≠tica regular do Windows e mutex STL. </font><font style="vertical-align: inherit;">Para o restante das configura√ß√µes, foi utilizada a vers√£o mais r√°pida da lista: ponteiros inteligentes biconetados, a estrat√©gia para verificar a presen√ßa de um elemento - SearchByIndex_BitArray, uma variante sem exce√ß√µes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como seria de esperar, um bloqueio "fino" aumenta o desempenho em quase 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A velocidade do trabalho com a se√ß√£o cr√≠tica do Windows e o mutex STL √© praticamente a mesma.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exce√ß√µes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para avaliar o impacto das exce√ß√µes no desempenho, realizei tr√™s testes. </font><font style="vertical-align: inherit;">Os dois primeiros usaram uma lista duplamente vinculada, ponteiros inteligentes, uma estrat√©gia de verifica√ß√£o de presen√ßa de elementos - SearchByIndex_BitArray e uma se√ß√£o cr√≠tica do SRWLock. </font><font style="vertical-align: inherit;">O mesmo teste foi usado para o √∫ltimo teste, apenas a trava foi substitu√≠da pela se√ß√£o cr√≠tica usual para compara√ß√£o. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode-se observar que o suporte a exce√ß√µes pode realmente reduzir a velocidade do trabalho, especialmente se voc√™ usar uma op√ß√£o de bloqueio mais "bruta". </font><font style="vertical-align: inherit;">No entanto, lembre-se de que, nesse caso, o suporte para STL e loops na cole√ß√£o n√£o estar√° dispon√≠vel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi um experimento em grande escala para mim. N√£o quero dizer os testes acima, mas todo o projeto. Ele n√£o esperava ser t√£o arrastado. No entanto, eu a realizei completamente e na medida em que planejei. Obviamente, no final, essa ainda n√£o √© a vers√£o final, mas apenas um prot√≥tipo funcional, a implementa√ß√£o das id√©ias descritas no in√≠cio do artigo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com os resultados do teste, √© claro que, no Windows, ela se tornou a lista duplamente vinculada mais r√°pida com ponteiros inteligentes, uma estrat√©gia para verificar a presen√ßa do elemento SearchByIndex_BitArray, uma se√ß√£o cr√≠tica do SRWLock e sem exce√ß√µes. Nesta configura√ß√£o, a lista fornece desempenho m√°ximo com acesso ca√≥tico intensivo a partir de v√°rios fluxos e o comportamento √© o mais pr√≥ximo da lista cl√°ssica, com garantias de seguran√ßa no modo multithread. A op√ß√£o com um consumo de mem√≥ria mais econ√¥mico tamb√©m √© muito produtiva (em compara√ß√£o com a verifica√ß√£o direta do DirectSearch), mas ainda √© visivelmente mais lenta que a anterior, e seu desempenho diminui com o aumento do n√∫mero de elementos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ acha que vou fazer campanha aqui pelo que √© legal e por que √© √≥timo us√°-lo, ent√£o n√£o: na verdade, come√ßarei desencorajando voc√™. </font><font style="vertical-align: inherit;">De fato:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pense se √© poss√≠vel usar um cont√™iner com um arranjo diferente de elementos: por exemplo, uma matriz. </font><font style="vertical-align: inherit;">N√£o tem problemas como uma lista.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    ‚Äì       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   ‚Äì     .    . ,   ‚Äì          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As estrat√©gias de transfer√™ncia de mem√≥ria para uma matriz de bits sob demanda tamb√©m aproximam pelo menos parcialmente uma lista multithread da cl√°ssica: pelo menos at√© que a matriz de mem√≥ria esteja completamente cheia, ser√° preciso exatamente o necess√°rio. </font><font style="vertical-align: inherit;">No entanto, isso implica uma redu√ß√£o no desempenho.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Desvantagens do projeto:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A possibilidade observada anteriormente de bloqueio m√∫tuo na opera√ß√£o de listas combinadas.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que isso tenha sido interessante. Iniciantes podem ser √∫teis, porque tudo √© considerado do simples ao complexo. Pe√ßo aos profissionais que digam quanto, na sua opini√£o, as id√©ias descritas aqui s√£o aplic√°veis ‚Äã‚Äãna pr√°tica em projetos reais? Houve um caso em sua atividade quando, de acordo com o significado, voc√™ precisava de uma lista ou √°rvore, e n√£o de outro cont√™iner, mas isso se tornou um gargalo no seu programa devido aos problemas descritos aqui? Ou voc√™ teve que mudar ou complicar bastante o programa. Se voc√™ j√° encontrou isso antes, como resolveu isso?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, em ess√™ncia, este projeto √© apenas a realiza√ß√£o de minha pr√≥pria vis√£o sobre a solu√ß√£o desse problema. </font><font style="vertical-align: inherit;">√â prov√°vel que exista alguma op√ß√£o melhor. </font><font style="vertical-align: inherit;">Repito o pensamento desde o in√≠cio de que o fiz inicialmente e n√£o planejei coloc√°-lo em exibi√ß√£o p√∫blica. </font><font style="vertical-align: inherit;">Ainda assim, fiz isso pelas raz√µes descritas l√°, por isso terei prazer em receber cr√≠ticas construtivas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com uma revis√£o cuidadosa do c√≥digo, voc√™ pode encontrar um design como esse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa magia negra merece um artigo separado. </font><font style="vertical-align: inherit;">√â verdade que isso √© ainda menos pr√°tico do que a lista multithread descrita aqui, mas tem seus pr√≥prios recursos curiosos. </font><font style="vertical-align: inherit;">Se voc√™ est√° interessado em saber de onde veio e por que apareceu, e deseja que eu fale sobre isso mais tarde em detalhes, escreva nos coment√°rios.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt506702/index.html">Os HDDs mais confi√°veis ‚Äã‚Äãde acordo com o Backblaze Q1 2020</a></li>
<li><a href="../pt506704/index.html">Por que escrever em PHP em 2020? Holivarim √© um podcast interativo no Youtube nesta quinta-feira</a></li>
<li><a href="../pt506706/index.html">O desempenho do Java moderno ao trabalhar com grandes quantidades de dados, parte 1</a></li>
<li><a href="../pt506708/index.html">Autentica√ß√£o de dois fatores VPN / Mikrotik - simples e escal√°vel</a></li>
<li><a href="../pt506710/index.html">Gerenciar v√°rios cat√°logos de endere√ßos no Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../pt506726/index.html">Experi√™ncia no uso da tecnologia Rutoken para registro e autoriza√ß√£o de usu√°rios no sistema (parte 2)</a></li>
<li><a href="../pt506730/index.html">Bufo ou Suricata. Parte 1: escolha um IDS / IPS gratuito para proteger a rede corporativa</a></li>
<li><a href="../pt506732/index.html">Reutiliza√ß√£o em toda a organiza√ß√£o de componentes da interface do usu√°rio</a></li>
<li><a href="../pt506734/index.html">C√°lculos transit√≥rios em redes el√©tricas</a></li>
<li><a href="../pt506736/index.html">Quantos m√©todos devem estar em uma classe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>