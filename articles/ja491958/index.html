<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨 👰🏾 🐫 スケルトンアニメーション圧縮ガイド 🖍️ 🥡 🎃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、簡単なアニメーション圧縮スキームといくつかの関連する概念を実装する方法の概要を説明します。私はこの問題の専門家ではありませんが、このトピックに関する情報はほとんどなく、断片化されています。このトピックに関する詳細な記事を読みたい場合は、次のリンクにアクセスすることをお勧めします。
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>スケルトンアニメーション圧縮ガイド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491958/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/6v/gp/o16vgpz4u-9_ntko92qweoxqzx0.png" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、簡単なアニメーション圧縮スキームといくつかの関連する概念を実装する方法の概要を説明します。</font><font style="vertical-align: inherit;">私はこの問題の専門家ではありませんが、このトピックに関する情報はほとんどなく、断片化されています。</font><font style="vertical-align: inherit;">このトピックに関する詳細な記事を読みたい場合は、次のリンクにアクセスすることをお勧めします。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://nfrechette.github.io/2016/10/21/anim_compression_toc/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technology.riotgames.com/news/compressing-skeletal-animation-data</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2011/10/low-level-animation-part-2.html</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始める前に、骨格アニメーションとその基本概念のいくつかを簡単に紹介する価値があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションと圧縮の基本</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキニングを忘れた場合、骨格アニメーションはかなり単純なトピックです。キャラクターのボーンの変換を含むスケルトンの概念があります。これらのボーン変換は階層形式で保存されます。実際、それらはグローバルな位置と親の位置の間のデルタとして保存されます。ゲームエンジンでは、ローカルはモデル/キャラクタースペースと呼ばれることが多く、グローバルはワールドスペースであるため、ここでの用語は混乱を招きます。アニメーションの用語では、ローカルはボーンの親のスペースと呼ばれ、グローバルは、ルートボーンの動きがあるかどうかに応じて、キャラクターのスペースまたはワールドスペースのいずれかです。そんなに気にしないで。重要なことは、ボーンの変換は、その親に対してローカルに保存されるということです。これには多くの利点があり、特に混合（ブレンド）の場合は次のようになります。2つの位置の混合がグローバルである場合、位置で線形に補間され、ボーンの増減とキャラクターの変形につながります。</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、デルタを使用する場合、ミキシングは1つの差異から別の差異へと実行されるため、2つのポーズ間の1つのボーンのデルタ変換が同じであれば、ボーンの長さは一定のままです。この方法を採用するのが最も簡単ですが（完全に正確ではありません）、デルタを使用すると、ミキシング中にボーンの位置が「球形」に移動し、グローバルな変換をミキシングすると、ボーンの位置が直線的に移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケルタルアニメーションは、（通常は）一定のフレームレートを持つキーフレームの順序付きリストです。キーフレームはスケルトンポーズです。キーフレーム間のポーズを取得したい場合は、両方のキーフレームをサンプリングし、それらの間の時間の一部をミックスの重みとして使用して、キーフレーム間でミックスします。以下の画像は、30fpsで作成されたアニメーションを示しています。アニメーションには合計5つのフレームがあり、開始から0.52秒後にポーズを取得する必要があります。したがって、フレーム1のポーズとフレーム2のポーズをサンプリングし、約57％の混合ウェイトでそれらを混合する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/f11/c43/733f11c43022b935901e6f20f8a70fab.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5フレームのアニメーションと中間フレーム時間でのポーズのリクエストの例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記の情報があり、メモリは問題ではないと信じている場合、ポーズを順次保存することは、次に示すようにアニメーションを保存する理想的な方法です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/7c5/f3c/d287c5f3cbfd9a8144d20432c3a258dc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンプルなアニメーションデータストレージ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが完璧なのですか？キーフレームをサンプリングすると、単純なmemcpy操作になります。中間ポーズのサンプリングには、2つのmemcpy操作と1つの混合操作が必要です。キャッシュの観点から、memcpyを使用して2つのデータブロックを順番にコピーします。つまり、最初のフレームをコピーした後、キャッシュの1つにすでに2番目のフレームがあります。あなたが言うことができます：待って、私たちがミキシングをするとき、私たちはすべての骨を混ぜる必要があります。それらのほとんどがフレーム間で変化しない場合はどうなりますか？ボーンをレコードとして保存し、変更された変換のみをミックスする方が良いのではないでしょうか。これが実装されている場合、個々のレコードを読み取るときにキャッシュミスが少し発生する可能性があるため、どの変換を混合する必要があるかを追跡する必要があります。しかし、本質的には、すでにキャッシュにあるメモリの2つのブロックに1つの命令を適用することです。さらに、ミキシングコードは比較的単純で、多くの場合、分岐のない単なるSIMD命令のセットであり、最新のプロセッサはそれらを瞬時に処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの問題は、特に次の条件がデータの95％に当てはまるゲームで、非常に大量のメモリを使用することです。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">骨の長さは一定です</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどのゲームのキャラクターは骨を伸ばしません。したがって、同じアニメーション内では、変換の記録は一定です。</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常、ボーンのスケーリングは行いません。</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケールはゲームアニメーションではほとんど使用されません。</font><font style="vertical-align: inherit;">映画やVFXでかなり積極的に使用されていますが、ゲームではほとんど使用されていません。</font><font style="vertical-align: inherit;">通常は同じ目盛りを使用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、実行時に作成したほとんどのアニメーションでは、この事実を利用して、ボーン変換全体を8つの浮動小数点変数に保持しました。4はクォータニオンを回転させ、3は移動し、1はスケールします。</font><font style="vertical-align: inherit;">これにより、実行時のポーズのサイズが大幅に縮小され、ミキシングおよびコピー時の生産性が向上します。</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてを念頭に置いて、元のデータ形式を見ると、メモリの消費がどれほど非効率であるかがわかります。</font><font style="vertical-align: inherit;">各ボーンの変位値とスケール値は、変化しなくても複製します。</font><font style="vertical-align: inherit;">そして、状況はすぐに手に負えなくなってきています。</font><font style="vertical-align: inherit;">通常、アニメータは30fpsの頻度でアニメーションを作成します。AAAレベルのゲームでは、キャラクターのボーンは通常約100です。</font><font style="vertical-align: inherit;">この情報量と8浮動小数点のフォーマットに基づいて、結果としてポーズごとに約3 KB、1秒あたり94 KBのアニメーションが必要になります。</font><font style="vertical-align: inherit;">値はすぐに蓄積され、一部のプラットフォームではすべてのメモリが簡単に詰まる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、圧縮について話しましょう。</font><font style="vertical-align: inherit;">データを圧縮しようとする場合、考慮すべきいくつかの側面があります。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮比</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">占有されているメモリの量を削減するためにどれだけ管理できましたか</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースデータから失われた情報の量</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮率</font></font></strong><ul>
<li>     </li>
</ul></li>
<li><strong> </strong><ul>
<li>           .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は主に品質と速度に関心があり、記憶にはあまり関心がありません。さらに、私はゲームアニメーションを使用しており、実際には、メモリへの負荷を軽減するために、データで変位やスケールを使用する必要がないという事実を利用できます。これにより、フレーム数の減少による品質の低下やその他の損失のあるソリューションを回避することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションの圧縮がパフォーマンスに与える影響を過小評価しないように注意することも非常に重要です。以前のプロジェクトの1つでは、サンプリングレートが約35％低下し、品質の問題も発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションデータの圧縮を開始するとき、考慮すべき2つの主要な重要な領域があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報の個々の要素をキーフレーム（四元数、フロートなど）にどれだけ速く圧縮できるか。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーフレームのシーケンスを圧縮して、冗長な情報を削除するにはどうすればよいですか。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの離散化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションのほとんどすべてを、データの離散化という1つの原則に減らすことができます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">離散化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、値を連続区間から離散値のセットに変換したいと言うのが難しい方法です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">離散化フロート</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浮動小数点値のサンプリングに関しては、その浮動小数点値を取得し、より少ないビットを使用して整数として表すように努めています。トリックは、整数は実際にはソース番号を表すのではなく、連続した間隔にマッピングされた離散間隔の値を表す場合があるということです。通常、非常に単純なアプローチが使用されます。値をサンプリングするには、最初に元の値の間隔が必要です。この間隔を受け取ったら、この間隔の初期値を正規化します。次に、この正規化された値に、目的の特定の出力サイズ（ビット単位）で可能な最大値を掛けます。つまり、16ビットの場合、値に65535を掛けます。結果の値は、最も近い整数に丸められて格納されます。これは画像にはっきりと示されています：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e73/827/f7be73827067126fd51c0bf6f2396b10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビット浮動小数点を符号なし16ビット整数にサンプリングする例元の</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
値を再び取得するには、単純に逆の順序で操作を実行します。ここで、値の初期間隔をどこかに記録する必要があることに注意してください。そうしないと、サンプル値をデコードできません。サンプリングされた値のビット数は、正規化された間隔のステップサイズ、したがって元の間隔のステップサイズを決定します。デコードされた値はこのステップサイズの倍数になるため、サンプリングプロセスによって発生する最大エラーを簡単に計算できるため、ビット数を決定できます。アプリケーションに必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なサンプリング操作を実行するためのかなり便利でシンプルなライブラリがあるため、ソースコードの例は示しません。これは、このトピックの優れたソースです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">//github.com/r-lyeh-archived/quant</font></a><font style="vertical-align: inherit;">（その四元数の離散化関数は使用しないでください。詳しくは後で説明します）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クォータニオン圧縮</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クォータニオン圧縮はよく研究されているトピックなので、他の人がよりよく説明したことを繰り返すことはしません。</font><font style="vertical-align: inherit;">これは、このトピックに関する最も適切な説明を提供するスナップショット圧縮投稿へのリンク</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">//gafferongames.com/post/snapshot_compression/</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私はその話題について何か言いたいことがあります。</font><font style="vertical-align: inherit;">クォータニオン圧縮について説明するビットスクイッドの投稿では、クォータニオンコンポーネントごとに約10ビットのデータを使用して、クォータニオンを32ビットに圧縮することを推奨しています。</font><font style="vertical-align: inherit;">これは、ビットイクの投稿に基づいているため、Quantが行うこととまったく同じです。</font><font style="vertical-align: inherit;">私の意見では、そのような圧縮は大きすぎ、私のテストでは強い揺れを引き起こしました。</font><font style="vertical-align: inherit;">おそらく著者はキャラクターのより深い階層を使用していませんが、私のアニメーションの例から15以上の四元数を掛けると、組み合わされたエラーは非常に深刻になります。</font><font style="vertical-align: inherit;">私の意見では</font><font style="vertical-align: inherit;">、精度</font><font style="vertical-align: inherit;">の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">絶対</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小値は、クォータニオンあたり48ビットです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリングによるダウンサイジング</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな圧縮方法とレコードの配置を検討する前に、元の回路で単に離散化を適用した場合にどのような種類の圧縮が得られるかを見てみましょう。以前と同じ例（100ボーンのスケルトン）を使用するので、クォータニオンごとに48ビット（3 x 16ビット）を使用すると、48ビット（3×16）が移動し、16ビットがスケーリングし、合計で変換されます。 32バイトではなく14バイトが必要です。これは元のサイズの43.75％です。つまり、頻度が30FPSのアニメーションの1秒間で、ボリュームを約94 KBから約41 KBに減らしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはまったく問題ありません。離散化は比較的低コストの操作であるため、解凍時間にあまり影響しません。</font><font style="vertical-align: inherit;">私たちは最初の良い出発点を見つけました。場合によっては、リソースの予算内でアニメーションを実装し、優れた品質とパフォーマンスを保証するのに十分な場合もあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコード圧縮</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてが非常に複雑になります。特に、開発者がキーフレームの削減やカーブフィッティングなどのテクニックを試し始めたときは、特に複雑になります。</font><font style="vertical-align: inherit;">また、この段階で、アニメーションの品質を実際に下げ始めています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなほとんどすべての決定では、各骨の特性（回転、変位、およびスケール）が個別のレコードとして格納されると想定されています。</font><font style="vertical-align: inherit;">したがって、前に示したように、回路を反転できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/752/16a/f6475216adb6ac795e1737de30aef6af.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボーンのデータをレコードとして</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
保存ここでは、すべてのレコードを順番に保存するだけでなく、回転、変位、スケールのすべてのレコードをグループ化することもできます。基本的な考え方は、各ポーズのデータ​​の保存からレコードの保存に移行することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実行すると、他の方法を使用して占有メモリをさらに減らすことができます。 1つ目は、フレームのドロップを開始することです。注：これはレコード形式を必要とせず、この方法は前のスキームに適用できます。この方法は機能しますが、ほとんどのデータが破棄されるため、アニメーションの小さな動きが失われます。この手法はPS3で積極的に使用されており、非常に低いサンプリング周波数、たとえば毎秒7フレームまで（通常はそれほど重要ではないアニメーションの場合）に急降下しなければなりませんでした。私はこれから悪い思い出があります。アニメーションプログラマーとして、失われた詳細と表現力をはっきりと見ていますが、システムプログラマーの観点から見ると、アニメーションは「ほぼ」同じであると言えます。多くのメモリを節約します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチを省略し（私の意見では、破壊的すぎる）、他の可能なオプションを検討します。別の一般的なアプローチは、各レコードのカーブを作成し、カーブ上のキーフレームの削減を実行することです。重複するキーフレームを削除します。ゲームアニメーションの観点から見ると、このアプローチでは、動きとスケールの記録が完全に圧縮され、場合によっては1つのキーフレームに削減されます。このソリューションは非破壊的ですが、変換を取得する必要があるたびに曲線を計算する必要があるため、解凍する必要があります。これは、メモリ内のデータにアクセスできないためです。</font><strong><font style="vertical-align: inherit;">一方向のみのアニメーション</font></strong><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">計算すると</font></strong><font style="vertical-align: inherit;">、状況が少し改善される可能</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性があります。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、各ボーンの各アニメーションのサンプラーの状態（つまり、カーブの計算をどこから取得するか）を保存しますが、メモリの増加とコードの複雑性の大幅な増加によりこれを支払う必要があります。最近のアニメーションシステムでは、アニメーションを最初から最後まで再生しないことがよくあります。多くの場合、特定の時間オフセットでは、同期化されたブレンディングやフェーズマッチングなどのおかげで、新しいアニメーションに移行します。多くの場合、オブジェクトの照準/見方の混合などを実装するために、連続したポーズではなく個別のポーズをサンプリングし、アニメーションは逆の順序で再生されることがよくあります。したがって、そのようなソリューションを使用することはお勧めしません。複雑さと潜在的なバグによって引き起こされる面倒なことに価値がないだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーブ上の同一のキーを削除するだけでなく、類似のキーが削除されるしきい値を指定するという概念もあります。これにより、フレームをドロップする方法と同様に、アニメーションがよりフェードするようになります。これは、データに関しては最終結果が同じであるためです。アニメーションの圧縮スキームがよく使用されます。この方法では、レコードごとに圧縮パラメーターが設定され、アニメーターはこれらの値で常に苦しめられ、品質の維持とサイズの縮小を同時に試みます。これは苦痛でストレスの多いワークフローですが、古い世代のコンソールの限られたメモリで作業する場合に必要です。幸いなことに、今日私たちは大量のメモリを持っているので、そのようなひどいものは必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての側面は、Riot / BitSquidとNicholasの投稿で公開されています（私の記事の冒頭にあるリンクを参照）。それらについては詳しくは触れません。代わりに、レコードの圧縮について決定したことについて話します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...レコードを圧縮しないことにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手を振る前に説明しましょう... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レコードにデータを保存すると、すべてのフレームの回転データが保存されます。動きとスケールに関しては、圧縮中に動きとスケールが静的であるかどうかを追跡し、そうであれば、レコードごとに1つの値のみを保存します。つまり、レコードがXに沿って移動し、YとZに沿って移動しない場合、レコードをXに沿って移動するすべての値を保存しますが、レコードをYとZに沿って移動する1つの値のみを保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況は、ほとんどのボーンでアニメーションの約95％で発生するため、最終的には、品質を失うことなく、占有メモリを大幅に削減できます。これにはコンテンツ作成（DCC）の観点からの作業が必要です。アニメーション作成ワークフローでボーンにわずかな動きやズームを持たせたくないのですが、そのような利点は追加のコストに見合うものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアニメーションの例では、移動のあるレコードは2つしかなく、縮尺のあるレコードはありません。次に、アニメーションの1秒間で、データ量は41 KBから18.6 KBに減少します（つまり、元のデータの量の最大20％）。アニメーションの継続時間が増えると状況はさらに良くなり、リソースをターンの記録と動的な動きにのみ費やし、静的な記録のコストは一定に保たれるため、長いアニメーションではさらに節約できます。また、サンプリングによる品質の低下を経験する必要もありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべての情報を念頭に置いて、私の最終的なデータスキーマは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f5/347/eb0/9f5347eb09718967ebacbe89d443e992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮されたアニメーションデータスキームの例（レコードごとに3フレーム）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さらに、オフセットをデータブロックに保存して、各ボーンのデータを開始します。</font><font style="vertical-align: inherit;">ポーズ全体を読み取らずに、1つのボーンのみのデータをサンプリングする必要がある場合があるため、これは必要です。</font><font style="vertical-align: inherit;">これにより、レコードデータに直接アクセスする簡単な方法が提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのメモリブロックに保存されているアニメーションデータに加えて、各レコードの圧縮オプションも用意しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/b3d/7a3/4d7b3d7a3f1362c0429d72591268dbce.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Krugerエンジンからのレコードの圧縮パラメーターの例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらのパラメーターは、各レコードのサンプル値をデコードするために必要なすべてのデータを格納します。</font><font style="vertical-align: inherit;">また、レコードの静的を監視するため、サンプリング時に静的レコードに遭遇したときに圧縮データを処理する方法がわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、各レコードの離散化が個別であることにも気づくでしょう：圧縮中に、各レコードの各特性の最小値と最大値（たとえば、Xに沿って移動）を追跡して、データが最小/最大間隔内で離散化され、最大の精度が維持されるようにします。</font><font style="vertical-align: inherit;">データを破壊することなく（値が間隔の外にある場合）、重大なエラーを発生させることなく、グローバルサンプリング間隔を作成することは、一般的には可能ではないと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、アニメーション圧縮を実装しようとする私の愚かな試みの簡単な要約を次に示します。結局、ほとんど圧縮を使用しています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491942/index.html">item2vecを使用して同様の製品を推奨する方法</a></li>
<li><a href="../ja491944/index.html">2つのプラットフォームを1つに統合する方法。Yandex.Kew開発者エクスペリエンス</a></li>
<li><a href="../ja491946/index.html">プログラミングの法則</a></li>
<li><a href="../ja491948/index.html">設計トークンはさらに多くのことができます：UIコンポーネントに関する単一の情報源を作成します</a></li>
<li><a href="../ja491956/index.html">Rust 1.42.0リリース：スライステンプレートとより便利なパニックメッセージ</a></li>
<li><a href="../ja491960/index.html">道に迷いにくい時代</a></li>
<li><a href="../ja491962/index.html">VPNキラー。バトルサーバーへの適切なリモートアクセス</a></li>
<li><a href="../ja491964/index.html">SMB v3でのリモートコード実行：CVE-2020-0796</a></li>
<li><a href="../ja491974/index.html">コロナウイルス：今すぐ行動する必要がある理由</a></li>
<li><a href="../ja491976/index.html">私たちは、オンラインストアまたはプロダクションのためにUNIT経済を転換します</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>