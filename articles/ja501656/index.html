<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏿 ❄️ 🥅 Reactコンポーネントの企業ライブラリーの開発。クロスプラットフォームアプローチ ⚾️ 🏂🏼 🔩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、最大のDIY小売業者の1社で、設計システムの実装が成功した事例を紹介します。ReactおよびReact Nativeライブラリを使用したUIコンポーネントのクロスプラットフォーム開発の原理とアプローチ、および異なるプラットフォームのプロジェクト間でコードを再利用する問題の解決策について...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reactコンポーネントの企業ライブラリーの開発。クロスプラットフォームアプローチ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/luxoft/blog/501656/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、最大のDIY小売業者の1社で、設計システムの実装が成功した事例を紹介します。</font><font style="vertical-align: inherit;">ReactおよびReact Nativeライブラリを使用したUIコンポーネントのクロスプラットフォーム開発の原理とアプローチ、および異なるプラットフォームのプロジェクト間でコードを再利用する問題の解決策について説明します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、すべてがどのように始まったのか、そしてなぜシステム設計を実装するというアイデアが浮かんだのかについて少し説明します。それはすべて、店の売り手のためのモバイルAndroidアプリケーションから始まりました。アプリケーションは、React-Nativeフレームワークに基づいて構築されています。開始機能は、カタログや製品カード、販売ドキュメントでの製品の検索など、いくつかのモジュールで表されていました。ちなみに、今やこれはかなり強力なアプリケーションであり、店内のインフォメーションデスクの機能の大部分をすでに置き換えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、物流部門の従業員やさまざまなコンフィギュレーター向けのWebアプリケーションプロジェクトが開始されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、これらのアプリケーションの設計に対する一般的なアプローチの理解と、かなり大きなコードベースの存在が明らかになりました。そして、さらなる再利用のために他を体系化することは論理的でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UI / UXを体系化するために、設計システムを開発することにしました。詳細については触れません。インターネットでは、このトピックに関する多くの記事を見つけることができます。たとえば、Habréでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrei Sundiev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">作品</font></a><font style="vertical-align: inherit;">を読むことをお勧めします</font><font style="vertical-align: inherit;">。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムを設計する理由とその利点は何ですか？ 1つ目は、共通の経験と製品の使用感です。アプリケーションに関係なく、ユーザーは使い慣れたインターフェイスを使用できます。ボタンは見慣れた方法で動作し、メニューは適切な場所に開き、適切なダイナミクスで、入力フィールドは通常の方法で機能します。 2番目の利点は、設計側と開発側の両方からの特定の標準と一般的なアプローチの導入です。新しい機能はそれぞれ、すでに確立されている基準とアプローチに従って開発されています。初日から、新入社員は明確な仕事の列を受け取ります。次は、コンポーネントの再利用と開発の簡素化です。毎回「車輪を再発明」する必要はありません。既成のブロックからインターフェースを構築し、期待される最終結果を得ることができます。まあ、そもそも顧客にとっての主な利点は、お金と時間の節約です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、私たちは何をしましたか。実際、コンポーネントライブラリだけでなく、クロスプラットフォームフレームワーク全体を作成しました。フレームワークはバッチスキームに基づいています。 5つのコアnpmパッケージがあります。これは、クロスプラットフォームのWebおよびAndroidアプリケーションを展開するための中核です。モジュール、ユーティリティ、サービスのパッケージ。そして、後で説明するコンポーネントのパッケージ。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、コンポーネントパッケージのUMLダイアグラムです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/kn/xs/wiknxsuqj_n4jze72crt4c4u10g.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには、コンポーネント自体が含まれ、その一部は独立（要素）であり、一部は互いに接続されているだけでなく、内部コアまたは「サブコア」にも接続されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「サブ核」に何が含まれるかをさらに詳しく考えてみましょう。最初は、システム設計の視覚層です。ここでのすべては、カラーパレット、タイポグラフィ、インデントシステム、グリッドなどに関するものです。次のブロックは、コンポーネントが機能するために必要なサービスです。たとえば、ComponentsConfig（コンポーネント構成）、StyleSet（この概念については後で詳しく説明します）、Device（デバイスAPIを操作する方法）です。そして、3番目のブロックはあらゆる種類のヘルパー（リゾルバー、スタイルジェネレーターなど）です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/7l/f6/fx7lf6zz7n8olddc2yuf7576s6a.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリを開発するとき、コンポーネントの設計にアトミックなアプローチを使用しました。すべては、基本的なコンポーネントまたは要素の作成から始まりました。それらは互いに独立した基本的な「粒子」です。主なものは、ビュー、テキスト、画像、アイコンです。次は、より複雑なコンポーネントです。それぞれが1つ以上の要素を使用して構造を構築します。たとえば、ボタン、入力フィールド、選択などです。次のレベルはパターンです。これらは、UIの問題を解決するためのコンポーネントの組み合わせです。たとえば、承認フォーム、パラメーターと設定を含むヘッダー、異なるモジュールで使用できる設計者が設計した製品カードなどです。最後の、そして最も難しいと同時に重要なレベルは、いわゆる振る舞いです。これらはすぐに使えるモジュールで、特定のビジネスロジックを実装し、必要に応じてバックエンドリクエストのセットを含めます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/00/jv/e3/00jve3iwyh64n0tifikfxtoz0v4.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、コンポーネントライブラリの実装に移りましょう。</font><font style="vertical-align: inherit;">前に述べたように、ターゲットプラットフォームは2つあります-WebとAndroid（react-native）です。</font><font style="vertical-align: inherit;">Web上では、これらはdiv、span、img、ヘッダーなどのすべてのWeb開発者によく知られている要素です。react-nativeでは、これらはコンポーネントView、Text、Image、Modalです。</font><font style="vertical-align: inherit;">そして最初に合意したのは、コンポーネントの名前です。</font><font style="vertical-align: inherit;">次のように、反応ネイティブスタイルのシステムを使用することにしました。</font><font style="vertical-align: inherit;">1つ目は、いくつかのコンポーネントベースが既にプロジェクトに実装されていること、2つ目は、これらの名前が最も一般的で、Web開発者と反応ネイティブ開発者の両方に理解できることです。</font><font style="vertical-align: inherit;">たとえば、Viewコンポーネントについて考えてみます。</font><font style="vertical-align: inherit;">Webの条件付きレンダリングコンポーネントメソッドは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
	<span class="hljs-keyword">return</span>(
		<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...props</span>}&gt;</span>
			{children}
		<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
	)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">内部的には、これは必要な小道具と子孫を持つdivに過ぎません。</font><font style="vertical-align: inherit;">反応ネイティブでは、構造は非常に似ており、divの代わりにビューコンポーネントのみが使用されます。</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
	<span class="hljs-keyword">return</span>(
		<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> {<span class="hljs-attr">...props</span>}&gt;</span>
			{children}
		<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><font></font>
	)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生します：これを1つのコンポーネントに組み合わせ、同時にレンダリングを分割する方法？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、HOCまたは高次コンポーネントと呼ばれるReactパターンが役に立ちます。</font><font style="vertical-align: inherit;">このパターンのUMLダイアグラムを描画しようとすると、次のような結果になります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/73/sz/tb/73sztbbrwdkvgknh3edlwk93gyo.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、各コンポーネントは、外部から小道具を受け取り、両方のプラットフォームに共通のロジックを担当する、いわゆるデリゲートと、各プラットフォームに固有のメソッドが既にカプセル化されている2つのプラットフォームパーツと最も重要なレンダリングで構成されます。</font><font style="vertical-align: inherit;">たとえば、ボタンデリゲートコードを考えてみます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buttonDelegate</span>(<span class="hljs-params">ReactComponent: ComponentType&lt;Props&gt;</span>): <span class="hljs-title">ComponentType</span>&lt;<span class="hljs-title">Props</span>&gt; </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButtonDelegate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span>&lt;<span class="hljs-title">Props</span>&gt; </span>{<font></font>
        <font></font>
        <span class="hljs-comment">// Button common methods</span><font></font>
<font></font>
        render() {<font></font>
           <span class="hljs-keyword">const</span> { onPress, onPressIn, onPressOut } = <span class="hljs-keyword">this</span>.props;
            <span class="hljs-keyword">const</span> delegate = {
                <span class="hljs-attr">buttonContent</span>: <span class="hljs-keyword">this</span>.buttonContent,
                <span class="hljs-attr">buttonSize</span>: <span class="hljs-keyword">this</span>.buttonSize,
                <span class="hljs-attr">iconSize</span>: <span class="hljs-keyword">this</span>.iconSize,
                <span class="hljs-attr">onClick</span>: onPress,
                <span class="hljs-attr">onMouseUp</span>: onPressIn,
                <span class="hljs-attr">onMouseDown</span>: onPressOut,
                <span class="hljs-attr">onPress</span>: <span class="hljs-keyword">this</span>.onPress,
                <span class="hljs-attr">textColor</span>: <span class="hljs-keyword">this</span>.textColor,<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ReactComponent</span> {<span class="hljs-attr">...this.props</span>} <span class="hljs-attr">delegate</span>=<span class="hljs-string">{delegate}</span> /&gt;</span></span>);<font></font>
        }<font></font>
    };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デリゲートは、コンポーネントのプラットフォーム部分を引数として受け取り、両方のプラットフォームに共通のメソッドを実装して、それらをプラットフォーム部分に渡します。</font><font style="vertical-align: inherit;">コンポーネント自体のプラットフォーム部分は次のとおりです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span>&lt;<span class="hljs-title">WebProps</span>, <span class="hljs-title">State</span>&gt; </span>{<font></font>
    <font></font>
   <span class="hljs-comment">// Web specific methods</span><font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">delegate</span>: { onPress, buttonContent } } = <span class="hljs-keyword">this</span>.props;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{this.classes}</span>
                {<span class="hljs-attr">...buttonProps</span>}
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onPress}</span>
                <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
            &gt;</span>
                {buttonContent(this.spinner, this.iconText)}
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> buttonDelegate(Button);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、すべてのプラットフォーム機能を備えたrenderメソッドです。デリゲートの一般的な機能は、propsデリゲートを介してオブジェクトの形で提供されます。反応ネイティブ実装のボタンのプラットフォーム部分の例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span>&lt;<span class="hljs-title">NativeProps</span>, <span class="hljs-title">State</span>&gt; </span>{<font></font>
<font></font>
    <span class="hljs-comment">// Native specific methods</span><font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">delegate</span>: { onPress, buttonContent } } = <span class="hljs-keyword">this</span>.props;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">styleSet</span>=<span class="hljs-string">{this.styles}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TouchableOpacity</span>
                    {<span class="hljs-attr">...butonProps</span>}
                    <span class="hljs-attr">onPress</span>=<span class="hljs-string">{onPress}</span>
                    <span class="hljs-attr">style</span>=<span class="hljs-string">{this.touchableStyles}</span>
                    {<span class="hljs-attr">...touchableProps</span>}    
                &gt;</span>
                    {buttonContent(this.spinner, this.iconText)}
                <span class="hljs-tag">&lt;/<span class="hljs-name">TouchableOpacity</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> buttonDelegate(Button);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ロジックは似ていますが、反応ネイティブコンポーネントが使用されます。どちらのリストでも、buttonDelegateは共通のロジックを持つHOCです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントの実装におけるこのアプローチでは、プロジェクトの組み立て中にプラットフォームパーツを分離するという疑問が生じます。 Webのプロジェクトで使用するWebpackがWeb向けのコンポーネントの一部のみを収集することを確認する必要がありますが、React-NativeのMetroバンドラーはWebのコンポーネントに注意を払わずにプラットフォームパーツを「フック」する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、プラットフォームのファイル拡張子プレフィックスを指定できる組み込みのメトロバンドラー機能を利用しました。この場合、metro.config.jsは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-attr">resolver</span>: {
        <span class="hljs-attr">useWatchman</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">platforms</span>: [<span class="hljs-string">'native'</span>],<font></font>
    },<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、バンドルをビルドするとき、metroは最初に拡張子native.jsのファイルを探し、それが現在のディレクトリにない場合は、拡張子.jsのファイルをフックします。この機能により、コンポーネントのプラットフォームパーツを個別のファイルに配置することが可能になりました。Webパーツは.jsファイルに配置され、react-nativeパーツは.native.js拡張子を持つファイルに配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、webpackはNormalModuleReplacementPluginを使用して同じ機能を持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロスプラットフォームアプローチのもう1つの目的は、コンポーネントのスタイルを設定する単一のメカニズムを提供することでした。 Webアプリケーションの場合、最終的に通常のcssにコンパイルされるsassプリプロセッサーを選択しました。それら。 Webコンポーネントについては、おなじみのreact className開発者を使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React-nativeコンポーネントは、インラインスタイルと小道具スタイルによってスタイル設定されます。</font><font style="vertical-align: inherit;">これら2つのアプローチを組み合わせて、Androidアプリケーションのスタイルクラスを使用できるようにする必要がありました。</font><font style="vertical-align: inherit;">この目的のために、styleSetの概念が導入されました。これは、文字列の配列にすぎません-クラス名：</font></font><br>
<br>
<pre><code class="javascript hljs">styleSet: <span class="hljs-built_in">Array</span>&lt;string&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、同じ名前のStyleSetサービスがreact-nativeに実装され、クラス名を登録できるようになりました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> StyleSet.define({
    <span class="hljs-string">'lmui-Button'</span>: {
        <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">6</span>,<font></font>
    },<font></font>
    <span class="hljs-string">'lmui-Button-buttonSize-md'</span>: {
        <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">paddingBottom</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">paddingLeft</span>: <span class="hljs-number">12</span>,
        <span class="hljs-attr">paddingRight</span>: <span class="hljs-number">12</span>,<font></font>
    },<font></font>
    <span class="hljs-string">'lmui-Button-buttonSize-lg'</span>: {
        <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">8</span>,
        <span class="hljs-attr">paddingBottom</span>: <span class="hljs-number">8</span>,
        <span class="hljs-attr">paddingLeft</span>: <span class="hljs-number">16</span>,
        <span class="hljs-attr">paddingRight</span>: <span class="hljs-number">16</span>,<font></font>
    },<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webコンポーネントの場合、styleSetは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classnames</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリを使用して「接着」されたcssクラス名の配列です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトはクロスプラットフォームであるため、コードベースの成長に伴い、外部依存関係の数も増えることは明らかです。さらに、依存関係はプラットフォームごとに異なります。たとえば、Webコンポーネントの場合、スタイルローダー、react-dom、クラス名、webpackなどのライブラリが必要です。react-nativeコンポーネントの場合は、「react-native自体」など、多数の「ネイティブ」ライブラリが使用されます。コンポーネントライブラリを使用することになっているプロジェクトにターゲットプラットフォームが1つしかない場合、別のプラットフォームにすべての依存関係をインストールするのは合理的ではありません。この問題を解決するために、npm自体のpostinstallフックを使用しました。このスクリプトでは、指定されたプラットフォームの依存関係をインストールするスクリプトがインストールされています。依存関係自体は、パッケージのpackage.jsonの対応するセクションに登録されていました。ターゲットプラットフォームは、プロジェクトのpackage.jsonで配列として指定する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このアプローチには欠点があり、CIシステムでの組み立て中にいくつかの問題が発生しました。問題の根本は、package-lock.jsonでは、postinstallで指定されたスクリプトが、登録されているすべての依存関係をインストールしないことでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の別の解決策を探す必要がありました。解決策は簡単でした。 2パッケージスキームが適用され、すべてのプラットフォームの依存関係は、対応するプラットフォームパッケージの依存関係セクションに配置されました。たとえば、Webの場合、パッケージはcomponents-webと呼ばれ、package.jsonファイルが1つあります。これには、Webプラットフォームのすべての依存関係と、コンポーネントコンポーネントを含むメインパッケージが含まれています。このアプローチにより、依存関係の分離を維持し、package-lock.jsonの機能を維持することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、コンポーネントライブラリを使用したJSXコードの例を示します。</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;View row&gt;
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>
      <span class="hljs-attr">col-xs</span>=<span class="hljs-string">{12}</span>
      <span class="hljs-attr">col-md</span>=<span class="hljs-string">{8}</span>
      <span class="hljs-attr">col-lg</span>=<span class="hljs-string">{4}</span>
      <span class="hljs-attr">col-xl</span>=<span class="hljs-string">{4}</span>
      <span class="hljs-attr">middle-xs</span>
      <span class="hljs-attr">col-md-offset-3</span>
   /&gt;</span></span>
     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">size</span>=<span class="hljs-string">”fs1”</span>&gt;</span>Sample text<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><font></font>
   &lt;/View&gt;<font></font>
&lt;/View&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードスニペットはクロスプラットフォームであり、Web用の反応アプリケーションでも、反応ネイティブのAndroidアプリケーションでも同じように機能します。</font><font style="vertical-align: inherit;">必要に応じて、iOSで同じコードを「巻き上げる」ことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにして、私たちが直面した主なタスク、つまり、さまざまなプロジェクト間での設計アプローチとコードベースの両方の最大の再利用が解決されました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックのどの質問が次の記事で学ぶのが面白かったかをコメントで教えてください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501646/index.html">Go、Vue、そして3日間で開発：患者を監視するためのリアルタイムシステム</a></li>
<li><a href="../ja501648/index.html">VS Codeの10個の拡張機能なしではプログラムできません</a></li>
<li><a href="../ja501650/index.html">.wasmファイル内には何がありますか？wasm-decompileの紹介</a></li>
<li><a href="../ja501652/index.html">フルスタックサーバーとしてのNuxt：フロントエンド+バックエンドAPIサーバー（パート1）</a></li>
<li><a href="../ja501654/index.html">リモートサイトでワークプロセスを構築する：実用的な推奨事項</a></li>
<li><a href="../ja501658/index.html">「遠く」でワークフローを確立する方法：7つの実際的な手順</a></li>
<li><a href="../ja501662/index.html">AxureがSketchとFigmaを曲げることができたが、曲げられなかった理由</a></li>
<li><a href="../ja501664/index.html">ビデオ会議は現在、市場であり、新しいテクノロジーです。Longrid、パート2</a></li>
<li><a href="../ja501668/index.html">移動するオブジェクトとツールの通信を提供して、その信頼性を向上させる</a></li>
<li><a href="../ja501670/index.html">注射1回あたりの生命または210万ドルはどれくらいですか？素晴らしい遺伝子治療</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>