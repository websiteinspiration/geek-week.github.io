<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔬 🤼 💇 私の過ちの経験 👨🏽‍🚒 🧘🏻 🧒🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私の過ちの経験
 エラーリスト
 

1. 全能クラスMCManager
2. 画面間のナビゲーションを発明する
3. 多くの継承はありません
4. 私たち自身の生産のアーキテクチャまたは自転車を作り続けます
5. MVVM with Soul MVP
6. ナビゲーションまたはルーターの2番目の試...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>私の過ちの経験</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451996/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の過ちの経験</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーリスト</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全能クラスMCManager</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面間のナビゲーションを発明する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの継承はありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たち自身の生産のアーキテクチャまたは自転車を作り続けます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVVM with Soul MVP</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ナビゲーションまたはルーターの2番目の試みとナビゲーションの湾曲</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常任マネージャー</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私を含む多くの人が、特定の状況で正しいことを行う方法、コードを正しく書く方法、アーキテクチャソリューションを適用する方法などを書いています。しかし、それが正しく行われなかった方法と、彼の過ちに基づいて作られました。</font><font style="vertical-align: inherit;">ほとんどの場合、これらは開発者の道をたどるすべての人の一般的な間違いであるか、何か新しいものになるでしょう。</font><font style="vertical-align: inherit;">私は自分の経験を共有し、他の人のコメントを読みたいだけです。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 全能クラスMCManager</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ITでの最初の1年間の作業、より具体的にはiOS開発の後で、私はすでに十分に建築家であり、作成する準備ができていると判断しました。それでも直感的に、ビジネスロジックとプレゼンテーションレイヤーを分離する必要があることがわかりました。しかし、これを行う方法についての私の考えの質は、現実とはかけ離れていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は新しい職場に移り、既存のプロジェクトの新しい機能を独自に開発するよう割り当てられました。これは、Instagramで動画を録画するのと似ていて、ユーザーがボタンを押したまま録画が実行され、その後、動画のいくつかの断片が接続されます。当初、この機能を個別のプロジェクトとして、またはサンプルの形式で作成することが決定されました。これは、私が理解しているように、1年以上続いた建築上の問題の原因となっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、このサンプルは本格的なビデオ録画および編集アプリケーションに成長しました。おもしろいのは、最初のサンプルにMCプレフィックスが収集された略語の名前があったことです。プロジェクトの名前はすぐに変更されましたが、Objective-Cの命名規則で必要な接頭辞はMCに残りました。それで、万能のMCManagerクラスが生まれました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sz/jw/m_/szjwm_hbfvtxjbovprczya2jyca.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはサンプルであり、最初は機能が単純だったので、1つのマネージャークラスで十分だと判断しました。前述のように、機能には、開始/停止オプションを使用してビデオフラグメントを記録し、さらにこれらのフラグメントをビデオ全体に結合することが含まれます。そしてその瞬間に、最初の間違い、つまりMCManagerクラスの名前に名前を付けることができます。 MCManager、カール！他の開発者にその目的、その機能、およびその使用方法について伝えるべきクラスの名前は何ですか？そうです、絶対に何もありません！そして、これは付録にあり、その名前にはMの文字も彼の母親のCも含まれていません。ただし、これは私の主な間違いではありませんが、パルチザン名のクラスがすべてを行ったので、単語からのすべてが絶対にすべてであり、これが重要な間違いでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオ録画は1つの小さなサービスです。ファイルシステムでのビデオファイルのストレージの管理は、複数のビデオを1つに結合するための2番目の追加サービスです。これら3つの独立したサービスの作業は、1人のマネージャーに統合することが決定されました。ファサードパターンを使用してビジネスロジック用のシンプルなインターフェースを作成し、さまざまなコンポーネントの相互作用に関するすべての不要な詳細を隠すというアイデアは高貴でした。初期段階では、そのようなファサードクラスの名前でさえ、特にサンプルでは疑いを引き起こしませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、顧客はデモを気に入って、すぐにサンプルは本格的なアプリケーションに変わりました。リファクタリングに十分な時間がなかったこと、顧客が作業中のコードをやり直すことを望まなかったことを正当化できますが、正直なところ、私自身、私は優れたアーキテクチャを設定したと思っていました。実際、ビジネスロジックとプレゼンテーションを分離するというアイデアは成功しました。アーキテクチャはシングルクラスのMCManagerの1つのクラスであり、これは数十のサービスやその他のマネージャのファサードでした。はい、これはシングルトンでもあり、アプリケーションのすべてのコーナーから利用できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
災害全体の規模はすでにわかっています。</font><font style="vertical-align: inherit;">数千行のコードが含まれるクラスで、読みにくく、保守が困難です。</font><font style="vertical-align: inherit;">個々の機能を別のアプリケーションに転送するために強調表示する可能性については、すでに沈黙しています。これは、モバイル開発では非常に一般的です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらくして自分のためにした結論は、あいまいな名前のユニバーサルクラスを作成することではありません。</font><font style="vertical-align: inherit;">ロジックは細かく分割する必要があり、すべてに共通のインターフェースを作成する必要はないことに気付きました。</font><font style="vertical-align: inherit;">実際、これは、SOLIDの原則の1つであるインターフェース分離の原則に準拠しない場合に起こることの例でした。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面間のナビゲーションを発明する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロジックとインターフェースの分離だけが上記のプロジェクトについて心配した唯一の問題ではありません。その時点で画面コードとナビゲーションコードを分離するつもりだったとは言いませんが、ナビゲーション用に自転車を思いついたことがわかりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ab/dt/j1/abdtj1sogyy-j7ppjfbk9uhshge.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルには3つの画面しかありませんでした。記録されたビデオの表を含むメニュー、記録画面、および後処理画面です。ナビゲーションスタックに重複するViewControllerが含まれていることを気にしないために、UINavigationControllerを使用しないことにしました。 RootViewcontrollerを追加しました。注意深い読者は、プロジェクト設定でメインとして設定されたMCRootViewControllerであるとすでに推測しています。同時に、ルートコントローラーはアプリケーション画面の1つではなく、目的のUIViewControllerを表示するだけでした。これでは不十分であるかのように、ルートコントローラーは表されるすべてのコントローラーのデリゲートでもありました。その結果、各時点で、階層には2つのvcしかなく、すべてのナビゲーションはデリゲートパターンを使用して実装されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外観：各画面には、ナビゲーションメソッドが示されている独自のデリゲートプロトコルがあり、ルートコントローラーはこれらのメソッドを実装して画面を変更しました。 RootViewControllerは現在のコントローラーをディスミシルし、新しいコントローラーを作成して表示しましたが、画面間で情報を転送することは可能でした。幸い、ビジネスロジックは最もクールなシングルトンクラスに含まれていたため、画面には何も保存されておらず、簡単に破棄できませんでした。この場合も、両方の脚で足を引っ張られて、ときどきつまずきましたが、善意が実現されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご想像のとおり、ビデオ録画画面からメインメニューに戻る必要がある場合、メソッドが呼び出されました。</font></font><br>
<br>
<pre><code class="objectivec hljs">- (<span class="hljs-keyword">void</span>)cancel;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
またはそのようなものであり、ルートコントローラはすでにすべての汚い仕事をしています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、MCRootViewControllerはMCManagerのアナログになりましたが、画面間のナビゲーションでは、アプリケーションの成長と新しい機能の追加に伴い、新しい画面が追加されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自転車工場は容赦なく機能し、モバイルアプリケーションアーキテクチャに関する記事は無視し続けました。しかし、ナビゲーションを画面から分離するという考えを決してあきらめませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
利点は、画面が独立していて再利用できることですが、これは正確ではありません。しかし、不利な点は、そのようなクラスを維持することの困難さを含みます。以前に選択した画面をスクロールして戻る必要がある場合に、画面のスタックが不足する問題。画面間の遷移の複雑なロジックであるルートコントローラは、新しい画面を正しく表示するために、ビジネスロジックの一部に影響を及ぼしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のMCRootViewControllerは開閉原理に違反しているため、一般に、この方法ですべてのナビゲーションをアプリケーションに実装するべきではありません。拡張することはほとんど不可能であり、すべての変更はクラス自体に常に行われる必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイルアプリケーションの画面間のナビゲーションについて詳しく読むようになり、ルーターやコーディネーターなどのアプローチに慣れました。</font><font style="vertical-align: inherit;">共有するものがあるので、ルーターについては少し後で説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの継承はありません</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分の真珠だけでなく、他の人たちの面白いアプローチや解決策も共有したいと思います。私が傑作を作ったのと同じ場所で、彼らは私に簡単な仕事を任せました。タスクは、別のプロジェクトから自分のプロジェクトに画面を追加することでした。 PMで決定したように、浅い分析と短い思考の後、これには2〜3時間はかかるはずです。何が問題なのかは、既製のスクリーンクラスをアプリケーションに追加するだけです。実際、すべてがすでに行われているため、ctrl + cおよびctrl + vを実行する必要があります。ここにほんの小さなニュアンスがあります。このアプリケーションを作成した開発者は、継承を本当に愛していました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/e7/h8/bve7h8vugtvsjzyw_ml4esh5vbe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なViewControllerをすぐに見つけました。幸運にも、ロジックとプレゼンテーションの分離はありませんでした。コントローラーに必要なすべてのコードが含まれていたとき、それは古き良きアプローチでした。私はそれを自分のプロジェクトにコピーし、それを機能させる方法を理解し始めました。そして最初に発見したのは、必要なコントローラーが別のコントローラーから継承されていることです。よくあることですが、かなり期待される出来事です。時間があまりなかったので、必要なクラスを見つけてプロジェクトにドラッグしました。さて、それはうまくいくはずだと私は思いました、そして私はそんなに間違ったことはありませんでした！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なクラスだけでなく、プロジェクトにコピーする必要があるカスタムクラスの多くの変数があったため、それぞれが何かを継承しました。一方、基本クラスは継承されているか、カスタムタイプのフィールドが含まれていたため、多くの人が推測したり、継承したりしましたが、残念ながら、これはNSObject、UIViewController、UIViewではありませんでした。したがって、不要なプロジェクトの3分の1がプロジェクトで私に移行されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタスクを完了するのに予想される時間はあまりなかったので、xCodeがプロジェクトを簡単に起動するために必要なクラスを単に追加する方法の他の方法はありませんでした。</font><font style="vertical-align: inherit;">結果として、2、3時間は少し遅れました。結局のところ、私は継承階層の全体を掘り下げて、真の彫刻家のように、余分な部分を切り捨てなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、相続のような「素晴らしい」ものも含め、すべての良いものは適度にあるべきだという結論に達しました。</font><font style="vertical-align: inherit;">それから私は継承の欠点を理解し始めました。</font><font style="vertical-align: inherit;">私は、再利用可能なモジュールを作成する場合は、モジュールをより独立させる必要があると自分で結論付けました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たち自身の生産のアーキテクチャまたは自転車を作り続けます</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい作業場所に移動して新しいプロジェクトを開始するとき、私は建築の設計で利用可能なすべての経験を考慮に入れ、作成を続けました。当然、私はすでに発明されたアーキテクチャを無視し続けましたが、同時に「分割統治」の原則に固執しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはSwiftが登場する少し前のことなので、Objective-cの可能性について詳しく調べました。言語機能を使用して依存性注入を行うことにしました。私はlib拡張ツールに触発されましたが、その名前すら覚えていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一番下の行は：BaseViewController基本クラスで、BaseViewModelクラスフィールドを追加しました。</font><font style="vertical-align: inherit;">したがって、各画面について、基本的なものを継承した独自のコントローラーを作成し、コントローラーがviewModelと対話するためのプロトコルを追加しました。</font><font style="vertical-align: inherit;">それから魔法がやってきた。</font><font style="vertical-align: inherit;">viewModelプロパティを再定義し、目的のプロトコルのサポートを追加しました。</font><font style="vertical-align: inherit;">次に、このプロトコルを実装する特定の画面用に新しいViewModelクラスを作成しました。</font><font style="vertical-align: inherit;">その結果、BaseViewControllerのviewDidLoadメソッドで、モデルプロトコルのタイプを確認し、BaseViewModelのすべての子孫のリストを確認し、必要なクラスを見つけて、必要なタイプのviewModelを作成しました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なViewControllerの例</font></font></b><div class="spoiler_text"><pre><code class="objectivec hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// MVC model</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"BaseMVCModel.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">BaseViewController</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">BaseViewControllerDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><font></font>
<font></font>
<span class="hljs-keyword">@required</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)backFromNextViewController:(BaseViewController *)aNextViewController withOptions:(<span class="hljs-built_in">NSDictionary</span> *)anOptionsDictionary;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BaseViewController</span> : <span class="hljs-title">UIViewController</span> &lt;<span class="hljs-title">BaseViewControllerDelegate</span>&gt;</span><font></font>
<font></font>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) BaseMVCModel *model;<font></font>
<font></font>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">id</span>&lt;BaseViewControllerDelegate&gt; prevViewController;<font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)backWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)anOptionsDictionary;<font></font>
<font></font>
+ (<span class="hljs-keyword">void</span>)setupUIStyle;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
import <span class="hljs-string">"BaseViewController.h"</span><font></font>
<font></font>
<span class="hljs-comment">// Helpers</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RuntimeHelper.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BaseViewController</span> ()</span><font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BaseViewController</span></span><font></font>
<font></font>
+ (<span class="hljs-keyword">void</span>)setupUIStyle {<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark Life cycle</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)viewDidLoad {<font></font>
   [<span class="hljs-keyword">super</span> viewDidLoad];<font></font>
  <font></font>
   <span class="hljs-keyword">self</span>.model = [BaseMVCModel getModel:FindPropertyProtocol(<span class="hljs-string">@"model"</span>, [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>])];<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark Navigation</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)backWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)anOptionsDictionary {
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.prevViewController) {<font></font>
       [<span class="hljs-keyword">self</span>.prevViewController performSelector:<span class="hljs-keyword">@selector</span>(backFromNextViewController:withOptions:) withObject:<span class="hljs-keyword">self</span> withObject:anOptionsDictionary];<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark Seque</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)prepareForSegue:(<span class="hljs-built_in">UIStoryboardSegue</span> *)segue sender:(<span class="hljs-keyword">id</span>)sender {
   <span class="hljs-keyword">if</span> ([segue.destinationViewController isKindOfClass:[BaseViewController <span class="hljs-keyword">class</span>]] {<font></font>
       ((BaseViewController *)segue.destinationViewController).prevViewController = <span class="hljs-keyword">self</span>;<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark BaseViewControllerDelegate</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)backFromNextViewController:(BaseViewController *)aNextViewController withOptions:(<span class="hljs-built_in">NSDictionary</span> *)anOptionsDictionary {<font></font>
   [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:_cmd];<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">@end</span>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なViewModelの例</font></font></b><div class="spoiler_text"><pre><code class="objectivec hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BaseMVCModel</span> : <span class="hljs-title">NSObject</span></span><font></font>
<font></font>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">id</span> delegate;<font></font>
<font></font>
+ (<span class="hljs-keyword">id</span>)getModel:(<span class="hljs-built_in">NSString</span> *)someProtocol;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-meta">#import <span class="hljs-meta-string">"BaseMVCModel.h"</span></span><font></font>
<font></font>
<span class="hljs-comment">// IoC</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"IoCContainer.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BaseMVCModel</span></span><font></font>
<font></font>
+ (<span class="hljs-keyword">id</span>)getModel:(<span class="hljs-built_in">NSString</span> *)someProtocol {
   <span class="hljs-keyword">return</span> [[IoCContainer sharedIoCContainer] getModel:<span class="hljs-built_in">NSProtocolFromString</span>(someProtocol)];<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">@end</span></code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘルパークラス</font></font></b><div class="spoiler_text"><pre><code class="objectivec hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">IoCContainer</span> : <span class="hljs-title">NSObject</span></span><font></font>
<font></font>
+ (<span class="hljs-keyword">instancetype</span>)sharedIoCContainer;<font></font>
<font></font>
- (<span class="hljs-keyword">id</span>)getModel:(Protocol *)someProtocol;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-meta">#import <span class="hljs-meta-string">"IoCContainer.h"</span></span><font></font>
<font></font>
<span class="hljs-comment">// Helpers</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RuntimeHelper.h"</span></span><font></font>
<font></font>
<span class="hljs-comment">// Models</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"BaseMVCModel.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">IoCContainer</span> ()</span><font></font>
<font></font>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableSet</span> *models;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">IoCContainer</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark Singleton</span><font></font>
<font></font>
+ (<span class="hljs-keyword">instancetype</span>)sharedIoCContainer {
   <span class="hljs-keyword">static</span> IoCContainer *_sharedIoCContainer = <span class="hljs-literal">nil</span>;
   <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;
   <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^{<font></font>
       _sharedIoCContainer = [IoCContainer new];<font></font>
   });<font></font>
  <font></font>
   <span class="hljs-keyword">return</span> _sharedIoCContainer;<font></font>
}<font></font>
<font></font>
- (<span class="hljs-keyword">id</span>)getModel:(Protocol *)someProtocol {<font></font>
  <font></font>
   <span class="hljs-keyword">if</span> (!someProtocol) {
       <span class="hljs-keyword">return</span> [BaseMVCModel new];<font></font>
   }<font></font>
  <font></font>
   <span class="hljs-built_in">NSArray</span> *modelClasses = ClassGetSubclasses([BaseMVCModel <span class="hljs-keyword">class</span>]);<font></font>
  <font></font>
   __block Class currentClass = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
   [modelClasses enumerateObjectsUsingBlock:^(Class <span class="hljs-keyword">class</span>, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> *stop) {
       <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">class</span> conformsToProtocol:someProtocol]) {<font></font>
           currentClass = <span class="hljs-keyword">class</span>;<font></font>
       }<font></font>
   }];<font></font>
  <font></font>
   <span class="hljs-keyword">if</span> (currentClass == <span class="hljs-literal">nil</span>) {
       <span class="hljs-keyword">return</span> [BaseMVCModel new];<font></font>
   }<font></font>
  <font></font>
   __block BaseMVCModel *currentModel = <span class="hljs-literal">nil</span>;<font></font>
  <font></font>
   [<span class="hljs-keyword">self</span>.models enumerateObjectsUsingBlock:^(<span class="hljs-keyword">id</span> model, <span class="hljs-built_in">BOOL</span> *stop) {
       <span class="hljs-keyword">if</span> ([model isKindOfClass:currentClass]) {<font></font>
           currentModel = model;<font></font>
       }<font></font>
   }];<font></font>
  <font></font>
   <span class="hljs-keyword">if</span> (!currentModel) {<font></font>
       currentModel = [currentClass new];<font></font>
       [<span class="hljs-keyword">self</span>.models addObject:currentModel];<font></font>
   }<font></font>
  <font></font>
   <span class="hljs-keyword">return</span> currentModel;<font></font>
}<font></font>
<font></font>
- (<span class="hljs-built_in">NSMutableSet</span> *)models {
   <span class="hljs-keyword">if</span> (!_models) {<font></font>
       _models = [<span class="hljs-built_in">NSMutableSet</span> set];<font></font>
   }<font></font>
   <span class="hljs-keyword">return</span> _models;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-built_in">NSString</span> * FindPropertyProtocol(<span class="hljs-built_in">NSString</span> *propertyName, Class <span class="hljs-keyword">class</span>);<font></font>
<font></font>
<span class="hljs-built_in">NSArray</span> * ClassGetSubclasses(Class parentClass);<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RuntimeHelper.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark Functions</span><font></font>
<font></font>
<span class="hljs-built_in">NSString</span> * FindPropertyProtocol(<span class="hljs-built_in">NSString</span> *aPropertyName, Class <span class="hljs-keyword">class</span>) {
   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> propertyCount;<font></font>
   objc_property_t *properties = class_copyPropertyList(<span class="hljs-keyword">class</span>, &amp;propertyCount);<font></font>
  <font></font>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; propertyCount; i++) {<font></font>
      <font></font>
       objc_property_t property = properties[i];<font></font>
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *propertyName = property_getName(property);
       <span class="hljs-keyword">if</span> ([@(propertyName) isEqualToString:aPropertyName]) {<font></font>
          <font></font>
           <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *attrs = property_getAttributes(property);
           <span class="hljs-built_in">NSString</span>* propertyAttributes = @(attrs);<font></font>
          <font></font>
           <span class="hljs-built_in">NSScanner</span> *scanner = [<span class="hljs-built_in">NSScanner</span> scannerWithString: propertyAttributes];<font></font>
          <font></font>
           [scanner scanUpToString:<span class="hljs-string">@"&lt;"</span> intoString:<span class="hljs-literal">NULL</span>];<font></font>
           [scanner scanString:<span class="hljs-string">@"&lt;"</span> intoString:<span class="hljs-literal">NULL</span>];<font></font>
          <font></font>
           <span class="hljs-built_in">NSString</span>* protocolName = <span class="hljs-literal">nil</span>;<font></font>
          <font></font>
           [scanner scanUpToString:<span class="hljs-string">@"&gt;"</span> intoString: &amp;protocolName];<font></font>
          <font></font>
           <span class="hljs-keyword">return</span> protocolName;<font></font>
       }<font></font>
   }<font></font>
  <font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">NSArray</span> * ClassGetSubclasses(Class parentClass) {
   <span class="hljs-keyword">int</span> numClasses = objc_getClassList(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<font></font>
   Class *classes = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
   classes = (Class *)malloc(<span class="hljs-keyword">sizeof</span>(Class) * numClasses);<font></font>
   numClasses = objc_getClassList(classes, numClasses);<font></font>
  <font></font>
   <span class="hljs-built_in">NSMutableArray</span> *result = [<span class="hljs-built_in">NSMutableArray</span> array];
   <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; numClasses; i++) {<font></font>
       Class superClass = classes[i];<font></font>
       <span class="hljs-keyword">do</span> {<font></font>
           superClass = class_getSuperclass(superClass);<font></font>
       } <span class="hljs-keyword">while</span>(superClass &amp;&amp; superClass != parentClass);<font></font>
      <font></font>
       <span class="hljs-keyword">if</span> (superClass == <span class="hljs-literal">nil</span>) {
           <span class="hljs-keyword">continue</span>;<font></font>
       }<font></font>
       [result addObject:classes[i]];<font></font>
   }<font></font>
  <font></font>
   free(classes);<font></font>
  <font></font>
   <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログイン画面例</font></font></b><div class="spoiler_text"><pre><code class="objectivec hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">"BaseViewController.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">LoginProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><font></font>
<font></font>
<span class="hljs-keyword">@required</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)login:(<span class="hljs-built_in">NSString</span> *)aLoginString<font></font>
    password:(<span class="hljs-built_in">NSString</span> *)aPasswordString<font></font>
completionBlock:(DefaultCompletionBlock)aCompletionBlock;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">LoginVC</span> : <span class="hljs-title">BaseViewController</span></span><font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-meta">#import <span class="hljs-meta-string">"LoginVC.h"</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"UIViewController+Alert.h"</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"UIViewController+HUD.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">LoginVC</span> ()</span><font></font>
<font></font>
<span class="hljs-keyword">@property</span> <span class="hljs-keyword">id</span>&lt;LoginProtocol&gt; model;<font></font>
<font></font>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UITextField</span> *emailTF;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UITextField</span> *passTF;<font></font>
<font></font>
<span class="hljs-keyword">@end</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">LoginVC</span></span><font></font>
<font></font>
<span class="hljs-keyword">@synthesize</span> model = _model;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark IBActions</span><font></font>
<font></font>
- (<span class="hljs-keyword">IBAction</span>)loginAction:(<span class="hljs-keyword">id</span>)sender {<font></font>
   [<span class="hljs-keyword">self</span> login];<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark UITextFieldDelegate</span><font></font>
<font></font>
- (<span class="hljs-built_in">BOOL</span>)textFieldShouldReturn:(<span class="hljs-built_in">UITextField</span> *)textField {
   <span class="hljs-keyword">if</span> (textField == <span class="hljs-keyword">self</span>.emailTF) {<font></font>
       [<span class="hljs-keyword">self</span>.passTF becomeFirstResponder];<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
       [<span class="hljs-keyword">self</span> login];<font></font>
   }<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark -</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark Login</span><font></font>
<font></font>
- (<span class="hljs-keyword">void</span>)login {
   <span class="hljs-built_in">NSString</span> *email = <span class="hljs-keyword">self</span>.emailTF.text;
   <span class="hljs-built_in">NSString</span> *pass = <span class="hljs-keyword">self</span>.passTF.text;<font></font>
  <font></font>
   <span class="hljs-keyword">if</span> (email.length == <span class="hljs-number">0</span> || pass.length == <span class="hljs-number">0</span>) {<font></font>
       [<span class="hljs-keyword">self</span> showAlertOkWithMessage:<span class="hljs-string">@"Please, input info!"</span>];
       <span class="hljs-keyword">return</span>;<font></font>
   }<font></font>
  <font></font>
   __<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>)weakSelf = <span class="hljs-keyword">self</span>;<font></font>
   [<span class="hljs-keyword">self</span> showHUD];<font></font>
   [<span class="hljs-keyword">self</span>.model login:<span class="hljs-keyword">self</span>.emailTF.text password:<span class="hljs-keyword">self</span>.passTF.text completionBlock:^(<span class="hljs-built_in">BOOL</span> isDone, <span class="hljs-built_in">NSError</span> *anError) {<font></font>
       [weakSelf hideHUD];<font></font>
      <font></font>
       <span class="hljs-keyword">if</span> (isDone) {<font></font>
           [weakSelf backWithOptions:<span class="hljs-literal">nil</span>];<font></font>
       }<font></font>
   }];<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">@end</span></code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような単純な方法で、viewModelの遅延初期化を行い、プロトコルを介してビューとモデルを適切に接続しませんでした。これらすべてについて、その瞬間、私はまだMVPアーキテクチャについて何も知りませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントローラへの弱いリンクを追加したため、画面間のナビゲーションは「viewModel」の裁量に任されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装を今思い出すと、すべてが悪かったとは言えません。レイヤーを分離するというアイデアは成功し、モデルを作成してコントローラーに割り当てる瞬間が簡素化されました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私自身は、既製のアプローチとアーキテクチャについて詳しく学ぶことにしました。自分のアーキテクチャでアプリケーションを開発しているときに、多くのニュアンスに対処する必要があったからです。</font><font style="vertical-align: inherit;">たとえば、画面とモデルの再利用、継承、画面間の複雑な遷移。</font><font style="vertical-align: inherit;">現時点では、viewModelはビジネスロジックの一部であるように見えましたが、今でもプレゼンテーションレイヤーであることを理解しています。</font><font style="vertical-align: inherit;">この実験で素晴らしい経験をしました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVVM with Soul MVP</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに経験を積んでいたので、自転車を発明するのではなく、自分のために特定のアーキテクチャを選択してそれに従うことにしました。私はアーキテクチャの詳細を読み始め、当時人気のあった詳細な調査を行い、MVVMに落ち着きました。正直、その本質はすぐにはわかりませんでしたが、名前が気に入ったので選びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャの本質やViewModelとView（ViewController）の関係はすぐにはわかりませんでしたが、理解したとおりに始めました。目は恐れて、手は必死にコードをタイプしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の弁護では、その時点で、私が作成した作品を考えて分析するための時間は非常に厳しかったことを付け加えておきます。したがって、バインディングの代わりに、ViewModelで対応するビューに直接リンクを作成しました。そして、すでにViewModel自体で、プレゼンテーションのセットアップを行いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVPについては、他のアーキテクチャと同じ考えを持っていたので、ViewModelが最も現実的なプレゼンテーションであることが判明したのはMVVMだと固く信じていました。 </font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の「MVVM」アーキテクチャーの例で、はい、私はRootViewControllerのアイデアが気に入りました。RootViewControllerは、アプリケーションのナビゲーションの最高レベルを担当しています。</font><font style="vertical-align: inherit;">ルーターについては以下に書かれています。</font></font></b><div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootViewController</span>: <span class="hljs-title">UIViewController</span> </span>{<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">RootViewModel?</span><font></font>
    <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.viewDidLoad()
        <span class="hljs-keyword">let</span> router =  (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as</span>? <span class="hljs-type">AppDelegate</span>)!.router<font></font>
        viewModel = <span class="hljs-type">RootViewModel</span>(with: <span class="hljs-keyword">self</span>, router: router)<font></font>
        viewModel?.setup()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewModelProtocol</span>: <span class="hljs-title">class</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backAction</span><span class="hljs-params">()</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootViewModel</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">ViewModelProtocol</span> </span>{<font></font>
    <font></font>
    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">var</span> router : <span class="hljs-type">RootRouter</span>
    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">var</span> view: <span class="hljs-type">RootViewController</span><font></font>
    <font></font>
    <span class="hljs-keyword">init</span>(with view: <span class="hljs-type">RootViewController</span>, router: <span class="hljs-type">RootRouter</span>) {
        <span class="hljs-keyword">self</span>.view = view
        <span class="hljs-keyword">self</span>.router = router<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// MARK: - ViewModelProtocol</span><font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> <span class="hljs-type">AccountManager</span>.shared.isLoggedIn() {<font></font>
            router.route(to: <span class="hljs-type">RootRoutes</span>.launch.rawValue, from: view, parameters: <span class="hljs-literal">nil</span>)<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
            router.route(to: <span class="hljs-type">RootRoutes</span>.loginregistartion.rawValue, from: view, parameters: <span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backAction</span><span class="hljs-params">()</span></span> {<font></font>
        <font></font>
    }<font></font>
    <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
順序と単一のアプローチが尊重されたため、これはプロジェクトの品質に特に影響しませんでした。</font><font style="vertical-align: inherit;">しかし、その経験は非常に貴重でした。</font><font style="vertical-align: inherit;">自分で作った自転車の後、ようやく一般に認められた建築にしたがい始めました。</font><font style="vertical-align: inherit;">プレゼンターがプレゼンターと呼ばれていない限り、サードパーティの開発者を混乱させる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、設計における特定のアプローチの本質をさらに深く掘り下げるために、小規模なテストプロジェクトを行う価値があると判断しました。</font><font style="vertical-align: inherit;">いわば、まず実際に感じてから、戦闘に突入します。</font><font style="vertical-align: inherit;">これが私が自分で決めた結論です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ナビゲーションまたはルーターの2番目の試みとナビゲーションの湾曲</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVVMを積極的かつ単純に実装した同じプロジェクトで、画面間のナビゲーションに新しいアプローチを試すことにしました。</font><font style="vertical-align: inherit;">先に述べたように、私はまだ画面を分離するという考えと画面間の遷移のロジックを遵守しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVVMについて読んで、ルーターなどのパターンに興味を持っていました。</font><font style="vertical-align: inherit;">説明をもう一度確認した後、私は自分のプロジェクトにソリューションを実装し始めました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルーターの例</font></font></b><div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-keyword">import</span> UIKit<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Router</span>: <span class="hljs-title">class</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">route</span><span class="hljs-params">(to routeID: String, from view: UIViewController, parameters: <span class="hljs-keyword">Any</span>?)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">back</span><span class="hljs-params">(from view: UIViewController, parameters: <span class="hljs-keyword">Any</span>?)</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Router</span> </span>{<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">back</span><span class="hljs-params">(from view: UIViewController, parameters: <span class="hljs-keyword">Any</span>?)</span></span> {
        <span class="hljs-keyword">let</span> navigationController: <span class="hljs-type">UINavigationController</span> = checkNavigationController(<span class="hljs-keyword">for</span>: view)<font></font>
        navigationController.popViewController(animated: <span class="hljs-literal">false</span>)<font></font>
    }<font></font>
   <font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RootRoutes</span>: <span class="hljs-title">String</span> </span>{
    <span class="hljs-keyword">case</span> launch = <span class="hljs-string">"Launch"</span>
    <span class="hljs-keyword">case</span> loginregistartion = <span class="hljs-string">"LoginRegistartionRout"</span>
    <span class="hljs-keyword">case</span> mainmenu = <span class="hljs-string">"MainMenu"</span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootRouter</span>: <span class="hljs-title">Router</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> loginRegistartionRouter: <span class="hljs-type">LoginRegistartionRouter?</span>
    <span class="hljs-keyword">var</span> mainMenuRouter: <span class="hljs-type">MainMenuRouter?</span><font></font>
    <font></font>
    <span class="hljs-comment">// MARK: Router</span><font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">route</span><span class="hljs-params">(to routeID: String, from view: UIViewController, parameters: <span class="hljs-keyword">Any</span>?)</span></span> {<font></font>
        <font></font>
        <span class="hljs-keyword">var</span> rootView = view<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> view <span class="hljs-keyword">is</span> <span class="hljs-type">EPLaunchViewController</span> {<font></font>
            rootView = (view.navigationController?.viewControllers.first)!<font></font>
            view.navigationController?.popViewController(animated: <span class="hljs-literal">false</span>)<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> routeID == <span class="hljs-type">RootRoutes</span>.loginregistartion.rawValue {<font></font>
            loginRegistartionRouter = <span class="hljs-type">LoginRegistartionRouter</span>(with: <span class="hljs-keyword">self</span>)<font></font>
            loginRegistartionRouter?.route(to: <span class="hljs-type">LRRouteID</span>.phoneNumber.rawValue, from: rootView, parameters: <span class="hljs-literal">nil</span>)<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> routeID == <span class="hljs-type">RootRoutes</span>.mainmenu.rawValue {
            <span class="hljs-keyword">if</span> mainMenuRouter == <span class="hljs-literal">nil</span> {<font></font>
                mainMenuRouter = <span class="hljs-type">MainMenuRouter</span>(with: <span class="hljs-keyword">self</span>)<font></font>
            }<font></font>
            mainMenuRouter?.route(to: <span class="hljs-type">MMRouteID</span>.start.rawValue, from: rootView, parameters: <span class="hljs-literal">nil</span>)<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> routeID == <span class="hljs-type">RootRoutes</span>.launch.rawValue {
            <span class="hljs-keyword">let</span> storyboard = <span class="hljs-type">UIStoryboard</span>(name: <span class="hljs-string">"RootStoryboard"</span>, bundle: <span class="hljs-literal">nil</span>)
            <span class="hljs-keyword">let</span> launchView = storyboard.instantiateViewController(withIdentifier: <span class="hljs-string">"LaunchViewController"</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">LaunchViewController</span>
            <span class="hljs-keyword">let</span> navigationController: <span class="hljs-type">UINavigationController</span> = checkNavigationController(<span class="hljs-keyword">for</span>: view)<font></font>
            launchView.viewModel = <span class="hljs-type">LaunchViewModel</span>(with: launchView, router: <span class="hljs-keyword">self</span>)<font></font>
            navigationController.pushViewController(launchView, animated: <span class="hljs-literal">false</span>)<font></font>
        }<font></font>
    }    <font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなパターンを実装する経験の欠如は、それ自体を感じさせました。</font><font style="vertical-align: inherit;">すべてがすっきりとしていて、ルーターは新しいUIViewControllerクラスを作成し、そのViewModelを作成して、この画面に切り替えるためのロジックを実行しました。</font><font style="vertical-align: inherit;">しかし、それでも多くの欠点が感じられました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プッシュ通知後、特定の画面でアプリケーションを開く必要が生じた場合に問題が発生し始めました。</font><font style="vertical-align: inherit;">その結果、いくつかの場所では、適切な画面を選択するためのロジックが混乱し、そのようなアプローチをサポートすることがさらに困難になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はルーターを実装するという考えを放棄しませんでしたが、この方向に進み、ますます経験を積んでいきました。</font><font style="vertical-align: inherit;">最初の失敗した試みの後で何かをあきらめないでください。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常任マネージャー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の練習で別の興味深いマネージャークラス。しかし、これは比較的若いです。とにかく、開発プロセスは試行錯誤で構成されており、私たち全員、または私たちのほとんどが常に開発プロセスにいるため、常にエラーが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の本質はこれです。アプリケーションには、常にハングアップすると同時に多くの場所で利用できるサービスが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：Bluetoothのステータスを確認する。私のアプリケーションでは、いくつかのサービスで、Bluetoothがオンかオフかを理解し、ステータスの更新をサブスクライブする必要があります。いくつかのそのような場所があるので：いくつかの画面、いくつかの追加のビジネスロジックマネージャーなど、それらのそれぞれがCBPeripheralManager（またはCBCentralManager）デリゲートをサブスクライブする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は明白なようです。Bluetoothのステータスを監視し、それを必要とするすべての人にObserverパターンを通じて通知する別のクラスを作成します。しかし、このサービスが永続的に保存されるのは誰なのでしょうか。現時点で最初に頭に浮かぶのは、それをシングルトンにすることです！すべて問題ないようです！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ここで私のアプリケーションに複数のそのようなサービスが蓄積された瞬間が来ます。プロジェクトで100500のシングルトーンも作成したくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもう一つの光が私の明るい小さな頭の上に来ました。このようなすべてのサービスを格納し、アプリケーション全体でそれらへのアクセスを提供するシングルトンを1つ作成します。そして、「常任マネージャー」が誕生しました。その名前で、私は長い間賢く成長しなかったので、誰もがすでに推測できるように、PersistentManagerと呼びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、クラスの命名には非常に独自のアプローチがあります。私の開発計画では、クラスの名前に関する流行を追加する必要があると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装の重要な問題は、プロジェクトのどこからでも利用できるシングルトンです。そして、これは永続的なサービスの1つを使用するマネージャーがメソッド内でそれにアクセスするという事実につながりますが、これは明白ではありません。初めて、別のデモプロジェクトで大きな複雑な機能を作成し、ビジネスロジックの一部をメインプロジェクトから転送しているときに、これに遭遇しました。次に、サービスが不足しているというエラーメッセージが表示されるようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この後の結論は、隠された依存関係がないようにクラスを設計する必要があるということです。</font><font style="vertical-align: inherit;">必要なサービスは、クラスを初期化するときにパラメーターとして渡す必要がありますが、どこからでもアクセスできるシングルトンを使用する必要はありません。</font><font style="vertical-align: inherit;">そしてさらに美しく、プロトコルを使用する価値があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、シングルトンパターンの欠如の別の確認であることがわかりました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合計</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私は立ち止まらず、プログラミングの新しいアプローチを習得しながら前進します。</font><font style="vertical-align: inherit;">主なことは、移動、検索、実験です。</font><font style="vertical-align: inherit;">間違いは常にあり、これからの脱出はありません。</font><font style="vertical-align: inherit;">しかし、自分の過ちを認めたからといって、定性的に発展することができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xe/xr/wf/xexrwfhf0_i5cpoxtv3kjrqxsne.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、問題は多くのことを行うスーパークラス、またはクラス間の誤った依存関係です。</font><font style="vertical-align: inherit;">これは、ロジックをより適切に分解する必要があることを示唆しています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451974/index.html">AMDの歴史：急速な発展の50年</a></li>
<li><a href="../ja451976/index.html">「主権の」ルネットの費用はいくらですか？</a></li>
<li><a href="../ja451982/index.html">あなたがOOPを忘れるのが早いほど、あなたとあなたのプログラムにとって良いことです。</a></li>
<li><a href="../ja451986/index.html">ORMを使用したデータの取得は簡単です。か否か？</a></li>
<li><a href="../ja451990/index.html">乗り換えと乗り継ぎに関するFAQ：乗客ができることとできないことの違いは何ですか</a></li>
<li><a href="../ja451998/index.html">精密農業の問題とそれらとの付き合い方</a></li>
<li><a href="../ja452000/index.html">Leroy Merlinで、店舗の品揃えではないサプライヤーの倉庫から商品を購入する方法</a></li>
<li><a href="../ja452004/index.html">デバイス「Bereshit」の月への落下の場所を見つけた</a></li>
<li><a href="../ja452006/index.html">Epic Meta Universe：Fortnite Authorsが作成すべき理由</a></li>
<li><a href="../ja452008/index.html">エンジニアリングのアプローチとチェックリスト：混沌としたタスクに夢中にならない方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>