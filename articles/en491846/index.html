<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≥Ô∏è‚Äçüåà ‚è∫Ô∏è üè° Verifying Isomorphism of Two Graphs and Searching for Isomorphic Subgraphs: An Approach Based on NB-Paths Analysis üëà üë®üèª‚ÄçüöÄ üå°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone. 
 
 There is such a task - to check whether two graphs are isomorphic to each other. That is, to put it simply, to find out whether bo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Verifying Isomorphism of Two Graphs and Searching for Isomorphic Subgraphs: An Approach Based on NB-Paths Analysis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491846/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello everyone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is such a task - to check whether two graphs are isomorphic to each other. That is, to put it simply, to find out whether both of these graphs are ‚Äúthe same‚Äù graph, but with different vertex numbers and, if graphs are specified graphically, with different spatial locations. The solution to this problem is not so obvious as it might seem to someone at first glance: even for small graphs, a look at their graphical representation will not always give a definite answer. See, for example, a drawing on the same Wiki: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Graph_isomorphism#Example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, obviously?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there is a more difficult task: to search in a ‚Äúlarge‚Äù graph for all subgraphs isomorphic to some other ‚Äúsmaller‚Äù graph. </font><font style="vertical-align: inherit;">This is an even more "dark forest." </font><font style="vertical-align: inherit;">That is, of course, not entirely dark, but the task, you see, is not the easiest. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So what do we have?</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Why is all this necessary?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And although the problem of isomorphic (sub) graphs, as we have already mentioned, is complicated, it is quite necessary and useful. </font><font style="vertical-align: inherit;">What for? </font><font style="vertical-align: inherit;">And then, for example, to search the database for chemical compounds similar to a given molecule by its structural formula. </font><font style="vertical-align: inherit;">After all, it can be imagined as a graph, right? </font><font style="vertical-align: inherit;">Chemoinformatics does this - there is such a science. </font><font style="vertical-align: inherit;">But there are also tasks of comparison with the sample, various bioinformatic tasks, and many other interesting things.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. How to solve this problem?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The classical approach to solving this problem was laid down by J. Ullman in 1976 [3], later on he substantially improved his algorithm [4]. Also, this approach was further developed in the works of many other authors, for example, Cordella and co-authors [2] (VF2 algorithm), Bonnitsi and co-authors [1] (RI algorithm), etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In short, the essence of this approach is ‚Äúsmart enumerating ‚Äùthe possible correspondences of the vertices of the sample graph B and graph A in which it is being searched. This search makes it "smart" to enter various conditions and restrictions that allow you to cut off unsuitable options as early as possible. Also, for these purposes, various preliminary processing of the source data can be carried out.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will not be engaged in retelling these works here, but we will invite the reader to get acquainted with them independently. </font><font style="vertical-align: inherit;">However, ‚Äúa show is better than an order‚Äù, and it should be noted that there are good graphic examples and explanations of these algorithms on the Web. </font><font style="vertical-align: inherit;">See, for example, the following: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coderoad.ru/17480142/Is-or-simple-example-for-explanation-algorithm-Ulman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a very good and clear explanation with an example, </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">issue.life/questions/8176298</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - steps of the VF2 algorithm with an example . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the question arises - are there any other possible ways and approaches for solving this problem, albeit for some special cases? </font><font style="vertical-align: inherit;">And I would like to introduce you to one of the possible answers to this question.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Isomorphism of graphs and NB-paths</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's immediately agree: under NB-paths (and not from English, but simply because it is so shorter) we will call maximal non-branching paths, i.e. </font><font style="vertical-align: inherit;">maximally long unbranched paths of some graph. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, if we have </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two graphs that are isomorphic to each other</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then for any representation of the first graph as a sequence of maximally extended non-branching paths (i.e., these of our NB-paths) there always exists a corresponding representation of the second graph corresponding to it, and at the same time:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for directed graphs, the paths corresponding to each other will be aligned,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the degrees of the vertices corresponding to each other for undirected graphs (and for oriented graphs, the numbers of incoming and outgoing edges, respectively) will be equal to</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when "combining" such representations as a result, we will have a correspondence of the vertices of the first and second graphs.</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Graph A = {1-&gt; 2, 1-&gt; 6, 4-&gt; 5, 5-&gt; 1, 3-&gt; 3}. </font><font style="vertical-align: inherit;">Graph B = {3-&gt; 4, 3-&gt; 5, 1-&gt; 2, 2-&gt; 3, 6-&gt; 6} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PathsA ( </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximal non-branching paths of A</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): 1-&gt; 2, 1-&gt; 6, 4-&gt; 5-&gt; 1, 3-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PathsB ( </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximal non-branching paths of B</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): 3-&gt; 4, 3-&gt; 5, 1-&gt; 2-&gt; 3, 6-&gt; 6 </font><font style="vertical-align: inherit;">Vertex matching </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: 1 ( A): 3 (B), 2 (A): 4 (B), 6 (A): 5 (B), 4 (A): 1 (B), 5 (A): 2 (B), 3 ( A): 6 (B).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the task of checking the isomorphism of two graphs can be solved by finding such paths corresponding to each other and then checking the equality of the adjacency matrices constructed based on their conservation of the order of the vertices in the obtained path sequences (each vertex is added to the sequence once, first ‚Äúmention‚Äù). In our example, the following vertex orders will be used to construct adjacency matrices: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 1, 2, 6, 4, 5, 3 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 3, 4, 5, 1, 2, 6 </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjacency matrix for A for a given order of vertices: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/px/ec/cx/pxeccxjhfchxn7rhafe3trgqsyw.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjacency matrix for B for a given order of vertices: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nt/b8/_g/ntb8_gc0ap4hojnuzg4ddmrkky8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The matrices are equal; therefore, the graphs A and B are isomorphic.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moreover, this approach (1) is applicable for both oriented and non-oriented graphs, (2) it is applicable for graphs containing more than one connected component / strong connection, (3) it is applicable for graphs containing multiple (multiple) edges and loops, however (4) does not take into account vertices for which there are no edges incident to it.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Well, checked the isomorphism of graphs. </font><font style="vertical-align: inherit;">But what about the search for subgraphs?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here, frankly, everything is much more complicated. Here we will have the following restriction: based on the very essence of the method, you can find not any, but only </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúinscribed‚Äù subgraphs</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And </font><font style="vertical-align: inherit;">we mean a </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúsubgraph‚Äù of a</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> graph A such a subgraph that can be ‚Äúglued‚Äù to other parts of A only due to edges incident only to the boundary vertices of its (subgraph) non-branching paths of maximum length (in this case, A can contain other connected components). Do not worry, below will be an example, and everything will be clearer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, when solving this problem, in addition to searching for correspondence of NB paths of graphs A and B in length (as was the case with the isomorphism test above), it is also necessary to separately search for the following possible correspondences between them:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correspondence of NB paths - simple chains from graph B to NB paths - simple chains / simple cycles of graph A. Moreover, initially such paths in graph A can be longer - in this case, their segments are taken that are equal in length to the desired path from B. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correspondence of the NB-‚Äúend‚Äù paths of graph B to any NB-paths of graph A (in this case, the paths from graph A can also be longer ‚Äî in this case, their segments are taken that are equal in length to the desired path from graph B).</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at an example:</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/v7/gl/s8/v7gls8xyi1oef-3jmq-883v4ayw.png" alt="image"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
When searching for an ‚Äúinscribed‚Äù isomorphic subgraph of graph B in column A (see figure above), the following correspondences will be found:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inner path 2-&gt; 3-&gt; 4 of column B: inner path 2-&gt; 3-&gt; 4 of column A, </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end paths 1-&gt; 2 and 10-&gt; 2 of column B: end path 0-&gt; 2 of column A and a fragment of the end path 7-&gt; 1-&gt; 2 of column A, namely 1-&gt; 2,</font></font></li>
<li>  7-&gt;8  B:    9-&gt;10-&gt;11  A,   9-&gt;10  10-&gt;11,      12-&gt;13-&gt;14-&gt;12  A,   12-&gt;13, 13-&gt;14,  14-&gt;12.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, as ‚Äúinscribed‚Äù subgraphs of graph A that are isomorphic to graph B, the following 5 options can be found: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A1 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 9-&gt; 10} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A2 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 10-&gt; 11} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A3 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 12-&gt; 13} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A4 = {0-&gt; 2, 1-&gt; 2, 2 -&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 13-&gt; 14} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A5 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 14-&gt; 12} </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, if we add an additional edge 3-&gt; 8 to the graph A, we get the graph A '(below in the same figure). And in A 'there will no longer be any ‚Äúinscribed‚Äù subgraphs isomorphic to the graph B. Indeed: the edge 3-&gt; 8 ‚Äúsplits‚Äù the path 2-&gt; 3-&gt; 4 of the graph A into two and, therefore, candidate paths for the inner path 2 -&gt;3-&gt; 4 columns B will not be found.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Now the algorithm itself</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can move on to a more detailed consideration of the search algorithm for the </font><font style="vertical-align: inherit;">subgraphs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúinscribed‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in column A that are isomorphic to some column B. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the algorithm will consist of 4 stages:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preprocessing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matching</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thinning,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></li>
</ul><br>
<i><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage I. Preprocessing </font></font></h3></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this stage, we find all NB-paths for each of the graphs, as well as evaluate the factors that limit the choice space during enumeration. </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">we do the following:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We find all NB-paths in column A and put them into a dynamic array (in C ++ - into a vector) PathsA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We find all NB-paths in column B and put them in a dynamic array (vector) PathsB</font></font></li>
<li>        A  B.     II-IV    ,      1.           A-     B      B:    -     ,      B.</li>
<li>      A  B (          ).</li>
<li>          A   B:   DA  DB .</li>
<li>    ‚Äì   B00 ‚Äì   B   ,     ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have NB-paths on both graphs and limit parameters from p.p. </font><font style="vertical-align: inherit;">3-5.</font></font><br>
<br>
<i><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage II. </font><font style="vertical-align: inherit;">Mapping</font></font></h3></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this stage, we will select candidate NB paths (hereinafter simply referred to as ‚Äúcandidate paths‚Äù) from column A for each of the NB paths of column B. Marking each candidate path from PathsA for each ith path PathsB [i ] will be written to a two-dimensional dynamic array (in C ++ - to a vector of vectors) NPaths - respectively to the i-th vector (i-th line) - in the form of an ordered triple of numbers: the number of the corresponding path in PathsA - the number of the starting position in it - the length of the path . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, PathsB [2] = {1, 0, 3, 3, 1, 3} means that PathsB [2] paths are associated with 2 candidate paths from A: from PathsA [1] - the first 3 path elements starting from zero ( initial), and from PathsA [3] - also 3 elements starting from the first (next to the initial). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, we will search (select) candidate paths in 4 directions:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Search for candidate paths for all internal NB paths of graph B from PathsB, i.e. </font><font style="vertical-align: inherit;">those whose both boundary vertices are connected in the graph B with at least 2 other vertices (regardless of the direction of such a connection) and at the same time this path is not a simple cycle (oriented - for oriented graphs).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search for candidate paths for trailing NB paths from PathsB. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search for candidate paths for NB paths - simple loops from PathsB. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search for candidate paths for NB paths - simple paths from PathsB. </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When selecting candidate paths for each ith path from PathsB, they are compared (this is where some of the previously calculated limiter parameters come in handy): </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">its length and the length of the candidate path (should be equal for cases 1 and 3, and for cases 2 and 4 the candidate path from PathsA can also be longer),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the degrees of its boundary vertices and the corresponding vertices of the candidate path (for vertices from the candidate path, these values ‚Äã‚Äãmust be at least the path from PathsB).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If, according to the results of stage II, not a single candidate path from PathsA was found for any of the paths in PathsB, then it is considered that A does not contain ‚Äúinscribed‚Äù subgraphs isomorphic to column B.</font></font><br>
<br>
<i><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thinning</font></font></h4></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's try to ‚Äúsqueeze‚Äù graph A. We leave in it only those edges that went into the candidate paths we found. </font><font style="vertical-align: inherit;">If at the same time, graph A has lost at least one edge in comparison with its initial state, we return to stage I ‚ÄúPreprocessing‚Äù: the degrees of the vertices of graph A and, accordingly, the list of candidate paths can be reduced and, accordingly, the search space can be reduced.</font></font><br>
<br>
<i><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage III. </font><font style="vertical-align: inherit;">Thinning the list of candidate paths</font></font></h2></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The purpose of this step is to further eliminate as many candidates as possible inappropriate. </font><font style="vertical-align: inherit;">To do this, we carry out the following steps.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The exclusion of obviously inappropriate candidate paths based on the minimum distances between the vertices in column B. The candidate path for each PathsB [i] for which at least one PathsB [j] no candidate path was found for the shortest the distance between their boundary vertices in column A was less than or equal to the shortest distance between the corresponding boundary vertices of the paths PathsB [i] and PathsB [j] from graph B.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An exception for all cycles from PathsB to non-cyclic candidate paths associated with it and vice versa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The exception of candidate paths similar to Section 1, but not by the criterion of the shortest distance between boundary vertices, but by their (boundary vertices) to mutual equality or inequality. </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, if: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the starting element of PathsB [i] is not equal to the starting element of PathsB [j], and</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the final element of PathsB [i] is not equal to the final element of PathsB [j], and</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the starting element of PathsB [i] is equal to the ending element of PathsB [j], and</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the starting element of PathsB [j] is not equal to the ending element of PathsB [i], </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
the candidate path along the PathsB [i] path for which at least one PathsB [j] did not find any candidate paths satisfying the above condition regarding the equality / inequality of their (candidate paths) initial and final peaks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, roughly speaking, we discard those candidate paths that obviously will not be included in the desired subgraphs - based on the distance to all other candidate paths (these paths are terribly far from all others), based on their cyclicity / non-cyclicity, and also based on due equality / inequality of their boundary vertices with boundary vertices of other candidate paths.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If, according to the results of stage III, at least 1 candidate path was deleted from PathsA, then - again - column A is updated - only those edges that are included in the remaining candidate paths remain in it. </font><font style="vertical-align: inherit;">And, again, if at the same time, graph A ‚Äúlost weight‚Äù by at least one edge, we again return to stage I ‚ÄúPreprocessing‚Äù: the degrees of the vertices of graph A and, accordingly, the list of candidate paths can be reduced and, accordingly, can be reduced search space.</font></font><br>
<br>
<i><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage IV. </font><font style="vertical-align: inherit;">Conclusion</font></font></h2></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each possible combination of all remaining candidate paths defines a subgraph of column A. For each such subgraph, an adjacency matrix is ‚Äã‚Äãconstructed taking into account the order of the candidate paths in the same way as the adjacency matrix B00 was constructed for graph B, and then these adjacency matrices are compared. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If they are equal, then the multiplicities of the edges are compared (see Sec. 3 of Stage I Preprocessing). </font><font style="vertical-align: inherit;">If all these conditions are fulfilled, the found subgraph is considered isomorphic to graph B and is added to the set of results found. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During stage IV ‚ÄúConclusion‚Äù, various additional checks may be used to speed up the identification and rejection of an inappropriate subgraph.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. How everything is confused ... Consider an example of the algorithm</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I don‚Äôt know about you, but it would be incomprehensible to me without an example. Let's look at an example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fig. the graphs below are A = {1-&gt; 2, 2-&gt; 5, 5-&gt; 15, 16-&gt; 15, 5-&gt; 5, 5-&gt; 5, 5-&gt; 4, 5-&gt; 6, 7-&gt; 6 , 6-&gt; 8, 6-&gt; 6, 6-&gt; 9, 9-&gt; 10, 9-&gt; 11, 12-&gt; 0, 0-&gt; 12, 4-&gt; 13, 13-&gt; 14, 14-&gt; 4 } and B = {1-&gt; 1, 4-&gt; 5, 5-&gt; 1, 1-&gt; 3, 3-&gt; 3, 3-&gt; 2, 2-&gt; 7, 2-&gt; 8, 9-&gt; 10, 10-&gt; 9, 1-&gt; 6, 6-&gt; 11, 11-&gt; 12, 12-&gt; 6}. Our task is to find in graph A all the ‚Äúinscribed‚Äù subgraphs isomorphic to graph B. The result is also shown in the figure: the found vertices and edges of graph A are highlighted by a thick line, and the numbers of the corresponding vertices of graph B are indicated in brackets (if there are several options, they are indicated by fraction). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kj/w2/j8/kjw2j8ez-w-qiljh_rbzbki_xys.png" alt="image"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When solving the search problem in column A of ‚Äúinscribed‚Äù subgraphs isomorphic to column B,we have the following results of the algorithm. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: All actions and calculations were performed according to p.p. 1-5 of this step, the following are the resulting PathsA and PathsB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PathsA: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 2-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4-&gt; 13-&gt; 14 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 9 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9 -&gt; 10 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16-&gt; 15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0-&gt; 12-&gt; 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PathsB: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4- &gt; 5-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 11-&gt; 12-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 10-&gt; 9 </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stages II-III</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The comparison showed that for each path from PathsA there is at least one candidate path from PathsB, and PathsA was shortened by the results of preliminary thinning. At the stage of main thinning (III), further reduction of PathsA did not occur. As a result, PathsA and PathsB took the form: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PathsA: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 2-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4-&gt; 13-&gt; 14-&gt; 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 9 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 10 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0-&gt; 12-&gt; 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PathsB: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4-&gt; 5-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 -&gt; 11-&gt; 12-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 10-&gt;9 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The final comparison of NPaths is: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NPaths:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 0: 3 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 1: 4 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 2: 2 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 3: 7 0 2 8 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 4: 7 0 2 8 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 5: 6 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 6: 5 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 7: 0 0 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 8: 1 0 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 9: 9 0 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the time to recall that each ordered triplet of numbers in NPaths [i] defines the corresponding PathsB [i] candidate path from A in the format: the number of the corresponding path from PathsA - the starting position of the segment from this path - the length of the segment. Thus, it is easy to verify that the pathsB [0] = {1-&gt; 1} (i = 0: 3 0 2) corresponds to the only path from A, namely, the segment from PathsA [3], starting from the very beginning and having a length of 2. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage IV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As a result, a unique subgraph A1 was found in column A, isomorphic to B. A1 = {0-&gt; 12, 1-&gt; 2, 2-&gt; 5, 4-&gt; 13, 5-&gt; 4, 5-&gt; 5, 5- &gt; 6, 6-&gt; 6, 6-&gt; 9, 9-&gt; 10, 9-&gt; 11, 12-&gt; 0, 13-&gt; 14, 14-&gt; 4}.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. What next?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And then, in principle, that‚Äôs all. </font><font style="vertical-align: inherit;">Although not quite: the author must admit that the algorithm can still be finalized and finalized. </font><font style="vertical-align: inherit;">What is there to add?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When additional features of the vertices of columns A and B are introduced (for example, when the compounds are given by the graphs of chemical compounds, a numerical code corresponding to one and only one atom (isotope) can be associated with each vertex), the search process can be accelerated due to the greater accuracy of the comparisons according to Stage II: additional the condition for selecting candidate paths will be the correspondence of vertex labels.</font></font></li>
<li>               .     ,   ¬´¬ª, ¬´¬ª     - B. </li>
<li>   ,         ,   , <b>¬´¬ª  </b>    : <br>
 (1)   ¬´¬ª ,  , <br>
 (2)     . <br>
 ¬´¬ª   ¬´ - ¬ª,         ,        ,       . </li>
<li> ,  -         <i><b>  </b></i>,     <i><b>   </b></i>    . </li>
</ol><br>
<h2></h2><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General on the problems:</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1. Bonnici, V., Giugno, R., Pulvirenti, A. et al. A subgraph isomorphism algorithm and its application to biochemical data. BMC Bioinformatics 14, S13 (2013). </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doi.org/10.1186/1471-2105-14-S7-S13</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Cordella L, Foggia P, Sansone C, Vento M: A (Sub) Graph Isomorphism Algorithm for Matching Large Graphs. IEEE Transactions on Pattern Analysis and Machine Intelligence. 2004, 26 (10): 1367-1372. 10.1109 / TPAMI.2004.75. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Ullmann Julian R .: An algorithm for Subgraph Isomorphism. Journal of the Association for Computing Machinery. 1976, 23: 31-42. 10.1145 / 321921.321925. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Ullmann Julian R .: Bit-vector algorithms for binary constraint satisfaction and subgraph isomorphism. J Exp Algorithmics. 2011, 15 (1.6): 1.1-1.6. 1.64</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The author‚Äôs preprint written in a more official language about this is the most ‚ÄúNB-Paths-based algorithm‚Äù, which also contains information about an attempt to implement it in C ++:</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
5. Chernoukhov SA </font><font style="vertical-align: inherit;">2020. Preprints.RU. </font><font style="vertical-align: inherit;">Checking the isomorphism of two graphs and searching for isomorphic "inscribed" subgraphs: an approach based on the analysis of maximally extended non-branching paths approach to solve (sub) graph isomorphism problem. </font><font style="vertical-align: inherit;">DOI: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx.doi.org/10.24108/preprints-3111977 </font></font></a><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful Internet sources on the topic:</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
6. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coderoad.ru/17480142/Is-li- simple-example-for-explanation-algorithm-Ulman</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
7. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">issue.life/questions / 8176298</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491828/index.html">DataMatrix or how to label shoes correctly</a></li>
<li><a href="../en491832/index.html">8 pluses of Flutter in comparison with React Native</a></li>
<li><a href="../en491838/index.html">MIPT launches an open online course on sports programming</a></li>
<li><a href="../en491840/index.html">Visualization of the work of service workers</a></li>
<li><a href="../en491844/index.html">Auto test coverage visualization</a></li>
<li><a href="../en491848/index.html">Redux Toolkit is no longer needed?</a></li>
<li><a href="../en491852/index.html">Flask-DJ: Django (mvc) structure for a project on flask</a></li>
<li><a href="../en491854/index.html">Corporate phones for each of 31 thousand employees</a></li>
<li><a href="../en491856/index.html">LinkedIn for Students and Graduates: First Steps</a></li>
<li><a href="../en491858/index.html">Belated hangover March 8: another article on Habr√© about women in IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>