<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏻 👩🏿‍🔬 🤾🏾 SwiftUI di rak: Animasi, bagian 2 🍴 💷 👩🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari cerita animasi di SwiftUI. Pada artikel pertama , kami melihat contoh sederhana untuk dasar-dasar bagaimana animasi beker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI di rak: Animasi, bagian 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah bagian kedua dari cerita animasi di SwiftUI. Pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pertama </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> kami melihat contoh sederhana untuk dasar-dasar bagaimana animasi bekerja di SwiftUI. Pada bagian ini, kita akan melangkah lebih jauh, dan kita akan menganalisis secara rinci contoh yang diumumkan dengan animasi pelangi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah potongan Anda akan menemukan analisis waktu animasi, membuat mekanisme kurva waktu Anda sendiri untuk bekerja dalam animasi linier melingkar, contoh penerapan gradien yang berbeda dan beberapa trik menarik yang akan membantu Anda memahami bagaimana animasi bekerja di bawah tenda.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan saya mengingatkan Anda bahwa saya memata-matai ide untuk menerapkan animasi seperti ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di sana, penulis mengambil jalan perlawanan paling sedikit, dan menerapkan cara yang paling jelas untuk menerapkan konsep ini dengan menjiwai bentuk. Prinsipnya sederhana: setiap gelombang adalah garis yang digariskan oleh kurva Bezier, dan parameter "waktu" mempengaruhi posisi batas kanan gelombang ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah bagaimana animasi selesai terlihat: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kejelasan, saya akan menyebarkan gelombang sedikit secara vertikal. Ini mudah dilakukan, saya baru saja menambahkan pada akhir NotchWave memindahkan seluruh kontur ke ketinggian gelombang, sesuai dengan fase animasi saat ini:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik dan juga .drowingGroup () perlu untuk tidak lupa untuk memutuskan sambungan - itu tidak berarti gambar melampaui batas bingkai tetap. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatannya sederhana, itu menghasilkan hasil yang diinginkan ... tapi menurut saya terlalu membosankan. </font><font style="vertical-align: inherit;">Jalan saya ternyata jauh lebih lama, dan saya tidak akan mengatakan bahwa hasil akhirnya akan setidaknya sedikit lebih baik, tetapi akan menarik di sepanjang jalan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda masih belum begitu memahami prinsip-prinsip pekerjaan animasi di SwiftUI, saya sangat merekomendasikan membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan saya ingin mempelajari kode sumber di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja dengan gradien</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya, saya memilih pendekatan yang berbeda. Saya merasa jauh lebih berguna untuk berurusan dengan animasi perpindahan objek daripada dengan animasi bentuk (saya masih menyebut struktur bentuk formulir). Offset dapat bekerja dengan apa saja - berbagai bentuk, gambar, Tampilan lainnya. Sebagai tugas pendidikan, saya ingin menerapkan transisi warna yang halus dari satu gelombang ke yang lain. Dalam konsep aslinya, sesuatu seperti itu memang seperti itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara total, SwiftIUI menawarkan tiga kemungkinan penggunaan gradien - linier, bundar dan sudut. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode, ini terlihat seperti semacam konstruktor blok. Perhatikan bagaimana seluruh gelombang tersegmentasi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gradien linier ditandai dengan titik awal dan akhir untuk gradien. </font><font style="vertical-align: inherit;">Ini bukan poin CGPoint dengan koordinat absolut (x: y :), tetapi poin UnitPoint, mis. </font><font style="vertical-align: inherit;">koordinat relatif, di mana x: y: ditentukan dalam fraksi lebar dan tinggi area yang dipilih untuk Tampilan ini. </font><font style="vertical-align: inherit;">Ada juga titik yang telah ditentukan terkait dengan sudut (.topLeading, .bottomTrailing, dll.) Dan titik tengah sisi (.top, .trailing, dll.).</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segmen gradien linier adalah "karet". </font><font style="vertical-align: inherit;">Ini memiliki lebar tetap, tetapi tingginya tidak ditentukan. </font><font style="vertical-align: inherit;">Dengan demikian, itu akan mengisi seluruh jumlah yang disediakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cerita yang sedikit lebih rumit dengan gradien melingkar. </font><font style="vertical-align: inherit;">Kami menunjukkan titik - pusat lingkaran, jari-jari awal gradien dan jari-jari ujung gradien. </font><font style="vertical-align: inherit;">Jari-jari sudah dalam kondisi absolut, mis. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pusat lingkaran masih ditetapkan sebagai UnitPoint.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sepotong dengan lingkaran atas memiliki ketinggian tetap, tetapi membentang secara horizontal. Setelah semua, kami menetapkan jari-jari tetap tertentu dalam titik-titik, jadi tidak perlu merekatkan peregangan persegi panjang tambahan dari warna dasar, seperti halnya dengan gradien linier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang paling sulit untuk diterapkan adalah gradien sudut. Ini diberikan oleh sudut awal dan akhir, serta arah. Seperti yang dapat Anda lihat dari daftar kode, bekerja dengan sudut tidak nyaman. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda harus mengingat kursus trigonometri sekolah untuk menghitung sudut yang diperlukan, jika Anda harus memulai gradien sudut pada satu titik dan menyelesaikannya pada yang lain.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gradien sudut, yang merupakan ekor gelombang, juga karet, tetapi sudah lebarnya - ia menempati setengah ukuran yang tersisa. Sebenarnya, itulah sebabnya ada begitu banyak trigonometri. Saya tahu posisi titik-titik tertentu di perbatasan layar di mana warna tertentu seharusnya (karena saya menempelkan gradien melingkar dengan yang sudut). Selain itu, nilai sudut tidak hanya bergantung pada jari-jari gradien yang lebih rendah, tetapi juga pada lebar blok itu sendiri dengan gradien. Untuk pertama kalinya sejak sekolah, saya mengambil pensil dan mengingat aljabar :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketiga opsi menggunakan satu deskripsi warna dalam gradien. </font><font style="vertical-align: inherit;">Ini adalah daftar warna dalam array. </font><font style="vertical-align: inherit;">Distribusi mereka akan seragam pada segmen tertentu. </font><font style="vertical-align: inherit;">Anda dapat memperbaiki distribusi menggunakan array elemen Stop. </font><font style="vertical-align: inherit;">Bahkan, ini adalah penghitungan warna yang sama, hanya untuk masing-masing dari mereka koordinat pada satu segmen di mana ia akan ditempatkan juga ditunjukkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, saya membuat gelombang dengan bentuk yang kira-kira sama dengan konsep aslinya. </font><font style="vertical-align: inherit;">Namun, transisi dari satu warna ke warna lain sekarang tidak tajam, tetapi dihaluskan, yang berpotensi membuat animasi lebih halus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warna tidak seperti apa kelihatannya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu hal yang terkait dengan Warna. </font><font style="vertical-align: inherit;">Untuk membuat efek gelombang bergulir, saya memutuskan untuk membuat transisi antar warna tidak terlalu linier. </font><font style="vertical-align: inherit;">Jika Anda melihat lebih dekat, Anda akan melihat bahwa gradien lebih tajam di tepi itu sendiri, dan semakin jauh dari tepi, semakin halus mengalir ke warna utama. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mencapai ini dengan menghitung warna antara, dan membuat gradien dengan distribusi ini:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warna awal - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
warna menengah - 0,3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
warna akhir - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah muncul dengan menghitung rata-rata dua warna. SwiftUI berarti menggunakan objek Warna untuk gradien, dan saya tergoda. Bahkan, jika Anda ingin bekerja dengan warna seperti halnya dengan objek RGB, awalnya gunakan UIColor dalam model Anda, karena Warna tidak memiliki akses langsung ke warna. Anda tidak dapat dengan mudah mengubahnya kembali ke UIColor. Satu-satunya </font><font style="vertical-align: inherit;">solusi </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tidak) yang</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memadai yang saya temukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah untuk mendapatkan Mirror refleksi dengan analisis representasi string-nya. Seperti boilerplate, tetapi belum ada opsi lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ini bukan kesalahan, bukan kelalaian. </font><font style="vertical-align: inherit;">Intinya adalah bahwa SwiftUI dalam objek Warna tidak menduplikasi fungsi UIColor. </font><font style="vertical-align: inherit;">Jika Anda perlu bekerja dengan saluran rgb - gunakanlah. </font><font style="vertical-align: inherit;">Warna dalam SwiftUI adalah Tampilan yang memiliki beberapa warna dasar, nilai spesifiknya mungkin sedikit berbeda tergantung pada lokasi bintang-bintang di langit - warna rgb tertentu hanya ditentukan pada saat menggambar di layar. </font><font style="vertical-align: inherit;">Dokumentasi mengatakan</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI hanya menyelesaikannya ke nilai konkret sebelum menggunakannya di lingkungan tertentu.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi apa yang dimaksud dengan lingkungan: warna dinding di belakang pengguna, atau tema desain iOS tidak jelas. </font><font style="vertical-align: inherit;">Jika ini tidak cocok untuk Anda, gunakan UIColor secara asli.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi tanpa akhir</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animasi ditentukan oleh pengubah .animation () dan dimulai setelah tampilan diinisialisasi dalam pengubah </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan mengubah </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel. </font><font style="vertical-align: inherit;">Akibatnya, pengubah </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berlangganan untuk menerima data animatable dalam interval dari "adalah" menjadi "menjadi", konsisten dengan timer sistem. </font><font style="vertical-align: inherit;">Kami berbicara tentang ini di bagian terakhir.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan menjalankan animasi tanpa akhir dengan cara ini, Anda harus memahami bahwa setiap perubahan pengubah animasi berikutnya akan "memecahnya". </font><font style="vertical-align: inherit;">Misalnya, jika setelah memulai, karena alasan tertentu, Anda mengubah nilai sudut ke 0, Anda mendapatkan efek ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa? Jawabannya ada dalam mekanisme animasi transisi dari satu animasi ke animasi lainnya. Dalam contoh kami, saat tampilan pertama Tampilan di layar, kami memulai transisi animasi dari 0 hingga 90. Tampilan sebenarnya hanya menyimpan nilai akhir 90, dan nilai asli 0 tidak disimpan di mana pun. Mesin animasi mengetahui posisi waktu animasi saat ini, dan nilai AnimatableData saat ini. Pada titik waktu 0,5, itu akan menjadi 45. Apa yang terjadi jika pada saat ini pengguna mengubah nilai menjadi 0? Jawab: animasi untuk mengubah nilai dari 45 menjadi 0 akan dimulai. Semuanya masih diulang. Tetapi hanya secara visual, siklus tidak tertutup, tetapi rusak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, ada beberapa kasus di mana animasi juga "rusak" jika tampilan Anda menggunakan @ObservedObject, atau parameter lain yang menyebabkan tampilan dirender lagi. Untuk mengatasi masalah ini, modifier .animation memiliki parameter .animation (: value :). Melewati nilai di sana, kami menunjukkan kepada renderer bahwa animasi restart hanya diperlukan ketika nilai ini berubah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, mari kita cari tahu cara menghentikan animasi jika kita tidak lagi membutuhkannya. Untuk melakukan ini, Anda perlu menyediakan dua hal. Jelas, kita harus memberi tahu SwiftUI bahwa animasi tanpa akhir tidak lagi diperlukan, menggantikannya dengan final yang biasa. Tetapi ini tidak cukup. Modifier .animation () adalah instruksi yang digunakan timing, tetapi rotasi itu sendiri dijelaskan di dalam modifier .rotationEffect (), dan sudah berlangganan untuk menerima nilai baru dari sudut rotasi dengan timer. Untuk menghentikan rotasi, kita perlu mengubah nilainya juga.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti sebelumnya, mengubah nilai sudut menyebabkan dimulainya animasi baru (yang tampak rusak), perubahan ini juga akan dianimasikan, tetapi sekarang dengan timing animasi normal. Itu sebabnya, persegi kami berhenti berputar tidak secara instan, tetapi seolah-olah dengan perlambatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal yang sama dapat ditulis sedikit lebih ringkas, jika Anda menangguhkan semua fungsi pada satu </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel dari tipe on / off:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hingga saat ini, semuanya relatif mudah. Tetapi perhatikan bahwa semua peristiwa di sini dihasilkan di dalam Tampilan. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini disebut oleh sistem, dan </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tentu saja, oleh pengguna. Namun, bagaimana jika Anda ingin merangkum seluruh animasi di dalam satu Tampilan, hanya meneruskan / menonaktifkannya? SwiftUI tidak menyiratkan kemungkinan metode induk apa pun dari tampilan induk. Secara teoritis, Anda dapat menyimpan Tampilan anak sebagai struktur dan memanggil metode mutasinya, tetapi </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel Tampilan anak tidak dapat diubah dengan cara ini, saya mencobanya - itu tidak berfungsi. Satu-satunya cara untuk melakukan sesuatu seperti ini adalah menggunakan Combine's PassthroughSubject, seperti yang Anda lakukan di artikel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Padahal, semuanya jauh lebih sederhana. Jika jelas diletakkan di rak-rak di kepala, itu</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini adalah keadaan internal Tampilan, dan tidak mencoba memanipulasinya dari luar, solusi yang tepat akan sangat sederhana:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, kita tidak perlu </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berlangganan untuk memperbarui Tampilan di dalam tampilan anak - sudah diperbarui secara keseluruhan ketika parameter eksternal untuk itu berubah. </font><font style="vertical-align: inherit;">Terkadang itu tidak nyaman. </font><font style="vertical-align: inherit;">Terkadang kita tidak ingin menginisialisasi tampilan anak sekali lagi - misalnya, agar tidak merusak animasi, atau dalam init () beberapa perhitungan yang rumit dan intensif sumber daya (kueri, misalnya) terjadi. </font><font style="vertical-align: inherit;">Dalam kasus ini, lebih baik menggunakan entitas objek, yang perubahannya dapat dipantau menggunakan pengubah onReceive.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengubah kondisi selama pembaruan tampilan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu hal lagi yang layak dicakup. Kami beroperasi dengan hanya dua nilai 0 dan 90 derajat. Mematikan animasi mengatur ulang sudut ke 0. Tapi apakah mungkin untuk menjeda animasi tepat saat kita mengklik tombol dan melanjutkan lagi dari tempat yang sama ketika melanjutkan? Mari kita lihat kode yang memungkinkan ini:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ide utamanya adalah untuk melacak waktu di awal animasi. Setelah beberapa waktu, ketika tergantung pada kami untuk menghentikan animasi, kami akan dapat memeriksa berapa banyak siklus animasi lengkap yang telah berlalu, dan untuk menebak sudut rotasi persegi mana yang kami lihat saat ini. Setelah itu, kita dapat menetapkan </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai ini dengan tepat ke variabel sudut rotasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar pendekatan ini berhasil, kita perlu melacak awal dan akhir animasi. Init () tidak akan berfungsi. Kami tidak dapat mengakses </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter yang </font><font style="vertical-align: inherit;">ada </font><font style="vertical-align: inherit;">untuk mendapatkan waktu mulai animasi sebelumnya. Ini adalah token </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel. Di dalam init, Anda hanya dapat mengatur keadaan awal variabel ini, tetapi pada akhir inisialisasi, jika Lihat sudah ada sebelum init (), nilai </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel akan dikembalikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, di sini biarkan parameter externalStarted diimplementasikan (yang kami kontrol dari luar), dan parameter </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internal var internalStarted, yang dengannya kami langsung mengendalikan animasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hanya ada satu yang hilang - beberapa pengubah yang akan memeriksa kepatuhan dan pembaruan mereka jika perlu, seperti .onRecieve (), hanya untuk bekerja dengan setiap rendering. </font><font style="vertical-align: inherit;">Dan kemudian saya berpikir - setelah semua, tubuh dipanggil untuk setiap gambar, jadi mengapa tidak melakukan pemeriksaan ini langsung di dalamnya? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata SwiftUI sangat bersumpah, jika selama proses rendering, View mengubah nilai </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel, itu memberi</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengubah kondisi selama pembaruan tampilan, ini akan menyebabkan perilaku yang tidak terdefinisi.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memblokir perubahan seperti itu. Kemudian saya melakukan hack yang kotor, dan menggunakan DispatchQueue.main.async. Tapi mari kita lihat mengapa ini adalah hack kotor, dan mengapa ini tidak pernah dilakukan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini sebenarnya masalahnya. Jika kita menulis di dalam tubuh beberapa kebodohan yang jelas seperti i + = 1, di mana saya adalah semacam</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel, maka kita mendapatkan loop tak terbatas. Pada saat rendering, kami membuat tampilan di memori tidak relevan - karena kami mengubah data awal untuk rendering. Ini berarti bahwa segera setelah rendering selesai, tampilan kami akan diantrekan untuk rendering ulang, tetapi bahkan kemudian kami akan segera membuatnya tidak relevan lagi. Kami menciptakan siklus tanpa akhir dengan tangan kami sendiri. Panggilan asinkron dalam hal ini tidak mengubah apa pun. Ini hanya sedikit menggeser inisiasi putaran berikutnya ke saat "segera setelah rendering". Dengan demikian, panggilan asinkron tidak menyelesaikan masalah, tetapi hanya menyamarkannya, mencegah SwiftUI dari menusuk kami dengan hidungnya. Seperti halnya di dalam mobil bola lampu "mesin cek" terkoyak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di satu sisi, ada apa dengan itu? Dalam bahasa pemrograman apa pun, ada banyak cara untuk menembak diri sendiri jika Anda tidak mengerti apa yang Anda lakukan. Tetapi di sisi lain, pendekatan ini sama sekali bukan cara SwiftUI bekerja. Bekerja dengan tampilan dalam runtime buruk. Ya, Anda dapat mengalahkan tumit Anda di dada, memastikan bahwa Anda selalu menulis kode yang benar yang tidak akan pernah berakhir dalam lingkaran tanpa akhir ... Tapi itu seperti dengan pengambilan opsi yang tidak aman - itu hanya praktik yang buruk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya katakan, dalam kasus seperti itu, Anda harus menggunakan Combine, memberikan nilai baru menggunakan PassthroughSubject. Tapi Anda bisa bertahan dengan ObservableObject yang biasa dengan berlangganan acara willChange-nya.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin kontroversial di sini adalah penggunaan nilai-nilai objek itu sendiri dalam berlangganan pemberitahuan bahwa objek hanya akan diubah. </font><font style="vertical-align: inherit;">Sejauh ini, dalam contoh saya, saya memiliki objek yang sudah dimodifikasi. </font><font style="vertical-align: inherit;">Rupanya, pemberitahuan datang dengan sedikit keterlambatan. </font><font style="vertical-align: inherit;">Tetapi saya tidak dapat menjamin bahwa ini akan selalu menjadi masalah, oleh karena itu saya menyarankan untuk menggunakan notifikasi doChange buatan sendiri, atau PassthroughSubject, meneruskan nilai baru melaluinya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi Perubahan Animasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat di gif, animasi tidak berhenti secara instan. </font><font style="vertical-align: inherit;">Dia butuh waktu. </font><font style="vertical-align: inherit;">Ini karena ketika kita menetapkan nilai menengah ke sudut, kita juga menggunakan animasi tertentu - default.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mengarah pada perilaku yang tidak biasa. </font><font style="vertical-align: inherit;">Terlepas dari kesederhanaan relatif dari semua yang saya jelaskan, banyak nuansa interaksi tetap di bawah tenda sehingga gambar selalu terlihat mulus, bahkan jika programmer yang ceroboh tidak menunjukkan sesuatu. </font><font style="vertical-align: inherit;">Oleh karena itu, animasi default adalah musim semi. </font><font style="vertical-align: inherit;">Ini paling cocok untuk mensimulasikan hukum fisika. </font><font style="vertical-align: inherit;">Dan ini adalah animasi yang agak pendek, sekitar 0,2 detik. </font><font style="vertical-align: inherit;">Jika animasi transisi ke keadaan baru (sudut yang dihitung dan ditunjukkan oleh kami) tidak berhasil masuk ke standar 0,2 detik untuk beralih dari kecepatan animasi saat ini dengan perlambatan yang indah ke penghentian total, SwiftUI sendiri akan menambahkan lingkaran animasi tanpa akhir lainnya, yang dimainkan dalam versi akselerasi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghindari ini, cukup tidak menggunakan animasi default. </font><font style="vertical-align: inherit;">Untuk kotak bawah, saya mematikan animasi berhenti rotasi seperti ini:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atau, Anda dapat lebih akurat menghitung nilai yang diperlukan dari parameter pada saat berhenti, tetapi untuk ini Anda tidak hanya perlu mengasumsikan momen animasi saat ini, tetapi mengetahuinya dengan tepat. </font><font style="vertical-align: inherit;">Saya akan tunjukkan di bawah ini bagaimana melakukan ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pergerakan beberapa gelombang dalam satu animasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali ke animasi pelangi. </font><font style="vertical-align: inherit;">Jadi, kita memiliki ombak sendiri, mari ajari mereka untuk bergerak. </font><font style="vertical-align: inherit;">Hal pertama yang ingin saya lakukan adalah menjalankan animasi tanpa akhir. </font><font style="vertical-align: inherit;">Saya memutuskan untuk melakukannya dengan cara ini: Saya akan memiliki satu </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel yang bertanggung jawab atas posisi animasi saat ini. </font><font style="vertical-align: inherit;">Pada kondisi 0, gelombang pertama akan berada di bagian paling awal, dan yang terakhir di bagian paling akhir. </font><font style="vertical-align: inherit;">Ombaknya sendiri akan tumpang tindih. </font><font style="vertical-align: inherit;">Dengan demikian, panjang bagian yang terlihat dari setiap gelombang akan tergantung pada jumlah gelombang. </font><font style="vertical-align: inherit;">Saya menerapkan ini menggunakan ZStack, yang mencantumkan semua gelombang, dan pengubah .wavePosition saya sendiri, di dalamnya saya menghitung posisi masing-masing gelombang pada saat animasi, dan urutan tumpang tindihnya.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak kode</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama kali Tampilan ditampilkan di layar, kami mengubah status dari 0 menjadi 1, yang, dengan mempertimbangkan animasi linear yang dinyatakan, membuat gelombang berjalan tanpa henti di sekitar layar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika tepi gelombang mencapai tepi kanan, posisi berikutnya akan berada di bagian paling awal, di luar tepi layar. Ini akan terlihat seolah-olah hanya akan menghilang dari ujung gelombang, mengekspos substrat latar belakang, yang ingin kita hindari. Untuk tujuan ini, blok if {...} muncul di modifier, di fungsi body (), di mana salinan gelombang pertama yang hilang dari layar dibuat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa saya harus mentransfer karakteristik geometris setiap gelombang dalam bentuk parameter pengubah. </font><font style="vertical-align: inherit;">Masalahnya adalah saya perlu mendefinisikan ulang indeks-z dari setiap gelombang berdasarkan fase animasi saat ini. </font><font style="vertical-align: inherit;">Saya dapat mengekstraksi lebar wilayah yang terlihat dengan menggunakan pengubah GeometryReader {} di dalamnya, namun, saya dihadapkan dengan fakta bahwa ia memblokir perubahan dalam urutan gelombang. </font><font style="vertical-align: inherit;">Pengubah .zIndex () hanya berfungsi dalam konteks wadah ZStack {} pertama hingga hierarki Tampilan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader memutus koneksi ini, dan zIndex () berhenti berfungsi. </font><font style="vertical-align: inherit;">Jika sampai saat ini Anda berpikir bahwa GeometryReader adalah cara yang tidak berbahaya untuk mendapatkan data tentang ukuran tampilan saat ini, ini tidak sepenuhnya benar.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi aliran</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin penting lainnya adalah memahami animasi pengubah bawaan di dalam pengubah Anda sendiri. Pada beberapa titik, setiap gelombang mendekati tepi layar, mendapatkan offset horizontal maksimum, dan kemudian pergi ke posisi awal, mendapatkan offset minimum. Ini adalah perubahan yang sama dengan yang lain, dan ini dianimasikan, bahkan di dalam animasi. Lagi pula, animasi hanyalah transfer nilai yang sangat sering ke pengubah, dan itu juga akan dilakukan dengan animasi, tidak peduli betapa aneh kedengarannya. Ternyata di dalam animasi, melewati nilai baru di dalam pengubah ini, kami hanya mengubah titik akhir dari animasi gerakan saat ini. Ternyata setiap gelombang, mencapai tepi layar, berbalik dan mengapung kembali. Tapi itu tidak mencapai awal, tapi cepat atau lambat mengejar ketinggalan dengan posisi yang dibutuhkan,dan kemudian mulai bergerak dari kiri ke kanan lagi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mengatasi masalah ini dengan memasukkan pengubah .animation (nil). Jadi, saya mematikan animasi semua pengubah yang diterapkan di atas dalam teks. Ini adalah logika umum dari pekerjaan pengubah: perubahan apa yang ada pada inputnya, dan pada input kita memiliki hasil dari semua pengubah sebelumnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, seluruh hierarki animasi yang berbeda berfungsi di sini. Standarnya adalah yang akan digunakan untuk menampilkan perubahan pada semua pengubah, kecuali jika Anda menentukan sebaliknya untuk Tampilan Anda. Kami memiliki utas eksekusi (katakanlah ini adalah utama), di mana tubuh dipanggil. Kami berasumsi bahwa ia memiliki .animation parameter, yang diperiksa setiap kali pengubah menerima nilai baru. Jika pengubah mendukung animasi (sesuai dengan protokol AnimatableModifier), dan animasi diaktifkan untuk streaming (beberapa animasi tertentu digunakan, bukan .tidak ada atau nol), maka perubahan akan dianimasikan. Inilah yang kami lakukan, melampirkan beberapa kode untuk mengubah </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter di blok withAnimation {} - kami meresepkan animasi tertentu di utas saat ini, dan kemudian kami membuat semacam perubahan</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel. Dalam hal ini, denganAnimasi {}, ini adalah sejenis transaksi yang setara, dan semua perubahan yang dilakukan pada transaksi ini akan dianimasikan. Akibatnya, di dalam aliran yang sama, siklus menerjemahkan perubahan-perubahan ini ke semua mulai tampilan bergantung, pengubah tampilan ini menerima nilai baru, dan berlangganan untuk menerima nilai-nilai perantara AnimatableData. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, ada elemen pada animasi yang tidak dapat Anda pengaruhi. Misalnya, posisi slider dianimasikan dengan sendirinya, oleh mekanisme internal, dan tidak ada yang dapat dilakukan tentang hal itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, withAnimation () adalah cara untuk memulai animasi default untuk tindakan yang dilakukan. Tetapi untuk Tampilan tertentu, Anda dapat secara eksplisit menentukan animasi Anda sendiri menggunakan pengubah .animation (). Dalam kasus ini, pengubah dan formulir yang membentuk konten diteruskan ke .animation () (semua yang tercantum dalam kode sebelum menerapkan .animation ()) menerima waktu yang Anda gambarkan dan abaikan animasi aliran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pengubah WavePosition saya, saya menggunakan .animation (nil) untuk menyingkirkan animasi offset bawaan, sehingga memerintahkan saya untuk mengabaikan animasi streaming saat ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kisah yang sama dengan ujung topi. Biarkan saya mengingatkan Anda tentang kesimpulan dari artikel terakhir. Bahkan, kami memiliki struktur pengubah N WavePosition di memori kami, satu untuk setiap gelombang. Dan mereka semua mendapatkan nilai posisi baru dari pengatur waktu sistem, menghitung posisi setiap gelombang pada titik waktu tertentu. Ini berarti bahwa kami juga memiliki batas ujung N untuk setiap gelombang. Hanya saja salah satunya ditampilkan pada waktu tertentu, berkat blok if {}. Namun, blok yang sama memberi kita babi. Hilangnya dan tampilan View juga dilakukan dengan animasi aliran. Ini berarti bahwa .transition modifier digunakan untuk menghidupkan tampilan dan hilangnya tampilan setelah mengubah kondisi. Biasanya, .opacity digunakan secara default, namun karena alasan tertentu .slide digunakan untuk saya. Tidak ada yang cocok untuk saya, jadi saya hanya membatalkan animasi ini,menggunakan .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd. </font><font style="vertical-align: inherit;">Ketika saya sedang mempersiapkan artikel, Xcode 11.4 keluar, di mana, sepertinya, transisi dikerjakan ulang secara default. </font><font style="vertical-align: inherit;">Setidaknya sekarang saya berkomentar .transition (.identity) tanpa masalah dan tidak menerima masalah yang menyebabkan saya menambahkannya.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengaturan waktu animasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang kita akhirnya sampai pada pertanyaan yang paling menarik: bagaimana membuat ombak dipercepat? </font><font style="vertical-align: inherit;">Seperti biasa, saya akan datang dari jauh.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, Animasi adalah deskripsi kecepatan animasi yang diberikan. Kita dapat menentukan rute dari titik A ke titik B di dalam modifikator itu sendiri, tetapi SwiftUI memutuskan kapan dan apa nilai AnimatableData untuk dilewati. Dia melakukan ini dengan kurva waktu. Misalkan kita mengambil titik A sebagai titik asal, dan menandai titik B sebagai titik dengan koordinat (1; 1). Horizontal kita akan menandai waktu yang telah berlalu (pergerakan dari titik A ke titik B membutuhkan tepat 1 unit waktu). Vertikal - jarak yang ditempuh dalam pecahan unit. Saat menggunakan animasi linier, kami langsung. Jika kita ingin mendapatkan gerakan yang sedikit mirip dengan saat ini, maka pertama-tama kita perlu meluangkan sedikit waktu untuk akselerasi, dan pada akhirnya pada pengereman. Di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat bermain-main dengan berbagai opsi dengan menggambar kurva Anda sendiri dan membandingkan animasi gerakannya dengan yang standar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di SwiftUI, kurva Bezier digunakan untuk berbagai jenis animasi. </font><font style="vertical-align: inherit;">Bagaimanapun, itu harus dimulai pada (0; 0) dan berakhir pada (1; 1). </font><font style="vertical-align: inherit;">Lengkungan garis ditentukan oleh titik kontrol.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurva waktu bersarang di dalam animasi tak berujung linier</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, apa yang perlu kita lakukan untuk mencapai gerakan dipercepat dari setiap gelombang (memudahkan dalam) di dalam animasi loop linear? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pilihan paling jebol yang bisa saya buat adalah menerapkan kurva waktu saya sendiri, dan mengubah aliran waktu linear dengan itu menjadi semacam .easeIn. </font><font style="vertical-align: inherit;">Dengan contoh ini, Anda bisa sangat memahami bagaimana ini bekerja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idenya sederhana. Kita akan membuat kelas kita sendiri, berdasarkan jalur - kurva Bezier yang dengannya kita akan menentukan jarak dari titik A ke titik B, yang perlu ditunjukkan pada setiap titik waktu tertentu. Faktanya, inilah tepatnya cara kerja animasi di SwiftUI, dan dalam kerangka kerja lainnya dengan fungsi serupa. Menggunakan kurva waktu, detik nyata dan milidetik (yang paling sering mengalir, namun, secara linear) diubah menjadi pecahan jarak (lebih tepatnya, pecahan segmen animasi - vektor AnimatableData, yang mewakili perubahan yang dibuat). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah implementasi pertama saya:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata, saya agak bodoh. Menurut definisi, saya harus menemukan titik pada kurva yang sesuai dengan nilai X yang diberikan dan mengembalikannya ke Y. Saya tidak dapat menemukan beberapa metode bawaan standar untuk menyelesaikan masalah ini, atau pola yang populer, jadi saya memutuskan untuk mengadaptasi metode trim yang ada untuk keperluan ini ( ) Saya memutuskan bahwa saya bisa mempertimbangkan kembali pendekatan itu, dan mendapatkan titik yang diinginkan dengan mendapatkan bagian dari jalan yang sesuai dengan fraksi jarak yang ditempuh. Untuk nol, metode ini akan mengembalikan 0, untuk 1 akan mengembalikan 1, well, di tengah, mungkin, semuanya juga akan kira-kira benar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sadar bahwa pendekatan semacam itu tidak akan memberikan hasil yang sangat akurat, namun, keparahan masalah muncul kemudian ketika saya mencoba mereproduksi animasi yang sama persis dengan cara standar. Saya terkejut betapa berbedanya itu, dan memutuskan untuk memeriksa pada grafik seberapa jauh poin yang diperoleh dengan cara ini akan dari kurva asli. Hasilnya tidak menyenangkan saya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak hanya titik-titik yang jauh dari kurva yang diinginkan, sifat kurva itu juga terdistorsi. Ada ketegaran ekstra, yang saya tidak perlu sama sekali. Akibatnya, saya masih harus menemukan cara yang relatif akurat untuk menemukan titik pada kurva Bezier, hanya mengetahui satu koordinat:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harus menyimpan dalam banyak segmen memori, yang ujung-ujungnya terletak pada kurva yang diberikan. Pencarian untuk Y dengan X yang diberikan dengan pendekatan ini adalah pencarian untuk segmen yang sesuai, pembagiannya menjadi setengah, jika perlu, sampai salah satu batas segmen tersebut berada cukup dekat dengan titik yang diinginkan. Dalam hal ini, kami menemukan titik dengan koordinat X yang diperlukan terletak pada segmen ini dan mengembalikannya Y. Jika Anda tahu cara yang lebih sederhana untuk menemukan titik yang terletak pada kurva Bezier yang sewenang-wenang, menggunakan satu koordinat yang diberikan, tulis di komentar. Saya pikir ini bisa bermanfaat bagi banyak orang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasilnya, poinnya cukup dekat dengan grafik:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuat objek singlton untuk membuat kurva waktu untuk titik kontrol dan cache array segmen yang dicari Y. Dengan demikian, semua yang saya butuhkan untuk menemukan titik tertentu pada kurva adalah menemukan segmen di mana titik ini akan terletak, membaginya menjadi dua. sampai salah satu ujung segmen cukup dekat ke titik ini untuk jatuh ke dalam kesalahan yang diberikan, dan kemudian secara linear menginterpolasi nilai Y sepanjang X yang diberikan, menggantikan bagian kurva oleh segmen ini. Saya tidak mengklaim bahwa ini adalah cara terbaik, dan itu akan berhasil dalam semua kasus. Sekali lagi, tulis di komentar jika Anda tahu cara yang lebih baik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan bantuan alat seperti itu, transformasi animasi linear menjadi non-linear menjadi mudah. </font><font style="vertical-align: inherit;">Yang diperlukan hanyalah menggambarkan kurva dengan dua titik kontrol, dan menghitung ulang posisi pada segmen sesuai dengan kurva ini. </font><font style="vertical-align: inherit;">Jika animasi dari berbagai durasi diperlukan, kami masih menggunakan kurva satuan menggunakan koefisien yang sesuai untuk koordinat X.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah bagaimana animasi terlihat, bersama dengan kurva waktu kami: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kode lengkap, selamat datang di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tonton file TimingCurveView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah memahami contoh ini, Anda akan 100% memahami bagaimana pengaturan waktu animasi. </font><font style="vertical-align: inherit;">Ngomong-ngomong, Anda dapat menggunakan pengetahuan ini, karena SwiftUI memungkinkan Anda untuk membuat kurva waktu Anda sendiri untuk titik kontrol menggunakan fungsi timingCurve (), dan menggunakannya seperti animasi lainnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transisi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, kita memiliki animasi tanpa akhir yang dapat ditoleransi. Tetap hanya untuk mencari tahu bagaimana seharusnya menghidupkan dan mematikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan menjiwai penampilan adalah untuk membuat blok animasi hanya muncul di tempat yang sudah dihidupkan, tetapi tirai akan ditarik kembali dari itu, seperti tirai di teater. Jika kita menyinkronkan kecepatan tirai dengan kecepatan gelombang di dalam animasi, dan di tirai itu sendiri membuat gradien dari warna latar belakang ke warna gelombang kejadian saat ini, kita mendapatkan efek visual, seolah-olah tirai ini adalah gelombang bergulir pertama. Untuk menyinkronkan kecepatan gerakan, kita cukup menggunakan timingCurve yang sama seperti untuk menggerakkan pergerakan gelombang. Untungnya, kita sekarang tahu bagaimana melakukan ini.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve (x: y :) memungkinkan Anda untuk mengatur waktu animasi Anda sendiri berdasarkan titik kontrol kurva Bezier. </font><font style="vertical-align: inherit;">Pada output, kita mendapatkan objek Animasi penuh, seperti .linear yang familier (durasi: 1), yang dapat digunakan tanpa batasan. </font><font style="vertical-align: inherit;">Dan mengingat bahwa saya menggunakan titik kontrol yang sama persis untuk animasi gelombang, animasi akan sinkron.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan lebih mudah untuk mengatur kode ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          …     ,     ,     .  -  ,        —    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menonaktifkan animasi dapat dilakukan dengan cara yang sama, hanya gorden yang akan merayap ke blok animasi, secara bertahap menutupnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah pertama muncul pada saat saya perlu mendapatkan kondisi animasi saat ini untuk memilih warna tirai. </font><font style="vertical-align: inherit;">Untuk melakukan ini, saya membuat ObservableObject, yang saya lewati di dalam modifier, dan yang saya ubah di dalam setter AnimatableData. </font><font style="vertical-align: inherit;">Penting untuk dipahami di sini bahwa mengubah properti @Published 60 kali per detik sama sekali bukan yang Anda butuhkan. </font><font style="vertical-align: inherit;">Ini adalah cara mengubah </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel di dalam blok tubuh. </font><font style="vertical-align: inherit;">Kita tidak perlu memulai apa pun ketika keadaan animasi berubah. </font><font style="vertical-align: inherit;">Tetapi jika perlu, kita dapat mengetahui keadaan animasi kapan saja.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu sebabnya saya tidak mendaftar SharpRainbowView untuk melacak perubahan AnimationHendler: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengilustrasikan pengoperasian gorden ini, saya akan menghidupkan tampilan apa yang terjadi di luar Tampilan dengan mengomentari .clipped (). Selain itu, saya akan memindahkan tirai sedikit di atas animasi, untuk kejelasan. Sekarang lebih jelas, bukan? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tirai harus pendek sehingga jalur yang dilalui oleh setiap gelombang dan tirai bertepatan (jika tidak akan berubah menjadi tidak sinkron dalam animasi), tetapi pada saat yang sama, dia berhasil sepenuhnya menghilang dari layar. Pada saat yang sama, gorden disusun sebagai gradien tiga warna. Ini terlihat jelas di tirai penutup. Ini karena ekor panjang yang sangat saya sukai di awal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa gelombang pertama adalah gradien dari warna terakhir dan pertama dari array yang ditransmisikan. Tidak satu pun dari mereka yang cocok dengan warna latar belakang. Karena itu, ada kebutuhan untuk tirai pada umumnya. Untuk membuat gorden dua-nada, dari warna latar belakang ke warna dasar gelombang pertama, panjang gorden menghalangi saya. Ini sama sekali tidak tumpang tindih dengan ekor panjang gelombang pertama, dan perbatasan satu warna diperoleh, dan ekor lainnya. Karena itu, saya harus membuat tirai sebanyak tiga warna - pertama dari latar belakang ke warna gelombang terakhir, dan kemudian dari warna gelombang terakhir ke yang pertama. Kemudian ekor gelombang pertama cocok dengan perbatasan gorden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk alasan yang sama, mereka membuat tirai penutup juga berwarna. Kalau tidak, perbatasan tampak tidak alami. Tetapi sebagai hasilnya, "gelombang" pertama (dan sekarang kita tahu bahwa ini sebenarnya tirai yang dijelaskan dalam Transition.truncate) ternyata pendek. Dan meskipun itu bergerak sepenuhnya sinkron dengan gelombang pertama, yaitu dipercepat, dan tidak linier, lebarnya tidak berubah seiring waktu, meskipun lebar gelombang berikutnya secara visual meningkat. Ini bisa dikalahkan dengan mengubah lebar tirai secara dinamis, tetapi saya terus terang malas. Mari kita anggap ini sebagai pekerjaan rumah bagi mereka yang ingin membenamkan diri dalam mekanisme ini dan merokok kode (saya minta maaf kepada orang-orang seperti sebelumnya, ada banyak jejak percobaan saya yang dapat membingungkan Anda).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu masalah. </font><font style="vertical-align: inherit;">Jika Anda menekan tombol pada waktu yang gagal, tirai penutup hampir tidak akan menutupi gelombang berikutnya. </font><font style="vertical-align: inherit;">Itu tidak terlihat sangat bagus. </font><font style="vertical-align: inherit;">Anda dapat memecahkan masalah dengan memperkenalkan sedikit keterlambatan dalam menyembunyikan Tampilan dengan animasi. </font><font style="vertical-align: inherit;">Kami memiliki cara untuk mengetahui posisi animasi saat ini, kami hanya perlu sedikit menunda awal transisi, dan gelombang terakhir akan selalu ditampilkan sepenuhnya.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, Anda juga dapat membuat tirai dengan lebar variabel untuk menciptakan ilusi kecepatan berbeda dari perbatasan antara latar belakang dan tirai, dan tirai dan gelombang pertama, tetapi sekarang gelombang pertama terlihat sedikit tidak wajar, tetapi saya sudah terlalu malas untuk repot.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transisi suka melapisi babi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, animasi penampilan dan lenyapnya, seperti bagi saya, adalah alat yang sangat keren. Tetapi tampaknya konsep ini baru, dan tidak semua alat biasanya menanganinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, pengubah .rotation3DEffect () cukup berhasil membalikkan Tampilan dengan beberapa animasi yang rumit di dalamnya, tetapi tidak tahu cara membalikkan .transition. Sangat mengecewakan untuk menulis kode ringkas, melihat bagaimana gelombang Anda tersebar jauh dari tengah layar, dan kemudian melihat bahwa di sebelah kiri Lihat tirai berjalan dari kiri ke kanan. Saya harus menulis banyak boilerplate, sehingga pengubah transisi dapat bekerja di kedua arah.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, pengubah drowingGroup (), yang dengannya Anda dapat menghubungkan Logam untuk mentransfer ke rendering ZStack GPU dengan sejumlah besar Tampilan bersarang, terutama Tampilan dengan gradien, tidak tahu bagaimana melakukan transisi. </font><font style="vertical-align: inherit;">Dia tidak mengerti animasi penampilan dan penghilangan yang dijelaskan oleh Anda dan menggantinya dengan miliknya sendiri.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bagaimana kita menyembunyikan bilah status?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat sederhana. SwiftUI memiliki .statisBar (hidden :) modifier. Berikut ini hanya api untuk mengendalikan transisi untuk bilah status yang tidak disediakan oleh SwiftUI. Untuk melakukan ini, kita harus mengambil keuntungan dari kemampuan UIKit. File SceneDelegate menggunakan UIHostingController untuk mengubah Tampilan SwiftUI menjadi ViewController UIKit. Pada tahap ini yang paling nyaman untuk menggunakan beberapa fungsi UIKit global, seperti bekerja dengan status bar, atau menonaktifkan gerakan sistem yang terkait dengan tepi layar (preferScreenEdgesDeferringSystemGestures). Anda bisa mewarisi dari UIHostingController dengan mengganti nilai beberapa properti sistem, dan menggunakan turunan ini untuk meneruskan View Anda ke rootViewController. Sayangnya, hanya sejumlah transisi yang dapat menerima bilah status: .fade, .slide, dan .none. Standarnya memudar,dan ini cocok di sini, jadi mari kita biarkan apa adanya. Mari kita berharap bahwa fungsi ini masih akan diperluas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menyinkronkan persembunyian dan tampilan bilah status dengan gerakan gelombang, saya membuat tampilan terpisah, di dalamnya saya mengubah nilai parameter ini dengan jeda:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, Spacer sederhana () terbentuk di sini, yang sudah saya butuhkan, tetapi pengubah statusBar luka di atasnya. Secara umum, tentu saja, itu tidak masuk akal bagi Apple untuk menampilkan fungsi ini ke pengubah, sebagai ini tidak berlaku untuk Tampilan spesifik yang Anda modifikasi, tetapi tampaknya tidak tahu cara melakukannya dengan lebih baik. Jauh lebih menarik adalah hal lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu menggunakan hack kotor yang sama yang kita anggap sebelumnya: di dalam tubuh, saya melakukan beberapa tindakan dalam runtime, sambil mengubah nilai </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel. Logikanya secara keseluruhan adalah sama, ada parameter struktur yang dikirim dari luar, dan </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel yang diubah setelah beberapa waktu, menyebabkan bilah status menghilang atau muncul.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, saya memerlukan peretasan ini karena mengendalikan animasi status bar adalah fungsi UIKit yang masih kurang berkembang di SwiftUI. </font><font style="vertical-align: inherit;">Secara teori, saya akan mengacaukan animasi mulai tertunda ke .statusBar (hidden :) modifier, tapi ini tidak berhasil. </font><font style="vertical-align: inherit;">Animasi persembunyian dan tampilan bilah status diperbaiki, dan tidak dapat diubah oleh SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, tidak ada yang menghalangi saya untuk melakukan perubahan yang sama secara serempak dengan penundaan yang diinginkan, tidak di dalam Tampilan ini, tetapi di dalam induknya, bahkan ketika pengguna mengklik tombol - tetapi mari kita biarkan itu sebagai monumen untuk usaha saya untuk mencari tahu apa apa (dan satu lagi alasan untuk memberi tahu bahwa ini tidak boleh dilakukan).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan bagaimana ukuran dan posisi bilah status dimasukkan ke @Environment?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment (jangan disamakan dengan @EnvironmentObject) adalah pembungkus yang memberikan akses ke daftar variabel tetap yang mencerminkan lingkungan aplikasi kita. Misalnya, orientasi layar, atau tema warna OS. Wrapper yang sama memungkinkan tampilan Anda berlangganan untuk mengubah parameter ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar ini dapat diperluas. Saya pikir memiliki @Environment memiliki akses ke ukuran dan posisi bilah status akan tepat. Inilah cara saya melakukannya:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuat struktur dengan nilai default statis. </font><font style="vertical-align: inherit;">Kemudian, saya memperluas struktur sistem SystemValues ​​dengan menambahkan properti yang dihitung sendiri, pengambil dan penyetel yang merujuk pada tipe yang saya buat. </font><font style="vertical-align: inherit;">Jenis ini digunakan di sini, karena EnvironmentValues ​​mengimplementasikan subskrip di mana Anda meneruskan jenisnya dan mendapatkan nilai tersimpan yang sesuai dengan jenis ini. </font><font style="vertical-align: inherit;">Bukan nilai jenis ini, tetapi nilai yang disimpan dalam kamus bersyarat, di mana jenis itu sendiri adalah kuncinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai di @Environment diakses menggunakan keyPath \ .statusBarFrame. </font><font style="vertical-align: inherit;">Misalnya, untuk meneruskan nilai lingkungan ke semua tampilan hierarki:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di View sendiri untuk mengambil nilai dari toko:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, untuk bekerja dengan bilah status di objek UIWindowScene di iOS 13, atribut statusBarManager telah muncul. </font><font style="vertical-align: inherit;">Beberapa parameter dapat diambil darinya. </font><font style="vertical-align: inherit;">Tetapi sekarang Anda tidak bisa mengelolanya. </font><font style="vertical-align: inherit;">Seperti yang saya pahami, sebelumnya dimungkinkan untuk mengakses bilah status ViewController dan menambahkan subView ke dalamnya. </font><font style="vertical-align: inherit;">Rupanya, mereka menutup bangku. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, saya akan mentransfer fungsionalitas .statusBar (hidden :) modifier tepat di sini, di sini akan lebih tepat, bagi saya. </font><font style="vertical-align: inherit;">Saya pikir cepat atau lambat, pengembang akan sampai ke titik ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, saya pikir pada contoh yang menarik ini, kunjungan ke Animasi menggunakan alat SwiftUI dapat dianggap lengkap. Menggunakan contoh-contoh sederhana, saya berbicara tentang alat dasar animasi, memberi tahu bagaimana tepatnya mereka bekerja di bawah tenda, bagaimana mereka harus digunakan dan mengapa tepatnya. Dengan menggunakan contoh yang lebih kompleks, saya menunjukkan kesulitan khas yang mungkin Anda temui dan cara untuk mengatasinya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah kode saya, dibandingkan dengan contoh dari artikel di atas, menjadi lebih bersih, lebih jelas, lebih pendek, atau mungkin lebih mudah dipelihara? Mungkin tidak. Apakah ini menghabiskan lebih sedikit sumber daya? Sayangnya, tidak. Mungkin pendekatan saya lebih universal, tetapi ini tidak akurat. Namun, ada satu tugas yang pasti ia lakukan lebih baik. Ini menggambarkan lebih dalam operasi SwiftUI di bawah tenda. Dengannya, Anda dapat meletakkan animasi di rak di kepala Anda dan menerapkannya secara bebas di aplikasi Anda.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI aktif digergaji. </font><font style="vertical-align: inherit;">Bahkan sekarang, dua minggu setelah menulis kode untuk artikel pertama, sekarang, memeriksa kode pada versi Xcode saat ini, saya melihat bagaimana beberapa bug yang harus saya hindari sudah diperbaiki. </font><font style="vertical-align: inherit;">Karena itu, saya tinggal sedikit dengan artikel tersebut. </font><font style="vertical-align: inherit;">Sesuatu harus dipotong agar tidak relevan, dan yang lainnya - untuk mengecek. </font><font style="vertical-align: inherit;">Dan itu menyenangkan. </font><font style="vertical-align: inherit;">SwiftUI jelas merupakan masa depan pengembangan iOS asli, dan sangat informatif untuk mengetahui asal usulnya dan mengamati perkembangannya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata penutup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam proses mempersiapkan bahan untuk artikel ini, saya juga menaruh banyak hal di kepala saya di kepala saya. </font><font style="vertical-align: inherit;">Saya menemukan banyak nuansa yang saya tidak tahu ketika saya baru mulai menulisnya. </font><font style="vertical-align: inherit;">Oleh karena itu, saya mendesak semua orang yang sudah memiliki pengalaman dalam pengembangan SwiftUI - jangan malu, berbagi pengalaman dan pengetahuan Anda. </font><font style="vertical-align: inherit;">Ini sangat berguna baik untuk komunitas maupun untuk kelengkapan pengetahuan Anda sendiri. </font><font style="vertical-align: inherit;">Ini lebih keren daripada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode bebek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan ada juga kebutuhan untuk merumuskan jawabannya. </font><font style="vertical-align: inherit;">Hal utama adalah jangan malas mencari jawaban seperti itu sehingga tidak memalukan bagi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anak laki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">laki untuk menunjukkan</font></a><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id506644/index.html">Tantangan baru bagi para manajer dalam pekerjaan jarak jauh. Bagian 2</a></li>
<li><a href="../id506648/index.html">Laravel Digest (8-14 Juni, 2020)</a></li>
<li><a href="../id506662/index.html">Partisi adaptif kurva Bezier urutan 2 dan 3</a></li>
<li><a href="../id506664/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 419 (8-14 Juni, 2020)</a></li>
<li><a href="../id506666/index.html">Tekstur ORM, tetapi apakah itu layak?</a></li>
<li><a href="../id506676/index.html">Qatar: pusat dunia untuk transplantasi dan kota malam</a></li>
<li><a href="../id506680/index.html">.NET Core vs Node.js. Argumen dan Fakta</a></li>
<li><a href="../id506684/index.html">Bagaimana saya mentransfer dedic.ru ke halaman github dan merasa puas</a></li>
<li><a href="../id506686/index.html">Acara digital di Moskow dari 15 hingga 21 Juni</a></li>
<li><a href="../id506688/index.html">Acara digital di St. Petersburg dari 15 hingga 21 Juni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>