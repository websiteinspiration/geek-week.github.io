<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👌🏾 💕 扑。BlOC，提供程序，异步-架子架构 📗 🧛🏿 💕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="介绍
 当您尝试编写应用程序时，遇到的第一件事是如何组织应用程序的体系结构。当涉及Flutter时，头脑可以完全绕过Google提供的功能-香草，范围模型，BLoC，MVP，MVC，MVVM，MVI等。假设您决定采用最时尚的方式（谷歌在2018年建议的方式）使用BLOC。它是什么？如何使用它？还是R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>扑。BlOC，提供程序，异步-架子架构</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您尝试编写应用程序时，遇到的第一件事是如何组织应用程序的体系结构。</font><font style="vertical-align: inherit;">当涉及Flutter时，头脑可以完全绕过Google提供的功能-香草，范围模型，BLoC，MVP，MVC，MVVM，MVI等。</font><font style="vertical-align: inherit;">假设您决定采用最时尚的方式（谷歌在2018年建议的方式）使用BLOC。</font><font style="vertical-align: inherit;">它是什么？</font><font style="vertical-align: inherit;">如何使用它？</font><font style="vertical-align: inherit;">还是Redux或RxDart？</font><font style="vertical-align: inherit;">-虽然停下来是关于“其他”的事情……但是，接下来该怎么办？</font><font style="vertical-align: inherit;">要连接哪些库？</font><font style="vertical-align: inherit;">Bloc，Flutter_bloc，bloc_pattern等？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如此众多的体系结构选项和用于实现它们的工具实际上会长时间延迟选择阶段。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给谁的文章</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于那些刚刚开始学习Flutter并且不知道从哪里开始的人来说，本文将是非常有用的。</font><font style="vertical-align: inherit;">我将展示在Flutter上实现应用程序的选项之一。</font><font style="vertical-align: inherit;">这将使您“感觉” Flutter，然后自己决定编写应用程序的方式和使用方式。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式和工具。</font><font style="vertical-align: inherit;">简短而简单</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以，让我们开始吧。值得注意的第一件事是，存在一个应用程序架构（模式，模板，某些构造概念）-完全相同：BLoC，MVP，MVC，MVVM，MVI等。这些架构中的许多不仅在Flutter中使用，而且在其他编程语言中使用。问题-有什么选择？我认为，您需要选择自己熟悉的知识，但前提是这需要反应性并将业务逻辑与界面严格分开（是的，是的-“如果汽车是黑色，则可以是任何颜色”）。至于界面和业务逻辑的分离，我认为没有必要进行解释，但是对于反应性-试试，如果您还没有尝试过-最后，它真的非常方便且“漂亮”。如果您自己不能选择它，那么让我们允许不是Google最高才的家伙-BLOC为我们完成它。我们找出了架构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，工具-有现成的库-Bloc，Flutter_bloc，bloc_pattern-哪个更好？我不知道-每个人都很好。您可以选择和比较很长一段时间，但是就像在军队中一样，这里又是一次-最好现在就做出错误的决定，而不要做出任何决定。现在，我建议回到mod之后并使用Provider（在2019年，同样的人建议使用Provider）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些将使我们能够根据需要创建全局块和局部块。</font><font style="vertical-align: inherit;">关于BLoC的体系结构（即模式，而不是库）已经写了很多文章，我认为您不应该再详细介绍它。</font><font style="vertical-align: inherit;">我只注意到本文的一点，不是使用经典的BLoC，而是稍作修改-在BLoC中，动作（事件）不会通过接收器进行传输，但是会调用BLoC函数。</font><font style="vertical-align: inherit;">简而言之，此刻我看不到使用水槽的好处-既然它们不存在，那为什么使您的生活变得复杂？</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dart中的异步和并行计算</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因为我们在谈论反应性，所以在Dart中还需要对异步的概念进行一些澄清。很多时候，在接触Dart的最初阶段，异步函数（async）的含义无法正确理解。您应该始终记住，“默认情况下”该程序在一个线程中运行，并且异步仅允许您更改命令的顺序，而不是并行执行它们。也就是说，如果仅通过将其标记为异步来简单地运行带有大量计算的函数，那么该接口将被阻塞。异步不会启动新线程。异步和等待的工作方式在Internet上有很多信息，因此我也不再赘述。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果需要进行一些大的计算并且同时又不阻塞接口，则需要使用计算功能（对于特殊的硬核，可以使用隔离）。</font><font style="vertical-align: inherit;">这实际上将启动一个单独的执行线程，该线程还将具有其自己的单独的内存区域（这很令人难过）。</font><font style="vertical-align: inherit;">您只能通过包含简单数据类型及其列表的消息与此类流进行通信。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们开始练习</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题的提法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试编写最简单的应用程序-让它成为某种电话目录。</font><font style="vertical-align: inherit;">我们将使用Firebase作为存储-这将使我们能够创建“云”应用程序。</font><font style="vertical-align: inherit;">我将跳过如何将Firebase连接到项目的操作（有关该主题的文章已写了多篇，我看不到重复的意思。注意：该项目中使用Cloud Firestore。）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应该是这样的：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用说明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的应用程序将在外部包含：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firebase授权窗口（此窗口的逻辑将包含在MainBloc中）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息窗口-将显示有关授权程序的用户的信息（该窗口的逻辑也将包含在MainBloc中）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电话列表形式的目录窗口（此窗口的逻辑将包含在单独的PhonebookBloc中）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以切换屏幕的应用程序菜单。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部应用程序的构造如下：每个屏幕将包含一个带有屏幕小部件的文件，一个bloc文件（具有相应的bloc类），一个动作文件（包含描述影响bloc状态的事件的简单类），一个状态文件（包含反映bloc状态的简单类） ），包含存储库类（负责接收数据）和数据类（存储集团业务逻辑数据）的data_model文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序将具有以下功能：打开屏幕时，将使用初始状态值初始化相应的块，并在必要时在块构造器中调用一些初始动作。</font><font style="vertical-align: inherit;">屏幕根据状态构建/重建，返回状态。</font><font style="vertical-align: inherit;">用户在应用程序中执行一些具有相应动作的动作。</font><font style="vertical-align: inherit;">动作被传递给bloc类，在mapEventToState函数中对其进行处理，并且bloc将新状态返回到屏幕，并以此为基础重建屏幕。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">档案结构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们创建一个空的Flutter项目，并创建这种项目结构（我注意到在演示项目中，某些文件最终将保持为空）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权窗口。</font><font style="vertical-align: inherit;">主块</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您需要在Firebase中实施授权。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从创建事件类（通过bloc中的事件传输数据很方便）和Main bloc的状态开始：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件MainBloc \ action</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件MainBloc \国家</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状态类中的busy标志用于在界面中显示progress_hud，并在滚动列表时排除从数据库读取的不必要数据。</font><font style="vertical-align: inherit;">在该块中的所有操作开始之前，将设置了忙标志的旧类型的新状态发布到输出流-这样，接口将收到操作已开始的通知。</font><font style="vertical-align: inherit;">在操作结束时，将清除忙碌标志后将新状态发送到流。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBlocState类的继承人描述了主应用程序Bloc的状态。</font><font style="vertical-align: inherit;">MainBlocAction的继承人描述了其中发生的事件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc类包含4个主要元素-将事件“转换”为状态（Future mapEventToState）的功能，Bloc状态为_blocState，bloc状态存储库为repo，“输出”状态流（接口元素跟踪）为blocStream。基本上，这些都是提供bloc-a功能的元素。有时建议在一个块中使用2个输出流-这样的例子将更少。我不会在这里列出它-您可以通过下载项目来查看它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bloc存储库类包含用于处理Firebase的逻辑和一个对象（数据），该对象存储该bloc实现的业务逻辑所需的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainData类还存储状态，但将授权状态存储在Firebase中，而不存储Bloc状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们为主要集团编写了逻辑，现在我们可以开始实现授权/注册屏幕了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc在主文件中初始化：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主文件</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在该讨论一下StreamBuilder，Provider，StreamProvider，Consumer和Selector。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于供应商的退却</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供程序</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -仅将存储的值沿树传送。而且您只能在孩子建立后访问它，即您需要构建一个子窗口小部件。不负责更新小部件。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">监视流的小部件，当它从流中</font><b><font style="vertical-align: inherit;">接收到</font></b><font style="vertical-align: inherit;">新对象时将对其进行完全重建。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个监视流的小部件，并在接收到新对象时发出信号，指示应重建子小部件（那些通过build方法声明为单独类的小部件）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消费者</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择者</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是“语法糖”，即这实际上是一个“包装”，其中包含构建并将其隐藏在其下。在Selector-e中，您可以进行其他更新过滤。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，当您需要在每次事件中重建大部分屏幕时，可以将此选项与Provider和StreamBuilder一起使用。</font><font style="vertical-align: inherit;">当需要重建靠近叶子的窗口小部件树的部分时，建议将StreamProvider与Consumer和Selector结合使用，以排除树的不必要重建。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权书 </font><font style="vertical-align: inherit;">延续性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
进入应用程序时，用户必须进入授权/注册窗口，并且此时应用程序菜单尚不可用。第二点-部分刷新此屏幕没有多大意义，因此我们可以使用StreamBuilder来构建界面。该项目的第三点是使用导航器在屏幕之间导航。收到成功授权事件后，有必要调用转换到信息屏幕。但是，仅在内部构建StreamBuilder中，这将无法工作-将会出现错误。为了解决这个问题，你可以使用辅助包装类StreamBuilderWithListener（尤金Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，此屏幕的列表为auth_screen本身（我将在此处进行部分介绍）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，创建一个StreamBuilderWithListener来侦听来自bloc的流。</font><font style="vertical-align: inherit;">然后根据当前状态，调用LoggedWidget小部件（如果用户已经登录）或SignInAndSignUpWidget（如果用户尚未登录）。</font><font style="vertical-align: inherit;">如果bloc返回IsLogged状态，则在构建器中不会发生使用Navigator切换到新屏幕的情况（这会导致错误），但在侦听器中不会发生。</font><font style="vertical-align: inherit;">在基础小部件中，基于此处返回的数据构建接口。</font><font style="vertical-align: inherit;">在这里，实际上使用了Provider + StreamBuilder捆绑包，因为 </font><font style="vertical-align: inherit;">当块的状态更改时，实际上整个接口都会更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要将数据传输到块，请使用TextEditingController和action参数：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auth_screen文件</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电话簿屏幕窗口</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们谈谈PhoneBookScreen窗口。这是最有趣的窗口-这里的界面是基于来自bloc的2个流构建的，并且还有一个带有滚动和分页（pagination）的列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \屏幕文件</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要第一个StreamProvider在目录的不同屏幕之间切换-列表，联系人卡片，用于编辑的联系人卡片等。在caseWidget函数中选择了用于屏幕的窗口小部件（但在此示例中，仅实现了列表的视图-您可以尝试实现联系人卡的视图-这非常简单，并且从一个好的开始就可以）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此屏幕上，已经使用了一堆StreamProvider + Selector / Consumer，因为列表有一个滚动条，建议不要用它来重建整个屏幕（即，重建小部件来自相应的选择器/使用者，并且位于树的下部）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是列表本身的实现：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen文件</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们看到第二个StreamProvider，它监视负责滚动的第二个bloc流。分页是通过_scrollListener（控制器：_scrollController）进行标准组织的。尽管该窗口很有趣，但是由于给出了第一个窗口的详细说明，因此这里无话可说了。因此，就是今天。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文的目的不是展示完美的代码，也就是说，您可以在这里找到许多优化点-正确地“拆分”为文件，使用实例，mixin等。</font><font style="vertical-align: inherit;">另外，下一步是“乞求”什么-您可以制作联系卡。</font><font style="vertical-align: inherit;">主要任务是构造知识，为构建应用程序设置一定的向量，对在Flutter上设计应用程序的某些时刻进行说明，这些认识在相识的最初阶段并不十分明显。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在以下位置下载该项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（注册时，您可以使用密码至少为6个字符的任何邮件。重新授权时，密码必须与注册时使用的密码相同）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489496/index.html">寻找员工和寻找工作：我从内部到外部的观点</a></li>
<li><a href="../zh-CN489500/index.html">在故事点评估任务</a></li>
<li><a href="../zh-CN489502/index.html">Selenium + AutoIT。Windows测试自动化Windows</a></li>
<li><a href="../zh-CN489504/index.html">如何在UE4中开始创建地图</a></li>
<li><a href="../zh-CN489510/index.html">试图解决假期2号票之前的选择问题</a></li>
<li><a href="../zh-CN489514/index.html">免费下载和存储任意大小的文件到Google云端硬盘。错误或功能？</a></li>
<li><a href="../zh-CN489516/index.html">朋友反应本机和Fastlane</a></li>
<li><a href="../zh-CN489518/index.html">会员交流低成本交流出现在美国</a></li>
<li><a href="../zh-CN489526/index.html">零和游戏和Karush-Kun-Takker条件</a></li>
<li><a href="../zh-CN489528/index.html">您在开发过程中没有观看广告？紊乱</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>