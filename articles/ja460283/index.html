<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚕️ 👶🏻 ⏸️ 新しい日曜大工のプログラミング言語 ☝🏿 🎴 🍣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！ポイントにまっすぐ行きます。現在、「ドラゴンブック」を読んでいて、ロロと呼ばれる私のプログラミング言語用のコンパイラを開発しています（ソビエト-日本の漫画のペンギンを記念して）。何も痛くないなら1年以内に終了する予定です。並行して、翻訳、中間コードの作成、最適化などの経験からの興...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>新しい日曜大工のプログラミング言語</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460283/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">ポイントにまっすぐ行きます。</font><font style="vertical-align: inherit;">現在、「ドラゴンブック」を読んでいて、ロロと呼ばれる私のプログラミング言語用のコンパイラを開発しています（ソビエト-日本の漫画のペンギンを記念して）。</font><font style="vertical-align: inherit;">何も痛くないなら1年以内に終了する予定です。</font><font style="vertical-align: inherit;">並行して、翻訳、中間コードの作成、最適化などの経験からの興味深い抜粋を投稿します。今日は、この言語を紹介します。</font><font style="vertical-align: inherit;">席を持って行きましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語はコンパイルされ、命令指向であり、オブジェクト指向ではありません。セマンティクスはCから無作法に作成され、多くの便利な機能が追加されています。</font><font style="vertical-align: inherit;">それらから始めましょう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味の変更</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全なポインタ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、Rustのスマートポインターについて考えたことがあるかもしれませんが、そうではありません。私の言語では、メモリへのアクセスの安全性は2つのイディオムによって提供されます。まず、ポインターに対する逆参照操作がありません。代わりに、宣言されたポインターにアクセスすると、オブジェクト自体が参照されます。つまり、次のように記述できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">int # pointer ~~ new int(5)<font></font>
int variable ~ pointer + 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数variableに数値12が含まれるようになります。見慣れない構文が表示され、おそらく少し困惑しているかもしれませんが、記事の中ですべてを説明します。 2番目のイディオム：ポインターに対する操作の欠如。繰り返しますが、割り当て、増分、減分を含む、ポインタにアクセスするときのすべての操作は、オブジェクトに対して実行されます。ポインターに直接関連する唯一の操作は、アドレス、または私が呼ぶように、IDによる割り当てです。上記のコード例では、1行目は正確に識別しています。どのポインターも、すでに割り当てられているメモリ領域のみのアドレスに設定できます。これは、返される新しい操作です。ヒープ上でも、スタック上でも割り当てられている別の変数のアドレスへのポインターを置くこともできます。次に例を示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">int variable ~ 5<font></font>
int # pointer ~~ variable</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで「〜」は通常の代入演算です。</font><font style="vertical-align: inherit;">特別なnullポインターでポインターを識別することもできます。</font><font style="vertical-align: inherit;">NULLアドレスを参照するポインタとして機能します。</font><font style="vertical-align: inherit;">比較の操作とIDの比較（同一のアドレス）をnullで識別すると、trueになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">int # pointer ~~ null<font></font>
if (pointer = null) nop  ;; true<font></font>
if (pointer == nul) nop  ;; true</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、「=」は値の比較、「==」はアドレスによる比較、「nop」は空の操作、「;;」の後です。</font><font style="vertical-align: inherit;">-コメント。</font><font style="vertical-align: inherit;">そして、はい、nullは、型の互換性をチェックせずに可能な唯一のポインター操作です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ポインタは割り当てられたメモリまたはnull領域にのみ割り当てることができ、どこにも移動できません。</font><font style="vertical-align: inherit;">ただし、これらの対策では、セグメンテーションフォールトエラーから完全に保護することはできません。</font><font style="vertical-align: inherit;">それを取得するには、次の手順に従ってください。</font></font><br>
<br>
<pre><code class="plaintext hljs">int # pointer1 ~~ new int(5)<font></font>
int # pointer2 ~~ pointer1<font></font>
delete pointer1<font></font>
int variable ~ pointer2  ;; segmentation fault!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてがはっきりしていると思います。</font><font style="vertical-align: inherit;">しかし、そのような過ちを犯すことは、故意に、そしてそれから一生懸命働いたことによってのみ行うことができます。</font><font style="vertical-align: inherit;">結局のところ、削除操作はガベージコレクターと同じことを行いますが、安全性は低くなります。</font><font style="vertical-align: inherit;">彼と言えば...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクター</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ガベージコレクター-彼はLoloのコレクターでもあります。</font><font style="vertical-align: inherit;">おそらくそれを説明する必要はないでしょう。</font><font style="vertical-align: inherit;">コンパイル中に特別なオプションで無効にできるとしか言えません。</font><font style="vertical-align: inherit;">コレクターを使用してプログラムをテストしましたが、すべてが正常に機能します。オプションを入力して、手動のメモリ管理を使用してプログラムを最適化することができます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込み配列</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語のセマンティクスはCから作成されていると述べましたが、その違いは非常に重要です。ここで、配列はポインターです。配列には独自の構文と安全なアドレス指定があります。いいえ、範囲チェックはありません。原則として、ランタイムエラーを取得することは困難です。これは、各配列がJavaのように可変サイズで長さを格納し、インデックスからの各インデックス付けで...このサイズで除算する余りがあるためです。負のインデックスを見るまでの、一見愚かな決定。 -1を配列の長さで割った余りが見つかった場合、size-1に等しい数、つまり最も有限な要素を取得します。このような操作により、配列の最初からだけでなく、配列の最後からもインデックスにアクセスできます。もう1つのトリックは、プリミティブ型をバイト[]配列にキャストすることです。しかし、どのようにしてランタイムエラーが発生するのでしょうか？この質問は簡単ななぞとしておきます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のC標準にリンクが含まれているかどうかはわかりませんが、Loloでは間違いなく含まれます。</font><font style="vertical-align: inherit;">おそらく、以前のバージョンのCに参照がないことは、ポインターへのポインターの主な理由の1つです。</font><font style="vertical-align: inherit;">それらはアドレスに引数を渡し、コピーせずに関数から値を返すために必要です。</font><font style="vertical-align: inherit;">ポインタと配列も参照で渡すことができます（値で渡す場合、配列は完全にコピーされ、~~操作で新しい場所に設定されたポインタは保存されません）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッド</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがより美しく、より美しくなります。</font><font style="vertical-align: inherit;">私はすでに私の言語に恋をしています。</font><font style="vertical-align: inherit;">彼の次の趣味はマルチスレッドです。</font><font style="vertical-align: inherit;">正直なところ、どのツールが提供されるかは完全には決めていません。</font><font style="vertical-align: inherit;">おそらく、ala-Javaのすべてのプロパティを備えたsynchronizedキーワード、そしておそらく、非インライン関数の前の並行キーワード、つまり「これらの関数を並列スレッドで実行する」ことを意味します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インライン文字列</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは文字列であり、C ++のように文字列リテラルではありません。</font><font style="vertical-align: inherit;">各行には独自の長さがあり、残りを見つけるとインデックスが作成されます。</font><font style="vertical-align: inherit;">一般に、Loloの文字列は文字配列と非常に似ていますが、配列には「+」による連結、「*」によるアニメーション、および「&lt;」と「&gt;」による比較がない点が異なります。</font><font style="vertical-align: inherit;">そして、私たちは線について話しているので、キャラクターに言及しなければなりません。</font><font style="vertical-align: inherit;">C ++のように、Loloのシンボルは数値ではありません。</font><font style="vertical-align: inherit;">また、1バイトではなく、DKOTI文字の場合は4バイト、UTF文字の場合は6バイトが含まれます。</font><font style="vertical-align: inherit;">次回はDKOTIについてお話しますが、今のところは、Loloが2つのエンコーディングで文字と文字列をサポートしていることを知っておいてください。</font><font style="vertical-align: inherit;">そしてはい、長さプロパティは定数から取得することもできます：</font></font><br>
<br>
<pre><code class="plaintext hljs">int len ~ "Hello, world!".length  ;; len = 13</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つの値を持つブール型</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理データ型を持つプログラミング言語の大部分は、バイナリロジックを使用します。</font><font style="vertical-align: inherit;">しかし、Loloでは3値、つまりファジー3値になります。</font><font style="vertical-align: inherit;">3つの値：true-true、false-false、none-なし。</font><font style="vertical-align: inherit;">これまでのところ、何も返さない操作の言語では見つかりませんでしたが、3つの値を持つフラグが非常に役立つ場合の練習からの多くの例を覚えています。</font><font style="vertical-align: inherit;">列挙型または整数型を使用する必要がありました。</font><font style="vertical-align: inherit;">もう必要はありません。</font><font style="vertical-align: inherit;">それは私が選択できないこのタイプの名前です。</font><font style="vertical-align: inherit;">最も一般的なのは「論理的」ですが、長すぎます。</font><font style="vertical-align: inherit;">他のオプションは、Jan Lukasevichを称える「luk」、N。P. Brusnetsovを称える「brus」、および「trit」ですが、厳密に言えば、このタイプはTritではありません。</font><font style="vertical-align: inherit;">一般的に、調査は記事の最後にあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造とリストを初期化するためのリスト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造変数を宣言した後、〜記号を入れて角かっこを開くと、そのフィールドの値を順番に、または辞書の形式で設定できます。</font><font style="vertical-align: inherit;">配列を使用してこのような手順を実行すると、辞書なしでのみ、そのセルの値を設定できます。</font><font style="vertical-align: inherit;">特別なことは何もありません。コードを見てください。</font></font><br>
<br>
<pre><code class="plaintext hljs">struct {<font></font>
    int i;<font></font>
    real r;<font></font>
    str s;<font></font>
} variable ~ [ i: 5, r: 3.14, s: "Hello!" ]<font></font>
int[5] arr ~ [ 1, 2, 3, 4, 5 ]</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数から複数の値を返す</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goと同じように！</font><font style="vertical-align: inherit;">複数の変数名をコンマで区切って記述し、関数から返されたすべての値を一度に割り当てることができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">int, real function() {<font></font>
    return 5, 3.14<font></font>
}<font></font>
byte § {<font></font>
    int i; real r<font></font>
    i, r ~ function<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダーの代わりにモジュール</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてが明確です。</font><font style="vertical-align: inherit;">C-shyヘッダーの代わりに-Javaのモジュール。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（自動項目：配列）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再びネイティブJava。</font><font style="vertical-align: inherit;">長さの配列があるので、それぞれに式を使用しないのは罪です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択演算子はintだけのものではありません</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はあなたのことは知りませんが、CとC ++では、整数以外の変数に大文字と小文字の切り替え操作を使用できないことにひどく怒っています。</font><font style="vertical-align: inherit;">そして、構文も激怒します。</font><font style="vertical-align: inherit;">ここパスカルでは別の問題です。</font><font style="vertical-align: inherit;">そして今ロロで：</font></font><br>
<br>
<pre><code class="plaintext hljs">case variable {<font></font>
    "hello", "HELLO": nop<font></font>
    "world": {<font></font>
        nop; nop<font></font>
    }<font></font>
    "WORLD": nop<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電力供給と除算の演算子</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはPythonからのものです。</font></font><br>
<br>
<pre><code class="plaintext hljs">real r ~ 3.14 ** 2<font></font>
int i ~ r // 3</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数パラメーターのタプル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインターを使用したすべての操作は、識別を除いて、Loloでは禁止されていることを覚えていますか？</font><font style="vertical-align: inherit;">次に、可変長パラメーターリストから関数パラメーターにアクセスする方法を思い出してみましょう。</font><font style="vertical-align: inherit;">最初の要素へのポインタを宣言し、真理チェックがtrueを返すまでインクリメントする必要があります。</font><font style="vertical-align: inherit;">Loloではインクリメントできません。</font><font style="vertical-align: inherit;">しかし、それは大丈夫です。</font><font style="vertical-align: inherit;">結局のところ、ここでのパラメーターのリストは、配列のように、インデックスセーフの固定（呼び出し依存）長のタプルの形式で提示されます。</font><font style="vertical-align: inherit;">彼の名前は "？" </font><font style="vertical-align: inherit;">型チェックは、関数定義で設定されたパラメーターに対してのみ実行されます。</font><font style="vertical-align: inherit;">残りの（「マルチポイント」）パラメーターは任意のタイプに削減され、厄介な動きではその動作は定義されません。</font><font style="vertical-align: inherit;">ただし、そのようなタプルはCのマクロよりもはるかに安全で便利です。</font></font><br>
<br>
<pre><code class="plaintext hljs">void function(...) {<font></font>
    if (?.size &gt; 1) {<font></font>
        int i ~ ?[0]<font></font>
        real r ~ ?[1]<font></font>
    }<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値間隔</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして別の文字-インターバル型のファミリー（range、urange、lrangeなど）。</font><font style="vertical-align: inherit;">それらは2つのポイント（..）を介して2つの整数で与えられ、配列から配列、文字列から文字列を切り取ることができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">int[5] arr ~ [ 1, 2, 3, 4, 5 ]<font></font>
int[3] subarr = arr[1..3]  ;; [ 2, 3, 4 ]</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パスカルから。</font><font style="vertical-align: inherit;">文字列、配列、タプルで動作しますか？</font><font style="vertical-align: inherit;">と範囲。</font></font><br>
<br>
<pre><code class="plaintext hljs">int[5] arr ~ [ 1, 2, 3, 4, 5 ]<font></font>
if (4 in arr) nop</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数パラメーター辞書</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直なところ、これが正しく呼び出される方法はすでに混乱しています。これを使用すると、純粋でない関数の引数を直接指定できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">int pos = str_find(string, npos: -1)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのオプション</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++から。</font><font style="vertical-align: inherit;">ここでは例を挙げる必要はなく、すべてが明確です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、それらなしでどこに？</font></font><br>
<br>
<pre><code class="plaintext hljs">try {<font></font>
    raise SEGMENTATION_FAULT_EXCEPTION<font></font>
} except (Exception e) {<font></font>
    print(e.rus)<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無条件ジャンプなし</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2019年には、GOTOの死の演算子を使用することも同様であるためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、構文について少しお話します。お気づきのとおり、セミコロンは浅いです。最新のプログラミング言語は、このエラーの原因なしで非常にうまく機能します。例としては、Python、Kotlinがあります。矢印演算子（-&gt;）はドット演算子と組み合わされます。引数なしで関数を呼び出す場合、角かっこはオプションです。文字列は数値で与えられ、その逆も同様です。論理演算子とビットごとの演算子が組み合わされています。集計には関数修飾子があります。入れ子関数type_of。そして最も重要なこと-多言語主義。はい、私は国際コミュニケーションのすべての言語、つまり英語、ロシア語、日本語、中国語、スペイン語、ポルトガル語、アラビア語、フランス語、ドイツ語、ラテン語でキーワード、文字列と配列のプロパティ、および標準ライブラリのすべての識別子を複製します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、上記のすべてにLoloの機能の半分は含まれていません。</font><font style="vertical-align: inherit;">すべての機能をすぐに思い出せません。</font><font style="vertical-align: inherit;">コンパイラの準備ができたら追加します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460265/index.html">Xcodeプロジェクトテンプレートを作成する</a></li>
<li><a href="../ja460273/index.html">最小のApple Payでの承認</a></li>
<li><a href="../ja460275/index.html">完璧なソリューションが必要なのはなぜですか</a></li>
<li><a href="../ja460279/index.html">100億契約：国防総省のクラウドを誰が扱うか</a></li>
<li><a href="../ja460281/index.html">UXライターが製品の改善にどのように役立つか</a></li>
<li><a href="../ja460285/index.html">PHPを用意します。while、foreach、array_walk、その他の怖い言葉はどうですか</a></li>
<li><a href="../ja460287/index.html">ルネットニュース視覚化</a></li>
<li><a href="../ja460291/index.html">リクエストのバッチ処理の問題とその解決策（パート1）</a></li>
<li><a href="../ja460295/index.html">Rustで危険とはどういう意味ですか？</a></li>
<li><a href="../ja460297/index.html">WeakRef-ECMAScript標準に追加するための提案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>