<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüíª üçú üì£ Computa√ß√£o GPU - Por que, quando e como. Mais alguns testes üíà üë©‚Äç‚úàÔ∏è üôÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos sabem h√° muito tempo que, nas placas de v√≠deo, voc√™ n√£o pode apenas brincar com brinquedos, mas tamb√©m executar coisas que n√£o est√£o relacionada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Computa√ß√£o GPU - Por que, quando e como. Mais alguns testes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/498374/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos sabem h√° muito tempo que, nas placas de v√≠deo, voc√™ n√£o pode apenas brincar com brinquedos, mas tamb√©m executar coisas que n√£o est√£o relacionadas a jogos, por exemplo, treinar uma rede neural, lembrar-se de criptomoeda ou realizar c√°lculos cient√≠ficos. Como aconteceu, voc√™ pode l√™-lo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas eu queria </font><font style="vertical-align: inherit;">falar </font><font style="vertical-align: inherit;">sobre o </font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motivo pelo qual a GPU pode ser interessante para o</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programador m√©dio (n√£o relacionado ao GameDev) </font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como abordar o</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desenvolvimento na GPU sem gastar muito tempo, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decidir</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se olhe nessa dire√ß√£o e " </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descubra com os dedos" qual o lucro que voc√™ pode obter.</font></font></strong>&nbsp;<br>
<br>
<div style="text-align:center;"><img width="800" src="https://habrastorage.org/getpro/habr/post_images/3ee/2ac/893/3ee2ac8936a685e6993966cfa40f53fd.jpg"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O artigo foi escrito com base na minha </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresenta√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no HighLoad ++. </font><font style="vertical-align: inherit;">Ele discute principalmente as tecnologias oferecidas pela NVIDIA. </font><font style="vertical-align: inherit;">N√£o tenho o prop√≥sito de anunciar produtos, apenas os cito como exemplo e, com certeza, algo semelhante pode ser encontrado em fabricantes concorrentes.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que contar com a GPU?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dois processadores podem ser comparados de acordo com crit√©rios diferentes, provavelmente os mais populares s√£o a frequ√™ncia e o n√∫mero de n√∫cleos, o tamanho dos caches etc., mas no final, estamos interessados ‚Äã‚Äãem quantas opera√ß√µes um processador pode executar por unidade de tempo, que tipo de opera√ß√£o √© essa, mas uma pergunta separada Uma m√©trica comum √© o n√∫mero de opera√ß√µes de ponto flutuante por segundo - flops. E quando queremos comparar quente com macio e, no nosso caso, GPU com CPU, essa m√©trica √© √∫til. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O gr√°fico abaixo mostra o crescimento desses mesmos fracassos ao longo do tempo para processadores e placas de v√≠deo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e2/048/3f5/5e20483f59e87b0a395b0fae0e6495c5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Os dados s√£o coletados de fontes abertas, n√£o h√° dados para 2019-20 anos, porque nem tudo √© t√£o bonito l√°, mas as GPUs ainda vencem)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bem, √© tentador, n√£o √©? </font><font style="vertical-align: inherit;">Mudamos todos os c√°lculos da CPU para a GPU e obtemos oito vezes o melhor desempenho! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, claro, nem tudo √© t√£o simples. </font><font style="vertical-align: inherit;">Voc√™ n√£o pode simplesmente levar e transferir tudo para a GPU, por que conversaremos mais.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitetura da GPU e sua compara√ß√£o com a CPU</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trago para muitos uma imagem familiar com a arquitetura da CPU e os elementos b√°sicos:</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/df0/8c2/4c3/df08c24c3fe92cd97356670729c318cd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫cleo da CPU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O que h√° de t√£o especial? </font><font style="vertical-align: inherit;">Um n√∫cleo e um monte de blocos auxiliares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver a arquitetura da GPU:</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/0fe/138/0cc/0fe1380ccbb321b289d16e39a499009a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫cleo da GPU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Uma placa de v√≠deo possui muitos n√∫cleos de processamento, geralmente v√°rios milhares, mas s√£o combinados em blocos; para placas de v√≠deo NVIDIA, geralmente 32 cada, e possuem elementos comuns, incluindo e registros. A arquitetura do n√∫cleo da GPU e dos elementos l√≥gicos √© muito mais simples do que na CPU, ou seja, n√£o h√° pr√©-buscadores, preditores de brunch e muito mais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, esses s√£o os pontos principais da diferen√ßa na arquitetura da CPU e da GPU e, de fato, imp√µem restri√ß√µes ou, inversamente, abrem as possibilidades do que podemos ler efetivamente na GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu n√£o mencionei mais um ponto importante, geralmente, a placa de v√≠deo e o processador n√£o "remexem" entre si e gravam dados na placa de v√≠deo e l√™ o resultado de volta - essas s√£o opera√ß√µes separadas e podem vir a ser um "gargalo" em seu sistema, um gr√°fico do tempo de bombeamento versus tamanho dados s√£o fornecidos posteriormente neste artigo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limita√ß√µes e recursos da GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quais limita√ß√µes essa arquitetura imp√µe aos algoritmos execut√°veis:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se estivermos calculando em uma GPU, n√£o podemos selecionar apenas um n√∫cleo, um bloco inteiro de n√∫cleos ser√° alocado (32 para NVIDIA).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos os n√∫cleos executam as mesmas instru√ß√µes, mas com dados diferentes (falaremos sobre isso mais adiante), esses c√°lculos s√£o chamados de instru√ß√£o √∫nica - dados m√∫ltiplos ou SIMD (embora a NVIDIA introduza seu refinamento).&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido ao conjunto relativamente simples de blocos l√≥gicos e registros gerais, a GPU realmente n√£o gosta de ramifica√ß√£o e, de fato, a l√≥gica complexa nos algoritmos.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que oportunidades ele abre:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na verdade, a acelera√ß√£o desses mesmos c√°lculos SIMD. </font><font style="vertical-align: inherit;">O exemplo mais simples √© a adi√ß√£o elementar de matrizes, e vamos analis√°-lo.</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redu√ß√£o de algoritmos cl√°ssicos para representa√ß√£o SIMD</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transforma√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos duas matrizes, A e B, e queremos adicionar um elemento da matriz B a cada elemento da matriz A. Abaixo est√° um exemplo em C, embora eu espero que fique claro para aqueles que n√£o falam esse idioma:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span>
</span>{ 
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <font></font>
   { <font></font>
       A[i] += B[i]<font></font>
   } <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Loopback cl√°ssico de elementos em um loop e tempo de execu√ß√£o linear. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como esse c√≥digo ficar√° para a GPU:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span> 
</span>{ 
   <span class="hljs-keyword">int</span> i = threadIdx.x; 
   <span class="hljs-keyword">if</span> (i &lt; size) <font></font>
      A[i] += B[i] <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui j√° √© interessante, a vari√°vel threadIdx apareceu, o que n√£o parecemos declarar em lugar algum. Sim, seu sistema nos fornece. Imagine que no exemplo anterior a matriz consiste em tr√™s elementos e voc√™ deseja execut√°-la em tr√™s threads paralelos. Para fazer isso, voc√™ precisaria adicionar outro par√¢metro - o n√∫mero do √≠ndice ou fluxo. √â isso que a placa de v√≠deo faz por n√≥s, embora ela passe o √≠ndice como uma vari√°vel est√°tica e possa trabalhar com v√°rias dimens√µes ao mesmo tempo - x, y, z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra nuance: se voc√™ iniciar um grande n√∫mero de fluxos paralelos de uma s√≥ vez, os fluxos dever√£o ser divididos em blocos (um recurso arquitet√¥nico das placas de v√≠deo). O tamanho m√°ximo do bloco depende da placa de v√≠deo, e o √≠ndice do elemento para o qual realizamos c√°lculos precisar√° ser obtido da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-comment">// blockIdx ‚Äì  , blockDim ‚Äì  , threadIdx ‚Äì    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, o que temos: muitos threads de execu√ß√£o paralela que executam o mesmo c√≥digo, mas com √≠ndices diferentes e, consequentemente, dados, ou seja, </font><font style="vertical-align: inherit;">o mesmo SIMD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este √© o exemplo mais simples, mas se voc√™ quiser trabalhar com a GPU, precisar√° levar sua tarefa para o mesmo formul√°rio. </font><font style="vertical-align: inherit;">Infelizmente, isso nem sempre √© poss√≠vel e, em alguns casos, pode se tornar objeto de uma disserta√ß√£o de doutorado, mas, no entanto, algoritmos cl√°ssicos ainda podem ser trazidos para esse formul√°rio.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agrega√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos agora ver como ser√° a agrega√ß√£o convertida para a representa√ß√£o SIMD:</font></font><br>
&nbsp;<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/ecd/78a/bba/ecd78abbaff0c1be8799c1337f7652f8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos uma matriz de n elementos. </font><font style="vertical-align: inherit;">No primeiro est√°gio, iniciamos n / 2 threads e cada thread adiciona dois elementos, ou seja, </font><font style="vertical-align: inherit;">em uma itera√ß√£o, adicionamos metade dos elementos na matriz. </font><font style="vertical-align: inherit;">E ent√£o, no loop, repetimos a mesma coisa para a matriz rec√©m-criada, at√© agregar os dois √∫ltimos elementos. </font><font style="vertical-align: inherit;">Como voc√™ pode ver, quanto menor o tamanho da matriz, menos threads paralelos podemos iniciar, ou seja, </font><font style="vertical-align: inherit;">em uma GPU, faz sentido agregar matrizes de tamanho suficientemente grande. </font><font style="vertical-align: inherit;">Esse algoritmo pode ser usado para calcular a soma de elementos (a prop√≥sito, n√£o se esque√ßa do poss√≠vel estouro do tipo de dados com o qual voc√™ est√° trabalhando), procure o m√°ximo, o m√≠nimo ou apenas a pesquisa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordena√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas a classifica√ß√£o j√° parece muito mais complicada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os dois algoritmos de classifica√ß√£o mais populares na GPU s√£o:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitonic-sort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radix-sort</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por√©m, o radix-sort ainda √© usado com mais frequ√™ncia e a implementa√ß√£o pronta para produ√ß√£o pode ser encontrada em algumas bibliotecas. </font><font style="vertical-align: inherit;">N√£o analisarei detalhadamente como esses algoritmos funcionam; os interessados ‚Äã‚Äãpodem encontrar uma descri√ß√£o do tipo de raiz em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.codeproject.com/Articles/543451/Parallel-Radix-Sort-on-the-GPU-using-Cplusplus- AMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://stackoverflow.com/a/26229897</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mas a ideia √© que mesmo um algoritmo n√£o linear como a classifica√ß√£o possa ser reduzido a uma visualiza√ß√£o SIMD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora, antes de analisar os n√∫meros reais que podem ser obtidos na GPU, vamos descobrir como programar para esse milagre da tecnologia?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onde come√ßar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As duas tecnologias mais comuns que podem ser usadas para programa√ß√£o na GPU:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opencl</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O OpenCL √© um padr√£o suportado pela maioria dos fabricantes de placas de v√≠deo, incluindo </font><font style="vertical-align: inherit;">e em dispositivos m√≥veis, tamb√©m o c√≥digo escrito em OpenCL pode ser executado na CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode usar o OpenCL a partir de C / C ++, existem pastas para outros idiomas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o OpenCL, gostei mais do livro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL in Action</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tamb√©m descreve diferentes algoritmos na GPU, incluindo </font><font style="vertical-align: inherit;">Classifica√ß√£o Bitonic e Radix. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA √© a tecnologia propriet√°ria e o SDK da NVIDIA. </font><font style="vertical-align: inherit;">Voc√™ pode escrever em C / C ++ ou usar liga√ß√µes para outros idiomas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparar OpenCL e CUDA n√£o est√° correto, porque </font><font style="vertical-align: inherit;">um √© o padr√£o, o outro √© o SDK inteiro. </font><font style="vertical-align: inherit;">No entanto, muitas pessoas escolhem a CUDA para o desenvolvimento de placas de v√≠deo, apesar de a tecnologia ser propriet√°ria, embora gratuita e funcionando apenas em placas NVIDIA. </font><font style="vertical-align: inherit;">H√° v√°rias raz√µes para isso:</font></font><br>
<br>
<ul>
<li>  API</li>
<li>    </li>
<li>,   GPU,      (host) </li>
<li> ,  ..  </li>
<li>   </li>
<li>  </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As peculiaridades incluem o fato de que o CUDA vem com seu pr√≥prio compilador, que tamb√©m pode compilar o c√≥digo C / C ++ padr√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O livro CUDA mais abrangente que me deparei foi a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programa√ß√£o CUDA C profissional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , embora j√° esteja um pouco desatualizada, mas discute muitas nuances t√©cnicas de programa√ß√£o para placas NVIDIA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas e se eu n√£o quiser passar alguns meses lendo esses livros, escrevendo meu pr√≥prio programa para uma placa de v√≠deo, testando e depurando e depois descobrindo que isso n√£o √© para mim?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse, h√° um grande n√∫mero de bibliotecas que escondem a complexidade do desenvolvimento sob a GPU: XGBoost, cuBLAS, TensorFlow, PyTorch e outras, consideraremos a biblioteca de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empuxo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uma vez que √© menos especializada do que as outras bibliotecas acima, mas ao mesmo tempo implementa algoritmos b√°sicos, por exemplo, classifica√ß√£o, pesquisa, agrega√ß√£o e com alta probabilidade de aplicabilidade em suas tarefas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thrust √© uma biblioteca C ++ que visa "substituir" algoritmos STL padr√£o por algoritmos baseados em GPU. </font><font style="vertical-align: inherit;">Por exemplo, classificar uma matriz de n√∫meros usando esta biblioteca em uma placa de v√≠deo seria assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">thrust::host_vector&lt;DataType&gt; <span class="hljs-title">h_vec</span><span class="hljs-params">(size)</span></span>; <span class="hljs-comment">//    </span>
<span class="hljs-built_in">std</span>::generate(h_vec.begin(), h_vec.end(), rand); <span class="hljs-comment">//   </span>
thrust::device_vector&lt;DataType&gt; d_vec = h_vec; <span class="hljs-comment">//        &nbsp;</span>
thrust::sort(d_vec.begin(), d_vec.end()); <span class="hljs-comment">//    </span>
thrust::copy(d_vec.begin(), d_vec.end(), h_vec.begin()); <span class="hljs-comment">//   ,     </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(n√£o esque√ßa que o exemplo deve ser compilado por um compilador da NVIDIA)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, o thrust :: sort √© muito semelhante a um algoritmo semelhante do STL. Esta biblioteca esconde muitas dificuldades, em particular o desenvolvimento de um subprograma (mais precisamente, o kernel), que ser√° executado na placa de v√≠deo, mas, ao mesmo tempo, priva a flexibilidade. Por exemplo, se quisermos classificar v√°rios gigabytes de dados, seria l√≥gico enviar um dado para o cart√£o para iniciar a classifica√ß√£o e, enquanto a classifica√ß√£o estiver em andamento, envie mais dados para o cart√£o. Essa abordagem √© chamada oculta√ß√£o de lat√™ncia e permite um uso mais eficiente dos recursos de mapas do servidor, mas, infelizmente, quando usamos bibliotecas de alto n√≠vel, essas oportunidades permanecem ocultas. Mas para prototipar e medir o desempenho, eles s√£o iguais, especialmente com o empuxo, que voc√™ pode medir qual sobrecarga a transfer√™ncia de dados fornece. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escrevi uma pequena </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refer√™ncia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando esta biblioteca, que executa v√°rios algoritmos populares com diferentes quantidades de dados na GPU, vamos ver quais s√£o os resultados.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados do algoritmo GPU</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para testar a GPU, eu instalei uma inst√¢ncia na AWS com uma placa de v√≠deo Tesla k80, essa n√£o √© a placa de servidor mais poderosa at√© o momento (a Tesla v100 mais poderosa), mas a mais acess√≠vel e a bordo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4992 CUDA Kernels</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24 GB de mem√≥ria</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">480 Gb / s - largura de banda de mem√≥ria&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E para testes na CPU, tomei uma inst√¢ncia com um processador Intel Xeon CPU E5-2686 v4 a 2.30GHz</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transforma√ß√£o</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/930/6e1/687/9306e1687be5ee95c29c8aac7b2ae337.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo de execu√ß√£o da transforma√ß√£o na GPU e CPU em ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como voc√™ pode ver, a transforma√ß√£o usual dos elementos da matriz √© aproximadamente a mesma no tempo, tanto na GPU quanto na CPU. </font><font style="vertical-align: inherit;">E porque? </font><font style="vertical-align: inherit;">Como a sobrecarga para enviar dados para o cart√£o e vice-versa consome todo o aumento de desempenho (falaremos sobre sobrecarga separadamente), e h√° relativamente poucos c√°lculos no cart√£o. </font><font style="vertical-align: inherit;">Al√©m disso, n√£o esque√ßa que os processadores tamb√©m suportam instru√ß√µes SIMD e os compiladores, em casos simples, podem us√°-los efetivamente.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos agora ver com que efici√™ncia a agrega√ß√£o √© feita na GPU.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agrega√ß√£o</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c92/d0e/cb9/c92d0ecb96c32866000e6948f5da61f9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo de execu√ß√£o da agrega√ß√£o na GPU e CPU em ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
No exemplo de agrega√ß√£o, j√° observamos um aumento significativo no desempenho com um aumento no volume de dados. </font><font style="vertical-align: inherit;">Tamb√©m vale a pena prestar aten√ß√£o ao fato de bombearmos uma grande quantidade de dados para a mem√≥ria do cart√£o e apenas um valor agregado √© recuperado, ou seja, </font><font style="vertical-align: inherit;">A sobrecarga para transferir dados do cart√£o para a RAM √© m√≠nima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos para o exemplo mais interessante - a classifica√ß√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordena√ß√£o</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fde/504/8da/fde5048da5084d1f0902c9362b21d939.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classifica√ß√£o do tempo na GPU e CPU em ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Apesar de enviarmos toda a matriz de dados para a placa de v√≠deo e vice-versa, a classifica√ß√£o na GPU de 800 MB de dados √© aproximadamente 25 vezes mais r√°pida que no processador.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobrecarga de transfer√™ncia de dados</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como pode ser visto no exemplo de transforma√ß√£o, nem sempre √© √≥bvio se a GPU ser√° eficaz, mesmo nas tarefas que s√£o paralelas. </font><font style="vertical-align: inherit;">O motivo disso √© uma sobrecarga para transferir dados da RAM do computador para a mem√≥ria da placa de v√≠deo (em consoles de jogos, a prop√≥sito, a mem√≥ria √© compartilhada entre a CPU e a GPU e n√£o √© necess√°rio transferir dados). </font><font style="vertical-align: inherit;">Uma das caracter√≠sticas de uma placa de v√≠deo √© a largura de banda da mem√≥ria ou largura de banda da mem√≥ria, que determina a largura de banda te√≥rica da placa. </font><font style="vertical-align: inherit;">Para o Tesla k80, √© de 480 GB / s, para o Tesla v100, j√° √© de 900 GB / s. </font><font style="vertical-align: inherit;">Al√©m disso, a vers√£o PCI Express e a implementa√ß√£o de como voc√™ transferir√° dados para o cart√£o afetar√£o a taxa de transfer√™ncia, por exemplo, isso pode ser feito em v√°rios fluxos paralelos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos os resultados pr√°ticos obtidos para a placa gr√°fica Tesla k80 na nuvem Amazon:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/fb5/613/798fb56139f6158566232bc6283b24e7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hora de transferir dados para a GPU, classificar e transferir dados de volta para a RAM em ms </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HtoD - transferir dados para a placa de v√≠deo da </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU Execu√ß√£o - classificar na placa de v√≠deo </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DtoH - copiar dados da placa de v√≠deo para a RAM</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A primeira coisa a observar √© que a leitura de dados da placa de v√≠deo √© mais r√°pida do que escreva-as l√° em baixo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda - ao trabalhar com uma placa de v√≠deo, √© poss√≠vel obter lat√™ncia de 350 microssegundos, e isso j√° pode ser suficiente para alguns aplicativos de baixa lat√™ncia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O gr√°fico abaixo mostra uma sobrecarga para mais dados:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/653/b96/d18653b96af325f35fade713bdaa8dae.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hora de transferir dados para a GPU, classificar e transferir dados de volta para a RAM em ms</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso do servidor</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pergunta mais comum √© como a placa de v√≠deo do jogo difere da placa de servidor? </font><font style="vertical-align: inherit;">De acordo com as caracter√≠sticas, eles s√£o muito semelhantes, mas os pre√ßos diferem significativamente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/01b/741/20301b7418ee616d9611f42d2b4a8f5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As principais diferen√ßas entre o servidor (NVIDIA) e a placa de jogo:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garantia do fabricante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o cart√£o de jogo n√£o foi projetado para uso do servidor)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poss√≠veis problemas de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtualiza√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para uma placa gr√°fica de consumidor</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disponibilidade do mecanismo de corre√ß√£o de erros na placa do servidor</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de threads paralelos (n√£o n√∫cleos CUDA) ou suporte ao Hyper-Q, que permite trabalhar com o cart√£o de v√°rios threads na CPU, por exemplo, fazer upload de dados para o cart√£o de um thread e iniciar c√°lculos com outro</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas s√£o, talvez, as principais diferen√ßas importantes que encontrei.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois que descobrimos como executar o algoritmo mais simples na placa de v√≠deo e quais resultados podem ser esperados, a pr√≥xima pergunta l√≥gica √© como a placa de v√≠deo se comportar√° ao processar v√°rias solicita√ß√µes paralelas. Como resposta, tenho dois gr√°ficos de computa√ß√£o na GPU e um processador com 4 e 32 n√∫cleos:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a1/1f6/022/0a11f6022198a582929f384be357fe43.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tempo necess√°rio para executar c√°lculos matem√°ticos na GPU e na CPU com matrizes de 1000 x 60 em ms.Este</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
gr√°fico executa c√°lculos com matrizes de 1000 x 60 elementos. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os c√°lculos s√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iniciados a </font><font style="vertical-align: inherit;">partir de v√°rios fluxos de programas; um fluxo separado √© criado para a GPU para cada fluxo de CPU (o pr√≥prio Hyper-Q √© usado).&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, o processador lida muito bem com essa carga, enquanto a lat√™ncia de uma solicita√ß√£o por GPU aumenta significativamente com um aumento no n√∫mero de solicita√ß√µes paralelas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/22c/7fb/e0922c7fba0ef001cca97c7a99817c83.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tempo para realizar c√°lculos matem√°ticos na GPU e CPU com matrizes 10.000 x 60 em ms.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
No segundo gr√°fico, os mesmos c√°lculos, mas com matrizes 10 vezes mais longas, e a GPU se comporta muito melhor sob essa carga. Esses gr√°ficos s√£o muito indicativos e podemos concluir: o comportamento sob carga depende da natureza da pr√≥pria carga. Um processador tamb√©m pode lidar com c√°lculos matriciais de maneira bastante eficiente, mas at√© certo ponto. Para uma placa de v√≠deo, √© caracter√≠stico que, para uma pequena carga de computa√ß√£o, o desempenho diminua aproximadamente linearmente. Com um aumento na carga e no n√∫mero de threads paralelos, a placa de v√≠deo lida melhor.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â dif√≠cil supor como a GPU se comportar√° em v√°rias situa√ß√µes, mas como voc√™ pode ver, sob certas condi√ß√µes, uma placa de servidor pode processar solicita√ß√µes de v√°rios fluxos paralelos com bastante efici√™ncia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discutiremos mais algumas perguntas que voc√™ possa ter se ainda decidir usar a GPU em seus projetos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limite de recursos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como j√° dissemos, os dois principais recursos de uma placa de v√≠deo s√£o os n√∫cleos e a mem√≥ria da computa√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, temos v√°rios processos ou cont√™ineres usando uma placa de v√≠deo e gostar√≠amos de poder compartilhar a placa de v√≠deo entre eles. </font><font style="vertical-align: inherit;">Infelizmente, n√£o existe uma API simples para isso. </font><font style="vertical-align: inherit;">A NVIDIA oferece tecnologia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vGPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas n√£o encontrei a placa Tesla k80 na lista de placas suportadas e, at√© onde posso entender pela descri√ß√£o, a tecnologia est√° mais focada em monitores virtuais do que em c√°lculos. </font><font style="vertical-align: inherit;">Talvez a AMD ofere√ßa algo mais adequado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, se voc√™ planeja usar a GPU em seus projetos, deve confiar no fato de que o aplicativo usar√° a placa de v√≠deo exclusivamente ou controlar√° programaticamente a quantidade de mem√≥ria alocada e o n√∫mero de n√∫cleos usados ‚Äã‚Äãnos c√°lculos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cont√™ineres e GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ descobriu o limite de recursos, a seguinte pergunta l√≥gica: e se houver v√°rias placas de v√≠deo no servidor? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Novamente, voc√™ pode decidir, no n√≠vel do aplicativo, qual GPU ele usar√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra maneira mais conveniente s√£o os cont√™ineres Docker. </font><font style="vertical-align: inherit;">Voc√™ pode usar cont√™ineres regulares, mas a NVIDIA oferece seus cont√™ineres </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NGC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , com vers√µes otimizadas de v√°rios softwares, bibliotecas e drivers. </font><font style="vertical-align: inherit;">Para um cont√™iner, voc√™ pode limitar o n√∫mero de GPUs usadas e sua visibilidade para o cont√™iner. </font><font style="vertical-align: inherit;">A sobrecarga no uso de cont√™iner √© de cerca de 3%.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhar em um cluster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra pergunta, o que fazer se voc√™ deseja executar uma tarefa em v√°rias GPUs no mesmo servidor ou cluster? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ escolheu uma biblioteca semelhante ao empuxo ou a uma solu√ß√£o de n√≠vel inferior, a tarefa ter√° que ser resolvida manualmente. </font><font style="vertical-align: inherit;">Estruturas de alto n√≠vel, por exemplo, para aprendizado de m√°quina ou redes neurais, geralmente suportam a capacidade de usar v√°rias placas prontas para uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, gostaria de observar que, por exemplo, a NVIDIA oferece uma interface para troca direta de dados entre cart√µes - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVLINK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que √© significativamente mais r√°pido que o PCI Express. </font><font style="vertical-align: inherit;">E h√° tecnologia para acesso direto √† mem√≥ria da placa de outros dispositivos PCI Express - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUDirect RDMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , incl. </font><font style="vertical-align: inherit;">e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rede</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomenda√ß√µes</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ est√° pensando em usar a GPU em seus projetos, √© prov√°vel que a GPU seja adequada para voc√™ se:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sua tarefa pode ser reduzida para uma visualiza√ß√£o SIMD</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â poss√≠vel carregar a maioria dos dados no mapa antes dos c√°lculos (cache)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O desafio envolve computa√ß√£o intensiva</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ tamb√©m deve fazer perguntas com anteced√™ncia:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quantas consultas paralelas ser√£o&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que lat√™ncia voc√™ espera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ precisa de uma placa para sua carga? Voc√™ precisa de um servidor com v√°rias placas ou um cluster de servidores GPU&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√≥ isso, espero que o material seja √∫til e ajude voc√™ a tomar a decis√£o certa!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncias</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Refer√™ncia e resultados no github - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tishden/gpu_benchmark/tree/master/cuda</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Al√©m do t√≥pico, uma grava√ß√£o do relat√≥rio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Bancos de dados GPU - Arquitetura, desempenho e perspectivas de uso"</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Webinar NVIDIA NGC Containers - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http : //bit.ly/2UmVIVt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bit.ly/2x4vJKF</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt498362/index.html">A Kingston mant√©m a lideran√ßa nos envios de SSD: como fazemos?</a></li>
<li><a href="../pt498366/index.html">Quais algoritmos os desenvolvedores Yandex implementam todos os dias</a></li>
<li><a href="../pt498368/index.html">A hist√≥ria de um switch</a></li>
<li><a href="../pt498370/index.html">SAP UI5 e Windows de confirma√ß√£o: novamente sobre o contexto</a></li>
<li><a href="../pt498372/index.html">Tutorial do simulador de rede ns-3. cap√≠tulo 5</a></li>
<li><a href="../pt498378/index.html">An√∫ncio da Escola Noturna de Slurm pela Agile</a></li>
<li><a href="../pt498380/index.html">Janela de Overton em a√ß√£o: como uma pandemia √© usada para limitar nossa liberdade</a></li>
<li><a href="../pt498390/index.html">IAR + Clion = amizade</a></li>
<li><a href="../pt498392/index.html">18 recursos do GitLab s√£o de c√≥digo aberto</a></li>
<li><a href="../pt498394/index.html">7 an√°logos gratuitos de Screaming Frog e Netpeak Spider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>