<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù£Ô∏è üëê üë©üèº‚Äçüé§ SHISHUA: el generador de n√∫meros pseudoaleatorios m√°s r√°pido del mundo üïµüèº ü§≤üèΩ üå∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace seis meses, quer√≠a crear el mejor generador de n√∫meros pseudoaleatorios (PRNG) con una arquitectura inusual. Pens√© que el comienzo ser√≠a f√°cil, y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: el generador de n√∫meros pseudoaleatorios m√°s r√°pido del mundo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace seis meses, quer√≠a crear el mejor generador de n√∫meros pseudoaleatorios (PRNG) con una arquitectura inusual. Pens√© que el comienzo ser√≠a f√°cil, y mientras trabajas, la tarea se volver√° lentamente m√°s compleja. Y pens√© que si pod√≠a aprender todo lo suficientemente r√°pido como para hacer frente a lo m√°s dif√≠cil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para mi sorpresa, la complejidad no aument√≥ linealmente. ¬°La prueba de bytes de chi-cuadrado result√≥ ser muy dif√≠cil! M√°s tarde, fue igual de dif√≠cil pasar pruebas ac√©rrimas. Me </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publicaron los resultados actuales</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para entender lo que otras dificultades me esperan. Sin embargo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la prueba PractRand fall√≥ en ese momento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces fue muy dif√≠cil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasar la prueba BigCrush</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces fue muy dif√≠cil transferir 32 terabytes de datos al pasar PractRand. </font><font style="vertical-align: inherit;">La velocidad se ha convertido en un problema. </font><font style="vertical-align: inherit;">No fue suficiente crear un dise√±o que generara diez megabytes por segundo, porque pasar PractRand llevar√≠a un mes. </font><font style="vertical-align: inherit;">Pero debo admitir que </font><font style="vertical-align: inherit;">fue muy dif√≠cil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasar esta prueba a una velocidad de gigabytes por segundo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando te elevas a tal altura ... quieres saber si puedes llegar al borde de Pareto. </font><font style="vertical-align: inherit;">Desea crear el PRNG m√°s r√°pido del mundo, que pasar√° las pruebas estad√≠sticas m√°s complejas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He tenido √©xito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> habl√© sobre lo que aprend√≠ para lograr mi objetivo. </font><font style="vertical-align: inherit;">Y aqu√≠ te dir√© c√≥mo funciona la arquitectura final.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prop√≥sito</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con lo obvio: la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad depende de la plataforma</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Me centr√© en optimizar para la arquitectura moderna x86-64 (procesadores Intel y AMD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comparar el rendimiento, se utiliza la m√©trica </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cl√°sica </font><font style="vertical-align: inherit;">: este es el n√∫mero de ciclos de procesador dedicados a generar un byte. </font><font style="vertical-align: inherit;">Esta m√©trica se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcula y compara</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en todos los trabajos criptogr√°ficos. </font><font style="vertical-align: inherit;">Un cpb ligeramente inferior en el mundo del software o hardware puede garantizar la victoria en la competencia o el uso en sitios web de todo el mundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para mejorar cpb, puedes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genera m√°s bytes con la misma cantidad de trabajo,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O haga menos trabajo para generar el mismo n√∫mero de bytes,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O paralelizar el trabajo.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haremos todo lo anterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seg√∫n el primer punto, necesitamos producir m√°s bits en cada iteraci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ten√≠a miedo de que me dijeran: "Si no da n√∫meros de 32 bits, entonces este no es el DELP", o lo mismo con los n√∫meros de 64 bits. O: "El PRNG solo debe ser para arquitectura x86-64", como si las instrucciones como POPCNT o registros como% xmm7 estuvieran prohibidos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, el PRNG es ingenier√≠a: ¬°los generadores han estado tratando durante varias d√©cadas de exprimir todo lo posible de los procesadores! Cuando apareci√≥ ROL, comenzaron a confiar en √©l. Con la llegada de los procesadores de 64 bits, comenzaron a confiar en% rax. Por supuesto, en ARM, tales algoritmos pueden funcionar m√°s lentamente (aunque esto a√∫n est√° por verse), sin embargo, los PRN de 64 bits se usaron activamente incluso antes de que Android comenzara a requerir soporte para 64 bits en 2019. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, esta √°rea se est√° desarrollando junto con el hardware. Y hoy, los procesadores Intel y AMD debido a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya admiten operaciones de 256 bits. RC4 produjo 1 byte, drand48 podr√≠a producir 4 bytes a la vez, pcg64 - 8 bytes, y ahora podemos generar inmediatamente 32 bytes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 bytes pueden ser un n√∫mero de 64 bits, y la mayor√≠a de los lenguajes de programaci√≥n tienen tipos incorporados para esto. </font><font style="vertical-align: inherit;">Pero pocos idiomas proporcionan tipos para 16 bytes (una excepci√≥n notable es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en C). </font><font style="vertical-align: inherit;">Incluso menos idiomas tienen tipo para 32 bytes (excepto interno). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces podemos decir adi√≥s al prototipo habitual de la funci√≥n PRNG (ejemplo del punto de referencia Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cambio, puede hacer un generador que llene el b√∫fer (ejemplo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mi punto de referencia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øCu√°les son las desventajas de esta soluci√≥n? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su generador produce 32 bytes a la vez, entonces necesita que el consumidor proporcione una matriz que sea un m√∫ltiplo de 32 (idealmente alineado a 32 bytes). </font><font style="vertical-align: inherit;">Aunque puede prescindir de √©l, simplemente llenaremos el b√∫fer. </font><font style="vertical-align: inherit;">Eliminaremos los datos no utilizados y los rellenaremos nuevamente seg√∫n sea necesario. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El retraso se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vuelve impredecible: algunas llamadas solo leer√°n el b√∫fer. </font><font style="vertical-align: inherit;">Pero en promedio todo ser√° igual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora generamos m√°s bytes, haciendo la misma cantidad de trabajo. </font><font style="vertical-align: inherit;">¬øC√≥mo lo paralelizamos?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelismo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los procesadores ofrecen un incre√≠ble conjunto de herramientas de paralelizaci√≥n en todos los niveles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, estas son instrucciones SIMD (Instrucci√≥n √∫nica, Datos m√∫ltiples). Por ejemplo, AVX2 realiza simult√°neamente cuatro adiciones de 64 bits, u ocho adiciones de 32 bits, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ha utilizado en criptograf√≠a durante aproximadamente quince a√±os. La concurrencia proporcion√≥ el incre√≠ble rendimiento de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo usan las primitivas m√°s importantes que no usan AESNI. Por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli est√°n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dise√±ados con el paralelismo en mente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente, el inter√©s en este tema tambi√©n ha aumentado en la comunidad PRNG no criptogr√°fica. En particular, las primitivas existentes que no fueron dise√±adas para SIMD pueden ser la base para crear PRN muy r√°pidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando Sebastiano Vigna promocion√≥ su arquitectura </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la biblioteca est√°ndar de Julia, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descubri√≥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que los resultados de ocho instancias de PRNG competitivas y con inicializaci√≥n diferente pueden concatenarse muy r√°pidamente si cada operaci√≥n se realiza simult√°neamente en todas las PRNR. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD es solo uno de los niveles de paralelizaci√≥n en el procesador. Recomiendo leer el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior sobre este tema</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para tener una mejor idea, pero dar√© algunas explicaciones. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las canalizaciones del procesador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permiten procesar varias instrucciones en diferentes etapas. Si el orden de su ejecuci√≥n est√° bien organizado para reducir las dependencias entre etapas, entonces el procesamiento de las instrucciones puede acelerarse.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ejecuci√≥n superescalar le</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite procesar simult√°neamente las partes inform√°ticas de las instrucciones. </font><font style="vertical-align: inherit;">Pero para esto no deber√≠an tener dependencias de lectura-escritura. </font><font style="vertical-align: inherit;">Puede adaptar la arquitectura para reducir el riesgo de tiempo de inactividad grabando mucho antes de leer. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ejecuci√≥n extraordinaria</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite que el procesador ejecute instrucciones no en el orden de secuencia, sino como est√°n listas, incluso si las instrucciones anteriores a√∫n no est√°n listas. </font><font style="vertical-align: inherit;">Pero para esto no deber√≠a haber dependencia de lectura-escritura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Y ahora pasamos a la implementaci√≥n!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitectura</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere un esquema llamado semi-SHISHUA. </font><font style="vertical-align: inherit;">De d√≥nde viene ese nombre se har√° gradualmente aparente a medida que leas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El esquema se ve as√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere su l√≠nea por l√≠nea.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El estado se divide en dos partes, que se colocan en el registro AVX2 (256 bits). Para aumentar la velocidad, mantenemos el resultado cerca del estado en s√≠, pero no es parte del estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n tenemos un contador de 64 bits. Para simplificar el c√°lculo, tambi√©n es un registro AVX2. El hecho es que AVX2 tiene una peque√±a caracter√≠stica: los registros ordinarios (% rax y similares) no se pueden transferir directamente a SIMD a trav√©s de MOV, deben pasar a trav√©s de RAM (a menudo a trav√©s de la pila), lo que aumenta el retraso y cuesta dos instrucciones de procesador (MOV en la pila, VMOV de la pila). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora echemos un vistazo a la generaci√≥n. Comencemos cargando, luego revise el b√∫fer y ll√©nelo con 32 bytes en cada iteraci√≥n.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // ‚Ä¶<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que la funci√≥n est√° en l√≠nea, el llenado inmediato del b√∫fer al inicio permite que el procesador ejecute inmediatamente las instrucciones dependiendo de esto mediante un mecanismo de ejecuci√≥n extraordinario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro del ciclo, realizamos r√°pidamente tres operaciones de estado:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De ah√≠ el nombre de SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primer turno</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, el AVX2 no admite revoluciones. </font><font style="vertical-align: inherit;">¬°Pero quiero mezclar los bits de una posici√≥n en un n√∫mero de 64 bits con los bits de otra posici√≥n! </font><font style="vertical-align: inherit;">Y shift es la mejor manera de darse cuenta de esto. </font><font style="vertical-align: inherit;">Cambiaremos por un n√∫mero impar, de modo que cada bit visitar√° todas las posiciones de 64 bits, y no la mitad de ellas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante el cambio, se pierden bits, lo que conduce a la eliminaci√≥n de informaci√≥n de nuestro estado. </font><font style="vertical-align: inherit;">Esto es malo, debe minimizar las p√©rdidas. </font><font style="vertical-align: inherit;">Los n√∫meros impares m√°s peque√±os son 1 y 3, utilizaremos diferentes valores de desplazamiento para aumentar la discrepancia entre las dos partes. </font><font style="vertical-align: inherit;">Esto ayudar√° a reducir la similitud de su autocorrelaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos desplazaremos a la derecha, porque los bits m√°s a la derecha tienen la difusi√≥n m√°s baja durante la suma: por ejemplo, el bit menos significativo en A + B es solo el XOR de los bits menos significativos A y B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emocionante</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilizaremos la mezcla de 32 bits, ya que proporciona una granularidad diferente en comparaci√≥n con las operaciones de 64 bits que usamos en todas partes (se viola la alineaci√≥n de 64 bits). Tambi√©n puede ser una operaci√≥n de carril cruzado: otras barajas pueden mover bits dentro de los 128 bits de la izquierda si comienzan a la izquierda, o dentro de los 128 bits de la derecha si comienzan a la derecha. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Constantes de mezcla:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que la mezcla realmente mejore el resultado, trasladaremos las partes d√©biles (baja dispersi√≥n) de 32 bits de las adiciones de 64 bits a posiciones fuertes, de modo que las siguientes adiciones las enriquezcan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La parte de 32 bits de gama baja del fragmento de 64 bits nunca se mueve al mismo fragmento de 64 bits que la parte de orden superior. </font><font style="vertical-align: inherit;">Por lo tanto, ambas partes no permanecen dentro del mismo fragmento, lo que mejora la mezcla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, cada parte de 32 bits pasa por todas las posiciones en un c√≠rculo: de A a B, de B a C, ... de H a A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es posible que haya notado que la mezcla m√°s simple que tiene en cuenta todos estos requisitos es dos 256 bits rotaci√≥n (revoluciones de 96 bits y 160 bits a la derecha, respectivamente).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agreguemos fragmentos de 64 bits de dos variables temporales: cambio y mezcla.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La adici√≥n es la principal fuente de dispersi√≥n: en esta operaci√≥n, los bits se combinan en combinaciones irreducibles de expresiones XOR y AND distribuidas en posiciones de 64 bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Almacenar el resultado de la adici√≥n dentro de un estado preserva permanentemente esta dispersi√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funci√≥n de salida</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øDe d√≥nde obtenemos la salida? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es simple: la estructura que creamos nos permite generar dos partes independientes del estado s0 y s1, que no se afectan entre s√≠ de ninguna manera. </font><font style="vertical-align: inherit;">Aplique XOR a ellos y obtenga un resultado completamente al azar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fortalecer la independencia entre los datos a los que aplicamos XOR, tomamos un resultado parcial: la parte desplazada de un estado y la parte mixta de otro.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es similar a reducir las dependencias de lectura y escritura entre instrucciones en un procesador superescalar, como si u0 y t1 estuvieran listas para leer en s0 y s1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora discuta el mostrador. Lo procesamos al comienzo del ciclo. Primero, cambie el estado y luego aumente el valor del contador:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© primero cambiamos el estado y luego actualizamos el contador? s1 est√° disponible antes, esto reduce la probabilidad de que las instrucciones posteriores que lo lean se detengan en la tuber√≠a del procesador. Adem√°s, esta secuencia ayuda a evitar la dependencia directa del contador de lectura-escritura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicamos el contador a s1, y no a s0, porque ambos afectan la salida de todos modos, sin embargo, s1 pierde m√°s bits debido al cambio, por lo que le ayuda a "ponerse de pie" despu√©s del cambio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El contador no puede grabar la prueba PractRand. Su √∫nico prop√≥sito es establecer un l√≠mite inferior de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes = 512 exbibytes para el per√≠odo PRNG: comenzamos a repetir el ciclo solo despu√©s de un milenio de trabajo a una velocidad de 10 gibytes por segundo. Es poco probable que sea demasiado lento para su uso pr√°ctico en los pr√≥ximos siglos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incremento:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los n√∫meros impares se eligen como incrementos, porque solo los n√∫meros primos b√°sicos cubren todo el ciclo del campo finito GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), y todos los n√∫meros impares son primos para 2. En otras palabras, si incrementa en un entero par en el rango de 0 a 4, volviendo a 0 despu√©s de 4, obtenemos la secuencia 0-2-0-2- ..., que nunca conducir√° a 1 o 3. Y el incremento impar pasa por todos los enteros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todos los n√∫meros de 64 bits en estado, utilizaremos diferentes n√∫meros impares, que los separar√°n a√∫n m√°s y aumentar√°n ligeramente la mezcla. </font><font style="vertical-align: inherit;">Eleg√≠ los n√∫meros impares m√°s peque√±os para que no se vean m√°gicos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como funcionan la transici√≥n de estado y la funci√≥n de salida. </font><font style="vertical-align: inherit;">¬øC√≥mo inicializarlos?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializamos el estado usando los d√≠gitos hexadecimales Œ¶, el n√∫mero irracional que es menos aproximado por la fracci√≥n.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toma una semilla de 256 bits. </font><font style="vertical-align: inherit;">Esto a menudo se realiza en criptograf√≠a y no da√±a el trabajo de los PRNG no criptogr√°ficos:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // ‚Ä¶<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No queremos redefinir toda la parte del estado (s0 o s1) con este n√∫mero inicial, solo necesitamos afectar la mitad. </font><font style="vertical-align: inherit;">De esta manera, evitaremos el uso de n√∫meros iniciales atenuantes, que accidental o intencionalmente dan lugar a un estado inicial d√©bil conocido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como no cambiamos la mitad de cada estado, conservamos el control sobre 128 bits de estado. </font><font style="vertical-align: inherit;">Tal entrop√≠a es suficiente para comenzar y mantener una posici√≥n fuerte.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego repetimos ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">varias veces la </font><font style="vertical-align: inherit;">siguiente secuencia:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecute los pasos ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) de las iteraciones de SHISHUA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignamos una parte del estado a otro estado, y la otra parte a la salida.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La asignaci√≥n de un resultado de salida aumenta la dispersi√≥n del estado. </font><font style="vertical-align: inherit;">Durante la inicializaci√≥n, el trabajo adicional y la correlaci√≥n de estados no importa, porque esta serie de operaciones se realiza una vez. </font><font style="vertical-align: inherit;">Solo estamos interesados ‚Äã‚Äãen la dispersi√≥n durante la inicializaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de evaluar el efecto sobre la correlaci√≥n de los valores iniciales, eleg√≠ </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">para el </font><font style="vertical-align: inherit;">valor y </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">10. Calcul√© la correlaci√≥n calculando las anomal√≠as "inusuales" y "sospechosas" que surgen de la herramienta de control de calidad PRNG en PractRand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es dif√≠cil medir la velocidad por varias razones:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La medici√≥n del reloj</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede no ser lo suficientemente precisa.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uso la instrucci√≥n del procesador RDTSC, que calcula el n√∫mero de ciclos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que cualquiera pueda reproducir mis resultados, uso una m√°quina virtual basada en la nube. Esto no cambia el nivel de los resultados de referencia en comparaci√≥n con las pruebas locales. Adem√°s, no tiene que comprar la misma computadora que la m√≠a. Finalmente, hay muchas situaciones en las que el PRNG se lanza en las nubes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eleg√≠ Google Cloud Platform N2 (procesador Intel) y N2D (procesador AMD). La ventaja de GCP es que ofrecen servidores con procesadores de ambos fabricantes. En este art√≠culo, nos centraremos en Intel, pero para AMD los resultados estar√°n en el mismo orden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para profundizar en el tema, primero eliminemos el antiguo generador criptogr√°fico RC4. Incapaz de paralelizar el trabajo, obtuve</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ciclos por byte generado). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecutemos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un MCG muy popular y r√°pido: el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Lehmer128 PRNG m√°s simple</font></a><font style="vertical-align: inherit;"> , que pasa la prueba BigCrush, mostr√≥ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ¬°Wow asombroso! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego ejecutaremos el √∫ltimo desarrollo, que se utiliza para tablas hash r√°pidas: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un poco mejor! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos PRSP no pasan la prueba PractRand de 32 terabytes, pero funcionan muy r√°pidamente. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alcanz√≥ solo 512 mebibytes, pero mostr√≥ una velocidad muy alta: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro desarrollo reciente de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ella dice ser la PRNG m√°s r√°pida del mundo: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, eso es suficiente. </font><font style="vertical-align: inherit;">¬øQu√© mostr√≥ semi-SHISHUA? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dos veces m√°s r√°pido que RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frio. </font><font style="vertical-align: inherit;">Ahora pruebe el generador criptogr√°fico ChaCha8. </font><font style="vertical-align: inherit;">Alcanz√≥ ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD es verdadera magia! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para la comunidad criptogr√°fica, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esto no fue una sorpresa especial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 es extremadamente f√°cil de paralelizar. </font><font style="vertical-align: inherit;">Esto es solo un contador bien hash en un estado difuso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øY recuerda c√≥mo el equipo de lenguaje de Julia intent√≥ combinar varias instancias de la arquitectura de Vigny para crear un PRNG r√°pido basado en SIMD? </font><font style="vertical-align: inherit;">Veamos su resultado usando esta t√©cnica ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 piezas de Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
T√©cnicamente, mi computadora port√°til podr√≠a afectar los resultados. No estoy seguro de por qu√© el desarrollo del equipo de Julia es m√°s r√°pido que ChaCha8 en GCP, pero m√°s lento cuando se prueba localmente. En mi m√°quina, semi-SHISHUA funciona m√°s r√°pido que el desarrollo del equipo de Julia, pero m√°s lento que ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es necesario derrotar a todos los competidores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente ya se est√© preguntando por qu√© llamamos a la versi√≥n anterior del generador semi-SHISHUA. Porque result√≥ f√°cil duplicar la velocidad si ejecuta dos copias de semi-SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Similar a la idea del comando Julia, inicializamos por separado dos PRNG (cuatro bloques de un estado de 256 bits), suministrando alternativamente la salida de su trabajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero si hacemos m√°s estados, entonces podemos producir a√∫n m√°s datos, combinando cuatro estados en pares:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces obtuvimos SHISHUA, que mostr√≥ una velocidad de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.06 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es dos veces m√°s r√°pido que el competidor m√°s r√°pido anterior en el mundo, que pas√≥ la prueba PractRand de 32 terabytes. </font><font style="vertical-align: inherit;">El resultado est√° en el gr√°fico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que el desarrollo result√≥ ser competitivo. </font><font style="vertical-align: inherit;">Funciona a√∫n m√°s r√°pido en mi computadora port√°til: 0.03 cpb, pero cumplir√© con mis principios con respecto al punto de referencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que por unas semanas m√°s mi generador se mantenga en el podio de los m√°s r√°pidos del mundo (por favor h√°galo).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calidad</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El generador honestamente pasa BigCrush y la prueba PractRand de 32 terabytes. Y todo gracias a cuatro flujos de salida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las desventajas de la arquitectura incluyen su </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreversibilidad</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto se puede ver reduciendo a un estado de 4 bits con </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Con un cambio, obtenemos </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y con agitaci√≥n, </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nuevo </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igual </font></font><code>[b, c] + [0, a] = [b‚äï(a‚àßc), a‚äïc]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igual </font></font><code>[d, a] + [0, c] = [d‚äï(a‚àßc), a‚äïc]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si </font></font><code>a = ¬¨c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces, </font></font><code>a‚äïc = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>a‚àßc = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por lo tanto, </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es decir, obtenemos dos combinaciones de </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nos dan el mismo estado final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, esto no es un problema, porque el contador de 64 bits tambi√©n es parte del estado. Resulta el ciclo m√≠nimo de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes (128 bytes por transici√≥n de estado), que es a una velocidad de 10 gibytes / seg. </font><font style="vertical-align: inherit;">durar√° siete mil a√±os. </font><font style="vertical-align: inherit;">Esto equilibra los estados perdidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, incluso a pesar de la irreversibilidad, el per√≠odo de transici√≥n promedio entre estados es 2 ^ ((256 + 1) √∑ 2). </font><font style="vertical-align: inherit;">Esto proporciona un ciclo promedio de </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes (a una velocidad de 10 gibytes / seg. Durar√° m√°s de un bill√≥n de veces m√°s de lo que existe el universo). </font><font style="vertical-align: inherit;">Aunque creo que los ciclos intermedios est√°n sobreestimados, porque no nos dicen nada sobre la calidad del generador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√°n los resultados de referencia:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generador</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuaci√≥n</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calidad</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlaci√≥n de semillas</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el n√∫mero de ciclos de procesador gastados en un byte generado. </font><font style="vertical-align: inherit;">Recibido en m√°quinas en la nube N2 GCP y N2D (AMD), el orden es el mismo.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calidad</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el nivel en el que el generador no pasa la prueba PractRand. </font><font style="vertical-align: inherit;">Si no falla, hay un signo&gt;. </font><font style="vertical-align: inherit;">Si no se prueba el resultado, hay un signo de interrogaci√≥n.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlaci√≥n de n√∫meros semilla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : PractRand transversal con bytes alternos de ocho flujos con semillas n√∫mero 0, 1, 2, 4, 8, 16, 32, 64. Utilizamos PractRand con doble convoluci√≥n y pruebas avanzadas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s lejos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque en nuestro caso no hay problemas con la irreversibilidad, a√∫n podemos mejorar SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mi opini√≥n, el PRNG ideal tiene las siguientes propiedades:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    ¬´¬ª (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La inicializaci√≥n del estado tiene una dispersi√≥n perfecta</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : todos los bits del n√∫mero inicial afectan a todos los bits del estado con la misma probabilidad. </font><font style="vertical-align: inherit;">Quiero averiguar en relaci√≥n con SHISHUA.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los problemas que frena el desarrollo de los PRNG y la criptograf√≠a en su conjunto es la falta de mejores herramientas de uso general. </font><font style="vertical-align: inherit;">Necesito una herramienta que pueda darme inmediatamente el resultado exacto de la medici√≥n para poder comparar diferentes arquitecturas sobre la marcha. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, PractRand es excelente en comparaci√≥n con lo que era antes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No permite evaluar generadores de alta calidad, por lo que es imposible compararlos entre s√≠. </font><font style="vertical-align: inherit;">Tenemos que decir: "bueno, despu√©s de 32 terabytes no tienen anomal√≠as ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lleva semanas ejecutarlo ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que la situaci√≥n mejore mucho pronto.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es498332/index.html">Implementaci√≥n de la arquitectura de seguridad de confianza cero: segunda edici√≥n</a></li>
<li><a href="../es498334/index.html">C√≥mo organizar el proceso de planificaci√≥n en SAP Analytics Cloud</a></li>
<li><a href="../es498340/index.html">Sobre el nuevo IDA Home (revisi√≥n)</a></li>
<li><a href="../es498346/index.html">GoLand 2020.1: soporte mejorado para m√≥dulos Go, mucha autocompletaci√≥n y mucho m√°s</a></li>
<li><a href="../es498350/index.html">Los mejores materiales para entrevistas de trabajo y b√∫squedas de trabajo.</a></li>
<li><a href="../es498354/index.html">C√≥mo traducir "Lista de deseos" en "hardware", o semi-escritorio semi-m√≥vil semi-ideal</a></li>
<li><a href="../es498358/index.html">Aprenda franc√©s o c√≥mo obtener un adaptador universal de un esc√°ner de diagn√≥stico PSA</a></li>
<li><a href="../es498360/index.html">Evaluaci√≥n integrada de m√©tricas de carga del servidor</a></li>
<li><a href="../es498362/index.html">Kingston mantiene el liderazgo en env√≠os SSD: ¬øc√≥mo lo hacemos?</a></li>
<li><a href="../es498368/index.html">La historia de un interruptor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>