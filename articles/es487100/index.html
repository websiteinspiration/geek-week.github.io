<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§î üë• ‚ú® Estructuras de datos inmutables de √∫ltima generaci√≥n. üë®üèø üé® üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante a√±os, los expertos en C ++ han estado discutiendo la sem√°ntica de los valores, la inmutabilidad y el intercambio de recursos a trav√©s de la co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Estructuras de datos inmutables de √∫ltima generaci√≥n.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante a√±os, los expertos en C ++ han estado discutiendo la sem√°ntica de los valores, la inmutabilidad y el intercambio de recursos a trav√©s de la comunicaci√≥n. </font><font style="vertical-align: inherit;">Sobre un mundo nuevo sin mutexes y razas, sin patrones de Command y Observer. </font><font style="vertical-align: inherit;">De hecho, no todo es tan simple. </font><font style="vertical-align: inherit;">El principal problema a√∫n est√° en nuestras estructuras de datos.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las estructuras de datos inmutables no cambian sus valores. Para hacer algo con ellos, necesita crear nuevos valores. Los valores antiguos permanecen en el mismo lugar, por lo que pueden leerse desde diferentes flujos sin problemas y bloqueos. Como resultado, los recursos se pueden compartir de manera m√°s racional y ordenada, porque los valores antiguos y nuevos pueden usar datos comunes. Gracias a esto, son mucho m√°s r√°pidos de comparar entre s√≠ y almacenan de forma compacta el historial de operaciones con la posibilidad de cancelaci√≥n. Todo esto encaja perfectamente en sistemas multihilo e interactivos: tales estructuras de datos simplifican la arquitectura de las aplicaciones de escritorio y permiten que los servicios se escalen mejor. Las estructuras inmutables son el secreto del √©xito de Clojure y Scala, e incluso la comunidad JavaScript ahora las aprovecha, porque tienen la biblioteca Immutable.js,escrito en las entra√±as de la empresa Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bajo el corte: video y traducci√≥n del informe </font><font style="vertical-align: inherit;">de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la conferencia C ++ Rusia 2019 Mosc√∫. </font><font style="vertical-align: inherit;">Juan habla de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , una biblioteca de estructuras inmutables para C ++. </font><font style="vertical-align: inherit;">En el post:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ventajas arquitect√≥nicas de la inmunidad;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creaci√≥n de un tipo de vector persistente efectivo basado en √°rboles RRB;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lisis de la arquitectura en el ejemplo de un editor de texto simple.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tragedia de la arquitectura basada en valores.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender la importancia de las estructuras de datos inmutables, discutimos la sem√°ntica de los valores. Esta es una caracter√≠stica muy importante de C ++, considero que es una de las principales ventajas de este lenguaje. Por todo esto, es muy dif√≠cil usar la sem√°ntica de valores como nos gustar√≠a. Creo que esta es la tragedia de la arquitectura basada en valores, y el camino a esta tragedia est√° pavimentado con buenas intenciones. Supongamos que necesitamos escribir software interactivo basado en un modelo de datos con una representaci√≥n de un documento editable por el usuario. Cuando la arquitectura basada en los valores en el seno de este modelo utiliza los tipos simples y convenientes de valores que ya existe en el lenguaje: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La l√≥gica de aplicaci√≥n se crea a partir de funciones que toman documentos por valor y devuelven una nueva versi√≥n de un documento por valor. Este documento puede cambiar dentro de la funci√≥n (como sucede a continuaci√≥n), pero la sem√°ntica de los valores en C ++, aplicada al argumento por valor y al tipo de retorno por valor, asegura que no haya efectos secundarios. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta caracter√≠stica es muy f√°cil de analizar y probar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como estamos trabajando con valores, intentaremos implementar la acci√≥n de deshacer. Esto puede ser dif√≠cil, pero con nuestro enfoque es una tarea trivial: tenemos </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con diferentes estados varias copias del documento.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tambi√©n tenemos una interfaz de usuario, y para garantizar su capacidad de respuesta, la asignaci√≥n de la interfaz de usuario debe realizarse en un hilo separado. El documento se env√≠a a otra secuencia por mensaje, y la interacci√≥n tambi√©n se realiza en funci√≥n de los mensajes, y no a trav√©s del uso compartido del estado </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cuando la segunda transmisi√≥n recibe la copia, all√≠ puede realizar todas las operaciones necesarias. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guardar un documento en el disco suele ser muy lento, especialmente si el documento es grande. Por lo tanto, el uso de </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta operaci√≥n se realiza de forma asincr√≥nica. Usamos una lambda, ponemos un signo igual dentro para tener una copia, y ahora puede guardar sin otros tipos primitivos de sincronizaci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, supongamos que tambi√©n tenemos un flujo de control de sonido. Como dije, trabaj√© mucho con el software de m√∫sica, y el sonido es otra representaci√≥n de nuestro documento, debe estar en una secuencia separada. Por lo tanto, tambi√©n se requiere una copia del documento para esta secuencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, obtuvimos un esquema muy hermoso, pero no demasiado realista. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Constantemente tiene que copiar documentos, el historial de acciones para la cancelaci√≥n toma gigabytes, y para cada representaci√≥n de la interfaz de usuario debe hacer una copia profunda del documento. En general, todas las interacciones son demasiado costosas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© est√° haciendo el desarrollador de C ++ en esta situaci√≥n? En lugar de aceptar un documento por valor, la l√≥gica de la aplicaci√≥n ahora acepta un enlace al documento y lo actualiza si es necesario. En este caso, no necesita devolver nada. Pero ahora no estamos tratando con valores, sino con objetos y ubicaciones. Esto crea nuevos problemas: si hay un enlace al estado con acceso compartido, lo necesita </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto es extremadamente costoso, por lo que habr√° alguna representaci√≥n de nuestra interfaz de usuario en forma de un √°rbol extremadamente complejo de varios Widgets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos estos elementos deben recibir actualizaciones cuando cambia un documento, por lo que se necesita alg√∫n mecanismo de cola para las se√±ales de cambio. Adem√°s, la historia del documento ya no es un conjunto de estados; ser√° una implementaci√≥n del patr√≥n de Equipo. La operaci√≥n debe implementarse dos veces, en una direcci√≥n y en la otra, y asegurarse de que todo sea sim√©trico. Guardar en un hilo separado ya es demasiado dif√≠cil, por lo que habr√° que abandonarlo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los usuarios ya est√°n acostumbrados a la imagen del reloj de arena, por lo que est√° bien si esperan un poco. Otra cosa es aterradora: el monstruo de la pasta ahora rige nuestro c√≥digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øEn qu√© punto todo fue cuesta abajo? </font><font style="vertical-align: inherit;">Dise√±amos nuestro c√≥digo muy bien, y luego tuvimos que comprometernos debido a la copia. </font><font style="vertical-align: inherit;">Pero en C ++, se requiere copiar para pasar por valor solo para datos mutables. </font><font style="vertical-align: inherit;">Si el objeto es inmutable, entonces el operador de asignaci√≥n puede implementarse para que solo copie el puntero a la representaci√≥n interna y nada m√°s.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere una estructura de datos que podr√≠a ayudarnos. </font><font style="vertical-align: inherit;">En el siguiente vector, todos los m√©todos est√°n marcados como </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que es inmutable. </font><font style="vertical-align: inherit;">En la ejecuci√≥n </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el vector no se actualiza; en cambio, se devuelve un nuevo vector al que se agregan los datos transferidos. </font><font style="vertical-align: inherit;">Desafortunadamente, no podemos usar corchetes con este enfoque debido a c√≥mo se definen. </font><font style="vertical-align: inherit;">En cambio, puedes usar la funci√≥n</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelve una nueva versi√≥n con un elemento actualizado. Nuestra estructura de datos ahora tiene una propiedad que se llama persistencia en la programaci√≥n funcional. No significa que guardemos esta estructura de datos en el disco duro, sino el hecho de que cuando se actualiza, el contenido anterior no se elimina; en cambio, se crea una nueva bifurcaci√≥n de nuestro mundo, es decir, la estructura. Gracias a esto, podemos comparar los valores pasados ‚Äã‚Äãcon el presente; esto se hace con la ayuda de dos </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los cambios ahora se pueden verificar directamente, ya no son propiedades ocultas de la estructura de datos. Esta caracter√≠stica es especialmente valiosa en sistemas interactivos donde constantemente tenemos que cambiar los datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra propiedad importante es el intercambio estructural. Ahora no estamos copiando todos los datos para cada nueva versi√≥n de la estructura de datos. Incluso con </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No todos los datos se copian, pero solo una peque√±a parte de ellos. Todos nuestros tenedores tienen acceso com√∫n a una vista compacta, que es proporcional al n√∫mero de cambios, no al n√∫mero de copias. Tambi√©n se deduce que la comparaci√≥n es muy r√°pida: si todo se almacena en un bloque de memoria, en un puntero, simplemente puede comparar los punteros y no examinar los elementos que est√°n dentro de ellos, si son iguales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que este vector, me parece, es extremadamente √∫til, lo implement√© en una biblioteca separada: esto es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , una biblioteca de estructuras inmutables, un proyecto de c√≥digo abierto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al escribirlo, quer√≠a que su uso fuera familiar para los desarrolladores de C ++. </font><font style="vertical-align: inherit;">Hay muchas bibliotecas que implementan los conceptos de programaci√≥n funcional en C ++, pero da la impresi√≥n de que los desarrolladores escriben para Haskell y no para C ++. </font><font style="vertical-align: inherit;">Esto crea inconvenientes. </font><font style="vertical-align: inherit;">Adem√°s, logr√© un buen rendimiento. </font><font style="vertical-align: inherit;">Las personas usan C ++ cuando los recursos disponibles son limitados. </font><font style="vertical-align: inherit;">Finalmente, quer√≠a que la biblioteca fuera personalizable. </font><font style="vertical-align: inherit;">Este requisito est√° relacionado con el requisito de rendimiento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En busca de un vector m√°gico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la segunda parte del informe, consideraremos c√≥mo se estructura este vector inmutable. La forma m√°s f√°cil de comprender los principios de dicha estructura de datos es comenzando con una lista regular. Si est√° un poco familiarizado con la programaci√≥n funcional (usando Lisp o Haskell como ejemplo), sabe que las listas son las estructuras de datos inmutables m√°s comunes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, supongamos que tenemos una lista con un solo nodo </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al agregar nuevos elementos a la parte superior de la lista, se crean nuevos nodos, cada uno de los cuales tiene un puntero a un nodo existente. Por lo tanto, en el ejemplo de la diapositiva, tenemos no tres copias de una lista, sino tres elementos en la memoria, es decir, </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indican diferentes elementos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n podemos crear una bifurcaci√≥n de la realidad, es decir, crear una nueva lista que tenga el mismo final, pero un comienzo diferente.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dichas estructuras de datos se han estudiado durante mucho tiempo: Chris Okasaki escribi√≥ el trabajo fundamental de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructuras de datos puramente funcionales</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Adem√°s, la estructura de datos de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> propuesta por Ralf Hinze y Ross Paterson es muy interesante </font><font style="vertical-align: inherit;">. Pero para C ++, tales estructuras de datos no funcionan bien. Usan nodos peque√±os, y sabemos que en C ++ los nodos peque√±os significan una falta de eficiencia de almacenamiento en cach√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, a menudo se basan en propiedades que C ++ no tiene, como la pereza. Por lo tanto, el trabajo de Phil Bagwell sobre estructuras de datos inmutables es mucho m√°s √∫til para nosotros: un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito a principios de la d√©cada de 2000, as√≠ como el trabajo de Rich Hickey: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, autor de Clojure. Rich Hickey cre√≥ una lista, que en realidad no es una lista, sino que se basa en estructuras de datos modernas: vectores y mapas hash. Estas estructuras de datos tienen eficiencia de almacenamiento en cach√© e interact√∫an bien con los procesadores modernos, por lo que no es deseable trabajar con nodos peque√±os. Dichas estructuras se pueden usar en C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo construir un vector inmune? En el coraz√≥n de cualquier estructura, incluso remotamente parecida a un vector, debe haber una matriz. Pero la matriz no tiene intercambio estructural. Para cambiar cualquier elemento de la matriz, sin perder la propiedad de persistencia, debe copiar la matriz completa. Para no hacer esto, la matriz se puede dividir en partes separadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, al actualizar un elemento vectorial, necesitamos copiar solo una pieza, y no todo el vector. Pero esas piezas en s√≠ mismas no son una estructura de datos; deben combinarse de una forma u otra. P√≥ngalos en otra matriz. Una vez m√°s, surge el problema de que la matriz puede ser muy grande, y luego copiarla nuevamente tomar√° demasiado tiempo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividimos esta matriz en partes, las colocamos nuevamente en una matriz separada y repetimos este procedimiento hasta que solo haya una matriz ra√≠z. La estructura resultante se llama √°rbol residual. Este √°rbol se describe por la constante M = 2B, es decir, el factor de ramificaci√≥n. Este indicador de rama debe ser una potencia de dos, y muy pronto descubriremos por qu√©. En el ejemplo de la diapositiva, se usan bloques de cuatro caracteres, pero en la pr√°ctica, se usan bloques de 32 caracteres. Hay experimentos con los que puede encontrar el tama√±o de bloque √≥ptimo para una arquitectura en particular. Esto le permite lograr la mejor proporci√≥n de acceso estructural compartido al tiempo de acceso: cuanto m√°s bajo sea el √°rbol, menor ser√° el tiempo de acceso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al leer esto, los desarrolladores que escriben en C ++ probablemente piensen: ¬°pero las estructuras basadas en √°rboles son muy lentas! Los √°rboles crecen con un aumento en el n√∫mero de elementos en ellos, y debido a esto, los tiempos de acceso se degradan. Es por eso que los programadores prefieren </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en lugar de </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Me apresuro a tranquilizarte: nuestro √°rbol crece muy lentamente. Un vector que contiene todos los valores posibles de un int de 32 bits tiene solo 7 niveles de altura. Se puede demostrar experimentalmente que con este tama√±o de datos, la relaci√≥n de la memoria cach√© al volumen de carga afecta significativamente el rendimiento que la profundidad del √°rbol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo se realiza el acceso a un elemento de un √°rbol. Suponga que necesita pasar al elemento 17. Tomamos una representaci√≥n binaria del √≠ndice y la dividimos en grupos del tama√±o de un factor de ramificaci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cada grupo, usamos el valor binario correspondiente y, por lo tanto, bajamos del √°rbol. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, supongamos que necesitamos hacer un cambio en esta estructura de datos, es decir, ejecutar el m√©todo </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, primero debe copiar el bloque en el que se encuentra el elemento y luego copiar cada nodo interno en el camino hacia el elemento. Por un lado, se debe copiar una gran cantidad de datos, pero al mismo tiempo una parte importante de estos datos es com√∫n, lo que compensa su volumen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, hay una estructura de datos mucho m√°s antigua que es muy similar a la que describ√≠. Estas son p√°ginas de memoria con un √°rbol de tabla de p√°ginas. Su gesti√≥n tambi√©n se lleva a cabo mediante una llamada </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentemos mejorar nuestra estructura de datos. Supongamos que necesitamos conectar dos vectores. La estructura de datos descrita hasta ahora tiene las mismas limitaciones </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que tiene celdas vac√≠as en su parte m√°s a la derecha. Dado que la estructura est√° perfectamente equilibrada, estas celdas vac√≠as no pueden estar en el medio del √°rbol. Por lo tanto, si hay un segundo vector que queremos combinar con el primero, necesitaremos copiar los elementos en celdas vac√≠as, lo que crear√° celdas vac√≠as en el segundo vector, y al final tendremos que copiar todo el segundo vector. Tal operaci√≥n tiene una complejidad computacional O (n), donde n es el tama√±o del segundo vector.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentaremos lograr un mejor resultado. Hay una versi√≥n modificada de nuestra estructura de datos llamada √°rbol equilibrado de radix relajado. En esta estructura, los nodos que no est√°n en el camino de la izquierda pueden tener celdas vac√≠as. Por lo tanto, en tales nodos incompletos (o relajados), es necesario calcular el tama√±o del sub√°rbol. Ahora puede realizar una operaci√≥n de uni√≥n compleja pero logar√≠tmica. Esta operaci√≥n de complejidad de tiempo constante es O (log (32)). Como los √°rboles son poco profundos, el tiempo de acceso es constante, aunque relativamente largo. Debido al hecho de que tenemos una operaci√≥n de uni√≥n de este tipo, una versi√≥n relajada de esta estructura de datos se denomina confluente: adem√°s de ser persistente, y se puede bifurcar, dos de estas estructuras se pueden combinar en una.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo con el que hemos trabajado hasta ahora, la estructura de datos es muy clara, pero en la pr√°ctica, las implementaciones en Clojure y otros lenguajes funcionales se ven diferentes. Crean contenedores para cada valor, es decir, cada elemento en el vector est√° en una celda separada, y los nodos de hoja contienen punteros a estos elementos. Pero este enfoque es extremadamente ineficiente, en C ++ generalmente no pone todos los valores en un contenedor. Por lo tanto, ser√≠a mejor si estos elementos se ubican en nodos directamente. Entonces surge otro problema: diferentes elementos tienen diferentes tama√±os. Si el elemento tiene el mismo tama√±o que el puntero, nuestra estructura se ver√° como la que se muestra a continuaci√≥n:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero si los elementos son grandes, entonces la estructura de datos pierde las propiedades que medimos (tiempo de acceso O (log (32) ()), porque copiar una de las hojas ahora lleva m√°s tiempo. Por lo tanto, cambi√© esta estructura de datos para que a medida que aumenta el tama√±o el n√∫mero de elementos contenidos en √©l disminuy√≥ el n√∫mero de estos elementos en los nodos de la hoja. Por el contrario, si los elementos son peque√±os, ahora pueden caber m√°s. La nueva versi√≥n del √°rbol se llama √°rbol de incrustaci√≥n radix balanceado. No se describe por una constante, sino por dos: uno de ellos describe nodos internos y el segundo - frondoso. La implementaci√≥n del √°rbol en C ++ puede calcular el tama√±o √≥ptimo del elemento de la hoja dependiendo del tama√±o de los punteros y de los elementos mismos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro √°rbol ya est√° funcionando bastante bien, pero a√∫n se puede mejorar. Eche un vistazo a una funci√≥n similar a una funci√≥n </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toma una entrada </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se ejecuta </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al final del vector para cada n√∫mero entero entre </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y devuelve lo que sucedi√≥. Todo est√° en orden con la correcci√≥n de esta funci√≥n, pero funciona de manera ineficiente. Cada llamada </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copia el bloque m√°s a la izquierda innecesariamente: la siguiente llamada empuja otro elemento y la copia se repite nuevamente, y los datos copiados por el m√©todo anterior se eliminan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede probar otra implementaci√≥n de esta funci√≥n, en la que abandonamos la persistencia dentro de la funci√≥n. Se puede usar </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con una API mutable que sea compatible con la API normal </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dentro de dicha funci√≥n, cada llamada </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambia la estructura de datos.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta implementaci√≥n es m√°s eficiente y le permite reutilizar nuevos elementos en el camino correcto. Al final de la funci√≥n, se realiza una llamada </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelve inmutable </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Los posibles efectos secundarios permanecen invisibles desde fuera de la funci√≥n. El original </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">era y sigue siendo inmutable, solo se cambian los datos creados dentro de la funci√≥n. Como dije, una ventaja importante de este enfoque es que puede usar </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos est√°ndar que requieren API mutables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere otro ejemplo.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n no acepta y regresa </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero dentro se ejecuta una cadena de llamadas </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aqu√≠, como en el ejemplo anterior, puede ocurrir una copia innecesaria dentro de la llamada </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tenga en cuenta que el primer valor que se ejecuta </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el valor con nombre, y el resto es el valor r, es decir, enlaces an√≥nimos. Si utiliza el recuento de referencias, el m√©todo </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede referirse a los contadores de referencia para los nodos para los que se asigna memoria en el √°rbol. Y en el caso del valor r, si el n√∫mero de enlaces es uno, queda claro que ninguna otra parte del programa accede a estos nodos. Aqu√≠ el rendimiento es exactamente el mismo que en el caso con </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ‚üµ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, para ayudar al compilador, podemos ejecutarlo </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se usa en ning√∫n otro lugar de la funci√≥n. Ten√≠amos una ventaja importante, que no estaba en la </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variante: si pasamos el valor devuelto de otro say_hi a la funci√≥n say_hi, entonces no habr√° copias adicionales. En el caso de c, </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existen l√≠mites en los que puede producirse un exceso de copia. En otras palabras, tenemos una estructura de datos persistente e inmutable, cuyo rendimiento depende de la cantidad real de acceso compartido en tiempo de ejecuci√≥n. Si no se comparte, el rendimiento ser√° el mismo que el de una estructura de datos mutable. Esta es una propiedad extremadamente importante. El ejemplo que ya te mostr√© arriba puede reescribirse con un m√©todo </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta ahora hemos hablado de vectores, y adem√°s de ellos tambi√©n hay mapas hash. Est√°n dedicados a un informe muy √∫til de Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El Santo Grial. Una matriz hash mapeada trie para C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Describe tablas hash implementadas en base a los mismos principios de los que acabo de hablar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estoy seguro de que muchos de ustedes tienen dudas sobre el desempe√±o de tales estructuras. ¬øTrabajan r√°pidamente en la pr√°ctica? He hecho muchas pruebas y, en resumen, mi respuesta es s√≠. Si desea obtener m√°s informaci√≥n sobre los resultados de las pruebas, se publican en mi art√≠culo para la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conferencia Internacional de Programaci√≥n Funcional 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ahora, creo, es mejor discutir no los valores absolutos, sino el efecto que esta estructura de datos tiene en el sistema en su conjunto. </font><font style="vertical-align: inherit;">Por supuesto, la actualizaci√≥n de nuestro vector es m√°s lenta porque necesita copiar varios bloques de datos y asignar memoria para otros datos. </font><font style="vertical-align: inherit;">Pero eludir nuestro vector se realiza casi a la misma velocidad que uno normal. </font><font style="vertical-align: inherit;">Fue muy importante para m√≠ lograr esto, ya que la lectura de datos se realiza con mucha m√°s frecuencia que el cambio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, debido a la actualizaci√≥n m√°s lenta, no es necesario copiar nada, solo se copia la estructura de datos. </font><font style="vertical-align: inherit;">Por lo tanto, el tiempo dedicado a actualizar el vector se amortiza, por as√≠ decirlo, para todas las copias realizadas en el sistema. </font><font style="vertical-align: inherit;">Por lo tanto, si aplica esta estructura de datos en una arquitectura similar a la que describ√≠ al comienzo del informe, el rendimiento aumentar√° significativamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No ser√© infundado y demostrar√© mi estructura de datos usando un ejemplo. </font><font style="vertical-align: inherit;">Escrib√≠ un peque√±o editor de texto. </font><font style="vertical-align: inherit;">Esta es una herramienta interactiva llamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en la que los documentos est√°n representados por vectores inmutables. </font><font style="vertical-align: inherit;">Tengo una copia de toda la Wikipedia en esperanto guardada en mi disco, pesa 1 gigabyte (al principio quer√≠a descargar la versi√≥n en ingl√©s, pero es demasiado grande). </font><font style="vertical-align: inherit;">Independientemente del editor de texto que utilice, estoy seguro de que no le gustar√° este archivo. </font><font style="vertical-align: inherit;">Y cuando descargue este archivo en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puede editarlo de inmediato, porque la descarga es as√≠ncrona. </font><font style="vertical-align: inherit;">La navegaci√≥n de archivos funciona, nada se cuelga, no </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no hay sincronizaci√≥n. </font><font style="vertical-align: inherit;">Como puede ver, el archivo descargado toma 20 millones de l√≠neas de c√≥digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de considerar las propiedades m√°s importantes de esta herramienta, prestemos atenci√≥n a un detalle divertido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comienzo de la l√≠nea, resaltada en blanco en la parte inferior de la imagen, ver√° dos guiones. Es muy probable que esta IU sea familiar para los usuarios de emacs; los guiones all√≠ significan que el documento no se ha modificado de ninguna manera. Si realiza alg√∫n cambio, se muestran asteriscos en lugar de guiones. Pero, a diferencia de otros editores, si </font><font style="vertical-align: inherit;">elimina estos cambios </font><font style="vertical-align: inherit;">en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (no lo deshaga, simplemente elim√≠nelo), aparecer√°n nuevamente guiones en lugar de asteriscos, ya que </font><font style="vertical-align: inherit;">todas las versiones anteriores del texto se guardan </font><font style="vertical-align: inherit;">en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gracias a esto, no se necesita un indicador especial para mostrar si el documento ha sido modificado: la presencia de cambios se determina en comparaci√≥n con el documento original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere otra propiedad interesante de la herramienta: copie todo el texto y p√©guelo un par de veces en el medio del texto existente. </font><font style="vertical-align: inherit;">Como puede ver, esto sucede al instante. </font><font style="vertical-align: inherit;">Unir vectores aqu√≠ es una operaci√≥n logar√≠tmica, y el logaritmo de varios millones no es una operaci√≥n tan larga. </font><font style="vertical-align: inherit;">Si intenta guardar este documento enorme en su disco duro, tomar√° mucho m√°s tiempo, ya que el texto ya no se presenta como un vector obtenido de la versi√≥n anterior de este vector. </font><font style="vertical-align: inherit;">Al guardar en el disco, se produce la serializaci√≥n, por lo que se pierde la persistencia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regresar a la arquitectura basada en valores</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos por c√≥mo no puede volver a esta arquitectura: usando el controlador, el modelo y la vista habituales de estilo Java, que se usan con mayor frecuencia para aplicaciones interactivas en C ++. No hay nada malo con ellos, pero no son adecuados para nuestro problema. Por un lado, el patr√≥n Modelo-Vista-Controlador permite la separaci√≥n de tareas, pero por otro lado, cada uno de estos elementos es un objeto, tanto desde un punto de vista orientado a objetos como desde el punto de vista de C ++, es decir, estas son √°reas de memoria con mutable condici√≥n. Ver sabe sobre Modelo; lo que es mucho peor: el Modelo sabe indirectamente acerca de la Vista, porque es casi seguro que hay una devoluci√≥n de llamada a trav√©s de la cual se le notifica a la Vista cuando cambia el Modelo. Incluso con la mejor implementaci√≥n de principios orientados a objetos, tenemos muchas dependencias mutuas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A medida que la aplicaci√≥n crece y se agregan nuevos modelos, controladores y vistas, surge una situaci√≥n en la que, para cambiar un segmento del programa, debe conocer todas las partes asociadas, todas las vistas que reciben alertas </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. Como resultado, todos el familiar monstruo de la pasta comienza a mirar a trav√©s de estas dependencias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øEs posible otra arquitectura? Existe un enfoque alternativo para el patr√≥n Modelo-Vista-Controlador denominado "Arquitectura de flujo de datos unidireccional". Este concepto no fue inventado por m√≠, se usa con bastante frecuencia en el desarrollo web. En Facebook, esto se llama la arquitectura Flux, pero en C ++, a√∫n no se aplica.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los elementos de dicha arquitectura ya nos son familiares: Acci√≥n, Modelo y Vista, pero el significado de bloques y flechas es diferente. Los bloques son valores, no objetos y no regiones con estados mutables. Esto se aplica incluso a Ver. Adem√°s, las flechas no son enlaces, porque sin objetos no puede haber enlaces. Aqu√≠ las flechas son funciones. Entre Acci√≥n y Modelo, hay una funci√≥n de actualizaci√≥n que acepta el Modelo actual, es decir, el estado actual del mundo, y Acci√≥n, que es una representaci√≥n de un evento, por ejemplo, un clic del mouse o un evento de otro nivel de abstracci√≥n, por ejemplo, la inserci√≥n de un elemento o s√≠mbolo en un documento. La funci√≥n de actualizaci√≥n actualiza el documento y devuelve el nuevo estado del mundo. El modelo se conecta al renderizado de la funci√≥n Ver, que toma el Modelo y devuelve la vista. Esto requiere un marco en el que la vista se pueda representar como valores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el desarrollo web, React hace esto, pero en C ++ todav√≠a no hay nada igual, aunque qui√©n sabe, si hay personas que quieren pagarme para escribir algo como esto, puede aparecer pronto. Mientras tanto, puede usar la API del modo Inmediato, en la que la funci√≥n de dibujo le permite crear un valor como efecto secundario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, la Vista debe tener un mecanismo que permita al usuario u otras fuentes de eventos enviar Acci√≥n. Hay una manera f√°cil de implementar esto, se presenta a continuaci√≥n:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la excepci√≥n de guardar y cargar de forma asincr√≥nica, este es el c√≥digo que se utiliza en el editor que se acaba de presentar. Aqu√≠ hay un objeto </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le permite leer y escribir desde la l√≠nea de comandos. Adem√°s, </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este es el valor de Model, almacena todo el estado de la aplicaci√≥n. Como puede ver en la parte superior de la pantalla, hay una funci√≥n que devuelve una nueva versi√≥n </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El ciclo dentro de la funci√≥n se ejecuta hasta que la aplicaci√≥n necesita cerrarse, es decir, hasta </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En el bucle, se dibuja un nuevo estado, luego se solicita el siguiente evento. Finalmente, el estado se almacena en una variable local </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el ciclo comienza nuevamente. Este c√≥digo tiene una ventaja muy importante: solo existe una variable mutable durante la ejecuci√≥n del programa, es un objeto </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los desarrolladores de Clojure llaman a esta arquitectura de un solo √°tomo: hay un solo punto en toda la aplicaci√≥n a trav√©s del cual se realizan todos los cambios. </font><font style="vertical-align: inherit;">La l√≥gica de la aplicaci√≥n no participa en la actualizaci√≥n de este punto de ninguna manera; esto hace un ciclo especialmente dise√±ado para esto. </font><font style="vertical-align: inherit;">Gracias a esto, la l√≥gica de la aplicaci√≥n consiste completamente en funciones puras, como funciones </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con este enfoque para escribir aplicaciones, la forma de pensar sobre el software est√° cambiando. </font><font style="vertical-align: inherit;">El trabajo ahora comienza no con el diagrama UML de interfaces y operaciones, sino con los datos en s√≠. </font><font style="vertical-align: inherit;">Hay algunas similitudes con el dise√±o orientado a datos. </font><font style="vertical-align: inherit;">Es cierto que el dise√±o orientado a datos generalmente se usa para obtener el m√°ximo rendimiento, aqu√≠, adem√°s de la velocidad, nos esforzamos por la simplicidad y la correcci√≥n. </font><font style="vertical-align: inherit;">El √©nfasis es ligeramente diferente, pero existen importantes similitudes en la metodolog√≠a.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arriba est√°n los principales tipos de datos de nuestra aplicaci√≥n. El cuerpo principal de la aplicaci√≥n consta </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es flex_vector, y flex_vector es </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno para el que puede realizar una operaci√≥n de uni√≥n. El siguiente </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el vector en el que se almacena </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como puede ver, esta es una representaci√≥n muy simple del texto. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almacenado con la ayuda </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de los cuales tiene un nombre, es decir, una direcci√≥n en el sistema de archivos, y en realidad </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como se </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa otro tipo, un simple pero muy √∫til: </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es un contenedor de un solo elemento. Le permite poner en un mont√≥n y mover un objeto, copiando que puede ser demasiado intensivo en recursos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro tipo importante: </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seg√∫n este tipo, una funci√≥n de cancelaci√≥n est√° activa. Contiene un documento (en el formulario</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y posici√≥n del cursor (coord). Esto le permite devolver el cursor a la posici√≥n en la que estaba durante la edici√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente tipo es </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es un t√©rmino de vim y emacs, ya que los documentos abiertos se llaman all√≠. En </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay un archivo del que se descarg√≥ el texto, as√≠ como el contenido del texto - esto le permite comprobar los cambios en el documento. Para resaltar parte del texto, hay una variable opcional que </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica el comienzo de la selecci√≥n. El vector de </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es la historia del texto. Tenga en cuenta que no utilizamos el patr√≥n Equipo; el historial consta solo de estados. Finalmente, si la cancelaci√≥n se acaba de completar, necesitamos un √≠ndice de posici√≥n en el historial del estado </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente tipo: </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Contiene un documento abierto (b√∫fer) </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para atajos de teclado, as√≠ como un vector </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el portapapeles y otro vector para mensajes que se muestran en la parte inferior de la pantalla. </font><font style="vertical-align: inherit;">Hasta ahora, en la versi√≥n debut de la aplicaci√≥n, solo habr√° un hilo y un tipo de acci√≥n que tome entrada </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo m√°s probable es que muchos de ustedes ya est√©n pensando en c√≥mo implementar estas operaciones. </font><font style="vertical-align: inherit;">Si se toma por valor y se devuelve por valor, en la mayor√≠a de los casos las operaciones son bastante simples. </font><font style="vertical-align: inherit;">El c√≥digo de mi editor de texto est√° publicado en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , para que pueda ver c√≥mo se ve realmente. </font><font style="vertical-align: inherit;">Ahora me detendr√© en detalles solo en el c√≥digo que implementa la funci√≥n de cancelaci√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribir correctamente una cancelaci√≥n sin la infraestructura adecuada no es tan simple. En mi editor, lo implement√© siguiendo las l√≠neas de emacs, as√≠ que primero un par de palabras sobre sus principios b√°sicos. Aqu√≠ falta el comando de retorno y, gracias a esto, no puede perder el trabajo. Si es necesaria una devoluci√≥n, se realiza cualquier cambio en el texto, y luego todas las acciones de cancelaci√≥n vuelven a formar parte del historial de cancelaci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este principio se muestra arriba. El rombo rojo aqu√≠ muestra una posici√≥n en la historia: si una cancelaci√≥n no se ha completado, el rombo rojo siempre est√° al final. Si cancela, el diamante retroceder√° un estado, pero al mismo tiempo, se agregar√° otro estado al final de la cola, lo mismo que el usuario ve actualmente (S3). Si cancela nuevamente y regresa al estado S2, el estado S2 se agrega al final de la cola. Si ahora el usuario realiza alg√∫n tipo de cambio, se agregar√° al final de la cola como un nuevo estado de S5 y se mover√° un rombo a √©l. Ahora, al deshacer acciones pasadas, las acciones de deshacer anteriores se desplazar√°n primero. Para implementar dicho sistema de cancelaci√≥n, el siguiente c√≥digo es suficiente:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos acciones, </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizado durante cualquier operaci√≥n. Esto es muy conveniente ya que no necesitamos saber si se produjo alguna edici√≥n del documento. La funci√≥n es transparente a la l√≥gica de la aplicaci√≥n. Despu√©s de cualquier acci√≥n, la funci√≥n verifica si el documento ha cambiado. Si se ha producido un cambio, </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">ejecutan los </font><font style="vertical-align: inherit;">contenidos y la posici√≥n del cursor </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la acci√≥n no condujo a un cambio </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(es decir, la entrada recibida </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">causada por la acci√≥n cancelar), entonces </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se asigna un valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si es necesario </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo comprobamos </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si no tiene sentido, consideramos que </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√° al final de la historia. Si el historial de cancelaci√≥n no est√° vac√≠o (es decir,</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no al comienzo de la historia), se realiza la cancelaci√≥n. </font><font style="vertical-align: inherit;">El contenido actual y el cursor se reemplazan y cambian </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La irrevocabilidad de la operaci√≥n de deshacer se logra mediante la funci√≥n </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que tambi√©n se llama durante la operaci√≥n de deshacer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos una operaci√≥n </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que ocupa 10 l√≠neas de c√≥digo, y que sin cambios (o con cambios m√≠nimos) se puede usar en casi cualquier otra aplicaci√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viaje en el tiempo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobre el viaje en el tiempo. Como veremos ahora, este es un tema relacionado con la cancelaci√≥n. Demostrar√© el trabajo de un marco que agregar√° funcionalidades √∫tiles a cualquier aplicaci√≥n con una arquitectura similar. El marco aqu√≠ se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta versi√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> incluye algunas caracter√≠sticas de depuraci√≥n. Ahora desde el navegador puede abrir el depurador, en el que puede examinar el estado de la aplicaci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que la √∫ltima acci√≥n fue cambiar el tama√±o, porque abr√≠ una nueva ventana, y mi administrador de ventanas redimension√≥ autom√°ticamente la ventana ya abierta. Por supuesto, para la serializaci√≥n autom√°tica en JSON, tuve que agregar anotaciones para la estructura de la biblioteca especial de reflexi√≥n. Pero el resto del sistema es bastante universal, se puede conectar a cualquier aplicaci√≥n similar. Ahora en el navegador puede ver todas las acciones completadas. Por supuesto, hay un estado inicial que no tiene acci√≥n. Este es el estado anterior a la descarga. Adem√°s, al hacer doble clic puedo devolver la aplicaci√≥n a su estado anterior. Esta es una herramienta de depuraci√≥n muy √∫til que le permite rastrear la ocurrencia de un mal funcionamiento en la aplicaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si est√° interesado, puede escuchar mi informe sobre CPPCON 19, Los valores m√°s valiosos, all√≠ examinar√© este depurador en detalle. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, la arquitectura basada en el valor se discute con m√°s detalle all√≠. </font><font style="vertical-align: inherit;">En √©l, tambi√©n te digo c√≥mo implementar acciones y organizarlas jer√°rquicamente. </font><font style="vertical-align: inherit;">Esto asegura la modularidad del sistema y elimina la necesidad de mantener todo en una gran funci√≥n de actualizaci√≥n. </font><font style="vertical-align: inherit;">Adem√°s, ese informe habla sobre asincron√≠a y descargas de archivos multiproceso. </font><font style="vertical-align: inherit;">Existe otra versi√≥n de este informe en la que media hora de material adicional son estructuras de datos inmutables posmodernas.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que es hora de hacer un balance. Citar√© a Andy Wingo: es un excelente desarrollador, dedic√≥ mucho tiempo a V8 y a los compiladores en general, finalmente se dedica a apoyar a Guile, implementando Scheme for GNU. Recientemente, escribi√≥ en su Twitter: ‚ÄúPara lograr una ligera aceleraci√≥n del programa, medimos cada peque√±o cambio y dejamos solo aquellos que dan un resultado positivo. Y realmente logramos una aceleraci√≥n significativa, ciegamente, invirtiendo mucho esfuerzo, sin tener 100% de confianza y guiados solo por la intuici√≥n. Qu√© dicotom√≠a m√°s extra√±a.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me parece que los desarrolladores de C ++ est√°n teniendo √©xito en el primer g√©nero. </font><font style="vertical-align: inherit;">Danos un sistema cerrado y nosotros, armados con nuestras herramientas, exprimiremos todo lo que sea posible. </font><font style="vertical-align: inherit;">Pero en el segundo g√©nero no estamos acostumbrados a trabajar. </font><font style="vertical-align: inherit;">Por supuesto, el segundo enfoque es m√°s arriesgado y, a menudo, conduce a una p√©rdida de gran esfuerzo. </font><font style="vertical-align: inherit;">Por otro lado, al reescribir completamente un programa, a menudo se puede hacer m√°s f√°cil y m√°s r√°pido. </font><font style="vertical-align: inherit;">Espero haber logrado convencerte de que al menos intentes este segundo enfoque.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente habl√≥ en la conferencia C ++ Rusia 2019 Mosc√∫ y habl√≥ sobre las estructuras de datos que le permiten hacer cosas interesantes. </font><font style="vertical-align: inherit;">Parte de la magia de estas estructuras radica en la elisi√≥n de copia: esto es de lo que </font><font style="vertical-align: inherit;">Anton Polukhin y Roman Rusyaev </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hablar√°n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la pr√≥xima conferencia </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Siga las actualizaciones del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el sitio.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es487100/">https://habr.com/ru/post/es487100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es487090/index.html">Un nuevo nivel de optimizaci√≥n de Windows</a></li>
<li><a href="../es487092/index.html">Modelado de procesos comerciales como parte de un proyecto para implementar un sistema ERP</a></li>
<li><a href="../es487094/index.html">Reprocesamiento de eventos recibidos de Kafka</a></li>
<li><a href="../es487096/index.html">Fragmentos C√≥mo facilitar el proceso de trabajar con documentaci√≥n</a></li>
<li><a href="../es487098/index.html">Dibujar con hormigas: im√°genes de procedimiento utilizando algoritmos de optimizaci√≥n de colonias de hormigas</a></li>
<li><a href="../es487106/index.html">Analizador PVS-Studio RunUO check</a></li>
<li><a href="../es487108/index.html">Perfil de jugador m√≥vil: MyTracker Research</a></li>
<li><a href="../es487110/index.html">Slurm SRE. Un experimento completo con expertos de Booking.com y Google.com.</a></li>
<li><a href="../es487112/index.html">Edge of Madness: The Basic Circle</a></li>
<li><a href="../es487116/index.html">Por qu√© Discord migra de Go to Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>