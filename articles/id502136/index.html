<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕋 ♠️ 👊🏼 Kompresi data di Apache Ignite. Pengalaman Sberbank ☝️ 🔌 🙇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat bekerja dengan volume data yang besar, terkadang masalah ruang disk yang tidak mencukupi bisa menjadi akut. Salah satu cara untuk mengatasi masal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kompresi data di Apache Ignite. Pengalaman Sberbank</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/502136/"><img src="https://habrastorage.org/webt/cl/nj/sz/clnjsz90dmzkkj3wr4vuusu_-nu.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat bekerja dengan volume data yang besar, terkadang masalah ruang disk yang tidak mencukupi bisa menjadi akut. </font><font style="vertical-align: inherit;">Salah satu cara untuk mengatasi masalah ini adalah kompresi, karena itu, pada peralatan yang sama, Anda dapat meningkatkan volume penyimpanan. </font><font style="vertical-align: inherit;">Pada artikel ini, kita akan melihat bagaimana kompresi data bekerja di Apache Ignite. </font><font style="vertical-align: inherit;">Artikel ini hanya akan menjelaskan metode kompresi disk yang diterapkan dalam produk. </font><font style="vertical-align: inherit;">Metode kompresi data lainnya (melalui jaringan, dalam memori), baik yang diimplementasikan maupun tidak, akan tetap berada di luar cakupan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, ketika mode kegigihan aktif, sebagai akibat dari mengubah data dalam cache, Ignite mulai menulis ke disk:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konten Cache</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write Ahead Log (selanjutnya disebut WAL)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu mekanisme yang disebut pemadatan WAL telah ada sejak lama untuk mengkompres WAL. </font><font style="vertical-align: inherit;">Apache Ignite 2.8 baru-baru ini dirilis memperkenalkan dua mekanisme lagi untuk mengompresi data pada disk: kompresi halaman disk untuk mengompresi konten cache dan kompresi snapshot halaman WAL untuk mengompresi beberapa catatan WAL. </font><font style="vertical-align: inherit;">Lebih lanjut tentang ketiga mekanisme di bawah ini.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi halaman disk</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana itu bekerja</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memulainya, kita akan membahas secara singkat bagaimana Ignite menyimpan data. Untuk penyimpanan, memori halaman digunakan. Ukuran halaman diatur pada awal node dan tidak dapat diubah pada tahap selanjutnya, juga ukuran halaman harus kekuatan dua dan kelipatan dari ukuran blok sistem file. Halaman dimuat ke dalam RAM dari disk sesuai kebutuhan, ukuran data pada disk dapat melebihi jumlah RAM yang dialokasikan. Jika tidak ada cukup ruang dalam RAM untuk memuat halaman dari disk, halaman lama yang tidak digunakan akan dipaksa keluar dari RAM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data disimpan dalam disk dalam bentuk berikut: file terpisah dibuat untuk setiap partisi dari masing-masing grup cache, dalam file ini, dalam urutan indeks yang naik, halaman berjalan satu demi satu. Pengenal halaman penuh berisi pengidentifikasi grup cache, nomor partisi, dan indeks halaman dalam file. Dengan demikian, dengan pengidentifikasi halaman penuh, kami dapat secara unik mengidentifikasi file dan mengimbangi file untuk setiap halaman. Anda dapat membaca lebih lanjut tentang memori halaman dalam sebuah artikel di Apache Ignite Wiki: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ignite Persistent Store - di bawah tenda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme kompresi halaman disk, seperti namanya, berfungsi di level halaman. </font><font style="vertical-align: inherit;">Ketika mekanisme ini dihidupkan, bekerja dengan data dalam RAM dilakukan sebagaimana adanya, tanpa kompresi apa pun, tetapi pada saat menyimpan halaman dari RAM ke disk, mereka dikompres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi untuk mengompres setiap halaman secara terpisah bukanlah solusi untuk masalah ini, Anda perlu mengurangi ukuran file data yang dihasilkan. </font><font style="vertical-align: inherit;">Jika ukuran halaman tidak lagi diperbaiki, kami tidak bisa lagi menulis halaman ke file satu per satu, karena ini dapat menimbulkan sejumlah masalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak dapat menggunakan indeks halaman untuk menghitung offset di mana ia terletak di file.</font></font></li>
<li> ,    ,          .    ,     .    ,         .</li>
<li>           ,      ,        ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tidak menyelesaikan masalah ini pada tingkatnya sendiri, kompresi halaman disk di Apache Ignite menggunakan mekanisme sistem file yang disebut file jarang. File jarang adalah file di mana beberapa daerah diisi dengan nol dapat ditandai sebagai lubang. Dalam hal ini, blok sistem file untuk menyimpan lubang-lubang ini tidak akan dialokasikan, akibatnya ruang disk yang disimpan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adalah logis bahwa untuk membebaskan blok sistem file, ukuran lubang harus lebih besar dari atau sama dengan blok sistem file, yang menerapkan batasan tambahan pada ukuran halaman Apache Ignite: untuk kompresi untuk memberikan setidaknya beberapa efek, ukuran halaman harus benar-benar lebih besar daripada ukuran blok sistem file . Jika ukuran halaman sama dengan ukuran blok, maka kita tidak akan pernah bisa membebaskan satu blok, karena untuk membebaskan satu blok kita membutuhkan halaman terkompresi untuk menempati 0 byte. Jika ukuran halaman sama dengan ukuran 2 atau 4 blok, kita sudah dapat membebaskan setidaknya satu blok jika halaman kita dikompresi masing-masing setidaknya 50% atau 75%.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, deskripsi akhir dari mekanisme: Saat menulis halaman ke disk, upaya dilakukan untuk mengompres halaman. Jika ukuran halaman yang dikompresi memungkinkan satu atau lebih blok dari sistem file untuk dibebaskan, maka halaman tersebut ditulis dalam bentuk terkompresi, sebuah "lubang" dilubangi di tempat blok yang dirilis (panggilan sistem dibuat </font></font><code>fallocate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan bendera "lubang berlubang" dibuat). Jika ukuran halaman terkompresi tidak memungkinkan pembebasan blok, halaman disimpan apa adanya, dalam bentuk terkompresi. Semua offset halaman dipertimbangkan dan tanpa kompresi, dengan mengalikan indeks halaman dengan ukuran halaman. Tidak perlu memindahkan halaman secara mandiri. Offset halaman, dan juga tanpa kompresi, jatuh pada batasan blok sistem file.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-l/0f/3x/-l0f3xzxozvrxefbiauxdivslv0.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam implementasi saat ini, Ignite hanya dapat bekerja dengan file yang jarang di Linux OS, jadi kompresi halaman disk hanya dapat diaktifkan ketika Ignite digunakan pada sistem operasi ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma kompresi yang dapat digunakan untuk kompresi halaman disk: ZSTD, LZ4, Snappy. </font><font style="vertical-align: inherit;">Selain itu, ada mode operasi (SKIP_GARBAGE), di mana hanya tempat yang tidak digunakan di halaman yang dibuang tanpa menerapkan kompresi ke data yang tersisa, yang memungkinkan untuk mengurangi beban pada CPU dibandingkan dengan algoritma yang tercantum di atas.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dampak kinerja </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, saya tidak benar-benar mengukur kinerja pada tegakan nyata, karena kami tidak berencana untuk menggunakan mekanisme ini dalam produksi, tetapi secara teoritis kami dapat berspekulasi di mana kami akan kehilangan dan di mana kami akan menang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan ini, kita perlu mengingat cara membaca dan menulis halaman saat mengaksesnya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika operasi baca dilakukan, pertama kali dicari dalam RAM, jika pencarian gagal, halaman dimuat ke dalam RAM dari disk dengan aliran yang sama yang membaca.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat melakukan operasi tulis, halaman dalam RAM ditandai sebagai kotor, sementara penyimpanan fisik halaman ke disk segera dalam aliran yang melakukan perekaman tidak terjadi. </font><font style="vertical-align: inherit;">Semua halaman kotor disimpan ke disk nanti dalam proses pos pemeriksaan di aliran terpisah.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, efek pada operasi baca:</font></font><br>
<br>
<ul>
<li> (disk IO),        .</li>
<li> (CPU),           sparse .       IO       sparse  (    sparse  ,  ,  ).</li>
<li> (CPU),     .</li>
<li>    .</li>
<li>    (    ):</li>
<li> (disk IO),        .</li>
<li> (CPU,  disk IO),     sparse .</li>
<li> (CPU),     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skala mana yang akan lebih penting? </font><font style="vertical-align: inherit;">Itu semua sangat tergantung pada lingkungan, tetapi saya cenderung percaya bahwa kompresi halaman disk lebih cenderung menurunkan kinerja pada kebanyakan sistem. </font><font style="vertical-align: inherit;">Selain itu, tes pada DBMS lain menggunakan pendekatan yang sama dengan file jarang menunjukkan penurunan kinerja ketika kompresi diaktifkan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mengaktifkan dan mengkonfigurasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti disebutkan di atas, versi minimum Apache Ignite yang mendukung kompresi halaman disk: 2.8 dan hanya mendukung sistem operasi Linux. </font><font style="vertical-align: inherit;">Pengaktifan dan pengaturan dilakukan sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas-path harus memiliki modul kompresi penyalaan. </font><font style="vertical-align: inherit;">Secara default, ini terletak di distribusi Apache Ignite di direktori libs / opsional dan tidak termasuk dalam jalur kelas. </font><font style="vertical-align: inherit;">Anda cukup memindahkan direktori satu tingkat ke atas ke lib dan kemudian ketika diluncurkan melalui ignite.sh, direktori itu akan dihidupkan secara otomatis.</font></font></li>
<li>Persistence    (  <code>DataRegionConfiguration.setPersistenceEnabled(true))</code>.</li>
<li>         (    <code>DataStorageConfiguration.setPageSize()</code> ).</li>
<li>  ,            ()   ( <code>CacheConfiguration.setDiskPageCompression() , CacheConfiguration.setDiskPageCompressionLevel()</code>).</li>
</ul><br>
<h3>WAL compaction</h3><br>
<h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa itu WAL dan mengapa itu dibutuhkan? Sangat singkat: ini adalah jurnal di mana semua peristiwa yang berubah sebagai akibat dari repositori halaman jatuh. Dia dibutuhkan terutama untuk kemungkinan pemulihan jika jatuh. Sebelum mentransfer kontrol ke pengguna, operasi apa pun harus terlebih dahulu menulis acara ke WAL, sehingga jika jatuh, ia dapat memutar log dan mengembalikan semua operasi yang menerima respons sukses pengguna, bahkan jika operasi ini tidak memiliki waktu untuk tercermin dalam penyimpanan halaman pada disk (di atas sudah telah dijelaskan bahwa penulisan aktual ke halaman toko dilakukan dalam proses yang disebut pos pemeriksaan dengan beberapa penundaan dalam utas terpisah).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entri dalam WAL dibagi menjadi logis dan fisik. Yang logis adalah kunci dan nilai itu sendiri. Fisik - mencerminkan perubahan halaman di halaman toko. Jika catatan logis dapat berguna untuk beberapa kasus lain, catatan fisik hanya diperlukan untuk pemulihan jika jatuh dan catatan hanya diperlukan sejak saat pos pemeriksaan terakhir yang berhasil. Di sini kita tidak akan masuk ke rincian dan menjelaskan mengapa ini bekerja dengan cara ini, tetapi siapa pun yang tertarik dapat merujuk ke artikel yang sudah disebutkan di Apache Ignite Wiki: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ignite Persistent Store - di bawah tenda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu catatan logis sering menjelaskan beberapa catatan fisik. Misalnya, satu operasi cache menempatkan beberapa halaman dalam memori halaman (halaman dengan data itu sendiri, halaman dengan indeks, halaman dengan daftar bebas). Pada beberapa tes sintetik, ternyata catatan fisik menempati hingga 90% dari file WAL. Selain itu, mereka membutuhkan waktu yang sangat singkat (secara default, interval antara pos-pos pemeriksaan adalah 3 menit). Adalah logis untuk menyingkirkan data ini setelah kehilangan relevansinya. Ini persis apa yang dilakukan mekanisme pemadatan WAL, menghilangkan catatan fisik dan kompres catatan logis yang tersisa dengan zip, sedangkan ukuran file menurun sangat signifikan (kadang-kadang puluhan kali).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara fisik, WAL terdiri dari beberapa segmen (default 10) dengan ukuran tetap (default 64 MB), yang ditimpa dalam lingkaran. </font><font style="vertical-align: inherit;">Segera setelah segmen saat ini diisi, segmen berikutnya ditetapkan ke segmen saat ini, dan segmen yang diisi disalin ke arsip dalam aliran yang terpisah. </font><font style="vertical-align: inherit;">Kompaksi WAL sudah berfungsi dengan segmen arsip. </font><font style="vertical-align: inherit;">Selain itu, dalam aliran terpisah, ia memantau pelaksanaan pos pemeriksaan dan mulai kompresi oleh segmen arsip, yang catatan fisiknya tidak lagi diperlukan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zk/95/jo/zk95jo7dnthiox2sv0ezywhrj2a.png"><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dampak kinerja</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena pemadatan WAL beroperasi sebagai utas terpisah, seharusnya tidak ada pengaruh langsung pada operasi yang dilakukan. </font><font style="vertical-align: inherit;">Tetapi masih memberikan beban latar belakang tambahan pada CPU (kompresi) dan disk (membaca setiap segmen WAL dari arsip dan menulis segmen terkompresi), jadi jika sistem berjalan ke batas, itu juga akan menyebabkan penurunan kinerja.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mengaktifkan dan mengkonfigurasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mengaktifkan pemadatan WAL menggunakan properti </font></font><code>WalCompactionEnabled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>DataStorageConfiguration (DataStorageConfiguration.setWalCompactionEnabled(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Selain itu, menggunakan metode DataStorageConfiguration.setWalCompactionLevel (), Anda dapat mengatur rasio kompresi jika Anda tidak puas dengan nilai default (BEST_SPEED).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi snapshot halaman WAL</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana itu bekerja</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami telah menemukan bahwa dalam WAL, entri dibagi menjadi logis dan fisik. Untuk setiap perubahan setiap halaman dalam memori halaman, catatan WAL fisik dihasilkan. Catatan fisik, pada gilirannya, juga dibagi menjadi 2 subspesies: catatan snapshot halaman dan catatan delta. Setiap kali kami mengubah sesuatu pada halaman dan mengubahnya dari keadaan bersih ke yang kotor, salinan lengkap halaman ini disimpan dalam WAL (catatan foto halaman). Bahkan jika kita mengubah hanya satu byte di WAL, catatan dengan ukuran yang sedikit lebih besar dari ukuran halaman akan disimpan. Jika kita mengubah sesuatu pada halaman yang sudah kotor, maka catatan delta terbentuk di WAL, yang hanya mencerminkan perubahan dibandingkan dengan keadaan halaman sebelumnya, tetapi tidak seluruh halaman. Karena mengatur ulang status halaman dari kotor ke bersih dilakukan selama proses pemeriksaan,segera setelah dimulainya pos pemeriksaan, hampir semua catatan fisik hanya terdiri dari snapshot halaman (karena semua halaman segera setelah dimulainya pos pemeriksaan kosong), maka ketika Anda mendekati pos pemeriksaan berikutnya, proporsi catatan delta mulai bertambah dan direset lagi di awal pos pemeriksaan berikutnya. Pengukuran pada beberapa tes sintetis menunjukkan bahwa bagian dari snapshot halaman dalam volume total catatan fisik mencapai 90%.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan di balik kompresi snapshot halaman WAL adalah untuk mengompresi snapshot halaman menggunakan alat kompresi halaman yang tidak tersedia (lihat kompresi halaman disk). Pada saat yang sama, di WAL, catatan disimpan secara berurutan dalam mode append-only dan tidak perlu untuk mengikat catatan ke batas blok sistem file, oleh karena itu, di sini, tidak seperti mekanisme kompresi halaman disk, kami sama sekali tidak memerlukan file yang jarang, sehingga mekanisme ini akan bekerja tidak hanya pada OS Linux Selain itu, kami tidak lagi peduli seberapa besar kami dapat mengompres halaman. Bahkan jika kita membebaskan 1 byte, ini sudah merupakan hasil positif dan kita dapat menyimpan data terkompresi di WAL, tidak seperti kompresi halaman disk, di mana kita menyimpan halaman terkompresi hanya jika lebih dari 1 blok sistem file dibebaskan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Halaman adalah data yang dapat dikompresi dengan baik, bagiannya dalam total volume WAL sangat tinggi, jadi tanpa mengubah format file WAL, kita bisa mendapatkan pengurangan yang signifikan dalam ukurannya. </font><font style="vertical-align: inherit;">Kompresi catatan logis, antara lain, akan memerlukan perubahan dalam format dan kehilangan kompatibilitas, misalnya, untuk konsumen eksternal yang mungkin tertarik pada catatan logis, tanpa secara signifikan mengurangi ukuran file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedangkan untuk kompresi halaman disk untuk kompresi snapshot halaman WAL, algoritma kompresi ZSTD, LZ4, Snappy, serta mode SKIP_GARBAGE dapat digunakan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dampak kinerja</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak sulit untuk memperhatikan bahwa penyertaan langsung kompresi snapshot halaman WAL hanya memengaruhi stream yang menulis data ke memori halaman, yaitu stream yang mengubah data dalam cache. Membaca dari catatan fisik WAL hanya terjadi sekali, pada saat menaikkan node setelah jatuh (dan hanya dalam kasus jatuh selama pos pemeriksaan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mempengaruhi aliran data sebagai berikut: kami mendapatkan efek negatif (CPU) karena kebutuhan untuk mengompres halaman setiap kali sebelum menulis ke disk dan efek positif (disk IO) dengan mengurangi jumlah data yang sedang ditulis. Dengan demikian, semuanya sederhana di sini, jika kinerja sistem bertumpu pada CPU, kami mendapatkan sedikit degradasi, jika dalam disk I / O, kami mendapatkan peningkatan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara tidak langsung, mengurangi ukuran WAL juga mempengaruhi aliran (positif) yang menjatuhkan segmen WAL ke dalam arsip dan aliran pemadatan WAL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tes kinerja nyata di lingkungan kita pada data sintetis menunjukkan peningkatan kecil (throughput meningkat 10% -15%, latensi menurun 10% -15%).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mengaktifkan dan mengkonfigurasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi minimum Apache Ignite adalah 2.8. </font><font style="vertical-align: inherit;">Pengaktifan dan pengaturan dilakukan sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas-path harus memiliki modul kompresi penyalaan. </font><font style="vertical-align: inherit;">Secara default, ini terletak di distribusi Apache Ignite di direktori libs / opsional dan tidak termasuk dalam jalur kelas. </font><font style="vertical-align: inherit;">Anda cukup memindahkan direktori satu tingkat ke atas ke lib dan kemudian ketika diluncurkan melalui ignite.sh, direktori itu akan dihidupkan secara otomatis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kegigihan harus diaktifkan (Diaktifkan melalui </font></font><code>DataRegionConfiguration.setPersistenceEnabled(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li>
<li>        <code>DataStorageConfiguration.setWalPageCompression()</code>,     ( DISABLED).</li>
<li>        <code>DataStorageConfiguration.setWalPageCompression()</code>,         javadoc  .</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme kompresi data yang dibahas dalam Apache Ignite dapat digunakan secara independen satu sama lain, tetapi kombinasi keduanya juga valid. </font><font style="vertical-align: inherit;">Memahami prinsip-prinsip pekerjaan mereka akan menentukan bagaimana mereka sesuai dengan tugas Anda di lingkungan Anda dan apa yang harus Anda korbankan saat menggunakannya. </font><font style="vertical-align: inherit;">Kompresi halaman disk dirancang untuk mengompresi penyimpanan utama dan dapat memberikan kompresi sedang. </font><font style="vertical-align: inherit;">Kompresi snapshot halaman WAL akan memberikan tingkat kompresi rata-rata file WAL yang sudah ada, sementara itu kemungkinan akan meningkatkan kinerja. </font><font style="vertical-align: inherit;">Pemadatan WAL tidak akan mempengaruhi kinerja secara positif, tetapi akan meminimalkan ukuran file WAL dengan menghapus catatan fisik.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id502122/index.html">Thanos - Prometheus Terukur</a></li>
<li><a href="../id502124/index.html">Hasil usaha 2019 untuk Ukraina</a></li>
<li><a href="../id502126/index.html">Cara Meningkatkan Resume Programmer Bahasa Inggris Anda</a></li>
<li><a href="../id502132/index.html">Cara mentransfer wadah OpenVZ 6 ke server KVM tanpa sakit kepala</a></li>
<li><a href="../id502134/index.html">Cukup takut pada keputusan indah yang subyektif dalam kode - Anda bukan robot</a></li>
<li><a href="../id502146/index.html">Roundtable online "Saya ingin gamedev"</a></li>
<li><a href="../id502148/index.html">Menggunakan komponen pihak ketiga dalam penyimpanan menggunakan Qsan sebagai contoh</a></li>
<li><a href="../id502150/index.html">Menskalakan jaringan beban tinggi dengan Nutanix: fitur dan tantangan dengan casing pribadi</a></li>
<li><a href="../id502154/index.html">Menulis Autotests Secara Efektif - Tes subkutan</a></li>
<li><a href="../id502156/index.html">Rambler v. NGINX Kasus: Resiko Pidana Digitalisasi Roundtable 16 Mei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>