<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚤 👍🏽 🔟 MASK-RCNN用于从无人机图像中查找屋顶 🌂 👩‍⚖️ 💏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在一条白色街道上的白色城市中，有白色和白色的房屋……而这张照片中您能很快找到房屋的所有屋顶吗？
 
 人们越来越多地听到政府计划对房地产进行完整清点以澄清地籍数据的计划。对于此问题的主要解决方案，可以基于从航空照片计算出的首都建筑物屋顶面积并与地籍数据进行进一步比较的基础上，采用一种简单的方法。不幸...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>MASK-RCNN用于从无人机图像中查找屋顶</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/500752/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/eb5/21e/ad9eb521e7c2fcb232116aa876742ee3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一条白色街道上的白色城市中，有白色和白色的房屋……而这张照片中您能很快找到房屋的所有屋顶吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人们越来越多地听到政府计划对房地产进行完整清点以澄清地籍数据的计划。对于此问题的主要解决方案，可以基于从航空照片计算出的首都建筑物屋顶面积并与地籍数据进行进一步比较的基础上，采用一种简单的方法。不幸的是，手动搜索和计算需要大量时间，并且由于新房屋的拆除和建造是连续的，因此需要一次又一次地重复计算。立刻出现了一个假设，即可以使用机器学习算法（特别是Computer Vision）来自动执行此过程。在本文中，我将讨论我们在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORBIT的情况</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解决了这个问题，以及他们遇到了什么困难。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剧透-我们</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做到了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">开发的ML服务基于基于卷积神经网络的深度机器学习模型。</font><font style="vertical-align: inherit;">该服务接受来自无人机的图像作为输入；在输出处，该服务生成一个GeoJSON文件，该文件带有参考地理坐标的找到的基本建设对象的标记。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，它看起来像这样：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ab/892/528/0ab892528db9a5c84fd26d0e30329b5a.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从遇到的技术问题开始：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冬季和夏季航空照片之间存在显着差异（仅在夏季照片中训练的模型在冬季完全无法找到屋顶）；</font></font></li>
<li>            ,       ;</li>
<li>  ,          (  ),     (     )      ,           ;</li>
<li>   ,     ,         (     ).        ;</li>
<li>  (,   )     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无人机有时会带来以下照片：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/663/809/821/66380982148bc07c8309f8d106ecfc38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我还想指出可能存在的问题，但它们与我们无关：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们没有任务可以在有限的时间内执行推理（例如，在飞行时直接进行推理），这可以立即解决所有可能的性能问题；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在进行处理时，我们立即从客户Shakhty公司收到了高质量的高分辨率图像（使用焦距为21 mm的镜头，高度为250 m，即5 cm / px），可以使用他们的专业知识对地图上的对象进行地理定位，并且他们还有机会对未来的无人机飞行制定一套特定的要求，这最终大大降低了训练集中没有的非常独特的瓷砖的可能性；</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个解决问题的方法是使用“边界框”描边&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于我们用来创建解决方案的工具的几句话。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anaconda是用于Python和R的便捷软件包管理系统。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensorflow是Google开发的开源机器学习软件库。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keras是Deeplearning4j，TensorFlow和Theano框架的附加组件。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV是用于计算机视觉，图像处理和通用开源数值算法的算法库。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flask是用于使用Python编程语言创建Web应用程序的框架。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于操作系统使用Ubuntu 18.04。</font><font style="vertical-align: inherit;">借助Ubuntu中GPU（NVIDIA）上的驱动程序，一切都井井有条，因此通常可以通过以下命令来解决此任务：</font></font><br>
<br>
<code>&gt; sudo apt install nvidia-cuda-toolkit</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">瓷砖准备</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们面临的第一个任务是将飞越图像拆分为图块（2048x2048 px）。</font><font style="vertical-align: inherit;">您可以编写自己的脚本，但是随后您必须考虑维护每个图块的地理位置。</font><font style="vertical-align: inherit;">使用现成的解决方案（例如GeoServer）更容易，它是一种开放源代码软件，可让您在服务器上发布地理数据。</font><font style="vertical-align: inherit;">此外，GeoServer为我们解决了另一个问题-在地图上方便地显示自动标记的结果。</font><font style="vertical-align: inherit;">这可以在本地完成，例如在qGIS中，但是对于分布式命令和演示，Web资源更加方便。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要执行平铺，您需要在设置中指定所需的比例和大小。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/688/b29/4d1/688b294d129f14dddc810ca0defdef44.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于坐标系之间的转换，我们使用了pyproj库：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> pyproj <span class="hljs-keyword">import</span> Proj, transform<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Converter</span>:</span>
&nbsp;&nbsp;&nbsp;&nbsp;P3857 = Proj(init=<span class="hljs-string">'epsg:3857'</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;P4326 = Proj(init=<span class="hljs-string">'epsg:4326'</span>)<font></font>
...<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_3857_to_GPS</span>(<span class="hljs-params">self, point</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = point<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> transform(self.P3857, self.P4326, x, y)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_GPS_to_3857</span>(<span class="hljs-params">self, point</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = point<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> transform(self.P4326, self.P3857, x, y)<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，可以容易地从所有多边形形成一个大的层并将其放置在基板的顶部上。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b8/9f6/428/2b89f642889bdc551871a35ba43a7c03.png"></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要安装GeoServer软件，您必须完成以下步骤。</font></font></b>
                        <div class="spoiler_text"><ol>
<li> Java  8.</li>
<li> GeoServer.       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a></li>
<li>     , ,&nbsp;<code>/usr/share/geoserver</code></li>
<li>      &nbsp;<br>
<br>
<strong><code>echo «export GEOSERVER_HOME=/usr/share/geoserver» &gt;&gt; ~/.profile</code></strong></li>
<li>   :<br>
<br>
<strong><code>sudo groupadd geoserver</code></strong></li>
<li> ,     ,   :<br>
<br>
<strong><code>sudo usermod -a -G geoserver &lt;user_name&gt;</code></strong></li>
<li> -  :<br>
<br>
<strong><code>sudo chown -R :geoserver /usr/share/geoserver/</code></strong></li>
<li>    :<br>
<br>
<strong><code>sudo chmod -R g+rwx /usr/share/geoserver/</code></strong></li>
<li> GeoServer&nbsp;<br>
<br>
<strong><code>cd geoserver/bin &amp;&amp; sh startup.sh</code></strong></li>
</ol></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeoServer并不是使我们能够解决问题的唯一应用程序。</font><font style="vertical-align: inherit;">例如，可以选择使用ArcGIS for Server，但该产品是专有的，因此我们没有使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，每个瓷砖都必须找到所有可见的屋顶。</font><font style="vertical-align: inherit;">解决问题的第一种方法是使用</font><font style="vertical-align: inherit;">来自模型/研究Tensorflow集</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object_detection</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通过这种方式，可以找到图像上的类并使用矩形选择（边界框）定位它们。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">训练数据标记&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，要训练模型，您需要标记的数据集。幸运的巧合是，除了盘旋之外，在我们的垃圾箱中，保存了过去美好时光的5万个屋顶的数据集，当时所有用于训练的数据集仍然处在公共领域。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要获得可接受的模型精度所需的训练样本的确切大小很难事先预测。它可以根据图像的质量，它们彼此之间的不相似程度以及在生产中使用该模型的条件而有所不同。我们有200块足够的情况，有时也遗漏了5万个标记样品。在缺少标记图像的情况下，我们通常会添加增强方法：转向，镜面反射，颜色分级等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，有许多服务可用来标记图像-既可以使用开放源代码进行标记以在计算机/服务器上安装，也可以使用公司解决方案，包括外部评估人员的工作，例如Yandex.Toloka。</font><font style="vertical-align: inherit;">在此项目中，我们使用了最简单的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGG图像注释器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">另外，您可以尝试</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coco-annotator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">label-studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们通常使用后者来标记文本和音频文件。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/46b/39c/5b146b39c6413ebde30c1a0a6f25421a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了训练各种注释器的标记，通常需要对字段进行一小部分转换，例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了正确计算落入矩形分配区域的屋顶面积，有必要注意以下几个条件：</font></font><br>
<br>
<ul>
<li>     /     .          :</li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/41a/80e/b0c41a80e0ae785794143da7b38dfbbf.png"></div><br>
<ul>
<li>,    ,      :</li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/092/1de/dcb/0921dedcbc4effc0430d11cd8dea8401.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要解决第二个问题，您可以尝试训练一个单独的模型，该模型可以确定用于标记的瓷砖的正确旋转角度，但事实证明一切都更加容易。</font><font style="vertical-align: inherit;">人们自己努力减少熵，因此他们将所有人造结构相互对齐，尤其是与密集的建筑物对齐。</font><font style="vertical-align: inherit;">如果从上方看，则在局部区域中，篱笆，人行道，植物，温室，乔木将平行于或垂直于屋顶的边界。</font><font style="vertical-align: inherit;">剩下的只是找到所有清晰的线条并计算最常见的垂直倾斜角度。</font><font style="vertical-align: inherit;">为此，OpenCV具有出色的HoughLinesP工具。&nbsp;</font></font><br>
<br>
<pre><code class="python hljs">...<font></font>
<font></font>
lines = cv2.HoughLinesP(edges, <span class="hljs-number">1</span>, np.pi/<span class="hljs-number">180</span>, <span class="hljs-number">50</span>, minLineLength=minLineLength, maxLineGap=<span class="hljs-number">5</span>)
<span class="hljs-keyword">if</span> lines <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;length = image.shape[<span class="hljs-number">0</span>]<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;angles = []<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> lines[<span class="hljs-number">0</span>]:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle = math.degrees(math.atan2(y2 — y1, x2 - x1))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angles.append(angle)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;parts_angles.append(angles)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;median_angle = np.median(angles)<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">#    &nbsp;</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, image.shape[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, image.shape[<span class="hljs-number">0</span>] // count_crops):
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, image.shape[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>, image.shape[<span class="hljs-number">1</span>] // count_crops):<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_line(image[x:x+image.shape[<span class="hljs-number">0</span>]//count_crops, y:y+image.shape[<span class="hljs-number">1</span>]//count_crops, :])<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
<font></font>
np.median([a <span class="hljs-keyword">if</span> a&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">90</span>+a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> np.array(parts_angles).flatten()])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
找到角度后，我们使用仿射变换旋转图像：</font></font><br>
<br>
<pre><code class="python hljs">
h, w = image.shape[:<span class="hljs-number">2</span>]<font></font>
image_center = (w/<span class="hljs-number">2</span>, h/<span class="hljs-number">2</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> size <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;radians = math.radians(angle)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;sin = math.sin(radians)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;cos = math.cos(radians)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;size = (int((h * abs(sin)) + (w * abs(cos))), int((h * abs(cos)) + (w * abs(sin))))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix = cv2.getRotationMatrix2D(image_center, angle, <span class="hljs-number">1</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>] += ((size[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>) — image_center[<span class="hljs-number">0</span>])<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] += ((size[<span class="hljs-number">1</span>] / <span class="hljs-number">2</span>) — image_center[<span class="hljs-number">1</span>])
<span class="hljs-keyword">else</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix = cv2.getRotationMatrix2D(image_center, angle, <span class="hljs-number">1</span>)<font></font>
<font></font>
cv2.warpAffine(image, rotation_matrix, size)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完整的示例代码在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">看起来是这样的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/032/15c/2b203215c7a688dc7639e7993643a99e.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/423/c1b/594423c1b3e52a8e4fcd383b20a04b05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
旋转瓷砖和用矩形标记的方法比用掩模标记的方法更快，几乎可以找到所有屋顶，但是在生产中，由于以下几个缺点，该方法仅用作辅助方法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有很多飞越的地方都有大量的非矩形屋顶，因此需要太多的手工工作来完善该区域，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时会在同一瓷砖上以不同方向在家中找到</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时，图块上有许多错误的线条，最终会导致错误的转弯。</font><font style="vertical-align: inherit;">看起来像这样：</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/ba0/30c/6d4ba030c0784c6ee7366486b3a8f03c.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/691/5fd/a10/6915fda10769dc9b5d96522737d6aef6.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于Mask-RCNN的最终解决方案</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二种尝试是通过逐像素遮罩来搜索并突出显示屋顶，然后自动为找到的遮罩轮廓绘制轮廓并创建矢量多边形。&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于卷积神经网络的操作原理，类型和任务的材料已经足够，包括俄语，因此在本文中我们不再赘述。让我们仅讨论一种特定的实现，即Mask-RCNN-一种用于定位和突出显示图像中对象轮廓的体系结构。还有其他各有优缺点的出色解决方案，例如UNet，但是可以在Mask-RCNN上获得更好的质量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在其发展过程中，它经历了几个阶段。 R-CNN的第一版于2014年开发。它的工作原理是突出显示图像中的小区域，对于每个小区域都将估计目标物体在该区域中的存在概率。 R-CNN在这项任务上做得很出色，但是其速度仍然有很多不足之处。合理的发展是Fast R-CNN和Faster R-CNN网络，它们在图像抓取算法上得到了改进，从而显着提高了速度。在Faster R-CNN的出口处，出现带有矩形选择的标记，指示对象的边界，但这并不总是足以解决问题。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遮罩R-CNN还添加了逐像素遮罩叠加层，以获取对象的精确轮廓。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在模型的操作结果上可以清楚地看到边界框和蒙版（打开最小建筑面积的过滤器）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6e/d0c/756/d6ed0c7567ed2894bbe11161fc91af55.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，此网络的运行分为四个阶段：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有卷积神经网络的标准，是图像中特征的分配，例如线条，折弯，对比边界等。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区域提议网（RPN）扫描图像的小片段，称为锚点（anchor），并确定该锚点是否包含特定于目标类别的标志（在我们的情况下为屋顶）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">兴趣区域分类和边界框。</font><font style="vertical-align: inherit;">在此阶段，网络根据上一阶段的结果，试图突出显示照片中可能包含目标对象的矩形区域。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细分蒙版。</font><font style="vertical-align: inherit;">在此阶段，从通过应用边界框获得的矩形区域中获得所需对象的蒙版。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，该网络的配置非常灵活，我们能够对其进行重建以处理带有附加信息层的图像。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅使用RGB图像无法使我们达到必要的识别精度（该模型错过了整个建筑物，在计算屋顶面积时平均误差为15％），因此我们为模型提供了更多有用的数据，例如通过</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">摄影测量</font></a><font style="vertical-align: inherit;">获得的高度图</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a>&nbsp;<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cc/801/ac8/7cc801ac8060a3b99a2bb26415d2fe38.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于评估模型质量的指标</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在确定模型的质量时，我们最经常使用“交集相交”（IoU）度量</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/486/5be/8cc4865be494cc0bee045c618df9ff59.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用geometry.shapely库计算IoU的示例代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> shapely.geometry <span class="hljs-keyword">import</span> Polygon<font></font>
<font></font>
true_polygon = Polygon([(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)])<font></font>
predicted_polygon = Polygon([(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">3</span>)])<font></font>
print(true_polygon.intersection(predicted_polygon).area / true_polygon.union(predicted_polygon).area)<font></font>
<font></font>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.3333333333333333</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Tensorboard可以方便地控制跟踪模型的训练过程，Tensorboard是一种方便的度量控制工具，可让您接收有关模型质量的实时数据并将其与其他模型进行比较。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/a7a/b20/31ca7ab20d4583360b3058b59277bc10.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tensorboard提供有关许多不同指标的数据。</font><font style="vertical-align: inherit;">对我们来说最有趣的是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">val_mrcnn_bbox_loss-显示模型对对象的本地化程度（即强加边界框）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">val_mrcnn_mask_loss-显示模型对对象的分割程度（即施加遮罩）。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型训练与验证</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
训练时，我们采用将数据集随机分为3个部分的标准做法-训练，验证和测试。在学习过程中，将基于验证样本评估模型的质量，并在完成后通过对在学习过程中关闭的测试数据的最终测试。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从一小撮夏天的镜头开始了我们的第一次训练，然后决定检查我们的模型在冬天的状态如何，我们预期会收到令人失望的结果。</font><font style="vertical-align: inherit;">当然，可以选择在不同的季节使用不同的模型，这是摆脱情况的绝佳方法，但这会带来许多不便，因此我们决定尝试使模型通用。</font><font style="vertical-align: inherit;">通过对图层的不同配置进行实验，并通过权重变化来关闭各个图层的权重，我们找到了通过交替使用夏季和冬季图片作为输入来训练模型的最佳策略。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建用于识别的后台服务</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们有了一个可以正常运行的模型，我们可以从识别脚本中提供后台API服务，该脚本将图像作为输入并生成在输出中找到带有屋顶多边形的json。</font><font style="vertical-align: inherit;">这不会直接影响问题的解决，但对某人可能有用。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ubuntu使用systemd，并将为此系统专门给出一个示例。</font><font style="vertical-align: inherit;">服务本身的代码可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用户单元位于/ etc / systemd / system目录中，我们将在其中创建我们的服务文件。</font><font style="vertical-align: inherit;">
编辑文件：</font></font><br>
<br>
<code>cd /etc/systemd/system<br>
<br>
sudo touch my_srv.service</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="bash hljs">sudo vim my_srv.service
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
系统单元包括三个部分：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Unit]-描述启动的顺序和条件（例如，您可以告诉进程等待某个服务的启动，然后自己启动）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[服务]-描述启动参数；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[安装]-描述将服务添加到启动时的行为。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们的文件将如下所示：</font></font><br>
<br>
<pre><code class="bash hljs">[Unit]<font></font>
Description=my_test_unit<font></font>
<font></font>
[Service]<font></font>
WorkingDirectory=/home/user/test_project<font></font>
User=root<font></font>
ExecStart=/home/user/test_project/venv/bin/python3 /home/user/test_project/script.py<font></font>
<font></font>
[Install]<font></font>
WantedBy=multi-user.target<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在重新加载systemd配置并运行我们的服务：</font></font><br>
<br>
<pre><code class="bash hljs">sudo systemctl daemon-reload<font></font>
sudo systemctl start my_srv.service<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个后台进程的简单示例，systemd支持许多不同的参数，这些参数使您可以灵活地配置服务的行为，但是我们的任务并不需要更复杂。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该项目的主要结果是能够自动检测实际开发中的不一致性以及地籍数据中包含的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据测试数据评估模型的准确性后，获得了以下值：发现的屋顶数量-91％，屋顶轮廓多边形的准确性-94％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在夏季和冬季的飞行中可以达到可接受的模型质量，但是降雪后图像中的识别质量可能会下降。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，即使是悉尼歌剧院也不会从我们模特的视线中溜走。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zs/c1/yl/zsc1yl0dgkkhjahgjk3vssn8swc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们计划在我们的演示台上以经过培训的模型提供此服务。</font><font style="vertical-align: inherit;">如果您想在自己的照片上尝试使用该服务，请将应用程序发送至ai@norbit.ru。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500728/index.html">Kubernetes：开源与供应商</a></li>
<li><a href="../zh-CN500732/index.html">人工智能与意识理论的危机</a></li>
<li><a href="../zh-CN500734/index.html">＃GitLab 12.10已发布，具有需求管理和AWS Fargate的自动CI扩展</a></li>
<li><a href="../zh-CN500744/index.html">“比您说的更好，我的扬声器”：如何在家中更好地播放</a></li>
<li><a href="../zh-CN500746/index.html">用于SMD和其他小物件的拳击架</a></li>
<li><a href="../zh-CN500754/index.html">如何在30年内躺在沙发上成为百万富翁</a></li>
<li><a href="../zh-CN500756/index.html">远程全能。JUG Ru Group在线会议上的流媒体如何工作？</a></li>
<li><a href="../zh-CN500758/index.html">2020-2021年网络安全和信息安全市场的主要趋势与2019-2020年的预测</a></li>
<li><a href="../zh-CN500760/index.html">如何使用ZeroTier更有效地杀死僵尸</a></li>
<li><a href="../zh-CN500764/index.html">演讲：软件自动口</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>