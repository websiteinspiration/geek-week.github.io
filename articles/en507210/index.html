<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèº üí• ü¶á The performance of modern Java when working with large amounts of data, part 2 ‚òëÔ∏è üë´ üî°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FYI: The first part .
 
 Benchmark Batch Conveyor
 The batch pipeline processes the final amount of stored data. There is no stream of processing resu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>The performance of modern Java when working with large amounts of data, part 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/507210/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d1/gm/bn/d1gmbnhwk4pkhy1bck7ykdmu-uq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FYI: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first part</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark Batch Conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The batch pipeline processes the final amount of stored data. There is no stream of processing results, the output of the aggregating function needs to be applied to the entire data set. This changes the performance requirements: latency - a key factor in streaming processing - is absent here because we process data in real time. The only important metric is the total run time of the conveyor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, we chose Parallel. </font><font style="vertical-align: inherit;">At the first stage of testing, when working on one node, this collector really showed the best throughput (but only after tuning). </font><font style="vertical-align: inherit;">However, this was obtained at the cost of long pauses. </font><font style="vertical-align: inherit;">If one of the cluster nodes stops at garbage collection, this stops the entire pipeline. </font><font style="vertical-align: inherit;">And since the nodes collect garbage at different times, the total build time increases with the addition of each node to the cluster. </font><font style="vertical-align: inherit;">We analyzed this effect by comparing the test results on one node and on a cluster of three nodes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, at this stage, we did not consider experimental low latency collectors. </font><font style="vertical-align: inherit;">Their very short pauses do not affect the test results, moreover, this is achieved due to bandwidth.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing on a single node: conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a batch benchmark on a single node, we used a simple pipeline. Full code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource)<font></font>
 .rebalance() <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; (e.getKey() &amp; <span class="hljs-number">0xFF_FFFFL</span>) == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The source is a stub that generates a sequence of type numbers </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The key function is defined so that it </font></font><code>groupingKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycles through the key space: 0, 1, 2, ... </font></font><code>NUM_KEYS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, 0, 1, 2, ... This means that during the first cycle the pipeline sees all the keys and creates a fixed data structure for storing the results aggregation. And during the next cycles, the system only updates the available data. This is fully consistent with the hypothesis of garbage collection taking into account different generations: objects either go through all the calculations, or do not exist for long and become garbage shortly after their creation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our source generated 400 million elements, and we created 100 million individual keys, that is, four times passed through all the keys. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator</font></font><code>.rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">replaces Jet's default </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two-stage aggregation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with one </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">-stage aggregation</font></a><font style="vertical-align: inherit;"> . This made the behavior of the engine in our benchmarks more predictable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also tested an option in which the aggregation operation uses an instance of an object of type as state </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and generates garbage every time the current account is updated. In this case, many objects die after a decent time in the old generation. In this situation, we had to reduce the number of keys to 70 million, because at 100 million the load on the collector was too high.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We did not focus on low latency collectors because they have nothing to offer in the case of a batch pipeline. </font><font style="vertical-align: inherit;">Since we have already seen that JDK 14 works almost like JDK 11, we ran one test to confirm this. </font><font style="vertical-align: inherit;">And then we focused on JDK 8 and JDK 11. And we also compared the default Parallel collector used in JDK 8 to G1.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing on a single node: results</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We ran the benchmark on a laptop with 16 GB of RAM and a 6-core Intel Core i7. The heap size was 10 GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first, due to Parallel, performance was very poor, and we had to tune garbage collection. Therefore, we highly recommend using VisualVM and the Visual GC plugin. If you set the maximum frame rate (10 fps), you can enjoy a very detailed visualization of the relationship between the allocation of your application memory and the work of the garbage collector. After watching the animation, we realized that the main problem was too large pieces of memory allocated for the new generation. By default, the ratio of the old generation to the new is only 2: 1, and during execution it does not change dynamically. Therefore, we decided to apply the setting</font></font><code>-XX:NewRatio=8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and that changed the whole picture. Now Parallel worked best. We also applied </font></font><code>-XX:MaxTenuringThreshold=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">survivor spaces to reduce data copying between spaces because temporary objects quickly die in the pipeline. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now about the results. The only suitable metric for a batch pipeline is the duration of the task. To visualize the results, we took their reciprocal values, therefore, the graph shows the throughput in elements per second. For one node:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/87a/5c6/a4f87a5c66be2c77e0337151adb9d2ca.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/377/c40/5ab/377c405ab09606862cb1464b07624d56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aggregation without garbage collection works about 30-35% faster, despite a larger set of keys. The G1 and JDK 8 bundle worked the worst, and the Parallel and JDK 11 tuned best. The G1 and JDK 11 bundle did not lose much. Please note that we did not touch the G1 configuration, this is an important point. Garbage collection configuration is highly dependent on the situation. The results can change dramatically, for example, with an increase in the amount of data. And you need to configure for the entire cluster, for a specific type of load. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the performance of the default Parallel collector compared to the customized version we used when testing:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/797/c4a/81b797c4acae8f632c51147b699c3cad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a 10 GB heap, the results are very poor. </font><font style="vertical-align: inherit;">The system got stuck in full pauses for assembly, each of which took about 7 s. </font><font style="vertical-align: inherit;">As the heap increased, the situation improved, but still, complete assembly cycles occurred very often. </font><font style="vertical-align: inherit;">Please note that these results were obtained for the most common case - aggregation without assembly.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing on three nodes: conveyor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To test the cluster correctly, we had to use a more complex </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource())<font></font>
 .rebalance()<font></font>
 .flatMap(n -&gt; {<font></font>
     Long[] items = <span class="hljs-keyword">new</span> Long[SOURCE_STEP];<font></font>
     Arrays.setAll(items, i -&gt; n + i);<font></font>
     <span class="hljs-keyword">return</span> traverseArray(items);<font></font>
 })<font></font>
 .rebalance()<font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(AggregateOperations.summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; e.getKey() % <span class="hljs-number">1_000_000</span> == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the source does not work in parallel, we made some optimizations so that it does not turn into a bottleneck in the system. </font><font style="vertical-align: inherit;">The source generates the numbers 0, 10, 20, ..., and we parallelized the stage </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at which the missing numbers are interpolated. </font><font style="vertical-align: inherit;">Also between the source and </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we used </font></font><code>rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, distributing data across the cluster. </font><font style="vertical-align: inherit;">And before the start of the main stage (key aggregation), we again rebalanced. </font><font style="vertical-align: inherit;">After aggregation, we first leave only every millionth key-value pair, and then pass them to the logger. </font><font style="vertical-align: inherit;">A billion data elements and a set of 500 million keys were used. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As in the case with one node, we tested the conveyor with aggregation without garbage and with it.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing on three nodes: result</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We ran this benchmark on an AWS cluster from three c5d.4xlarge instances. They had 16 virtualized processor cores and 32 GB of memory. Channel bandwidth 10 Gb / s. Result:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/cc6/a6d/579cc6a6d172a6098f96b3c2b9cfbda8.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/32f/ca6/b2832fca67b0123a6ca976e518ecd87c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In passing, we note an approximately threefold overall increase in throughput compared to a single node. This is a consequence of distributed processing. As for the assemblers, the combination of G1 and JDK 11 became the winner of both tests. Another striking result is the almost inoperable combination of G1 and JDK 8. However, this has deeper reasons that affect other dimensions. For example, the obvious advantage of Parallel on JDK 8 and JDK 11. This is due to the effect that we noted at the very beginning: as soon as any node pauses for garbage collection, processing on the entire cluster stops. And G1 on JDK 8 rises for very long pauses, more than a minute. This is enough for the failure detector in the cluster to work and decide that the node has died. The task fails, the cluster reorganizes itself, and the task starts again on two nodes.This leads to a new failure even faster, because each node now processes more data. At the same time, the ejected node joins again, and the task starts again on two nodes, but others. There is an endless loop of restarting tasks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallel pauses are not so long as to break the cluster, but it worked much worse on tests on the same node. On three nodes, he lost 30% to the bunch of G1 and JDK 11. And on larger clusters the situation will be even worse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look at all the tests, it is surprising that Parallel runs faster on JDK 8 than on JDK 11. However, this is due to a very good coincidence: in these test runs, full pauses started synchronously on all nodes, which parallelized the work of the collector. Obviously, this effect cannot be relied on.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even despite the fact that in our test configuration when using Parallel, we did not observe the catastrophic effect of long pauses on cluster stability, this is a very likely scenario. </font><font style="vertical-align: inherit;">In other tests, when we increased the heap and the amount of data, or left the same heap, but reduced the operating margin, Parallel acted just as destructively. </font><font style="vertical-align: inherit;">But even when it did not lead to failures, on the graphs its advantage disappeared when working on the same node. </font><font style="vertical-align: inherit;">It can be expected that the situation will worsen with the addition of new nodes to the cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, a bunch of G1 and JDK 11 worked with rather short pauses, so the conveyor did not stop. </font><font style="vertical-align: inherit;">It has a mechanism that mitigates short downtimes, and while pauses do not exceed 150 ms, garbage collection has only a local impact.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en507198/index.html">Podcasts as corporate media: how to make money on them and what metrics to use</a></li>
<li><a href="../en507200/index.html">7 Ways Data Scientists Fool You</a></li>
<li><a href="../en507202/index.html">Avito Analytics meetup</a></li>
<li><a href="../en507204/index.html">Industrial design interior kitchen: from sketch to product in box</a></li>
<li><a href="../en507206/index.html">Architecture Y messenger</a></li>
<li><a href="../en507212/index.html">Training smart gaming rivals in Unity using the "play with yourself" method using ML-Agents</a></li>
<li><a href="../en507214/index.html">How to create and modify interactive PDF forms, or the new skill ABBYY FineReader PDF</a></li>
<li><a href="../en507218/index.html">Read me, or why the text is not read to the end</a></li>
<li><a href="../en507222/index.html">Why everyone should wear masks</a></li>
<li><a href="../en507224/index.html">How to eliminate blind spots with visual testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>