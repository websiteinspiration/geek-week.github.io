<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèæ üîå üëß Aprendizaje autom√°tico en R: t√©cnicas expertas para el an√°lisis predictivo ü§µ üò® üõ∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! El lenguaje R ofrece un poderoso conjunto de m√©todos de aprendizaje autom√°tico que le permiten realizar r√°pidamente an√°lisis no tri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Aprendizaje autom√°tico en R: t√©cnicas expertas para el an√°lisis predictivo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="imagen"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola habrozhiteli! El lenguaje R ofrece un poderoso conjunto de m√©todos de aprendizaje autom√°tico que le permiten realizar r√°pidamente an√°lisis no triviales de sus datos. El libro es una gu√≠a que ayudar√° a aplicar m√©todos de aprendizaje autom√°tico para resolver problemas cotidianos. Brett Lanz le ense√±ar√° todo lo que necesita para el an√°lisis, pron√≥stico y visualizaci√≥n de datos. Aqu√≠ encontrar√° informaci√≥n sobre bibliotecas nuevas y mejoradas, consejos sobre los aspectos √©ticos del aprendizaje autom√°tico y los problemas de sesgo, as√≠ como capacitaci√≥n en profundidad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este libro: Fundamentos del aprendizaje autom√°tico y caracter√≠sticas de la capacitaci√≥n en inform√°tica en ejemplos. </font><font style="vertical-align: inherit;">- Preparaci√≥n de datos para su uso en el aprendizaje autom√°tico mediante el lenguaje R. - Clasificaci√≥n de la importancia de los resultados. </font><font style="vertical-align: inherit;">- Predicci√≥n de eventos utilizando √°rboles de decisi√≥n, reglas y vectores de referencia. </font><font style="vertical-align: inherit;">- Predicci√≥n de datos num√©ricos y evaluaci√≥n de datos financieros utilizando m√©todos de regresi√≥n. </font><font style="vertical-align: inherit;">- Modelar procesos complejos utilizando redes neuronales es la base del aprendizaje profundo. </font><font style="vertical-align: inherit;">- Evaluaci√≥n de modelos y mejora de su rendimiento. </font><font style="vertical-align: inherit;">- Las √∫ltimas tecnolog√≠as para procesar big data, en particular R 3.6, Spark, H2O y TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPara qui√©n es el libro?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El libro est√° destinado a aquellos que esperan usar datos en un √°rea espec√≠fica. </font><font style="vertical-align: inherit;">Puede que ya est√© un poco familiarizado con el aprendizaje autom√°tico, pero nunca ha trabajado con el lenguaje R; </font><font style="vertical-align: inherit;">o, por el contrario, sabes un poco sobre R, pero casi no sabes sobre aprendizaje autom√°tico. </font><font style="vertical-align: inherit;">En cualquier caso, este libro lo ayudar√° a comenzar r√°pidamente. </font><font style="vertical-align: inherit;">Ser√≠a √∫til actualizar un poco los conceptos b√°sicos de matem√°ticas y programaci√≥n, pero no se requerir√≠a experiencia previa. </font><font style="vertical-align: inherit;">Todo lo que necesitas es un deseo de aprender.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© leer√°s en la publicaci√≥n?</font></font></b><div class="spoiler_text"> 1 ¬´   ¬ª    ,          ,      ,   ,     .<br>
<br>
 2 ¬´    ¬ª            R.         ,   ,    .<br>
<br>
 3 ¬´ :      ¬ª      ,           :     .<br>
<br>
 4 ¬´ :      ¬ª     ,       .    ,      .<br>
<br>
 5 ¬´  :       ¬ª    ,     ,    .      ,    .<br>
<br>
 6 ¬´  :  ¬ª     ,    .        ,     ,     .<br>
<br>
 7 ¬´ ‚Äú ‚Äù:      ¬ª   ,     .        ,    ,    .<br>
<br>
 8 ¬´ :       ¬ª  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 ¬´  :   k-¬ª      .         -.<br>
<br>
 10 ¬´  ¬ª    ,                  .<br>
<br>
 11 ¬´  ¬ª  ,  ,        .                ,         .<br>
<br>
 12 ¬´   ¬ª    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo: modelar la resistencia del concreto usando una red neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el campo de la ingenier√≠a civil, es extremadamente importante contar con estimaciones precisas de la efectividad de los materiales de construcci√≥n. </font><font style="vertical-align: inherit;">Estas evaluaciones son necesarias para desarrollar reglas de seguridad que rijan el uso de materiales en la construcci√≥n de edificios, puentes y carreteras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De particular inter√©s es la evaluaci√≥n de la resistencia del hormig√≥n. </font><font style="vertical-align: inherit;">El hormig√≥n se utiliza en casi cualquier construcci√≥n, las caracter√≠sticas de rendimiento del hormig√≥n son muy diferentes, ya que consta de una gran cantidad de ingredientes que interact√∫an en un complejo. </font><font style="vertical-align: inherit;">Como resultado, es dif√≠cil decir exactamente cu√°l ser√° la resistencia del producto terminado. </font><font style="vertical-align: inherit;">Un modelo que permita determinar con seguridad la resistencia del concreto, teniendo en cuenta la composici√≥n de los materiales de partida, podr√≠a proporcionar un mayor nivel de seguridad para los sitios de construcci√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 1. Recolecci√≥n de datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para este an√°lisis, utilizaremos los datos concretos de resistencia a la compresi√≥n proporcionados por I-Cheng Yeh al Dep√≥sito de aprendizaje autom√°tico de UCI (http://archive.ics.uci.edu/ml). </font><font style="vertical-align: inherit;">Como Ai-Cheng Ye utiliz√≥ con √©xito redes neuronales para modelar estos datos, intentaremos reproducir su trabajo aplicando un modelo simple de una red neuronal en R.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A juzgar por el sitio, este conjunto de datos contiene 1030 entradas sobre diferentes grados de concreto con ocho caracter√≠sticas que describen los componentes utilizados en la mezcla de concreto. </font><font style="vertical-align: inherit;">Se cree que estas caracter√≠sticas afectan la resistencia a la compresi√≥n final. </font><font style="vertical-align: inherit;">Estos incluyen: la cantidad (en kilogramos por metro c√∫bico) de cemento, agua, varios aditivos, agregados grandes y peque√±os como piedra triturada y arena utilizada en el producto terminado, as√≠ como el tiempo de fraguado (en d√≠as).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ejecutar este ejemplo, descargue el archivo concrete.csv y gu√°rdelo en el directorio de trabajo de R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 2. Investigaci√≥n y preparaci√≥n de datos.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como de costumbre, comenzamos el an√°lisis cargando los datos en el objeto R usando la funci√≥n read.csv () y nos aseguramos de que el resultado corresponda a la estructura esperada:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nueve variables en el marco de datos corresponden a ocho caracter√≠sticas y un resultado esperado, pero se hizo evidente que hay un problema. </font><font style="vertical-align: inherit;">Las redes neuronales funcionan mejor cuando los datos de entrada se escalan a un rango estrecho centrado alrededor de 0, y aqu√≠ vemos valores en el rango de 0 a m√°s de 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo general, la soluci√≥n a este problema es escalar los datos utilizando la funci√≥n de normalizaci√≥n o estandarizaci√≥n. Si la distribuci√≥n de datos corresponde a una curva en forma de campana (distribuci√≥n normal, consulte el cap√≠tulo 2), entonces puede tener sentido utilizar la estandarizaci√≥n utilizando la funci√≥n incorporada scale (). Si la distribuci√≥n de datos es casi uniforme o muy diferente de lo normal, entonces la normalizaci√≥n al rango de 0 a 1 puede ser m√°s adecuada. En este caso, utilizaremos la √∫ltima opci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el cap√≠tulo 3, creamos nuestra propia funci√≥n normalize ():</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) ‚Äî min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de ejecutar este c√≥digo, puede aplicar la funci√≥n normalizar () a todas las columnas del marco de datos seleccionado utilizando la funci√≥n lapply (): </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para verificar que la normalizaci√≥n ha funcionado, puede verificar si los valores m√≠nimo y m√°ximo del atributo de fuerza son 0 y 1, respectivamente:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A modo de comparaci√≥n: los valores m√≠nimos y m√°ximos iniciales de este atributo fueron 2,33 y 82,60, respectivamente:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier conversi√≥n aplicada a los datos antes de entrenar el modelo debe aplicarse posteriormente en el orden inverso para convertir el atributo nuevamente a las unidades originales. </font><font style="vertical-align: inherit;">Para facilitar el escalado, es aconsejable guardar los datos de origen, o al menos un resumen de las estad√≠sticas de los datos de origen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siguiendo el escenario descrito por Ye en el art√≠culo original, dividiremos los datos en un conjunto de entrenamiento, que incluye el 75% de todos los ejemplos, y un conjunto de prueba, que consiste en un 25%. </font><font style="vertical-align: inherit;">El archivo CSV utilizado se clasifica en orden aleatorio, por lo que solo podemos dividirlo en dos partes: </font><font style="vertical-align: inherit;">
utilizaremos un conjunto de datos de entrenamiento para construir una red neuronal y un conjunto de datos de prueba para evaluar qu√© tan bien el modelo se generaliza para resultados futuros. </font><font style="vertical-align: inherit;">Dado que la red neuronal se lleva f√°cilmente a un estado de reciclaje, este paso es muy importante.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 3. Entrenando el modelo en datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para modelar la relaci√≥n entre los ingredientes utilizados en la producci√≥n de concreto y la resistencia del producto terminado, construiremos una red neuronal de distribuci√≥n directa multicapa. El paquete neuralnet, desarrollado por Stefan Fritsch y Frauke Guenther, proporciona una implementaci√≥n est√°ndar y f√°cil de usar de dichas redes. Este paquete tambi√©n incluye una funci√≥n para construir una topolog√≠a de red. La implementaci√≥n de neuralnet es una buena manera de obtener informaci√≥n adicional sobre las redes neuronales, aunque esto no significa que tampoco se pueda usar para hacer un trabajo real; como ver√° pronto, es una herramienta bastante poderosa.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    ‚Äî  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que el paquete de neuralnet no est√° incluido en la base R, deber√° instalarlo escribiendo install.packages ("neuralnet") y descargarlo utilizando el comando de biblioteca (neuralnet). </font><font style="vertical-align: inherit;">La funci√≥n neuralnet () en el paquete se puede usar para entrenar redes neuronales en predicci√≥n num√©rica usando la siguiente sintaxis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis de red neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando la funci√≥n neuralnet () del paquete neuralnet </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Construyendo un modelo:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ objetivo: un modelo que se crear√° como resultado de la capacitaci√≥n en el marco de datos mydata; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ predictores: f√≥rmula R que determina las caracter√≠sticas del marco de datos mydata que se utilizar√° en la predicci√≥n; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ datos: marco de datos al que pertenecen el objetivo y los predictores; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ oculto: el n√∫mero de neuronas en la capa oculta (el valor predeterminado es 1). Nota: para describir varias capas ocultas, se utiliza un vector de enteros, por ejemplo, c (2, 2); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ act.fct - funci√≥n de activaci√≥n: "log√≠stica" o "tanh". Nota: tambi√©n se puede usar cualquier otra funci√≥n diferenciable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n devuelve un objeto de red neuronal que puede usarse para pronosticar. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicci√≥n:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- calcular (m, prueba)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ m - modelo entrenado usando la funci√≥n neuralnet (); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ prueba: un marco de datos que contiene datos de prueba con las mismas caracter√≠sticas que los datos de entrenamiento utilizados para construir el clasificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n devuelve una lista que consta de dos componentes: $ neuronas, donde se almacenan las neuronas para cada capa de red, y $ net.result, donde se almacenan los valores pronosticados con este modelo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos entrenando la red de distribuci√≥n directa multinivel m√°s simple con par√°metros predeterminados, que tiene solo un nodo oculto:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, como se muestra en la fig. </font><font style="vertical-align: inherit;">7.11, puede visualizar la topolog√≠a de la red utilizando la funci√≥n plot () y pasarle el objeto modelo resultante:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este modelo simple, hay un nodo de entrada para cada una de las ocho caracter√≠sticas, luego hay un nodo oculto y uno de salida, que proporciona un pron√≥stico de la resistencia del concreto. </font><font style="vertical-align: inherit;">El diagrama tambi√©n muestra los pesos para cada enlace y el valor de desplazamiento indicado para los nodos marcados con el n√∫mero 1. El valor de desplazamiento es una constante num√©rica que le permite cambiar el valor en el nodo especificado hacia arriba o hacia abajo, aproximadamente como un cambio en una ecuaci√≥n lineal.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una red neuronal con un nodo oculto puede considerarse el "primo" de los modelos de regresi√≥n lineal discutidos en el Cap√≠tulo 6. Los pesos entre los nodos de entrada y el nodo oculto son similares a los coeficientes beta, y el peso de compensaci√≥n es como un cambio.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte inferior de la figura, se muestra el n√∫mero de pasos de entrenamiento y la magnitud del error: el error cuadr√°tico medio total (Suma de errores al cuadrado, SSE), que, como se esperaba, es la suma de las diferencias al cuadrado entre los valores predichos y reales. </font><font style="vertical-align: inherit;">Cuanto m√°s peque√±o es el SSE, m√°s exactamente coincide el modelo con los datos de entrenamiento, lo que indica la efectividad de estos datos, pero dice poco sobre c√≥mo funcionar√° el modelo con datos desconocidos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 4. Evaluar la efectividad del modelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El diagrama de topolog√≠a de red brinda la oportunidad de examinar el "recuadro negro" de una red neuronal, pero no proporciona mucha informaci√≥n sobre qu√© tan bien el modelo coincide con datos futuros. Para generar pron√≥sticos en un conjunto de datos de prueba, puede usar la funci√≥n compute (): </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n compute () funciona de manera un poco diferente a las funciones predict () que hemos usado hasta ahora. Devuelve una lista que consta de dos componentes: $ neuronas, donde se almacenan las neuronas para cada capa de red, y $ net.result, donde se almacenan los valores pronosticados. Es $ net.result lo que necesitamos:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que tenemos la tarea del pron√≥stico num√©rico, no la clasificaci√≥n, no podemos usar la matriz de inconsistencias para verificar la precisi√≥n del modelo. </font><font style="vertical-align: inherit;">Medimos la correlaci√≥n entre el valor predicho y el verdadero valor de la resistencia del concreto. </font><font style="vertical-align: inherit;">Si los valores predichos y reales se correlacionan fuertemente, entonces, probablemente, el modelo ser√° √∫til para determinar la resistencia del concreto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perm√≠tame recordarle que para obtener la correlaci√≥n entre dos vectores num√©ricos, se utiliza la funci√≥n cor ():</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se alarme si su resultado difiere del nuestro. </font><font style="vertical-align: inherit;">Dado que la red neuronal comienza a trabajar con pesos aleatorios, las predicciones presentadas en el libro pueden ser diferentes para diferentes modelos. </font><font style="vertical-align: inherit;">Si desea hacer coincidir con precisi√≥n los resultados, pruebe el comando set.seed (12345) antes de comenzar a construir una red neuronal.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la correlaci√≥n es cercana a 1, esto indica una fuerte relaci√≥n lineal entre las dos variables. </font><font style="vertical-align: inherit;">Por lo tanto, una correlaci√≥n de aproximadamente 0,806 indica una relaci√≥n bastante fuerte. </font><font style="vertical-align: inherit;">Esto significa que el modelo funciona bastante bien incluso con un √∫nico nodo oculto. </font><font style="vertical-align: inherit;">Dado que usamos solo un nodo oculto, es probable que podamos mejorar la eficiencia del modelo, lo que intentaremos hacer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 5. Mejora de la eficiencia del modelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que las redes con una topolog√≠a m√°s compleja pueden estudiar conceptos m√°s complejos, veamos qu√© sucede si aumenta el n√∫mero de nodos ocultos a cinco. </font><font style="vertical-align: inherit;">Usaremos la funci√≥n neuralnet (), como antes, pero agregaremos el par√°metro hidden = 5:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez construido el diagrama de red nuevamente (Fig. 7.12), veremos un fuerte aumento en el n√∫mero de conexiones. ¬øC√≥mo ha afectado esto a la eficiencia? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que el error resultante (nuevamente medido como SSE) disminuy√≥ de 5.08 en el modelo anterior a 1.63. Adem√°s, el n√∫mero de etapas de entrenamiento aument√≥ de 4882 a 86,849, lo cual no es sorprendente, dado lo complicado que es el modelo. Cuanto m√°s compleja es la red, se requieren m√°s iteraciones para encontrar los pesos √≥ptimos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicando los mismos pasos para comparar los valores pronosticados con los verdaderos, obtenemos una correlaci√≥n de aproximadamente 0,92, que es mucho mejor en comparaci√≥n con el resultado anterior de 0,80 para una red con un nodo oculto:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de las mejoras significativas, puede ir a√∫n m√°s lejos para aumentar la efectividad del modelo. En particular, es posible introducir capas ocultas adicionales y cambiar la funci√≥n de activaci√≥n de la red. Al realizar estos cambios, estamos sentando las bases para construir una red neuronal profunda simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La elecci√≥n de la funci√≥n de activaci√≥n es muy importante para el aprendizaje profundo. La mejor funci√≥n para una tarea de aprendizaje en particular generalmente se encuentra experimentalmente, y luego es ampliamente utilizada por la comunidad de investigadores de aprendizaje autom√°tico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente, la funci√≥n de activaci√≥n, llamada funci√≥n de destilaci√≥n, o rectificador, se ha vuelto muy popular debido a su aplicaci√≥n exitosa en tareas complejas, como el reconocimiento de im√°genes. Un nodo de red neuronal en el que se utiliza un rectificador como funci√≥n de activaci√≥n se denomina Unidad lineal rectificada (ReLU). Como se muestra en la fig. 7.13, la funci√≥n de activaci√≥n de tipo rectificador se describe de tal manera que devuelve x si x es mayor o igual a 0, y 0 en caso contrario. La importancia de esta funci√≥n es que, por un lado, no es lineal y, por otro, tiene propiedades matem√°ticas simples que la hacen computacionalmente econ√≥mica y altamente eficiente para el descenso de gradiente. Desafortunadamente, para x = 0, la derivada del rectificador no est√° definida,por lo tanto, el rectificador no se puede usar junto con la funci√≥n neuralnet ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cambio, puede usar una aproximaci√≥n suavizada de ReLU llamada softplus o SmoothReLU, una funci√≥n de activaci√≥n definida como log (1 + ex). </font><font style="vertical-align: inherit;">Como se muestra en la fig. </font><font style="vertical-align: inherit;">7.13, la funci√≥n softplus es cercana a cero para valores x menores que 0 y aproximadamente igual a x para x mayores que 0.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para definir la funci√≥n softplus () en R, usamos el siguiente c√≥digo: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal funci√≥n de activaci√≥n se puede proporcionar a la entrada neuralnet () usando el par√°metro act.fct. </font><font style="vertical-align: inherit;">Adem√°s, agregamos una segunda capa oculta que consta de cinco nodos, asignando al par√°metro oculto el valor del vector entero c (5, 5). </font><font style="vertical-align: inherit;">Como resultado, obtenemos una red de dos capas, cada una de las cuales tiene cinco nodos, y todos utilizan la funci√≥n de activaci√≥n softplus:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, la red se puede visualizar (Fig. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La correlaci√≥n entre la resistencia prevista y la real del concreto se puede calcular de la siguiente manera:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La correlaci√≥n entre la fuerza pronosticada y la real fue de 0.935, que es el mejor indicador obtenido hasta ahora. Curiosamente, en la publicaci√≥n original, Ye inform√≥ una correlaci√≥n de 0.885. Esto significa que, con relativamente poco esfuerzo, pudimos obtener un resultado comparable e incluso superar los resultados de un experto en este campo. Es cierto que los resultados de Ye se publicaron en 1998, lo que nos dio una ventaja sobre m√°s de 20 a√±os de investigaci√≥n adicional en el campo de las redes neuronales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro detalle importante debe tenerse en cuenta: dado que normalizamos los datos antes de entrenar el modelo, los pron√≥sticos tambi√©n est√°n en el intervalo normalizado de 0 a 1. Por ejemplo, el siguiente c√≥digo muestra un marco de datos que compara l√≠nea por l√≠nea los valores de resistencia concretos del conjunto de datos inicial con los pron√≥sticos correspondientes:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinando la correlaci√≥n, vemos que la elecci√≥n de datos normalizados o no normalizados no afecta las estad√≠sticas de rendimiento calculadas, al igual que antes, la correlaci√≥n es 0.935: </font><font style="vertical-align: inherit;">
Pero si calculamos un indicador de rendimiento diferente, por ejemplo, la diferencia absoluta entre los valores predichos y los reales, entonces La elecci√≥n de la escala ser√≠a muy importante. </font><font style="vertical-align: inherit;">
Con esto en mente, puede crear la funci√≥n unnormalize () que realizar√≠a el reverso de la normalizaci√≥n minimax y le permitir√≠a convertir pron√≥sticos normalizados a la escala original:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de aplicar la funci√≥n unnormalize () que escribimos a los pron√≥sticos, queda claro que la escala de los nuevos pron√≥sticos es similar a los valores iniciales de la resistencia del concreto. </font><font style="vertical-align: inherit;">Esto le permite calcular el valor significativo del error absoluto. </font><font style="vertical-align: inherit;">Adem√°s, la correlaci√≥n entre los valores de resistencia anormales e iniciales permanece sin cambios:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new ‚Äî strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al aplicar redes neuronales a sus proyectos, debe seguir una secuencia similar de pasos para devolver los datos a su escala original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n puede descubrir que las redes neuronales se est√°n volviendo cada vez m√°s complejas a medida que se utilizan para tareas de aprendizaje cada vez m√°s dif√≠ciles. Por ejemplo, puede encontrar el llamado problema de gradiente peque√±o ‚Äúdesapareciendo‚Äù y el problema de gradiente ‚Äúexplotando‚Äù estrechamente relacionado cuando el algoritmo de propagaci√≥n inversa no encuentra una soluci√≥n √∫til porque no converge en un tiempo razonable. Para resolver estos problemas, puede intentar cambiar el n√∫mero de nodos ocultos, aplicar varias funciones de activaci√≥n, como ReLU, ajustar la velocidad de aprendizaje, etc. En la p√°gina de ayuda para la funci√≥n de red neuronal, encontrar√° informaci√≥n adicional sobre los diversos par√°metros que se pueden configurar. Sin embargo, esto lleva a otro problema,cuando el cuello de botella en la construcci√≥n de un modelo altamente eficiente est√° verificando una gran cantidad de par√°metros. Este es el precio del uso de redes neuronales, y a√∫n m√°s redes de aprendizaje profundo: su enorme potencial requiere mucho tiempo y potencia de procesamiento.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El m√©todo de la m√°quina de vectores de soporte (SVM) se puede representar como una superficie que forma el l√≠mite entre los puntos de datos trazados en un espacio multidimensional que describe ejemplos y valores de sus atributos. El objetivo de SVM es construir un borde plano, un hiperplano que divide el espacio de tal manera que se formen grupos homog√©neos en ambos lados. Por lo tanto, el entrenamiento de SVM combina aspectos del entrenamiento del vecino m√°s cercano en base a las instancias descritas en el Cap√≠tulo 3 y el modelado de regresi√≥n lineal descrito en el Cap√≠tulo 6. Esta es una combinaci√≥n extremadamente poderosa que permite a los SVM modelar relaciones muy complejas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar del hecho de que las matem√°ticas b√°sicas subyacentes a la SVM han existido durante d√©cadas, el inter√©s en estos m√©todos ha crecido significativamente despu√©s de que comenzaron a aplicarse a ML. La popularidad de estos m√©todos aument√≥ despu√©s de historias de √©xito de alto perfil en la resoluci√≥n de problemas de aprendizaje complejos, as√≠ como despu√©s del desarrollo de algoritmos SVM, que se otorgaron e implementaron en bibliotecas bien compatibles en muchos lenguajes de programaci√≥n, incluido R. Despu√©s de eso, los m√©todos SVM fueron aceptados por una amplia audiencia. De lo contrario, probablemente ser√≠a imposible aplicar las matem√°ticas complejas necesarias para implementar SVM. La buena noticia es que, aunque las matem√°ticas son posiblemente complejas, los conceptos b√°sicos son comprensibles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los m√©todos SVM se pueden adaptar para usar casi cualquier tipo de tarea de capacitaci√≥n, incluida la clasificaci√≥n y el pron√≥stico num√©rico. </font><font style="vertical-align: inherit;">Muchos de los √©xitos clave de este algoritmo se relacionan con el reconocimiento de patrones. </font><font style="vertical-align: inherit;">Las aplicaciones m√°s conocidas para estos m√©todos incluyen las siguientes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clasificaci√≥n de datos sobre la expresi√≥n de genes de microarrays en bioinform√°tica para la detecci√≥n de c√°ncer y otras enfermedades gen√©ticas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">categorizaci√≥n de texto, como determinar el idioma utilizado en un documento o clasificar documentos por tema;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detecci√≥n de eventos raros pero importantes, como la falla de un motor de combusti√≥n interna, una violaci√≥n de seguridad o un terremoto.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los m√©todos SVM son m√°s f√°ciles de entender utilizando la clasificaci√≥n binaria como ejemplo; as√≠ es como se usan generalmente. </font><font style="vertical-align: inherit;">Por lo tanto, en las secciones restantes, nos centraremos solo en los clasificadores SVM. </font><font style="vertical-align: inherit;">Principios similares a los presentados aqu√≠ tambi√©n se utilizan al adaptar los m√©todos SVM para el pron√≥stico num√©rico.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre el Autor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) ha estado utilizando t√©cnicas innovadoras de procesamiento de datos para estudiar el comportamiento humano durante m√°s de una d√©cada. </font><font style="vertical-align: inherit;">Siendo un soci√≥logo de formaci√≥n, Brett se interes√≥ por primera vez en el aprendizaje autom√°tico mientras exploraba una gran base de datos de perfiles de adolescentes en las redes sociales. </font><font style="vertical-align: inherit;">Brett es profesor en DataCamp y a menudo hace presentaciones en conferencias y seminarios de aprendizaje autom√°tico en todo el mundo. </font><font style="vertical-align: inherit;">Es un conocido entusiasta en el campo de la aplicaci√≥n pr√°ctica de la ciencia de datos en el campo de los deportes, los veh√≠culos no tripulados, el estudio de lenguas extranjeras y la moda, as√≠ como en muchas otras industrias. </font><font style="vertical-align: inherit;">Brett espera alg√∫n d√≠a escribir sobre todo esto en dataspelunking.com, un intercambio de conocimientos sobre c√≥mo encontrar patrones en los datos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre el editor de ciencias</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - investigador principal de una de las organizaciones de atenci√≥n m√©dica m√°s grandes del mundo. Se dedica a la investigaci√≥n y el desarrollo de soluciones corporativas basadas en el aprendizaje autom√°tico, el aprendizaje profundo y el procesamiento del lenguaje natural para su uso en la atenci√≥n m√©dica y los seguros. En su puesto anterior en Intel, particip√≥ en iniciativas proactivas en el campo de la tecnolog√≠a de la informaci√≥n, basadas en big data, utilizando procesamiento de lenguaje natural, aprendizaje profundo y m√©todos estad√≠sticos tradicionales. En American Express, trabaj√≥ en compromiso digital y retenci√≥n de clientes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav es autor de varios libros publicados por editoriales l√≠deres. </font><font style="vertical-align: inherit;">Su √∫ltimo libro es sobre lo √∫ltimo en estudio de transferencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav se gradu√≥ en el Instituto Internacional de Tecnolog√≠a de la Informaci√≥n en Bangalore, tiene una maestr√≠a (con honores). </font><font style="vertical-align: inherit;">En esos raros momentos en que no est√° ocupado resolviendo problemas cient√≠ficos, a Raghav le gusta leer y fotografiar todo en una fila. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬ªSe puede encontrar m√°s informaci√≥n sobre el libro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el sitio web del editor</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extracto de</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Khabrozhiteley 25% de descuento en el cup√≥n - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprendizaje autom√°tico</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Al pagar la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es496242/index.html">Cyberpunk ya est√° aqu√≠: los escolares estudian en Minecraft y los estudiantes toman ex√°menes f√≠sicos en CS: GO</a></li>
<li><a href="../es496248/index.html">Retos, calvas y vino. C√≥mo nosotros en HFLabs soportamos el autoaislamiento</a></li>
<li><a href="../es496250/index.html">¬øC√≥mo extra√±o c√≥digo oculta errores? An√°lisis TensorFlow.NET</a></li>
<li><a href="../es496252/index.html">Aeronaves de centrado con desplazamiento aerodin√°mico</a></li>
<li><a href="../es496254/index.html">C√≥mo Rostelecom redirigi√≥ el tr√°fico por error a Google, AWS, Cloudflare, etc.</a></li>
<li><a href="../es496258/index.html">Holivar en l√≠nea: un nuevo formato para el intercambio de experiencias. Este s√°bado</a></li>
<li><a href="../es496260/index.html">Consejos de ciberseguridad para trabajar desde casa</a></li>
<li><a href="../es496262/index.html">Obtener ID de CVE</a></li>
<li><a href="../es496266/index.html">Coronavirus: ¬ømoriremos todos?</a></li>
<li><a href="../es496268/index.html">Productos y soluciones de red de Huawei Enterprise para clientes empresariales en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>