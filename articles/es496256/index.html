<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏾 🔌 👧 Aprendizaje automático en R: técnicas expertas para el análisis predictivo 🤵 😨 🛶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! El lenguaje R ofrece un poderoso conjunto de métodos de aprendizaje automático que le permiten realizar rápidamente análisis no tri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Aprendizaje automático en R: técnicas expertas para el análisis predictivo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="imagen"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola habrozhiteli! El lenguaje R ofrece un poderoso conjunto de métodos de aprendizaje automático que le permiten realizar rápidamente análisis no triviales de sus datos. El libro es una guía que ayudará a aplicar métodos de aprendizaje automático para resolver problemas cotidianos. Brett Lanz le enseñará todo lo que necesita para el análisis, pronóstico y visualización de datos. Aquí encontrará información sobre bibliotecas nuevas y mejoradas, consejos sobre los aspectos éticos del aprendizaje automático y los problemas de sesgo, así como capacitación en profundidad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este libro: Fundamentos del aprendizaje automático y características de la capacitación en informática en ejemplos. </font><font style="vertical-align: inherit;">- Preparación de datos para su uso en el aprendizaje automático mediante el lenguaje R. - Clasificación de la importancia de los resultados. </font><font style="vertical-align: inherit;">- Predicción de eventos utilizando árboles de decisión, reglas y vectores de referencia. </font><font style="vertical-align: inherit;">- Predicción de datos numéricos y evaluación de datos financieros utilizando métodos de regresión. </font><font style="vertical-align: inherit;">- Modelar procesos complejos utilizando redes neuronales es la base del aprendizaje profundo. </font><font style="vertical-align: inherit;">- Evaluación de modelos y mejora de su rendimiento. </font><font style="vertical-align: inherit;">- Las últimas tecnologías para procesar big data, en particular R 3.6, Spark, H2O y TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Para quién es el libro?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El libro está destinado a aquellos que esperan usar datos en un área específica. </font><font style="vertical-align: inherit;">Puede que ya esté un poco familiarizado con el aprendizaje automático, pero nunca ha trabajado con el lenguaje R; </font><font style="vertical-align: inherit;">o, por el contrario, sabes un poco sobre R, pero casi no sabes sobre aprendizaje automático. </font><font style="vertical-align: inherit;">En cualquier caso, este libro lo ayudará a comenzar rápidamente. </font><font style="vertical-align: inherit;">Sería útil actualizar un poco los conceptos básicos de matemáticas y programación, pero no se requeriría experiencia previa. </font><font style="vertical-align: inherit;">Todo lo que necesitas es un deseo de aprender.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué leerás en la publicación?</font></font></b><div class="spoiler_text"> 1 «   »    ,          ,      ,   ,     .<br>
<br>
 2 «    »            R.         ,   ,    .<br>
<br>
 3 « :      »      ,           :     .<br>
<br>
 4 « :      »     ,       .    ,      .<br>
<br>
 5 «  :       »    ,     ,    .      ,    .<br>
<br>
 6 «  :  »     ,    .        ,     ,     .<br>
<br>
 7 « “ ”:      »   ,     .        ,    ,    .<br>
<br>
 8 « :       »  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 «  :   k-»      .         -.<br>
<br>
 10 «  »    ,                  .<br>
<br>
 11 «  »  ,  ,        .                ,         .<br>
<br>
 12 «   »    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo: modelar la resistencia del concreto usando una red neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el campo de la ingeniería civil, es extremadamente importante contar con estimaciones precisas de la efectividad de los materiales de construcción. </font><font style="vertical-align: inherit;">Estas evaluaciones son necesarias para desarrollar reglas de seguridad que rijan el uso de materiales en la construcción de edificios, puentes y carreteras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De particular interés es la evaluación de la resistencia del hormigón. </font><font style="vertical-align: inherit;">El hormigón se utiliza en casi cualquier construcción, las características de rendimiento del hormigón son muy diferentes, ya que consta de una gran cantidad de ingredientes que interactúan en un complejo. </font><font style="vertical-align: inherit;">Como resultado, es difícil decir exactamente cuál será la resistencia del producto terminado. </font><font style="vertical-align: inherit;">Un modelo que permita determinar con seguridad la resistencia del concreto, teniendo en cuenta la composición de los materiales de partida, podría proporcionar un mayor nivel de seguridad para los sitios de construcción.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 1. Recolección de datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para este análisis, utilizaremos los datos concretos de resistencia a la compresión proporcionados por I-Cheng Yeh al Depósito de aprendizaje automático de UCI (http://archive.ics.uci.edu/ml). </font><font style="vertical-align: inherit;">Como Ai-Cheng Ye utilizó con éxito redes neuronales para modelar estos datos, intentaremos reproducir su trabajo aplicando un modelo simple de una red neuronal en R.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A juzgar por el sitio, este conjunto de datos contiene 1030 entradas sobre diferentes grados de concreto con ocho características que describen los componentes utilizados en la mezcla de concreto. </font><font style="vertical-align: inherit;">Se cree que estas características afectan la resistencia a la compresión final. </font><font style="vertical-align: inherit;">Estos incluyen: la cantidad (en kilogramos por metro cúbico) de cemento, agua, varios aditivos, agregados grandes y pequeños como piedra triturada y arena utilizada en el producto terminado, así como el tiempo de fraguado (en días).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ejecutar este ejemplo, descargue el archivo concrete.csv y guárdelo en el directorio de trabajo de R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 2. Investigación y preparación de datos.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como de costumbre, comenzamos el análisis cargando los datos en el objeto R usando la función read.csv () y nos aseguramos de que el resultado corresponda a la estructura esperada:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nueve variables en el marco de datos corresponden a ocho características y un resultado esperado, pero se hizo evidente que hay un problema. </font><font style="vertical-align: inherit;">Las redes neuronales funcionan mejor cuando los datos de entrada se escalan a un rango estrecho centrado alrededor de 0, y aquí vemos valores en el rango de 0 a más de 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo general, la solución a este problema es escalar los datos utilizando la función de normalización o estandarización. Si la distribución de datos corresponde a una curva en forma de campana (distribución normal, consulte el capítulo 2), entonces puede tener sentido utilizar la estandarización utilizando la función incorporada scale (). Si la distribución de datos es casi uniforme o muy diferente de lo normal, entonces la normalización al rango de 0 a 1 puede ser más adecuada. En este caso, utilizaremos la última opción. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el capítulo 3, creamos nuestra propia función normalize ():</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) — min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de ejecutar este código, puede aplicar la función normalizar () a todas las columnas del marco de datos seleccionado utilizando la función lapply (): </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para verificar que la normalización ha funcionado, puede verificar si los valores mínimo y máximo del atributo de fuerza son 0 y 1, respectivamente:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A modo de comparación: los valores mínimos y máximos iniciales de este atributo fueron 2,33 y 82,60, respectivamente:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier conversión aplicada a los datos antes de entrenar el modelo debe aplicarse posteriormente en el orden inverso para convertir el atributo nuevamente a las unidades originales. </font><font style="vertical-align: inherit;">Para facilitar el escalado, es aconsejable guardar los datos de origen, o al menos un resumen de las estadísticas de los datos de origen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siguiendo el escenario descrito por Ye en el artículo original, dividiremos los datos en un conjunto de entrenamiento, que incluye el 75% de todos los ejemplos, y un conjunto de prueba, que consiste en un 25%. </font><font style="vertical-align: inherit;">El archivo CSV utilizado se clasifica en orden aleatorio, por lo que solo podemos dividirlo en dos partes: </font><font style="vertical-align: inherit;">
utilizaremos un conjunto de datos de entrenamiento para construir una red neuronal y un conjunto de datos de prueba para evaluar qué tan bien el modelo se generaliza para resultados futuros. </font><font style="vertical-align: inherit;">Dado que la red neuronal se lleva fácilmente a un estado de reciclaje, este paso es muy importante.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 3. Entrenando el modelo en datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para modelar la relación entre los ingredientes utilizados en la producción de concreto y la resistencia del producto terminado, construiremos una red neuronal de distribución directa multicapa. El paquete neuralnet, desarrollado por Stefan Fritsch y Frauke Guenther, proporciona una implementación estándar y fácil de usar de dichas redes. Este paquete también incluye una función para construir una topología de red. La implementación de neuralnet es una buena manera de obtener información adicional sobre las redes neuronales, aunque esto no significa que tampoco se pueda usar para hacer un trabajo real; como verá pronto, es una herramienta bastante poderosa.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    —  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que el paquete de neuralnet no está incluido en la base R, deberá instalarlo escribiendo install.packages ("neuralnet") y descargarlo utilizando el comando de biblioteca (neuralnet). </font><font style="vertical-align: inherit;">La función neuralnet () en el paquete se puede usar para entrenar redes neuronales en predicción numérica usando la siguiente sintaxis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis de red neuronal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando la función neuralnet () del paquete neuralnet </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Construyendo un modelo:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• objetivo: un modelo que se creará como resultado de la capacitación en el marco de datos mydata; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• predictores: fórmula R que determina las características del marco de datos mydata que se utilizará en la predicción; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• datos: marco de datos al que pertenecen el objetivo y los predictores; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• oculto: el número de neuronas en la capa oculta (el valor predeterminado es 1). Nota: para describir varias capas ocultas, se utiliza un vector de enteros, por ejemplo, c (2, 2); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• act.fct - función de activación: "logística" o "tanh". Nota: también se puede usar cualquier otra función diferenciable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función devuelve un objeto de red neuronal que puede usarse para pronosticar. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicción:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- calcular (m, prueba)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• m - modelo entrenado usando la función neuralnet (); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• prueba: un marco de datos que contiene datos de prueba con las mismas características que los datos de entrenamiento utilizados para construir el clasificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función devuelve una lista que consta de dos componentes: $ neuronas, donde se almacenan las neuronas para cada capa de red, y $ net.result, donde se almacenan los valores pronosticados con este modelo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos entrenando la red de distribución directa multinivel más simple con parámetros predeterminados, que tiene solo un nodo oculto:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, como se muestra en la fig. </font><font style="vertical-align: inherit;">7.11, puede visualizar la topología de la red utilizando la función plot () y pasarle el objeto modelo resultante:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este modelo simple, hay un nodo de entrada para cada una de las ocho características, luego hay un nodo oculto y uno de salida, que proporciona un pronóstico de la resistencia del concreto. </font><font style="vertical-align: inherit;">El diagrama también muestra los pesos para cada enlace y el valor de desplazamiento indicado para los nodos marcados con el número 1. El valor de desplazamiento es una constante numérica que le permite cambiar el valor en el nodo especificado hacia arriba o hacia abajo, aproximadamente como un cambio en una ecuación lineal.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una red neuronal con un nodo oculto puede considerarse el "primo" de los modelos de regresión lineal discutidos en el Capítulo 6. Los pesos entre los nodos de entrada y el nodo oculto son similares a los coeficientes beta, y el peso de compensación es como un cambio.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte inferior de la figura, se muestra el número de pasos de entrenamiento y la magnitud del error: el error cuadrático medio total (Suma de errores al cuadrado, SSE), que, como se esperaba, es la suma de las diferencias al cuadrado entre los valores predichos y reales. </font><font style="vertical-align: inherit;">Cuanto más pequeño es el SSE, más exactamente coincide el modelo con los datos de entrenamiento, lo que indica la efectividad de estos datos, pero dice poco sobre cómo funcionará el modelo con datos desconocidos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 4. Evaluar la efectividad del modelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El diagrama de topología de red brinda la oportunidad de examinar el "recuadro negro" de una red neuronal, pero no proporciona mucha información sobre qué tan bien el modelo coincide con datos futuros. Para generar pronósticos en un conjunto de datos de prueba, puede usar la función compute (): </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función compute () funciona de manera un poco diferente a las funciones predict () que hemos usado hasta ahora. Devuelve una lista que consta de dos componentes: $ neuronas, donde se almacenan las neuronas para cada capa de red, y $ net.result, donde se almacenan los valores pronosticados. Es $ net.result lo que necesitamos:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que tenemos la tarea del pronóstico numérico, no la clasificación, no podemos usar la matriz de inconsistencias para verificar la precisión del modelo. </font><font style="vertical-align: inherit;">Medimos la correlación entre el valor predicho y el verdadero valor de la resistencia del concreto. </font><font style="vertical-align: inherit;">Si los valores predichos y reales se correlacionan fuertemente, entonces, probablemente, el modelo será útil para determinar la resistencia del concreto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permítame recordarle que para obtener la correlación entre dos vectores numéricos, se utiliza la función cor ():</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se alarme si su resultado difiere del nuestro. </font><font style="vertical-align: inherit;">Dado que la red neuronal comienza a trabajar con pesos aleatorios, las predicciones presentadas en el libro pueden ser diferentes para diferentes modelos. </font><font style="vertical-align: inherit;">Si desea hacer coincidir con precisión los resultados, pruebe el comando set.seed (12345) antes de comenzar a construir una red neuronal.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la correlación es cercana a 1, esto indica una fuerte relación lineal entre las dos variables. </font><font style="vertical-align: inherit;">Por lo tanto, una correlación de aproximadamente 0,806 indica una relación bastante fuerte. </font><font style="vertical-align: inherit;">Esto significa que el modelo funciona bastante bien incluso con un único nodo oculto. </font><font style="vertical-align: inherit;">Dado que usamos solo un nodo oculto, es probable que podamos mejorar la eficiencia del modelo, lo que intentaremos hacer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 5. Mejora de la eficiencia del modelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que las redes con una topología más compleja pueden estudiar conceptos más complejos, veamos qué sucede si aumenta el número de nodos ocultos a cinco. </font><font style="vertical-align: inherit;">Usaremos la función neuralnet (), como antes, pero agregaremos el parámetro hidden = 5:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez construido el diagrama de red nuevamente (Fig. 7.12), veremos un fuerte aumento en el número de conexiones. ¿Cómo ha afectado esto a la eficiencia? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que el error resultante (nuevamente medido como SSE) disminuyó de 5.08 en el modelo anterior a 1.63. Además, el número de etapas de entrenamiento aumentó de 4882 a 86,849, lo cual no es sorprendente, dado lo complicado que es el modelo. Cuanto más compleja es la red, se requieren más iteraciones para encontrar los pesos óptimos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicando los mismos pasos para comparar los valores pronosticados con los verdaderos, obtenemos una correlación de aproximadamente 0,92, que es mucho mejor en comparación con el resultado anterior de 0,80 para una red con un nodo oculto:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de las mejoras significativas, puede ir aún más lejos para aumentar la efectividad del modelo. En particular, es posible introducir capas ocultas adicionales y cambiar la función de activación de la red. Al realizar estos cambios, estamos sentando las bases para construir una red neuronal profunda simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La elección de la función de activación es muy importante para el aprendizaje profundo. La mejor función para una tarea de aprendizaje en particular generalmente se encuentra experimentalmente, y luego es ampliamente utilizada por la comunidad de investigadores de aprendizaje automático.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente, la función de activación, llamada función de destilación, o rectificador, se ha vuelto muy popular debido a su aplicación exitosa en tareas complejas, como el reconocimiento de imágenes. Un nodo de red neuronal en el que se utiliza un rectificador como función de activación se denomina Unidad lineal rectificada (ReLU). Como se muestra en la fig. 7.13, la función de activación de tipo rectificador se describe de tal manera que devuelve x si x es mayor o igual a 0, y 0 en caso contrario. La importancia de esta función es que, por un lado, no es lineal y, por otro, tiene propiedades matemáticas simples que la hacen computacionalmente económica y altamente eficiente para el descenso de gradiente. Desafortunadamente, para x = 0, la derivada del rectificador no está definida,por lo tanto, el rectificador no se puede usar junto con la función neuralnet ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cambio, puede usar una aproximación suavizada de ReLU llamada softplus o SmoothReLU, una función de activación definida como log (1 + ex). </font><font style="vertical-align: inherit;">Como se muestra en la fig. </font><font style="vertical-align: inherit;">7.13, la función softplus es cercana a cero para valores x menores que 0 y aproximadamente igual a x para x mayores que 0.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para definir la función softplus () en R, usamos el siguiente código: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal función de activación se puede proporcionar a la entrada neuralnet () usando el parámetro act.fct. </font><font style="vertical-align: inherit;">Además, agregamos una segunda capa oculta que consta de cinco nodos, asignando al parámetro oculto el valor del vector entero c (5, 5). </font><font style="vertical-align: inherit;">Como resultado, obtenemos una red de dos capas, cada una de las cuales tiene cinco nodos, y todos utilizan la función de activación softplus:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, la red se puede visualizar (Fig. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La correlación entre la resistencia prevista y la real del concreto se puede calcular de la siguiente manera:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La correlación entre la fuerza pronosticada y la real fue de 0.935, que es el mejor indicador obtenido hasta ahora. Curiosamente, en la publicación original, Ye informó una correlación de 0.885. Esto significa que, con relativamente poco esfuerzo, pudimos obtener un resultado comparable e incluso superar los resultados de un experto en este campo. Es cierto que los resultados de Ye se publicaron en 1998, lo que nos dio una ventaja sobre más de 20 años de investigación adicional en el campo de las redes neuronales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro detalle importante debe tenerse en cuenta: dado que normalizamos los datos antes de entrenar el modelo, los pronósticos también están en el intervalo normalizado de 0 a 1. Por ejemplo, el siguiente código muestra un marco de datos que compara línea por línea los valores de resistencia concretos del conjunto de datos inicial con los pronósticos correspondientes:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinando la correlación, vemos que la elección de datos normalizados o no normalizados no afecta las estadísticas de rendimiento calculadas, al igual que antes, la correlación es 0.935: </font><font style="vertical-align: inherit;">
Pero si calculamos un indicador de rendimiento diferente, por ejemplo, la diferencia absoluta entre los valores predichos y los reales, entonces La elección de la escala sería muy importante. </font><font style="vertical-align: inherit;">
Con esto en mente, puede crear la función unnormalize () que realizaría el reverso de la normalización minimax y le permitiría convertir pronósticos normalizados a la escala original:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de aplicar la función unnormalize () que escribimos a los pronósticos, queda claro que la escala de los nuevos pronósticos es similar a los valores iniciales de la resistencia del concreto. </font><font style="vertical-align: inherit;">Esto le permite calcular el valor significativo del error absoluto. </font><font style="vertical-align: inherit;">Además, la correlación entre los valores de resistencia anormales e iniciales permanece sin cambios:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new — strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al aplicar redes neuronales a sus proyectos, debe seguir una secuencia similar de pasos para devolver los datos a su escala original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puede descubrir que las redes neuronales se están volviendo cada vez más complejas a medida que se utilizan para tareas de aprendizaje cada vez más difíciles. Por ejemplo, puede encontrar el llamado problema de gradiente pequeño “desapareciendo” y el problema de gradiente “explotando” estrechamente relacionado cuando el algoritmo de propagación inversa no encuentra una solución útil porque no converge en un tiempo razonable. Para resolver estos problemas, puede intentar cambiar el número de nodos ocultos, aplicar varias funciones de activación, como ReLU, ajustar la velocidad de aprendizaje, etc. En la página de ayuda para la función de red neuronal, encontrará información adicional sobre los diversos parámetros que se pueden configurar. Sin embargo, esto lleva a otro problema,cuando el cuello de botella en la construcción de un modelo altamente eficiente está verificando una gran cantidad de parámetros. Este es el precio del uso de redes neuronales, y aún más redes de aprendizaje profundo: su enorme potencial requiere mucho tiempo y potencia de procesamiento.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método de la máquina de vectores de soporte (SVM) se puede representar como una superficie que forma el límite entre los puntos de datos trazados en un espacio multidimensional que describe ejemplos y valores de sus atributos. El objetivo de SVM es construir un borde plano, un hiperplano que divide el espacio de tal manera que se formen grupos homogéneos en ambos lados. Por lo tanto, el entrenamiento de SVM combina aspectos del entrenamiento del vecino más cercano en base a las instancias descritas en el Capítulo 3 y el modelado de regresión lineal descrito en el Capítulo 6. Esta es una combinación extremadamente poderosa que permite a los SVM modelar relaciones muy complejas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar del hecho de que las matemáticas básicas subyacentes a la SVM han existido durante décadas, el interés en estos métodos ha crecido significativamente después de que comenzaron a aplicarse a ML. La popularidad de estos métodos aumentó después de historias de éxito de alto perfil en la resolución de problemas de aprendizaje complejos, así como después del desarrollo de algoritmos SVM, que se otorgaron e implementaron en bibliotecas bien compatibles en muchos lenguajes de programación, incluido R. Después de eso, los métodos SVM fueron aceptados por una amplia audiencia. De lo contrario, probablemente sería imposible aplicar las matemáticas complejas necesarias para implementar SVM. La buena noticia es que, aunque las matemáticas son posiblemente complejas, los conceptos básicos son comprensibles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los métodos SVM se pueden adaptar para usar casi cualquier tipo de tarea de capacitación, incluida la clasificación y el pronóstico numérico. </font><font style="vertical-align: inherit;">Muchos de los éxitos clave de este algoritmo se relacionan con el reconocimiento de patrones. </font><font style="vertical-align: inherit;">Las aplicaciones más conocidas para estos métodos incluyen las siguientes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clasificación de datos sobre la expresión de genes de microarrays en bioinformática para la detección de cáncer y otras enfermedades genéticas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">categorización de texto, como determinar el idioma utilizado en un documento o clasificar documentos por tema;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detección de eventos raros pero importantes, como la falla de un motor de combustión interna, una violación de seguridad o un terremoto.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los métodos SVM son más fáciles de entender utilizando la clasificación binaria como ejemplo; así es como se usan generalmente. </font><font style="vertical-align: inherit;">Por lo tanto, en las secciones restantes, nos centraremos solo en los clasificadores SVM. </font><font style="vertical-align: inherit;">Principios similares a los presentados aquí también se utilizan al adaptar los métodos SVM para el pronóstico numérico.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre el Autor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) ha estado utilizando técnicas innovadoras de procesamiento de datos para estudiar el comportamiento humano durante más de una década. </font><font style="vertical-align: inherit;">Siendo un sociólogo de formación, Brett se interesó por primera vez en el aprendizaje automático mientras exploraba una gran base de datos de perfiles de adolescentes en las redes sociales. </font><font style="vertical-align: inherit;">Brett es profesor en DataCamp y a menudo hace presentaciones en conferencias y seminarios de aprendizaje automático en todo el mundo. </font><font style="vertical-align: inherit;">Es un conocido entusiasta en el campo de la aplicación práctica de la ciencia de datos en el campo de los deportes, los vehículos no tripulados, el estudio de lenguas extranjeras y la moda, así como en muchas otras industrias. </font><font style="vertical-align: inherit;">Brett espera algún día escribir sobre todo esto en dataspelunking.com, un intercambio de conocimientos sobre cómo encontrar patrones en los datos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre el editor de ciencias</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - investigador principal de una de las organizaciones de atención médica más grandes del mundo. Se dedica a la investigación y el desarrollo de soluciones corporativas basadas en el aprendizaje automático, el aprendizaje profundo y el procesamiento del lenguaje natural para su uso en la atención médica y los seguros. En su puesto anterior en Intel, participó en iniciativas proactivas en el campo de la tecnología de la información, basadas en big data, utilizando procesamiento de lenguaje natural, aprendizaje profundo y métodos estadísticos tradicionales. En American Express, trabajó en compromiso digital y retención de clientes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav es autor de varios libros publicados por editoriales líderes. </font><font style="vertical-align: inherit;">Su último libro es sobre lo último en estudio de transferencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav se graduó en el Instituto Internacional de Tecnología de la Información en Bangalore, tiene una maestría (con honores). </font><font style="vertical-align: inherit;">En esos raros momentos en que no está ocupado resolviendo problemas científicos, a Raghav le gusta leer y fotografiar todo en una fila. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Se puede encontrar más información sobre el libro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el sitio web del editor</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extracto de</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Khabrozhiteley 25% de descuento en el cupón - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprendizaje automático</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Al pagar la versión en papel del libro, se envía un libro electrónico por correo electrónico.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es496242/index.html">Cyberpunk ya está aquí: los escolares estudian en Minecraft y los estudiantes toman exámenes físicos en CS: GO</a></li>
<li><a href="../es496248/index.html">Retos, calvas y vino. Cómo nosotros en HFLabs soportamos el autoaislamiento</a></li>
<li><a href="../es496250/index.html">¿Cómo extraño código oculta errores? Análisis TensorFlow.NET</a></li>
<li><a href="../es496252/index.html">Aeronaves de centrado con desplazamiento aerodinámico</a></li>
<li><a href="../es496254/index.html">Cómo Rostelecom redirigió el tráfico por error a Google, AWS, Cloudflare, etc.</a></li>
<li><a href="../es496258/index.html">Holivar en línea: un nuevo formato para el intercambio de experiencias. Este sábado</a></li>
<li><a href="../es496260/index.html">Consejos de ciberseguridad para trabajar desde casa</a></li>
<li><a href="../es496262/index.html">Obtener ID de CVE</a></li>
<li><a href="../es496266/index.html">Coronavirus: ¿moriremos todos?</a></li>
<li><a href="../es496268/index.html">Productos y soluciones de red de Huawei Enterprise para clientes empresariales en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>