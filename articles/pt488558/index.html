<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üë©‚Äçüëß‚Äçüë¶ üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Garantindo a alta disponibilidade de aplicativos com o Kafka Streams üì∏ üë©üèª üëèüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Kafka Streams √© uma biblioteca Java para analisar e processar dados armazenados no Apache Kafka. Como em qualquer outra plataforma de processamento ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Garantindo a alta disponibilidade de aplicativos com o Kafka Streams</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488558/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Kafka Streams √© uma biblioteca Java para analisar e processar dados armazenados no Apache Kafka. </font><font style="vertical-align: inherit;">Como em qualquer outra plataforma de processamento de streaming, ele √© capaz de executar o processamento de dados com e / ou sem preserva√ß√£o de estado em tempo real. </font><font style="vertical-align: inherit;">Neste post, tentarei descrever por que a alta disponibilidade (99,99%) √© problem√°tica no Kafka Streams e o que podemos fazer para alcan√ß√°-la.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que precisamos saber</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de descrever o problema e as poss√≠veis solu√ß√µes, vejamos os conceitos b√°sicos do Kafka Streams. </font><font style="vertical-align: inherit;">Se voc√™ trabalhou com APIs Kafka para consumidores / produtores, a maioria desses paradigmas √© familiar para voc√™. </font><font style="vertical-align: inherit;">Nas se√ß√µes a seguir, tentarei descrever em poucas palavras o armazenamento de dados em parti√ß√µes, o reequil√≠brio de grupos de consumidores e como os conceitos b√°sicos dos clientes Kafka se encaixam na biblioteca do Kafka Streams.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka: Particionando Dados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No mundo Kafka, os aplicativos produtores enviam dados como pares de valor-chave para um t√≥pico espec√≠fico. </font><font style="vertical-align: inherit;">O t√≥pico em si √© dividido em uma ou mais parti√ß√µes nos corretores Kafka. </font><font style="vertical-align: inherit;">Kafka usa uma chave de mensagem para indicar em qual parti√ß√£o os dados devem ser gravados. </font><font style="vertical-align: inherit;">Conseq√ºentemente, as mensagens com a mesma chave sempre terminam na mesma parti√ß√£o.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os aplicativos de consumidor s√£o organizados em grupos de consumidores e cada grupo pode ter uma ou mais inst√¢ncias de consumidores. </font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada inst√¢ncia de um consumidor no grupo de consumidores √© respons√°vel pelo processamento de dados de um conjunto exclusivo de parti√ß√µes do t√≥pico de entrada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As inst√¢ncias do consumidor s√£o essencialmente um meio de aumentar o processamento no seu grupo de consumidores.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka: reequilibrando o grupo de consumidores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dissemos anteriormente, cada inst√¢ncia do grupo de consumidores recebe um conjunto de parti√ß√µes exclusivas das quais consome dados. </font><font style="vertical-align: inherit;">Sempre que um novo consumidor ingressa em um grupo, o reequil√≠brio deve ocorrer para que ele obtenha uma parti√ß√£o. </font><font style="vertical-align: inherit;">O mesmo acontece quando o consumidor morre, o restante deve levar suas parti√ß√µes para garantir que todas as parti√ß√µes sejam processadas.</font></font><br>
<cut></cut><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams: Streams</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No in√≠cio deste post, nos familiarizamos com o fato de que a biblioteca Kafka Streams √© constru√≠da com base nas APIs de produtores e consumidores e o processamento de dados √© organizado da mesma maneira que a solu√ß√£o padr√£o no Kafka. Na configura√ß√£o do Kafka Streams, o campo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© </font><font style="vertical-align: inherit;">equivalente a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na API do consumidor. O Kafka Streams pr√©-cria um certo n√∫mero de threads e cada um deles executa o processamento de dados de uma ou mais parti√ß√µes dos t√≥picos de entrada. Falando na terminologia da API do Consumidor, os fluxos coincidem essencialmente com inst√¢ncias do Consumidor do mesmo grupo. Os encadeamentos s√£o a principal maneira de dimensionar o processamento de dados no Kafka Streams. Isso pode ser feito verticalmente aumentando o n√∫mero de encadeamentos para cada aplicativo Kafka Streams em uma m√°quina ou horizontalmente adicionando uma m√°quina adicional com o mesmo application.id. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb7/bd3/8ed/bb7bd38edd33f26a146c12a1dea385b5.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fonte: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kafka.apache.org/21/documentation/streams/architecture</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem muitos outros elementos no Kafka Streams, como tarefas, topologia de processamento, modelo de encadeamento etc., que n√£o discutiremos nesta postagem. </font><font style="vertical-align: inherit;">Mais informa√ß√µes podem ser encontradas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams: armazenamento em estado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No processamento de fluxo, h√° opera√ß√µes com e sem preserva√ß√£o de estado. </font><font style="vertical-align: inherit;">O estado √© o que permite ao aplicativo lembrar as informa√ß√µes necess√°rias que v√£o al√©m do escopo do registro atualmente sendo processado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opera√ß√µes estaduais, como contagem, qualquer tipo de agrega√ß√£o, jun√ß√µes etc., s√£o muito mais complicadas. Isso se deve ao fato de ter apenas um registro, n√£o √© poss√≠vel determinar o √∫ltimo estado (por exemplo, contar) para uma determinada chave; portanto, voc√™ precisa armazenar o estado do seu fluxo no aplicativo. Como discutimos anteriormente, cada encadeamento processa um conjunto de parti√ß√µes exclusivas; portanto, um encadeamento processa apenas um subconjunto de todo o conjunto de dados. Isso significa que cada encadeamento de aplicativo Kafka Streams com o mesmo application.id mant√©m seu pr√≥prio estado isolado. N√£o entraremos em detalhes sobre como o estado √© formado no Kafka Streams, mas √© importante entender que o estado √© restaurado usando o t√≥pico do log de altera√ß√µes e √© salvo n√£o apenas no disco local, mas tamb√©m no Kafka Broker.Salvar o log de altera√ß√µes de estado no Kafka Broker como um t√≥pico separado √© feito n√£o apenas para toler√¢ncia a falhas, mas tamb√©m para que voc√™ possa implantar facilmente novas inst√¢ncias do Kafka Streams com o mesmo application.id. Como o estado √© armazenado como um t√≥pico do log de altera√ß√µes no lado do broker, uma nova inst√¢ncia pode carregar seu pr√≥prio estado a partir deste t√≥pico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais informa√ß√µes sobre armazenamento de estado podem ser encontradas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a alta disponibilidade √© problem√°tica com o Kafka Streams?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revisamos os conceitos e princ√≠pios b√°sicos do processamento de dados com o Kafka Streams. </font><font style="vertical-align: inherit;">Agora vamos tentar combinar todas as partes e analisar por que alcan√ßar alta disponibilidade pode ser problem√°tico. </font><font style="vertical-align: inherit;">Nas se√ß√µes anteriores, devemos lembrar:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os dados no t√≥pico Kafka s√£o divididos em parti√ß√µes, que s√£o distribu√≠das entre os fluxos do Kafka Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os aplicativos Kafka Streams com o mesmo application.id s√£o, de fato, um grupo de consumidores e cada um de seus encadeamentos √© uma inst√¢ncia isolada e separada do consumidor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para opera√ß√µes de estado, o encadeamento mant√©m seu pr√≥prio estado, que √© "reservado" pelo t√≥pico Kafka na forma de um log de altera√ß√µes.</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br>
<h2>TransferWise SPaaS (Stream Processing as a Service)</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de destacar a ess√™ncia deste post, deixe-me contar primeiro o que criamos no TransferWise e por que a alta disponibilidade √© muito importante para n√≥s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No TransferWise, temos v√°rios n√≥s para processamento de streaming e cada n√≥ cont√©m v√°rias inst√¢ncias do Kafka Streams para cada equipe de produto. As inst√¢ncias do Kafka Streams projetadas para uma equipe de desenvolvimento espec√≠fica t√™m um application.id especial e geralmente t√™m mais de 5 threads. Em geral, as equipes geralmente t√™m de 10 a 20 threads (equivalente ao n√∫mero de inst√¢ncias de consumidores) em todo o cluster. Os aplicativos implantados nos n√≥s ouvem os t√≥picos de entrada e executam v√°rios tipos de opera√ß√µes com e sem estado nos dados de entrada e fornecem atualiza√ß√µes de dados em tempo real para microsservi√ßos posteriores subseq√ºentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As equipes de produtos precisam atualizar os dados agregados em tempo real. </font><font style="vertical-align: inherit;">Isso √© necess√°rio para fornecer aos nossos clientes a capacidade de transferir dinheiro instantaneamente. </font><font style="vertical-align: inherit;">Nosso SLA habitual:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em qualquer dia, 99,99% dos dados agregados devem estar dispon√≠veis em menos de 10 segundos.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para se ter uma id√©ia, durante o teste de estresse, o Kafka Streams conseguiu processar e agregar 20.085 mensagens de entrada por segundo. </font><font style="vertical-align: inherit;">Assim, 10 segundos de SLA sob carga normal pareciam bastante vi√°veis. </font><font style="vertical-align: inherit;">Infelizmente, nosso SLA n√£o foi atingido durante a atualiza√ß√£o sem interrup√ß√£o dos n√≥s nos quais os aplicativos est√£o implantados, e abaixo descreverei por que isso aconteceu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualiza√ß√£o do n√≥ deslizante</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na TransferWise, acreditamos firmemente na entrega cont√≠nua de nosso software e geralmente lan√ßamos novas vers√µes de nossos servi√ßos algumas vezes por dia. </font><font style="vertical-align: inherit;">Vejamos um exemplo de uma simples atualiza√ß√£o cont√≠nua de servi√ßo e vejamos o que acontece durante o processo de lan√ßamento. </font><font style="vertical-align: inherit;">Novamente, devemos lembrar que:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os dados no t√≥pico Kafka s√£o divididos em parti√ß√µes, que s√£o distribu√≠das entre os fluxos do Kafka Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os aplicativos Kafka Streams com o mesmo application.id s√£o, de fato, um grupo de consumidores e cada um de seus encadeamentos √© uma inst√¢ncia isolada e separada do consumidor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para opera√ß√µes de estado, o encadeamento mant√©m seu pr√≥prio estado, que √© "reservado" pelo t√≥pico Kafka na forma de um log de altera√ß√µes.</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um processo de libera√ß√£o em um √∫nico n√≥ geralmente leva de oito a nove segundos. </font><font style="vertical-align: inherit;">Durante o lan√ßamento, as inst√¢ncias do Kafka Streams no n√≥ "reinicializam suavemente". </font><font style="vertical-align: inherit;">Portanto, para um √∫nico n√≥, o tempo necess√°rio para reiniciar corretamente o servi√ßo √© de aproximadamente oito a nove segundos. </font><font style="vertical-align: inherit;">Obviamente, desligar uma inst√¢ncia do Kafka Streams em um n√≥ causa um reequil√≠brio do grupo de consumidores. </font><font style="vertical-align: inherit;">Como os dados s√£o particionados, todas as parti√ß√µes pertencentes √† inst√¢ncia inicializ√°vel devem ser distribu√≠das entre aplicativos ativos do Kafka Streams com o mesmo application.id. </font><font style="vertical-align: inherit;">Isso tamb√©m se aplica aos dados agregados que foram salvos no disco. </font><font style="vertical-align: inherit;">At√© que esse processo seja conclu√≠do, os dados n√£o ser√£o processados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©plicas em espera</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para reduzir o tempo de reequil√≠brio para aplicativos Kafka Streams, existe um conceito de r√©plicas de backup, definidas na configura√ß√£o como num.standby.replicas. R√©plicas de backup s√£o c√≥pias do armazenamento de estado local. Esse mecanismo torna poss√≠vel replicar o armazenamento de estado de uma inst√¢ncia do Kafka Streams para outra. Quando o encadeamento Kafka Streams morre por qualquer motivo, a dura√ß√£o do processo de recupera√ß√£o de estado pode ser minimizada. Infelizmente, pelos motivos que explicarei abaixo, mesmo as r√©plicas de backup n√£o ajudar√£o com uma atualiza√ß√£o do servi√ßo sem interrup√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que tenhamos duas inst√¢ncias do Kafka Streams em duas m√°quinas diferentes: n√≥-a e n√≥-b. </font><font style="vertical-align: inherit;">Para cada uma das inst√¢ncias do Kafka Streams, num.standby.replicas = 1 √© indicado nesses 2. N√≥s. Com essa configura√ß√£o, cada inst√¢ncia do Kafka Streams mant√©m sua pr√≥pria c√≥pia do reposit√≥rio em outro n√≥. </font><font style="vertical-align: inherit;">Durante uma atualiza√ß√£o sem interrup√ß√£o, temos a seguinte situa√ß√£o:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A nova vers√£o do servi√ßo foi implantada no n√≥-a.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inst√¢ncia do Kafka Streams no n√≥-a est√° desativada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O reequil√≠brio come√ßou.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O reposit√≥rio do n√≥-a j√° foi replicado para o n√≥-b, pois especificamos a configura√ß√£o num.standby.replicas = 1.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o n√≥-b j√° possui uma c√≥pia de sombra do n√≥-a, portanto, o processo de reequil√≠brio acontece quase instantaneamente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o n√≥-a √© iniciado novamente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√≥-a se junta a um grupo de consumidores.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O broker Kafka v√™ uma nova inst√¢ncia do Kafka Streams e inicia o reequil√≠brio.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como podemos ver, num.standby.replicas ajuda apenas em cen√°rios de um desligamento completo de um n√≥. </font><font style="vertical-align: inherit;">Isso significa que, se o n√≥-a travar, o n√≥-b poder√° continuar funcionando corretamente quase instantaneamente. </font><font style="vertical-align: inherit;">Por√©m, em uma situa√ß√£o de atualiza√ß√£o cont√≠nua, ap√≥s a desconex√£o, o n√≥-a ingressar√° no grupo novamente e esta √∫ltima etapa causar√° um reequil√≠brio. </font><font style="vertical-align: inherit;">Quando o n√≥-a ingressa no grupo de consumidores ap√≥s uma reinicializa√ß√£o, ser√° considerado como uma nova inst√¢ncia do consumidor. </font><font style="vertical-align: inherit;">Novamente, devemos lembrar que o processamento de dados em tempo real √© interrompido at√© que uma nova inst√¢ncia restaure seu estado do t√≥pico do log de altera√ß√µes.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que o reequil√≠brio de parti√ß√µes quando uma nova inst√¢ncia √© ingressada em um grupo n√£o se aplica √† API do Kafka Streams, pois √© exatamente assim que o protocolo do grupo de consumidores Apache Kafka funciona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conquista: Alta disponibilidade com Kafka Streams</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar de as bibliotecas cliente Kafka n√£o fornecerem funcionalidade interna para o problema mencionado acima, existem alguns truques que podem ser usados ‚Äã‚Äãpara obter alta disponibilidade de cluster durante uma atualiza√ß√£o sem interrup√ß√£o. </font><font style="vertical-align: inherit;">A id√©ia por tr√°s das r√©plicas de backup permanece v√°lida, e ter m√°quinas de backup na hora certa √© uma boa solu√ß√£o que usamos para garantir alta disponibilidade em caso de falha da inst√¢ncia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema com nossa configura√ß√£o inicial era que t√≠nhamos um grupo de consumidores para todas as equipes em todos os n√≥s. </font><font style="vertical-align: inherit;">Agora, em vez de um grupo de consumidores, temos dois, e o segundo atua como um cluster "quente". </font><font style="vertical-align: inherit;">No prod, os n√≥s t√™m uma vari√°vel especial CLUSTER_ID, que √© adicionada ao application.id das inst√¢ncias do Kafka Streams. </font><font style="vertical-align: inherit;">Aqui est√° um exemplo de configura√ß√£o do Spring Boot application.yml:</font></font><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml</font></font></b><div class="spoiler_text"><code>spring.profiles: production<br>
streaming-pipelines:<br>
 team-a-stream-app-id: "${CLUSTER_ID}-team-a-stream-app"<br>
 team-b-stream-app-id: "${CLUSTER_ID}-team-b-stream-app"</code><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um determinado momento, apenas um dos clusters est√° no modo ativo, respectivamente, o cluster de backup n√£o envia mensagens em tempo real para microsservi√ßos downstream. Durante a libera√ß√£o da libera√ß√£o, o cluster de backup se torna ativo, o que permite uma atualiza√ß√£o sem interrup√ß√£o no primeiro cluster. Como esse √© um grupo completamente diferente de consumidores, nossos clientes nem percebem viola√ß√µes no processamento, e os servi√ßos subsequentes continuam recebendo mensagens do cluster ativo recentemente. Uma das desvantagens √≥bvias do uso de um grupo de consumidores de backup √© o consumo adicional de sobrecarga e recursos, mas, no entanto, essa arquitetura fornece garantias adicionais, controle e toler√¢ncia a falhas do nosso sistema de processamento de streaming.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m de adicionar um cluster adicional, tamb√©m existem truques que podem atenuar o problema com o reequil√≠brio frequente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aumentar group.initial.rebalance.delay.ms</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir do Kafka 0.11.0.0, a configura√ß√£o group.initial.rebalance.delay.ms foi adicionada. </font><font style="vertical-align: inherit;">De acordo com a documenta√ß√£o, essa configura√ß√£o √© respons√°vel por:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A quantidade de tempo em milissegundos que o GroupCoordinator atrasar√° o reequil√≠brio inicial do consumidor do grupo.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, se definirmos 60.000 milissegundos nessa configura√ß√£o, com uma atualiza√ß√£o cont√≠nua, poderemos ter uma janela para o lan√ßamento do lan√ßamento. </font><font style="vertical-align: inherit;">Se a inst√¢ncia do Kafka Streams reiniciar com √™xito nessa janela de tempo, nenhum reequil√≠brio ser√° chamado. </font><font style="vertical-align: inherit;">Observe que os dados pelos quais a inst√¢ncia reiniciada do Kafka Streams foi respons√°vel continuar√£o indispon√≠veis at√© o n√≥ retornar ao modo online. </font><font style="vertical-align: inherit;">Por exemplo, se a reinicializa√ß√£o de uma inst√¢ncia demorar cerca de oito segundos, voc√™ ter√° oito segundos de tempo de inatividade para os dados pelos quais essa inst√¢ncia √© respons√°vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note-se que a principal desvantagem desse conceito √© que, no caso de uma falha no n√≥, voc√™ receber√° um atraso adicional de um minuto durante a restaura√ß√£o, levando em considera√ß√£o a configura√ß√£o atual.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diminuindo o tamanho do segmento nos t√≥picos do log de altera√ß√µes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O grande atraso no reequil√≠brio do Kafka Stream se deve √† restaura√ß√£o das lojas do estado dos t√≥picos do log de altera√ß√µes. Os t√≥picos do log de altera√ß√µes s√£o t√≥picos compactados, o que permite armazenar o registro mais recente de uma chave espec√≠fica no t√≥pico. Descreverei brevemente este conceito abaixo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os t√≥picos do Kafka Broker est√£o organizados em segmentos. Quando um segmento atinge o tamanho do limite configurado, um novo segmento √© criado e o anterior √© compactado. Por padr√£o, esse limite √© definido como 1 GB. Como voc√™ deve saber, a principal estrutura de dados subjacente aos t√≥picos do Kafka e suas parti√ß√µes √© a estrutura de log com grava√ß√£o direta, ou seja, quando as mensagens s√£o enviadas para o t√≥pico, elas sempre s√£o adicionadas ao √∫ltimo segmento "ativo" e a compacta√ß√£o n√£o √© indo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a maioria dos estados de armazenamento armazenados no changelog est√£o sempre no arquivo "segmento ativo" e nunca s√£o compactados, resultando em milh√µes de mensagens de changelog n√£o compactadas. </font><font style="vertical-align: inherit;">Para o Kafka Streams, isso significa que, durante o reequil√≠brio, quando a inst√¢ncia do Kafka Streams restaura seu estado a partir do t√≥pico changelog, ela precisa ler muitas entradas redundantes no t√≥pico changelog. </font><font style="vertical-align: inherit;">Dado que os armazenamentos estaduais se preocupam apenas com o √∫ltimo estado, e n√£o com o hist√≥rico, esse tempo de processamento √© desperdi√ßado. </font><font style="vertical-align: inherit;">Reduzir o tamanho do segmento causar√° uma compress√£o de dados mais agressiva, para que novas inst√¢ncias dos aplicativos Kafka Streams possam se recuperar muito mais rapidamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora o Kafka Streams n√£o forne√ßa a capacidade interna de fornecer alta disponibilidade durante uma atualiza√ß√£o do servi√ßo sem interrup√ß√£o, isso ainda pode ser feito no n√≠vel da infraestrutura. </font><font style="vertical-align: inherit;">Devemos lembrar que o Kafka Streams n√£o √© uma "estrutura de cluster", diferente do Apache Flink ou Apache Spark. </font><font style="vertical-align: inherit;">√â uma biblioteca Java leve que permite que os desenvolvedores criem aplicativos escal√°veis ‚Äã‚Äãpara streaming de dados. </font><font style="vertical-align: inherit;">Apesar disso, ele fornece os blocos de constru√ß√£o necess√°rios para atingir metas de streaming ambiciosas, como disponibilidade de "99,99%".</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt488544/index.html">Remova a cobertura do c√≥digo de um aplicativo Node.JS j√° em execu√ß√£o</a></li>
<li><a href="../pt488546/index.html">Corte a caixa. Explica√ß√£o passo a passo de JSON. Vulnerabilidade no Json.Net e LPE via SeImpersonatePrivilege</a></li>
<li><a href="../pt488548/index.html">Experi√™ncia: como aprender a criar textos populares em ingl√™s (e por que os habristas de l√≠ngua inglesa l√™em t√£o pouco)</a></li>
<li><a href="../pt488550/index.html">Quem quer transformar as cooperativas em gigantes de TI</a></li>
<li><a href="../pt488552/index.html">Desenvolvedores Apple FAS e Controle dos Pais</a></li>
<li><a href="../pt488560/index.html">Hospedagem gratuita de bot de Telegram no Google Cloud Platform</a></li>
<li><a href="../pt488564/index.html">Sua primeira rede neural em uma unidade de processamento gr√°fico (GPU). Guia do iniciante</a></li>
<li><a href="../pt488566/index.html">Como um engenheiro de controle de qualidade salvou um dia inteiro vinculando Testes autom√°ticos no Visual Studio e Test IT</a></li>
<li><a href="../pt488568/index.html">As redes neurais sonham com dinheiro el√©trico?</a></li>
<li><a href="../pt488570/index.html">Como o Servi√ßo Secreto dos EUA confundiu o RPG cyberpunk com um livro did√°tico para hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>