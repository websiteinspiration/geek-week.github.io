<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎆 🎐 🥉 VM、Nomad、Kubernetesでのアプリケーションのデプロイ ⌛️ 🤽🏽 🃏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！私の名前はパベル・アガレツキーです。私はLamodaデリバリーシステムを開発するチームのチームリーダーとして働いています。2018年にHighLoad ++カンファレンスで講演しましたが、本日は私のレポートの筆記録を紹介したいと思います。
 
 私のトピックは、さまざまな環境へ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>VM、Nomad、Kubernetesでのアプリケーションのデプロイ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/451644/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！</font><font style="vertical-align: inherit;">私の名前はパベル・アガレツキーです。</font><font style="vertical-align: inherit;">私はLamodaデリバリーシステムを開発するチームのチームリーダーとして働いています。</font><font style="vertical-align: inherit;">2018年にHighLoad ++カンファレンスで講演しましたが、本日は私のレポートの筆記録を紹介したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のトピックは、さまざまな環境へのシステムとサービスの展開における当社の経験に捧げられています。</font><font style="vertical-align: inherit;">すべてのシステムを通常の仮想サーバーにデプロイした先史時代から、NomadからKubernetesへのデプロイメントへと段階的に移行しました。</font><font style="vertical-align: inherit;">なぜそれを行ったのか、その過程でどのような問題があったのかを説明します。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oqrb7dWECSo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
 <h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VMにアプリケーションをデプロイする</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、3年前、会社のすべてのシステムとサービスが通常の仮想サーバーに展開されました。技術的には、Jenkinsを使用した自動アセンブリツールを使用して、システムのすべてのコードが配置およびアセンブルされるように編成されました。 Ansibleを使用して、バージョン管理システムから仮想サーバーにロールアウトしました。同時に、私たちの会社にあったすべてのシステムは少なくとも2台のサーバーに展開されました：それらの1つは頭にあり、2番目は尾にありました。これら2つのシステムは、すべての設定、電力、構成などにおいて、互いにまったく同じでした。両者の唯一の違いは、ヘッドがユーザートラフィックを受信したのに対し、テールはユーザートラフィックを受信しなかったことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが行われたのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの新しいリリースをデプロイするとき、シームレスなロールアウトの可能性を提供したいと考えました。つまり、ユーザーに大きな影響を与えません。これは、Ansibleを使用して組み立てられた次のリリースがテールにロールアウトされたために達成されました。そこで、展開に携わっていた人々は、すべてが問題ないことをチェックして確認できました。すべてのメトリック、セクション、およびアプリケーションが機能しました。必要なスクリプトが起動されます。すべてがOKであると彼らが確信した後でのみ、トラフィックが切り替えられました。彼は前にテールだったサーバーに行き始めました。また、以前のバージョンでは、ユーザートラフィックがなく、以前のバージョンのアプリケーションが残っていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ユーザーにとってはシームレスでした。</font><font style="vertical-align: inherit;">切り替えは同時に行われるため、バランサー切り替えにすぎません。</font><font style="vertical-align: inherit;">バランサーを元に戻すだけで、前のバージョンに簡単にロールバックできます。</font><font style="vertical-align: inherit;">また、ユーザートラフィックがアプリケーションに到達する前であっても、アプリケーションが本番環境で機能することを確認できたため、非常に便利でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてにおいて、どのような利点がありましたか？</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず第一に、それ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に</font><b><font style="vertical-align: inherit;">簡単</font></b><font style="vertical-align: inherit;">に</font><b><font style="vertical-align: inherit;">動作し</font></b><font style="vertical-align: inherit;">ます</font><b><font style="vertical-align: inherit;">。</font></b><font style="vertical-align: inherit;">ほとんどの人が通常の仮想サーバーに配備したことがあるので、誰もがこの配備スキームがどのように機能するかを理解しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">導入テクノロジーはシンプルで、数千の企業によってテストされているため、</font><font style="vertical-align: inherit;">これは非常に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信頼でき</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">何百万ものサーバーがそのように展開されています。</font><font style="vertical-align: inherit;">何かを壊すのは難しいです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして最後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックデプロイメントを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">古いバージョンと新しいバージョンを切り替える目立つ段階なしに、ユーザーに同時に発生するデプロイメント。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これにはいくつかの欠点もあります。 </font></font><br>
<br>
<ol>
<li> -,  ,    . , qa  preproduction.           60 .     <b>        </b> . ,         ,       .     ,         ,  ,  devops    .       ,            . ,  QA-    ,    — ,    . </li>
<li><b>   </b>  .     ,    .  ,   devops,   .           ,   .</li>
<li>                ,   ,        .          100.           ,      .  ,    , ,  , .      QA-.              <b>,    .</b></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、通常の仮想マシンのデプロイから、Dockerコンテナーでのアプリケーションのデプロイに切り替える方が便利だと判断しました。 Dockerがある場合、コンテナーを持ち上げるだけではできないため、クラスターでアプリケーションを実行できるシステムが必要です。通常、コンテナが自動的に上昇するように持ち上げられたコンテナの数を追跡する必要があります。このため、制御システムを選択する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは長い間、どれをとることができるかについて考えました。</font><font style="vertical-align: inherit;">実際のところ、当時の通常の仮想サーバーへの展開スタックは、オペレーティングシステムの最新バージョンがなかったため、時代遅れでした。</font><font style="vertical-align: inherit;">ある時点で、FreeBSDさえもそこに立っていましたが、維持するのはあまり便利ではありませんでした。</font><font style="vertical-align: inherit;">できる限り迅速にdockerに移行する必要があることを理解しました。</font><font style="vertical-align: inherit;">私たちの開発者は、さまざまなソリューションでの既存の経験を見て、Nomadのようなシステムを選択しました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遊牧民に切り替える</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NomadはHashiCorp製品です。また、他のソリューションでも知られています</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4e/vz/4e/4evz4entvdaauztnu558tb-2z9u.jpeg" alt="画像"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Consul</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、サービスを発見するためのツールです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Terraform」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、infrastructure-as-a-codeと呼ばれる構成を通じて構成できるサーバー管理システムです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vagrant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、特定の構成ファイルを使用して、ローカルまたはクラウドに仮想マシンを展開できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当時のNomadは、インフラ全体を変更せずにすぐに切り替えることができるかなりシンプルなソリューションのように見えました。さらに、非常に簡単に習得できます。したがって、私たちはそれを私たちのコンテナー用のフィルターシステムとして選択しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムをNomadに完全にデプロイするには何が必要ですか？</font></font><br>
<br>
<ol>
<li>   <b>docker image</b>  .         docker.     artifactory —  ,         .    ,  docker,  composer , N-   . </li>
<li> <b>  </b>,   Nomad, ,        . </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nomadについて話すとき、それはHCL言語を情報ファイル形式として使用します。これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HashiCorp Configuration Languageの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">略です</font><font style="vertical-align: inherit;">。これは、Nomadの観点からサービスを説明できるYamlのスーパーセットです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/q9/vb/vgq9vb_izh4i890ro7giihibz6g.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、デプロイするコンテナーの数を指定でき、そこから、デプロイ中にイメージからコンテナーにさまざまなパラメーターを転送できます。したがって、このNomadファイルをフィードすると、それに従ってプロダクションでコンテナーが起動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、多くのサービスがあり、場合によってはそれらを更新する必要があるため、各サービスに対してまったく同じ、まったく同じHCLファイルを書き込むだけではあまり便利ではないことがわかりました。 1つのサービスが1つのインスタンスではなく、最も異なるサービスにデプロイされることがあります。たとえば、私たちが運用しているシステムの1つには、運用環境に100を超えるインスタンスがあります。それらは同じイメージから起動されますが、構成設定と構成ファイルが異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、展開用のすべての構成ファイルを1つの共通リポジトリに格納すると便利だと判断しました。したがって、それらは観察可能になりました。それらは保守が簡単で、私たちが持っているシステムを確認することが可能でした。必要に応じて、何かを更新または変更することも簡単です。新しいシステムを追加することも難しくありません。新しいディレクトリ内に構成ファイルを入力するだけです。その中にはファイルがあります。service.hclにはサービスの説明が含まれており、このサービスを本番環境にデプロイして構成できるようにするいくつかの環境ファイルがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-g/l7/8h/-gl78hl7nbmdbhbuacuntgxw4ow.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、一部のシステムは、1つのコピーではなく、一度に複数で製品にデプロイされています。したがって、構成を純粋な形式ではなくテンプレート形式で保存する方が便利だと判断しました。また、テンプレート言語として、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jinja 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を選択しました</font><font style="vertical-align: inherit;">。この形式では、サービス自体の構成と、サービスに必要な環境ファイルの両方を保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、すべてのプロジェクトに共通のスクリプトデプロイをリポジトリに配置しました。これにより、適切な環境の適切なターゲットで、本番環境でサービスを起動およびデプロイできます。 HCL構成をテンプレートに変換した場合、以前は通常のNomad構成であったHCLファイルが、この場合は多少異なって見え始めました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9a/ib/zv/9aibzvsme34ra2eg53bjfbqt1tw.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、設定ファイルの一部の変数を、envファイルまたは他のソースから取得した変数挿入に置き換えました。さらに、HLファイルを動的に収集することができました。つまり、通常の変数の挿入だけでなく、それを使用することもできます。 jinjaはループと条件をサポートしているので、そこに構成ファイルを作成することもできます。これは、アプリケーションを正確にデプロイする場所によって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、サービスを本番前と本番にデプロイしたいとします。本番稼働前にクラウンスクリプトを実行したくない場合は、別のドメインでサービスを表示して、サービスが機能していることを確認したいとします。サービスをデプロイする人にとって、プロセスは非常にシンプルで透過的に見えます。 deploy.shファイルを実行して、デプロイするサービスとターゲットを指定するだけで十分です。たとえば、特定のシステムをロシア、ベラルーシ、またはカザフスタンに展開するとします。これを行うには、パラメーターの1つを変更するだけで、正しい構成ファイルが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nomadサービスがすでにクラスターにデプロイされている場合は、次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nu/au/8d/nuau8dqdcwft0boyw57x37wrkcm.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、すべてのユーザートラフィックをそれ自体に取り込む外部のバランサーが必要です。彼はConsulと協力して、特定のドメイン名に対応する特定のサービスがある場所、ノード、IPアドレスを確認します。 ConsulのサービスはNomad自体から提供されます。これらは同じ会社の製品であるため、接続が良好です。 Nomadはそのままで、起動したすべてのサービスをConsul内に登録できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部バランサーは、トラフィックの送信先となるサービスを見つけた後、それを適切なコンテナーまたはアプリケーションに対応するいくつかのコンテナーにリダイレクトします。当然、セキュリティについても考える必要があります。すべてのサービスはコンテナ内の同じ仮想マシンで実行されますが、これには通常、サービスから他のサービスへの無料アクセスを禁止する必要があります。セグメンテーションを通じてこれを実現しました。各サービスは独自の仮想ネットワークで起動され、ルーティング規則と、他のシステムおよびサービスへのアクセスを許可または拒否するための規則が規定されていました。それらは、このクラスターの内部と外部の両方に配置できます。たとえば、サービスが特定のデータベースに接続するのを防ぎたい場合、これは、ネットワークレベルでのセグメンテーションによって行うことができます。つまり、誤ってテスト環境から本番環境に誤って接続することはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人的資源の面での移行コストは私たちに何をもたらしましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
会社全体をNomadに移行するには、約5〜6か月かかりました。サービスレスに切り替えましたが、かなり速いペースで進んでいます。各チームは、サービス用に独自のコンテナーを作成する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、各チームが自分のシステムのドッカーイメージを自分で担当するようなアプローチを採用しています。一方、Devopsは、クラスター自体のサポート、CIシステムのサポートなど、デプロイに必要な一般的なインフラストラクチャを提供します。当時、60台を超えるシステムがNomadに移行されていたため、約2000のコンテナが取得されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devopsは、サーバーとのデプロイメントに関連するすべてのインフラストラクチャ全体を担当します。</font><font style="vertical-align: inherit;">そして、各開発チームは、特定のコンテナで一般的に何が必要かを知っているチームなので、特定のシステムのコンテナの実装を担当します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遊牧民を放棄する理由</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nomadとdockerを使用してデプロイするように切り替えることで、どのような利点が得られましたか？</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての環境に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ条件</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">提供しました</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">開発、QA環境、運用前、運用では、コンテナの同じイメージが使用され、同じ依存関係が使用されます。</font><font style="vertical-align: inherit;">したがって、実際にプロダクションが以前にローカルまたはテスト環境でテストしたものと異なる可能性はほとんどありません。</font></font></li>
<li>  ,   <b>   </b>.          .    ,  ,       ,     .            . </li>
<li> <b> </b>     <b> </b>.   ,         ,   Ansible,          .          .     ,    ,   ,   .         .   , ,    Nomad,         ,       .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちはいくつかの欠点にも直面しました：</font><font style="vertical-align: inherit;">ノマドの場合、</font><b><font style="vertical-align: inherit;">シームレスな展開</font></b><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">実現できないこと</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
がわかり</font><font style="vertical-align: inherit;">ました。コンテナーがさまざまな条件からロールアウトされたとき、実行中であることが判明し、Nomadはそれをトラフィックを受け入れる準備ができているコンテナーとして認識しました。これは、内部のアプリケーションがなんとか開始する前でも起こりました。このため、トラフィックはまだ受信する準備ができていないコンテナーに移動し始めたため、システムは短期間500エラーを生成し始めました。</font><font style="vertical-align: inherit;">
いくつかの</font><b><font style="vertical-align: inherit;">バグが発生しました</font></b></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最も重要なバグは、多くのシステムとコンテナがある場合、Nomadが大規模なクラスタをうまく受け入れないことです。 Nomadクラスターに含まれているサーバーの1つをサービスにしたい場合、クラスターがあまり気分が悪く、バラバラになる可能性がかなり高くなります。コンテナの一部は、たとえば、下がっても上がらない場合があります。運用環境のすべてのシステムがNomadによって管理されているクラスタに配置されている場合、その後、非常に高価になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、次にどこに行くかを考えることにしました。その時、私たちは自分たちが達成したいことをよりよく認識するようになりました。つまり、信頼性、Nomadよりも少し多くの機能、より成熟した、より安定したシステムが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この点で、クラスターを起動するための最も人気のあるプラットフォームとしてKubernetesを選びました。</font><font style="vertical-align: inherit;">特に、コンテナのサイズと数量が非常に大きい場合。</font><font style="vertical-align: inherit;">そのような目的のために、Kubernetesは私たちが見ることができるシステムの中で最も適切なシステムのように見えました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetesに移動する</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesの基本概念と、Nomadとの違いについて少しお話します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/eh/va/pvehvavusoxszoxum9bsuwyjqbc.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Kubernetesの最も基本的な概念はポッドの概念です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、常に一緒に実行される1つ以上のコンテナのグループです。そして、それらは常に同じ仮想マシン上で厳密に動作するようです。これらは、異なるポートでIP 127.0.0.1を介して相互に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nginxとphp-fpm（古典的な回路）で構成されるPHPアプリケーションがあるとします。最も可能性が高いのは、nginxとphp-fpmの両方のコンテナーを常に一緒にすることです。 Kubernetesは、これらを1つの共通のポッドとして説明することでこれを行います。これはまさに、Nomadの助けを借りて得ることができなかったものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二のコンセプトは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展開です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実際のところ、ポッド自体は一時的なものであり、開始して消滅します。以前のすべてのコンテナーを最初に強制終了してから、新しいバージョンを一度に起動するか、それとも段階的に展開するか-これは、デプロイメントが担当するまさにその概念です。ポッドのデプロイ方法、ポッドの数と更新方法について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のコンセプトは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。サービスは実際にはシステムであり、一部のトラフィックを受信して​​、サービスに対応する1つ以上のポッドに送信します。つまり、そのような名前のサービスへのすべての着信トラフィックは、これらの特定のポッドに送信する必要があると言うことができます。そしてそれはあなたにトラフィックバランスを提供します。つまり、アプリケーションの2つのポッドを実行でき、すべての受信トラフィックは、このサービスに関連するポッド間で均等に分散されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして4番目の基本コンセプトは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イングレスです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、Kubernetesクラスターで実行されるサービスです。</font><font style="vertical-align: inherit;">すべてのリクエストを処理する外部ロードバランサーとして機能します。</font><font style="vertical-align: inherit;">APIにより、Kubernetes Ingressはこれらのリクエストの送信先を決定できます。</font><font style="vertical-align: inherit;">そして彼はそれを非常に柔軟にしています。</font><font style="vertical-align: inherit;">すべてのリクエストをこのホストに送信し、そのようなURLをこのサービスに送信すると言うことができます。</font><font style="vertical-align: inherit;">そして、これらのリクエストをこのホストに送信し、別のURLから別のサービスに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを開発する人の観点から見て最もクールなことは、アプリケーションをすべて自分で管理できることです。</font><font style="vertical-align: inherit;">Ingress構成を設定することで、そのようなAPIに送信されるすべてのトラフィックを、Goなどに登録されている別のコンテナーに送信できます。</font><font style="vertical-align: inherit;">ただし、同じドメインに送信されるが、URLが異なるこのトラフィックは、多くのロジックがあるPHPで記述されたコンテナーに送信する必要がありますが、あまり高速ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのすべての概念をNomadと比較すると、最初の3つの概念はすべてServiceであると言えます。そして、Nomad自体の最後のコンセプトが欠けています。外部バランサーをそのまま使用しました：haproxy、nginx、nginx +などです。キューブの場合、この追加の概念を個別に紹介する必要はありません。ただし、内部のIngressを見ると、nginx、haproxy、traefikのいずれかですが、Kubernetesに組み込まれているように見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでに説明したすべての概念は、Kubernetesクラスター内に存在するリソースです。</font><font style="vertical-align: inherit;">キューブでそれらを記述するために、yamad形式が使用されます。これは、Nomadの場合のHClファイルよりも読みやすく、使い慣れています。</font><font style="vertical-align: inherit;">しかし、構造的には、たとえばポッドが同じものである場合について説明しています。</font><font style="vertical-align: inherit;">彼らは言う-私はそのようなポッドをあちこちで、そのような画像で、そのような量で修正したいと思っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2k/ka/53/2kka53a1vp1lm0rnl4xbhmcpyu4.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、デプロイ、サービス、Ingressなど、私たち自身の手で個々のリソースを作成したくないことに気づきました。</font><font style="vertical-align: inherit;">代わりに、必要なすべてのリソースの依存関係を正しい順序で手動で再作成する必要がないように、デプロイ中に、デプロイされた各システムをKubernetesの観点から説明したかったのです。</font><font style="vertical-align: inherit;">Helmは、これを可能にするシステムとして選択されました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helmの基本概念</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Helmは</font><font style="vertical-align: inherit;">Kubernetesの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージマネージャー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これは、パッケージマネージャーがプログラミング言語で機能する方法とよく似ています。これらを使用すると、たとえば、デプロイメントnginx、デプロイメントphp-fpm、Ingressの構成、configmaps（これは、システムのenvおよびその他のパラメーターを設定できるエンティティ）で構成されるサービスを、いわゆるチャートの形式で保存できます。 Helm </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はKubernetesの上で実行されます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、これは別のシステムではなく、キューブ内で実行される別のサービスです。コンソールコマンドを介して、APIを介して対話します。 helmは基本的にシステムを起動するためだけに機能するため、helmが中断したり、クラスターから削除したりしても、その便利さと魅力はサービスが消えないことです。 Kubernetes自体は、サービスの稼働時間と状態に責任があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また</font><font style="vertical-align: inherit;">、以前は独自の設定にjinjaを導入することで独自に行わなければならなかっ</font><font style="vertical-align: inherit;">た</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準化が</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、helmの主要な機能の1つである</font><font style="vertical-align: inherit;">ことも認識し</font><font style="vertical-align: inherit;">ました。システム用に作成したすべての構成は、ちょっとしたジンジャに似たテンプレートの形式でヘルムに格納されますが、実際には、Kubernetesなどのヘルムが記述されたGoテンプレート言語を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Helmはさらにいくつかの概念を追加します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャート</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はサービスの説明です。他のパッケージマネージャーは、パッケージ、バンドル、または類似のものと呼びます。これはここではチャートと呼ばれています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、テンプレートから構成を構築するために使用する変数です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解放する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 helmを使用してデプロイされたサービスがリリースの増分バージョンを受け取るたび。 Helmは、以前、前回のリリースの1年前などのサービス構成を記憶しています。したがって、ロールバックする必要がある場合は、helmコールバックコマンドを実行して、リリースの以前のバージョンを示します。ロールバック時にリポジトリ内の対応する構成が利用できない場合でも、helmはそれが何であったかを記憶し、システムを以前のリリースの状態にロールバックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
helmを使用する場合、Kubernetesの通常の構成もテンプレートに変わり、変数、関数、条件演算子の適用が可能になります。したがって、環境に応じてサービスの構成を収集できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dc/lr/fh/dclrfhbdr29ms0gouz_pvd8xz44.jpeg" alt="画像"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、Nomadの場合とは少し異なる方法で行うことにしました。同じリポジトリ内のNomadに、サービスのデプロイに必要なデプロイメントの構成とn変数の両方が格納されている場合、ここでそれらを2つの別々のリポジトリに分割することにしました。デプロイに必要なn変数のみがデプロイリポジトリに保存され、構成またはチャートはヘルムリポジトリに保存されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2r/lo/yt/2rloytnvlrj6nri8vj7e9-hccg8.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは私たちに何を与えましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定ファイル自体には本当に機密データを保存しないという事実にもかかわらず。たとえば、データベースのパスワード。それらはKubernetesにシークレットとして保存されますが、それでも、連続して全員にアクセスを許可したくないものがあります。したがって、デプロイリポジトリへのアクセスはより制限され、helmリポジトリにはサービスの説明のみが含まれます。このため、より広い範囲の人々に安全にアクセスすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この分離により、実稼働環境だけでなく他の環境もあるので、ヘルムチャートを再利用して、実稼働環境だけでなく、たとえばQA環境にもサービスを展開できます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minikube</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してローカルにデプロイする場合でも、</font><font style="vertical-align: inherit;">Kubernetesをローカルで実行することは</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各リポジトリ内では、サービスごとに別々のディレクトリに分離しました。つまり、各ディレクトリ内には、対応するグラフに関連するテンプレートがあり、システムを実行するためにデプロイする必要のあるリソースが記述されています。デプロイリポジトリにはenvesのみを残しました。この場合、jinjaを使用したテンプレートは使用しませんでした。ヘルム自体がそのままテンプレートを提供するためです。これはその主要な機能の1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デプロイメントスクリプトdeploy.shは、helmを使用したデプロイメントの起動を簡素化および標準化しました。</font><font style="vertical-align: inherit;">したがって、デプロイしたい人にとっては、デプロイメントインターフェースは、Nomadによるデプロイメントの場合とまったく同じように見えます。</font><font style="vertical-align: inherit;">同じdeploy.sh、サービスの名前、およびサービスのデプロイ先。</font><font style="vertical-align: inherit;">これにより、ヘルムが内部で開始されます。</font><font style="vertical-align: inherit;">次に、テンプレートから構成を収集し、必要な値ファイルをその中のファイルで置き換え、デプロイしてKubernetesに配置します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesサービスは、Nomadよりも複雑に見えます。 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fe/p6/qi/fep6qibp6hhnbsmqifk2jnmg20a.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、送信トラフィックがIngressに到達する場所です。これはすべてのリクエストを受信し、その後、リクエストデータに対応するサービスにリクエストを送信する、フロントコントローラーにすぎません。ヘルムでのアプリケーションの説明の一部であり、開発者が独自に設定する構成に基づいてそれらを定義します。サービスはそのポッド、つまり特定のコンテナーにリクエストを送信し、このサービスに属するすべてのコンテナー間で着信トラフィックを分散します。もちろん、ネットワークレベルのセキュリティから離れてはならないことを忘れないでください。したがって、Kubernetesクラスターは、タグ付けに基づくセグメンテーションを操作します。すべてのサービスには特定のタグがあり、特定の外部/内部リソースへのサービスのアクセス権がクラスターの内部または外部に付加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移行の過程で、Kubernetesには以前使用していたNomadのすべての機能があり、多くの新しい機能が追加されていることがわかりました。プラグインを介して、実際にはカスタムリソースタイプを介して拡張できます。つまり、すぐにKubernetesに入るものを使用するだけでなく、リソースを読み取る独自のリソースとサービスを作成する機会があります。これにより、Kubernetesを再インストールしたり、変更したりすることなく、システムを拡張するための追加オプションが提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は、Kubernetesクラスター内で実行されるPrometheusです。彼が特定のサービスからメトリックの収集を開始するには、サービスの説明に、追加タイプのリソース、いわゆるサービスモニターを追加する必要があります。 Prometheusは、カスタムタイプのリソースであるKubernetesで起動できるため、新しいシステムから自動的にメトリックの収集を開始できます。なかなか便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesで最初に導入したのは2018年3月です。</font><font style="vertical-align: inherit;">そしてこの間、私たちは彼と何の問題も経験しませんでした。</font><font style="vertical-align: inherit;">重大なバグがなく、安定して動作します。</font><font style="vertical-align: inherit;">また、さらに拡張できます。</font><font style="vertical-align: inherit;">今日、私たちはそれで十分な機会を得ており、Kubernetesの開発ペースが本当に気に入っています。</font><font style="vertical-align: inherit;">現在、3,000を超えるコンテナがKubernetesに配置されています。</font><font style="vertical-align: inherit;">クラスタはいくつかのノードを取ります。</font><font style="vertical-align: inherit;">同時に、サービスされ、安定しており、非常に制御されています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451634/index.html">ショップやレストランでの分析方法</a></li>
<li><a href="../ja451636/index.html">5年間の奴隷</a></li>
<li><a href="../ja451638/index.html">モバイルアプリケーションでのアニメーション：Lottieのテスト</a></li>
<li><a href="../ja451640/index.html">Game of Thrones：殺人、性別、旅行中のWesterosなどに関するインフォグラフィックの作成</a></li>
<li><a href="../ja451642/index.html">丸い障害物から道を見つける</a></li>
<li><a href="../ja451646/index.html">連邦宇宙船の船体の生産が始まりました</a></li>
<li><a href="../ja451648/index.html">ロシアでの珍しい観光をどのように探しましたか、そして一般的にどのような冒険が起こりましたか</a></li>
<li><a href="../ja451650/index.html">パートI.母親に尋ねる：誰もがそばにいる場合、顧客とコミュニケーションを取り、ビジネスアイデアの正当性を確認する方法は？</a></li>
<li><a href="../ja451652/index.html">パートII ママに尋ねる：誰もがそばにいる場合、顧客とコミュニケーションを取り、ビジネスアイデアの正確性を確認する方法は？</a></li>
<li><a href="../ja451654/index.html">新入社員-死んでいるか生きているか</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>