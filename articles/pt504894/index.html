<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💌 🏢 🍌 GUI em russo ou terminal VKS faça você mesmo 🍛 🧒🏿 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Experiência no desenvolvimento de uma GUI C ++ para o sistema de videoconferência russo (VKS). A síntese de tecnologia moderna e requisitos de certifi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GUI em russo ou terminal VKS faça você mesmo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/protei/blog/504894/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experiência no desenvolvimento de uma GUI C ++ para o sistema de videoconferência russo (VKS). </font><font style="vertical-align: inherit;">A síntese de tecnologia moderna e requisitos de certificação. </font><font style="vertical-align: inherit;">O principal "ancinho" do desenvolvimento e maneiras de contorná-los. </font><font style="vertical-align: inherit;">O que a GUI e o balé russo têm em comum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que o usuário do sistema de videoconferência vê é a interface. </font><font style="vertical-align: inherit;">E na maioria dos casos, é pela aparência e funcionalidade que eles julgam o sistema. </font><font style="vertical-align: inherit;">Uma interface inconveniente ou extensa não permitirá avaliar o alto desempenho do sistema ou a ampla funcionalidade. </font><font style="vertical-align: inherit;">Tecnicamente, um sistema "bonito" deve ser envolto em uma concha de trabalho atraente e estável. </font><font style="vertical-align: inherit;">Portanto, no início do desenvolvimento do sistema VKS doméstico, esse momento foi imediatamente levado em consideração.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/zf/vr/mqzfvrwj1mk6anlm3rjpjg44ngw.png" alt="imagem"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quem será o usuário do sistema de videoconferência russo?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde a primavera de 2020, a resposta à questão da conveniência de desenvolver um sistema VKS completo tornou-se óbvia. Funcionários, empresas comerciais, hospitais e escolas precisam de meios modernos de comunicação com um certo nível de produtividade e segurança. Você pode falar no Zoom, mas vale a pena usá-lo para negociações comerciais sérias ou para uma reunião operacional de gerentes?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para várias tarefas de empresas russas, tornou-se necessário criar um sistema de videoconferência doméstico. </font><font style="vertical-align: inherit;">Além disso, um sistema que consiste não apenas em um componente de software, mas também em um hardware completo. </font><font style="vertical-align: inherit;">Entre os fornecedores mundialmente famosos, pelo menos 5 empresas oferecem sistemas de videoconferência multifuncionais. </font><font style="vertical-align: inherit;">Mas na Rússia, o conceito de substituição de importações está gradualmente começando a funcionar. </font><font style="vertical-align: inherit;">Além disso, muitos problemas de segurança se tornaram mais importantes que o país de origem do produto e o preço nas taxas de câmbio atuais não está em último lugar. </font><font style="vertical-align: inherit;">E a "beleza" da interface acabou sendo bastante realista para se desenvolver a partir do zero.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GUI no início</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os principais requisitos para interfaces modernas são velocidade de implementação, aparência atualizada e usabilidade total. </font><font style="vertical-align: inherit;">Assim, a primeira tarefa dos desenvolvedores da interface gráfica do usuário (GUI) foi uma definição clara da funcionalidade do software para a videoconferência. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do ponto de vista da GUI, foram formulados os seguintes requisitos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fazer chamadas de vídeo / áudio;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aceitar / rejeitar chamadas recebidas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atender automaticamente uma chamada em um intervalo de tempo personalizado;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterne entre dois dispositivos de áudio (fone de ouvido / viva-voz) durante e fora da chamada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ligue / desligue o microfone e a câmera durante e fora da chamada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Discagem DTMF durante uma chamada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reunião de conferência no terminal;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerenciamento de câmeras PTZ, salvando presets de PTZ e sua aplicação;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A capacidade de produzir vídeo para várias janelas diferentes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Controle mouse, teclado, controle remoto;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A capacidade de controlar remotamente o terminal a partir da interface da Web.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta lista de funções permite resolver o problema de desenvolver uma interface de várias maneiras. </font><font style="vertical-align: inherit;">Além disso, a escolha de um tipo específico de implementação foi afetada por limitações do tipo de linguagens de programação (por exemplo, Java não era categoricamente adequado por razões de certificação, CSS / HTML - de acordo com a funcionalidade), especialização de desenvolvedores e tempo. </font><font style="vertical-align: inherit;">Coletivamente, a escolha foi feita em favor do C ++ e o uso da estrutura Qt5, pois, por exemplo, a tecnologia QML mais moderna não permite renderizar vídeo usando um contexto arbitrário do OpenGL, e isso era necessário de acordo com os terminais ToR for VKS.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f6/gd/lr/f6gdlr-u2n2ncctyiqjss5zloty.png" alt="imagem"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rapidamente e eficientemente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro protótipo da GUI foi criado para o softphone da Qt e usou muitas bibliotecas de código aberto. </font><font style="vertical-align: inherit;">Por exemplo, para o protocolo SIP, foram usadas bibliotecas eXosip / oSIP, para codificação / decodificação de vídeo e áudio - ffmpeg, para trabalhar com dispositivos de áudio - PortAudio. </font><font style="vertical-align: inherit;">Este softphone funcionava no Linux, Windows, MacOS e era um demonstrador de tecnologia, e não um dispositivo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais tarde, um softphone abstrato foi transformado em um projeto de videofone real, e a primeira versão do software para ele deveria ter sido criada 2 meses após o início. </font><font style="vertical-align: inherit;">Para resolver esse problema em tão pouco tempo, o software do telefone foi dividido em módulos e distribuído entre vários grupos de desenvolvedores de acordo com as competências. </font><font style="vertical-align: inherit;">Essa organização do processo ajudou a desenvolver rápida e eficientemente o projeto de videofone.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Núcleo e frente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para a unificação e a possibilidade de usar desenvolvimentos existentes da GUI em outros dispositivos de um projeto existente, a base de código comum está em um módulo separado - o back-end da GUI ou o módulo principal da GUI. </font><font style="vertical-align: inherit;">E representações diretamente, diferentes para diferentes dispositivos, são implementadas em módulos frontais da GUI separados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa arquitetura dos módulos da GUI mostrou-se vantajosa e levou ao resultado desejado: o desenvolvimento de interfaces para os novos componentes do sistema VKS se tornou relativamente rápido e de alta qualidade. </font><font style="vertical-align: inherit;">Afinal, agora as interfaces para os terminais VKS não precisavam ser reescritas do zero.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tormento e vitória</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caminho para criar qualquer software, naturalmente, existem dificuldades e problemas. </font><font style="vertical-align: inherit;">Criar uma GUI para a videoconferência não foi exceção. </font><font style="vertical-align: inherit;">Independentemente da finalidade específica do sistema, eles podem ser repetidos em qualquer comando. </font><font style="vertical-align: inherit;">Dificuldades e vitórias no caminho do desenvolvimento são interessantes para os colegas, e talvez elas busquem soluções eficazes sem o nosso “ancinho”.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sempre consistência</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historicamente, o primeiro problema interessante que surgiu durante o desenvolvimento da GUI para vários tipos de terminais VKS foi o problema de consistência, ou seja, o estado coordenado de todos os módulos. </font><font style="vertical-align: inherit;">Durante a operação, a GUI interage com vários outros módulos: um módulo para interagir com o hardware, um subsistema de gerenciamento de chamadas, um MCU (Media Processing Module) e um subsistema de interação do usuário.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/xp/5b/csxp5bydmvx6vi9eviyuxg8-d3k.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, a GUI trabalhava com todos esses módulos como independentes, ou seja, podia enviar solicitações para 2 módulos diferentes ao mesmo tempo. Isso acabou errado e algumas vezes levou a problemas, já que esses módulos não eram independentes e interagiram ativamente entre si. A solução para o problema foi a criação de um esquema de trabalho especial, que garantiu a execução estritamente seqüencial de solicitações em todos os módulos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Havia duas dificuldades em adicionar: primeiro, alguns (mas não todos) pedidos requerem uma resposta, antecipando que o terminal, de fato, esteja em um estado inconsistente, portanto outros pedidos não podem ser executados. No entanto, bloquear a interface do usuário enquanto aguarda respostas também é indesejável. Em segundo lugar, as respostas às solicitações da GUI dos módulos, bem como às solicitações dos módulos da GUI, vêm em seus próprios encadeamentos, diferentes da GUI, mas a GUI deve implementar todas as alterações de estado em seu encadeamento (para algumas ações o Qt exige isso, mas em em alguns casos, isso evita dificuldades desnecessárias para garantir a sincronização do encadeamento).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução foi encontrada e consistia em duas partes. Primeiro, todas as solicitações / respostas de outros módulos foram redirecionadas para o fluxo da GUI usando o mecanismo de slot de sinal Qt em conjunto com QueuedConnection, ou seja, usando o loop de eventos QApplication global. Em seguida, para garantir o processamento consistente de todas as solicitações, um sistema Transitions foi desenvolvido com sua própria fila e ciclo de processamento (TransitionLoop).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, quando o usuário pressiona algum botão de ação na GUI (por exemplo, o botão de chamada), uma transição correspondente é criada, que é colocada na fila de transição. Depois disso, um sinal é gerado para o ciclo de processamento de transição. O TransitionLoop, ao receber um sinal, procura ver se há alguma transição em andamento agora. Se houver, a espera pela conclusão da transição atual continua; caso contrário, a próxima transição é recuperada da fila de transição e iniciada. Quando uma resposta é recebida de outro módulo TransitionLoop usando o mesmo sinal, a conclusão da transição atual é notificada e o TransitionLoop pode iniciar a próxima transição da fila.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O importante aqui é que todo o processamento de transição seja feito em um encadeamento da GUI. </font><font style="vertical-align: inherit;">Isso é garantido pelo uso do mecanismo de slot de sinal Qt na variante QueuedConnection, na qual um evento é gerado para cada sinal e colocado no EventLoop principal do aplicativo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderização OpenGL em hardware de baixa potência</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra dificuldade que tivemos que enfrentar foi o problema de renderização de vídeo. O Qt fornece ao OpenGL a renderização de uma classe QOpenGLWidget especial e de classes auxiliares relacionadas, que foram originalmente usadas para renderizar vídeo. Os dados para renderização (quadros de vídeo decodificados) são fornecidos pelo módulo de processamento de mídia (MCU), que, entre outras coisas, implementa a decodificação de hardware do fluxo de vídeo (na GPU). Em processadores de baixa potência, “diminuindo a velocidade” foi encontrada a renderização do vídeo em FullHD. A solução direta foi substituir o processador, mas isso exigiria um processamento sério dos componentes já finalizados do sistema de videoconferência e aumentaria o custo dos próprios dispositivos. Portanto, todo o processo de renderização foi cuidadosamente analisado para encontrar maneiras mais bonitas de resolver o problema.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a renderização OpenGL padrão e a decodificação de hardware, ocorre o seguinte: os dados com vídeo codificado vêm da rede, são armazenados na RAM e, em seguida, esses dados da RAM são transferidos para a memória de vídeo na GPU, onde são decodificados. Em seguida, os dados decodificados com um volume significativamente maior que os dados codificados são transferidos novamente para a RAM. Em seguida, um código de renderização entra em ação, que transfere esses dados da RAM de volta para a GPU diretamente para renderização. Assim, grandes quantidades de dados são bombeadas para frente e para trás através do barramento de memória, e o barramento simplesmente não pode fazer isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas versões modernas do OpenGL, existem extensões especiais que permitem especificar dados de renderização que já estão na memória da GPU e não dados na RAM principal, como de costume. Esse mecanismo excluiu o movimento dos dados dos quadros decodificados por hardware da GPU para a RAM e depois para trás. Assim, o problema de renderização em processadores de baixa potência foi quase resolvido.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ta/gx/rr/tagxrr-ydgiw9vlbucxyvli2jni.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro grande problema foram os contextos OpenGL suportados no Qt. Eles não permitem o uso da extensão OpenGL necessária, ou seja, você não pode usar o QOpenGLWidget com esta opção. A solução foi usar um QWidget regular, mas desativou o pipeline de renderização Qt. Essa oportunidade existe no Qt. No entanto, surgiu uma pergunta aqui, porque nesta opção a GUI é totalmente responsável por toda a renderização na área deste widget, o Qt não nos ajuda. Isso é normal para a exibição de vídeo, mas para o uso de widgets em cima de vídeo, as ferramentas regulares do Qt não podem ser usadas, pois, por exemplo, um menu pop-up adicional deve ser exibido na parte superior do vídeo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse problema foi resolvido da seguinte forma: no widget existente, sua imagem é obtida (o QWidget possui um método grab () para isso), a imagem resultante é convertida em textura OpenGL e a última é renderizada na parte superior do vídeo usando as ferramentas OpenGL. </font><font style="vertical-align: inherit;">Ao adicionar o ambiente apropriado, foi implementado um mecanismo universal que pode ser usado para exibir widgets padrão na parte superior do vídeo de maneira não padronizada.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiosques e widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tarefa de gerenciar exibições e distribuir fragmentos da interface do usuário no modo “quiosque” não foi fácil. O terminal VKS pode operar em 2 modos - modo de janela, ou seja, como qualquer outro aplicativo de janela no ambiente de desktop do sistema operacional e "modo de quiosque" (ou seja, o sistema operacional executa apenas um aplicativo com uma interface gráfica - VKST - e não há ambiente) Área de Trabalho).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No modo janela, tudo é relativamente simples: a janela é controlada pelo gerenciador de janelas do ambiente da área de trabalho, o aplicativo cria uma segunda janela, se necessário, e o usuário distribui as janelas nos monitores conforme necessário. Porém, no modo “quiosque”, tudo é muito mais complicado, pois o sistema não possui um gerenciador de janelas e pode haver apenas uma janela, e o usuário não pode movê-lo. Portanto, a tarefa de detectar automaticamente um evento, por exemplo, conectar / desconectar um monitor, apareceu. Quando esse evento ocorreu, era necessário configurar automaticamente os monitores e colocar corretamente fragmentos da interface do usuário neles.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-x/dm/w_/-xdmw_fvqpxs-frj0pl04wszabg.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A resposta veio da biblioteca do sistema LINUX Xrandr OS, responsável por trabalhar com monitores. Como há muito pouca documentação na Internet, a implementação foi realizada usando exemplos da Internet, inclusive da Habr. Além disso, era necessário criar um algoritmo para distribuir fragmentos de interface entre os monitores, além de integrar duas janelas diferentes em uma única. O último foi implementado da seguinte forma: o que são janelas no modo janela, no modo “quiosque” são widgets dentro de uma janela grande, que se estende por 2 telas (se houver 2). Nesse caso, é necessário configurar as posições dos monitores para criar um espaço virtual contínuo (isso é feito usando a biblioteca XRandr) e, em seguida, definir a geometria dos widgets internos dentro de uma única janela global para quepara que todos apareçam na tela.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos russo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo o modo de criar o sistema de videoconferência russo consistia e consiste em muitos estágios, e a GUI é apenas a ponta do iceberg. </font><font style="vertical-align: inherit;">O mais perceptível e não o mais difícil. </font><font style="vertical-align: inherit;">No entanto, a complexidade da solução, a combinação de software e hardware e componentes de software e o desejo de criar um sistema técnico e esteticamente "bonito" criaram muitas dificuldades ao longo do caminho. </font><font style="vertical-align: inherit;">Novas tarefas deram origem a soluções não padronizadas e ajudaram a criar um produto que não tem vergonha de mostrar não apenas na Rússia, mas também no exterior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os desenvolvimentos russos há muito provam seu desempenho, e com uma bela concha e competitividade. </font><font style="vertical-align: inherit;">Nossos hacks de vida serão úteis para qualquer pessoa que esteja seriamente envolvida no desenvolvimento de GUI, e esperamos que eles ajudem outros desenvolvedores a acelerar e simplificar o processo de criação de shells modernos para novos produtos de software russos. </font><font style="vertical-align: inherit;">Acreditamos que as decisões russas serão valorizadas no mundo não menos que o balé russo ou o caviar preto.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt504880/index.html">Desenvolvimento, otimização e lançamento de jogos Synthety no Unity</a></li>
<li><a href="../pt504884/index.html">Periféricos Perigosos: Entendendo a Trovoada</a></li>
<li><a href="../pt504886/index.html">Selenium WebDriver ao serviço do desenvolvedor</a></li>
<li><a href="../pt504888/index.html">"Calma, apenas calma!" ou menos preocupação</a></li>
<li><a href="../pt504890/index.html">Retornar o valor do comando de chamada do powershell para o SQL-Server Agent</a></li>
<li><a href="../pt504902/index.html">As 9 principais tendências em testes automatizados em 2020</a></li>
<li><a href="../pt504906/index.html">PHP - qual é o nicho da linguagem e o PHP8 ajudará a resolver problemas prementes (spoiler: IMHO não)</a></li>
<li><a href="../pt504908/index.html">PyTrace - Depurador de viagens no tempo para Python</a></li>
<li><a href="../pt504912/index.html">Fim de jogo do HackTheBox. Passagem do laboratório Operações Ofensivas Profissionais. Pentest Active Directory</a></li>
<li><a href="../pt504918/index.html">Os serviços de aula on-line mais eficazes para alunos e professores: os cinco principais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>