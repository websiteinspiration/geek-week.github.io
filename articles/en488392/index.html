<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📝 🤵🏾 🔰 Production-ready images for k8s 🚂 💅🏽 〰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This story is about how we use containers in the grocery environment, especially under Kubernetes. The article is devoted to the collection of metrics...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Production-ready images for k8s</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/exness/blog/488392/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This story is about how we use containers in the grocery environment, especially under Kubernetes. </font><font style="vertical-align: inherit;">The article is devoted to the collection of metrics and logs from containers, as well as a build of images.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4o/r6/tm/4or6tm3pqygawzhld3ht0opp_3e.jpeg" alt="image"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are from the fintech company Exness, which develops services for online trading and fintech products for B2B and B2C. </font><font style="vertical-align: inherit;">There are many different teams in our R&amp;D, in the development department 100+ employees. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We represent the team that is responsible for the platform for collecting and running code by our developers. </font><font style="vertical-align: inherit;">In particular, we are responsible for collecting, storing and providing metrics, logs, and events from applications. </font><font style="vertical-align: inherit;">Currently, we operate around three thousand Docker containers in the product environment, support our 50 TB big data storage and provide architectural solutions that are built around our infrastructure: Kubernetes, Rancher and various public cloud providers.&nbsp;</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our motivation</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is burning? </font><font style="vertical-align: inherit;">No one can answer. </font><font style="vertical-align: inherit;">Where is the hearth? </font><font style="vertical-align: inherit;">It’s hard to understand. </font><font style="vertical-align: inherit;">When did it catch fire? </font><font style="vertical-align: inherit;">You can find out, but not immediately.&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/915/b6a/807/915b6a8072231adcddda50f86093038e.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why do some containers stand while others fall? </font><font style="vertical-align: inherit;">Which container was to blame? </font><font style="vertical-align: inherit;">Indeed, outside the containers are the same, but inside each has its own Neo. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/182/9b5/e14/1829b5e14acf8849524f20c5cbb907d3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our developers are literate guys. </font><font style="vertical-align: inherit;">They make good services that make the company profit. </font><font style="vertical-align: inherit;">But there are fakapy when containers with applications go randomly. </font><font style="vertical-align: inherit;">One container consumes too much CPU, the other consumes network, the third consumes I / O operations, and the fourth is generally unclear what it does with sockets. </font><font style="vertical-align: inherit;">All this falls, and the ship sinks.&nbsp;</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agents</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand what is going on inside, we decided to put agents directly in containers. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/405/66a/551/40566a55180bbdda60ad9c49f790b22b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These agents are containment programs that keep containers in such a state that they do not break each other. Agents are standardized, and this allows a standardized approach to container handling.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, agents must provide logs in a standard format, tagged and with trotting. They should also provide us with standardized metrics that are extensible in terms of business applications. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agents also mean utilities for operation and maintenance, able to work in different orchestration systems, supporting different images (Debian, Alpine, Centos, etc.).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, agents must support a simple CI / CD including Docker files. </font><font style="vertical-align: inherit;">Otherwise, the ship will fall apart, because the containers will begin to be delivered on "curved" rails.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly process and target device image</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order for everything to be standardized and manageable, you must adhere to some standard assembly process. </font><font style="vertical-align: inherit;">Therefore, we decided to collect containers by containers - such a recursion. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ad3/41a/ada/ad341aadafbc26fadf0df4e14616cae1.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here the containers are represented by solid contours. </font><font style="vertical-align: inherit;">At the same time, they decided to put distributions in them so that "life does not seem raspberry." </font><font style="vertical-align: inherit;">Why this was done, we will describe below. </font></font><br>
&nbsp;<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result is a build tool - a container of a certain version, which refers to certain versions of distributions and certain versions of scripts.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How do we use it? </font><font style="vertical-align: inherit;">We have a Docker Hub in which the container lies. </font><font style="vertical-align: inherit;">We mirror it inside our system in order to get rid of external dependencies. </font><font style="vertical-align: inherit;">The resulting container is marked in yellow. </font><font style="vertical-align: inherit;">We create a template to install in the container all the distributions and scripts we need. </font><font style="vertical-align: inherit;">After that, we collect an image that is ready for operation: the developers put the code and some special dependencies in it.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is this approach good?&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firstly, full version control of build tools - build container, scripts and distributions versions.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, we have achieved standardization: in the same way we create templates, intermediate and ready for operation image.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thirdly, containers provide us portability. </font><font style="vertical-align: inherit;">Today we use Gitlab, and tomorrow we will switch to TeamCity or Jenkins and in the same way we will be able to launch our containers.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fourth, minimizing dependencies. </font><font style="vertical-align: inherit;">It is no coincidence that we put distributions in the container, because this allows us not to download them every time from the Internet.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fifthly, the assembly speed has increased - the availability of local copies of images allows you not to waste time downloading, since there is a local image.&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In other words, we have achieved a controlled and flexible assembly process. </font><font style="vertical-align: inherit;">We use the same tools to build any containers with full versioning.&nbsp;</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How our build procedure works</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/36f/569/f11/36f569f111cc0f0f7e963ec9944e7656.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The assembly is launched with one command, the process is performed in the image (highlighted in red). The developer has a Docker-file (highlighted in yellow), we render it by replacing the variables with values. And along the way we add headers and footers - these are our agents.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Header adds distributions from the corresponding images. And the footer installs our services inside, configures the launch of the workload, logging and other agents, replaces the entrypoint, etc.&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a58/668/435/a58668435efa2b0ce59e6d2c0fc6fc3e.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We thought for a long time whether to set a supervisor. In the end, they decided that we needed him. Choose S6. The supervisor provides control of the container: it allows you to connect to it in the event of a fall in the main process and provides manual control of the container without re-creating it. Logs and metrics are processes that run inside a container. They also need to be somehow controlled, and we do this with the help of a supervisor. Finally, the S6 takes care of housekeeping, signal processing and other tasks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since we use different systems of orchestration, after assembly and launch, the container must understand what environment it is in and act on the situation. For instance:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This allows us to collect one image and launch it in different orchestration systems, and it will be launched taking into account the specifics of this orchestration system. </font></font><br>
<br>
&nbsp;<img src="https://habrastorage.org/getpro/habr/post_images/9cf/fed/b5e/9cffedb5e38cfc8d67d3c107d4f4cc49.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the same container, we get different process trees in Docker and Kubernetes: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/83b/56d/46f/83b56d46fcf929d8ae6365822be7a5ee.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The payload is executed under the S6 supervisor. Pay attention to collector and events - these are our agents responsible for logs and metrics. Kubernetes doesn't have them, but Docker has them. Why?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look at the specification of the "hearth" (hereinafter - Kubernetes pod), we will see that the events container is executed in the hearth, in which there is a separate collector container that performs the function of collecting metrics and logs. </font><font style="vertical-align: inherit;">We can use the capabilities of Kubernetes: running containers in one hearth, in a single process and / or network space. </font><font style="vertical-align: inherit;">Actually introduce your agents and perform some functions. </font><font style="vertical-align: inherit;">And if the same container is launched in Docker, it will receive all the same features at the output, that is, it will be able to deliver logs and metrics, since the agents will be launched inside.&nbsp;</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metrics and Logs</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delivery of metrics and logs is a difficult task. There are several aspects to her decision. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The infrastructure is created to fulfill the payload, and not the mass delivery of logs. That is, this process should be performed with minimal requirements for container resources. We strive to help our developers: "Take the Docker Hub container, launch it, and we can deliver the logs."&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second aspect is the limitation of the volume of logs. If in several containers there is a situation of a surge in the volume of logs (the application displays stack-trace in a loop), the load on the CPU, communication channels, the log processing system increases, and this affects the operation of the host as a whole and other containers on the host, sometimes this leads to "Fall" of the host.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third aspect - you need to support as many metrics collection methods out of the box as possible. From reading files and polling Prometheus-endpoint to using specific application protocols. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last aspect - you need to minimize resource consumption. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We chose an open-source Go solution called Telegraf. This is a universal connector that supports more than 140 types of input channels (input plugins) and 30 types of output (output plugins). We finalized it and now we will tell how it is used with Kubernetes as an example.&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/951/b60/324/951b603240a67d0e2867a66c3ce2f13a.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose a developer deploys a load and Kubernetes receives a request to create a hearth. </font><font style="vertical-align: inherit;">At this point, a container called Collector is automatically created for each pod (we use mutation webhook). </font><font style="vertical-align: inherit;">Collector is our agent. </font><font style="vertical-align: inherit;">At the start, this container configures itself to work with Prometheus and the log collection system.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, he uses the annotations of the hearth, and depending on its contents, creates, say, the end point of the Prometheus;&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on the specification of the hearth and the specific settings of the containers, it decides how to deliver the logs.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We collect logs through the Docker API: it is enough for developers to put them in stdout or stderr, and then Collector will figure it out. </font><font style="vertical-align: inherit;">Logs are collected by chunk with some delay in order to prevent possible host congestion.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metrics are collected on workload instances (processes) in containers. </font><font style="vertical-align: inherit;">Everything is tagged: namespace, under, and so on, and then converted to the Prometheus format - and becomes available for collection (except for logs). </font><font style="vertical-align: inherit;">Also, we send logs, metrics and events to Kafka and further:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logs are available at Graylog (for visual analysis);</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logs, metrics, events are sent to Clickhouse for long-term storage.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Likewise, everything works in AWS, only we are replacing Graylog from Kafka with Cloudwatch. </font><font style="vertical-align: inherit;">We send logs there, and everything turns out very conveniently: it’s immediately clear to whom the cluster and container belong. </font><font style="vertical-align: inherit;">The same is true for Google Stackdriver. </font><font style="vertical-align: inherit;">That is, our scheme works both on-premise with Kafka, and in the cloud.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we don’t have Kubernetes with pods, the scheme is a bit more complicated, but it works on the same principles. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dc3/8ff/e25/dc38ffe25475cb321c11e0bb41f30901.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same processes are performed inside the container, they are orchestrated using S6. </font><font style="vertical-align: inherit;">All the same processes are running inside the same container.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventually</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have created a complete solution for assembling and launching images into operation, with options for collecting and delivering logs and metrics:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Developed a standardized approach to the assembly of images, based on it developed CI-templates;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data collection agents are our extensions to Telegraf. </font><font style="vertical-align: inherit;">We ran them well in production;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use mutation webhook to implement containers with agents in the pods;&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrated into the Kubernetes / Rancher ecosystem;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can execute the same containers in different orchestration systems and get the result we expect;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Created a fully dynamic container management configuration.&nbsp;</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Co-author: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilya Prudnikov</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488380/index.html">The easiest start in STM through "one place"</a></li>
<li><a href="../en488382/index.html">I add 3-25 seconds delay to sites that I visit</a></li>
<li><a href="../en488386/index.html">Cases for applying network anomaly analysis tools: attacks through browser plug-ins</a></li>
<li><a href="../en488388/index.html">Relogin and HTTP Basic Auth</a></li>
<li><a href="../en488390/index.html">How to make Telegram bot friends with OpenId Connect</a></li>
<li><a href="../en488404/index.html">Games worth waiting for in 2020</a></li>
<li><a href="../en488406/index.html">IPv6 - you are doing it wrong</a></li>
<li><a href="../en488408/index.html">STM32 Ethernet-RS485 IoT Gateway</a></li>
<li><a href="../en488410/index.html">7 lessons that I learned in ten years in development</a></li>
<li><a href="../en488412/index.html">Creating a Discord bot based on discord.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>