<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌼 👩🏻‍🔧 👩🏻‍🔧 量子コンピューティングの原理の解明 🍻 👨🏾‍🔬 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="「誰も量子力学を理解していないと言っても間違いないでしょう」リチャードファインマン
 
 量子コンピューティングのトピックは、テクニカルライターやジャーナリストを常に魅了してきました。彼女の計算能力と複雑さは彼女に一種の神秘的なハローを与えました。テーマ別の記事やインフォグラフィックは、実際のアプリ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>量子コンピューティングの原理の解明</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476444/"><i><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/7de/0de/1cc7de0de64ab4691f4d12f2b54a51ab.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「誰も量子力学を理解していないと言っても間違いないでしょう」リチャードファインマン</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
量子コンピューティングのトピックは、テクニカルライターやジャーナリストを常に魅了してきました。彼女の計算能力と複雑さは彼女に一種の神秘的なハローを与えました。テーマ別の記事やインフォグラフィックは、実際のアプリケーションの問題にほとんど触れずに、この業界のあらゆる種類の見通しを詳細に説明することが多すぎます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な科学論文では、量子システムの説明は省略され、タイプのステートメントが示されています</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常のビットは「1」または「0」に等しくできますが、キュビットは「1」および「0」に同時に等しい場合があります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
あなたが非常に幸運である場合（私にはわかりません）、彼らはあなたに次のように伝えます：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キュービットは「1」と「0」の間の重ね合わせにあります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
非常に伝統的な世界で作成された言語ツールを使用して量子力学的現象を定式化しようとしているため、これらの説明はどれももっともらしいとは思えません。量子コンピューティングの原理を明確に説明するには、数学という別の言語を使用する必要があります。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、量子コンピューティングシステムをモデル化して理解するために必要な数学的ツールと、量子コンピューティングのロジックを例示および適用する方法について説明します。さらに、量子アルゴリズムの例を示し、従来のコンピューターと比較した場合の利点について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれについてすべて理解できる言語で話すために最善を尽くしますが、この記事の読者が線形代数とデジタルロジックに関する基本的なアイデアを持っていることを願っています（線形代数については</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">説明</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">、デジタルロジック</font><font style="vertical-align: inherit;">については</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ここ</font></a><font style="vertical-align: inherit;">で&nbsp; </font><font style="vertical-align: inherit;">説明し&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はじめに、デジタルロジックの原則について説明します。</font><font style="vertical-align: inherit;">これは、計算に電気回路を使用することに基づいています。</font><font style="vertical-align: inherit;">説明をより抽象化するために、ワイヤの状態を「1」または「0」に簡略化します。これは「オン」または「オフ」の状態に対応します。</font><font style="vertical-align: inherit;">特定のシーケンスでトランジスタを構築したら、入力信号の1つ以上の値を取り、ブール論理の特定の規則に基づいて出力信号に変換する、いわゆる論理要素を作成します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/872/e40/4ec872e405490899e02ed8c8c9923055.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な論理要素と状態テーブル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような基本的な要素のチェーンに基づいて、より複雑な要素を作成できます。さらに複雑な要素のチェーンに基づいて、最終的には高度な抽象性を持つ中央プロセッサのアナログを取得することに依存できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述したように、デジタルロジックを数学的にマッピングする方法が必要です。はじめに、伝統的な数学的論理を紹介しましょう。線形代数を使用すると、値「1」と「0」を持つ古典的なビットは、2つの列ベクトルとして表すことができます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9c/434/3df/c9c4343df6118928be1a7bca294bbf9b.png" width="200"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、左側の数字は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディラック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">表記</font></a><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">このようにビットを表現することにより、ベクトル変換を使用してビットの論理演算をモデル化できます。</font><font style="vertical-align: inherit;">注：ロジック要素で2ビットを使用する場合、1つを使用すると多くの演算（「AND」（AND）、「Not」（NOT）、「Exclude Or」（XOR）など）を実行できるという事実にもかかわらずビットアイデンティティ変換、否定、定数「0」の計算、および定数「1」の計算の4つの操作のみを実行できます。</font><font style="vertical-align: inherit;">同一の変換中、ビットは変更されず、否定されるとビット値が反転し（「0」から「1」または「1」から「0」）、定数「1」または「0」の計算によりビットが「1」に設定されますまたは以前の値に関係なく「0」。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/8bd/c76/7a88bdc760e2f03ffd3da0030335445c.png" width="400"></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">身元</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイデンティティの変革</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否定</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否定</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数-0</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数「0」の計算</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数-1</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数「1」の計算</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビットの新しい表現に基づいて、ベクトル変換を使用して対応するビットで操作を実行するのは非常に簡単です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/6f4/92d/a3f6f492dc62d70852f3be02a1323a69.png" width="400"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に進む前に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可逆コンピューティング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の概念を見てみましょう</font><font style="vertical-align: inherit;">。これは、操作または論理要素の可逆性を保証するために、使用される出力信号と操作の名前に基づいて入力信号値のリストを決定する必要があることを意味します。したがって、恒等変換と否定は可逆的であると結論付けることができますが、定数「1」と「0」を計算する操作はそうではありません。</font><font style="vertical-align: inherit;">量子力学</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統一</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性により</font><font style="vertical-align: inherit;">、量子コンピューターは排他的な可逆演算を使用するため、ここではそれらに焦点を当てます。次に、量子コンピューターでの使用の可能性を保証するために、不可逆要素を可逆要素に変換します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">テンソル積の</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 個々のビットは多くのビットを表すことができます：</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/07e/a5f/21c07ea5f6329faf6214fcff5fbbcc5e.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な数学的概念がほぼすべて揃ったので、最初の量子論理要素に移ります。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNOT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font><font style="vertical-align: inherit;">、または制御された「NOT」（NOT）であり、可逆および量子計算で非常に重要です。</font><font style="vertical-align: inherit;">CNOT要素は2ビットに適用され、2ビットを返します。</font><font style="vertical-align: inherit;">最初のビットは「コントロール」として割り当てられ、2番目のビットは「コントロール」として割り当てられます。</font><font style="vertical-align: inherit;">制御ビットが「1」に設定されている場合、制御ビットはその値を変更します。</font><font style="vertical-align: inherit;">制御ビットが「0」に設定されている場合、制御ビットは変化しません。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/55a/f27/f2e55af2760a72e7389a1ce0777cc216.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この演算子は、次の変換ベクトルとして表すことができます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/c12/c0a/c18c12c0a3d170ae5d6cc02726f9e24a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでに取り扱ってきたすべてを示すために、多くのビットに関してCNOT要素を使用する方法を示します。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdb/1f0/ef0/bdb1f0ef078a62a045af5a3432ff5eaa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の例では、|10⟩をテンソル積の部分に分解し、CNOT行列を使用して積の新しい対応する状態を取得します。次に、以前に与えられたCNOT値の表に従って、|11⟩に因数分解します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、従来の計算と通常のビットの処理に役立つ数学的ルールをすべて覚えており、最後に最新の量子コンピューティングとキュービットに移ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場所まで読んだら、朗報です。キュービットは数学的に簡単に表現できます。一般に、クラシックビット（cbit）を|1⟩または|0⟩に設定できる場合、キュビットは単純に重ね合わされ、測定前は|0⟩および|1⟩に等しくなります。測定後、|0⟩または|1⟩で折りたたまれます。言い換えると、キュービットは、次の式に従って、|0⟩と|1⟩の線形結合として表すことができます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/ec8/e2e/fd7ec8e2e1b3dd8167d584664a4bfa90.png" width="200"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a₀</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;および&nbsp; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a₁&nbsp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、それぞれ振幅|0⟩および|1⟩を表します。</font><font style="vertical-align: inherit;">それらは「量子確率」と見なすことができます。量子力学では、重ね合わせのオブジェクトは固定後にいずれかの状態に崩壊するため、測定後に任意の状態に崩壊する確率を表します。</font><font style="vertical-align: inherit;">この式を展開して、以下を取得します。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/3ae/a51/c803aea51e4c1afa3d1fb2120f02333b.png" width="200"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明を簡単にするために、この記事ではこの概念を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このキュービットの場合、</font><font style="vertical-align: inherit;">&nbsp;測定後</font><font style="vertical-align: inherit;">に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a₀</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に崩壊する可能性</font><font style="vertical-align: inherit;">は|です。</font><font style="vertical-align: inherit;">₀|²、とに崩壊の可能性</font><font style="vertical-align: inherit;">₁あり| </font><font style="vertical-align: inherit;">₁|²。</font><font style="vertical-align: inherit;">たとえば、次のキュービットの場合：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/d62/80d/b1ad6280d3eb193391b69bcd43fa28c7.png" width="200"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「1」の崩壊の可能性は| 1 /√2|²、または½、つまり50/50です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的なシステムでは、和のすべての確率が（完全な確率分布の場合）1でなければならないため、振幅|0⟩および|1⟩の絶対値の2乗は合計1である必要があると結論付けることができます。</font><font style="vertical-align: inherit;">この情報に基づいて、次の方程式を作成できます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74e/96b/6aa/74e96b6aa455eaab9c77562b3286648b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角法に精通している場合、この方程式がピタゴラスの定理（a²+b²=c²）に対応していることに気づくでしょう。つまり、キュービットの可能な状態を単位円上の点の形でグラフィカルに表すことができます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/666/ef3/792666ef38e24cb8ce453e802f2fac6e.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理演算子と要素は、行列変換に基づいて、量子ビットだけでなく、古典的なビットの場合にも適用されます。</font><font style="vertical-align: inherit;">これまでにリコールしたすべての可逆行列演算子、特にCNOTは、キュービットの操作に使用できます。</font><font style="vertical-align: inherit;">このような行列演算子は、量子ビットを測定して折りたたむことなく、量子ビットの各振幅を使用することを可能にします。</font><font style="vertical-align: inherit;">否定演算子を使用してキュービットを作成する例を紹介しましょう。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/8f9/17b/fa48f917b87b850ee63c2d85abc95a83.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は継続する前に、私は振幅がいることを思い出し</font><font style="vertical-align: inherit;">₀と&nbsp; </font><font style="vertical-align: inherit;">₁実際に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">複素数</font></a><font style="vertical-align: inherit;">の量子ビットの状態が最も正確としても知られている3次元単位球面上に表示することができますので、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ブロッホ球</font></a><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/e7e/1b4/12ce7e1b4211732a27bcf4b9b45d1be4.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、説明を簡単にするために、ここでは実数に限定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
量子コンピューティングの文脈でのみ意味をなす論理要素のいくつかを議論する時がきたようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要な演算子の1つは「アダマール要素」です。これは、「0」または「1」の状態でビットを取り、対応する重ね合わせに配置して、測定後に50％の確率で「1」または「0」に折りたたみます。&nbsp;</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/3c7/11c/5873c711c538223c223588bb2767b080.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アダマール演算子の右下に負の数があることに注意してください。これは、演算子を適用した結果が入力信号の値に依存するためです--1⟩または|0⟩で、計算は可逆的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アダマール要素に関連するもう1つの重要な点は、その可逆性です。つまり、対応する重ね合わせでキュービットを取得し、|0⟩または|1⟩に変換できます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/8e1/e67/8038e1e6747112de2a6f516e42932c5d.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、キュービットの状態を決定せずに、したがって、崩壊することなく、量子状態から変換できるため、非常に重要です。したがって、確率論的原理ではなく決定論的原理に基づいて量子コンピューティングを構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実数のみを含む量子演算子は、それ自体が反対なので、キュービットに演算子を適用した結果を、状態機械の形で単位円内の変換として提示できます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/c91/b24/505c91b2434b2d73e8738fbd31545718.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、アダマール演算を適用した後の状態が上の図に示されているキュービットは、対応する矢印で示される状態に変換されます。</font><font style="vertical-align: inherit;">同様に、上に示すように、否定演算子（パウリ否定演算子またはビット反転とも呼ばれます）を使用して、以下に示すように、キュービットの変換を示す別の状態マシンを構築できます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/3d9/b1b/8543d9b1bf8a155b7a8945d814edfc00.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キュービットでより複雑な操作を実行するには、多数の演算子のチェーンを使用するか、要素を何度も適用できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">量子チェーンの表現に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づくシリアル変換の例は</font><font style="vertical-align: inherit;">次のとおりです。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/ef3/1cb/134ef31cb001fc1c9ff3c3854d32838b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、ビット|0⟩で開始し、ビット反転を適用してから、アダマール演算を適用し、次に別のビット反転を適用し、さらにアダマール演算を実行した後、最終的なビット反転を実行すると、ベクトルが得られます。チェーンの右側にあります。さまざまなステートマシンを互いに重ね合わせることで、|0⟩から始め、各変換に対応する色付きの矢印を追跡して、これがどのように機能するかを理解できます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここまで行ってきたので、量子アルゴリズムのタイプの1つ、つまり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドイツ・ジョージアルゴリズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を検討</font><font style="vertical-align: inherit;">し、古典的なコンピューターに対するその利点を示します。 Deutsch-Jojiアルゴリズムは完全に決定論的です。つまり、（量子ビットの確率論的決定に基づく他の多くの量子アルゴリズムとは異なり）ケースの100％で正解を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1ビットに関数/演算子を含むブラックボックスがあるとしましょう（1ビットを使用する場合、4つの操作のみが可能です：変換、否定、定数「0」の計算、定数「1」の計算）。ボックスではどのような機能が実行されますか？どれがどれかはわかりませんが、入力値のバリエーションを好きなだけ並べ替えて、出力で結果を評価できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5e/f24/938/c5ef249384466b29fb07ea99b2c1b000.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どの機能が使用されているかを確認するために、ブラックボックスを介して駆動する必要がある入力信号と出力信号の数少し考えてみてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラシックコンピュータの場合、使用する関数を決定するには2つのクエリを実行する必要があります。たとえば、「1」を入力すると、出力に「0」が表示される場合、定数「0」を計算する関数または否定関数が使用されていることが明らかになり、その後、入力信号の値を「0」に変更して、何が起こるかを確認する必要があります。出口で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
量子コンピューターの場合は、入力値に適用される正確な関数を決定するために2つの異なる出力値が必要なため、2つのクエリも必要になります。ただし、質問を少し再定式化すると、量子コンピューターには依然として重大な利点があることがわかります。使用する関数が定数または変数のどちらであるかを確認したい場合、優位性は量子コンピューター側にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボックスで使用される関数は変数であり、入力信号の異なる値が出力で異なる結果をもたらす場合（たとえば、ビットの同一の変換と反転）、出力値が入力値に関係なく変化しない場合、関数は定数です（たとえば、定数の計算） 「1」または定数「0」の計算）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
量子アルゴリズムを使用すると、1つのリクエストのみに基づいて、ブラックボックス内の関数が定数か変数かを判断できます。</font><font style="vertical-align: inherit;">しかし、これを行う方法を詳細に検討する前に、これらの各関数を量子コンピューター上で構造化できる方法を見つける必要があります。</font><font style="vertical-align: inherit;">量子演算子は可逆でなければならないため、すぐに問題が発生します。定数「1」と「0」を計算する関数はそうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
量子コンピューティングでは、次のソリューションがよく使用されます。追加の出力キュービットが追加され、関数が受け取った入力信号の任意の値を返します。&nbsp;</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前：</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後：</font></font><br>
</td>
</tr>
<tr>
<td><img src="https://habrastorage.org/webt/xi/kq/k3/xikqk3njz-k-xetlo8efjhjsggk.png"><br>
</td>
<td><img src="https://habrastorage.org/webt/lj/rq/f9/ljrqf955o6xtubsf9mrrvridfko.png"><br>
</td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、出力で得られた値に基づいて入力値を単独で決定でき、関数は反転可能になります。量子回路の構造により、追加の入力ビットが必要になります。対応する演算子を開発するために、追加の入力キュービットが|0⟩に設定されていると仮定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前に使用したのと同じ量子チェーンの表現を適用して、4つの要素（恒等変換、否定、定数「0」の計算および定数「1」の計算）のそれぞれが量子演算子を使用してどのように実装できるかを確認します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、定数「0」を計算する関数を実装できます。定数「0」の</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/395/b09/e52/395b09e5258ce87f8f9a873d573853c2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、オペレーターはまったく必要ありません。</font><font style="vertical-align: inherit;">最初の入力キュービット（|0⟩に等しい）は同じ値で戻り、2番目の入力値は通常どおりそれ自体を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数「1」を計算する関数を使用すると、状況は少し異なります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数「1」の計算：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/82d/51e/fbe82d51e97a2c5cc8d7b4d5446555c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の入力量子ビットは常に|0⟩に設定されることを受け入れたため、ビット反転演算子を適用した結果、出力で常に1が得られます。</font><font style="vertical-align: inherit;">そしていつものように、2番目の量子ビットは出力で独自の値を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
恒等変換演算子が表示されると、タスクはより複雑になります。</font><font style="vertical-align: inherit;">これを行う方法は次のとおりです</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ID変換：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/a2c/0c9/3bca2c0c97de2080ae979084924569a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで使用されている記号はCNOT要素を示しています。上の線は制御ビットを示し、下の線は制御ビットを示します。 CNOT演算子を使用する場合、制御ビットが|1⟩の場合、制御ビットの値は変更されますが、制御ビットが|0⟩の場合、変更されないままです。上の線の値は常に|0⟩に等しいと想定したため、その値は常に下の線に割り当てられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、否定演算子を使用します：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否定：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e0/9ea/05e/3e09ea05eb3aa4509360adb50250a57d.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力ラインの最後のビットを反転するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予備的なプレゼンテーションを理解したところで、1つのクエリのみを使用してブラックボックスに隠された関数の不変性または変動性を決定することに関して、従来のコンピューターに対する量子コンピューターの特定の利点を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のクエリで量子コンピューティングを使用してこの問題を解決するには、以下に示すように、入力キュビットを関数に転送する前に、重ね合わせに変換する必要があります。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/ed6/9ca/e76ed69ca877e88a0cc269a5a3a27770.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アダマール要素は、関数を使用して重ね合わせからキュービットを導出し、アルゴリズムを確定的にする結果に再適用されます。</font><font style="vertical-align: inherit;">システムを|00⟩の状態で起動し、次に説明する理由により、使用される関数が定数の場合、結果は| 11 |になります。</font><font style="vertical-align: inherit;">ブラックボックス内の関数が可変の場合、システムの測定後に結果| 01 |が返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の残りの部分を処理するために、前に示した図を見てみましょう。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビット反転演算子を使用してから、アダマール要素を|0⟩に等しい両方の入力値に適用すると、それらが同じ重ね合わせ|0⟩および|1⟩に変換されます。つまり、</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a0/f37/764/6a0f37764e197dc76be36173f72b2f7a.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この値をブラックボックス内の関数に転送する例を使用すると、定数値の両方の関数が出力に|11⟩を与えることを簡単に示すことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数「0」の計算：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/675/2ca/9596752cadbc0194e1883322fed9ba2d.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、定数「1」を計算するための関数も|11⟩を与えることがわかります。つまり、</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数「1」の計算：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/628/2d3/bd76282d39512c75f15d30cbc18ade2a.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：出力では、-1²= 1であるため、両方の値は|1⟩に等しくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ原理により、両方の変数関数を使用すると、出力で常に|01⟩が得られることを証明できます（ただし、同じメソッドが使用されている場合）。ここではすべてが少し複雑です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイデンティティの変革：</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/771/51d/245/77151d245aa16fa8f8832ef4a4026576.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CNOTは2キュービット演算子であるため、単純な状態機械として表すことはできません。したがって、前述の原理に従って、両方の入力キュービットのテンソル積とCNOT行列の乗算に基づいて2つの出力信号を決定する必要があります。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/c25/1ee/d11c251ee0068742d7004e5fe2fe0fe8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法を使用すると、ブラックボックスで否定関数が非表示になっている場合、出力の値が| 01であることも確認できます</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/9a3/120/29b9a31201cd3ce106480ba82f40970e.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、量子コンピュータが従来のコンピュータよりもはるかに効率的である状況を示したところです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次は何？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれを終わらせることを提案します。私たちはすでに素晴らしい仕事をしました。私が話したすべてを理解していれば、量子計算と量子論理の基本に精通していると思います。また、特定の状況で量子アルゴリズムが従来の計算方法よりも効果的である理由を理解していると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の説明を量子コンピューティングとアルゴリズムの完全なガイドと呼ぶのは難しいです。これは、数学と表記システムの簡単な紹介であり、人気の科学情報源によって課された主題に関する読者の考えを払拭するように設計されています（真剣に、多くの人が実際に状況を理解することはできません！）。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">キュービットの量子もつれ</font></a><font style="vertical-align: inherit;">など、多くの重要なトピックに触れる時間はありませんでした</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、振幅値の複雑さ|0⟩および|1⟩と、ブロッホ球による変換中のさまざまな量子論理要素の機能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
量子コンピュータの知識を体系化して構造化したい場合は、</font><font style="vertical-align: inherit;">&nbsp;Emma Strubelの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">「量子アルゴリズム入門</font></a><font style="vertical-align: inherit;">」を読むこと</font><font style="vertical-align: inherit;">を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強く</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お勧めします。&nbsp; </font><font style="vertical-align: inherit;">豊富な数式にかかわらず、この本では量子アルゴリズムについて詳しく説明しています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja476428/index.html">Nginx VTS Stats、Mockify-モックAPI、WiremockおよびMockifyの比較</a></li>
<li><a href="../ja476430/index.html">完璧な技術ポートフォリオを作成する方法</a></li>
<li><a href="../ja476434/index.html">放棄されたデバイス用のUSBドライバーの作成</a></li>
<li><a href="../ja476436/index.html">ロボットオペレーティングシステムに関するロボット開発者のロシアでの最初の会議からのレポート</a></li>
<li><a href="../ja476442/index.html">いくつかのスペースまたは周波数計のようなマイクロコントローラを与える</a></li>
<li><a href="../ja476446/index.html">Jiraプラグイン：成功した自転車発明のいくつかの例</a></li>
<li><a href="../ja476448/index.html">ジャーニーゲームのサンドシェーダーの探索</a></li>
<li><a href="../ja476450/index.html">cPanelの概要-サイトの管理とホスティングのためのWebベースのコンソール</a></li>
<li><a href="../ja476452/index.html">Key-Valueストレージ、またはアプリケーションがより便利になった方法</a></li>
<li><a href="../ja476454/index.html">5Gの到来：2020年に新技術の導入を確実にする企業</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>