<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍾 🔰 💕 ウィジェットを備えたバックエンド駆動のUI 👩🏿‍🔧 👼🏿 🤵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このアプローチの特徴とウィジェットを使用した実装、その概念、利点、Androidの他のビューとの違いを検討してください。
 
 
 
 バックエンド駆動型UI-サーバーの応答に基づいてUIコンポーネントを作成できるアプローチ。 APIの説明にはコンポーネントのタイプとそのプロパティが含まれている必要...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ウィジェットを備えたバックエンド駆動のUI</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/498664/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このアプローチの特徴とウィジェットを使用した実装、その概念、利点、Androidの他のビューとの違いを検討してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0z/p9/hd/0zp9hdtjfkdd28_s70pm46rqvw0.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンド駆動型UI-サーバーの応答に基づいてUIコンポーネントを作成できるアプローチ。 APIの説明にはコンポーネントのタイプとそのプロパティが含まれている必要があり、アプリケーションはタイプとプロパティに応じて必要なコンポーネントを表示する必要があります。一般に、コンポーネントのロジックは設定できます。モバイルアプリケーションの場合、コンポーネントはブラックボックスです。各コンポーネントは、アプリケーションの残りの部分から独立したロジックを持つことができ、必要なビジネスロジックに応じて、サーバーによって任意に設定できるためです。そのため、この方法は銀行のアプリケーションでよく使用されます。たとえば、動的に定義された多数のフィールドを持つ翻訳フォームを表示する必要がある場合などです。アプリケーションはフォームの構成とその中のフィールドの順序を事前に知らないため、このアプローチは、松葉杖なしでコードを記述する唯一の方法です。さらに、柔軟性が追加されます。サーバー側からいつでもフォームを変更でき、モバイルアプリケーションでこれに対応できます。</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用事例</font></font></h3><br>
<img src="https://habrastorage.org/webt/kd/ao/vw/kdaovw36bkxi3ec-y5ajmidakke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコンポーネントのタイプは次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送可能なアカウントのリスト。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳のタイプの名前。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電話番号を入力するためのフィールド（入力用のマスクがあり、デバイスから連絡先を選択するためのアイコンが含まれています）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">振込金額を入力するフィールド。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、フォームでは、ビジネスロジックに組み込まれ、設計段階で決定された他のコンポーネントをいくつでも使用できます。サーバーからの応答に含まれる各コンポーネントに関する情報は要件を満たしている必要があり、各コンポーネントがモバイルアプリケーションで正しく処理されることが期待されている必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/3g/hu/j93ghualguxt2lxhch93sraomys.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力フィールドが異なれば、マスクと検証ルールも異なります。ボタンには、起動時にきらめくアニメーションが表示される場合があります。精算勘定を選択するためのウィジェットは、スクロール時にアニメーションを表示できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのUIコンポーネントは互いに独立しており、ロジックは責任の異なる領域を持つ個別のビューに取り出すことができます。ウィジェットと呼びましょう。各ウィジェットは、サーバーの応答で構成を受け取り、表示とデータ処理のロジックをカプセル化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面を実装する場合、RecyclerViewが最適であり、その要素にはウィジェットが含まれます。</font><font style="vertical-align: inherit;">各一意のリスト項目のViewHolderはウィジェットを初期化し、ウィジェットに表示する必要があるデータを与えます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットのコンセプト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットについてさらに詳しく考えてみましょう。</font><font style="vertical-align: inherit;">基本的に、ウィジェットは「最大速度」のカスタムビューです。</font><font style="vertical-align: inherit;">通常のカスタムビューには、データとその表示のロジックを含めることもできますが、ウィジェットはさらに何かを意味します-プレゼンター、画面モデル、独自のDIスコープがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットの実装の詳細に入る前に、ウィジェットの利点について説明します。</font></font><br>
<br>
<ul>
<li>     ,   ,   «» ,       —     UI-  ,             .</li>
<li>        ,         ,         .</li>
<li>,     —        :  ,      ,    .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケーラブルなウィジェットを実装するために、独自のDIスコープを持つ最も一般的に使用されるViewGroupの基本クラスを使用します。次に、すべての基本クラスは、ウィジェットの初期化に必要なすべてを含む共通インターフェースから継承されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットを使用する最も簡単なケースは、レイアウトで直接指定される静的ビューです。ウィジェットクラスを実装した後、レイアウトでIDを指定することを忘れずに、それをXMLレイアウトに安全に追加できます（IDに基づいて、ウィジェットのDIスコープが形成されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、動的ウィジェットについて詳しく説明します。任意のフィールドセットを使用する上記の翻訳フォームの場合は、それらの助けを借りて便利に解決できるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの実装における静的および動的の両方のウィジェットは、MVPの点で通常のビューとほとんど変わりません。</font><font style="vertical-align: inherit;">通常、ウィジェットを実装するには4つのクラスが必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイアウトレイアウトとコンテンツの表示が行われるビュークラス。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidget</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        context: Context,<font></font>
        attrs: AttributeSet? = <span class="hljs-literal">null</span><font></font>
) : CoreFrameLayoutView(context, attrs) {<font></font>
<span class="hljs-meta">@Inject</span>
<span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> presenter: TextInputFieldPresenter<font></font>
…<font></font>
<span class="hljs-keyword">init</span> {<font></font>
     inflate(context, R.layout.view_field_text_input, <span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットの基本的なロジックが記述されているプレゼンターのクラス。次に例を示します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> レンダリングのためにデータをロードして送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> さまざまなイベントをサブスクライブし、ウィジェット入力変更のイベントを発行します。</font></font></li>
</ol><br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@PerScreen</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldPresenter</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        basePresenterDependency: BasePresenterDependency,<font></font>
        rxBus: RxBus<font></font>
) : BaseInputFieldPresenter&lt;TextInputFieldWidget&gt;(<font></font>
       basePresenterDependency, rxBus<font></font>
) {<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TextInputFieldScreenModel()<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの実装では、RxBusクラスは、イベントを送信してサブスクライブするためのPublishSubjectベースのバスです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンターがデータを受け取り、ビューでレンダリングするためにデータを転送する（プレゼンテーションモデルパターンの観点から）画面モデルのクラス。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldScreenModel</span> : <span class="hljs-type">ScreenModel</span></span>() {
	<span class="hljs-keyword">val</span> value = String = “”
	<span class="hljs-keyword">val</span> hint = String = “”
	<span class="hljs-keyword">val</span> errorText = String = “”<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIを実装するためのコンフィギュレータークラス。ウィジェットのどの依存関係が提供され、目的のスコープを持ち、プレゼンターがそのビューに挿入されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidgetConfigurator</span> : <span class="hljs-type">WidgetScreenConfigurator</span></span>() {
	<span class="hljs-comment">// logic for components injection</span><font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットと本格的な画面の実装（Activity、Fragment）の唯一の違いは、ウィジェットに多くのライフサイクルメソッド（onStart、onResume、onPause）がないことです。</font><font style="vertical-align: inherit;">ウィジェットが現在そのスコープを作成していることを示すonCreateメソッドのみがあり、スクープはonDetachedFromWindowメソッドで破棄されます。</font><font style="vertical-align: inherit;">ただし、利便性と一貫性のために、ウィジェットのプレゼンターは、他の画面と同じライフサイクルメソッドを取得します。</font><font style="vertical-align: inherit;">これらのイベントは、親から彼に自動的に送信されます。</font><font style="vertical-align: inherit;">ウィジェットプレゼンターの基本クラスは、他の画面のプレゼンターの基本クラスと同じであることに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的ウィジェットの使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の冒頭で説明したケースの実装に移りましょう。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面プレゼンターでは、翻訳フォームのデータが読み込まれ、レンダリングのためにデータがビューに送信されます。</font><font style="vertical-align: inherit;">この段階では、アクティビティ画面のビューがフラグメントであるかウィジェットであるかは重要ではありません。</font><font style="vertical-align: inherit;">RecyclerViewを用意し、それを使用して動的フォームをレンダリングすることにのみ関心があります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormPresenter</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TransferFormScreenModel()<font></font>
…<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {<font></font>
	loadDataDisposable.dispose()<font></font>
  	loadDataDisposable = subscribe(<font></font>
              observerDataForTransfer().io(), <font></font>
              { <span class="hljs-keyword">data</span> -&gt; <font></font>
                      sm.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span><font></font>
                      view.render(sm)<font></font>
              },<font></font>
              { error -&gt; <span class="hljs-comment">/* error handling */</span> }<font></font>
  	)<font></font>
 }<font></font>
</code></pre><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォームデータはリストアダプターに転送され、ViewHolderにあるウィジェットを使用して、一意のフォーム要素ごとにレンダリングされます。</font><font style="vertical-align: inherit;">コンポーネントのレンダリングに必要なViewHolderは、事前定義されたタイプのフォームコンポーネントに基づいて決定されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormView</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(sm: <span class="hljs-type">TransferFormScreenModel</span>)</span></span> {
    <span class="hljs-comment">//      </span>
    <span class="hljs-comment">//   EasyAdapter [3]</span>
    <span class="hljs-keyword">val</span> list = ItemList.create()
    <span class="hljs-comment">//       Controller,</span>
    <span class="hljs-comment">//       </span><font></font>
<font></font>
    sm.<span class="hljs-keyword">data</span><font></font>
        .filter { transferField -&gt; transferField.visible }<font></font>
        .forEach { transferField -&gt;<font></font>
            <span class="hljs-keyword">when</span> (transferField.type) {<font></font>
                TransferFieldType.PHONE_INPUT -&gt; {<font></font>
                    list.add(<font></font>
                        PhoneInputFieldData(transferField),<font></font>
                        phoneInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.MONEY -&gt; {<font></font>
                    list.add(<font></font>
                        MoneyInputFieldData(transferField),<font></font>
                        moneyInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.BUTTON -&gt; {<font></font>
                    list.add(<font></font>
                        ButtonInputFieldData(transferField),<font></font>
                        buttonController<font></font>
                    )<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> -&gt; {<font></font>
                    list.add(<font></font>
                        TextInputFieldData(transferField),<font></font>
                        textInputController<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-comment">//     RecyclerView</span><font></font>
        adapter.setItems(list)<font></font>
}  <font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットは、ViewHolderのbindメソッドで初期化されます。</font><font style="vertical-align: inherit;">レンダリング用のデータを送信することに加えて、ウィジェットの一意のIDを設定することも重要です。これに基づいて、DIスコープが形成されます。</font><font style="vertical-align: inherit;">私たちの場合、フォームの各要素には一意のIDがあり、これは入力のアポイントメントを担当し、要素のタイプに加えて応答しました（タイプはフォームで繰り返すことができます）。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ViewHolder</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">TransferFieldUi</span>)</span></span> {
	<span class="hljs-comment">// get initialize params from given data</span><font></font>
	itemView.findViewById(R.id.field_tif).initialize(...)<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initializeメソッドはウィジェットビューデータを初期化し、それがonCreateライフサイクルメソッドを使用してプレゼンターに送信されます。ここで、フィールド値はウィジェットモデルとそのレンダリングに設定されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">(
       id: <span class="hljs-type">String</span> = this.id,
       value: <span class="hljs-type">String</span> = this.value,
       hint: <span class="hljs-type">String</span> = this.hint,
       errorText: <span class="hljs-type">String</span> = this.errorText
)</span></span> {
       <span class="hljs-keyword">this</span>.id = id
       <span class="hljs-keyword">this</span>.value = value
       <span class="hljs-keyword">this</span>.hint = hint
       <span class="hljs-keyword">this</span>.errorText = errorText<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
       presenter.onCreate(value, hint, errorText)<font></font>
       <span class="hljs-comment">// other logic...</span><font></font>
}<font></font>
<span class="hljs-comment">// TextInputFieldPresenter</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, hint: <span class="hljs-type">String</span>, errorText: <span class="hljs-type">String</span>)</span></span> {<font></font>
       sm.value = value<font></font>
       sm.hint = hint<font></font>
       sm.errorText = errorText<font></font>
       view.render(sm)<font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水中の岩</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明からわかるように、実装は非常にシンプルで直感的です。</font><font style="vertical-align: inherit;">ただし、考慮が必要なニュアンスがあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットのライフサイクルを検討する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットの基本クラスは、一般的に使用されるViewGroupsの継承クラスであるため、ウィジェットのライフサイクルも知っています。</font><font style="vertical-align: inherit;">通常、ウィジェットは、前の段落で示したように、データが転送される特別なメソッドを呼び出すことによってViewHolderで初期化されます。</font><font style="vertical-align: inherit;">その他の初期化はonCreateで行われます（たとえば、クリックリスナーの設定）-このメソッドは、ウィジェットロジックのキーエンティティを制御する特別なデリゲートを使用して、onAttachedToWindowの後に呼び出されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// CoreFrameLayoutView (      ViewGroup)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreFrameLayoutView</span></span><font></font>
          extends FrameLayout implements CoreWidgetViewInterface {<font></font>
…<font></font>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onAttachedToWindow() {
   <span class="hljs-keyword">super</span>.onAttachedToWindow();
   <span class="hljs-keyword">if</span> (!isManualInitEnabled) {<font></font>
        widgetViewDelegate = createWidgetViewDelegate();<font></font>
        widgetViewDelegate.onCreate();<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
    <span class="hljs-comment">//empty. define in descendant class if needed</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WidgetViewDelegate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetViewDelegate</span> </span>{<font></font>
…<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
   <span class="hljs-comment">// other logic of widget initialization</span><font></font>
   coreWidgetView.onCreate();<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にリスナーを掃除する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォームに依存フィールドがある場合は、onDetachedFromWindowが必要になることがあります。</font><font style="vertical-align: inherit;">次のケースを考えてみます。翻訳フォームには多くのフィールドがあり、その中にドロップダウンリストがあります。</font><font style="vertical-align: inherit;">リストで選択した値によっては、追加のフォーム入力フィールドが表示されるか、既存のフォーム入力フィールドが非表示になる場合があります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳のタイプを選択するためのドロップダウン値</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支払期間入力フィールドの可視性</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電話番号入力フィールドの可視性</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電話番号で転送</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支払い</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の場合、ウィジェットをリストに再度追加するとすべてのリスナーが再初期化されるため、onDetachedFromWindowメソッドですべてのウィジェットリスナーをクリアすることが非常に重要です。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
     initListeners()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> {
      <span class="hljs-keyword">super</span>.onDetachedFromWindow()<font></font>
      clearListeners()<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットイベントサブスクリプションを正しく処理する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィジェットを含む画面の表示は、各ウィジェットの入力の変更を通知する必要があります。エミットイベントを使用し、スクリーンプレゼンターですべてのイベントをサブスクライブする各ウィジェットの最も明白な実装。イベントには、ウィジェットIDとそのデータが含まれている必要があります。このロジックを実装して、現在の入力値が画面モデルに保存され、ボタンをクリックすると、完成したデータがリクエストで送信されるようにするのが最適です。この方法を使用すると、フォームの検証を実装するのが簡単になります。これは、ボタンがクリックされたときに発生し、エラーがない場合は、事前に保存されたフォームデータを使用してリクエストが送信されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTextChangedListener = <span class="hljs-keyword">object</span> : OnMaskedValueChangedListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onValueChanged</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {<font></font>
            presenter.onTextChange(value, id)<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Events.kt</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputValueType</span></span>(<span class="hljs-keyword">val</span> id: String)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextValue</span></span>(id: String, <span class="hljs-keyword">val</span> value: String) : InputValueType(id)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataEvent</span></span>(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: InputValueType)<font></font>
<font></font>
<span class="hljs-comment">// TextInputFieldPresenter -  </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChange</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, id: <span class="hljs-type">String</span>)</span></span> {<font></font>
	rxBus.emitEvent(DataEvent(<span class="hljs-keyword">data</span> = TextValue(id = id, value = value)))<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// TransferFormPresenter -  </span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeToEvents</span><span class="hljs-params">()</span></span> {<font></font>
	subscribe(rxBus.observeEvents(DataEvent::<span class="hljs-keyword">class</span>.java))<font></font>
        {<font></font>
            handleValue(it.<span class="hljs-keyword">data</span>) // handle <span class="hljs-keyword">data</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handleValue(value: InputValueType) {
	 <span class="hljs-keyword">val</span> id = value.id
	 <span class="hljs-keyword">when</span> (value) {<font></font>
		 // handle event using its type, saving event value using its id<font></font>
	 	 <span class="hljs-keyword">is</span> TextValue -&gt; {<font></font>
       		 	 sm.fieldValuesMap[id] = value.value<font></font>
       	 	 }<font></font>
		 <span class="hljs-keyword">else</span> -&gt; {<font></font>
			// handle other events<font></font>
		 }<font></font>
 	 }<font></font>
}<font></font>
// TransferScreenModel<font></font>
<span class="hljs-keyword">class</span> TransferScreenModel : ScreenModel() {<font></font>
 	 // map <span class="hljs-keyword">for</span> form values: key = input id
	 <span class="hljs-keyword">val</span> fieldValuesMap: MutableMap&lt;String, String&gt; = mutableMapOf()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の実装オプションがあります。このオプションでは、ウィジェットからのイベントとそのデータは、ボタンをクリックした後にのみ発生し、入力時には発生しません。つまり、リクエストを送信する直前にすべてのデータを収集します。</font><font style="vertical-align: inherit;">このオプションを使用すると、イベントの数ははるかに少なくなりますが、この実装は実際には簡単ではないことが判明し、すべてのイベントが受信されたかどうかを確認するために追加のロジックが必要になることに注意してください。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての要件を統合</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のケースは、バックエンドと要件を調整した後にのみ可能であることを再度述べておきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統一する必要のある要件：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドタイプ。</font><font style="vertical-align: inherit;">各フィールドは、正しい表示と処理のためにモバイルアプリケーションによって期待されます。</font></font></li>
<li>  —     ,   ,     ,        .</li>
<li>   ,         .</li>
<li> .    ,          : ,    ,     —              ,        -,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/vy/h-/v4/vyh-v4r81dk91ehe3t3j8fgurkq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、応答で受信されたコンポーネントが正しい表示とロジックの処理のためにモバイルアプリケーションに認識されるために必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目のニュアンスは、フォームのコンポーネント自体が一般に互いに独立していることですが、たとえば、上記のように、ある要素の可視性が別の要素の状態に依存する場合など、いくつかのシナリオが考えられます。</font><font style="vertical-align: inherit;">このロジックを実装するには、依存する要素が常に一緒になり、応答にはロジックの説明が含まれている必要があります。</font><font style="vertical-align: inherit;">そしてもちろん、これらすべては、開発を始める前にサーバーチームと合意する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、動的なリストを埋めるなどの標準的なケースを実装する場合でも、既存のソリューションを常に利用できるわけではありません。</font><font style="vertical-align: inherit;">私たちにとってこれは新しい概念であり、巨大な画面からロジックとアトミックのアトミックな部分を選択できるようになり、他のビューとウィジェットが類似しているため、メンテナンスが容易で機能する拡張可能なソリューションを得ることができました。</font><font style="vertical-align: inherit;">私たちの実装では、ウィジェットはRxPMパターンの観点から開発されました-バインダーを追加した後、ウィジェットを使用することがさらに便利になりましたが、これは完全に別の話です。</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></b></h4><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Androidアプリケーション開発</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">フレームワークSurf</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィジェットモジュール</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当社</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な、複雑なリストのレンダリング</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PresentationModelパターン</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja498654/index.html">VPS / VDSとは何ですか？最もわかりやすい説明</a></li>
<li><a href="../ja498656/index.html">クローンバッテリーテスト</a></li>
<li><a href="../ja498658/index.html">OWASPコンソーシアム更新されたWebセキュリティテストガイド</a></li>
<li><a href="../ja498660/index.html">無人トラムが実際の都市をどのように見ているか</a></li>
<li><a href="../ja498662/index.html">COVID-19がGoogleの検索結果を永久に変えるにはどうすればよいですか？</a></li>
<li><a href="../ja498672/index.html">ボタンとその種類</a></li>
<li><a href="../ja498674/index.html">製品セキュリティの傾向2020オンライン会議のビデオ録画</a></li>
<li><a href="../ja498678/index.html">山の頂上とキリストの像の近くのフォンドスコープへのマッピング-プロジェクターを使用して困難な時期にサポートの言葉を表現する方法</a></li>
<li><a href="../ja498680/index.html">Eスポーツクラブを単独で：生き残るだけでなく稼ぐ機会としての分散型ゲーム</a></li>
<li><a href="../ja498682/index.html">Goでランダムパスワードジェネレーターを作成する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>