<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎉 🧔🏼 ⏱️ Accélérer le décompte POSTGRESQL (*) 🚡 🏬 👷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On se plaint souvent que le nombre (*) dans PostgreSQL est très lent. 
 
 Dans cet article, je souhaite explorer les options afin d'obtenir le résulta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Accélérer le décompte POSTGRESQL (*)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490320/"><img src="https://habrastorage.org/webt/gd/v7/vr/gdv7vrlvosn5rd46igghex_2ofe.png" height="60%" width="60%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On se plaint souvent que le nombre (*) dans PostgreSQL est très lent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, je souhaite explorer les options afin d'obtenir le résultat le plus rapidement possible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi le décompte (*) est-il si lent?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des gens comprennent sans problème que la requête suivante sera exécutée lentement:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*)
<span class="hljs-keyword">FROM</span> <span class="hljs-comment">/*   */</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit, après tout, d'une requête complexe, et PostgreSQL doit calculer le résultat avant de savoir combien de lignes il contiendra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais beaucoup de gens sont choqués lorsqu'ils découvrent que la requête suivante est lente:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">FROM</span> large_table;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si vous pensez à nouveau, tout ce qui précède est vrai: PostgreSQL doit calculer le jeu de résultats avant de pouvoir le compter. </font><font style="vertical-align: inherit;">Comme le «compteur de lignes magiques» n'est pas stocké dans la table (comme dans MyISAM MySQL), la seule façon de compter les lignes est de les regarder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, count (*) effectue généralement des analyses de table séquentielles, ce qui peut être assez coûteux.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le "*" dans le décompte (*) est-il un problème?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le "*" dans SELECT * FROM ... s'applique à toutes les colonnes. </font><font style="vertical-align: inherit;">Par conséquent, de nombreuses personnes trouvent que l'utilisation de count (*) est inefficace et utilisent plutôt count (id) ou count (1) à la place. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais le "*" dans count (*) est complètement différent, cela signifie simplement "string" et ne se développe pas du tout (en fait, c'est "un agrégat avec zéro argument"). </font><font style="vertical-align: inherit;">La notation count (1) ou count (id) est en fait plus lente que count (*), car il faut vérifier si l'argument est NULL ou non (count, comme la plupart des agrégats, ignore les arguments NULL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous n'obtiendrez donc rien en évitant le "*".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analyse d'index uniquement</font></font></i></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est tentant d'analyser un petit index, pas la table entière, pour compter le nombre de lignes. Cependant, ce n'est pas si simple dans PostgreSQL en raison de sa stratégie de gestion des accès simultanés multi-versions. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque version de la ligne («tuple») contient des informations sur l'instantané de base de données auquel elle est visible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais ces informations (redondantes) ne sont pas stockées dans des index. Par conséquent, il n'est généralement pas suffisant de compter les entrées dans l'index, car PostgreSQL doit regarder l'entrée de table («tuple de tas») pour s'assurer que l'entrée d'index est visible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour atténuer ce problème, PostgreSQL a mis en œuvre une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carte de visibilité</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une structure de données qui stocke des informations indiquant si tous les tuples d'un bloc de table sont visibles par tout le monde ou non.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la plupart des blocs du tableau sont entièrement visibles, les analyses d'index ne nécessitent pas de visites fréquentes à un groupe de tuples pour déterminer la visibilité. </font><font style="vertical-align: inherit;">Une telle analyse d'index est appelée «analyse d'index uniquement» et il est souvent plus rapide d'analyser un index pour compter les lignes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, c'est VACUUM qui prend en charge la carte de visibilité, alors assurez-vous que l'auto-vide est effectué assez souvent si vous souhaitez utiliser un petit index pour accélérer le comptage (*).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation du tableau croisé dynamique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai écrit ci-dessus que PostgreSQL ne stocke pas le nombre de lignes dans une table. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le maintien d'un tel nombre de lignes est une surcharge importante, car cet événement se produit à chaque modification de données et ne rapporte pas. Ce serait une mauvaise affaire. De plus, étant donné que différentes requêtes peuvent voir différentes versions de chaînes, le compteur doit également être versionné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais rien ne vous empêche d'implémenter vous-même un tel compteur de lignes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que vous souhaitiez suivre le nombre de lignes dans une mytable. Vous pouvez le faire comme suit:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<font></font>
 <font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable_count(c <span class="hljs-built_in">bigint</span>);<font></font>
 <font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> mytable_count() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">trigger</span>
   <span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span>
$$<span class="hljs-keyword">BEGIN</span>
   <span class="hljs-keyword">IF</span> TG_OP = <span class="hljs-string">'INSERT'</span> <span class="hljs-keyword">THEN</span>
      <span class="hljs-keyword">UPDATE</span> mytable_count <span class="hljs-keyword">SET</span> c = c + <span class="hljs-number">1</span>;<font></font>
 <font></font>
      RETURN NEW;<font></font>
   ELSIF TG_OP = '<span class="hljs-keyword">DELETE</span><span class="hljs-string">' THEN
      UPDATE mytable_count SET c = c - 1;
 
      RETURN OLD;
   ELSE
      UPDATE mytable_count SET c = 0;
 
      RETURN NULL;
   END IF;
END;$$;
 
CREATE CONSTRAINT TRIGGER mytable_count_mod
   AFTER INSERT OR DELETE ON mytable
   DEFERRABLE INITIALLY DEFERRED
   FOR EACH ROW EXECUTE PROCEDURE mytable_count();
 
-- TRUNCATE triggers must be FOR EACH STATEMENT
CREATE TRIGGER mytable_count_trunc AFTER TRUNCATE ON mytable
   FOR EACH STATEMENT EXECUTE PROCEDURE mytable_count();
 
-- initialize the counter table
INSERT INTO mytable_count
   SELECT count(*) FROM mytable;
 
COMMIT;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous faisons tout en une seule transaction afin qu'aucune modification des données sur les transactions simultanées ne puisse être «perdue» en raison d'une condition de sonnerie. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est garanti par la commande CREATE TRIGGER qui verrouille la table en mode SHARE ROW EXCLUSIVE, ce qui empêche toutes les modifications simultanées. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'inconvénient est que toutes les modifications de données parallèles doivent attendre jusqu'à ce que le compte SELECT (*) soit exécuté. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela nous donne une alternative vraiment rapide pour compter (*), mais au prix de ralentir toutes les modifications de données dans le tableau. L'utilisation d'un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déclencheur de contrainte différée</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> garantit que le verrou de ligne dans mytable_count est aussi court que possible pour améliorer la concurrence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le fait que cette table de comptage peut recevoir de nombreuses mises à jour, il n'y a aucun danger</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de "ballonnement de la table"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car toutes ces mises à jour seront "à chaud" (mises à jour CHAUDES).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous avez vraiment besoin de compter (*)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parfois, la meilleure solution est de chercher une alternative. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Souvent, l'approximation est assez bonne et vous n'avez pas besoin du montant exact. </font><font style="vertical-align: inherit;">Dans ce cas, vous pouvez utiliser le score utilisé par PostgreSQL pour planifier des requêtes:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> reltuples::<span class="hljs-built_in">bigint</span>
<span class="hljs-keyword">FROM</span> pg_catalog.pg_class
<span class="hljs-keyword">WHERE</span> relname = <span class="hljs-string">'mytable'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette valeur est mise à jour à la fois par le vide automatique et l'analyse automatique, elle ne doit donc jamais dépasser 10%. </font><font style="vertical-align: inherit;">Vous pouvez réduire autovacuum_analyze_scale_factor pour cette table afin que l'analyse automatique s'exécute plus souvent.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimation du nombre de résultats de requête</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à présent, nous avons exploré comment accélérer le comptage des lignes du tableau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais parfois, vous devez savoir combien de lignes l'instruction SELECT retournera sans réellement exécuter la requête. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toute évidence, la seule façon d'obtenir une réponse précise à cette question est de répondre à la demande. </font><font style="vertical-align: inherit;">Mais si la note est assez bonne, vous pouvez utiliser l'optimiseur PostgreSQL pour l'obtenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction simple suivante utilise SQL dynamique et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLAIN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour obtenir le plan d'exécution de requête passé en argument et retourne une estimation du nombre de lignes:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> row_estimator(<span class="hljs-keyword">query</span> <span class="hljs-built_in">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-built_in">bigint</span>
   <span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span>
$$<span class="hljs-keyword">DECLARE</span><font></font>
   plan jsonb;<font></font>
<span class="hljs-keyword">BEGIN</span>
   <span class="hljs-keyword">EXECUTE</span> <span class="hljs-string">'EXPLAIN (FORMAT JSON) '</span> || <span class="hljs-keyword">query</span> <span class="hljs-keyword">INTO</span> plan;<font></font>
 <font></font>
   RETURN (plan-&gt;0-&gt;'Plan'-&gt;&gt;'Plan Rows')::bigint;<font></font>
<span class="hljs-keyword">END</span>;$$;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'utilisez pas cette fonction pour traiter des instructions SQL non fiables, car elle est intrinsèquement vulnérable à l'injection SQL.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490302/index.html">Apprendre à déployer des microservices. Partie 3. Heaume</a></li>
<li><a href="../fr490306/index.html">Comment nous avons réalisé des maquettes de technologie spatiale pour l'Institut d'aviation de Moscou</a></li>
<li><a href="../fr490310/index.html">Loi de Faraday ou comment un aimant se coince dans un tuyau en cuivre</a></li>
<li><a href="../fr490314/index.html">RE: 23 minutes. Justification de l'esprit lent</a></li>
<li><a href="../fr490318/index.html">Les prothèses bioniques de nos jours</a></li>
<li><a href="../fr490322/index.html">Namibie: les infrastructures et ce qu'il faut savoir avant de voyager</a></li>
<li><a href="../fr490324/index.html">Comment trouver des erreurs non évidentes dans les interfaces d'affectation en ligne pour les enfants</a></li>
<li><a href="../fr490328/index.html">Profession: testeur</a></li>
<li><a href="../fr490332/index.html">Nous faisons un clone du service de livraison de nourriture en utilisant Nuxt.js, GraphQL, Strapi et Stripe. Partie 2/7</a></li>
<li><a href="../fr490336/index.html">Anatomie des canaux dans Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>