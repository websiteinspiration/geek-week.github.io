<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌾 🚴🏽 👨🏻‍🏫 C # -Implementierungen in C # .NET 🕘 🛡️ 🤹🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Im Vorfeld des Kursbeginns "C # ASP.NET Core Developer" haben wir eine Übersetzung von interessantem Material zur Implementierung des Cach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # -Implementierungen in C # .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502974/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Im Vorfeld des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kursbeginns "C # ASP.NET Core Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben wir eine Übersetzung von interessantem Material zur Implementierung des Caches in C # vorbereitet. </font><font style="vertical-align: inherit;">Viel Spaß beim Lesen.</font></font></b></i><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der am häufigsten verwendeten Muster in der Softwareentwicklung ist das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es ist ein einfaches und gleichzeitig sehr effektives Konzept. Die Idee ist, die Ergebnisse der durchgeführten Operationen wiederzuverwenden. Nach einem zeitaufwändigen Vorgang speichern wir das Ergebnis in unserem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Container</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn wir dieses Ergebnis das nächste Mal benötigen, extrahieren wir es aus dem Cache-Container, anstatt erneut eine mühsame Operation ausführen zu müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um beispielsweise einen Benutzeravatar zu erhalten, müssen Sie ihn möglicherweise von der Datenbank anfordern. Anstatt die Anforderung bei jedem Aufruf auszuführen, speichern wir diesen Avatar im Cache und extrahieren ihn jedes Mal aus dem Speicher, wenn Sie ihn benötigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Caching eignet sich hervorragend für Daten, die sich nur selten ändern. </font><font style="vertical-align: inherit;">Oder im Idealfall ändern sie sich nie. </font><font style="vertical-align: inherit;">Daten, die sich ständig ändern, z. B. die aktuelle Uhrzeit, sollten nicht zwischengespeichert werden. Andernfalls besteht die Gefahr, dass Sie falsche Ergebnisse erhalten.</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokaler Cache, persistenter lokaler Cache und verteilter Cache</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt 3 Arten von Caches:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der In-Memory-Cache wird in Fällen verwendet, in denen Sie den Cache nur in einem Prozess implementieren müssen. </font><font style="vertical-align: inherit;">Wenn ein Prozess stirbt, stirbt der Cache damit. </font><font style="vertical-align: inherit;">Wenn Sie denselben Prozess auf mehreren Servern ausführen, verfügen Sie für jeden Server über einen separaten Cache.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permanenter In-Process-Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - In diesem </font><b><font style="vertical-align: inherit;">Fall sichern</font></b><font style="vertical-align: inherit;"> Sie den Cache außerhalb des Prozessspeichers. </font><font style="vertical-align: inherit;">Es kann sich in einer Datei oder in einer Datenbank befinden. </font><font style="vertical-align: inherit;">Es ist komplexer als der Cache im Speicher, aber wenn Ihr Prozess neu gestartet wird, wird der Cache nicht geleert. </font><font style="vertical-align: inherit;">Am besten geeignet für Fälle, in denen das Abrufen eines zwischengespeicherten Elements teuer ist und Ihr Prozess häufig neu gestartet wird.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verteilter Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist, wenn Sie einen gemeinsam genutzten Cache für mehrere Computer benötigen. </font><font style="vertical-align: inherit;">Normalerweise sind dies mehrere Server. </font><font style="vertical-align: inherit;">Der verteilte Cache wird in einem externen Dienst gespeichert. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wenn ein Server ein Cache-Element beibehalten hat, andere Server es auch verwenden können. </font><font style="vertical-align: inherit;">Services wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind dafür großartig.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nur über den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lokalen Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sprechen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primitive Implementierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Erstellung einer sehr einfachen Cache-Implementierung in C #:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NaiveCache</span>&lt;TItem&gt;<font></font>
{<font></font>
    Dictionary&lt;<span class="hljs-keyword">object</span>, TItem&gt; _cache = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">object</span>, TItem&gt;();<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TItem <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;TItem&gt; createItem</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (!_cache.ContainsKey(key))<font></font>
        {<font></font>
            _cache[key] = createItem();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> _cache[key];<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden von:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> _avatarCache = <span class="hljs-keyword">new</span> NaiveCache&lt;<span class="hljs-keyword">byte</span>[]&gt;();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> myAvatar = _avatarCache.GetOrCreate(userId, () =&gt; _database.GetAvatar(userId));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser einfache Code löst ein wichtiges Problem. Um einen Benutzeravatar zu erhalten, ist nur die erste Anforderung die tatsächliche Anforderung aus der Datenbank. Die Avatar-Daten ( </font></font><code>byte []</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) des Ergebnisses der Anforderung werden im Prozessspeicher gespeichert. Alle nachfolgenden Avatar-Anfragen rufen es aus dem Speicher ab, was Zeit und Ressourcen spart. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie die meisten Dinge in der Programmierung sind die Dinge nicht so einfach. Die obige Implementierung ist aus mehreren Gründen keine gute Lösung. Einerseits ist diese Implementierung nicht </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">threadsicher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei Verwendung aus mehreren Threads können Ausnahmen auftreten. Darüber hinaus bleiben zwischengespeicherte Elemente für immer im Speicher, was eigentlich sehr schlecht ist. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund sollten wir Elemente aus dem Cache entfernen:</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Cache kann viel Speicherplatz beanspruchen, was letztendlich aufgrund seines Mangels und seiner Abstürze zu Ausnahmen führt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein hoher Speicherverbrauch kann zu Speicherdruck führen (auch als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GC-Druck bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">In diesem Zustand arbeitet der Garbage Collector viel mehr als er sollte, was die Leistung verringert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Cache muss möglicherweise aktualisiert werden, wenn sich Daten ändern. </font><font style="vertical-align: inherit;">Unsere Caching-Infrastruktur muss diese Funktion unterstützen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Probleme zu lösen, gibt es im Rahmen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von Vertreibungsrichtlinien</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (auch als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen von Richtlinien - Räumungs- / Entfernungsrichtlinien bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Dies sind die Regeln zum Entfernen von Elementen aus dem Cache gemäß der angegebenen Logik. </font><font style="vertical-align: inherit;">Zu den allgemeinen Richtlinien zum Entfernen gehören die folgenden:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Absolute Expiration-Richtlinie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die ein Element nach einer festgelegten Zeit aus dem Cache entfernt, egal was passiert.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Sliding Expiration-Richtlinie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die ein Element aus dem Cache entfernt, wenn für einen bestimmten Zeitraum nicht auf es zugegriffen wurde. </font><font style="vertical-align: inherit;">Das heißt, wenn ich die Ablaufzeit auf 1 Minute einstelle, bleibt das Element im Cache, während ich es alle 30 Sekunden verwende. </font><font style="vertical-align: inherit;">Wenn ich es länger als eine Minute nicht benutze, wird der Artikel gelöscht.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größenbeschränkungsrichtlinie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die Größe des Caches begrenzt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir alles herausgefunden haben, was wir brauchen, gehen wir zu besseren Lösungen über.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bessere Lösungen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu meiner großen Enttäuschung als Blogger hat Microsoft bereits eine wunderbare Cache-Implementierung erstellt. </font><font style="vertical-align: inherit;">Dies beraubte mich der Freude, selbst eine ähnliche Implementierung zu erstellen, aber zumindest ist das Schreiben dieses Artikels auch weniger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Ihnen eine Microsoft-Lösung zeigen, wie Sie sie effektiv einsetzen und dann für einige Szenarien verbessern können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Runtime.Caching / MemoryCache vs Microsoft.Extensions.Caching.Memory</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft hat 2 Lösungen, 2 verschiedene NuGet-Caching-Pakete. </font><font style="vertical-align: inherit;">Beide sind großartig. </font><font style="vertical-align: inherit;">Nach den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empfehlungen von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Microsoft ist die Verwendung vorzuziehen </font></font><code>Microsoft.Extensions.Caching.Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da sie sich besser in Asp integrieren lässt. </font><font style="vertical-align: inherit;">NET Core. </font><font style="vertical-align: inherit;">Es kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problemlos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Asp .NET Core-Abhängigkeitsinjektionsmechanismus integriert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein einfaches Beispiel mit </font></font><code>Microsoft.Extensions.Caching.Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMemoryCache</span>&lt;TItem&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">private</span> MemoryCache _cache = <span class="hljs-keyword">new</span> MemoryCache(<span class="hljs-keyword">new</span> MemoryCacheOptions());<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TItem <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;TItem&gt; createItem</span>)</span><font></font>
    {<font></font>
        TItem cacheEntry;<font></font>
        <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry)) <span class="hljs-comment">//    .</span><font></font>
        {<font></font>
            <span class="hljs-comment">//    ,   .</span><font></font>
            cacheEntry = createItem();<font></font>
            <font></font>
            <span class="hljs-comment">//    . </span><font></font>
            _cache.Set(key, cacheEntry);<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cacheEntry;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden von:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> _avatarCache = <span class="hljs-keyword">new</span> SimpleMemoryCache&lt;<span class="hljs-keyword">byte</span>[]&gt;();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> myAvatar = _avatarCache.GetOrCreate(userId, () =&gt; _database.GetAvatar(userId));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es erinnert sehr an mein eigenes </font></font><code>NaiveCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also was hat sich geändert? </font><font style="vertical-align: inherit;">Erstens ist es eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread-sichere</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementierung. </font><font style="vertical-align: inherit;">Sie können es sicher von mehreren Threads gleichzeitig aufrufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens werden </font></font><code>MemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdrängungsrichtlinien</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berücksichtigt </font><font style="vertical-align: inherit;">, über die wir zuvor gesprochen haben. </font><font style="vertical-align: inherit;">Hier ein Beispiel: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMemoryCache mit Vorkaufsrichtlinien:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryCacheWithPolicy</span>&lt;TItem&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">private</span> MemoryCache _cache = <span class="hljs-keyword">new</span> MemoryCache(<span class="hljs-keyword">new</span> MemoryCacheOptions()<font></font>
    {<font></font>
        SizeLimit = <span class="hljs-number">1024</span><font></font>
    });<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TItem <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;TItem&gt; createItem</span>)</span><font></font>
    {<font></font>
        TItem cacheEntry;<font></font>
        <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry))<span class="hljs-comment">//    .</span><font></font>
        {<font></font>
            <span class="hljs-comment">//    ,   . </span><font></font>
            cacheEntry = createItem();<font></font>
 <font></font>
            <span class="hljs-keyword">var</span> cacheEntryOptions = <span class="hljs-keyword">new</span> MemoryCacheEntryOptions()<font></font>
         	.SetSize(<span class="hljs-number">1</span>)<span class="hljs-comment">// </span>
         	<span class="hljs-comment">//        (  )</span><font></font>
                .SetPriority(CacheItemPriority.High)<font></font>
                <span class="hljs-comment">//       ,    .</span>
                 .SetSlidingExpiration(TimeSpan.FromSeconds(<span class="hljs-number">2</span>))
                <span class="hljs-comment">//       ,    .</span>
                .SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="hljs-number">10</span>));<font></font>
 <font></font>
            <span class="hljs-comment">//    .</span><font></font>
            _cache.Set(key, cacheEntry, cacheEntryOptions);<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cacheEntry;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die neuen Elemente analysieren:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die MemoryCacheOptions wurden hinzugefügt </font></font><code>SizeLimit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch wird unserem Cache-Container eine Richtlinie zur Größenbeschränkung hinzugefügt. </font><font style="vertical-align: inherit;">Der Cache verfügt nicht über einen Mechanismus zum Messen der Größe von Datensätzen. </font><font style="vertical-align: inherit;">Daher müssen wir die Größe jedes Cache-Eintrags festlegen. </font><font style="vertical-align: inherit;">In diesem Fall setzen wir jedes Mal die Größe auf 1 mit </font></font><code>SetSize(1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass unser Cache ein Limit von 1024 Elementen hat.</font></font></li>
<li>     ,      ?       <code>.SetPriority (CacheItemPriority.High)</code>.   : <b>Low (), Normal (), High ()</b>  <b>NeverRemove (  )</b>.</li>
<li><code>SetSlidingExpiration(TimeSpan.FromSeconds(2))</code>  <b>   </b>  2 .  ,         2 ,   .</li>
<li><code>SetAbsoluteExpiration(TimeSpan.FromSeconds(10))</code>  <b>   </b>  10 .  ,       10 ,      .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu den Optionen im Beispiel können Sie auch einen Delegaten festlegen </font></font><code>RegisterPostEvictionCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der beim Löschen des Elements aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein ziemlich breiter Funktionsumfang, aber wir müssen uns dennoch überlegen, ob wir noch etwas hinzufügen können. </font><font style="vertical-align: inherit;">Es gibt tatsächlich ein paar Dinge.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme und fehlende Funktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Implementierung fehlen einige wichtige Teile.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während Sie eine Größenbeschränkung festlegen können, steuert das Caching den Speicherdruck nicht. </font><font style="vertical-align: inherit;">Wenn wir überwachen würden, könnten wir die Politik mit hohem Druck straffen und die Politik mit niedrigem Druck schwächen.</font></font></li>
<li>         ,      .     . , ,    ,        10 .      2    ,  ,     ( ),       .</li>
</ol><br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum </font><b><font style="vertical-align: inherit;">ersten Problem des</font></b><font style="vertical-align: inherit;"> Drucks auf Gleichstrom: Es ist möglich, den Druck auf Gleichstrom durch verschiedene Methoden und Heuristiken zu steuern. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es nicht darum, aber Sie können meinen Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Suchen, Beheben und Verhindern von Speicherlecks in C # .NET: 8 Best Practices“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">, um einige nützliche Methoden zu erfahren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite Problem ist leichter zu lösen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eigentlich ist hier eine Implementierung </font></font><code>MemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die es vollständig löst:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaitToFinishMemoryCache</span>&lt;TItem&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">private</span> MemoryCache _cache = <span class="hljs-keyword">new</span> MemoryCache(<span class="hljs-keyword">new</span> MemoryCacheOptions());
    <span class="hljs-keyword">private</span> ConcurrentDictionary&lt;<span class="hljs-keyword">object</span>, SemaphoreSlim&gt; _locks = <span class="hljs-keyword">new</span> ConcurrentDictionary&lt;<span class="hljs-keyword">object</span>, SemaphoreSlim&gt;();<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;TItem&gt; <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;Task&lt;TItem&gt;&gt; createItem</span>)</span><font></font>
    {<font></font>
        TItem cacheEntry;<font></font>
 <font></font>
        <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry))<span class="hljs-comment">//    .</span><font></font>
        {<font></font>
            SemaphoreSlim mylock = _locks.GetOrAdd(key, k =&gt; <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<font></font>
 <font></font>
            <span class="hljs-keyword">await</span> mylock.WaitAsync();
            <span class="hljs-keyword">try</span><font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry))<font></font>
                {<font></font>
                    <span class="hljs-comment">//    ,   .</span>
                    cacheEntry = <span class="hljs-keyword">await</span> createItem();<font></font>
                    _cache.Set(key, cacheEntry);<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">finally</span><font></font>
            {<font></font>
                mylock.Release();<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cacheEntry;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden von:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> _avatarCache = <span class="hljs-keyword">new</span> WaitToFinishMemoryCache&lt;<span class="hljs-keyword">byte</span>[]&gt;();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> myAvatar =
<span class="hljs-keyword">await</span> _avatarCache.GetOrCreate(userId, <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> _database.GetAvatar(userId));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie in dieser Implementierung versuchen, ein Element abzurufen, warten Sie, bis der erste Thread abgeschlossen ist, wenn dasselbe Element bereits von einem anderen Thread erstellt wird. </font><font style="vertical-align: inherit;">Dann erhalten Sie ein bereits zwischengespeichertes Element, das von einem anderen Thread erstellt wurde.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code-Analyse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Implementierung blockiert die Erstellung eines Elements. </font><font style="vertical-align: inherit;">Ein Schlüssel wird gesperrt. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise auf Alexeys Avatar warten, können wir die zwischengespeicherten Werte von Zhenya oder Barbara immer noch in einem anderen Thread abrufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wörterbuch </font></font><code>_locks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichert alle Sperren. </font><font style="vertical-align: inherit;">Normale Sperren funktionieren nicht </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher müssen wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SemaphoreSlim verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt 2 Überprüfungen, um zu überprüfen, ob der Wert bereits zwischengespeichert ist, wenn </font></font><code>(!_Cache.TryGetValue(key, out cacheEntry))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der im Schloss ist derjenige, der die einzige Erstellung des Elements bereitstellt. </font><font style="vertical-align: inherit;">Eine, die sich zur Optimierung außerhalb des Schlosses befindet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann zu verwenden </font></font><code>WaitToFinishMemoryCache</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Implementierung hat offensichtlich einen gewissen Aufwand. </font><font style="vertical-align: inherit;">Schauen wir uns an, wann es relevant ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie, </font></font><code>WaitToFinishMemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Erstellungszeit eines Elements einen Wert hat und Sie die Anzahl der Erstellungen so gering wie möglich halten möchten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zeit zum Erstellen eines Elements sehr lang ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Element für jeden Schlüssel einmal erstellt werden muss.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht verwenden, </font></font><code>WaitToFinishMemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht keine Gefahr, dass mehrere Threads Zugriff auf dasselbe Cache-Element erhalten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sind nicht kategorisch dagegen, Elemente mehr als einmal zu erstellen. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn eine zusätzliche Abfrage an die Datenbank keine großen Auswirkungen hat.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caching ist ein sehr mächtiges Muster. </font><font style="vertical-align: inherit;">Und es ist auch gefährlich und hat seine Tücken. </font><font style="vertical-align: inherit;">Wenn Sie zu viel zwischenspeichern, können Sie Druck auf den GC ausüben. </font><font style="vertical-align: inherit;">Wenn Sie zu wenig zwischenspeichern, können Leistungsprobleme auftreten. </font><font style="vertical-align: inherit;">Es gibt auch verteiltes Caching, das eine ganz neue Welt zum Erkunden darstellt. </font><font style="vertical-align: inherit;">Dies ist Softwareentwicklung, es gibt immer etwas Neues, das gemeistert werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, Ihnen hat dieser Artikel gefallen. </font><font style="vertical-align: inherit;">Wenn Sie an Speicherverwaltung interessiert sind, wird sich mein nächster Artikel auf die Gefahren des Drucks auf den GC und dessen Verhinderung konzentrieren. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melden Sie sich an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Viel Spaß beim Codieren.</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahren Sie mehr über den Kurs.</font></font></a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502954/index.html">Probieren Sie 5 weitere Webinar-Plattformen aus</a></li>
<li><a href="../de502962/index.html">Warum wir nicht ins Büro zurückkehren (ein Blick auf die Fernarbeit nach 2 Monaten)</a></li>
<li><a href="../de502964/index.html">Finanzielle Nuance in der Projektvereinbarung des IT-Projekts</a></li>
<li><a href="../de502968/index.html">Grundlagen des Datentresors</a></li>
<li><a href="../de502972/index.html">SD Express: SD 8.0 & PCIe 4.0 Standard. Was ist das und warum?</a></li>
<li><a href="../de502978/index.html">Farbschema ohne die Hilfe eines Designers</a></li>
<li><a href="../de502980/index.html">HNO und Handlung in Nicht-Handlungsspielen am Beispiel von Throne: Kingdom at War</a></li>
<li><a href="../de502984/index.html">Wie wählt man einen Psychologen / Psychotherapeuten?</a></li>
<li><a href="../de502986/index.html">F #, Erhöhen des Bildkontrasts durch Ausrichten der Histogramme</a></li>
<li><a href="../de502988/index.html">Geschäftsexperte und Programmierer. Kombinieren kann nicht geteilt werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>