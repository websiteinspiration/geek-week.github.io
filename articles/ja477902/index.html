<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐧 🥦 🙅🏿 ユニバーサルDSL。出来ますか？ 🌼 👲🏿 ⌚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="サブジェクトエリアの言語。汎用言語構造でオーバーロードされません。同時に、数行で非常に複雑なロジックを実装できます。これはすべてDSLです。
 
 ただし、DSLの作成には、開発者の資格が必要です。このアプローチを定期的に使用すると、別の言語を開発するルーチンになります。解決策は、普遍的なツールを作...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ユニバーサルDSL。出来ますか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/477902/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/rq/r6/gbrqr6yefzzlp8sboskriuwrne0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブジェクトエリアの言語。</font><font style="vertical-align: inherit;">汎用言語構造でオーバーロードされません。</font><font style="vertical-align: inherit;">同時に、数行で非常に複雑なロジックを実装できます。</font><font style="vertical-align: inherit;">これはすべてDSLです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、DSLの作成には、開発者の資格が必要です。</font><font style="vertical-align: inherit;">このアプローチを定期的に使用すると、別の言語を開発するルーチンになります。</font><font style="vertical-align: inherit;">解決策は、普遍的なツールを作成することかもしれません-完全に異なるタスクに適用可能で、修正が容易なエンジンです。</font><font style="vertical-align: inherit;">この記事では、実装の観点から最も単純なCで開発しますが、同時に、かなり広範囲の問題を解決できる非常に強力な言語エンジンを開発します。</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションプロジェクトを開発するには、2つの方法があります。それを単純化して欠陥がないことを明らかにすることと、非常に複雑にして欠陥がないことを明らかにすることです。</font><font style="vertical-align: inherit;">C.E. R. Hoar（CAR Hoare）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、私とチームがプロジェクトの複雑さを処理するのに役立つ開発手法の1つを紹介します。</font><font style="vertical-align: inherit;">もう1つは、プロトタイプアプリケーションをすばやく開発できることです。</font><font style="vertical-align: inherit;">一見すると、プログラミング言語の開発は複雑すぎるようです。</font><font style="vertical-align: inherit;">つまり、普遍的なツールについて話しているのであれば、そうです。</font><font style="vertical-align: inherit;">目的が狭い主題領域をカバーすることである場合、特定の言語の開発はしばしばそれ自体を正当化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、顧客のソフトウェアに統合するための工業用言語（IEC 61131-3）の実装を開発するという課題に直面しました。</font><font style="vertical-align: inherit;">この作業の過程で、私はインタープリター構造のトピックに興味を持つようになり、それ以来、趣味としての言語ではなく、難解なインタープリターを書きました。</font><font style="vertical-align: inherit;">将来的には、自分で作成した通訳を使用して日常生活を簡素化する方法が理解されました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yh/j3/wl/yhj3wlkgasabptstq5toj3vasxc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
健全なプログラミング言語の主な目的は、プログラミングとプログラムの読み取りのプロセスを簡略化することです。</font><font style="vertical-align: inherit;">asmでの記述はマシンコードでの記述よりも簡単です。Cでの記述はasmでの記述よりも簡単です。Cでの記述はさらに簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは主に、最も一般的な還元主義の方法、つまり複雑なタスクをシンプルで認識可能なコンポーネントに分割すること、それらの相互作用と特定の構文を標準化することにより達成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミング言語は、一連の演算子で構成されます。これは、基本的に、言語、基本的なビルディングブロック、演算子の組み合わせの記述方法を定義する構文、および標準ライブラリの基本です。構文規則に従った基本アクションのシーケンスは関数にグループ化され、関数はクラス（OOPがある場合）にグループ化され、クラスはライブラリに結合され、さらにそれらはパッケージに結合されます。これは、典型的な主流言語がどのように見えるかです。原則として、これらのテクニックは、ほとんどの日常的なタスクを解決するのに十分です。ただし、これは制限ではありません。より高度な抽象化にさらに一歩踏み出すことができ、マクロ形式のメタプログラミングをサポートしていない場合は、使用する言語の制限を超える必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/r4/ky/skr4kym02scw_o_neotnxrtmamy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、ほとんどのプロジェクトは、既製のコンポーネントと重要ではない低レベルの自己作成部品の組み合わせに要約されています。コンポーネントの組み合わせは通常、C＃、Java、Pythonなどの汎用プログラミング言語を使用して行われます。これらの言語は高水準ですが、汎用的であるため、低水準の操作、関数の作成、クラス、一般化された型の記述、非同期プログラミングなどのための構文構成が必ず含まれています。このため、「1度実行、2度、3度実行」というタスクは、大量の構文構造で一杯になり、最大で数百行以上のコードが膨らむ可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
還元主義の手法を繰り返す場合は、コンポーネントの再利用を単純化できますが、これらのコンポーネントに限定します。これは、単純化された構文を持ち、これらのコンポーネントの相互作用を説明するためだけに役立つ特殊な言語の開発を通じて実現されます。このアプローチはYaOP（言語指向プログラミング）と呼ばれ、言語はDSL（ドメイン固有言語-ドメイン固有言語）と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
冗長な構成がないため、DSLのほんの数行で非常に複雑な機能を実装できます。これにより、開発速度が向上し、エラー数が減少し、システムテストが簡素化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチをうまく適用すると、システムの動作を定義および拡張するコンパクトスクリプトを作成できるため、開発中の製品の柔軟性が大幅に向上します。 DSLはどこにでもあるので、このアプローチの普及によって証明されるように、このアプローチには多くのアプリケーションが存在する可能性があります。一般的なHTMLはドキュメント記述言語、SQLは構造化クエリ言語、JSONは構造化データ記述言語、XAML、PostScript、Emacs Lisp、nnCronなどです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/zo/ew/fwzoewmnmucf6kyeycclx_uibxa.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての利点に加えて、DSLには重大な欠点もあります。それは、システム開発者にとって高い要件です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての開発者が原始的な言語でさえ開発する知識と経験を持っているわけではありません。少数の専門家でさえ、十分に柔軟で生産的な言語を開発できます。他にも問題があります。たとえば、元々設定されていた機能の開発の特定の時点では、十分ではない場合があり、関数またはOOPを作成する必要があります。また、関数がある場合は、ループなしで実行するために末尾再帰を最適化する必要がある場合もあります。この場合、以前に作成されたスクリプトが引き続き新しいバージョンで機能するように、下位互換性を考慮する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの問題は、ある問題を解決するために設計された言語が他の問題にはまったく適していないことです。したがって、新しいDSLをゼロから開発する必要があるため、新しい言語の開発は面倒になります。これもまた、メンテナンスを複雑にし、異なるDSL実装とそれを使用するプロジェクト間で共有するのが難しいコードの再利用を減らします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/0z/cs/rz0zcsehkdtthonxqqhrci4yezu.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は、DSLを作成してDSLを構築することです。ここで、私はRBNFを意味するのではなく、組み込みの手段によって主題領域の言語に変更できる言語を意味します。柔軟で変換可能な言語を作成する上での主な障害は、厳密に定義された構文と型システムの存在です。コンピュータ業界の開発期間全体で、構文のない柔軟な言語がいくつか提案されてきましたが、それらは今日まで存続し、ForthおよびLisp言語は活発に開発を続けています。これらの言語の主な特徴は、それらの構造と同義語性により、組み込みの手段により、インタープリターの動作を変更し、必要に応じて、元々用意されていなかった構文構造を解析できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Forthの構文をCまたはSchemeに拡張するためのソリューションがあります。 「フォート」は、引数と操作の異常な後置シーケンスについて批判されることがよくあります。これは、スタックを使用して引数を渡すことによって決まります。ただし、「Fort」はテキストインタープリターにアクセスできます。これにより、必要に応じて、リバースレコードをユーザーから隠すことができます。そして最後に、これは習慣の問題であり、非常に迅速に開発されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lisp言語ファミリの言語は、必要に応じてDSLを入力できるマクロに依存しています。また、インタープリターとリーダーへのアクセスにより、特定の解釈機能を備えたメタサイクリックインタープリターの実装が容易になります。たとえば、Scheme lisp Racketの実装は、言語を開発するための環境として位置付けられており、Webサーバーの作成、GUIインターフェイスの構築、推論言語などのためのすぐに使える言語を備えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような柔軟性により、これらの言語はユニバーサルDSLエンジンの役割に適した候補になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「フォート」とLispは、ニッチなものではありますが、結果として主に汎用言語として開発されます。これらは、DSL言語にとって冗長な機能を利用しています。しかし同時に、それらは実装するのに十分に単純であるため、拡張の可能性を備えた限定バージョンを開発できます。これにより、特定のタスクに小さな変更を加える（理想的には行わない）ことで、そのような言語のコアを再利用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、これらの言語はスクリプトの作成だけでなく、REPLを介したシステムとのインタラクティブな対話にも優れていることにも注意してください。これは、一方ではデバッグに便利であり、他方ではシステムとのユーザーがアクセス可能なインターフェースとして機能します。システムとのテキストインターフェイスは、実装がはるかに簡単で柔軟性があり、ユーザーが一般的な操作を関数に一般化できるなどの理由で、グラフィカルなものよりも効果的であると考えられています。テキストインターフェイスの印象的な例はBashです。また、言語が同義語である場合、その構成は、インタープリターグラフィック言語の上に最小限の労力で比較的簡単に生成および解析および実装できます。これは、ターゲットユーザーがプログラミングから離れている場合に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、XMLおよびJSONデータ記述言語は、構成用のDSLとして広く使用されています。もちろん、これは優れた方法ですが、データだけでは不十分な場合があり、たとえば、それらの操作を説明する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/_5/xm/hq_5xmmftlr1yj6xnsmn5-qzoo8.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿では、フォート言語の簡単なインタープリターを作成し、特定の問題を解決するためにそれをどのように適応させるかを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fort言語は、実装と使用が最も簡単なものとして選択されましたが、多くのタスクのDSLとして使用するのに十分強力です。</font><font style="vertical-align: inherit;">実際、言語の中心はアドレスインタープリターであり、アセンブラーでも数行しかかかりません。実装の大部分は、より普遍的で高速で柔軟なプリミティブに依存しています。</font><font style="vertical-align: inherit;">言語のもう1つの重要な部分は、テキストインタープリターです。これにより、アドレスインタープリターと対話できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/93/4s/uh934sq0-dwfzsmyjn2h5n0auvy.jpeg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">住所通訳</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォート言語の基本的な要素は、スペース、行末、タブで他の単語やアトム（数字）と区切られた単語です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単語は、Cなどの他の言語の関数と同じ意味とプロパティを持っています。実装で配線された、つまりインタープリターと同じ方法で実装された単語は、他の言語の演算子に似ています。実際、あらゆるプログラミング言語のプログラムは、言語とデータ演算子の組み合わせにすぎません。したがって、プログラミング言語の作成は、演算子の定義とそれらを組み合わせる方法と考えることができます。さらに、Cなどの言語は、言語の構文を決定する演算子を書く別の方法を決定します。ほとんどの言語では、通常、ステートメントを変更することはできません。たとえば、ifステートメントの構文や動作を変更することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォート言語では、すべての演算子とその組み合わせ（ユーザー単語）の記述方法は同じです。フォートワードはプリミティブとカスタムに分かれています。プリミティブをオーバーロードして、プリミティブの動作を変更する単語を定義できます。実際には、再定義された単語は、最初に定義されたプリミティブを介して実装されます。この実装では、C＃の関数がプリミティブになります。ユーザー定義のワードは、実行されるワードのアドレスのリストで構成されます。単語は2種類あるので、通訳はそれらを区別する必要があります。プリミティブとユーザーワードの分離は同じプリミティブを介して実行されます。各ユーザーワードはDoList操作で始まり、Exit操作で終わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような分離がどのように発生するかを長い間説明することは可能ですが、インタプリタプログラムの実行順序を研究することでこれを理解するのは簡単です。</font><font style="vertical-align: inherit;">これを行うには、最小限のインタープリターを実装し、単純なプログラムを定義して、それが段階的に実行される方法を確認します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4l/uq/jw/4luqjwgysqj6iuchqkxdihjof8c.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのフォートマシンは、線形メモリ、データスタック、リターンスタック、命令ポインター、ワードポインターで構成されています。</font><font style="vertical-align: inherit;">また、プリミティブを格納する別の場所もあります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span>[] Mem;     <span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> Stack&lt;<span class="hljs-keyword">int</span>&gt; RS;    <span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> Stack&lt;<span class="hljs-keyword">object</span>&gt; DS; <span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> IP;           <span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> WP;           <span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CoreCall</span>(<span class="hljs-params"></span>)</span>;
<span class="hljs-keyword">public</span> List&lt;CoreCall&gt; Core; <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解釈の本質は、メモリ内のアドレスに移動し、そこに示されている命令を実行することです。</font><font style="vertical-align: inherit;">アドレスインタプリタ全体（言語の中心）は、この場合、1つの関数Next（）で定義されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Next</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (IP == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span>;<font></font>
    WP = (<span class="hljs-keyword">int</span>)Mem[IP++];<font></font>
    Core[(<span class="hljs-keyword">int</span>)Mem[WP]]();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ユーザーワードはDoListコマンドで始まります。そのタスクは、現在の解釈アドレスをスタックに保存し、次のワードの解釈アドレスを設定することです。 </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoList</span>(<span class="hljs-params"></span>)</span> {<font></font>
  RS.Push(IP);<font></font>
  IP = WP + <span class="hljs-number">1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワードを終了するには、リターンスタックからアドレスを復元するExitコマンドを使用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span>(<span class="hljs-params"></span>)</span> {<font></font>
  IP = RS.Pop();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタプリタの原理を明確に示すために、コマンドを導入し、有用な作業をシミュレートします。</font><font style="vertical-align: inherit;">Hello（）としましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span>(<span class="hljs-params"></span>)</span> {<font></font>
  Console.WriteLine(<span class="hljs-string">"Hello"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、マシンを初期化し、インタープリターが正しく機能するようにプリミティブを指定する必要があります。</font><font style="vertical-align: inherit;">また、プログラムメモリ内のプリミティブのアドレスを指定する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">Mem = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1024</span>];<font></font>
RS = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
DS = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-keyword">object</span>&gt;();<font></font>
Core = <span class="hljs-keyword">new</span> List&lt;CoreCall&gt;();<font></font>
<font></font>
Core.Add(Next);<font></font>
Core.Add(DoList);<font></font>
Core.Add(Exit);<font></font>
Core.Add(Hello);<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> opNext = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> opDoList = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> opExit = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> opHello = <span class="hljs-number">3</span>;<font></font>
<font></font>
<span class="hljs-comment">// core pointers</span><font></font>
Mem[opNext]   = opNext;<font></font>
Mem[opDoList] = opDoList;<font></font>
Mem[opExit]   = opExit;<font></font>
Mem[opHello]  = opHello;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで簡単なプログラムを作成できます。この場合、ユーザーコードはアドレス4から始まり、2つのサブプログラムで構成されます。</font><font style="vertical-align: inherit;">最初のルーチンはアドレス7から始まり、2番目のルーチンを呼び出します。これはアドレス4から始まり、Helloという単語を表示します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// program</span>
Mem[<span class="hljs-number">4</span>] = opDoList; <span class="hljs-comment">// 3)    IP = 9   ,   IP = WP + 1 = 5</span>
Mem[<span class="hljs-number">5</span>] = opHello;  <span class="hljs-comment">// 4)    </span>
Mem[<span class="hljs-number">6</span>] = opExit;   <span class="hljs-comment">// 5)   ,  IP = 9   </span>
Mem[<span class="hljs-number">7</span>] = opDoList; <span class="hljs-comment">// 1)    </span>
Mem[<span class="hljs-number">8</span>] = <span class="hljs-number">4</span>;        <span class="hljs-comment">// 2)     4,  WP = 4</span>
Mem[<span class="hljs-number">9</span>] = opExit;   <span class="hljs-comment">// 6)   ,  IP = 0   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムを実行するには、最初に戻りスタックに値0を保存する必要があります。これにより、アドレスインタープリターが解釈サイクルを中断し、エントリポイントを設定してから、インタープリターを開始します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> entryPoint = <span class="hljs-number">7</span>; <span class="hljs-comment">//   </span><font></font>
<font></font>
IP = <span class="hljs-number">0</span>;          <span class="hljs-comment">//  IP = 0,       </span>
WP = entryPoint; <span class="hljs-comment">//  WP = 7     </span>
DoList();        <span class="hljs-comment">//     ,  IP = 0   </span>
Next();          <span class="hljs-comment">//   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明したように、このインタプリタではプリミティブは別のメモリに格納されます。もちろん、別の方法で実装することもできます。たとえば、プログラムメモリに、オペレーター関数へのデリゲートが格納されていました。一方では、そのようなインタープリターは簡単には判明しませんでしたが、他方では、解釈の各ステップで型のチェック、キャスト、および実行が必要になるため、より多くの操作が得られるため、明らかに低速でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタプリタの各ユーザーワードは、DoListプリミティブで始まります。そのタスクは、解釈の現在のアドレスを保存して、次のアドレスに移動することです。</font><font style="vertical-align: inherit;">サブルーチンからの出口は、Exitオペレーションによって実行されます。Exitオペレーションは、さらに解釈するためにリターンスタックからアドレスを復元します。</font><font style="vertical-align: inherit;">実際、アドレスインタプリタ全体について説明しました。</font><font style="vertical-align: inherit;">任意のプログラムを実行するには、プリミティブでそれを拡張するだけで十分です。</font><font style="vertical-align: inherit;">ただし、最初に、アドレスインタープリターへのインターフェイスを提供するテキストインタープリターを処理する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/fw/gt/qpfwgtzzyissc6ujdvq_eq3wdby.jpeg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキスト通訳</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fort言語には構文がなく、その中で記述されたプログラムは、スペース、タブ、または行末で区切られた単語です。したがって、テキストインタープリタのタスクは、入力ストリームを単語（トークン）に分割し、それらのエントリポイントを見つけ、実行するか、メモリに書き込むことです。ただし、すべてのトークンが実行されるわけではありません。通訳者が単語を見つけられない場合、彼はそれを数値定数として解釈しようとします。さらに、テキストインタープリターには、解釈モードとプログラミングモードの2つのモードがあります。プログラミングモードでは、ワードアドレスは実行されませんが、メモリに書き込まれるため、新しいワードが決定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「フォート」の正規の実装では、通常、辞書（辞書エントリ）とプログラムメモリを組み合わせて、単純に接続されたリストの形式で単一のコードファイルを定義します。</font><font style="vertical-align: inherit;">私たちの実装では、実行可能コードのみがメモリにあり、単語のエントリポイントは別の構造、つまり辞書に格納されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-keyword">string</span>, List&lt;WordHeader&gt;&gt; Entries;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このディクショナリは、単語の対応を複数の見出しに設定するため、同じ名前で任意の数のルーチンを定義してから、この定義を削除して古いものを使い始めることができます。</font><font style="vertical-align: inherit;">また、保存された古いアドレスを使用すると、単語が再定義されている場合でも、辞書で単語の名前を見つけることができます。これは、スタックトレースの生成やメモリのデバッグに特に役立ちます。</font><font style="vertical-align: inherit;">WordHeaderは、サブルーチンエントリアドレスと即時解釈フラグを格納するクラスです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WordHeader</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Address;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Immediate;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イミディエイトフラグは、このワードをプログラミングモードで実行し、メモリに書き込まないようにインタープリターに指示します。</font><font style="vertical-align: inherit;">概略的に、インタープリターのロジックは次のように表すことができます。右手はYES、左手はNOです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vh/5t/pz/vh5tpzf-atkgovuyyqrqoeitfmo.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TextReaderを使用して入力ストリームを読み取り、TextWriterを使用して出力します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> TextReader Input;
<span class="hljs-keyword">public</span> TextWriter Output;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のスキームによるインタプリタの実装は、1つの関数インタプリタ（）で行われます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Interpreter</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">var</span> word = ReadWord(Input);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.IsNullOrWhiteSpace(word))
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// EOF</span><font></font>
<font></font>
    <span class="hljs-keyword">var</span> lookup = LookUp(word);
    <span class="hljs-keyword">if</span> (IsEvalMode) {
      <span class="hljs-keyword">if</span> (lookup != <span class="hljs-literal">null</span>) {<font></font>
        Execute(lookup.Address);<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IsConstant(word)) {<font></font>
        DS.Push(ParseNumber(word));<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
        DS.Clear();<font></font>
        Output.WriteLine(<span class="hljs-string">$"The word <span class="hljs-subst">{word}</span> is undefined"</span>);<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// program mode</span>
      <span class="hljs-keyword">if</span> (lookup != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (lookup.Immediate) {<font></font>
          Execute(lookup.Address);<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
          AddOp(lookup.Address);<font></font>
        }<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IsConstant(word)) {<font></font>
        AddOp(LookUp(<span class="hljs-string">"doLit"</span>).Address);<font></font>
        AddOp(ParseNumber(word));<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
        IsEvalMode = <span class="hljs-literal">true</span>;<font></font>
        DS.Clear();<font></font>
        Output.WriteLine(<span class="hljs-string">$"The word <span class="hljs-subst">{word}</span> is undefined"</span>);<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解釈はループで実行され、その出力は入力ストリームの最後（たとえば、ファイルの最後）に到達すると実行されますが、ReadWord関数は空の文字列を返します。</font><font style="vertical-align: inherit;">ReadWordのタスクは、各呼び出しで次の単語を返すことです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span> <span class="hljs-title">ReadWord</span>(<span class="hljs-params">TextReader sr</span>)</span> {
  <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder();
  <span class="hljs-keyword">var</span> code = sr.Read();<font></font>
<font></font>
  <span class="hljs-keyword">while</span> (IsWhite((<span class="hljs-keyword">char</span>)code) &amp;&amp; code &gt; <span class="hljs-number">0</span>) {<font></font>
    code = sr.Read();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">while</span> (!IsWhite((<span class="hljs-keyword">char</span>)code) &amp;&amp; code &gt; <span class="hljs-number">0</span>) {<font></font>
    sb.Append((<span class="hljs-keyword">char</span>)code);<font></font>
    code = sr.Read();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> sb.ToString();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsWhite</span>(<span class="hljs-params"><span class="hljs-keyword">char</span> c</span>)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">" \n\r\t"</span>.Any(ch =&gt; ch == c);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単語が読み取られた後、辞書でそれを見つける試みが行われます。</font><font style="vertical-align: inherit;">成功した場合は単語のタイトルが返され、それ以外の場合はnullが返されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> WordHeader <span class="hljs-title">LookUp</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> word</span>)</span> {
  <span class="hljs-keyword">if</span> (Entries.ContainsKey(word)) {
    <span class="hljs-keyword">return</span> Entries[word].Last();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力した値が数値かどうかは、最初の2文字で確認できます。</font><font style="vertical-align: inherit;">最初の文字が数字の場合、それは数字であると想定します。</font><font style="vertical-align: inherit;">最初の文字が「+」または「-」記号で、2番目の文字が数字の場合、これはおそらく数字でもあります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsConstant</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> word</span>)</span> {
  <span class="hljs-keyword">return</span> IsDigit(word[<span class="hljs-number">0</span>]) || (word.Length &gt;= <span class="hljs-number">2</span> &amp;&amp; (word[<span class="hljs-number">0</span>] == <span class="hljs-string">'+'</span> || word[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>) &amp;&amp; IsDigit(word[<span class="hljs-number">1</span>]));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字列を数値に変換するには、標準メソッドInt32.TryParseおよびDouble.TryParseを使用できます。</font><font style="vertical-align: inherit;">しかし、それらはいくつかの理由で速度に違いがないため、カスタムソリューションを使用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">object</span> <span class="hljs-title">ParseNumber</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> str</span>)</span> {
  <span class="hljs-keyword">var</span> factor = <span class="hljs-number">1.0</span>;
  <span class="hljs-keyword">var</span> sign = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">'-'</span>) {<font></font>
    sign = <span class="hljs-number">-1</span>;<font></font>
    str = str.Remove(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">'+'</span>) {<font></font>
    str = str.Remove(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = str.Length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'.'</span>) {<font></font>
      str = str.Remove(i, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> IntParseFast(str) * factor * sign;<font></font>
    }<font></font>
<font></font>
    factor *= <span class="hljs-number">0.1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> IntParseFast(str) * sign;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">IntParseFast</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-keyword">value</span></span>)</span> {
  <span class="hljs-comment">// An optimized int parse method.</span>
  <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> c <span class="hljs-keyword">in</span> <span class="hljs-keyword">value</span>) {
    <span class="hljs-keyword">if</span> (!(c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>))
      <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// error</span><font></font>
<font></font>
    result = <span class="hljs-number">10</span> * result + (c - <span class="hljs-number">48</span>);<font></font>
  }<font></font>
  <font></font>
	<span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ParseNumberメソッドは、整数値と浮動小数点数の両方（たとえば、「1.618」）を変換できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワードの実行は、アドレスインタープリタを実行するために使用したのと同じ方法で行われます。</font><font style="vertical-align: inherit;">例外が発生した場合、アドレスインタープリターのスタックトレースが出力されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> address</span>)</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (address &lt; Core.Count) { <span class="hljs-comment">// eval core</span>
      Core[address](); <span class="hljs-comment">// invoke core function</span>
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// eval word</span>
      IP = <span class="hljs-number">0</span>;       <span class="hljs-comment">// set return address</span>
      WP = address; <span class="hljs-comment">// set eval address</span>
      DoList();     <span class="hljs-comment">// fake doList</span>
      Next();       <span class="hljs-comment">// run evaluator</span><font></font>
    }<font></font>
  } <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
    Output.WriteLine(e.Message);<font></font>
    <span class="hljs-keyword">var</span> wpEntry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == WP));
    <span class="hljs-keyword">var</span> ipEntry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == SearchKnowAddress(IP)));<font></font>
    Output.WriteLine(<span class="hljs-string">$"WP = <span class="hljs-subst">{WP:<span class="hljs-number">00000</span>}</span> - '<span class="hljs-subst">{wpEntry.Key}</span>', IP = <span class="hljs-subst">{IP:<span class="hljs-number">00000</span>}</span> - '<span class="hljs-subst">{ipEntry.Key}</span>'"</span>);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (RS.Any()) {<font></font>
      Output.WriteLine(<span class="hljs-string">"Stack trace..."</span>);
      <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> a <span class="hljs-keyword">in</span> RS) {
        <span class="hljs-keyword">var</span> ka = SearchKnowAddress(a);
        <span class="hljs-keyword">var</span> sEntry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == ka));<font></font>
        Output.WriteLine(<span class="hljs-string">$"...<span class="hljs-subst">{a:<span class="hljs-number">00000</span>}</span> -- <span class="hljs-subst">{sEntry.Key}</span>"</span>);<font></font>
      }<font></font>
      <font></font>
			RS.Clear();<font></font>
      DS.Clear();<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (address &lt; Core.Count) {
      <span class="hljs-keyword">var</span> entry = Entries.FirstOrDefault(d =&gt; d.Value.Any(en =&gt; en.Address == address));<font></font>
      Output.WriteLine(<span class="hljs-string">$"Core word is <span class="hljs-subst">{entry.Key}</span>"</span>);<font></font>
    }<font></font>
<font></font>
    IP = WP = <span class="hljs-number">0</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタープリターがコンパイルモードにあり、ワードに即時実行のマークが付いていない場合、そのアドレスをメモリに記録する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddOp</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> op</span>)</span> {<font></font>
  Mem[Here++] = op;<font></font>
}<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
here変数は、次の空きセルのアドレスを格納します。</font><font style="vertical-align: inherit;">この変数は、Fort言語の変数としてランタイム環境からアクセスできる必要があるため、ここの値はプログラムメモリの特定のオフセットに格納されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> _hereShift;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Here {
  <span class="hljs-keyword">get</span> =&gt; (<span class="hljs-keyword">int</span>)Mem[_hereShift];
  <span class="hljs-keyword">set</span> =&gt; Mem[_hereShift] = <span class="hljs-keyword">value</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解釈中に数値定数とワードアドレスを区別するために、doLitのコンパイルは各定数の前にコンパイルされ、メモリ内の次の値を読み取ってデータスタックに配置します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoLit</span>(<span class="hljs-params"></span>)</span> {<font></font>
  DS.Push(Mem[IP++]);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アドレスとテキストのインタープリターについて説明しましたが、核を原子で満たすことをさらに発展させました。 "Fort"のバージョンが異なれば、基本的な単語のセットも異なります。最もミニマルな実装は、おそらく31個のプリミティブのみを含むeForthです。プリミティブは複合ユーザーワードよりも速く実行されるため、最小限のFort実装は通常、詳細実装よりも低速です。インタプリタのいくつかのバージョンの単語のセットの比較は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで説明する通訳では、基本的な単語の辞書を不必要に膨らませないように努めました。</font><font style="vertical-align: inherit;">しかし、.netプラットフォームとの統合を簡単にするために、数学、ブール演算、そしてもちろん、一連のプリミティブによるリフレクションを実装することにしました。</font><font style="vertical-align: inherit;">同時に、Fortの実装では原始的であることが多い単語の一部がここにないため、インタプリタによる実装を示唆しています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">執筆時点では、基本セットは68語です。</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment">// Core</span>
SetCoreWord(<span class="hljs-string">"nop"</span>, Nop);<font></font>
SetCoreWord(<span class="hljs-string">"next"</span>, Next);<font></font>
SetCoreWord(<span class="hljs-string">"doList"</span>, DoList);<font></font>
SetCoreWord(<span class="hljs-string">"exit"</span>, Exit);<font></font>
SetCoreWord(<span class="hljs-string">"execute"</span>, Execute);<font></font>
SetCoreWord(<span class="hljs-string">"doLit"</span>, DoLit);<font></font>
SetCoreWord(<span class="hljs-string">":"</span>, BeginDefWord);<font></font>
SetCoreWord(<span class="hljs-string">";"</span>, EndDefWord, <span class="hljs-literal">true</span>);<font></font>
SetCoreWord(<span class="hljs-string">"branch"</span>, Branch);<font></font>
SetCoreWord(<span class="hljs-string">"0branch"</span>, ZBranch);<font></font>
SetCoreWord(<span class="hljs-string">"here"</span>, GetHereAddr);<font></font>
SetCoreWord(<span class="hljs-string">"quit"</span>, Quit);<font></font>
SetCoreWord(<span class="hljs-string">"dump"</span>, Dump);<font></font>
SetCoreWord(<span class="hljs-string">"words"</span>, Words);<font></font>
SetCoreWord(<span class="hljs-string">"'"</span>, Tick);<font></font>
SetCoreWord(<span class="hljs-string">","</span>, Comma);<font></font>
SetCoreWord(<span class="hljs-string">"["</span>, Lbrac, <span class="hljs-literal">true</span>);<font></font>
SetCoreWord(<span class="hljs-string">"]"</span>, Rbrac);<font></font>
SetCoreWord(<span class="hljs-string">"immediate"</span>, Immediate, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Mem</span>
SetCoreWord(<span class="hljs-string">"!"</span>, WriteMem);<font></font>
SetCoreWord(<span class="hljs-string">"@"</span>, ReadMem);<font></font>
SetCoreWord(<span class="hljs-string">"variable"</span>, Variable);<font></font>
SetCoreWord(<span class="hljs-string">"constant"</span>, Constant);
<span class="hljs-comment">// RW</span>
SetCoreWord(<span class="hljs-string">"."</span>, Dot);<font></font>
SetCoreWord(<span class="hljs-string">".s"</span>, DotS);<font></font>
SetCoreWord(<span class="hljs-string">"cr"</span>, Cr);<font></font>
SetCoreWord(<span class="hljs-string">"bl"</span>, Bl);<font></font>
SetCoreWord(<span class="hljs-string">"word"</span>, ReadWord, <span class="hljs-literal">true</span>);<font></font>
SetCoreWord(<span class="hljs-string">"s\""</span>, ReadString, <span class="hljs-literal">true</span>);<font></font>
SetCoreWord(<span class="hljs-string">"key"</span>, Key);
<span class="hljs-comment">// Comment</span>
SetCoreWord(<span class="hljs-string">"("</span>, Comment, <span class="hljs-literal">true</span>);<font></font>
SetCoreWord(<span class="hljs-string">"\\"</span>, CommentLine, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// .net mem</span>
SetCoreWord(<span class="hljs-string">"null"</span>, Null);<font></font>
SetCoreWord(<span class="hljs-string">"new"</span>, New);<font></font>
SetCoreWord(<span class="hljs-string">"type"</span>, GetType);<font></font>
SetCoreWord(<span class="hljs-string">"m!"</span>, SetMember);<font></font>
SetCoreWord(<span class="hljs-string">"m@"</span>, GetMember);<font></font>
SetCoreWord(<span class="hljs-string">"ms@"</span>, GetStaticMember);<font></font>
SetCoreWord(<span class="hljs-string">"ms!"</span>, SetStaticMember);<font></font>
SetCoreWord(<span class="hljs-string">"load-assembly"</span>, LoadAssembly);<font></font>
SetCoreWord(<span class="hljs-string">"invk"</span>, invk); 
<span class="hljs-comment">// Boolean</span>
SetCoreWord(<span class="hljs-string">"true"</span>, True);<font></font>
SetCoreWord(<span class="hljs-string">"false"</span>, False);<font></font>
SetCoreWord(<span class="hljs-string">"and"</span>, And);<font></font>
SetCoreWord(<span class="hljs-string">"or"</span>, Or);<font></font>
SetCoreWord(<span class="hljs-string">"xor"</span>, Xor);<font></font>
SetCoreWord(<span class="hljs-string">"not"</span>, Not);<font></font>
SetCoreWord(<span class="hljs-string">"invert"</span>, Invert);<font></font>
SetCoreWord(<span class="hljs-string">"="</span>, Eql);<font></font>
SetCoreWord(<span class="hljs-string">"&lt;&gt;"</span>, NotEql);<font></font>
SetCoreWord(<span class="hljs-string">"&lt;"</span>, Less);<font></font>
SetCoreWord(<span class="hljs-string">"&gt;"</span>, Greater);<font></font>
SetCoreWord(<span class="hljs-string">"&lt;="</span>, LessEql);<font></font>
SetCoreWord(<span class="hljs-string">"&gt;="</span>, GreaterEql);
<span class="hljs-comment">// Math</span>
SetCoreWord(<span class="hljs-string">"-"</span>, Minus);<font></font>
SetCoreWord(<span class="hljs-string">"+"</span>, Plus);<font></font>
SetCoreWord(<span class="hljs-string">"*"</span>, Multiply);<font></font>
SetCoreWord(<span class="hljs-string">"/"</span>, Devide);<font></font>
SetCoreWord(<span class="hljs-string">"mod"</span>, Mod);<font></font>
SetCoreWord(<span class="hljs-string">"1+"</span>, Inc);<font></font>
SetCoreWord(<span class="hljs-string">"1-"</span>, Dec);
<span class="hljs-comment">// Stack</span>
SetCoreWord(<span class="hljs-string">"drop"</span>, Drop);<font></font>
SetCoreWord(<span class="hljs-string">"swap"</span>, Swap);<font></font>
SetCoreWord(<span class="hljs-string">"dup"</span>, Dup);<font></font>
SetCoreWord(<span class="hljs-string">"over"</span>, Over);<font></font>
SetCoreWord(<span class="hljs-string">"rot"</span>, Rot);<font></font>
SetCoreWord(<span class="hljs-string">"nrot"</span>, Nrot);
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいユーザーワードを定義するには、「：」と「;」の2つのカーネルワードを使用します。</font><font style="vertical-align: inherit;">単語「：」は入力ストリームから新しい単語の名前を読み取り、このキーを使用してヘッダーを作成し、基本単語doListのアドレスをプログラムメモリに追加して、インタープリターをコンパイルモードにします。</font><font style="vertical-align: inherit;">即時とマークされているものを除いて、後続のすべての単語がコンパイルされます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginDefWord</span>(<span class="hljs-params"></span>)</span> {<font></font>
  AddHeader(ReadWord(Input));<font></font>
  AddOp(LookUp(<span class="hljs-string">"doList"</span>).Address);<font></font>
  IsEvalMode = <span class="hljs-literal">false</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルは「;」という語で終了し、「exit」という語のアドレスがプログラムメモリに書き込まれ、解釈モードになります。</font><font style="vertical-align: inherit;">これで、ループ、条件付きステートメントなどのカスタム単語を定義できます。</font></font><br>
<br>
<pre><code class="cs hljs">Eval(<span class="hljs-string">": ? @ . ;"</span>);<font></font>
Eval(<span class="hljs-string">": allot here @ + here ! ;"</span>);<font></font>
Eval(<span class="hljs-string">": if immediate doLit [ ' 0branch , ] , here @ 0 , ;"</span>);            <font></font>
Eval(<span class="hljs-string">": then immediate dup here @ swap - swap ! ;"</span>); <font></font>
Eval(<span class="hljs-string">": else immediate [ ' branch , ] , here @ 0 , swap dup here @ swap - swap ! ;"</span>); <font></font>
<font></font>
Eval(<span class="hljs-string">": begin immediate here @ ;"</span>);<font></font>
Eval(<span class="hljs-string">": until immediate doLit [ ' 0branch , ] , here @ - , ;"</span>);<font></font>
Eval(<span class="hljs-string">": again immediate doLit [ ' branch , ] , here @ - , ;"</span>);            <font></font>
Eval(<span class="hljs-string">": while immediate doLit [ ' 0branch , ] , here @ 0 , ;"</span>);<font></font>
Eval(<span class="hljs-string">": repeat immediate doLit [ ' branch , ] , swap here @ - , dup here @ swap - swap ! ;"</span>);<font></font>
Eval(<span class="hljs-string">": // immediate [ ' \\ , ] ;"</span>); <span class="hljs-comment">// C like comment</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの標準的な単語については説明しません。ネットワーク上の対応するテーマ別リソースには、それらに関する十分な情報があります。</font><font style="vertical-align: inherit;">プラットフォームと対話するために、9つの単語を定義しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Null"-nullをスタックにプッシュします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「タイプ」-クラスタイプを「単語TrueForth.MyClassタイプ」のスタックにプッシュします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「新規」-スタックから型を取得し、クラスのインスタンスを作成してスタックに配置します。コンストラクター引数がある場合は、それもスタックになければなりません「ワードTrueForth.MyClass type new」;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「M！」</font><font style="vertical-align: inherit;">-オブジェクトのインスタンス、フィールド名、スタックからの値を取得し、指定されたフィールドに値を割り当てます。</font></font></li>
<li>«m@» —     ,        ;</li>
<li>«ms!»  «ms@» —  ,    ,       ;</li>
<li>«load-assembly» —          ;</li>
<li>«invk» —    ,     «1133 word SomeMethod word TrueForth.MyClass type new m@ invk».</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fort言語の実装の主なポイントについて説明しました。この実装はDSLを構築するためのエンジンを実装することであり、汎用言語を実装することではないため、この言語のANSI標準をサポートすることを目的とはしていません。</font><font style="vertical-align: inherit;">ほとんどの場合、開発されたインタープリターで、対象分野の単純な言語を構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のインタープリターを使用するにはいくつかの方法があります。</font><font style="vertical-align: inherit;">たとえば、インタープリターのインスタンスを作成し、必要な単語が決定される初期化スクリプトを入力に送信できます。</font><font style="vertical-align: inherit;">後者は反射を介してシステムと相互作用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Init4Th</span>(<span class="hljs-params"></span>)</span> {<font></font>
  Interpreter = <span class="hljs-keyword">new</span> OForth();<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (File.Exists(InitFile)) {<font></font>
    Interpreter.Eval(File.ReadAllText(InitFile));<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    Console.WriteLine(<span class="hljs-string">$"  <span class="hljs-subst">{InitFile}</span>  !"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポート配信システムの構成例</font></font><br>
<br>
<pre><code class="plaintext hljs">( *****   ***** )<font></font>
word GetFReporter word ReportProvider.FlexReports.FReporterEntry type new m@ invk constant fr //      <font></font>
<font></font>
:  word ReportProvider.FlexReports.FDailyReport type new ; //      <font></font>
:  word AddReport fr m@ invk ; //         <font></font>
<font></font>
:  [ ' word , ] ; //  <font></font>
:  [ ' word , ] ; //   <font></font>
:  [ ' s" , ] ; //  ,      "<font></font>
<font></font>
:  ; // <font></font>
<font></font>
:  dup [ ' word , ] swap word MailSql swap m! ;<font></font>
:  dup [ ' word , ] swap word XlsSql swap m! ;<font></font>
<font></font>
<font></font>
( *****    ***** )<font></font>
cr s"   " . cr cr<font></font>
<font></font>
   "  08:00  mail@tinkoff.ru   seizure.sql <font></font>
  ,    "  08:00  mail@tinkoff.ru   fixed-errors-top.sql   fixed-errors.sql <font></font>
       WO"  08:00  mail@tinkoff.ru   wo-wait-complect-dates.sql <font></font>
     "  07:30  mail@tinkoff.ru   top-previous-input-errors.sql   previous-input-errors.sql <font></font>
      "  10:00  mail@tinkoff.ru   collection-report.sql <font></font>
     BPM   "  08:00  mail@tinkoff.ru   bpm-inbox-report.sql <font></font>
     ScanDoc3   7 "  07:50  mail@tinkoff.ru   new-sd3-complects-prevew.sql   new-sd3-complects.sql <font></font>
<font></font>
( ******************************** )<font></font>
<font></font>
cr s"  " . cr<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外の場合は、データスタックを介して既製のオブジェクトをインタープリターの入力に渡し、インタープリターを介してそれらと対話します。</font><font style="vertical-align: inherit;">たとえば、ドキュメントのスキャンを受信するためのデバイス設定、スキャナー、Webカメラ、または仮想デバイス（デバッグまたはトレーニング用）を復元しました。</font><font style="vertical-align: inherit;">この場合、パラメーターのセット、設定、異なるデバイスの初期化順序は非常に異なり、フォートインタープリターによって簡単に解決されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> interpreter = <span class="hljs-keyword">new</span> OForth();<font></font>
  interpreter.DS.Push(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// Push current instance on DataStack</span>
  interpreter.Eval(<span class="hljs-string">"constant arctium"</span>); <span class="hljs-comment">// Define constant with the instance</span><font></font>
            <font></font>
  <span class="hljs-keyword">if</span> (File.Exists(ConfigName)) {<font></font>
    interpreter.Eval(File.ReadAllText(ConfigName));<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構成はプログラムで生成され、次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">s" @device:pnp:\\?\usb#vid_2b16&amp;pid_6689&amp;mi_00#6&amp;1ef84f63&amp;0&amp;0000#{65e8773d-8f56-11d0-a3b9-00a0c9223196}\global" s" Doccamera" word Scanning.Devices.PhotoScanner.PhotoScannerDevice type new<font></font>
dup s" 3264x2448, FPS:20, BIT:24" swap word SetSnapshotMode swap m@ invk<font></font>
dup s" 1280x720, FPS:30, BIT:24" swap word SetPreviewMode swap m@ invk<font></font>
word SetActiveDevice arctium m@ invk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、スクリプト* .psと* .pdfは、PostScriptとPdfの両方が基本的に「フォート」のサブセットであるため、同様の方法で生成されますが、画面またはプリンターでドキュメントをレンダリングするためにのみ使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションだけでなく、コンソールにインタラクティブモードを簡単に実装できます。</font><font style="vertical-align: inherit;">これを行うには、まず準備されたスクリプトを使用してシステムを初期化し、次に標準入力STDINにインタープリターを設定して解釈を開始する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> interpreter = <span class="hljs-keyword">new</span> OForth();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> InitFile = <span class="hljs-string">"Init.4th"</span>;
<span class="hljs-keyword">if</span> (File.Exists(InitFile)) {<font></font>
  interpreter.Eval(File.ReadAllText(InitFile));<font></font>
} <span class="hljs-keyword">else</span> {<font></font>
  Console.WriteLine(<span class="hljs-string">$"  <span class="hljs-subst">{InitFile}</span>  !"</span>);<font></font>
}<font></font>
<font></font>
interpreter.Eval(Console.In); <span class="hljs-comment">// Start interactive console</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化スクリプトは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">( *****   ***** )<font></font>
word ComplectBuilder.Program type constant main   //    <font></font>
: mode! [ ' word , ] word Mode main ms! ;         //   <font></font>
: init word Init main ms@ invk ;                  // <font></font>
: load [ ' word , ] word LoadFile main ms@ invk ; //  <font></font>
: start word StartProcess main ms@ invk ;         //  <font></font>
: count word Count main ms@ invk ;                //  <font></font>
: all count ;                                     // <font></font>
<font></font>
( *****  ***** )<font></font>
init<font></font>
<font></font>
cr cr s"    ,     help" . cr cr<font></font>
<font></font>
( *****  ***** )<font></font>
: help<font></font>
  s"         :" . cr<font></font>
  s" load scandoc_test.csv 0 all start" . cr<font></font>
  bl bl s" load scandoc_test.csv --    " . cr<font></font>
  bl bl s" 0 all start --  ,  0      all " . cr<font></font>
  cr <font></font>
  s"     DEV TEST PROD:" . cr<font></font>
  s" mode! DEV init" . cr<font></font>
  s"     :" . cr<font></font>
  s" word Mode main ms@ . cr" . cr<font></font>
;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力として、UIを備えたTextBoxアプリケーションからのコンソールまたはテキストだけでなく、ネットワークも存在する可能性があります。この場合、コンポーネントのデバッグ、起動、停止のために、サービスなどの簡単なインタラクティブコントロールを実装できます。このような使用の可能性は、開発者の想像力と解決すべきタスクによって制限されます。後続の再生と編集のために、一連のフォートワードの形式でUIの操作を記録するマクロシステムを実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、私はエンジンの使用の別の例を共有したいと思います。リフレクションに煩わされないようにするために、初期化段階で匿名関数をインタープリターに渡すことができるので、それらの呼び出しを介してシステムの動作を制御できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デリゲートをコンパイルするには、次の関数を使用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Callback</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> word, MulticastDelegate action</span>)</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.IsNullOrWhiteSpace(word) || word.Any(c =&gt; <span class="hljs-string">" \n\r\t"</span>.Any(cw =&gt; cw == c))) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"invalid format of word"</span>);<font></font>
  }<font></font>
<font></font>
  DS.Push(action);<font></font>
  Eval(<span class="hljs-string">$": <span class="hljs-subst">{word}</span> [ ' doLit , , ] invk ;"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数へのデリゲートがDS.Push（アクション）データスタックにプッシュされ、そのデリゲートへの呼び出しで単語がコンパイルされます。</font><font style="vertical-align: inherit;">角かっこ[]で囲まれた単語はコンパイルされるのではなく解釈されることを思い出させてください。</font><font style="vertical-align: inherit;">単語 'Tickは次の単語を検索し、そのアドレスをスタックに配置します。この例ではdoLitです。これは、コンパイル時にデリゲートが定数としてスタックに配置されるために必要です。</font><font style="vertical-align: inherit;">最初のコンマ "、"はdoLitをコンパイルし、2つ目はスタックからデリゲートをコンパイルします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、簡単な構成を作成してみましょう。このために、config要素のクラスを定義します。</font><font style="vertical-align: inherit;">例は、示された名前が意味論的な意味を持つ実際のプロジェクトから取られています：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WoConfItem</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> ComplectType;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Route;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Deal;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsStampQuery;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構成インタープリターは基本的に行われます-必要な単語が決定され、構成が解釈されます：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通訳者コード</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WoConfig</span> {
  <span class="hljs-keyword">private</span> OForth VM;
  <span class="hljs-keyword">private</span> List&lt;WoConfItem&gt; _conf;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WoConfig</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> confFile</span>)</span> {<font></font>
    _conf = <span class="hljs-keyword">new</span> List&lt;WoConfItem&gt;();<font></font>
    VM = <span class="hljs-keyword">new</span> OForth();
    <span class="hljs-comment">//     </span>
    VM.Callback(<span class="hljs-string">"new-conf"</span>, <span class="hljs-keyword">new</span> Action(ClearConf));<font></font>
    VM.Callback(<span class="hljs-string">"{"</span>, <span class="hljs-keyword">new</span> Func&lt;WoConfItem&gt;(NewConf));<font></font>
    VM.Callback(<span class="hljs-string">"}"</span>, <span class="hljs-keyword">new</span> Action&lt;WoConfItem&gt;(AddConf));<font></font>
    VM.Callback(<span class="hljs-string">"complect-type"</span>, <span class="hljs-keyword">new</span> Func&lt;WoConfItem,<span class="hljs-keyword">string</span>,WoConfItem&gt;(ConfComplectType));<font></font>
    VM.Callback(<span class="hljs-string">"route"</span>, <span class="hljs-keyword">new</span> Func&lt;WoConfItem,<span class="hljs-keyword">string</span>,WoConfItem&gt;(ConfRoute));<font></font>
    VM.Callback(<span class="hljs-string">"deal"</span>, <span class="hljs-keyword">new</span> Func&lt;WoConfItem,<span class="hljs-keyword">string</span>,WoConfItem&gt;(ConfDeal));<font></font>
    VM.Callback(<span class="hljs-string">"is-stamp-query"</span>, <span class="hljs-keyword">new</span> Func&lt;WoConfItem,<span class="hljs-keyword">bool</span>,WoConfItem&gt;(ConfIsStampQuery));<font></font>
<font></font>
    <span class="hljs-comment">//  ,   ,      </span>
    <span class="hljs-keyword">var</span> initScript = <span class="hljs-keyword">new</span> StringBuilder();<font></font>
    initScript.AppendLine(<span class="hljs-string">": complect-type [ ' word , ] swap complect-type ;"</span>);<font></font>
    initScript.AppendLine(<span class="hljs-string">": route [ ' word , ] swap route ;"</span>);<font></font>
    initScript.AppendLine(<span class="hljs-string">": deal [ ' word , ] swap deal ;"</span>);<font></font>
    initScript.AppendLine(<span class="hljs-string">": is-stamp-query ' execute swap is-stamp-query ;"</span>);<font></font>
<font></font>
    VM.Eval(initScript.ToString());<font></font>
<font></font>
    <span class="hljs-comment">//  </span><font></font>
    WatchConfig(confFile);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadConfig</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> path</span>)</span> {
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> StreamReader(File.OpenRead(path), Encoding.Default)) {<font></font>
      VM.Eval(reader);<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">readonly</span> Func&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">bool</span>&gt; _any = s =&gt; s == <span class="hljs-string">"*"</span>;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> WoConfItem <span class="hljs-title">GetConf</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> complectType, <span class="hljs-keyword">string</span> routeId</span>)</span> {
    <span class="hljs-keyword">return</span> _conf?.FirstOrDefault(cr =&gt;<font></font>
      (cr.ComplectType == complectType || _any(cr.ComplectType)) &amp;&amp;<font></font>
      (cr.Route == routeId || _any(cr.Route))<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsAllow</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> complectType, <span class="hljs-keyword">string</span> routeId</span>)</span> {
    <span class="hljs-keyword">return</span> GetConf(complectType, routeId) != <span class="hljs-literal">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WatchConfig</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> path</span>)</span> {
    <span class="hljs-keyword">var</span> directory = Path.GetDirectoryName(path);
    <span class="hljs-keyword">var</span> fileName = Path.GetFileName(path);<font></font>
<font></font>
    <span class="hljs-comment">//   ,    </span>
    <span class="hljs-keyword">if</span> (!File.Exists(path)) {
      <span class="hljs-keyword">if</span> (!Directory.Exists(directory)) {<font></font>
        Directory.CreateDirectory(directory);<font></font>
      }<font></font>
<font></font>
      <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder();<font></font>
      sb.AppendLine(<span class="hljs-string">"\\ WO passport configuration"</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">"new-conf"</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">""</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">"\\ Config rules"</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">"\\ { -- begin config item, } -- end config item, * -- match any values"</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">"\\ Example:"</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">"\\ { complect-type * route offer deal 100500 is-stamp-query true }"</span>);<font></font>
      sb.AppendLine(<span class="hljs-string">""</span>);<font></font>
      File.WriteAllText(path, sb.ToString(), Encoding.Default);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//  </span><font></font>
    ReadConfig(path);<font></font>
<font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-keyword">var</span> fsWatcher = <span class="hljs-keyword">new</span> FileSystemWatcher(directory, fileName);<font></font>
    fsWatcher.Changed += (sender, args) =&gt; {<font></font>
      <span class="hljs-keyword">try</span> {<font></font>
        fsWatcher.EnableRaisingEvents = <span class="hljs-literal">false</span>;
        <span class="hljs-comment">//        ,</span>
        <span class="hljs-comment">//     ,  </span>
        <span class="hljs-comment">//    </span>
        Thread.Sleep(<span class="hljs-number">1000</span>);<font></font>
        ReadConfig(path);<font></font>
      } <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
        Console.WriteLine(e);<font></font>
      } <span class="hljs-keyword">finally</span> {<font></font>
        fsWatcher.EnableRaisingEvents = <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    };<font></font>
    fsWatcher.EnableRaisingEvents = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//  ,   </span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearConf</span>(<span class="hljs-params"></span>)</span> {<font></font>
    _conf.Clear();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddConf</span>(<span class="hljs-params">WoConfItem conf</span>)</span> {<font></font>
    _conf.Add(conf);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> WoConfItem <span class="hljs-title">NewConf</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WoConfItem();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> WoConfItem <span class="hljs-title">ConfComplectType</span>(<span class="hljs-params">WoConfItem conf, <span class="hljs-keyword">string</span> complectType</span>)</span> {<font></font>
    conf.ComplectType = complectType;<font></font>
    <span class="hljs-keyword">return</span> conf;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> WoConfItem <span class="hljs-title">ConfRoute</span>(<span class="hljs-params">WoConfItem conf, <span class="hljs-keyword">string</span> route</span>)</span> {<font></font>
    conf.Route = route;<font></font>
    <span class="hljs-keyword">return</span> conf;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> WoConfItem <span class="hljs-title">ConfDeal</span>(<span class="hljs-params">WoConfItem conf, <span class="hljs-keyword">string</span> deal</span>)</span> {<font></font>
    conf.Deal = deal;<font></font>
    <span class="hljs-keyword">return</span> conf;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> WoConfItem <span class="hljs-title">ConfIsStampQuery</span>(<span class="hljs-params">WoConfItem conf, <span class="hljs-keyword">bool</span> isStampQuery</span>)</span> {<font></font>
    conf.IsStampQuery = isStampQuery;<font></font>
    <span class="hljs-keyword">return</span> conf;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構成例：</font></font><br>
<br>
<pre><code class="plaintext hljs">\ WO passport configuration<font></font>
new-conf<font></font>
<font></font>
\ Config rules<font></font>
\ { -- begin config item, } -- end config item, * -- match any values<font></font>
\ Example:<font></font>
\ { complect-type * route offer deal 100500 is-stamp-query true }<font></font>
<font></font>
\ ***** offer *****<font></font>
{ complect-type offer     	route offer is-stamp-query false deal 5c18e87bfeed2b0b883fd4df }<font></font>
{ complect-type KVK       	route offer is-stamp-query true  deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type offer-cred	route offer is-stamp-query true  deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type offer-dep 	route offer is-stamp-query true  deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type quick-meeting route offer is-stamp-query true  deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type exica     	route offer is-stamp-query true  deal 5d03a894e2f5850001435492 }<font></font>
{ complect-type reissue   	route offer is-stamp-query true  deal 5d03a894e2f5850001435492 }<font></font>
    <font></font>
\ ***** offer-flow *****<font></font>
{ complect-type KVK    	route offer-flow is-stamp-query true deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type offer-cred route offer-flow is-stamp-query true deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type offer-dep  route offer-flow is-stamp-query true deal 5d03a8a1edf8af0001876df0 }<font></font>
{ complect-type reissue	route offer-flow is-stamp-query true deal 5d03a894e2f5850001435492 }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、最も単純な例を示しましたが、このアプローチにより、複雑なDSLを実装でき、最も重要なのは、最小限の時間コストで実装できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、最も単純なFortスクリプトエンジンを作成して使用する例を検討しました。言語の機能により、ユニバーサルDSLとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、開発されたインタープリターにはいくつかの制限があります。たとえば、ローカル変数、構造、テキストインタープリターの柔軟な制御の欠如、機能など、リフレクションを介したプラットフォームとの対話が遅くなります。ただし、理解と変更が簡単なため、必要に応じて拡張して特定の問題を解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、主なことは、さまざまな種類のインタプリタのエンジンを開発することの理解とスキルです。これにより、資格のある開発者として自分を実装するためのツールと機会を大幅に拡大することができます。</font><font style="vertical-align: inherit;">すべての理論をテストする最良の方法は実践であるため、主なものは実践的な経験です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタープリターの完全なソースコードは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらのgithubで確認でき</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フォートマシンの優れた説明を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含む</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リソースを</font></a><font style="vertical-align: inherit;">お勧めし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸運を</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477892/index.html">DevOps：2019年の結果とDevOpsコミュニティからの次の予測</a></li>
<li><a href="../ja477894/index.html">work＆dev fun（damentals）＃0。何を期待し、どのようにして研修生の開発者を自信に満ちた後輩に育てるのを助けるのですか？</a></li>
<li><a href="../ja477896/index.html">有線インイヤーヘッドフォンの予算セグメントを選択</a></li>
<li><a href="../ja477898/index.html">Kotlinコンテキスト指向プログラミングの概要</a></li>
<li><a href="../ja477900/index.html">素数-私たちの無力さはどれほど素晴らしいですか？</a></li>
<li><a href="../ja477904/index.html">oEmbedを使用してプログラムで一般的なコードを検索する</a></li>
<li><a href="../ja477906/index.html">Slurm：ブラックフライデーオンラインコースが50％オフ</a></li>
<li><a href="../ja477908/index.html">Puppetry 3：コードを1行も使用しない自動テスト</a></li>
<li><a href="../ja477910/index.html">ブラックフライデー2019-モスクワとアムステルダムのVDS、GPU搭載サーバー</a></li>
<li><a href="../ja477912/index.html">E Ink Carta Mobius画面を備えた10.3インチPocketBook Xリーダーの第一印象</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>