<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ üëãüèø üôÄ Reflections on Effective Enterprise Testing üë¥ üë≤üèΩ üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 
 Recently, we have returned to a thorough study of the testing topic, and in the foreseeable plans we even have an excellent book on U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reflections on Effective Enterprise Testing</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recently, we have returned to a thorough study of the testing topic, and in the foreseeable plans we even have an excellent book on Unit Testing. </font><font style="vertical-align: inherit;">At the same time, we believe that context is important in this topic as nowhere else, therefore today we offer a translation of two publications (combined into one) published on the blog of a prominent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specialist </font><font style="vertical-align: inherit;">Sebastian Dashner - namely, 1/6 and 2/6 from the series ‚Äú Thoughts on efficient enterprise testing. "</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enterprise testing is a topic that has not yet been examined in as much detail as we would like. </font><font style="vertical-align: inherit;">It takes a lot of time and effort to write and especially to support tests, however, trying to save time by abandoning the tests is not an option. </font><font style="vertical-align: inherit;">What volumes of tasks, approaches and testing technologies are worth exploring in order to increase the effectiveness of testing?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardless of the different types of tests and their scope, the point of preparing a set of tests is to make sure on this material that in production our application will work exactly as expected. </font><font style="vertical-align: inherit;">Such motivation should be the main one when checking whether the system fulfills the task, if we consider this system from the user's point of view. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since attention span and context switching are things to be reckoned with, we must ensure that our tests are run and tested in a short time frame and that test results are predictable. </font><font style="vertical-align: inherit;">When writing code, fast verification of the code (feasible within one second) is crucial - this ensures high productivity and focus during work.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, we must ensure test support. Software changes very often, and with a substantial coverage of the code with functional tests, each functional change in the production code will require a change at the test level. Ideally, the test code should change only when the functionality, i.e., business logic, changes, and not when cleaning up unnecessary code and refactoring. In general, test scenarios should include the possibility of non-functional, structural changes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we consider the different areas of application of tests, the question arises: which of these areas are worth the time and effort? </font><font style="vertical-align: inherit;">For example, in microservice applications, as well as in any system that provides significant work on the distribution and integration of code, integration tests are especially important, helping to grope the boundaries of the system. </font><font style="vertical-align: inherit;">Therefore, we need an effective way to test the entire application as a whole during local development, while maintaining the environment and structure of this application in the form that is as close to production as possible.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Principles and Limitations</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardless of the solutions that will be selected, let's define the following principles and limitations for our test suite:</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : ¬´     HTTP-  gRPC,   JSON  -      enterprise-, ..?‚Äù.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    ¬´ ¬ª,  ,    ,          , , ,  ‚Äúdev‚Äù  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">watch-and-deploy</a> (¬´  ¬ª)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The unit test checks the behavior of a single module, usually a class, while all external factors that are not related to the structure of the module are ignored or simulated. Unit tests should verify the business logic of individual modules, without checking their further integration or configuration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In my experience, most enterprise developers have a pretty good idea of ‚Äã‚Äãhow unit tests are compiled. To make an impression of this, you can see this example in my </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">coffee-testing</font></a><font style="vertical-align: inherit;"> project.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In most projects, JUnit is used in combination with Mockito to simulate dependencies, and ideally with AssertJ to efficiently define readable statements. I always emphasize that unit tests can be performed without special extensions or starters, that is, to do this with the usual JUnit. The explanation is simple: it‚Äôs all about runtime, because we need the ability to run hundreds of tests in a matter of milliseconds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a rule, unit tests run very quickly, and it is easy to assemble complex test suites or special workflows from them, since they are simple to execute and do not impose any restrictions on the life cycle of the test.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, when you have a lot of unit tests simulating the dependencies of the tested class, there is one drawback: they are closely connected with the implementation (this especially applies to classes and methods), which is why our code is difficult to refactor. In other words, for each refactoring act in the production code, it also requires changes to the test code. In the worst case, developers even begin to partially refuse refactoring, simply because it is too burdensome, and the quality of the code in the project is rapidly declining. Ideally, the developer should be able to refactor and rearrange the elements, provided that because of this there are no changes in the application that are noticeable to the user. Unit tests by no means always simplify refactoring production code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But experience suggests that unit tests are very effective at checking code that is densely filled with concise logic or describes the implementation of a specific function, for example, an algorithm, and, at the same time, does not interact very actively with other components. The less complex or dense the code in a particular class, the less its cyclomatic complexity, or the more actively it interacts with other components, the less effective unit tests will be when testing this class. Especially in cases with microservices, in which relatively little business logic is contained, but extensive integration with external systems is provided, there is probably little need to use unit tests in many. In such systems, individual modules (with rare exceptions) usually contain little specialized logic. This should be considered when decidingwhat is more appropriate to spend time and effort.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing application situations</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To cope with the problem of tightly linking tests with the implementation, you can try a slightly different approach to expand the scope of the tests. </font><font style="vertical-align: inherit;">In my book, I wrote about component tests, because I could not find a better term; </font><font style="vertical-align: inherit;">but, in essence, in this case we are talking about testing applied situations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application situation tests are integration tests that operate at the code level, which do not use built-in containers - they are abandoned for the sake of speeding up the launch. </font><font style="vertical-align: inherit;">They test the business logic of well-coordinated components, which are usually used within a specific practical case, from the boundary method - and then down to all the components associated with them. </font><font style="vertical-align: inherit;">Integration with external systems, for example, with databases, is imitated using mocks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Building such scenarios without the use of more advanced technologies that would automatically connect components seems like a big piece of work. However, we define reusable test components, they are also test counterparts that extend components by simulating, connecting, and also adding test configurations; all this is done to minimize the total amount of effort required for refactoring. The goal is to create the only responsibilities limiting the degree of influence of changes to a single class (or several classes) in the field of testing. Carrying out such work with a view to reuse, we reduce the total amount of necessary work, and such a strategy is justified when the project grows, but each component requires only minor repairs, and this work is quickly amortized.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To better imagine all this, suppose that we are testing a class that describes the order of coffee. This class includes two other classes: </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classes of test doubles, </font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are located in the test area of ‚Äã‚Äãthe project, where they inherit the components </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">located in the main area of ‚Äã‚Äãthe program. Test counterparts can set the necessary simulation and connection logic and potentially expand the class‚Äôs public interface using the simulation methods needed in this application or by verification methods. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following shows the test double class for the component </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The test double class can access the fields and constructors of the CoffeeShop base class to establish dependencies. Here, in the form of test twins, variants of other components are also used, in particular, </font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they are needed to call additional simulation or verification methods, which are part of the practical case. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classes of test doubles are reusable components, each of which is written once per scope of each project, and then is used in many practical cases:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Component test verifies the specific case of the business logic that is invoked at the entry point, in this case </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Such tests are obtained concise and readable, since all connection and simulation are performed in separate test twins, and later they can use highly specialized screening techniques, such as </font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, the test class expands the scope of the production class, allowing you to install mokee and use methods that verify the behavior. Despite the fact that it seems that setting up such a system takes a lot of effort, these costs are quickly amortized if, within the framework of the entire project, we have many practical cases where components can be reused. The more our project grows, the more useful this approach becomes - especially if you pay attention to the time taken to complete the tests. All our test cases are still run using JUnit, and in the shortest possible time, they are executed in hundreds.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the main benefit of this approach: component tests run as fast as regular unit tests, however, they stimulate production code refactoring, since changes need to be made to a single component or to just a few components. </font><font style="vertical-align: inherit;">In addition, improving test counterparts with expressive tuning and verification methods specific to our subject area, we increase the readability of our code, facilitate its use, and get rid of stereotyped code in test scripts.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489306/index.html">[Habr]: Donuts</a></li>
<li><a href="../en489310/index.html">Top 10: the best reports of Heisenbug 2019 Moscow</a></li>
<li><a href="../en489314/index.html">Ethernet Quartet: Old Speed, New Features</a></li>
<li><a href="../en489318/index.html">Mitap "DevOps Scalable Systems"</a></li>
<li><a href="../en489320/index.html">Practice using AI. Workshop ‚ÄúAnalysis of drone images to identify damaged houses‚Äù</a></li>
<li><a href="../en489328/index.html">Null sneaked up: breaking Scala Option using Java</a></li>
<li><a href="../en489332/index.html">Essential Assistants in the Intelligence of the Most Effective Intelligence Service in the World (Part 3)</a></li>
<li><a href="../en489336/index.html">Interface Bikes Toxic Grandfather. ‚ÄúLearn, study and study again‚Äù (s1 e3)</a></li>
<li><a href="../en489340/index.html">As the maximum unit for transmitting information on the Internet became 1500 bytes</a></li>
<li><a href="../en489342/index.html">Creation of fault-tolerant IT infrastructure. Part 4. Deploying Cisco 3850 Switches for Gateway Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>