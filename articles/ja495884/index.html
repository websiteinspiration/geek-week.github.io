<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏿 🌒 👩🏿‍🤝‍👨🏾 リカレントニューラルネットワークを使用した時系列予測 🤯 🍋 🧛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="普遍的な自己分離を背景にしたリモート操作モードは、非常に悪い結果につながる可能性があります。そして、感情的な燃え尽き症候群-それはどこにでもあります。結局のところ、屋根からそれほど遠くはありません。この点で、多くの人と同様に、彼は他のクラスに時間を割り当てて自分自身を「落ち着かせよう」とし、最も興味...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>リカレントニューラルネットワークを使用した時系列予測</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普遍的な自己分離を背景にしたリモート操作モードは、非常に悪い結果につながる可能性があります。そして、感情的な燃え尽き症候群-それはどこにでもあります。結局のところ、屋根からそれほど遠くはありません。この点で、多くの人と同様に、彼は他のクラスに時間を割り当てて自分自身を「落ち着かせよう」とし、最も興味深い記事を英語からロシア語に翻訳し始めました</font><font style="vertical-align: inherit;">。「大衆に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">与えます</font><font style="vertical-align: inherit;">！」）ロシア語を話す読者のために、意味的な内容とこのテキストの翻訳の両方について提案がある場合は、ディスカッションに参加してください。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="画像"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、これ</font><font style="vertical-align: inherit;">はテンソルフローのマニュアルセクションからの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列予測</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページの翻訳です</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私の追加と翻訳のイラストは、一般的なMLと計量経済学の最も興味深い領域の1つ、つまり予測時系列の基本的な考え方を理解するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翻訳前の簡単な紹介。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マニュアルは、1次元時系列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一変量時系列）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と多変量時系列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（多変量時系列）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づく気温予測の説明です</font><font style="vertical-align: inherit;">。各パーツについて、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを入力</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それに応じて準備する必要があります。このガイドで考慮されている気象データのセットを考えると、分離は次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">何を行う</font><font style="vertical-align: inherit;">か</font><font style="vertical-align: inherit;">、つまり、監視付きトレーニングのクラスのデータを準備する方法</font><font style="vertical-align: inherit;">についての質問</font><font style="vertical-align: inherit;">は、次の図から明らかになります。 1次元と多次元の両方の時系列を操作するためのターゲットベクトル（Y）の形成は同じであることに注意します。ターゲットベクトルは、符号</font><i><font style="vertical-align: inherit;">T（degC）に</font></i><font style="vertical-align: inherit;">基づいてコンパイルされます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大気温）。それらの違いは、モデルの入力に供給される一連の特徴の形成に「埋め込まれています」。将来の温度を予測するための1次元時系列の場合、入力ベクトル（X）は1つの特徴で構成されます。つまり、実際には気温です。多次元の場合-複数：気温に加えて、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p（mbar）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大気圧）と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho（g / m ** 3）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（湿度）</font><font style="vertical-align: inherit;">がこのガイドの例で使用されています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、表面的なもので、温度予測の例を見ると、多次元入力を使用する観点からは説得力がないように見えます。温度を予測する場合、最も重要な記号は温度です。ただし、これは完全に間違っています。気温の定性的な予測を作成するには、地表面の空気摩擦など、多くの要素を考慮する必要があります。さらに、実際には、いくつかのことは明白ではありません。ターゲットベクトルはそのホッジポッジ（またはボルシュ）の形式である場合があります。この点で、その後の多次元入力の形成に最も関連する機能を選択した探索的データ分析が唯一の正しい決定です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、このマニュアルの翻訳を以下に示します。追加のテキストは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イタリック体に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列予測</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドは、リカレントニューラルネットワーク（RNS、英語</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リカレントニューラルネットワーク、RNN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用した時系列予測の概要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは、2つの部分で構成されています。最初の部分は、1次元の時系列に基づく気温の予測を示し、2番目の部分は、多次元の時系列に基づいています。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">気象データのセット</font></font></b><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">生物地球化学研究所の</font></a><font style="vertical-align: inherit;">水文気象ステーションで記録された</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">気象データの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
手動使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての例は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マックスプランク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータセットには、2003年から10分ごとに実行された14種類の気象指標（気温、気圧、湿度など）の測定値が含まれています。</font><font style="vertical-align: inherit;">時間とメモリ使用量を節約するために、このマニュアルでは2009年から2016年までのデータを使用します。</font><font style="vertical-align: inherit;">データセットのこのセクションは、FrançoisCholletが彼の著書「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep Learning with Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」のために作成しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何があるか見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
観測記録期間が10分であることは、上の表で確認できます。したがって、1時間で6つの観測値が得られます。次に、1日あたり144（6x24）の観測が蓄積されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、6時間後の気温を予測するとします。この予測は、特定の期間のデータに基づいて行います。たとえば、5日間の観測を使用するとします。したがって、モデルをトレーニングするには、最後の720（5x144）観測を含む時間間隔を作成する必要があります（さまざまな構成が可能であるため、このデータセットは実験の良い基礎となります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の関数は、モデルをトレーニングするための上記の時間間隔を返します。引数</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは最後の時間間隔のサイズです</font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。-モデルが予測することを学習する必要がある未来までの距離を決定する引数。</font><font style="vertical-align: inherit;">つまり、</font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は予測が必要なターゲットベクトルです。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マニュアルの両方の部分で、モデルのトレーニングに最初の300,000行のデータが使用され、残りは検証（検証）に使用されます。</font><font style="vertical-align: inherit;">この場合、トレーニングデータの量は約2100日です。</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再現可能な結果を​​保証するために、シード関数が設定されています。</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1. 1次元の時系列に基づく予測</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分では、1つの属性-温度のみを使用してモデルをトレーニングします。</font><font style="vertical-align: inherit;">トレーニングされたモデルは、将来の気温を予測するために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、データセットから温度のみを抽出します。</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、このデータが時間とともにどのように変化するかを見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="画像"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人工ニューラルネットワーク（以降、ANN）をトレーニングする前に、重要なステップはデータのスケーリングです。</font><font style="vertical-align: inherit;">スケーリングを実行する一般的な方法の1つは、標準化（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standardization</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">です。これは</font><font style="vertical-align: inherit;">、平均を差し引き、各特性の標準偏差で割ることによって実行されます。</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を[0,1]の範囲にスケーリング</font><font style="vertical-align: inherit;">するメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用することもでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：標準化は、トレーニングデータを使用してのみ実行する必要があります。</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの標準化を行っています。</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、1次元の入力を持つモデルのデータを準備します。</font><font style="vertical-align: inherit;">温度の最後の20個の記録された観測値がモデルに送られ、次のタイムステップで温度を予測するようにモデルをトレーニングする必要があります。</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を適用した結果</font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：1次元の入力を持つモデルのデータの準備を次の図に概略的に示します（便宜上、この図と後続の図では、データは標準化前の未加工の形式で示され、インデックスとして '日時'属性もありません）：</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これでデータ適切に準備された、具体的な例を検討してください。</font><font style="vertical-align: inherit;">ANNに送信される情報は青色で強調表示され、赤い十字はANNが予測する将来の価値を示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="画像"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なソリューション（機械学習を含まない）</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
モデルのトレーニングを開始する前に、簡単な基​​本的なソリューション（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースライン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">をインストールし</font><font style="vertical-align: inherit;">ます。これは次のように構成されています。特定の入力ベクトルに対して、基本的な解法は履歴全体を「調べ」、次の値を最後の20個の観測値の平均として予測します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リカレントニューラルネットワークを使用して「平均化」の結果を超えることができるかどうかを見てみましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰型ニューラルネットワーク</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
再帰型ニューラルネットワーク（RNS）は、時系列問題の解決に適したANNの一種です。 RNSは、データの時系列を段階的に処理し、その要素を並べ替え、前の要素を処理することによって取得された内部状態を保持します。 RNSの詳細については、次の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガイドを参照してください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このガイドでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期短期記憶（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">と呼ばれるRNCの特殊なレイヤーを使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに使用</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットをシャッフル、バッチ、キャッシュします。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">tensorflow</font></a></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ページのシャッフル、バッチ、キャッシュメソッドの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳細</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の視覚化は、バッチ処理後のデータがどのように見えるかを理解するのに役立ちます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LSTMには、LSTMに提供される特定の形式のデータ入力が必要であることがわかります。</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデル出力を確認してください。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、RNSはシーケンスで機能します。</font><font style="vertical-align: inherit;">これは、モデルの入力に提供されるデータは次の形式である必要があることを意味します</font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1次元の入力を持つモデルのトレーニングデータの形式は次の形式です。</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、モデルを検討します。</font><font style="vertical-align: inherit;">データセットのサイズが大きいため、時間を節約するために</font><font style="vertical-align: inherit;">、通常行わ</font><font style="vertical-align: inherit;">れるように、各エポックは</font><font style="vertical-align: inherit;">完全なトレーニングデータの代わりに</font><font style="vertical-align: inherit;">200ステップ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のみを通過します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なLSTMモデルを使用した予測単純なLSTMモデル</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の準備が完了したら、いくつかの予測を行います。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本レベルよりも良く見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本に慣れたので、多次元時系列の操作について説明する2番目のパートに進みましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2：多次元時系列予測</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述べたように、元のデータセットには14種類の気象指標が含まれています。</font><font style="vertical-align: inherit;">簡略化と便宜のために、2番目の部分では、気温、気圧、気圧の3つだけが考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに多くの機能を使用するには、それらの名前を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストに追加する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの指標が時間とともにどのように変化するか見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前と同じように、最初のステップは、トレーニングデータの平均値と標準偏差の計算でデータセットを標準化することです。</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補足：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マニュアルではさらに、ポイントとインターバルの予測について説明します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一番下の行は次のとおりです。モデルで将来の1つの値（たとえば、12時間後の温度値）を予測する必要がある場合（1ステップ/シングルステップモデル）、モデルは将来の1つの値のみを予測するようにトレーニングする必要があります。タスクが将来の値の範囲を予測することである場合（たとえば、次の12時間の毎時の温度値）（マルチステップモデル）、モデルはまた、将来の値の範囲を予測するようにトレーニングする必要があります。</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="画像"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント予測</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この場合、モデルは、いくつかの利用可能な履歴に基づいて将来の1つの値を予測するようにトレーニングされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の関数は、時間間隔を整理する同じタスクを実行しますが、ここでは、所定のステップサイズに基づいて最新の観測を選択する点が異なります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、ANNは過去5日間のデータ、つまり720観測（6x24x5）を操作します。</font><font style="vertical-align: inherit;">データの選択が10分ごとではなく1時間ごとに実行されると想定します。60分以内には急激な変化は期待されません。</font><font style="vertical-align: inherit;">したがって、過去5日間の履歴は120回の観測（720/6）で構成されます。</font><font style="vertical-align: inherit;">スポット予測を実行するモデルの場合、目標は、12時間後の温度を読み取ることです。</font><font style="vertical-align: inherit;">この場合、ターゲットベクトルは、72（12x6）観測後の温度になります（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の追加を参照してください-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近似</font><i><font style="vertical-align: inherit;">トランスレーター</font></i><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間間隔を確認してください。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルを確認し、トレーニングと検証の段階で損失曲線を導き出します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="画像"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図に、ポイント予測を実行する多次元入力を持つモデルのデータ準備を概略的に示します。</font><font style="vertical-align: inherit;">便宜上、データ準備をより視覚的に表現するために、引数</font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は1です。指定されたジェネレーター関数では、</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数は</font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履歴の形成のみを目的</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">としており、ターゲットベクトルを対象としていない</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="画像"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場合、</font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の形式になり</font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の場合</font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フォームは次の形式になります：</font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の速度が大幅に向上します。</font><font style="vertical-align: inherit;">一般的には、プログラマーにクレジットを与える必要があります。マニュアルに記載されているジェネレーターは、メモリー消費に関して非常に貪欲です。</font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント予測を実行する</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルがトレーニングされたので、いくつかのテスト予測を実行します。 1時間ごと（時間間隔= 120）に選択された過去5日間の3つの兆候の観測履歴がモデル入力に供給されます。私たちの目標は温度のみを予測することなので、過去の温度値（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履歴</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は</font><font style="vertical-align: inherit;">グラフ上に青色で表示されます</font><font style="vertical-align: inherit;">。予測は未来の半日になされました（そのため、履歴と予測値のギャップ）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="画像"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間隔予測</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この場合、いくつかの利用可能な履歴に基づいて、モデルは将来の値の間隔を予測するようにトレーニングされます。</font><font style="vertical-align: inherit;">したがって、将来的に1つの値のみを予測するモデルとは対照的に、このモデルは将来の一連の値を予測します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイント予測を実行するモデルの場合と同様に、間隔予測を実行するモデルの場合、トレーニングデータは過去5日間の時間ごとの測定値（720/6）です。</font><font style="vertical-align: inherit;">ただし、この場合、次の12時間の温度を予測するようにモデルをトレーニングする必要があります。</font><font style="vertical-align: inherit;">観測は10分ごとに記録されるため、モデルの出力は72の予測で構成されます。</font><font style="vertical-align: inherit;">このタスクを完了するには、データ・セットを再度準備する必要がありますが、ターゲット間隔は異なります。</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択を確認してください。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：「点モデル」と「間隔モデル」のターゲットベクトルの形成の違いを次の図に示します。</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可視化の準備をします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このグラフとその後の同様のグラフでは、履歴と将来のデータは時間単位です。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタスクは前のタスクより少し複雑であるため、モデルは2つのLSTM層で構成されます。</font><font style="vertical-align: inherit;">最後に、72個の予測が実行されるため、出力層には72個のニューロンがあります。</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルを確認し、トレーニングと検証の段階で損失曲線を導き出します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="画像"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区間予測の実行では</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、訓練されたANNが将来の気温値の予測にどのようにうまく対処できるかを見てみましょう。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="画像"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のステップ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドは、RNSを使用した時系列予測の簡単な紹介です。今、あなたは株式市場を予測して、億万長者になることを試みることができます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（元のように:)。 - 注意翻訳者）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font><font style="vertical-align: inherit;">メモリをより効率的に使用するために</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uni / multivariate_data関数の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに、データを準備するための独自のジェネレーターを作成できます</font><font style="vertical-align: inherit;">。また、「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列のウィンドウ処理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の</font><font style="vertical-align: inherit;">作業に慣れ</font><font style="vertical-align: inherit;">、そのアイデアをこのガイドに取り入れる</font><font style="vertical-align: inherit;">こともできます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに理解を深めるために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Scikit-Learn、Keras、TensorFlowを使用した応用機械学習」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Aurelien Geron、第2版）の</font><font style="vertical-align: inherit;">第15章と、本の第6章を読むことをお勧めします。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Pythonでの深層学習」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Francois Scholl）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に追加</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自宅にいる間は、健康状態だけでなく、切り捨てられたデータセットに対してマニュアルの例を実行することで、コンピューターに同情してください。</font><font style="vertical-align: inherit;">たとえば、70x30（トレーニング/テスト）の比率を考慮して、次のように制限できます。</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495862/index.html">Trusted Types-WebアプリケーションコードをXSS攻撃から保護する新しい方法</a></li>
<li><a href="../ja495864/index.html">ゲームの設計システムの作成：アプローチの詳細な分析</a></li>
<li><a href="../ja495870/index.html">忙しいプロジェクトでCephを使用するためのヒントとコツ</a></li>
<li><a href="../ja495880/index.html">「Head First。ラーニングゴー»</a></li>
<li><a href="../ja495882/index.html">2020年3月の最高のオープンソース発見9つ</a></li>
<li><a href="../ja495888/index.html">PyConロシアは、将来の講演者のためにCFPを開設しました。参加フォームと期待されるトピック</a></li>
<li><a href="../ja495890/index.html">Docker SwarmでのNginx / LetsEncryptバンドルの構成</a></li>
<li><a href="../ja495892/index.html">あなたは本当に配列が何であるか知っていますか？</a></li>
<li><a href="../ja495894/index.html">JavaScriptパフォーマンス測定</a></li>
<li><a href="../ja495896/index.html">Use-soundパッケージ：Reactアプリケーションの効果音</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>