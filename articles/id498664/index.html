<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👒 👎🏾 🤷🏾 UI Backend-Driven dengan widget ♈️ 🙏🏼 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertimbangkan fitur-fitur dari pendekatan ini dan implementasi kami menggunakan widget, konsep, kelebihan, dan perbedaan dari pandangan lain di Androi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>UI Backend-Driven dengan widget</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/498664/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan fitur-fitur dari pendekatan ini dan implementasi kami menggunakan widget, konsep, kelebihan, dan perbedaan dari pandangan lain di Android.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0z/p9/hd/0zp9hdtjfkdd28_s70pm46rqvw0.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backend-Driven UI - sebuah pendekatan yang memungkinkan Anda membuat komponen UI berdasarkan respons server. Deskripsi API harus berisi jenis komponen dan propertinya, dan aplikasi harus menampilkan komponen yang diperlukan tergantung pada jenis dan propertinya. Secara umum, logika komponen dapat diletakkan, dan untuk aplikasi mobile, mereka adalah kotak hitam, karena masing-masing komponen dapat memiliki logika yang independen dari sisa aplikasi dan dapat dikonfigurasi secara sewenang-wenang oleh server, tergantung pada logika bisnis yang diperlukan. Itulah sebabnya pendekatan ini sering digunakan dalam aplikasi perbankan: misalnya, ketika Anda perlu menampilkan formulir terjemahan dengan sejumlah besar bidang yang ditentukan secara dinamis. Aplikasi tidak tahu sebelumnya komposisi bentuk dan urutan bidang di dalamnya, oleh karena itu,pendekatan ini adalah satu-satunya cara untuk menulis kode tanpa kruk. Selain itu, ini menambah fleksibilitas: dari sisi server, Anda dapat mengubah formulir kapan saja, dan aplikasi seluler akan siap untuk ini.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan kasing</font></font></h3><br>
<img src="https://habrastorage.org/webt/kd/ao/vw/kdaovw36bkxi3ec-y5ajmidakke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis komponen berikut ini disajikan di atas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar akun yang tersedia untuk ditransfer;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nama jenis terjemahan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang untuk memasukkan nomor telepon (memiliki topeng untuk memasukkan dan berisi ikon untuk memilih kontak dari perangkat);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang untuk memasukkan jumlah transfer.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga pada formulir, sejumlah komponen lain yang tertanam dalam logika bisnis dan ditentukan pada tahap desain dimungkinkan. Informasi tentang setiap komponen yang datang dalam respons dari server harus memenuhi persyaratan, dan setiap komponen harus diharapkan oleh aplikasi seluler untuk memprosesnya dengan benar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/3g/hu/j93ghualguxt2lxhch93sraomys.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bidang input yang berbeda memiliki masker dan aturan validasi yang berbeda; tombol mungkin memiliki animasi kilau pada saat boot; widget untuk memilih akun charge-off dapat memiliki animasi saat menggulir, dan sebagainya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua komponen UI terpisah satu sama lain, dan logikanya dapat dibawa ke tampilan terpisah dengan area tanggung jawab yang berbeda - sebut saja mereka widget. Setiap widget menerima konfigurasinya dalam respons server dan merangkum logika tampilan dan pemrosesan data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat mengimplementasikan layar, RecyclerView paling cocok, elemen yang akan berisi widget. </font><font style="vertical-align: inherit;">ViewHolder dari setiap item daftar unik akan menginisialisasi widget dan memberikannya data yang diperlukan untuk ditampilkan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsep widget</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita pertimbangkan widget lebih detail. </font><font style="vertical-align: inherit;">Pada intinya, widget adalah tampilan khusus "dengan kecepatan maksimum." </font><font style="vertical-align: inherit;">Tampilan kustom biasa juga dapat berisi data dan logika tampilan mereka, tetapi widget menyiratkan sesuatu yang lebih - itu memiliki presenter, model layar dan memiliki ruang lingkup DI sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum masuk ke detail penerapan widget, kami membahas keunggulannya:</font></font><br>
<br>
<ul>
<li>     ,   ,   «» ,       —     UI-  ,             .</li>
<li>        ,         ,         .</li>
<li>,     —        :  ,      ,    .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengimplementasikan widget scalable, kami menggunakan kelas dasar untuk ViewGroup yang paling umum digunakan, yang memiliki cakupan DI sendiri. Semua kelas dasar, pada gilirannya, diwarisi dari antarmuka umum, yang berisi semua yang diperlukan untuk menginisialisasi widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasing termudah untuk menggunakan widget adalah tampilan statis, yang ditentukan secara langsung dalam tata letak. Setelah menerapkan kelas widget, Anda dapat dengan aman menambahkannya ke tata letak XML, tanpa lupa untuk menentukan idnya di tata letak (berdasarkan id, lingkup DI widget akan dibentuk). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel ini, kami mempertimbangkan widget dinamis lebih detail, karena kasus bentuk terjemahan yang dijelaskan di atas dengan set bidang yang sewenang-wenang diselesaikan dengan mudah dengan bantuan mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Widget apa pun, baik statis maupun dinamis, dalam penerapan kami hampir tidak berbeda dengan tampilan biasa dalam hal MVP. </font><font style="vertical-align: inherit;">Biasanya, 4 kelas diperlukan untuk mengimplementasikan widget:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat kelas, tempat tata letak tata letak dan menampilkan konten terjadi;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidget</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        context: Context,<font></font>
        attrs: AttributeSet? = <span class="hljs-literal">null</span><font></font>
) : CoreFrameLayoutView(context, attrs) {<font></font>
<span class="hljs-meta">@Inject</span>
<span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> presenter: TextInputFieldPresenter<font></font>
…<font></font>
<span class="hljs-keyword">init</span> {<font></font>
     inflate(context, R.layout.view_field_text_input, <span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas untuk presenter, di mana logika dasar widget dijelaskan, misalnya:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memuat data dan mengirimkannya untuk render;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berlangganan berbagai acara dan memancarkan acara perubahan input widget;</font></font></li>
</ol><br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@PerScreen</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldPresenter</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        basePresenterDependency: BasePresenterDependency,<font></font>
        rxBus: RxBus<font></font>
) : BaseInputFieldPresenter&lt;TextInputFieldWidget&gt;(<font></font>
       basePresenterDependency, rxBus<font></font>
) {<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TextInputFieldScreenModel()<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam implementasi kami, kelas RxBus adalah bus berbasis PublishSubject untuk mengirim acara dan berlangganan.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas untuk model layar, dengan bantuan yang presenter menerima data dan mentransfernya untuk rendering dalam tampilan (dalam hal pola Model Presentasi);</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldScreenModel</span> : <span class="hljs-type">ScreenModel</span></span>() {
	<span class="hljs-keyword">val</span> value = String = “”
	<span class="hljs-keyword">val</span> hint = String = “”
	<span class="hljs-keyword">val</span> errorText = String = “”<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas konfigurator untuk mengimplementasikan DI, dengan bantuan dependensi widget yang memiliki cakupan yang diinginkan, dan presenter disuntikkan ke dalam pandangannya.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidgetConfigurator</span> : <span class="hljs-type">WidgetScreenConfigurator</span></span>() {
	<span class="hljs-comment">// logic for components injection</span><font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu-satunya perbedaan antara widget dan penerapan layar penuh kami (Aktivitas, Fragmen) adalah bahwa widget tidak memiliki banyak metode siklus hidup (onStart, onResume, onPause). </font><font style="vertical-align: inherit;">Ini hanya memiliki metode onCreate, yang menunjukkan bahwa widget saat ini telah menciptakan ruang lingkupnya, dan sendoknya dihancurkan dalam metode onDetachedFromWindow. </font><font style="vertical-align: inherit;">Tetapi untuk kenyamanan dan konsistensi, penyaji widget mendapatkan metode siklus hidup yang sama dengan sisa layar. </font><font style="vertical-align: inherit;">Peristiwa ini secara otomatis dikirimkan kepadanya dari orang tua. </font><font style="vertical-align: inherit;">Perlu dicatat bahwa kelas dasar dari presenter widget adalah kelas dasar yang sama dari presenter layar lain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan widget dinamis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita beralih ke implementasi kasus yang dijelaskan di awal artikel.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di presenter layar, data untuk formulir terjemahan dimuat, data ditransmisikan ke tampilan untuk rendering. </font><font style="vertical-align: inherit;">Pada tahap ini, tidak masalah bagi kami apakah tampilan layar aktivitas adalah fragmen atau widget. </font><font style="vertical-align: inherit;">Kami hanya tertarik memiliki RecyclerView dan merender bentuk dinamis dengannya.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormPresenter</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TransferFormScreenModel()<font></font>
…<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {<font></font>
	loadDataDisposable.dispose()<font></font>
  	loadDataDisposable = subscribe(<font></font>
              observerDataForTransfer().io(), <font></font>
              { <span class="hljs-keyword">data</span> -&gt; <font></font>
                      sm.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span><font></font>
                      view.render(sm)<font></font>
              },<font></font>
              { error -&gt; <span class="hljs-comment">/* error handling */</span> }<font></font>
  	)<font></font>
 }<font></font>
</code></pre><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data formulir ditransfer ke adaptor daftar dan diterjemahkan menggunakan widget yang ada di ViewHolder untuk setiap elemen formulir unik. </font><font style="vertical-align: inherit;">ViewHolder yang diinginkan untuk rendering komponen ditentukan berdasarkan tipe komponen form yang telah ditentukan.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormView</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(sm: <span class="hljs-type">TransferFormScreenModel</span>)</span></span> {
    <span class="hljs-comment">//      </span>
    <span class="hljs-comment">//   EasyAdapter [3]</span>
    <span class="hljs-keyword">val</span> list = ItemList.create()
    <span class="hljs-comment">//       Controller,</span>
    <span class="hljs-comment">//       </span><font></font>
<font></font>
    sm.<span class="hljs-keyword">data</span><font></font>
        .filter { transferField -&gt; transferField.visible }<font></font>
        .forEach { transferField -&gt;<font></font>
            <span class="hljs-keyword">when</span> (transferField.type) {<font></font>
                TransferFieldType.PHONE_INPUT -&gt; {<font></font>
                    list.add(<font></font>
                        PhoneInputFieldData(transferField),<font></font>
                        phoneInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.MONEY -&gt; {<font></font>
                    list.add(<font></font>
                        MoneyInputFieldData(transferField),<font></font>
                        moneyInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.BUTTON -&gt; {<font></font>
                    list.add(<font></font>
                        ButtonInputFieldData(transferField),<font></font>
                        buttonController<font></font>
                    )<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> -&gt; {<font></font>
                    list.add(<font></font>
                        TextInputFieldData(transferField),<font></font>
                        textInputController<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-comment">//     RecyclerView</span><font></font>
        adapter.setItems(list)<font></font>
}  <font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget diinisialisasi dalam metode mengikat ViewHolder. </font><font style="vertical-align: inherit;">Selain mentransmisikan data untuk render, penting juga untuk menetapkan id unik untuk widget, atas dasar di mana ruang lingkup DI-nya akan dibentuk. </font><font style="vertical-align: inherit;">Dalam kasus kami, setiap elemen formulir memiliki id unik, yang bertanggung jawab untuk pengangkatan input dan datang sebagai respons selain jenis elemen (jenis dapat diulang pada formulir).</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ViewHolder</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">TransferFieldUi</span>)</span></span> {
	<span class="hljs-comment">// get initialize params from given data</span><font></font>
	itemView.findViewById(R.id.field_tif).initialize(...)<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode inisialisasi menginisialisasi data tampilan widget, yang kemudian dikirim ke presenter menggunakan metode siklus hidup onCreate, di mana nilai-nilai bidang diatur ke model widget dan render-nya.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">(
       id: <span class="hljs-type">String</span> = this.id,
       value: <span class="hljs-type">String</span> = this.value,
       hint: <span class="hljs-type">String</span> = this.hint,
       errorText: <span class="hljs-type">String</span> = this.errorText
)</span></span> {
       <span class="hljs-keyword">this</span>.id = id
       <span class="hljs-keyword">this</span>.value = value
       <span class="hljs-keyword">this</span>.hint = hint
       <span class="hljs-keyword">this</span>.errorText = errorText<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
       presenter.onCreate(value, hint, errorText)<font></font>
       <span class="hljs-comment">// other logic...</span><font></font>
}<font></font>
<span class="hljs-comment">// TextInputFieldPresenter</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, hint: <span class="hljs-type">String</span>, errorText: <span class="hljs-type">String</span>)</span></span> {<font></font>
       sm.value = value<font></font>
       sm.hint = hint<font></font>
       sm.errorText = errorText<font></font>
       view.render(sm)<font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batuan bawah laut</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti dapat dilihat dari uraiannya, implementasinya sangat sederhana dan intuitif. </font><font style="vertical-align: inherit;">Namun, ada nuansa yang perlu diperhatikan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan siklus hidup widget</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kelas dasar widget adalah pewaris ViewGroup yang umum digunakan, kami juga mengetahui siklus hidup widget. </font><font style="vertical-align: inherit;">Biasanya, widget diinisialisasi dalam ViewHolder dengan memanggil metode khusus tempat data ditransfer, seperti yang ditunjukkan pada paragraf sebelumnya. </font><font style="vertical-align: inherit;">Inisialisasi lainnya terjadi di onCreate (misalnya, mengatur pendengar klik) - metode ini dipanggil setelah onAttachedToWindow menggunakan delegasi khusus yang mengontrol entitas kunci dari logika widget.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// CoreFrameLayoutView (      ViewGroup)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreFrameLayoutView</span></span><font></font>
          extends FrameLayout implements CoreWidgetViewInterface {<font></font>
…<font></font>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onAttachedToWindow() {
   <span class="hljs-keyword">super</span>.onAttachedToWindow();
   <span class="hljs-keyword">if</span> (!isManualInitEnabled) {<font></font>
        widgetViewDelegate = createWidgetViewDelegate();<font></font>
        widgetViewDelegate.onCreate();<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
    <span class="hljs-comment">//empty. define in descendant class if needed</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WidgetViewDelegate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetViewDelegate</span> </span>{<font></font>
…<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
   <span class="hljs-comment">// other logic of widget initialization</span><font></font>
   coreWidgetView.onCreate();<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selalu bersihkan pendengarnya</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika ada bidang tergantung pada formulir, kita mungkin perluDetachedFromWindow. </font><font style="vertical-align: inherit;">Pertimbangkan kasus berikut: formulir terjemahan memiliki banyak bidang, di antaranya ada daftar drop-down. </font><font style="vertical-align: inherit;">Bergantung pada nilai yang dipilih dalam daftar, bidang input formulir tambahan dapat menjadi terlihat atau yang sudah ada dapat menghilang.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai tarik-turun untuk memilih jenis terjemahan</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilitas bidang input periode pembayaran</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visibilitas bidang input nomor telepon</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfer dengan nomor telepon</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pembayaran</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus yang dijelaskan di atas, sangat penting untuk menghapus semua pendengar widget dalam metode onDetachedFromWindow, karena jika Anda menambahkan widget ke daftar lagi, semua pendengar akan diinisialisasi ulang.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
     initListeners()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> {
      <span class="hljs-keyword">super</span>.onDetachedFromWindow()<font></font>
      clearListeners()<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tangani langganan acara widget dengan benar</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Presentasi layar yang berisi widget harus diberitahu tentang perubahan input setiap widget. Implementasi yang paling jelas dari setiap widget menggunakan acara memancarkan dan berlangganan semua acara dengan presenter layar. Acara harus berisi id widget dan datanya. Yang terbaik adalah menerapkan logika ini sehingga nilai input saat ini disimpan dalam model layar dan ketika Anda mengklik tombol, data yang sudah selesai dikirim dalam permintaan. Dengan pendekatan ini, lebih mudah untuk menerapkan validasi formulir: itu terjadi ketika tombol diklik, dan jika tidak ada kesalahan, permintaan dikirim dengan data formulir disimpan terlebih dahulu.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTextChangedListener = <span class="hljs-keyword">object</span> : OnMaskedValueChangedListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onValueChanged</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {<font></font>
            presenter.onTextChange(value, id)<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Events.kt</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputValueType</span></span>(<span class="hljs-keyword">val</span> id: String)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextValue</span></span>(id: String, <span class="hljs-keyword">val</span> value: String) : InputValueType(id)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataEvent</span></span>(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: InputValueType)<font></font>
<font></font>
<span class="hljs-comment">// TextInputFieldPresenter -  </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChange</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, id: <span class="hljs-type">String</span>)</span></span> {<font></font>
	rxBus.emitEvent(DataEvent(<span class="hljs-keyword">data</span> = TextValue(id = id, value = value)))<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// TransferFormPresenter -  </span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeToEvents</span><span class="hljs-params">()</span></span> {<font></font>
	subscribe(rxBus.observeEvents(DataEvent::<span class="hljs-keyword">class</span>.java))<font></font>
        {<font></font>
            handleValue(it.<span class="hljs-keyword">data</span>) // handle <span class="hljs-keyword">data</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handleValue(value: InputValueType) {
	 <span class="hljs-keyword">val</span> id = value.id
	 <span class="hljs-keyword">when</span> (value) {<font></font>
		 // handle event using its type, saving event value using its id<font></font>
	 	 <span class="hljs-keyword">is</span> TextValue -&gt; {<font></font>
       		 	 sm.fieldValuesMap[id] = value.value<font></font>
       	 	 }<font></font>
		 <span class="hljs-keyword">else</span> -&gt; {<font></font>
			// handle other events<font></font>
		 }<font></font>
 	 }<font></font>
}<font></font>
// TransferScreenModel<font></font>
<span class="hljs-keyword">class</span> TransferScreenModel : ScreenModel() {<font></font>
 	 // map <span class="hljs-keyword">for</span> form values: key = input id
	 <span class="hljs-keyword">val</span> fieldValuesMap: MutableMap&lt;String, String&gt; = mutableMapOf()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada opsi implementasi kedua, di mana acara dari widget dengan datanya datang hanya setelah mengklik tombol, dan bukan saat Anda mengetik, yaitu, kami mengumpulkan semua data segera sebelum mengirim permintaan. </font><font style="vertical-align: inherit;">Dengan opsi ini, akan ada lebih sedikit peristiwa, tetapi perlu dicatat bahwa implementasi ini dapat berubah menjadi tidak praktis dalam praktiknya, dan logika tambahan akan diperlukan untuk memeriksa apakah semua peristiwa telah diterima.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unify All Requirements</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin sekali lagi mencatat bahwa kasus yang dijelaskan hanya mungkin setelah mengoordinasikan persyaratan dengan backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persyaratan apa yang perlu disatukan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis bidang. </font><font style="vertical-align: inherit;">Setiap bidang harus diharapkan oleh aplikasi seluler untuk tampilan dan pemrosesan yang benar.</font></font></li>
<li>  —     ,   ,     ,        .</li>
<li>   ,         .</li>
<li> .    ,          : ,    ,     —              ,        -,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/vy/h-/v4/vyh-v4r81dk91ehe3t3j8fgurkq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini diperlukan agar komponen yang diterima dalam respons diketahui oleh aplikasi seluler untuk tampilan dan pemrosesan logika yang benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuansa kedua adalah bahwa komponen-komponen bentuk itu sendiri umumnya tidak tergantung satu sama lain, namun beberapa skenario dimungkinkan ketika, misalnya, visibilitas satu elemen tergantung pada keadaan elemen lainnya, seperti dijelaskan di atas. </font><font style="vertical-align: inherit;">Untuk mengimplementasikan logika ini, perlu agar elemen-elemen dependen selalu datang bersama-sama, dan respon harus mengandung deskripsi dari logika, komponen mana yang saling bergantung dan bagaimana. </font><font style="vertical-align: inherit;">Dan tentu saja, semua ini harus disepakati dengan tim server sebelum memulai pengembangan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, ketika menerapkan bahkan kasus standar seperti mengisi daftar dinamis, Anda selalu dapat berhenti pada solusi yang sudah ada. </font><font style="vertical-align: inherit;">Bagi kami, ini adalah konsep baru, yang memungkinkan kami untuk memilih potongan atom logika dan representasi dari layar besar dan kami berhasil mendapatkan solusi yang dapat diperluas yang mudah dipelihara karena kesamaan widget dengan pandangan lain. </font><font style="vertical-align: inherit;">Dalam implementasi kami, widget dikembangkan berdasarkan pola RxPM - setelah menambahkan binder, widget menjadi lebih nyaman digunakan, tetapi ini adalah cerita yang sangat berbeda.</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan yang bermanfaat</font></font></b></h4><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerangka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pengembangan aplikasi Android </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Surf</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul widget</font></font></a></li>
<li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">dalam</font></a><font style="vertical-align: inherit;"> membuat daftar sederhana yang rumit</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola PresentationModel</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id498654/index.html">Apa itu VPS / VDS dan bagaimana cara membelinya. Instruksi yang paling masuk akal</a></li>
<li><a href="../id498656/index.html">Uji Baterai Crohn</a></li>
<li><a href="../id498658/index.html">Panduan Pengujian Keamanan Web Yang Diperbarui Konsorsium OWASP</a></li>
<li><a href="../id498660/index.html">Bagaimana trem tak berawak kita melihat kota yang sebenarnya</a></li>
<li><a href="../id498662/index.html">Bagaimana COVID-19 dapat mengubah hasil pencarian Google selamanya?</a></li>
<li><a href="../id498672/index.html">Tombol dan ragamnya</a></li>
<li><a href="../id498674/index.html">Tren Keamanan Produk 2020 Rekaman Video Konferensi Online</a></li>
<li><a href="../id498678/index.html">Memetakan ke puncak gunung dan phonendoscope di dekat patung Kristus - bagaimana proyektor memungkinkan Anda untuk mengekspresikan kata-kata dukungan di masa-masa sulit</a></li>
<li><a href="../id498686/index.html">Corners Langganan iOS Auto dapat diperpanjang</a></li>
<li><a href="../id498688/index.html">Panduan Uji A / B Bagus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>