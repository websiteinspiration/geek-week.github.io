<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛏️ 🙄 👩‍🚀 Guía para trabajar con OpenAL en C ++. Parte 1: reproducir sonido 👨‍👨‍👦‍👦 🗑️ 🐝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Tu juego necesita sonido! Probablemente ya haya usado OpenGL para dibujar en la pantalla. Descubriste su API, por lo que recurriste a OpenAL porque e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Guía para trabajar con OpenAL en C ++. Parte 1: reproducir sonido</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488744/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Tu juego necesita sonido! </font><font style="vertical-align: inherit;">Probablemente ya haya usado OpenGL para dibujar en la pantalla. </font><font style="vertical-align: inherit;">Descubriste su API, por lo que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recurriste</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">OpenAL</font></a><font style="vertical-align: inherit;"> porque el nombre parece familiar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, la buena noticia es que OpenAL también tiene una API muy familiar. </font><font style="vertical-align: inherit;">Originalmente fue diseñado para simular la API de especificación OpenGL. </font><font style="vertical-align: inherit;">Por eso lo elegí entre los muchos sistemas de sonido para juegos; </font><font style="vertical-align: inherit;">Además, es multiplataforma. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este artículo, hablaré en detalle sobre qué código se necesita para usar OpenAL en un juego escrito en C ++. </font><font style="vertical-align: inherit;">Discutiremos los sonidos, la música y el posicionamiento del sonido en el espacio 3D con ejemplos de código.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Historia de OpenAL</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentaré ser breve. Como se mencionó anteriormente, fue diseñado intencionalmente como una imitación de la API de OpenGL, y hay una razón para esto. Esta es una API conveniente que muchos conocen, y si los gráficos son un lado del motor del juego, entonces el sonido debería ser diferente. Inicialmente, se suponía que OpenAL era de código abierto, pero luego sucedió algo ... La </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gente no está tan interesada en el sonido como en los gráficos, por lo que Creative finalmente hizo de OpenAL su propiedad, y la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementación de referencia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ahora </font><em><font style="vertical-align: inherit;">es</font></em><font style="vertical-align: inherit;"> propietaria y no gratuita. ¡Pero! </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La especificación</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OpenAL sigue siendo un estándar "abierto", es decir, se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De vez en cuando, se modifican las especificaciones, pero no muchas. El sonido no cambia tan rápido como los gráficos, porque no hay una necesidad particular de esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La especificación abierta permitió a otras personas crear una implementación de código abierto de la especificación. Una de estas implementaciones es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenAL Soft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y, francamente, no tiene sentido buscar otras. Esta es la implementación que usaré, y le recomiendo que también la use.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ella es multiplataforma. </font><font style="vertical-align: inherit;">Se implementa de manera bastante curiosa; de hecho, dentro de la biblioteca utiliza otras API de sonido presentes en su sistema. </font><font style="vertical-align: inherit;">En Windows, usa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectSound</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en Unix, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Gracias a esto, ella pudo convertirse en multiplataforma; </font><font style="vertical-align: inherit;">en esencia, este es un gran nombre para la API del contenedor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede que le preocupe la velocidad de esta API. </font><font style="vertical-align: inherit;">Pero no te preocupes. </font><font style="vertical-align: inherit;">Este es el mismo sonido, y no crea una gran carga, por lo que no requiere las grandes optimizaciones requeridas por la API de gráficos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero suficiente historia, pasemos a la tecnología.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué necesitas para escribir código en OpenAL?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesita construir OpenAL Soft en la cadena de herramientas que elija. Este es un proceso muy simple que puede seguir de acuerdo con las instrucciones </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la sección Instalación de origen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nunca he tenido ningún problema con esto, pero si tiene alguna dificultad, escriba un comentario debajo del artículo original o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escriba a la lista de correo de OpenAL Soft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, necesitará algunos archivos de sonido y una forma de descargarlos. La carga de datos de audio en buffers y detalles sutiles de varios formatos de audio están fuera del alcance de este artículo, pero puede leer sobre la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descarga y transmisión de archivos Ogg / Vorbis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Descargar archivos WAV es muy simple, ya hay cientos de artículos en Internet sobre esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tarea de encontrar archivos de audio debe decidirla usted mismo. </font><font style="vertical-align: inherit;">Hay muchos ruidos y explosiones en Internet que puede descargar. </font><font style="vertical-align: inherit;">Si tienes un rumor, entonces puedes intentar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribir tu propia música chiptune</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traducción</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Habré]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, tenga a mano la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guía de programadores de OpenALSoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta documentación es mucho mejor pdf con especialización "oficial". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso, de hecho, es todo. </font><font style="vertical-align: inherit;">Asumiremos que ya sabe cómo escribir código, usar el IDE y la cadena de herramientas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripción general de la API de OpenAL</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dije varias veces, es similar a la API de OpenGL. La similitud radica en el hecho de que se basa en estados e interactúa con descriptores / identificadores, y no con los objetos en sí directamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existen discrepancias entre las convenciones de API en OpenGL y OpenAL, pero no son significativas. En OpenGL, debe realizar llamadas especiales del sistema operativo para generar un contexto de representación. Estos desafíos son diferentes para diferentes sistemas operativos y </font><font style="vertical-align: inherit;">no son </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parte de la especificación OpenGL. En OpenAL, todo es diferente: las funciones de creación de contexto son parte de la especificación y son las mismas independientemente del sistema operativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al interactuar con la API, existen tres tipos principales de objetos con los que interactúa. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oyentes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">("Oyentes") es la ubicación de los "oídos" ubicados en el espacio 3D (siempre hay un solo oyente). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las fuentes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ("fuentes") son "altavoces" que producen sonido, nuevamente en el espacio 3D. </font><font style="vertical-align: inherit;">El oyente y las fuentes se pueden mover en el espacio y, dependiendo de esto, lo que escuchas a través de los altavoces en el juego cambia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los últimos objetos son </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffers</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Almacenan muestras de sonidos que las fuentes reproducirán para los oyentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También hay </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que el juego usa para cambiar la forma en que se procesa el audio a través de OpenAL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuentes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se mencionó anteriormente, estos objetos son fuentes de sonidos. </font><font style="vertical-align: inherit;">Se pueden establecer en posición y dirección, y están asociados con un búfer de datos de audio de reproducción.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oyente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El único conjunto de "orejas" en el juego. </font><font style="vertical-align: inherit;">Lo que escucha el oyente se reproduce a través de los altavoces de la computadora. </font><font style="vertical-align: inherit;">Él también tiene un puesto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En OpenGL, su equivalente es Texture2D. </font><font style="vertical-align: inherit;">En esencia, estos son los datos de audio que reproduce la fuente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para poder soportar código multiplataforma, OpenAL realiza una cierta secuencia de acciones y define algunos tipos de datos. </font><font style="vertical-align: inherit;">De hecho, sigue a OpenGL con tanta precisión que incluso podemos convertir directamente tipos OpenAL a tipos OpenGL. </font><font style="vertical-align: inherit;">La siguiente tabla los enumera a ellos y sus equivalentes.</font></font><br>
<br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo abierto</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo openalc</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo opengl</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Typedef</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripción</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ALboolean</code></td>
<td><code>ALCboolean</code></td>
<td><code>GLboolean</code></td>
<td><code>std::int8_t</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor booleano de 8 bits</font></font></td>
</tr>
<tr>
<td><code>ALbyte</code></td>
<td><code>ALCbyte</code></td>
<td><code>GLbyte</code></td>
<td><code>std::int8_t</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor entero de 8 bits del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código adicional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con un signo</font></font></td>
</tr>
<tr>
<td><code>ALubyte</code></td>
<td><code>ALCubyte</code></td>
<td><code>GLubyte</code></td>
<td><code>std::uint8_t</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor entero sin signo de 8 bits</font></font></td>
</tr>
<tr>
<td><code>ALchar</code></td>
<td><code>ALCchar</code></td>
<td><code>GLchar</code></td>
<td><code>char</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">símbolo</font></font></td>
</tr>
<tr>
<td><code>ALshort</code></td>
<td><code>ALCshort</code></td>
<td><code>GLshort</code></td>
<td><code>std::int16_t</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor entero con signo de 16 bits</font></font></td>
</tr>
<tr>
<td><code>ALushort</code></td>
<td><code>ALCushort</code></td>
<td><code>GLushort</code></td>
<td><code>std::uint16_t</code></td>
<td>16-    </td>
</tr>
<tr>
<td><code>ALint</code></td>
<td><code>ALCint</code></td>
<td><code>GLint</code></td>
<td><code>std::int32_t</code></td>
<td>32-      </td>
</tr>
<tr>
<td><code>ALuint</code></td>
<td><code>ALCuint</code></td>
<td><code>GLuint</code></td>
<td><code>std::uint32_t</code></td>
<td>32-    </td>
</tr>
<tr>
<td><code>ALsizei</code></td>
<td><code>ALCsizei</code></td>
<td><code>GLsizei</code></td>
<td><code>std::int32_t</code></td>
<td> 32-   </td>
</tr>
<tr>
<td><code>ALenum</code></td>
<td><code>ALCenum</code></td>
<td><code>GLenum</code></td>
<td><code>std::uint32_t</code></td>
<td> 32- </td>
</tr>
<tr>
<td><code>ALfloat</code></td>
<td><code>ALCfloat</code></td>
<td><code>GLfloat</code></td>
<td><code>float</code></td>
<td>32-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IEEE 754</a></td>
</tr>
<tr>
<td><code>ALdouble</code></td>
<td><code>ALCdouble</code></td>
<td><code>GLdouble</code></td>
<td><code>double</code></td>
<td>64-     IEEE 754</td>
</tr>
<tr>
<td><code>ALvoid</code></td>
<td><code>ALCvoid</code></td>
<td><code>GLvoid</code></td>
<td><code>void</code></td>
<td> </td>
</tr>
</tbody>
</table></div><br>
<h2>  OpenAL</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un artículo sobre cómo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplificar el reconocimiento de errores de OpenAL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero en aras de la exhaustividad, lo repetiré aquí. Hay dos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de llamadas OpenAL API: regular y contextual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las llamadas de contexto que comienzan </font></font><code>alc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son similares a las llamadas de OpenGL win32 para obtener el contexto de representación o sus contrapartes en Linux. El sonido es lo suficientemente simple para que todos los sistemas operativos tengan las mismas llamadas. Las llamadas ordinarias comienzan con </font></font><code>al</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para obtener errores en las llamadas contextuales, llamamos </font></font><code>alcGetError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; en el caso de llamadas regulares, llamamos </font></font><code>alGetError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Devuelven un valor </font></font><code>ALCenum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o un valor </font></font><code>ALenum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que simplemente enumera posibles errores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora consideraremos un solo caso, pero en todo lo demás son casi lo mismo. </font><font style="vertical-align: inherit;">Tomemos los desafíos habituales </font></font><code>al</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, cree una macro de preprocesador para hacer el aburrido trabajo de pasar detalles:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> alCall(function, ...) alCallImpl(__FILE__, __LINE__, function, __VA_ARGS__)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teóricamente, es posible que su compilador tampoco </font></font><code>__FILE__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sea </font><font style="vertical-align: inherit;">compatible </font></font><code>__LINE__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero, para ser honesto, me sorprendería si así fuera. </font></font><code>__VA_ARGS__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denota un número variable de argumentos que se pueden pasar a esta macro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, implementamos una función que recibe manualmente el último error informado y muestra un valor claro para el flujo de error estándar.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check_al_errors</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint_fast32_t</span> line)</span>
</span>{<font></font>
    ALenum error = alGetError();<font></font>
    <span class="hljs-keyword">if</span>(error != AL_NO_ERROR)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"***ERROR*** ("</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">")\n"</span> ;
        <span class="hljs-keyword">switch</span>(error)<font></font>
        {<font></font>
        <span class="hljs-keyword">case</span> AL_INVALID_NAME:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"AL_INVALID_NAME: a bad name (ID) was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> AL_INVALID_ENUM:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"AL_INVALID_ENUM: an invalid enum value was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> AL_INVALID_VALUE:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"AL_INVALID_VALUE: an invalid value was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> AL_INVALID_OPERATION:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"AL_INVALID_OPERATION: the requested operation is not valid"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> AL_OUT_OF_MEMORY:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"AL_OUT_OF_MEMORY: the requested operation resulted in OpenAL running out of memory"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"UNKNOWN AL ERROR: "</span> &lt;&lt; error;<font></font>
        }<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No hay muchos posibles errores. </font><font style="vertical-align: inherit;">Las explicaciones que escribí en el código son la única información que recibirá sobre estos errores, pero la especificación explica por qué una función en particular puede devolver un error específico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego implementamos dos funciones de plantilla diferentes que envolverán todas nuestras llamadas OpenGL.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> alFunction, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">alCallImpl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, 
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint_fast32_t</span> line, 
                alFunction function, 
                Params... params)</span>
-&gt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;!<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(function(params...))</span>&gt;,<span class="hljs-title">decltype</span><span class="hljs-params">(function(params...))</span>&gt;
</span>{
    <span class="hljs-keyword">auto</span> ret = function(<span class="hljs-built_in">std</span>::forward&lt;Params&gt;(params)...);<font></font>
    check_al_errors(filename,line);<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> alcFunction, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">alcCallImpl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, 
                 <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint_fast32_t</span> line, 
                 alcFunction function, 
                 ALCdevice* device, 
                 Params... params)</span>
-&gt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(function(params...))</span>&gt;,<span class="hljs-keyword">bool</span>&gt;
</span>{<font></font>
    function(<span class="hljs-built_in">std</span>::forward&lt;Params&gt;(params)...);
    <span class="hljs-keyword">return</span> check_alc_errors(filename,line,device);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos de ellos, porque el primero se usa para las funciones OpenAL que regresan </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y el segundo se usa cuando la función devuelve un valor no vacío. </font><font style="vertical-align: inherit;">Si no está muy familiarizado con las plantillas de metaprogramación en C ++, eche un vistazo a las partes del código c </font></font><code>std::enable_if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Determinan cuáles de estas funciones de plantilla implementa el compilador para cada llamada de función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora lo mismo para las llamadas </font></font><code>alc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> alcCall(function, device, ...) alcCallImpl(__FILE__, __LINE__, function, device, __VA_ARGS__)</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check_alc_errors</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint_fast32_t</span> line, ALCdevice* device)</span>
</span>{<font></font>
    ALCenum error = alcGetError(device);<font></font>
    <span class="hljs-keyword">if</span>(error != ALC_NO_ERROR)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"***ERROR*** ("</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">")\n"</span> ;
        <span class="hljs-keyword">switch</span>(error)<font></font>
        {<font></font>
        <span class="hljs-keyword">case</span> ALC_INVALID_VALUE:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ALC_INVALID_VALUE: an invalid value was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> ALC_INVALID_DEVICE:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ALC_INVALID_DEVICE: a bad device was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> ALC_INVALID_CONTEXT:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ALC_INVALID_CONTEXT: a bad context was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> ALC_INVALID_ENUM:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ALC_INVALID_ENUM: an unknown enum value was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> ALC_OUT_OF_MEMORY:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ALC_OUT_OF_MEMORY: an unknown enum value was passed to an OpenAL function"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"UNKNOWN ALC ERROR: "</span> &lt;&lt; error;<font></font>
        }<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> alcFunction, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">alcCallImpl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, 
                 <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint_fast32_t</span> line, 
                 alcFunction function, 
                 ALCdevice* device, 
                 Params... params)</span>
-&gt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(function(params...))</span>&gt;,<span class="hljs-keyword">bool</span>&gt;
</span>{<font></font>
    function(<span class="hljs-built_in">std</span>::forward&lt;Params&gt;(params)...);
    <span class="hljs-keyword">return</span> check_alc_errors(filename,line,device);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> alcFunction, <span class="hljs-keyword">typename</span> ReturnType, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">alcCallImpl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename,
                 <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint_fast32_t</span> line,
                 alcFunction function,
                 ReturnType&amp; returnValue,
                 ALCdevice* device, 
                 Params... params)</span>
-&gt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;!<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(function(params...))</span>&gt;,<span class="hljs-keyword">bool</span>&gt;
</span>{<font></font>
    returnValue = function(<span class="hljs-built_in">std</span>::forward&lt;Params&gt;(params)...);
    <span class="hljs-keyword">return</span> check_alc_errors(filename,line,device);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mayor cambio es la inclusión </font></font><code>device</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que utilizan todas las llamadas </font></font><code>alc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, así como el uso correspondiente de errores de estilo </font></font><code>ALCenum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>ALC_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se ven muy similares, y por un tiempo muy largo desde pequeños cambios </font></font><code>al</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>alc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy dañado mi código y comprensión, así que continué leyendo justo encima de ella </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo. </font><font style="vertical-align: inherit;">Por lo general, una llamada de OpenAL en C ++ parece una de las siguientes opciones:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* example #1 */</span>
alGenSources(<span class="hljs-number">1</span>, &amp;source);<font></font>
ALenum error = alGetError();<font></font>
<span class="hljs-keyword">if</span>(error != AL_NO_ERROR)<font></font>
{<font></font>
    <span class="hljs-comment">/* handle different possibilities */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* example #2 */</span><font></font>
alcCaptureStart(&amp;device);<font></font>
ALCenum error = alcGetError();<font></font>
<span class="hljs-keyword">if</span>(error != ALC_NO_ERROR)<font></font>
{<font></font>
    <span class="hljs-comment">/* handle different possibilities */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* example #3 */</span>
<span class="hljs-keyword">const</span> ALchar* sz = alGetString(param);<font></font>
ALenum error = alGetError();<font></font>
<span class="hljs-keyword">if</span>(error != AL_NO_ERROR)<font></font>
{<font></font>
    <span class="hljs-comment">/* handle different possibilities */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* example #4 */</span>
<span class="hljs-keyword">const</span> ALCchar* sz = alcGetString(&amp;device, param);<font></font>
ALCenum error = alcGetError();<font></font>
<span class="hljs-keyword">if</span>(error != ALC_NO_ERROR)<font></font>
{<font></font>
    <span class="hljs-comment">/* handle different possibilities */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero ahora podemos hacerlo así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* example #1 */</span>
<span class="hljs-keyword">if</span>(!alCall(alGenSources, <span class="hljs-number">1</span>, &amp;source))<font></font>
{<font></font>
    <span class="hljs-comment">/* error occurred */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* example #2 */</span>
<span class="hljs-keyword">if</span>(!alcCall(alcCaptureStart, &amp;device))<font></font>
{<font></font>
    <span class="hljs-comment">/* error occurred */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* example #3 */</span>
<span class="hljs-keyword">const</span> ALchar* sz;
<span class="hljs-keyword">if</span>(!alCall(alGetString, sz, param))<font></font>
{<font></font>
    <span class="hljs-comment">/* error occurred */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* example #4 */</span>
<span class="hljs-keyword">const</span> ALCchar* sz;
<span class="hljs-keyword">if</span>(!alcCall(alcGetString, sz, &amp;device, param))<font></font>
{<font></font>
    <span class="hljs-comment">/* error occurred */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede parecerle extraño, pero es más conveniente para mí. </font><font style="vertical-align: inherit;">Por supuesto, puede elegir una estructura diferente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargar archivos .wav</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede descargarlos usted mismo o usar la biblioteca. </font><font style="vertical-align: inherit;">Aquí hay una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementación de código abierto para cargar archivos .wav</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Estoy loco, así que lo hago yo mismo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> <span class="hljs-title">convert_to_int</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* buffer, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> len)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> a = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::endian::native == <span class="hljs-built_in">std</span>::endian::little)
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">memcpy</span>(&amp;a, buffer, len);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)
            <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(&amp;a)[<span class="hljs-number">3</span> - i] = buffer[i];
    <span class="hljs-keyword">return</span> a;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">load_wav_file_header</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ifstream&amp; file,
                          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>&amp; channels,
                          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span>&amp; sampleRate,
                          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>&amp; bitsPerSample,
                          ALsizei&amp; size)</span>
</span>{
    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">4</span>];
    <span class="hljs-keyword">if</span>(!file.is_open())
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
    <span class="hljs-comment">// the RIFF</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read RIFF"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">"RIFF"</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: file is not a valid WAVE file (header doesn't begin with RIFF)"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// the size of the file</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read size of file"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// the WAVE</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read WAVE"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">"WAVE"</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: file is not a valid WAVE file (header doesn't contain WAVE)"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// "fmt/0"</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read fmt/0"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// this is always 16, the size of the fmt data chunk</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read the 16"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// PCM should be 1?</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">2</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read PCM"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// the number of channels</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">2</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read number of channels"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    channels = convert_to_int(buffer, <span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-comment">// sample rate</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read sample rate"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    sampleRate = convert_to_int(buffer, <span class="hljs-number">4</span>);<font></font>
<font></font>
    <span class="hljs-comment">// (sampleRate * bitsPerSample * channels) / 8</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read (sampleRate * bitsPerSample * channels) / 8"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// ?? dafaq</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">2</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read dafaq"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// bitsPerSample</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">2</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read bits per sample"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    bitsPerSample = convert_to_int(buffer, <span class="hljs-number">2</span>);<font></font>
<font></font>
    <span class="hljs-comment">// data chunk header "data"</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read data chunk header"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">"data"</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: file is not a valid WAVE file (doesn't have 'data' tag)"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// size of data</span>
    <span class="hljs-keyword">if</span>(!file.read(buffer, <span class="hljs-number">4</span>))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: could not read data size"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    size = convert_to_int(buffer, <span class="hljs-number">4</span>);<font></font>
<font></font>
    <span class="hljs-comment">/* cannot be at the end of file */</span>
    <span class="hljs-keyword">if</span>(file.eof())<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: reached EOF on the file"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(file.fail())<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: fail state set on the file"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">load_wav</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename,
               <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>&amp; channels,
               <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span>&amp; sampleRate,
               <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>&amp; bitsPerSample,
               ALsizei&amp; size)</span>
</span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">in</span><span class="hljs-params">(filename, <span class="hljs-built_in">std</span>::ios::binary)</span></span>;
    <span class="hljs-keyword">if</span>(!in.is_open())<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not open \""</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(!load_wav_file_header(in, channels, sampleRate, bitsPerSample, size))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not load wav header of \""</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">char</span>* data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[size];<font></font>
<font></font>
    in.read(data, size);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> data;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No explicaré el código, porque esto no está enteramente en el tema de nuestro artículo; </font><font style="vertical-align: inherit;">pero es muy obvio si lo lee en paralelo con la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificación del archivo WAV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialización y Destrucción</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero necesitamos inicializar OpenAL, y luego, como cualquier buen programador, terminarlo cuando terminemos de trabajar con él. </font><font style="vertical-align: inherit;">Se usa durante la inicialización </font></font><code>ALCdevice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tenga en cuenta que esto </font><i><font style="vertical-align: inherit;">no</font></i></font><code>ALC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">así</font></font></i> <code>AL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), que esencialmente representa algo en su computadora para reproducir música de fondo y lo usa </font></font><code>ALCcontext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>ALCdevice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar a elegir una tarjeta gráfica. </font><font style="vertical-align: inherit;">en el que se renderizará tu juego OpenGL. </font></font><code>ALCcontext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar al contexto de representación que desea crear (exclusivo del sistema operativo) para OpenGL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alcdevice</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un dispositivo OpenAL es a través del cual se emite el sonido, ya sea una tarjeta de sonido o un chip, pero en teoría puede ser muchas cosas diferentes. Al igual que la salida estándar </font></font><code>iostream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede ser una impresora en lugar de una pantalla, un dispositivo puede ser un archivo o incluso una secuencia de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, para la programación de juegos, será un dispositivo de sonido, y generalmente queremos que sea un dispositivo de salida de sonido estándar en el sistema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener una lista de dispositivos disponibles en el sistema, puede solicitarlos con esta función:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get_available_devices</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; devicesVec, ALCdevice* device)</span>
</span>{
    <span class="hljs-keyword">const</span> ALCchar* devices;
    <span class="hljs-keyword">if</span>(!alcCall(alcGetString, devices, device, <span class="hljs-literal">nullptr</span>, ALC_DEVICE_SPECIFIER))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ptr = devices;<font></font>
<font></font>
    devicesVec.clear();<font></font>
<font></font>
    <span class="hljs-keyword">do</span><font></font>
    {<font></font>
        devicesVec.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(ptr));<font></font>
        ptr += devicesVec.back().size() + <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">while</span>(*(ptr + <span class="hljs-number">1</span>) != <span class="hljs-string">'\0'</span>);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad, esto es solo un contenedor alrededor de un contenedor alrededor de una llamada </font></font><code>alcGetString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El valor de retorno es un puntero a una lista de cadenas separadas por un valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y que termina con dos valores </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aquí, el contenedor simplemente lo convierte en un vector conveniente para nosotros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente, ¡no necesitamos hacer esto! En el caso general, como sospecho, la mayoría de los juegos pueden simplemente emitir sonido al dispositivo de forma predeterminada, sea lo que sea. Raramente veo las opciones para cambiar el dispositivo de audio a través del cual desea emitir sonido. Por lo tanto, para inicializar el dispositivo OpenAL, utilizamos una llamada </font></font><code>alcOpenDevice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta llamada es ligeramente diferente de todo lo demás, porque no especifica el estado de error que se puede obtener </font></font><code>alcGetError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">por </font><font style="vertical-align: inherit;">lo que lo llamamos como una función normal:</font></font><br>
<br>
<pre><code class="cpp hljs">ALCdevice* openALDevice = alcOpenDevice(<span class="hljs-literal">nullptr</span>);
<span class="hljs-keyword">if</span>(!openALDevice)<font></font>
{<font></font>
    <span class="hljs-comment">/* fail */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si usted ha enumerado los dispositivos como se muestra arriba, y desea que el usuario seleccione uno de ellos, entonces usted necesita para transferir su nombre al </font></font><code>alcOpenDevice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Envío de </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">órdenes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para abrir el dispositivo por defecto</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El valor de retorno es el dispositivo correspondiente o </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se produce un error. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dependiendo de si ha completado la enumeración o no, un error puede detener el programa en las pistas. Sin dispositivo = Sin OpenAL; sin OpenAL = sin sonido; sin sonido = sin juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo último que hacemos al cerrar un programa es terminarlo correctamente.</font></font><br>
<br>
<pre><code class="cpp hljs">ALCboolean closed;
<span class="hljs-keyword">if</span>(!alcCall(alcCloseDevice, closed, openALDevice, openALDevice))<font></font>
{<font></font>
    <span class="hljs-comment">/* do we care? */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta etapa, si la finalización no fue posible, entonces esto ya no es importante para nosotros. Antes de cerrar el dispositivo, debemos cerrar todos los contextos creados, sin embargo, en mi experiencia, esta llamada también completa el contexto. Pero lo haremos bien. Si completa todo antes de hacer una llamada </font></font><code>alcCloseDevice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces no debe haber errores, y si por alguna razón han surgido, entonces no puede hacer nada al respecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es posible que haya notado que las llamadas de </font></font><code>alcCall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">envían dos copias del dispositivo. Sucedió debido a cómo funciona la función de plantilla: una es necesaria para la verificación de errores y la segunda se usa como parámetro de función.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teóricamente, puedo mejorar la función de la plantilla para que pase el primer parámetro para la verificación de errores y aún así la envíe a la función; </font><font style="vertical-align: inherit;">pero soy flojo para hacerlo. </font><font style="vertical-align: inherit;">Dejaré esto como tu tarea.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro contexto ALC</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda parte de la inicialización es el contexto. </font><font style="vertical-align: inherit;">Como antes, es similar al contexto de representación de OpenGL. </font><font style="vertical-align: inherit;">Puede haber varios contextos en un programa y podemos cambiar entre ellos, pero no lo necesitaremos. </font><font style="vertical-align: inherit;">Cada contexto tiene su propio </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oyente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuentes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y no se pueden pasar entre contextos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quizás esto sea útil en el software de procesamiento de sonido. </font><font style="vertical-align: inherit;">Sin embargo, para los juegos en el 99.9% de los casos, solo un contexto es suficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crear un nuevo contexto es muy simple:</font></font><br>
<br>
<pre><code class="cpp hljs">ALCcontext* openALContext;
<span class="hljs-keyword">if</span>(!alcCall(alcCreateContext, openALContext, openALDevice, openALDevice, <span class="hljs-literal">nullptr</span>) || !openALContext)<font></font>
{<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not create audio context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">/* probably exit program */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitamos comunicarnos para lo </font></font><code>ALCdevice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que queremos crear un contexto; </font><font style="vertical-align: inherit;">También podemos pasar una lista opcional de claves y valores de finalización cero </font></font><code>ALCint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que son atributos con los que se debe crear el contexto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honestamente, ni siquiera sé en qué situación es útil pasar el atributo. </font><font style="vertical-align: inherit;">Tu juego se ejecutará en una computadora normal con las características de sonido habituales. </font><font style="vertical-align: inherit;">Los atributos tienen valores predeterminados, según la computadora, por lo que esto no es particularmente importante. </font><font style="vertical-align: inherit;">Pero en caso de que aún lo necesite:</font></font><br>
<br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombre del Atributo</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripción</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ALC_FREQUENCY</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frecuencia de mezcla al búfer de salida, medido en Hz</font></font></td>
</tr>
<tr>
<td><code>ALC_REFRESH</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intervalos de actualización, medidos en Hz</font></font></td>
</tr>
<tr>
<td><code>ALC_SYNC</code></td>
<td><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicar si debe ser un contexto síncrono o asíncrono</font></font></td>
</tr>
<tr>
<td><code>ALC_MONO_SOURCES</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un valor que le ayuda a saber cuántas fuentes utilizará que requieren la capacidad de procesar datos de audio monoaural. </font><font style="vertical-align: inherit;">No limita la cantidad máxima, solo le permite ser más efectivo cuando lo sabe de antemano.</font></font></td>
</tr>
<tr>
<td><code>ALC_STEREO_SOURCES</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo mismo, pero para datos estéreo.</font></font></td>
</tr>
</tbody>
</table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si obtiene errores, lo más probable es que esto se deba a que los atributos que desea son imposibles o no puede crear otro contexto para el dispositivo compatible; </font><font style="vertical-align: inherit;">Esto dará como resultado un error </font></font><code>ALC_INVALID_VALUE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si pasa un dispositivo no válido, recibirá un error </font></font><code>ALC_INVALID_DEVICE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero, por supuesto, ya estamos verificando este error. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crear contexto no es suficiente. </font><font style="vertical-align: inherit;">Todavía tenemos que actualizarlo: parece un contexto de representación de Windows OpenGL, ¿verdad? </font><font style="vertical-align: inherit;">Es lo mismo.</font></font><br>
<br>
<pre><code class="cpp hljs">ALCboolean contextMadeCurrent = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">if</span>(!alcCall(alcMakeContextCurrent, contextMadeCurrent, openALDevice, openALContext)<font></font>
   || contextMadeCurrent != ALC_TRUE)<font></font>
{<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not make audio context current"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">/* probably exit or give up on having sound */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es necesario actualizar el contexto para cualquier otra operación con el contexto (o con fuentes y oyentes en él). </font><font style="vertical-align: inherit;">La operación volverá </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el único valor de error posible transmitido </font></font><code>alcGetError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el </font></font><code>ALC_INVALID_CONTEXT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que está claro del nombre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acabado con contexto, es decir </font><font style="vertical-align: inherit;">al salir del programa, es necesario que el contexto ya no sea actual y luego destruirlo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(!alcCall(alcMakeContextCurrent, contextMadeCurrent, openALDevice, <span class="hljs-literal">nullptr</span>))<font></font>
{<font></font>
    <span class="hljs-comment">/* what can you do? */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span>(!alcCall(alcDestroyContext, openALDevice, openALContext))<font></font>
{<font></font>
    <span class="hljs-comment">/* not much you can do */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El único error posible de </font></font><code>alcDestroyContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el mismo que el de </font></font><code>alcMakeContextCurrent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>ALC_INVALID_CONTEXT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">si haces todo bien, entonces no lo conseguirás, pero si lo haces, entonces no se puede hacer nada al respecto.</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué buscar errores con los que no se puede hacer nada? </font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porque quiero que los mensajes sobre ellos aparezcan al menos en el flujo de errores, lo cual para nosotros sí. </font></font><code>alcCall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos que nunca nos da errores, pero será útil saber que tal error ocurre en la computadora de otra persona. </font><font style="vertical-align: inherit;">Gracias a esto, podemos estudiar el problema y posiblemente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informar un error a los desarrolladores de OpenAL Soft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toca nuestro primer sonido</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, suficiente de todo esto, toquemos el sonido. </font><font style="vertical-align: inherit;">Para empezar, obviamente necesitamos un archivo de sonido. </font><font style="vertical-align: inherit;">Por ejemplo, este, de un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juego que terminaré</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://indiegamedev.net/wp-content/uploads/2020/02/iamtheprotectorofthissystem.wav</font></font></a></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Soy el protector de este sistema!</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Entonces, abra el IDE y use el siguiente código. Recuerde conectar OpenAL Soft y agregar el código de carga del archivo y el código de comprobación de errores que se muestra arriba.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    ALCdevice* openALDevice = alcOpenDevice(<span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">if</span>(!openALDevice)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
    ALCcontext* openALContext;<font></font>
    <span class="hljs-keyword">if</span>(!alcCall(alcCreateContext, openALContext, openALDevice, openALDevice, <span class="hljs-literal">nullptr</span>) || !openALContext)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not create audio context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    ALCboolean contextMadeCurrent = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span>(!alcCall(alcMakeContextCurrent, contextMadeCurrent, openALDevice, openALContext)<font></font>
       || contextMadeCurrent != ALC_TRUE)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not make audio context current"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span> channels;
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> sampleRate;
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span> bitsPerSample;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; soundData;
    <span class="hljs-keyword">if</span>(!load_wav(<span class="hljs-string">"iamtheprotectorofthissystem.wav"</span>, channels, sampleRate, bitsPerSample, soundData))<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not load wav"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    ALuint buffer;<font></font>
    alCall(alGenBuffers, <span class="hljs-number">1</span>, &amp;buffer);<font></font>
<font></font>
    ALenum format;<font></font>
    <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">1</span> &amp;&amp; bitsPerSample == <span class="hljs-number">8</span>)<font></font>
        format = AL_FORMAT_MONO8;<font></font>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">1</span> &amp;&amp; bitsPerSample == <span class="hljs-number">16</span>)<font></font>
        format = AL_FORMAT_MONO16;<font></font>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">2</span> &amp;&amp; bitsPerSample == <span class="hljs-number">8</span>)<font></font>
        format = AL_FORMAT_STEREO8;<font></font>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">2</span> &amp;&amp; bitsPerSample == <span class="hljs-number">16</span>)<font></font>
        format = AL_FORMAT_STEREO16;<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>
            &lt;&lt; <span class="hljs-string">"ERROR: unrecognised wave format: "</span>
            &lt;&lt; channels &lt;&lt; <span class="hljs-string">" channels, "</span>
            &lt;&lt; bitsPerSample &lt;&lt; <span class="hljs-string">" bps"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    alCall(alBufferData, buffer, format, soundData.data(), soundData.size(), sampleRate);<font></font>
    soundData.clear(); <span class="hljs-comment">// erase the sound in RAM</span><font></font>
<font></font>
    ALuint source;<font></font>
    alCall(alGenSources, <span class="hljs-number">1</span>, &amp;source);<font></font>
    alCall(alSourcef, source, AL_PITCH, <span class="hljs-number">1</span>);<font></font>
    alCall(alSourcef, source, AL_GAIN, <span class="hljs-number">1.0f</span>);<font></font>
    alCall(alSource3f, source, AL_POSITION, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
    alCall(alSource3f, source, AL_VELOCITY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
    alCall(alSourcei, source, AL_LOOPING, AL_FALSE);<font></font>
    alCall(alSourcei, source, AL_BUFFER, buffer);<font></font>
<font></font>
    alCall(alSourcePlay, source);<font></font>
<font></font>
    ALint state = AL_PLAYING;<font></font>
<font></font>
    <span class="hljs-keyword">while</span>(state == AL_PLAYING)<font></font>
    {<font></font>
        alCall(alGetSourcei, source, AL_SOURCE_STATE, &amp;state);<font></font>
    }<font></font>
<font></font>
    alCall(alDeleteSources, <span class="hljs-number">1</span>, &amp;source);<font></font>
    alCall(alDeleteBuffers, <span class="hljs-number">1</span>, &amp;buffer);<font></font>
<font></font>
    alcCall(alcMakeContextCurrent, contextMadeCurrent, openALDevice, <span class="hljs-literal">nullptr</span>);<font></font>
    alcCall(alcDestroyContext, openALDevice, openALContext);<font></font>
<font></font>
    ALCboolean closed;<font></font>
    alcCall(alcCloseDevice, closed, openALDevice, openALDevice);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compilando! </font><font style="vertical-align: inherit;">Nosotros componimos! </font><font style="vertical-align: inherit;">¡Lanzamiento! </font></font><em><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soy el prrrootector de este sistema</font></font></strong></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si no escucha el sonido, verifique todo nuevamente. </font><font style="vertical-align: inherit;">Si algo está escrito en la ventana de la consola, esta debería ser la salida estándar de la secuencia de error, y es importante. </font><font style="vertical-align: inherit;">Nuestras funciones de informe de errores deberían indicarnos la línea de código fuente que generó el error. </font><font style="vertical-align: inherit;">Si encuentra un </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
error, lea la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guía</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">programador</font></a><font style="vertical-align: inherit;"> y la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para comprender las condiciones bajo las cuales este error puede ser generado por una función. </font><font style="vertical-align: inherit;">Esto te ayudará a resolverlo. </font><font style="vertical-align: inherit;">Si no tiene éxito, deje un comentario debajo del artículo original y trataré de ayudarlo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargar datos RIFF WAVE</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span> channels;
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> sampleRate;
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span> bitsPerSample;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; soundData;
<span class="hljs-keyword">if</span>(!load_wav(<span class="hljs-string">"iamtheprotectorofthissystem.wav"</span>, channels, sampleRate, bitsPerSample, soundData))<font></font>
{<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"ERROR: Could not load wav"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se refiere al código de arranque de onda. </font><font style="vertical-align: inherit;">Lo importante es que recibamos datos, ya sea como puntero, o recopilados en un vector: el número de canales, la frecuencia de muestreo y el número de bits por muestra.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generación de buffer</font></font></h3><br>
<pre><code class="cpp hljs">ALuint buffer;<font></font>
alCall(alGenBuffers, <span class="hljs-number">1</span>, &amp;buffer);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente le resulte familiar si alguna vez generó buffers de datos de textura en OpenGL. En esencia, generamos un búfer y pretendemos que solo existirá en la tarjeta de sonido. De hecho, lo más probable es que se almacene en la RAM ordinaria, pero la especificación OpenAL resume todas estas operaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, el valor </font></font><code>ALuint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identificador de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nuestro búfer. Recuerde que el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">búfer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es esencialmente información de sonido en la memoria de la tarjeta de sonido. Ya no tenemos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceso directo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a estos datos, ya que los tomamos del programa (de la RAM normal) y los trasladamos a una tarjeta de sonido / chip, etc. OpenGL funciona de manera similar, moviendo datos de textura de RAM a VRAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descriptor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genera </font></font><code>alGenBuffers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tiene un par de posibles valores de error, el más importante de los cuales es </font></font><code>AL_OUT_OF_MEMORY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que significa que ya no podemos agregar datos de sonido a la tarjeta de sonido. </font><font style="vertical-align: inherit;">No obtendrá </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> error si, por ejemplo, utiliza un único búfer, pero debe tenerlo en cuenta si está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creando un motor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinar el formato de los datos de audio.</font></font></h3><br>
<pre><code class="cpp hljs">ALenum format;<font></font>
<font></font>
<span class="hljs-keyword">if</span>(channels == <span class="hljs-number">1</span> &amp;&amp; bitsPerSample == <span class="hljs-number">8</span>)<font></font>
    format = AL_FORMAT_MONO8;<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">1</span> &amp;&amp; bitsPerSample == <span class="hljs-number">16</span>)<font></font>
    format = AL_FORMAT_MONO16;<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">2</span> &amp;&amp; bitsPerSample == <span class="hljs-number">8</span>)<font></font>
    format = AL_FORMAT_STEREO8;<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(channels == <span class="hljs-number">2</span> &amp;&amp; bitsPerSample == <span class="hljs-number">16</span>)<font></font>
    format = AL_FORMAT_STEREO16;<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>
        &lt;&lt; <span class="hljs-string">"ERROR: unrecognised wave format: "</span>
        &lt;&lt; channels &lt;&lt; <span class="hljs-string">" channels, "</span>
        &lt;&lt; bitsPerSample &lt;&lt; <span class="hljs-string">" bps"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los datos de sonido funcionan así: hay varios </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canales</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y hay un tamaño de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit por muestra</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Los datos consisten en muchas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestras</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para determinar el número de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestras</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en los datos de audio, hacemos lo siguiente:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">int_fast32_t</span> numberOfSamples = dataSize / (numberOfChannels * (bitsPerSample / <span class="hljs-number">8</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que se puede convertir convenientemente para calcular la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duración de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> los datos </font><em><font style="vertical-align: inherit;">de</font></em><font style="vertical-align: inherit;"> audio:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> duration = numberOfSamples / sampleRate;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero si bien no necesitamos saberlo </font></font><code>numberOfSamples</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ni tampoco </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sin embargo, es importante saber cómo se utilizan todos estos datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volver a </font></font><code>format</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- necesitamos decirle a OpenAL el formato de datos de audio. Eso parece obvio, ¿verdad? De manera similar a cómo llenamos el búfer de textura OpenGL, diciendo que los datos están en una secuencia BGRA y están compuestos de valores de 8 bits, necesitamos hacer lo mismo en OpenAL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para decirle a OpenAL cómo interpretar los datos señalados por el puntero que pasaremos más adelante, necesitamos definir el formato de datos. Bajo el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formato</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se entiende como lo entiende OpenAL. Solo hay cuatro significados posibles. Hay dos valores posibles para el número de canales: uno para mono, dos para estéreo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además del número de canales, tenemos el número de bits por muestra. </font><font style="vertical-align: inherit;">Es igual a o </font></font><code>8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o </font></font><code>16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y es esencialmente calidad de sonido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, utilizando los valores de los canales y bits por muestra, sobre los cuales la función de carga de onda nos ha informado, podemos determinar cuál </font></font><code>ALenum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar para el parámetro futuro </font></font><code>format</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampón de llenado</font></font></h3><br>
<pre><code class="cpp hljs">alCall(alBufferData, buffer, format, soundData.data(), soundData.size(), sampleRate);<font></font>
soundData.clear(); <span class="hljs-comment">// erase the sound in RAM</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con esto, todo debería ser simple. </font><font style="vertical-align: inherit;">Cargamos en el OpenAL Buffer, al que apunta el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descriptor</font></font></em> <code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">los datos apuntados por ptr </font></font><code>soundData.data()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el tamaño del </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificado </font></font><code>sampleRate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">También informaremos a OpenAL el formato de estos datos a través del parámetro </font></font><code>format</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, simplemente eliminamos los datos que recibió el cargador de ondas. </font><font style="vertical-align: inherit;">¿Por qué? </font><font style="vertical-align: inherit;">Porque ya los hemos copiado en la tarjeta de sonido. </font><font style="vertical-align: inherit;">No necesitamos almacenarlos en dos lugares y gastar recursos preciosos. </font><font style="vertical-align: inherit;">Si la tarjeta de sonido pierde datos, simplemente la volveremos a descargar del disco y no necesitaremos copiarla a la CPU ni a otra persona.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuración de la fuente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde que OpenAL es esencialmente un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oyente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que escucha los sonidos hechos por una o más </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuentes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bueno, ahora es el momento de crear una fuente de sonido.</font></font><br>
<br>
<pre><code class="cpp hljs">ALuint source;<font></font>
alCall(alGenSources, <span class="hljs-number">1</span>, &amp;source);<font></font>
alCall(alSourcef, source, AL_PITCH, <span class="hljs-number">1</span>);<font></font>
alCall(alSourcef, source, AL_GAIN, <span class="hljs-number">1.0f</span>);<font></font>
alCall(alSource3f, source, AL_POSITION, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
alCall(alSource3f, source, AL_VELOCITY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
alCall(alSourcei, source, AL_LOOPING, AL_FALSE);<font></font>
alCall(alSourcei, source, AL_BUFFER, buffer);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honestamente, no es necesario establecer algunos de estos parámetros, porque los valores predeterminados son bastante adecuados para nosotros. Pero esto nos muestra algunos aspectos con los que puede experimentar y ver qué hacen (incluso puede actuar con astucia y cambiarlos con el tiempo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero generamos fuente: recuerde, esto es nuevamente un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identificador</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de algo dentro de la API de OpenAL. Configuramos el tono (tono) para que no cambie, la ganancia (volumen) se iguala al valor original de los datos de audio, la posición y la velocidad se restablecen; que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hacemos rizar el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sonido, porque de lo contrario el programa no tendrá fin, e indicar el búfer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde que diferentes fuentes pueden usar el mismo búfer. </font><font style="vertical-align: inherit;">Por ejemplo, los enemigos que disparan a un jugador desde diferentes lugares pueden reproducir el mismo sonido de disparo, por lo que no necesitamos muchas copias de los datos de sonido, sino solo unos pocos lugares en el espacio 3D desde donde se produce el sonido.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reproducir sonido</font></font></h3><br>
<pre><code class="cpp hljs">alCall(alSourcePlay, source);<font></font>
<font></font>
ALint state = AL_PLAYING;<font></font>
<font></font>
<span class="hljs-keyword">while</span>(state == AL_PLAYING)<font></font>
{<font></font>
    alCall(alGetSourcei, source, AL_SOURCE_STATE, &amp;state);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero tenemos que empezar a jugar fuente. </font><font style="vertical-align: inherit;">Simplemente llama </font></font><code>alSourcePlay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego creamos un valor para almacenar el estado actual de la </font></font><code>AL_SOURCE_STATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuente y actualizarlo sin cesar. </font><font style="vertical-align: inherit;">Cuando ya no es igual, </font></font><code>AL_PLAYING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos continuar. </font><font style="vertical-align: inherit;">Puede cambiar el estado a </font></font><code>AL_STOPPED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando termine de emitir sonido desde el búfer (o cuando ocurra un error). </font><font style="vertical-align: inherit;">Si establece el valor de bucle </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el sonido se reproducirá para siempre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego podemos cambiar el búfer de origen y reproducir otro sonido. </font><font style="vertical-align: inherit;">O reproduce el mismo sonido, etc. </font><font style="vertical-align: inherit;">Simplemente configure el búfer, úselo </font></font><code>alSourcePlay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y tal vez </font></font><code>alSourceStop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si es necesario. </font><font style="vertical-align: inherit;">En los siguientes artículos consideraremos esto con más detalle.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limpieza</font></font></h3><br>
<pre><code class="cpp hljs">alCall(alDeleteSources, <span class="hljs-number">1</span>, &amp;source);<font></font>
alCall(alDeleteBuffers, <span class="hljs-number">1</span>, &amp;buffer);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como simplemente reproducimos los datos de audio una vez y salimos, eliminaremos la fuente y el búfer creados previamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resto del código es comprensible sin explicación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿A dónde ir después?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Sabiendo todo lo descrito en este artículo, ya puedes crear un pequeño juego! </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intenta crear Pong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algún otro juego clásico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , para ellos no se requiere más. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Pero recuerda! </font><font style="vertical-align: inherit;">Estos buffers solo son adecuados para sonidos cortos, muy probablemente por unos segundos. </font><font style="vertical-align: inherit;">Si necesita música o actuación de voz, deberá transmitir audio a OpenAL. </font><font style="vertical-align: inherit;">Hablaremos de esto en una de las siguientes partes de una serie de tutoriales.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488730/index.html">Nuevos estándares rusos para Internet de las cosas, fabricación inteligente y ciudad inteligente</a></li>
<li><a href="../es488732/index.html">Talentoso Sr. Simon: cómo las habilidades únicas y la impresión 3D pueden cambiar el proceso de producción</a></li>
<li><a href="../es488736/index.html">El trabajo remoto está ganando impulso</a></li>
<li><a href="../es488740/index.html">Guía de etiquetas HTML personalizadas para Google Tag Manager por Simo Ahava</a></li>
<li><a href="../es488742/index.html">¿Ves la arquitectura? Y no veo, pero ella es</a></li>
<li><a href="../es488748/index.html">Crea una aplicación Todo con Django. Parte 1</a></li>
<li><a href="../es488750/index.html">Dinosaur Walk: dos grandes computadoras del siglo XX</a></li>
<li><a href="../es488752/index.html">Golang + Phaser3 = MMORPG - Hacemos la base para la generación interminable del mundo</a></li>
<li><a href="../es488754/index.html">Todo a la vez: comprobación automática del tamaño del paquete</a></li>
<li><a href="../es488756/index.html">Cómo trabajar con la API de Hojas de cálculo de Google (API de Hojas de cálculo de Google v4) en R usando el nuevo paquete de Google Googlesheets4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>