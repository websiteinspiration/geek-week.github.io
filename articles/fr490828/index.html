<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕉️ 🛋️ 🤶🏼 Créer roguelike dans Unity à partir de zéro 🎑 ♌️ 💂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il n'y a pas beaucoup de tutoriels sur la création de roguelike dans Unity, j'ai donc décidé de l'écrire. Non pas pour me vanter, mais pour partager d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Créer roguelike dans Unity à partir de zéro</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490828/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/093/6ab/ad40936ab0dff25fd3214571faf9aa61.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a pas beaucoup de tutoriels sur la création de roguelike dans Unity, j'ai donc décidé de l'écrire. Non pas pour me vanter, mais pour partager des connaissances avec ceux qui en sont au stade où j'étais déjà assez longtemps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: je ne dis pas que c'est la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seule</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> façon de créer un roguelike dans Unity. Il est juste l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Probablement pas le meilleur et le plus efficace, j'ai appris par essais et erreurs. Et j'apprendrai certaines choses dans le processus de création d'un tutoriel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que vous </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connaissiez au moins les bases de Unity</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple, comment créer un préfabriqué ou un script, etc. </font><font style="vertical-align: inherit;">Ne vous attendez pas à ce que je vous apprenne à créer des feuilles de sprites, il existe de nombreux tutoriels à ce sujet. </font><font style="vertical-align: inherit;">Je ne me concentrerai pas sur l'étude du moteur, mais sur la façon de mettre en œuvre le jeu que nous allons créer ensemble. </font><font style="vertical-align: inherit;">Si vous rencontrez des difficultés, rendez-vous dans l'une des superbes communautés de Discord et demandez de l'aide: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Developer Community </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roguelikes</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alors, commençons!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 0 - planification</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui c'est vrai. La première chose à créer est un plan. Ce sera bien pour vous de planifier le jeu, et pour moi - de planifier le tutoriel afin qu'après un certain temps nous ne soyons pas distraits du sujet. Il est facile de se perdre dans les fonctions du jeu, tout comme dans les donjons roguelike. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous écrirons roguelike. Nous suivrons principalement les sages conseils du développeur de Cogmind Josh Ge </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Suivez le lien, lisez l'article ou regardez la vidéo, puis revenez.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quel est le but de ce tutoriel? Obtenez un solide roguelike de base simple, avec lequel vous pourrez ensuite expérimenter. Il devrait avoir une génération de donjon, un joueur se déplaçant sur la carte, un brouillard de visibilité, des ennemis et des objets. Seuls les plus nécessaires. Ainsi, le joueur devrait pouvoir descendre les escaliers sur plusieurs étages. disons, par cinq, augmentez votre niveau, améliorez et, à la fin, combattez le boss et battez-le. Ou mourir. En fait, c'est tout.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suivant les conseils de Josh Ge, nous allons construire les fonctions du jeu pour qu'elles nous conduisent au but. </font><font style="vertical-align: inherit;">Nous obtenons donc le cadre roguelike, qui peut être encore étendu, ajoutez vos propres puces, créant un caractère unique. </font><font style="vertical-align: inherit;">Ou jetez tout dans le panier, profitez de l'expérience acquise et recommencez à zéro. </font><font style="vertical-align: inherit;">Ce sera génial de toute façon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne vous donnerai aucune ressource graphique. </font><font style="vertical-align: inherit;">Dessinez-les vous-même ou utilisez les ensembles de tuiles gratuits, qui peuvent être téléchargés </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou en effectuant une recherche dans Google. </font><font style="vertical-align: inherit;">N'oubliez pas de mentionner les auteurs des graphismes du jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, listons toutes les fonctions qui seront dans notre roguelike dans l'ordre de leur implémentation:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Génération de carte de donjon</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le personnage du joueur et son mouvement</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zone de visibilité</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ennemis</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechercher un moyen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combat, santé et mort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niveau supérieur du joueur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objets (armes et potions)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheats de la console (pour les tests)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planchers de donjon</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sauvegarde et chargement</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boss final</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir implémenté tout cela, nous aurons un solide roguelike et vous améliorerez considérablement vos compétences en développement de jeux. </font><font style="vertical-align: inherit;">En fait, c'était </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ma</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> façon d'améliorer </font><em><font style="vertical-align: inherit;">mes</font></em><font style="vertical-align: inherit;"> compétences: créer du code et implémenter des fonctions. </font><font style="vertical-align: inherit;">Par conséquent, je suis sûr que vous pouvez également gérer cela.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 1 - Classe MapManager</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est le premier script que nous allons créer et il deviendra l'épine dorsale de notre jeu. </font><font style="vertical-align: inherit;">C'est simple, mais contient la majeure partie des informations importantes pour le jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, créez un script .cs appelé MapManager et ouvrez-le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supprimez ": MonoBehaviour" car il n'en héritera pas et ne sera attaché à aucun GameObject. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supprimez les fonctions Démarrer () et Mettre à jour (). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la fin de la classe MapManager, créez une nouvelle classe publique appelée Tile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/54e/4c2/43154e4c2708a580bc3838b1fbee573b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe Tile contiendra toutes les informations d'une seule tuile. </font><font style="vertical-align: inherit;">Jusqu'à présent, nous n'avons pas besoin de beaucoup, seulement des positions x et y, ainsi qu'un objet de jeu situé à cette position de la carte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/405/21e/cd9/40521ecd9e1292e813391181e523b6dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc des informations de base sur les tuiles. </font><font style="vertical-align: inherit;">Créons une carte à partir de cette tuile. </font><font style="vertical-align: inherit;">C'est simple, nous n'avons besoin que d'un tableau bidimensionnel d'objets Tile. </font><font style="vertical-align: inherit;">Cela semble compliqué, mais il n'y a rien de spécial à ce sujet. </font><font style="vertical-align: inherit;">Ajoutez simplement la variable Tile [,] à la classe MapManager:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/2e8/806/f442e88061e77cbbb4c1aa904c73bdfd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">Nous avons une carte! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, c'est vide. </font><font style="vertical-align: inherit;">Mais ceci est une carte. </font><font style="vertical-align: inherit;">Chaque fois que quelque chose bouge ou change d'état sur la carte, les informations sur cette carte sont mises à jour. </font><font style="vertical-align: inherit;">Autrement dit, si, par exemple, un joueur essaie de passer à une nouvelle tuile, la classe vérifiera l'adresse de la tuile de destination sur la carte, la présence de l'ennemi et sa perméabilité. </font><font style="vertical-align: inherit;">Grâce à cela, nous n'avons pas à vérifier des milliers de collisions à chaque tour, et nous n'avons pas besoin de collisionneurs pour chaque objet de jeu, ce qui facilitera et simplifiera le travail avec le jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code résultant ressemble à ceci:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapManager</span> <font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tile[,] map; <span class="hljs-comment">// the 2-dimensional map with the information for all the tiles</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tile</span> { <span class="hljs-comment">//Holds all the information for each tile on the map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> xPosition; <span class="hljs-comment">// the position on the x axis</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yPosition; <span class="hljs-comment">// the position on the y axis</span>
    <span class="hljs-keyword">public</span> GameObject baseObject; <span class="hljs-comment">// the map game object attached to that position: a floor, a wall, etc.</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première étape est terminée, passons au remplissage de la carte. </font><font style="vertical-align: inherit;">Nous allons maintenant commencer à créer un générateur de donjon.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 2 - quelques mots sur la structure des données</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant de commencer, permettez-moi de partager les conseils qui ont surgi grâce aux commentaires reçus après la publication de la première partie. Lors de la création d'une structure de données, vous devez penser dès le début à la manière dont vous maintiendrez l'état du jeu. Sinon, plus tard, ce sera beaucoup plus chaotique. L'utilisateur de Discord st33d, le développeur de Star Shaped Bagel (vous pouvez jouer à ce jeu gratuitement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), a déclaré qu'au début, il avait créé le jeu, pensant que cela ne sauverait pas du tout les États. Peu à peu, le jeu a commencé à s'agrandir, et son fan a demandé un soutien pour la carte enregistrée. Mais en raison de la méthode choisie pour créer la structure de données, il était très difficile de sauvegarder les données, il n'a donc pas pu le faire.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/b02/858/82cb02858af686ef409ad8a6c0496135.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous apprenons vraiment de nos erreurs. Malgré le fait que je mette la partie sauvegarde / chargement à la fin du tutoriel, je pense à travers eux depuis le tout début, et je ne les ai pas encore expliqués. Dans cette partie, je vais en parler un peu, mais pour ne pas surcharger les développeurs inexpérimentés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons enregistrer des choses comme un tableau de variables de la classe Tile dans laquelle la carte est stockée. Nous enregistrerons toutes ces données, à l'exception des variables de la classe GameObject, qui se trouvent à l'intérieur de la classe Tile. Pourquoi? Tout simplement parce que GameObjects ne peut pas être sérialisé avec Unity en données stockées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, en fait, nous n'avons pas besoin de sauvegarder les données stockées dans GameObjects. Toutes les données seront stockées dans des classes telles que Tile, et plus tard également Player, Enemy, etc. Ensuite, nous aurons GameObjects pour simplifier le calcul de choses telles que la visibilité et le mouvement, ainsi que le dessin de sprites sur l'écran. Par conséquent, dans les classes, il y aura des variables GameObject, mais la valeur de ces variables ne sera pas enregistrée et chargée. Lors du chargement, nous forcerons à générer à nouveau GameObject à partir des données enregistrées (position, sprite, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, que devons-nous faire maintenant? Eh bien, ajoutez simplement deux lignes à la classe Tile existante et une en haut du script. Nous ajoutons d'abord «using System;» au titre du script, puis [Serializable] devant toute la classe et [NonSerialized] juste devant la variable GameObject. Comme ça:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfd/931/aa3/bfd931aa3a4a1b2b7792650cc25cba07.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2e/178/9d3/a2e1789d3663b1530d64d3d900c7f047.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vous en dirai plus à ce sujet lorsque nous arriverons à la partie du didacticiel sur l'enregistrement / le chargement. </font><font style="vertical-align: inherit;">Pour l'instant, laissons tout et continuons.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 3 - un peu plus sur la structure des données</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai obtenu un autre examen de la structure des données que je souhaite partager ici.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, il existe de nombreuses façons d'implémenter des données dans un jeu. La première que j'utilise et qui sera implémentée dans ce tutoriel: toutes les données de tuile sont dans la classe Tile, et toutes sont stockées dans un tableau. Cette approche présente de nombreux avantages: elle est plus facile à lire, tout ce dont vous avez besoin est au même endroit, les données sont plus faciles à manipuler et à exporter vers un fichier de sauvegarde. Mais du point de vue de la mémoire, ce n'est pas si efficace. Vous devrez allouer beaucoup de mémoire aux variables qui ne seront jamais utilisées dans le jeu. Par exemple, plus tard, nous mettrons la variable Enemy GameObject dans la classe Tile afin de pouvoir pointer directement de la carte vers le GameObject de l'ennemi se tenant sur cette tuile afin de simplifier tous les calculs liés à la bataille. Mais cela signifie que chaque tuile du jeu disposera d'un espace en mémoire pour la variable GameObject,même s'il n'y a pas d'ennemi sur cette tuile. S'il y a 10 ennemis sur une carte de 2500 tuiles, alors il y aura 2490 variables GameObject vides mais allouées - vous pouvez voir combien de mémoire est gaspillée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre méthode consisterait à utiliser des structures pour stocker les données de base des tuiles (par exemple, la position et le type), et toutes les autres données seraient stockées dans hashmap-s, qui ne seraient générées que si nécessaire. </font><font style="vertical-align: inherit;">Cela économiserait beaucoup de mémoire, mais le retour sur investissement serait une implémentation légèrement plus compliquée. </font><font style="vertical-align: inherit;">En fait, ce serait un peu plus avancé que je ne le souhaiterais dans ce tutoriel, mais si vous le souhaitez, à l'avenir, je pourrai écrire un article plus détaillé à ce sujet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, si vous souhaitez lire une discussion sur ce sujet, cela peut être fait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur Reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 4 - Algorithme de génération de donjon</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, c'est une autre section dans laquelle je parlerai et nous ne commencerons rien à programmer. Mais cela est important, une planification minutieuse des algorithmes nous permettra d'économiser beaucoup de temps de travail à l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe plusieurs façons de créer un générateur de donjon. Celui que nous allons mettre en œuvre ensemble n'est pas le meilleur ni le plus efficace ... c'est juste une manière simple et initiale. C'est très simple, mais les résultats seront assez bons. Le problème principal sera de nombreux couloirs sans issue. Plus tard, si vous le souhaitez, je pourrai publier un autre tutoriel sur de meilleurs algorithmes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, l'algorithme que nous utilisons fonctionne comme suit: disons que nous avons une carte entière remplie de valeurs nulles - un niveau composé d'une pierre. </font><font style="vertical-align: inherit;">Au début, nous avons découpé une pièce au centre. </font><font style="vertical-align: inherit;">De cette pièce, nous traversons le couloir dans une direction, puis ajoutons d'autres couloirs et pièces, en commençant toujours au hasard à partir d'une pièce ou d'un couloir existant, jusqu'à ce que nous atteignions le nombre maximal de couloirs / pièces indiqué au tout début. </font><font style="vertical-align: inherit;">Ou jusqu'à ce que l'algorithme puisse trouver un nouvel endroit pour ajouter une nouvelle pièce / couloir, selon la première éventualité. </font><font style="vertical-align: inherit;">Et nous obtenons donc un donjon.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Décrivons donc cela d'une manière plus proche d'un algorithme, étape par étape. </font><font style="vertical-align: inherit;">Pour plus de commodité, j'appellerai chaque détail de la carte (couloir ou pièce) un élément afin de ne pas avoir à dire «pièce / couloir» à chaque fois.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coupez la pièce au centre de la carte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sélectionnez au hasard l'un des murs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous traversons le couloir dans ce mur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sélectionnez au hasard l'un des éléments existants.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sélectionnez au hasard l'un des murs de cet élément</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le dernier élément sélectionné est une pièce, nous générons un couloir. </font><font style="vertical-align: inherit;">Si le couloir, choisissez au hasard si l'élément suivant sera une pièce ou un autre couloir</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifiez s'il y a suffisamment d'espace dans la direction sélectionnée pour créer l'élément souhaité</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il y a un lieu, créez un élément, sinon, revenez à l'étape 4</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Répétez à partir de l'étape 4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout. </font><font style="vertical-align: inherit;">Nous obtiendrons une carte simple du donjon, dans laquelle il n'y a que des salles et des couloirs, sans portes et éléments spéciaux, mais ce sera notre début. </font><font style="vertical-align: inherit;">Plus tard, nous le remplirons de coffres, d'ennemis et de pièges. </font><font style="vertical-align: inherit;">Et vous pouvez même le personnaliser: nous apprendrons à ajouter les éléments intéressants dont vous avez besoin.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 5 - découpez la pièce</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Procédez enfin au codage! </font><font style="vertical-align: inherit;">Coupons notre première chambre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, créez un nouveau script et appelez-le DungeonGenerator. </font><font style="vertical-align: inherit;">Il héritera de Monobehaviour, vous devrez donc le rattacher à GameObject plus tard. </font><font style="vertical-align: inherit;">Ensuite, nous devrons déclarer plusieurs variables publiques dans la classe afin de pouvoir définir les paramètres du donjon à partir de l'inspecteur. </font><font style="vertical-align: inherit;">Ces variables seront la largeur et la hauteur de la carte, la hauteur et la largeur minimales et maximales des pièces, la longueur maximale des couloirs et le nombre d'éléments qui devraient figurer sur la carte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/331/04d/12033104d1f3fcf270fdc5fd64ffb6bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous devons initialiser le générateur de donjon. Nous faisons cela pour initialiser les variables qui seront remplies par la génération. Pour l'instant, ce ne sera qu'une carte. Et, et supprimez également les fonctions Start () et Update () générées par Unity pour le nouveau script, nous n'en aurons pas besoin.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/a8f/e5d/f92a8fe5dc2ea241284fe95b8758c289.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad7/841/44b/ad784144b6aeea6aee3967caedaa37eb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons initialisé la variable de carte de la classe MapManager (que nous avons créée à l'étape précédente), en passant la largeur et la hauteur de la carte, définies par les variables ci-dessus comme paramètres des deux dimensions du tableau. Grâce à cela, nous aurons une carte de taille x horizontale (largeur) et de taille y verticale (hauteur), et nous pouvons accéder à n'importe quelle cellule de la carte en entrant MapManager.map [x, y]. Cela sera très utile lors de la manipulation de la position des objets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant créer une fonction pour rendre la première pièce. Nous l'appellerons FirstRoom (). Nous avons fait d'InitializeDungeon () une fonction publique, car il sera lancé par un autre script (Game Manager, que nous allons bientôt créer; il centralisera la gestion de l'ensemble du processus de lancement du jeu). Nous n'avons pas besoin de scripts externes pour avoir accès à FirstRoom (), nous ne le rendons donc pas public.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, pour continuer, nous allons créer trois nouvelles classes dans le script MapManager afin que vous puissiez créer une pièce. Il s'agit des classes d'objets, de murs et de positions. La classe Position contiendra les positions x et y afin que nous puissions suivre où tout se trouve. Le mur aura une liste de positions, la direction dans laquelle il "regarde" par rapport au centre de la pièce (nord, sud, est ou ouest), la longueur et la présence d'un nouvel élément créé à partir de celui-ci. L'élément aura une liste de toutes les positions qui le composent, le type de l'élément (pièce ou couloir), un tableau de variables de mur, ainsi que sa largeur et sa hauteur.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/abe/924/3b7abe9241bb1442f3224048384263ff.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/938/8bc/8d7/9388bc8d7dd523b45013fa80d918d8a2.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant à la fonction FirstRoom (). </font><font style="vertical-align: inherit;">Revenons au script DungeonGenerator et créons une fonction juste en dessous d'InitializeDungeon. </font><font style="vertical-align: inherit;">Elle n'aura pas besoin de recevoir de paramètres, nous allons donc laisser les choses simples (). </font><font style="vertical-align: inherit;">Ensuite, à l'intérieur de la fonction, nous devons d'abord créer et initialiser la variable Room et sa liste de variables Position. </font><font style="vertical-align: inherit;">Nous le faisons comme ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/164/b81/b5d/164b81b5dde06f8e996e22a75bf0b947.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définissons maintenant la taille de la pièce. </font><font style="vertical-align: inherit;">Il recevra une valeur aléatoire entre la hauteur et la largeur minimales et maximales déclarées au début du script. </font><font style="vertical-align: inherit;">Bien qu'ils soient vides, car nous n'avons pas défini de valeur pour eux dans l'inspecteur, mais ne vous inquiétez pas, nous le ferons bientôt. </font><font style="vertical-align: inherit;">Nous définissons des valeurs aléatoires comme ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/bbd/389/d77bbd3896dc4c60d93a9e6b1c006729.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous devons déclarer où le point de départ de la pièce sera situé, c'est-à-dire où le point de la pièce 0.0 sera situé dans la grille de la carte. Nous voulons le faire commencer au centre de la carte (mi-largeur et mi-hauteur), mais peut-être pas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au centre. Il pourrait être utile d'ajouter un petit randomiseur pour qu'il se déplace légèrement vers la gauche et vers le bas. Par conséquent, nous définissons xStartingPoint comme la moitié de la largeur de la carte, et yStartingPoint comme la moitié de la hauteur de la carte, puis prenons la roomWidth et roomHeight juste donnée, nous obtenons une valeur aléatoire de 0 à cette largeur / hauteur, et la soustrayons des x et y initiaux. Comme ça:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50f/3f2/f0e/50f3f2f0ecb267d5283dcd4684019708.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/0e7/f2b/8eb0e7f2bff7d3d08b1b0691885e89cd.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, dans la même fonction, nous ajouterons des murs. Nous devons initialiser le tableau des murs qui se trouvent dans la variable de pièce nouvellement créée, puis initialiser chaque variable de mur à l'intérieur de ce tableau. Ensuite, initialisez chaque liste de positions, définissez la longueur du mur à 0 et entrez la direction dans laquelle chaque mur «se penchera». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois le tableau initialisé, nous bouclons autour de chaque élément du tableau dans la boucle for (), initialisons les variables de chaque mur, puis utilisons le commutateur, qui nomme la direction de chaque mur. Il est choisi arbitrairement, il suffit de se rappeler ce qu'il signifiera.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3a/f8f/9da/d3af8f9da1ee8f317452d52f9f905536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant exécuter deux boucles imbriquées immédiatement après avoir placé les murs. </font><font style="vertical-align: inherit;">Dans la boucle externe, nous contournons toutes les valeurs y dans la pièce, et dans la boucle imbriquée, toutes les valeurs x. </font><font style="vertical-align: inherit;">De cette façon, nous vérifierons chaque cellule x de la ligne y afin de pouvoir l'implémenter.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/cb3/695/3eecb3695c59d199fb32064501ce1009.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la première chose à faire est de trouver la valeur réelle de la position de la cellule sur l'échelle de la carte à partir de la position de la pièce. </font><font style="vertical-align: inherit;">C'est assez simple: nous avons les points de départ x et y. </font><font style="vertical-align: inherit;">Ils seront positionnés 0,0 dans la grille de la pièce. </font><font style="vertical-align: inherit;">Ensuite, si nous devons obtenir la valeur réelle de x, y à partir de n'importe quel x, y local, nous ajoutons les x et y locaux avec les positions initiales x et y. </font><font style="vertical-align: inherit;">Ensuite, nous enregistrons ces valeurs réelles x, y dans la variable Position (à partir d'une classe précédemment créée), puis les ajoutons à la liste &lt;&gt; des positions de la pièce.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cc4/4a0/0b2cc44a0ae9953a3d49ac0b3c01a6c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'étape suivante consiste à ajouter ces informations à la carte. </font><font style="vertical-align: inherit;">Avant de modifier les valeurs, n'oubliez pas d'initialiser la variable Tile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/fe5/a43/1aafe5a43a8c30f2c343472ad7f157ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant modifier la classe Tile. </font><font style="vertical-align: inherit;">Passons au script MapManager et ajoutons une ligne à la définition de la classe Tile: «type de chaîne publique;». </font><font style="vertical-align: inherit;">Cela nous permettra d'ajouter une classe de tuiles en déclarant que la tuile en x, y est un mur, un sol ou autre chose. </font><font style="vertical-align: inherit;">Ensuite, revenons au cycle dans lequel nous avons fait le travail et ajoutons une grande construction if-else, qui nous permettra non seulement de déterminer chaque mur, sa longueur et toutes les positions dans ce mur, mais aussi de spécifier sur la carte globale ce qu'est une tuile spécifique - un mur ou le sexe.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/276/28c/7c327628cea73dafe9319a01ac10b72b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous avons déjà fait quelque chose. Si la variable y (contrôle de la variable dans la boucle externe) est 0, la tuile appartient à la rangée de cellules la plus basse de la pièce, c'est-à-dire qu'il s'agit du mur sud. Si x (contrôle de la variable de boucle intérieure) est égal à 0, alors la tuile appartient à la colonne de cellules la plus à gauche, c'est-à-dire qu'il s'agit du mur ouest. Et si c'est sur la ligne la plus haute, alors il appartient au mur nord, et tout à droite - le mur est. Nous soustrayons 1 des variables roomWidth et roomHeight, car ces valeurs ont été calculées à partir de 1 et les variables x et y du cycle ont commencé à 0, nous devons donc tenir compte de cette différence. Et toutes les cellules qui ne remplissent pas les conditions ne sont pas des murs, c'est-à-dire qu'elles sont le sol.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/4a6/2c9/2584a62c91fc46205f903cb4283bd1ce.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Super, nous avons presque fini avec la première chambre. </font><font style="vertical-align: inherit;">Il est presque prêt, il suffit de mettre les dernières valeurs dans la variable Feature que nous avons créée. </font><font style="vertical-align: inherit;">Nous quittons la boucle et terminons la fonction comme ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bd/aaf/a47/2bdaafa47adb2694f360eea850341920.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien! </font><font style="vertical-align: inherit;">Nous avons une chambre! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comment comprendre que tout fonctionne? </font><font style="vertical-align: inherit;">Besoin de tester. </font><font style="vertical-align: inherit;">Mais comment tester? </font><font style="vertical-align: inherit;">Nous pouvons passer du temps et ajouter des actifs pour cela, mais ce sera une perte de temps et nous distraira également de terminer l'algorithme. </font><font style="vertical-align: inherit;">Hmm, mais cela peut être fait en utilisant ASCII! </font><font style="vertical-align: inherit;">Oui, bonne idée! </font><font style="vertical-align: inherit;">ASCII est un moyen simple et peu coûteux de dessiner une carte afin qu'elle puisse être testée. </font><font style="vertical-align: inherit;">De plus, si vous le souhaitez, vous pouvez ignorer la partie avec des sprites et des effets visuels, que nous étudierons plus tard, et créer votre jeu entier en ASCII. </font><font style="vertical-align: inherit;">Voyons donc comment cela se fait.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 6 - dessiner la première salle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose à considérer lors de la mise en œuvre d'une carte ASCII est la police à choisir. Le principal facteur à considérer lors du choix d'une police pour ASCII est de savoir si elle est proportionnelle (largeur variable) ou monospace (largeur fixe). Nous avons besoin d'une police monospace pour que les cartes aient l'air nécessaires (voir l'exemple ci-dessous). Par défaut, tout nouveau projet Unity utilise la police Arial, et il n'est pas à espacement fixe, nous devons donc en trouver un autre. Windows 10 a généralement des polices à espacement fixe Courier New, Consolas et Lucida Console. Choisissez l'un de ces trois ou téléchargez-en un autre à l'endroit dont vous avez besoin et placez-le dans le dossier Polices à l'intérieur du dossier Actifs du projet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff4/beb/f23/ff4bebf23a4523f4dd348524ac6b0a9f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Préparons la scène pour la sortie ASCII. Pour commencer, rendez la couleur d'arrière-plan de la caméra principale de la scène noire. Ensuite, nous ajoutons l'objet Canvas à la scène et y ajoutons l'objet Text. Définissez la transformation du rectangle de texte au milieu du centre et à la position 0,0,0. Définissez l'objet Texte de sorte qu'il utilise la police que vous avez sélectionnée et la couleur blanche, débordement horizontal et vertical (débordement horizontal / vertical), sélectionnez Débordement et centrez l'alignement vertical et horizontal. Renommez ensuite l'objet Text en «ASCIITest» ou quelque chose de similaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons maintenant au code. Dans le script DungeonGenerator, créez une nouvelle fonction appelée DrawMap. Nous voulons qu'elle obtienne un paramètre indiquant quelle carte générer - ASCII ou sprite, alors créez un paramètre booléen et appelez-le isCASII.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/387/67a/957/38767a9575270115821d6be36ce97293.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous vérifierons si la carte rendue est ASCII. </font><font style="vertical-align: inherit;">Si oui (pour l'instant, nous ne considérerons que ce cas), alors nous rechercherons un objet texte dans la scène, passerons le nom qui lui est donné en paramètre et obtiendrons son composant Text. </font><font style="vertical-align: inherit;">Mais d'abord, nous devons dire à Unity que nous voulons travailler avec l'interface utilisateur. </font><font style="vertical-align: inherit;">Ajoutez la ligne utilisant UnityEngine.UI à l'en-tête de script:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17c/e18/c24/17ce18c24ec7c286b4390159dc98dab1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien. </font><font style="vertical-align: inherit;">Nous pouvons maintenant obtenir le composant Text de l'objet. </font><font style="vertical-align: inherit;">La carte sera une énorme ligne qui se reflétera sur l'écran sous forme de texte. </font><font style="vertical-align: inherit;">C'est pourquoi il est si facile à installer. </font><font style="vertical-align: inherit;">Créons donc une chaîne et initialisons-la avec la valeur "".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/7f2/92c/6d27f292c1f519a7b351d7b8d80a8f84.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien. Ainsi, à chaque appel de DrawMap, nous devrons indiquer si la carte est un ASCII. Si c'est le cas (et nous l'aurons toujours de cette façon, nous travaillerons avec d'autres plus tard), alors la fonction cherchera la hiérarchie des scènes à la recherche d'un objet de jeu appelé "ASCIITest". Si c'est le cas, il recevra son composant Texte et l'enregistrera dans la variable d'écran, dans laquelle nous pourrons ensuite facilement écrire la carte. Il crée ensuite une chaîne dont la valeur est initialement vide. Nous remplirons cette ligne avec notre carte marquée de symboles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habituellement, nous parcourons la carte en boucle, commençant à 0 et allant jusqu'à la fin de sa longueur. </font><font style="vertical-align: inherit;">Mais pour remplir la ligne, nous commençons par la première ligne de texte, c'est-à-dire la ligne la plus haute. </font><font style="vertical-align: inherit;">Par conséquent, sur l'axe y, nous devons nous déplacer dans une boucle dans la direction opposée, allant de la fin au début du tableau. </font><font style="vertical-align: inherit;">Mais l'axe des x du tableau va de gauche à droite, tout comme le texte, donc cela nous convient.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/019/f47/536019f479ea1af260d551f342ed46aa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cycle, nous vérifions chaque cellule de la carte pour découvrir ce qu'elle contient. </font><font style="vertical-align: inherit;">Jusqu'à présent, nous avons seulement initialisé les cellules en tant que nouveau Tile (), que nous avons découpé pour la pièce, donc tout le monde retournera une erreur lors de la tentative d'accès. </font><font style="vertical-align: inherit;">Nous devons donc d'abord vérifier </font><font style="vertical-align: inherit;">s'il </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quelque chose dans cette cellule, et nous le faisons en vérifiant la cellule pour null. </font><font style="vertical-align: inherit;">S'il n'est pas nul, alors nous continuons à travailler, mais s'il est nul, alors il n'y a rien à l'intérieur, nous pouvons donc ajouter de l'espace vide à la carte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/f56/5d9/3f3f565d9e9f7886c3baa600cd1ab99f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, pour chaque cellule non vide, nous vérifions son type, puis ajoutons le symbole correspondant. </font><font style="vertical-align: inherit;">Nous voulons que les murs soient indiqués par le symbole "#" et les sols par le ".". </font><font style="vertical-align: inherit;">Et tandis que nous n'avons que ces deux types. </font><font style="vertical-align: inherit;">Plus tard, lorsque nous ajouterons le joueur, les monstres et les pièges, tout sera un peu plus compliqué.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a24/ef0/f9fa24ef002860f5331479f9ac07a6e8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous devons effectuer des sauts de ligne lorsque nous atteignons la fin de la ligne du tableau, de sorte que les cellules ayant la même position x se trouvent directement les unes sous les autres. </font><font style="vertical-align: inherit;">Nous vérifierons à chaque itération de la boucle si la cellule est la dernière de la ligne, puis ajouterons un saut de ligne avec le caractère spécial "\ n".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/7b8/1eb/c147b81eb1f4efa01bafdfa8a4aa092d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout. </font><font style="vertical-align: inherit;">Ensuite, nous quittons la boucle pour pouvoir ajouter cette ligne une fois terminée à l'objet texte dans la scène.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/8bb/f4d/20f8bbf4d1c8e5b59afc3163a97d57bb.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/83f/a7f/fcb83fa7f923ec53e33696bb8962a1d9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes nos félicitations! Vous avez terminé le script qui crée la salle et l'affiche à l'écran. Il ne nous reste plus qu'à mettre ces lignes en action. Nous n'utilisons pas Start () dans le script DungeonGenerator, car nous voulons avoir un script séparé pour contrôler tout ce qui est effectué au début du jeu, y compris la génération de cartes, mais aussi les paramètres du joueur, les ennemis, etc. Par conséquent, cet autre script contiendra la fonction Start () et, si nécessaire, appellera les fonctions de notre script. Le script DungeonGenerator a une fonction Initialize, qui est publique, et FirstRoom et DrawMap ne sont pas publics. Initialiser initialise simplement les variables pour configurer le processus de génération de donjon, nous avons donc besoin d'une autre fonction qui appelle le processus de génération, qui doit être public afin qu'il puisse être appelé à partir d'autres scripts.Pour l'instant, elle n'appellera que la fonction FirstRoom (), puis la fonction DrawMap (), en lui passant une valeur vraie pour qu'elle dessine une carte ASCII. Oh, ou pas, c'est encore mieux - créons une variable publique isASCII, qui peut être incluse dans l'inspecteur, et passons simplement cette variable comme paramètre à la fonction. Bien.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c58/288/502/c58288502f107440def4f803d602662b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons maintenant un script GameManager. </font><font style="vertical-align: inherit;">Ce sera le script même qui contrôlera tous les éléments de haut niveau du jeu, par exemple, la création d'une carte et le déroulement des mouvements. </font><font style="vertical-align: inherit;">Supprimons la fonction Update (), ajoutons une variable de type DungeonGenerator appelée dungeonGenerator et créons une instance de cette variable dans la fonction Start ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/8da/424/e5b8da4243c91f887c08213b9ec14953.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, nous appelons simplement les fonctions InitializeDungeon () et GenerateDungeon () à partir de dungeonGenerator, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans cet ordre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ceci est important - vous devez d'abord initialiser les variables, et seulement après cela commencer à construire sur leur base.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/7e6/781/1587e6781595d0ee6661aea7898aa6e4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur cette partie avec le code est terminé. </font><font style="vertical-align: inherit;">Nous devons créer un objet de jeu vide dans le panneau de hiérarchie, le renommer en GameManager et y attacher les scripts GameManager et DungeonGenerator. </font><font style="vertical-align: inherit;">Et puis définissez les valeurs du générateur de donjon dans l'inspecteur. </font><font style="vertical-align: inherit;">Vous pouvez essayer différents schémas pour le générateur, et je me suis installé sur ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/41f/495/a1141f4953a6fdeac32cc978ac4a0b05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, cliquez simplement sur jouer et regardez la magie! </font><font style="vertical-align: inherit;">Vous devriez voir quelque chose de similaire sur l'écran du jeu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/093/6ab/ad40936ab0dff25fd3214571faf9aa61.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Félicitations, nous avons maintenant une chambre! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voulais que nous y mettions le personnage du joueur et le fassions bouger, mais le message était déjà assez long. </font><font style="vertical-align: inherit;">Par conséquent, dans la partie suivante, nous pouvons procéder directement à la mise en œuvre du reste de l'algorithme du donjon, ou nous pouvons y placer le joueur et lui apprendre à se déplacer. </font><font style="vertical-align: inherit;">Votez ce que vous préférez dans les commentaires de l'article original. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MapManager.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System; <span class="hljs-comment">// So the script can use the serialization commands</span>
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapManager</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tile[,] map; <span class="hljs-comment">// the 2-dimensional map with the information for all the tiles</span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>] <span class="hljs-comment">// Makes the class serializable so it can be saved out to a file</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tile</span> { <span class="hljs-comment">// Holds all the information for each tile on the map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> xPosition; <span class="hljs-comment">// the position on the x axis</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yPosition; <span class="hljs-comment">// the position on the y axis</span>
    [<span class="hljs-meta">NonSerialized</span>]
    <span class="hljs-keyword">public</span> GameObject baseObject; <span class="hljs-comment">// the map game object attached to that position: a floor, a wall, etc.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> type; <span class="hljs-comment">// The type of the tile, if it is wall, floor, etc</span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Position</span> { <span class="hljs-comment">//A class that saves the position of any cell</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y;<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wall</span> { <span class="hljs-comment">// A class for saving the wall information, for the dungeon generation algorithm</span>
    <span class="hljs-keyword">public</span> List&lt;Position&gt; positions;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> direction;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> length;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> hasFeature = <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Feature</span> { <span class="hljs-comment">// A class for saving the feature (corridor or room) information, for the dungeon generation algorithm</span>
    <span class="hljs-keyword">public</span> List&lt;Position&gt; positions;
    <span class="hljs-keyword">public</span> Wall[] walls;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> type;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> width;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DungeonGenerator.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DungeonGenerator</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        FirstRoom();<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FirstRoom</span>(<span class="hljs-params"></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Position&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = Random.Range(widthMinRoom, widthMaxRoom);
        <span class="hljs-keyword">int</span> roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint = mapWidth / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
<font></font>
        xStartingPoint -= Random.Range(<span class="hljs-number">0</span>, roomWidth);<font></font>
        yStartingPoint -= Random.Range(<span class="hljs-number">0</span>, roomHeight);<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Position&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Position position = <span class="hljs-keyword">new</span> Position();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = <span class="hljs-string">"Room"</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x,y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    } <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameManager.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    DungeonGenerator dungeonGenerator;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {<font></font>
        dungeonGenerator = GetComponent&lt;DungeonGenerator&gt;();<font></font>
<font></font>
        dungeonGenerator.InitializeDungeon();<font></font>
        dungeonGenerator.GenerateDungeon();<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490808/index.html">Mathématiques en astronautique: moteur de détonation rotationnelle</a></li>
<li><a href="../fr490812/index.html">Expérience de soumission de certification professionnelle de printemps 5</a></li>
<li><a href="../fr490816/index.html">Comment les sites de commerce électronique résistent-ils aux botnets AuthBots?</a></li>
<li><a href="../fr490820/index.html">Tous les Habr dans une seule base</a></li>
<li><a href="../fr490826/index.html">La source de l'efficacité de la production</a></li>
<li><a href="../fr490830/index.html">Gestion des mots de passe dans Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../fr490832/index.html">Marquage des chaussures: en mettant en circulation 2 millions de codes de marquage «1C» + «Honest Sign»</a></li>
<li><a href="../fr490836/index.html">Comment ouvrir des commentaires et ne pas se noyer dans le spam</a></li>
<li><a href="../fr490838/index.html">Le WiFi 6 est là: ce que le marché propose et pourquoi avons-nous besoin de cette technologie</a></li>
<li><a href="../fr490840/index.html">La planification des ressources. Partie 4.1. Avant de faire un plan de ressources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>