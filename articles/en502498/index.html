<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëù üò¥ üé† Best practices for improving performance in C # üëßüèæ üëÜüèª üë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone. We have prepared a translation of another useful material on the eve of the start of the course "C # Developer" . Enjoy reading.
 
 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Best practices for improving performance in C #</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502498/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello everyone. </font><font style="vertical-align: inherit;">We have prepared a translation of another useful material on the eve of the start of the course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"C # Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Enjoy reading.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/q4/xs/kv/q4xskv5-ia4gfwlhgm1hx5e1gdc.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since I recently made a list of best practices in C # for Criteo, I thought it would be nice to share it publicly. The purpose of this article is to provide an incomplete list of code templates that should be avoided, either because they are questionable, or because they just work poorly. The list may seem a bit random because it is slightly taken out of context, but </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> its elements were at some point found in our code and caused problems in production. I hope this will serve as a good prevention and prevent your mistakes in the future. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also note that Criteo web services rely on high-performance code, hence the need to avoid inefficient code. In most applications, there will be no noticeable tangible difference from replacing some of these templates.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And last, but not least, some points (for example, </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) have already been discussed in many articles, so I will not dwell on them in detail. </font><font style="vertical-align: inherit;">The goal is to form a compact list of points to which you need to pay attention, and not give a detailed technical description of each of them.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronously waiting for asynchronous code</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never expect synchronously unfinished tasks. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This applies to, but is not limited to: </font></font><code>Task.Wait, Task.Result, Task.GetAwaiter().GetResult(), Task.WaitAny, Task.WaitAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a generalization: any synchronous relationship between two pool threads can cause pool depletion. </font><font style="vertical-align: inherit;">The causes of this phenomenon are described in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If your code can be called from a synchronization context, use </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for each of your await calls. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that this is </font></font><code>ConfigureAwait</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only useful when using a keyword </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the following code is meaningless:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//  ConfigureAwait        </span>
<span class="hljs-keyword">var</span> result = ProcessAsync().ConfigureAwait(<span class="hljs-literal">false</span>).GetAwaiter().GetResult();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async void</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never use</font></font><code>async void</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The exception thrown in the </font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method propagates to the synchronization context and usually causes the entire application to crash. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you cannot return the task in your method (for example, because you are implementing the interface), move the asynchronous code to another method and call it:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInterface</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"></span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Implementation</span> : <span class="hljs-title">IInterface</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">//      ,</span>
        <span class="hljs-comment">//      </span><font></font>
        _ = DoSomethingAsync();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DoSomethingAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">100</span>);<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid async whenever possible </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Out of habit or because of muscle memory, you can write something like:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CallAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetAsync();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although the code is semantically correct, using a keyword </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not required here and can result in significant overhead in a highly loaded environment. </font><font style="vertical-align: inherit;">Try to avoid it whenever possible:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">CallAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client();
    <span class="hljs-keyword">return</span> _client.GetAsync();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, keep in mind that you cannot resort to this optimization when your code is wrapped in blocks (for example, </font></font><code> try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Correct</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetAsync();<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Incorrect</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> client.GetAsync();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the wrong version ( </font></font><code>Incorrect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), the client may be deleted before the </font></font><code>GetAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call is </font><font style="vertical-align: inherit;">completed </font><font style="vertical-align: inherit;">, since the task inside the using block is not expected by await.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regional comparisons</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you have no reason to use regional comparisons, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always use ordinal comparisons</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Although, due to internal optimizations, this does not really matter for the en-US data presentation forms, the comparison is an order of magnitude slower for the presentation forms of other regions (and up to two orders of magnitude on Linux!). </font><font style="vertical-align: inherit;">Since string comparison is a frequent operation in most applications, the overhead increases significantly.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConcurrentBag </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never use </font></font><code><code>ConcurrentBag&lt;</code>T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without benchmarking</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This collection was designed for very specific use cases (when most of the time the item is excluded from the queue by the thread that queued it) and suffers from serious performance problems if it is used for other purposes. If you need a thread-safe collection, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prefer ConcurrentQueue </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReaderWriterLock / ReaderWriterLockSlim </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never use </font><font style="vertical-align: inherit;">without benchmarking. </font></font><code><code>ReaderWriterLock&lt;T&gt;</code>/ReaderWriterLockSlim&lt;T<code>&gt;</code></code><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although using this kind of specialized synchronization primitive when working with readers and writers can be tempting, its cost is much higher than simple </font></font><code>Monitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(used with a keyword </font></font><code>lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">If the number of readers performing the critical section at the same time is not very large, concurrency will not be enough to absorb the increased overhead, and the code will work worse.</font></font><br>
<br>
</h3><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefer lambda functions instead of method groups</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the following code:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(i =&gt; Filter(i));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resharper suggests rewriting code without a lambda function, which might look a little cleaner:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(Filter);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, this leads to the allocation of dynamic memory for each call. </font><font style="vertical-align: inherit;">In fact, the call compiles as:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(<span class="hljs-keyword">new</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt;(Filter));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This can have a significant impact on performance if the code is called in a heavily loaded section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using lambda functions starts compiler optimization, which caches the delegate in a static field, avoiding allocation. </font><font style="vertical-align: inherit;">This only works if </font></font><code>Filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static. </font><font style="vertical-align: inherit;">If not, you can cache the delegate yourself:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt; _filter;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Constructor</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    _filter = <span class="hljs-keyword">new</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt;(Filter);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(_filter);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convert Enumerations to Strings</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calling </font></font><code>Enum.ToString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>.net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is quite expensive, because reflection is used to convert inside, and calling the virtual method on the structure provokes packaging. </font><font style="vertical-align: inherit;">This should be avoided as much as possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enumerations can often be replaced with constant strings:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//       Numbers.One, Numbers.Two, ...</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Numbers<font></font>
{<font></font>
    One,<font></font>
    Two,<font></font>
    Three<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Numbers</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> One = <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Two = <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Three = <span class="hljs-string">"Three"</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you really need to use an enumeration, consider caching the converted value in a dictionary to amortize overhead.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumeration Comparison</font></font></h2><br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: this is no longer relevant in .net core, since version 2.1, optimization is performed by JIT automatically.</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When using enumerations as flags, it may be tempting to use the method </font></font><code>Enum.HasFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Flags</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Options<font></font>
{<font></font>
    Option1 = <span class="hljs-number">1</span>,<font></font>
    Option2 = <span class="hljs-number">2</span>,<font></font>
    Option3 = <span class="hljs-number">4</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> Options _option;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsOption2Enabled</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _option.HasFlag(Options.Option2);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code provokes two packages with allocation: one for conversion </font></font><code>Options.Option2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the other for a virtual call </font></font><code>HasFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the structure. </font><font style="vertical-align: inherit;">This makes this code disproportionately expensive. </font><font style="vertical-align: inherit;">Instead, you should sacrifice readability and use binary operators:</font></font><br>
 <br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsOption2Enabled</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> (_option &amp; Options.Option2) == Options.Option2;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation of comparison methods for structures</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When using a structure in comparisons (for example, when used as a key for a dictionary), you need to override the methods </font></font><code>Equals/GetHashCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The default implementation uses reflection and is very slow. </font><font style="vertical-align: inherit;">The implementation generated by Resharper is usually pretty good. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can learn more about this here: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c</font></font></a></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid inappropriate packaging when using structures with interfaces</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the following code:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntValue</span> : <span class="hljs-title">IValue</span><font></font>
{<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> IntValue();<font></font>
<font></font>
    LogValue(<span class="hljs-keyword">value</span>);<font></font>
    SendValue(<span class="hljs-keyword">value</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendValue</span>(<span class="hljs-params">IValue <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogValue</span>(<span class="hljs-params">IValue <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Make </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structured can be tempting to avoid allocating dynamic memory. </font><font style="vertical-align: inherit;">But since </font></font><code>AddValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>SendValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expect an interface, and the interfaces have reference semantics, the value will be packaged with each call, negating the advantages of this "optimization". </font><font style="vertical-align: inherit;">In fact, there will be even more memory allocations than if it </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">were a class, since the value will be packaged independently for each call. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are writing an API and expect some values ‚Äã‚Äãto be structures, try using generic methods:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> IntValue : IValue<font></font>
{<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> IntValue();<font></font>
<font></font>
    LogValue(<span class="hljs-keyword">value</span>);<font></font>
    SendValue(<span class="hljs-keyword">value</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> SendValue&lt;T&gt;(T <span class="hljs-keyword">value</span>) <span class="hljs-keyword">where</span> T : IValue<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> LogValue&lt;T&gt;(T <span class="hljs-keyword">value</span>) <span class="hljs-keyword">where</span> T : IValue<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although the conversion of these methods to universal seems useless at first glance, it actually allows you to avoid packaging with allocation in the case when it </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a structure.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken Subscriptions Always Inline</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you cancel </font></font><code>CancellationTokenSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, all subscriptions will be executed inside the current thread. </font><font style="vertical-align: inherit;">This can lead to unplanned pauses or even implicit deadlocks.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
cts.Token.Register(() =&gt; Thread.Sleep(<span class="hljs-number">5000</span>));<font></font>
cts.Cancel(); <span class="hljs-comment">//     5 </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You cannot escape this behavior. </font><font style="vertical-align: inherit;">Therefore, when canceling </font></font><code>CancellationTokenSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ask yourself if you can safely allow your current thread to be captured. </font><font style="vertical-align: inherit;">If the answer is no, wrap the call </font></font><code>Cancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to execute it in the thread pool.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource continuations often inline</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like subscriptions </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, continuations </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are often inline. </font><font style="vertical-align: inherit;">This is a good optimization, but it can cause implicit errors. </font><font style="vertical-align: inherit;">For example, consider the following program:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ManualResetEventSlim _mutex = <span class="hljs-keyword">new</span> ManualResetEventSlim();<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Deadlock</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> ProcessAsync();<font></font>
        _mutex.Wait();<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Task <span class="hljs-title">ProcessAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-keyword">bool</span>&gt;();<font></font>
        <font></font>
        Task.Run(() =&gt;<font></font>
        {<font></font>
            Thread.Sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">//  - </span>
            tcs.SetResult(<span class="hljs-literal">true</span>);<font></font>
            _mutex.Set();<font></font>
        });<font></font>
        <font></font>
        <span class="hljs-keyword">return</span> tcs.Task;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
    {<font></font>
        Deadlock().Wait();<font></font>
        Console.WriteLine(<span class="hljs-string">"Will never get there"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The call </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">causes the continuation </font></font><code>await ProcessAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to execute in the current thread. </font><font style="vertical-align: inherit;">Therefore, the statement </font></font><code>_mutex.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is executed by the same thread that it should call </font></font><code>_mutex.Set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which leads to a deadlock. </font><font style="vertical-align: inherit;">This can be avoided by passing parameter </font></font><code>TaskCreationsOptions.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have no good reason to neglect it, always use the option </font></font><code>TaskCreationsOptions.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when creating </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Be careful: the code will also compile if you use </font></font><code><b>TaskContinuationOptions</b>.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead </font></font><code><b>TaskCreationOptions</b>.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but the parameters will be ignored, and the continuations will still be inline. </font><font style="vertical-align: inherit;">This is a surprisingly common mistake because it </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precedes </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autocomplete.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Run / Task.Factory.StartNew</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you have no reason to use </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, always choose </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to run a background task. </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses safer default values, and more importantly, it automatically unpacks the returned task, which can prevent unobvious errors with asynchronous methods. </font><font style="vertical-align: inherit;">Consider the following program:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ProcessAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);<font></font>
        Console.WriteLine(<span class="hljs-string">"Processing done"</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Factory.StartNew(ProcessAsync);<font></font>
        Console.WriteLine(<span class="hljs-string">"End of program"</span>);<font></font>
        Console.ReadLine();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite its appearance, the End of program will be displayed earlier than Processing done. </font><font style="vertical-align: inherit;">This is because it </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will return </font></font><code><code>Task&lt;Task&gt;</code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the code expects only an external task. </font><font style="vertical-align: inherit;">The correct code could be either </font></font><code>await Task.Factory.StartNew(ProcessAsync).Unwrap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or </font></font><code>await Task.Run(ProcessAsync)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are only three valid use cases </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running a task in another scheduler.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performing a task in a dedicated thread (using </font></font><code>TaskCreationOptions.LongRunning</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li>
<li>       (  <code>TaskCreationOptions.PreferFairness</code>).</li>
</ul><br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">   .</a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502486/index.html">The book "Race with the epidemic. Antibiotics against superbugs "</a></li>
<li><a href="../en502490/index.html">Flashing restrictive beliefs. For what and what does it give</a></li>
<li><a href="../en502492/index.html">Innovations in Zextras Suite and Zimbra OSE</a></li>
<li><a href="../en502494/index.html">7 mistakes of one Black Friday and how Magento Cloud works - video</a></li>
<li><a href="../en502496/index.html">Easy Web Access to LabVIEW VI PHP Applications via ActiveX Server</a></li>
<li><a href="../en502500/index.html">The evolution of a passport scanner: from plywood crafts to real business</a></li>
<li><a href="../en502504/index.html">Surround the user digit</a></li>
<li><a href="../en502508/index.html">Trolley Robot 2.0. Part 2. Management in rviz and without. Elements of beauty in rviz</a></li>
<li><a href="../en502510/index.html">What to save in the cloud</a></li>
<li><a href="../en502512/index.html">Results of the contest of sofa experts: the rules of scientific poking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>