<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧 🚶🏾 👩🏻‍🎤 Flattern. BlOC, Provider, Async - Shelf Architecture 🧗🏼 🐉 💀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung
 Wenn Sie versuchen, eine Anwendung zu schreiben, stoßen Sie zunächst auf die Organisation der Architektur der Anwendung. Und wenn es um Fl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flattern. BlOC, Provider, Async - Shelf Architecture</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie versuchen, eine Anwendung zu schreiben, stoßen Sie zunächst auf die Organisation der Architektur der Anwendung. </font><font style="vertical-align: inherit;">Und wenn es um Flutter geht, kann sich der Kopf vollständig um das drehen, was Google herausgibt - Vanille, Scoped Model, BLoC, MVP, MVC, MVVM, MVI usw. </font><font style="vertical-align: inherit;">Angenommen, Sie entscheiden sich für den modischsten Weg (den von Google im Jahr 2018 empfohlen wurde) und verwenden BLOC. </font><font style="vertical-align: inherit;">Was ist das? </font><font style="vertical-align: inherit;">Wie benutzt man es? </font><font style="vertical-align: inherit;">Oder vielleicht Redux oder RxDart? </font><font style="vertical-align: inherit;">- obwohl es bei der Haltestelle um das "Andere" geht ... Aber wie geht es weiter? </font><font style="vertical-align: inherit;">Welche Bibliotheken müssen verbunden werden? </font><font style="vertical-align: inherit;">Block, Flutter_Block, Block_Muster usw.? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Anzahl von Architekturoptionen und -werkzeugen für ihre Implementierung kann die Auswahlphase wirklich lange verzögern.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für wen der Artikel</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist in erster Linie für diejenigen nützlich, die gerade erst anfangen, Flutter zu lernen und nicht wissen, wo sie anfangen sollen. </font><font style="vertical-align: inherit;">Ich werde eine der Implementierungsoptionen für Flatteranwendungen zeigen. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie das Flattern „fühlen“ und dann selbst entscheiden, wie und mit welchen Anwendungen Sie Ihre Anwendungen schreiben.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muster und Werkzeuge. </font><font style="vertical-align: inherit;">Kurz und einfach</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also fangen wir an. Das erste, was erwähnenswert ist, ist, dass es eine Anwendungsarchitektur gibt (Muster, Vorlage, ein Konstruktionskonzept) - dies ist genau das gleiche: BLoC, MVP, MVC, MVVM, MVI usw. Viele dieser Architekturen werden nicht nur in Flutter, sondern auch in anderen Programmiersprachen verwendet. Frage - was zur Auswahl? Meiner Meinung nach müssen Sie auswählen, was Sie selbst gut wissen, aber nur, wenn dies Reaktivität und eine strikte Trennung der Geschäftslogik von der Benutzeroberfläche impliziert (ja, ja - „ein Auto kann jede Farbe haben, wenn es schwarz ist“). Die Trennung von Schnittstelle und Geschäftslogik muss meines Erachtens nicht erklärt werden, aber die Reaktivität - versuchen Sie es, wenn Sie es nicht versucht haben - ist am Ende wirklich sehr praktisch und "schön". Wenn Sie es nicht selbst auswählen können, lassen Sie es zu, dass es von nicht den dümmsten Leuten von Google - BLOC - für uns erledigt wird. Wir haben die Architektur herausgefunden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun die Tools - es gibt fertige Bibliotheken - Bloc, Flutter_bloc, bloc_pattern - was ist besser? Ich weiß nicht - jeder ist gut. Sie können lange wählen und vergleichen, aber auch hier, wie in der Armee, ist es besser, vorerst eine falsche Entscheidung zu treffen, als keine zu treffen. Und für den Moment schlage ich vor, nach dem Mod zurückzukehren und Provider zu verwenden (was die gleichen Leute 2019 empfehlen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies ermöglicht es uns, je nach Bedarf sowohl einen globalen als auch einen lokalen Block zu bilden. </font><font style="vertical-align: inherit;">Es wurde viel über die Architektur von BLoC geschrieben (nämlich ein Muster, keine Bibliotheken). Ich denke, Sie sollten nicht noch einmal im Detail darauf eingehen. </font><font style="vertical-align: inherit;">Ich stelle nur einen Punkt in diesem Artikel fest, es wird kein klassisches BLoC verwendet, sondern leicht modifiziert - in BLoC werden Aktionen (Ereignisse) nicht über Sinks übertragen, sondern BLoC-Funktionen werden aufgerufen. </font><font style="vertical-align: inherit;">Im Moment sehe ich einfach nicht die Vorteile der Verwendung von Waschbecken - und da diese nicht vorhanden sind, warum sollten Sie dann Ihr Leben komplizieren?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronität und paralleles Rechnen in Dart</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es lohnt sich auch, das Konzept der Asynchronität in Dart ein wenig zu klären, da es sich um Reaktivität handelt. Sehr oft wird in den ersten Phasen der Bekanntschaft mit Dart die Bedeutung von asynchronen Funktionen (asynchron) nicht richtig verstanden. Sie sollten immer daran denken, dass das Programm „standardmäßig“ in einem Thread ausgeführt wird und Sie durch Asynchronität nur die Reihenfolge der Befehle ändern können, anstatt sie parallel auszuführen. Das heißt, wenn Sie die Funktion einfach mit großen Berechnungen ausführen, indem Sie sie als asynchron markieren, wird die Schnittstelle blockiert. Async startet KEINEN neuen Thread. Wie asynchron und wie es funktioniert, gibt es im Internet viele Informationen, daher werde ich auch nicht darauf eingehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie einige große Berechnungen durchführen und gleichzeitig die Schnittstelle nicht blockieren müssen, müssen Sie die Rechenfunktion verwenden (für speziellen Hardcore können Sie Isolate verwenden). </font><font style="vertical-align: inherit;">Dies wird wirklich einen separaten Ausführungsthread starten, der auch einen eigenen separaten Speicherbereich hat (was sehr traurig und traurig ist). </font><font style="vertical-align: inherit;">Sie können mit solchen Streams nur über Nachrichten kommunizieren, die einfache Datentypen und deren Listen enthalten können.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lass uns üben</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulierung des Problems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, die einfachste Anwendung zu schreiben - lassen Sie es eine Art Telefonverzeichnis sein. </font><font style="vertical-align: inherit;">Wir werden Firebase als Speicher verwenden - dies ermöglicht es uns, eine "Cloud" -Anwendung zu erstellen. </font><font style="vertical-align: inherit;">Ich überspringe, wie Firebase mit dem Projekt verbunden wird (es wurde mehr als ein Artikel zu diesem Thema geschrieben, und ich sehe keinen Sinn darin, ihn zu wiederholen. Hinweis: In diesem Projekt wird Cloud Firestore verwendet.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sollte so sein:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsbeschreibung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Anwendung enthält extern:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firebase-Autorisierungsfenster (die Logik dieses Fensters ist in MainBloc enthalten).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationsfenster - Zeigt Informationen zu dem Benutzer an, unter dem das Programm autorisiert ist (die Logik dieses Fensters ist auch in MainBloc enthalten).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzeichnisfenster in Form einer Liste von Telefonen (die Logik dieses Fensters wird in einem separaten PhonebookBloc enthalten sein).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsmenü, das die Bildschirme wechselt.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die interne Anwendung wird wie folgt aufgebaut: Jeder Bildschirm enthält eine Datei mit Bildschirm-Widgets, eine Blockdatei (mit der entsprechenden Blockklasse), eine Aktionsdatei (enthält einfache Klassen, die Ereignisse beschreiben, die den Blockstatus beeinflussen), eine Statusdatei (enthält einfache Klassen, die den Blockstatus widerspiegeln ), die Datei data_model, die die Repository-Klasse (verantwortlich für den Empfang von Daten) und die Datenklasse (speichert Block-Geschäftslogikdaten) enthält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung funktioniert folgendermaßen: Wenn der Bildschirm geöffnet wird, wird der entsprechende Block mit dem Anfangszustandswert initialisiert, und bei Bedarf wird im Blockkonstruktor eine anfängliche Aktion aufgerufen. </font><font style="vertical-align: inherit;">Der Bildschirm wird basierend auf dem Status erstellt / neu erstellt, der den Block zurückgibt. </font><font style="vertical-align: inherit;">Der Benutzer führt einige Aktionen in der Anwendung aus, die über entsprechende Aktionen verfügen. </font><font style="vertical-align: inherit;">Aktionen werden an die Blockklasse übergeben, wo sie in der Funktion mapEventToState verarbeitet werden und der Block den neuen Status an den Bildschirm zurückgibt, auf dessen Grundlage der Bildschirm neu erstellt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst erstellen wir ein leeres Flutter-Projekt und erstellen die Projektstruktur dieser Art (ich stelle fest, dass im Demo-Projekt einige Dateien möglicherweise leer bleiben):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorisierungsfenster. </font><font style="vertical-align: inherit;">Hauptblock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie die Autorisierung in Firebase implementieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Erstellen von Ereignisklassen (es ist praktisch, Daten über Ereignisse im Block zu übertragen) und </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Status </font><font style="vertical-align: inherit;">für den </font><font style="vertical-align: inherit;">Hauptblock </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Datei MainBloc \ Aktionen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datei MainBloc \ Staaten</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Besetzt-Flag in der Statusklasse wird verwendet, um progress_hud in der Schnittstelle anzuzeigen und unnötige Datenlesevorgänge aus der Datenbank auszuschließen, wenn Sie durch die Liste scrollen. </font><font style="vertical-align: inherit;">Bevor alle Operationen im Block beginnen, wird ein neuer Status des alten Typs mit gesetztem Besetzt-Flag an den Ausgabestream ausgegeben. Auf diese Weise erhält die Schnittstelle eine Benachrichtigung, dass die Operation begonnen hat. </font><font style="vertical-align: inherit;">Am Ende des Vorgangs wird ein neuer Status an den Stream gesendet, wobei das Besetztzeichen gelöscht ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erben der MainBlocState-Klasse beschreiben den Status der Hauptanwendung Bloc. </font><font style="vertical-align: inherit;">Die Erben von MainBlocAction beschreiben die darin auftretenden Ereignisse.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die MainBloc-Klasse enthält 4 Hauptelemente - die Funktion zum "Konvertieren" von Ereignissen in Status (Future mapEventToState), der Blockstatus ist _blocState, das Blockstatus-Repository ist das Repo und der Statusstrom "Ausgabe" (welche Schnittstellenelemente verfolgen) ist blocStream. Grundsätzlich sind dies alles Elemente, die eine Block-A-Funktionalität bieten. Manchmal ist es ratsam, zwei Ausgabestreams in einem Block zu verwenden - ein solches Beispiel ist niedriger. Ich werde es hier nicht auflisten - Sie können es sehen, indem Sie das Projekt herunterladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Block-Repository-Klasse enthält die Logik für die Arbeit mit Firebase und ein Objekt (Daten), in dem die Daten gespeichert sind, die für die von diesem Block implementierte Geschäftslogik erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datei MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die MainData-Klasse speichert auch den Status, jedoch den Autorisierungsstatus in Firebase und nicht den Blockstatus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Logik für den Hauptblock geschrieben, jetzt können wir mit der Implementierung des Autorisierungs- / Registrierungsbildschirms beginnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc wird in der Hauptdatei initialisiert: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptdatei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, einen kleinen Exkurs über StreamBuilder, Provider, StreamProvider, Consumer und Selector zu machen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückzug über Anbieter</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - überträgt nur den gespeicherten Wert in den Baum. Und Sie können erst nach dem untergeordneten Build darauf zugreifen, d. H. Sie müssen ein Sub-Widget erstellen. Nicht verantwortlich für die Aktualisierung von Widgets. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ein Widget, das den Stream überwacht und vollständig neu erstellt wird, wenn </font><b><font style="vertical-align: inherit;">ein</font></b><font style="vertical-align: inherit;"> neues Objekt vom Stream </font><b><font style="vertical-align: inherit;">empfangen wird</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ein Widget, das den Stream überwacht und beim Empfang eines neuen Objekts signalisiert, dass die untergeordneten Widgets (die mit der Erstellungsmethode als separate Klasse deklariert werden) neu erstellt werden sollen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbraucher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selektor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind "syntaktischer Zucker", d.h. Dies ist eigentlich ein "Wrapper", der Build enthält und das Widget darunter verbirgt. In Selector-e können Sie Updates zusätzlich filtern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie also bei jedem Ereignis den größten Teil des Bildschirms neu erstellen müssen, können Sie die Option mit Provider und StreamBuilder verwenden. </font><font style="vertical-align: inherit;">Wenn Teile des Widget-Baums in der Nähe der Blätter neu erstellt werden müssen, empfiehlt es sich, StreamProvider in Kombination mit Consumer und Selector zu verwenden, um unnötige Neuerstellungen des Baums auszuschließen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genehmigung </font><font style="vertical-align: inherit;">Fortsetzung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Eingabe der Anwendung muss der Benutzer das Autorisierungs- / Registrierungsfenster aufrufen. Zu diesem Zeitpunkt sollte das Anwendungsmenü noch nicht für ihn verfügbar sein. Der zweite Punkt - das teilweise Aktualisieren dieses Bildschirms ist wenig sinnvoll, daher können wir StreamBuilder zum Erstellen der Benutzeroberfläche verwenden. Und der dritte Punkt im Projekt ist die Verwendung von Navigator zum Navigieren zwischen Bildschirmen. Nach Erhalt eines Ereignisses erfolgreicher Autorisierung muss der Übergang zum Informationsbildschirm aufgerufen werden. Aber nur in Build StreamBuilder wird dies nicht funktionieren - es wird ein Fehler auftreten. Um dies zu umgehen, können Sie die Auxiliary-Wrapper-Klasse StreamBuilderWithListener (Eugene Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist die Auflistung dieses Bildschirms auth_screen selbst (ich werde hier teilweise geben): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datei auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst wird ein StreamBuilderWithListener erstellt, um den Stream vom Block abzuhören. </font><font style="vertical-align: inherit;">Und basierend auf dem aktuellen Status wird entweder das Widget LoggedWidget (wenn der Benutzer bereits angemeldet ist) oder SignInAndSignUpWidget (wenn der Benutzer noch nicht angemeldet ist) aufgerufen. </font><font style="vertical-align: inherit;">Wenn bloc den Status IsLogged zurückgibt, erfolgt der Wechsel zu einem neuen Bildschirm mit dem Navigator nicht im Builder (was zu einem Fehler führen würde), sondern im Listener. </font><font style="vertical-align: inherit;">In den zugrunde liegenden Widgets wird die Schnittstelle basierend auf den hier zurückgegebenen Daten erstellt. </font><font style="vertical-align: inherit;">Hier wird das Provider + StreamBuilder-Bundle tatsächlich verwendet, weil </font><font style="vertical-align: inherit;">Wenn sich der Status des Blocks ändert, ändert sich praktisch die gesamte Schnittstelle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Übertragen von Daten an den Block werden TextEditingController und Aktionsparameter verwendet: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auth_screen-Datei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PhoneBookScreen-Fenster</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt sprechen wir ein wenig über unser PhoneBookScreen-Fenster. Dies ist das interessanteste Fenster - hier basiert die Schnittstelle auf 2 Streams aus dem Block, und es gibt auch eine Liste mit Bildlauf und Paginierung (Paginierung). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ Bildschirmdatei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste StreamProvider wird benötigt, um zwischen verschiedenen Bildschirmen des Verzeichnisses zu wechseln - Liste, Kontaktkarte, Kontaktkarte zum Bearbeiten usw. Das Widget für den Bildschirm wird in der caseWidget-Funktion ausgewählt (in diesem Beispiel wird jedoch nur die Ansicht für die Liste implementiert - Sie können versuchen, die Ansicht für die Kontaktkarte zu implementieren - dies ist sehr einfach und kein schlechter Start.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diesem Bildschirm wird bereits eine Reihe von StreamProvider + Selector / Consumer verwendet, weil Es gibt einen Bildlauf in der Liste, und es ist nicht ratsam, den gesamten Bildschirm neu zu erstellen (d. h. Widgets aus dem entsprechenden Selector / Consumer neu zu erstellen und weiter unten im Baum). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist die Implementierung der Liste selbst: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ Bildschirmdatei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen wir den zweiten StreamProvider, der den zweiten Blockstrom überwacht, der für die Schriftrolle verantwortlich ist. Die Paginierung wird standardmäßig über _scrollListener (Controller: _scrollController) organisiert. Das Fenster ist zwar interessant, aber angesichts der detaillierten Beschreibung des ersten Fensters gibt es hier nichts mehr zu sagen. Deshalb ist das heute alles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ziel dieses Artikels war es nicht, den idealen Code zu zeigen, das heißt, hier finden Sie viele Punkte für die Optimierung - korrekt nach Dateien „aufgeteilt“, Instanz, Mixins und dergleichen irgendwo verwendet. </font><font style="vertical-align: inherit;">Auch was "bettelt" der nächste Schritt - Sie können eine Kontaktkarte erstellen. </font><font style="vertical-align: inherit;">Die Hauptaufgabe bestand darin, das Wissen zu strukturieren, einen bestimmten Vektor für die Erstellung der Anwendung festzulegen und einige der Momente des Entwurfs der Anwendung auf Flutter zu erläutern, die in den ersten Phasen der Bekanntschaft nicht sehr offensichtlich waren. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Projekt kann unter heruntergeladen werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (für die Registrierung können Sie jede E-Mail mit einem Passwort von mindestens 6 Zeichen verwenden. Bei der erneuten Autorisierung muss das Passwort mit dem bei der Registrierung verwendeten übereinstimmen).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489496/index.html">Suche nach Mitarbeitern und Jobsuche: meine Sicht von innen und außen</a></li>
<li><a href="../de489500/index.html">Aufgaben an Story-Punkten bewerten</a></li>
<li><a href="../de489502/index.html">Selen + AutoIT. Windows Test Automation Windows</a></li>
<li><a href="../de489504/index.html">So erstellen Sie eine Karte in UE4</a></li>
<li><a href="../de489510/index.html">Der Versuch, das Problem der Auswahl von Tickets vor Urlaub Nr. 2 zu lösen</a></li>
<li><a href="../de489514/index.html">Laden Sie kostenlos Dateien jeder Größe auf Google Drive herunter und speichern Sie sie. Fehler oder Funktion?</a></li>
<li><a href="../de489516/index.html">Freunde reagieren auf Native und Fastlane</a></li>
<li><a href="../de489518/index.html">Mitgliederaustausch Low-Cost-Austausch erscheint in den USA</a></li>
<li><a href="../de489526/index.html">Nullsummenspiele und Karush-Kun-Takker-Bedingungen</a></li>
<li><a href="../de489528/index.html">Sie sehen während der Entwicklung keine Anzeigen? Störung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>