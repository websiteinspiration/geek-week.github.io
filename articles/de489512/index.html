<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß üö∂üèæ üë©üèª‚Äçüé§ Flattern. BlOC, Provider, Async - Shelf Architecture üßóüèº üêâ üíÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung
 Wenn Sie versuchen, eine Anwendung zu schreiben, sto√üen Sie zun√§chst auf die Organisation der Architektur der Anwendung. Und wenn es um Fl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flattern. BlOC, Provider, Async - Shelf Architecture</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie versuchen, eine Anwendung zu schreiben, sto√üen Sie zun√§chst auf die Organisation der Architektur der Anwendung. </font><font style="vertical-align: inherit;">Und wenn es um Flutter geht, kann sich der Kopf vollst√§ndig um das drehen, was Google herausgibt - Vanille, Scoped Model, BLoC, MVP, MVC, MVVM, MVI usw. </font><font style="vertical-align: inherit;">Angenommen, Sie entscheiden sich f√ºr den modischsten Weg (den von Google im Jahr 2018 empfohlen wurde) und verwenden BLOC. </font><font style="vertical-align: inherit;">Was ist das? </font><font style="vertical-align: inherit;">Wie benutzt man es? </font><font style="vertical-align: inherit;">Oder vielleicht Redux oder RxDart? </font><font style="vertical-align: inherit;">- obwohl es bei der Haltestelle um das "Andere" geht ... Aber wie geht es weiter? </font><font style="vertical-align: inherit;">Welche Bibliotheken m√ºssen verbunden werden? </font><font style="vertical-align: inherit;">Block, Flutter_Block, Block_Muster usw.? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Anzahl von Architekturoptionen und -werkzeugen f√ºr ihre Implementierung kann die Auswahlphase wirklich lange verz√∂gern.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr wen der Artikel</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist in erster Linie f√ºr diejenigen n√ºtzlich, die gerade erst anfangen, Flutter zu lernen und nicht wissen, wo sie anfangen sollen. </font><font style="vertical-align: inherit;">Ich werde eine der Implementierungsoptionen f√ºr Flatteranwendungen zeigen. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie das Flattern ‚Äûf√ºhlen‚Äú und dann selbst entscheiden, wie und mit welchen Anwendungen Sie Ihre Anwendungen schreiben.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muster und Werkzeuge. </font><font style="vertical-align: inherit;">Kurz und einfach</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also fangen wir an. Das erste, was erw√§hnenswert ist, ist, dass es eine Anwendungsarchitektur gibt (Muster, Vorlage, ein Konstruktionskonzept) - dies ist genau das gleiche: BLoC, MVP, MVC, MVVM, MVI usw. Viele dieser Architekturen werden nicht nur in Flutter, sondern auch in anderen Programmiersprachen verwendet. Frage - was zur Auswahl? Meiner Meinung nach m√ºssen Sie ausw√§hlen, was Sie selbst gut wissen, aber nur, wenn dies Reaktivit√§t und eine strikte Trennung der Gesch√§ftslogik von der Benutzeroberfl√§che impliziert (ja, ja - ‚Äûein Auto kann jede Farbe haben, wenn es schwarz ist‚Äú). Die Trennung von Schnittstelle und Gesch√§ftslogik muss meines Erachtens nicht erkl√§rt werden, aber die Reaktivit√§t - versuchen Sie es, wenn Sie es nicht versucht haben - ist am Ende wirklich sehr praktisch und "sch√∂n". Wenn Sie es nicht selbst ausw√§hlen k√∂nnen, lassen Sie es zu, dass es von nicht den d√ºmmsten Leuten von Google - BLOC - f√ºr uns erledigt wird. Wir haben die Architektur herausgefunden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun die Tools - es gibt fertige Bibliotheken - Bloc, Flutter_bloc, bloc_pattern - was ist besser? Ich wei√ü nicht - jeder ist gut. Sie k√∂nnen lange w√§hlen und vergleichen, aber auch hier, wie in der Armee, ist es besser, vorerst eine falsche Entscheidung zu treffen, als keine zu treffen. Und f√ºr den Moment schlage ich vor, nach dem Mod zur√ºckzukehren und Provider zu verwenden (was die gleichen Leute 2019 empfehlen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies erm√∂glicht es uns, je nach Bedarf sowohl einen globalen als auch einen lokalen Block zu bilden. </font><font style="vertical-align: inherit;">Es wurde viel √ºber die Architektur von BLoC geschrieben (n√§mlich ein Muster, keine Bibliotheken). Ich denke, Sie sollten nicht noch einmal im Detail darauf eingehen. </font><font style="vertical-align: inherit;">Ich stelle nur einen Punkt in diesem Artikel fest, es wird kein klassisches BLoC verwendet, sondern leicht modifiziert - in BLoC werden Aktionen (Ereignisse) nicht √ºber Sinks √ºbertragen, sondern BLoC-Funktionen werden aufgerufen. </font><font style="vertical-align: inherit;">Im Moment sehe ich einfach nicht die Vorteile der Verwendung von Waschbecken - und da diese nicht vorhanden sind, warum sollten Sie dann Ihr Leben komplizieren?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronit√§t und paralleles Rechnen in Dart</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es lohnt sich auch, das Konzept der Asynchronit√§t in Dart ein wenig zu kl√§ren, da es sich um Reaktivit√§t handelt. Sehr oft wird in den ersten Phasen der Bekanntschaft mit Dart die Bedeutung von asynchronen Funktionen (asynchron) nicht richtig verstanden. Sie sollten immer daran denken, dass das Programm ‚Äûstandardm√§√üig‚Äú in einem Thread ausgef√ºhrt wird und Sie durch Asynchronit√§t nur die Reihenfolge der Befehle √§ndern k√∂nnen, anstatt sie parallel auszuf√ºhren. Das hei√üt, wenn Sie die Funktion einfach mit gro√üen Berechnungen ausf√ºhren, indem Sie sie als asynchron markieren, wird die Schnittstelle blockiert. Async startet KEINEN neuen Thread. Wie asynchron und wie es funktioniert, gibt es im Internet viele Informationen, daher werde ich auch nicht darauf eingehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie einige gro√üe Berechnungen durchf√ºhren und gleichzeitig die Schnittstelle nicht blockieren m√ºssen, m√ºssen Sie die Rechenfunktion verwenden (f√ºr speziellen Hardcore k√∂nnen Sie Isolate verwenden). </font><font style="vertical-align: inherit;">Dies wird wirklich einen separaten Ausf√ºhrungsthread starten, der auch einen eigenen separaten Speicherbereich hat (was sehr traurig und traurig ist). </font><font style="vertical-align: inherit;">Sie k√∂nnen mit solchen Streams nur √ºber Nachrichten kommunizieren, die einfache Datentypen und deren Listen enthalten k√∂nnen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lass uns √ºben</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulierung des Problems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, die einfachste Anwendung zu schreiben - lassen Sie es eine Art Telefonverzeichnis sein. </font><font style="vertical-align: inherit;">Wir werden Firebase als Speicher verwenden - dies erm√∂glicht es uns, eine "Cloud" -Anwendung zu erstellen. </font><font style="vertical-align: inherit;">Ich √ºberspringe, wie Firebase mit dem Projekt verbunden wird (es wurde mehr als ein Artikel zu diesem Thema geschrieben, und ich sehe keinen Sinn darin, ihn zu wiederholen. Hinweis: In diesem Projekt wird Cloud Firestore verwendet.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sollte so sein:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsbeschreibung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Anwendung enth√§lt extern:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firebase-Autorisierungsfenster (die Logik dieses Fensters ist in MainBloc enthalten).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationsfenster - Zeigt Informationen zu dem Benutzer an, unter dem das Programm autorisiert ist (die Logik dieses Fensters ist auch in MainBloc enthalten).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzeichnisfenster in Form einer Liste von Telefonen (die Logik dieses Fensters wird in einem separaten PhonebookBloc enthalten sein).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsmen√º, das die Bildschirme wechselt.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die interne Anwendung wird wie folgt aufgebaut: Jeder Bildschirm enth√§lt eine Datei mit Bildschirm-Widgets, eine Blockdatei (mit der entsprechenden Blockklasse), eine Aktionsdatei (enth√§lt einfache Klassen, die Ereignisse beschreiben, die den Blockstatus beeinflussen), eine Statusdatei (enth√§lt einfache Klassen, die den Blockstatus widerspiegeln ), die Datei data_model, die die Repository-Klasse (verantwortlich f√ºr den Empfang von Daten) und die Datenklasse (speichert Block-Gesch√§ftslogikdaten) enth√§lt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung funktioniert folgenderma√üen: Wenn der Bildschirm ge√∂ffnet wird, wird der entsprechende Block mit dem Anfangszustandswert initialisiert, und bei Bedarf wird im Blockkonstruktor eine anf√§ngliche Aktion aufgerufen. </font><font style="vertical-align: inherit;">Der Bildschirm wird basierend auf dem Status erstellt / neu erstellt, der den Block zur√ºckgibt. </font><font style="vertical-align: inherit;">Der Benutzer f√ºhrt einige Aktionen in der Anwendung aus, die √ºber entsprechende Aktionen verf√ºgen. </font><font style="vertical-align: inherit;">Aktionen werden an die Blockklasse √ºbergeben, wo sie in der Funktion mapEventToState verarbeitet werden und der Block den neuen Status an den Bildschirm zur√ºckgibt, auf dessen Grundlage der Bildschirm neu erstellt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst erstellen wir ein leeres Flutter-Projekt und erstellen die Projektstruktur dieser Art (ich stelle fest, dass im Demo-Projekt einige Dateien m√∂glicherweise leer bleiben):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorisierungsfenster. </font><font style="vertical-align: inherit;">Hauptblock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen Sie die Autorisierung in Firebase implementieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Erstellen von Ereignisklassen (es ist praktisch, Daten √ºber Ereignisse im Block zu √ºbertragen) und </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Status </font><font style="vertical-align: inherit;">f√ºr den </font><font style="vertical-align: inherit;">Hauptblock </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Datei MainBloc \ Aktionen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datei MainBloc \ Staaten</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Besetzt-Flag in der Statusklasse wird verwendet, um progress_hud in der Schnittstelle anzuzeigen und unn√∂tige Datenlesevorg√§nge aus der Datenbank auszuschlie√üen, wenn Sie durch die Liste scrollen. </font><font style="vertical-align: inherit;">Bevor alle Operationen im Block beginnen, wird ein neuer Status des alten Typs mit gesetztem Besetzt-Flag an den Ausgabestream ausgegeben. Auf diese Weise erh√§lt die Schnittstelle eine Benachrichtigung, dass die Operation begonnen hat. </font><font style="vertical-align: inherit;">Am Ende des Vorgangs wird ein neuer Status an den Stream gesendet, wobei das Besetztzeichen gel√∂scht ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erben der MainBlocState-Klasse beschreiben den Status der Hauptanwendung Bloc. </font><font style="vertical-align: inherit;">Die Erben von MainBlocAction beschreiben die darin auftretenden Ereignisse.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die MainBloc-Klasse enth√§lt 4 Hauptelemente - die Funktion zum "Konvertieren" von Ereignissen in Status (Future mapEventToState), der Blockstatus ist _blocState, das Blockstatus-Repository ist das Repo und der Statusstrom "Ausgabe" (welche Schnittstellenelemente verfolgen) ist blocStream. Grunds√§tzlich sind dies alles Elemente, die eine Block-A-Funktionalit√§t bieten. Manchmal ist es ratsam, zwei Ausgabestreams in einem Block zu verwenden - ein solches Beispiel ist niedriger. Ich werde es hier nicht auflisten - Sie k√∂nnen es sehen, indem Sie das Projekt herunterladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Block-Repository-Klasse enth√§lt die Logik f√ºr die Arbeit mit Firebase und ein Objekt (Daten), in dem die Daten gespeichert sind, die f√ºr die von diesem Block implementierte Gesch√§ftslogik erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datei MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die MainData-Klasse speichert auch den Status, jedoch den Autorisierungsstatus in Firebase und nicht den Blockstatus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Logik f√ºr den Hauptblock geschrieben, jetzt k√∂nnen wir mit der Implementierung des Autorisierungs- / Registrierungsbildschirms beginnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc wird in der Hauptdatei initialisiert: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptdatei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, einen kleinen Exkurs √ºber StreamBuilder, Provider, StreamProvider, Consumer und Selector zu machen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckzug √ºber Anbieter</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - √ºbertr√§gt nur den gespeicherten Wert in den Baum. Und Sie k√∂nnen erst nach dem untergeordneten Build darauf zugreifen, d. H. Sie m√ºssen ein Sub-Widget erstellen. Nicht verantwortlich f√ºr die Aktualisierung von Widgets. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ein Widget, das den Stream √ºberwacht und vollst√§ndig neu erstellt wird, wenn </font><b><font style="vertical-align: inherit;">ein</font></b><font style="vertical-align: inherit;"> neues Objekt vom Stream </font><b><font style="vertical-align: inherit;">empfangen wird</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ein Widget, das den Stream √ºberwacht und beim Empfang eines neuen Objekts signalisiert, dass die untergeordneten Widgets (die mit der Erstellungsmethode als separate Klasse deklariert werden) neu erstellt werden sollen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbraucher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selektor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind "syntaktischer Zucker", d.h. Dies ist eigentlich ein "Wrapper", der Build enth√§lt und das Widget darunter verbirgt. In Selector-e k√∂nnen Sie Updates zus√§tzlich filtern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie also bei jedem Ereignis den gr√∂√üten Teil des Bildschirms neu erstellen m√ºssen, k√∂nnen Sie die Option mit Provider und StreamBuilder verwenden. </font><font style="vertical-align: inherit;">Wenn Teile des Widget-Baums in der N√§he der Bl√§tter neu erstellt werden m√ºssen, empfiehlt es sich, StreamProvider in Kombination mit Consumer und Selector zu verwenden, um unn√∂tige Neuerstellungen des Baums auszuschlie√üen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genehmigung </font><font style="vertical-align: inherit;">Fortsetzung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Eingabe der Anwendung muss der Benutzer das Autorisierungs- / Registrierungsfenster aufrufen. Zu diesem Zeitpunkt sollte das Anwendungsmen√º noch nicht f√ºr ihn verf√ºgbar sein. Der zweite Punkt - das teilweise Aktualisieren dieses Bildschirms ist wenig sinnvoll, daher k√∂nnen wir StreamBuilder zum Erstellen der Benutzeroberfl√§che verwenden. Und der dritte Punkt im Projekt ist die Verwendung von Navigator zum Navigieren zwischen Bildschirmen. Nach Erhalt eines Ereignisses erfolgreicher Autorisierung muss der √úbergang zum Informationsbildschirm aufgerufen werden. Aber nur in Build StreamBuilder wird dies nicht funktionieren - es wird ein Fehler auftreten. Um dies zu umgehen, k√∂nnen Sie die Auxiliary-Wrapper-Klasse StreamBuilderWithListener (Eugene Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist die Auflistung dieses Bildschirms auth_screen selbst (ich werde hier teilweise geben): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datei auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst wird ein StreamBuilderWithListener erstellt, um den Stream vom Block abzuh√∂ren. </font><font style="vertical-align: inherit;">Und basierend auf dem aktuellen Status wird entweder das Widget LoggedWidget (wenn der Benutzer bereits angemeldet ist) oder SignInAndSignUpWidget (wenn der Benutzer noch nicht angemeldet ist) aufgerufen. </font><font style="vertical-align: inherit;">Wenn bloc den Status IsLogged zur√ºckgibt, erfolgt der Wechsel zu einem neuen Bildschirm mit dem Navigator nicht im Builder (was zu einem Fehler f√ºhren w√ºrde), sondern im Listener. </font><font style="vertical-align: inherit;">In den zugrunde liegenden Widgets wird die Schnittstelle basierend auf den hier zur√ºckgegebenen Daten erstellt. </font><font style="vertical-align: inherit;">Hier wird das Provider + StreamBuilder-Bundle tats√§chlich verwendet, weil </font><font style="vertical-align: inherit;">Wenn sich der Status des Blocks √§ndert, √§ndert sich praktisch die gesamte Schnittstelle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum √úbertragen von Daten an den Block werden TextEditingController und Aktionsparameter verwendet: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auth_screen-Datei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PhoneBookScreen-Fenster</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt sprechen wir ein wenig √ºber unser PhoneBookScreen-Fenster. Dies ist das interessanteste Fenster - hier basiert die Schnittstelle auf 2 Streams aus dem Block, und es gibt auch eine Liste mit Bildlauf und Paginierung (Paginierung). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ Bildschirmdatei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste StreamProvider wird ben√∂tigt, um zwischen verschiedenen Bildschirmen des Verzeichnisses zu wechseln - Liste, Kontaktkarte, Kontaktkarte zum Bearbeiten usw. Das Widget f√ºr den Bildschirm wird in der caseWidget-Funktion ausgew√§hlt (in diesem Beispiel wird jedoch nur die Ansicht f√ºr die Liste implementiert - Sie k√∂nnen versuchen, die Ansicht f√ºr die Kontaktkarte zu implementieren - dies ist sehr einfach und kein schlechter Start.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diesem Bildschirm wird bereits eine Reihe von StreamProvider + Selector / Consumer verwendet, weil Es gibt einen Bildlauf in der Liste, und es ist nicht ratsam, den gesamten Bildschirm neu zu erstellen (d. h. Widgets aus dem entsprechenden Selector / Consumer neu zu erstellen und weiter unten im Baum). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist die Implementierung der Liste selbst: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ Bildschirmdatei</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen wir den zweiten StreamProvider, der den zweiten Blockstrom √ºberwacht, der f√ºr die Schriftrolle verantwortlich ist. Die Paginierung wird standardm√§√üig √ºber _scrollListener (Controller: _scrollController) organisiert. Das Fenster ist zwar interessant, aber angesichts der detaillierten Beschreibung des ersten Fensters gibt es hier nichts mehr zu sagen. Deshalb ist das heute alles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ziel dieses Artikels war es nicht, den idealen Code zu zeigen, das hei√üt, hier finden Sie viele Punkte f√ºr die Optimierung - korrekt nach Dateien ‚Äûaufgeteilt‚Äú, Instanz, Mixins und dergleichen irgendwo verwendet. </font><font style="vertical-align: inherit;">Auch was "bettelt" der n√§chste Schritt - Sie k√∂nnen eine Kontaktkarte erstellen. </font><font style="vertical-align: inherit;">Die Hauptaufgabe bestand darin, das Wissen zu strukturieren, einen bestimmten Vektor f√ºr die Erstellung der Anwendung festzulegen und einige der Momente des Entwurfs der Anwendung auf Flutter zu erl√§utern, die in den ersten Phasen der Bekanntschaft nicht sehr offensichtlich waren. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Projekt kann unter heruntergeladen werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (f√ºr die Registrierung k√∂nnen Sie jede E-Mail mit einem Passwort von mindestens 6 Zeichen verwenden. Bei der erneuten Autorisierung muss das Passwort mit dem bei der Registrierung verwendeten √ºbereinstimmen).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489496/index.html">Suche nach Mitarbeitern und Jobsuche: meine Sicht von innen und au√üen</a></li>
<li><a href="../de489500/index.html">Aufgaben an Story-Punkten bewerten</a></li>
<li><a href="../de489502/index.html">Selen + AutoIT. Windows Test Automation Windows</a></li>
<li><a href="../de489504/index.html">So erstellen Sie eine Karte in UE4</a></li>
<li><a href="../de489510/index.html">Der Versuch, das Problem der Auswahl von Tickets vor Urlaub Nr. 2 zu l√∂sen</a></li>
<li><a href="../de489514/index.html">Laden Sie kostenlos Dateien jeder Gr√∂√üe auf Google Drive herunter und speichern Sie sie. Fehler oder Funktion?</a></li>
<li><a href="../de489516/index.html">Freunde reagieren auf Native und Fastlane</a></li>
<li><a href="../de489518/index.html">Mitgliederaustausch Low-Cost-Austausch erscheint in den USA</a></li>
<li><a href="../de489526/index.html">Nullsummenspiele und Karush-Kun-Takker-Bedingungen</a></li>
<li><a href="../de489528/index.html">Sie sehen w√§hrend der Entwicklung keine Anzeigen? St√∂rung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>