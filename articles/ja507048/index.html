<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🍳 🤰🏻 ♌️ Olya、テスト、ファクトリー-美しいアーキテクチャとクリーンなコードへの道 🗿 🐰 ⤵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="テストの自動化には、さまざまなアプローチ、ソリューション、方法があります。最も一般的で不可欠なのは、ページオブジェクト（画面オブジェクト）パターンです。このパターンを操作するときに、ページオブジェクトのファクトリーを使用する方法と使用しない方法の2つのアプローチに遭遇しました。この記事では、自動テス...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Olya、テスト、ファクトリー-美しいアーキテクチャとクリーンなコードへの道</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/507048/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストの自動化には、さまざまなアプローチ、ソリューション、方法があります。</font><font style="vertical-align: inherit;">最も一般的で不可欠なのは、ページオブジェクト（画面オブジェクト）パターンです。</font><font style="vertical-align: inherit;">このパターンを操作するときに、ページオブジェクトのファクトリーを使用する方法と使用しない方法の2つのアプローチに遭遇しました。</font><font style="vertical-align: inherit;">この記事では、自動テストの例を使用して、両方の長所と短所を比較します。</font><font style="vertical-align: inherit;">ページオブジェクトのファクトリがどのように見えるかを紹介しましょう。</font><font style="vertical-align: inherit;">また、工場での自動テストで発生した問題とその解決方法についてもお話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swiftの記事のすべての例を引用しますが、Android自動テストの場合、すべてが同じように機能します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ci/5e/br/ci5ebr0v9onedivfawpjjy-ux0c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始めること</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは私の名前はオリヤです。私はhh.ruのモバイルアプリケーションテスターです。 2年間、テール付きで、手動テストの90％を自動化に移行しました。この間、私たちはさまざまな落とし穴に何度も遭遇し、何百もの紛争を議論することができました。今、私は自分の経験を世界と共有したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android（Kotlin、Kaspresso）およびiOS（Swift、XCUITest）で自動テストを作成します。個々のスクリプトのみをチェックして、UIテストを小さくしようとしています。これには鉄の利点で十分であり、各プラットフォームでの300〜400のUIテストの回帰には平均30〜40分かかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テストでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページオブジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンを使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。彼については何千もの記事が書かれているので、これ以上詳しくは触れません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
歴史的に、iOSとAndroidで最初の自動テストを作成するとき、ページオブジェクトを操作するためにさまざまなアプローチを選択しました。</font><font style="vertical-align: inherit;">Androidではパターンに従うだけで、iOSではページオブジェクトのファクトリーも作成しました。</font><font style="vertical-align: inherit;">ファクトリは、すべてのページオブジェクトが初期化される場所です。</font><font style="vertical-align: inherit;">これを使用して、画面のメソッドで他のページオブジェクトを転送し、アプリケーションの動作に似た一連の対話を構築できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファクトリにはページオブジェクトが必要ですか？&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何百ものテストケースを作成した後、ページオブジェクトのファクトリを使用することは、自動テストを作成するテスターに​​とって好みの問題であるという結論に達しました。さまざまなアプローチを使用しても、パフォーマンスと安定性に違いはありません。ただし、将来ネイティブコードに悩まされないようにするには、自動テストのアーキテクチャにページオブジェクトファクトリの場所を設けるかどうかをできるだけ早く決定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、同じテストの2つの例を示します。それは、ファクトリーを使用した場合と使用しない場合です。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテストの内容：アプリケーションのメイン画面から、ユーザーはプロファイルタブに移動しようとします。プロファイルで、「ログイン」を選択し、次にログインによるログイン方法を選択してユーザー名とパスワードを入力し、「ログイン」ボタンをクリックします。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{
   <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
   <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
   <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
   <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        mainScreen.openProfileTab()<font></font>
        profileScreen.goToAuthorization()<font></font>
        authorizationScreen.goToLogin()<font></font>
        loginScreen<font></font>
           .enterLogin(user.login)<font></font>
           .enterPassword(user.password)<font></font>
           .logIn()   <font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openProfileTab()<font></font>
            .goToAuthorization()<font></font>
            .goToLogin()<font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .logIn()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例の後で、ファクトリーなしのテストが見栄えが良いと判断した場合は、それなしで取得して書き込みます。</font><font style="vertical-align: inherit;">このヒントは、繰り返しのないさまざまなコンテンツや要素を含む、非常に大きなアプリケーションがない場合に特に関係があります。</font><font style="vertical-align: inherit;">または、10〜15ステップ以下のテストを作成する場合。</font><font style="vertical-align: inherit;">この場合、工場はその天候を行いません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これが当てはまらない場合、または工場テストが心の中で反応した場合、この記事はあなたのためです。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/g4/zc/qeg4zcjbcn8z9yrhq83bmteoz8k.jpeg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの工場はどのように見えますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページオブジェクトファクトリの目的、外観、機能を理解しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準テストケースは一連のステップです。</font></font><br>
<blockquote><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションを起動します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイル画面を開く</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ログイン」をタップします</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログインとパスワードを使用してログイン方法を選択します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーデータ（ユーザー名とパスワード）を入力します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ログイン」ボタンをタップ</font></font></li>
</ol><br>
</blockquote><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリーンキャストテスト</font></font></b>
                        <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYHsgZiJgo8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストケースの各ステップは、自動テストのステップに対応しています。各ステップは、対応する画面の個別のページオブジェクトメソッドであるとも言えます。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テストでこのテストケースを正確な手順で繰り返したい場合は、メソッド呼び出しの同じ連続したチェーンを構築するには、各メソッドが次の画面のページオブジェクトを返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページオブジェクトを作成するときは、初期化する必要があります。他の内部にページオブジェクトを作成する場合、各ページオブジェクトに多くの同一の初期化があることがわかります。これを行わないために、すべてのページオブジェクトの初期化は、ファクトリ-pageObjectFactory（またはscreenFactoryなど）に移動されます。各メソッドの最後に、必要な画面を作成するようファクトリに要求します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goToAuthScreen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {<font></font>
        openAuthButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAuthPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのページオブジェクトは、メインパラメータを含むBasePageObjectから継承されます。</font><font style="vertical-align: inherit;">その中で、ファクトリーがその相続人のいずれかを作成できるように、必要なコンストラクターを規定する必要があります。</font><font style="vertical-align: inherit;">この場合、基本クラスは次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePageObject</span> </span>{
    <span class="hljs-keyword">let</span> pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>
    <span class="hljs-keyword">let</span> application: <span class="hljs-type">XCUIApplication</span><font></font>
 <font></font>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
                       application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-keyword">self</span>.pageObjectsFactory = pageObjectsFactory
        <span class="hljs-keyword">self</span>.application = application<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ファクトリーの画面の初期化は次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initializePageObject</span>&lt;PageObject: BasePageObject&gt;<span class="hljs-params">(ofType type: PageObject.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">PageObject</span> {
        <span class="hljs-keyword">return</span> type.<span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAuthPageObject</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {
        <span class="hljs-keyword">return</span> initializePageObject(ofType: <span class="hljs-type">AuthPageObject</span>.<span class="hljs-keyword">self</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、どのページオブジェクトのメソッドでも、それを初期化する画面を作成するファクトリメソッドを呼び出すことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工場のないテスターの人生のプラス</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.テストから、アクションが実行される画面は常に明確です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工場が</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない場合、</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font><s><font style="vertical-align: inherit;">ポイントのみの</font></s><font style="vertical-align: inherit;">各行</font><s><font style="vertical-align: inherit;">に</font></s><font style="vertical-align: inherit;">、画面とその上で行われるアクションが明確に登録されます。</font><font style="vertical-align: inherit;">これにより、デバッグや修正中など、テストコード全体を最初から読み取らないようにすることができます。</font><font style="vertical-align: inherit;">ファクトリーがないため、特にアクションまたはチェックが1つの画面で実行される場合に、読みやすさが向上します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span> : <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">//   ,   </span>
    <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
    <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
    <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
    <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser() <span class="hljs-comment">//   </span><font></font>
 <font></font>
        mainScreen.openProfileTab() <span class="hljs-comment">//      </span>
        profileScreen.goToAuthorization() <span class="hljs-comment">//     ""</span>
        authorizationScreen.goToLogin() <span class="hljs-comment">//          </span>
        loginScreen <span class="hljs-comment">//           </span><font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .login()   <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションのすべての複雑さにあまり慣れていない場合でも、上記の例から、EnterLogin / EnterPasswordアクションが同じ画面で実行されることがすぐにわかります。</font><font style="vertical-align: inherit;">ファクトリーでのテストはそれほど明確ではありません-enterLoginアクションがユーザーを次の画面に転送したと思うかもしれません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.異なる画面につながる可能性のあるアクションを含むテストを作成する方が便利です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリを使用せずにテストを作成する場合、アプリケーションの状態に応じてユーザーアクションが異なる動作をする可能性があることを考える必要はありません。発生していることのロジックを記述するだけです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        </span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    authScreen.authUser(user)<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//       	</span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリーページオブジェクトの場合、ユーザーの承認に応じて、目的の画面をtapResponseButton（）メソッドで返す（またはtapResponseButtonAndLogin（）などのメソッドを複製する）方法を考える必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButton</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButtonAndLogin</span><span class="hljs-params">(login: String)</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        pageObjectsFactory<font></font>
            .makeAuthorizationPageObject()<font></font>
            .goToLogin()<font></font>
            .logIn(login)<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じボタンをタップするという事実にもかかわらず、この画面には6つの類似したメソッドがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.各アクションと各チェックを個別のメソッドでラップする必要はありません</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリのないページオブジェクトのメソッドは、チェーンを続行するために次の画面に戻る必要はありません。それぞれ、個別のアクションに対して、個別のメソッドを作成することはできません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ファクトリのないテストでボタンをタップすると、次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs">    vacancyScreen.responseButton.tap()</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.複雑なソリューションについて考える必要はなく、さらにページオブジェクトのアーキテクチャについて考える</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の経験では、ファクトリを使用せずに自動テストを作成する場合、ページオブジェクトに実質的に問題はありません。</font><font style="vertical-align: inherit;">新しいページオブジェクトの記述は、簡単で高速なプロセスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工場とその機能は、後で説明するいくつかの困難を追加します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工場の疑いのない利点</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.テストの作成中、ステップをスキップする方法はありません</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページオブジェクトのすべてのメソッドは、1つのチェーンのリンクです。新しい各リンク（メソッド）は、以下と連動する必要があります。これは、すべてのメソッドが（自分自身または別の）ページオブジェクトを返すという事実によるものです。そのため、テストを作成するときに、画面のメソッドを選択する方法がなく、次のものしかありません。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、新しいテスターに​​よる最初の自動テストの書き込みを大幅にスピードアップします。 IDE自体は、さらに実行できるアクションと画面を通知します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2に、この自動テストのアーキテクチャでは、アプリケーションを作成することでアプリケーションを認識でき、その逆はできません。 （再び-若いテスターに​​とって良い動機）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目に、スクリプトを正しく渡すまで目的のメソッドが表示されないため、ステップをスキップする方法はありません。</font><font style="vertical-align: inherit;">このような省略は、ファクトリを使用せずにテストを作成する場合に非常に一般的であり、テストを実行するときにのみわかります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.ページオブジェクトメソッドのシグネチャを変更すると、IDEはオブジェクトに関連付けられているすべてのテストを強制的に変更します。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアイテムは前のアイテムの続きです。</font><font style="vertical-align: inherit;">すべてのページオブジェクトメソッドは、アプリケーションのロジックと動作を繰り返します。</font><font style="vertical-align: inherit;">アプリケーションが画面間の遷移のロジックを変更したり、新しい画面を追加したりする場合は、必要なメソッドを修正して戻り値を変更します。</font><font style="vertical-align: inherit;">工場でのセルフテストでは、この変更の影響を受けるすべてのテストを見つけるために、すべてのテストを実行する必要はありません。</font><font style="vertical-align: inherit;">IDE自体は、「チェーン」が壊れたすべての場所を指し示します。</font><font style="vertical-align: inherit;">工場のないテストはこれに従いません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.アーキテクチャとコードのクリーンさは、余分な画面オブジェクトの作成の影響を受けません。&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリを使用せず、テストが数十の画面を介してスクリプトを通過する場合、テストを含むクラスの最初に、各画面のオブジェクトを作成するためのブロック全体を記述する必要があります。</font><font style="vertical-align: inherit;">また、テストのクラスごとに毎回これを行う必要があります。</font><font style="vertical-align: inherit;">同じクラスで複数のテストを作成すると、さらに悪化します。</font><font style="vertical-align: inherit;">次に、すべてのページオブジェクトの作成に伴うこの「ブロック」のサイズが大幅に増加します。&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが欠員に応答し、ログアウトして別のユーザーにログインする実際のテストの例。</font><font style="vertical-align: inherit;">このブロックは、クラス間を移動し、同様のすべてのテストでわずかな変更が加えられます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterUpdateAfterOtherUserLoginTest</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> mainScreen = <span class="hljs-type">MainScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> vacanciesScreen = <span class="hljs-type">VacanciesScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> responseToVacancyScreen = <span class="hljs-type">ResponseToVacancyBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> successResponseBottomSheet = <span class="hljs-type">SuccessResponseBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> settingsScreen = <span class="hljs-type">UserSettingsScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> chooseAuthScreen = <span class="hljs-type">ChooseAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> authScreen = <span class="hljs-type">NativeAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> navigation = <span class="hljs-type">NavigationPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> moreScreen = <span class="hljs-type">MoreScreenPageObject</span>()<font></font>
<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遅延初期化を使用して、テストの基本クラスのすべてのページオブジェクトを初期化するオプションがあります。</font><font style="vertical-align: inherit;">その後、各テストですべての画面が使用可能になり、不要なオブジェクトは作成されません。</font><font style="vertical-align: inherit;">しかし、別の画面を通過するメソッドを作成する必要がある場合に、ページオブジェクト自体にページオブジェクトを作成する場合、多くの画面のリストに関する問題が再発します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリは、必要なときに必要なページオブジェクトを初期化するタスクを引き受けます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.アプリケーションコードをさらに詳しく調べ、そのアーキテクチャ、モジュール、それらの相互作用などを研究する絶好の機会。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページオブジェクトのファクトリを使用するには、次の画面を返すメソッドで、すべてのアクションを画面でラップする必要があります。</font><font style="vertical-align: inherit;">このため、ページオブジェクトは大幅に拡大しており、すべてをより美しく正確にするにはどうすればよいのか不思議に思います。</font><font style="vertical-align: inherit;">このために、アーキテクチャー技術を使用して、アプリケーションコードでのさまざまな画面の実装を監視し、モジュールの相互作用を追跡して、自動テストで同様のシステムを構築します。これは、快適で使いやすいものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おまけとして、内部からアプリケーションがどのように機能するかについての知識を得ます。</font><font style="vertical-align: inherit;">これは少なくとも、全体的な開発に役立ち、多くの場合、テスト時に非常に役立ちます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.テストコードは非常にきれいできれいに見えます。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コメントはありません、これは本当に風味があります。</font><font style="vertical-align: inherit;">どのように「より正確でよりきれい」かは、最初の例で決めることができます。</font></font><br>
<br>
<p></p><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">落とし穴//彼らがつまずき、周りを回った方法</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/4a/jz/gd4ajzpobkjvg6t4tq1vy-3a-ws.jpeg" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テストを作成するときは、ページオブジェクトのファクトリーを使用する方が良いと結論付けることができます。</font><font style="vertical-align: inherit;">彼らがファクトリーを使用する理由を誰にも尋ねないでください。「そして、あなたはそれなしでテストを書いて比較しようとする」という常に1つの答えがあります。</font><font style="vertical-align: inherit;">ファクトリーは、タスクのかなりの部分、自動テストのシーケンスにエラーがないことなどの責任を実際に担っています。</font><font style="vertical-align: inherit;">それはまた、私が上で書いたいくつかの興味深い機会を開きます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私はこれらすべての機能が常にばかげているわけではないことに注意したい。</font><font style="vertical-align: inherit;">工場での自動化の際に、非常に不快な問題に遭遇しましたが、最終的には解決しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション全体に共通のプロトコルと要素</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのモバイルアプリケーションにも、どの画面からでもアクセスできる要素があります。たとえば、タブバー（メニュー）を取ることができます。問題が発生します。ページオブジェクトメソッドへの呼び出しのチェーンを中断せずに、テスト中にいつでもタブバーのメソッドにアクセスするにはどうすればよいですか。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も明白で最初の決定は、これらのメソッドを使用してページオブジェクトの基本クラスを拡張することです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-comment">/*
      .
 */</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> tabBar = application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch
    <span class="hljs-keyword">var</span> searchTab =  tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスカッション中に、すべての画面で必要な要素はタブバーだけではないことに気付き、拡張機能を追加することで、基本クラスがすぐに整理されるという結論に達しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションのもう1つの欠点は、メソッドがすべてのページオブジェクトで使用可能になることですが、これは誤りです。これは、理論的にはそれらに固有のメソッドのみを含むべきである相続人クラスの契約を破ります。たとえば、ページアラートオブジェクトの場合、タブバーメソッドは必要ありません。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的な解決策-TabbarのページオブジェクトからTabBarUsableプロトコルを作成しました（Kotlinのインターフェイスも同様です）。そして、彼らはその拡張（拡張、実装）を作成しました。これにより、コードを複製せず、同時に継承をコンポジションに置き換えることができます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TabBarUsable</span> </span>{
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span><font></font>
    …<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TabBarUsable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tabBar: <span class="hljs-type">XCUIElement</span> { application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch }
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タブバーがあるすべての画面で、このプロトコルへの準拠を追加します（準拠）。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、タブバーを操作するすべての方法が、これらのすべての画面で使用できるようになります。&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTabbarTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleOpenSearchTab</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy() <span class="hljs-comment">//   .makeVacancyPageObject()</span>
            .openSearchTab() <span class="hljs-comment">//   TabBarUsable </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、アーキテクチャは壊れず、タブバーのメソッドは必要な画面でのみ使用でき、同じメソッドのコードは複製されません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコルとコード改訂</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、ページオブジェクトファクトリを使用すると、すべてのアクションとすべてのチェックがメソッドにラップされます。</font><font style="vertical-align: inherit;">しばらくして、次の自動テストを作成すると、各ページオブジェクトに同じメソッドを記述していることに気づき始めます。これらのメソッドは、要素に違いさえありません。</font><font style="vertical-align: inherit;">このようなメソッドの例としては、ゼロスクリーンチェック、異なる画面で同じリストアイテムを操作するなどがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/a2/xg/ic/a2xgiczqetidmsoqa2rl2aandjo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理的な考えがあります：「もっと簡単にしましょうか！」コードの複製を停止する方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がすでに書いた最初のメソッドは、そのようなメソッドをすべて基本クラスに入れることです。それは可能ですが、非常に慎重に行ってください。まず、このプロセスは非常に魅力的です。基本クラスの1つのメソッドは何も台無しにしないようですが、遅かれ早かれ、基本クラスは耐えられず、構造化されず、散らかったモンスターになり、要するに、完全に実行不可能になります。私たちは試しました、知っています。このモンスターを取り除くことは、すぐに正しく行うよりもさらに困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間が経つにつれて、DRY（Do n't Repeat Yourself）の原理が理由のために発明されたことに気づきました。多くのページオブジェクトで使用されているものと同じメソッドを探し始めました。それらを見つけて、彼らは長い間、これらの方法がどこでも本当に同じように使用され、同じロジックを持っているかどうかを議論しました。そして最後に、方法の80％で同じ方法を使用する場合は、別のプロトコルで取り出す必要があると決定しました。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングされた最初のメソッドの1つは、waitView（）メソッドでした。特別なプロトコルViewWaitableとその実装をプロトコル拡張で説明しましたが、このメソッドをページオブジェクトで使用できるようにするには、プロトコルへの適合（適合）を追加するだけです。ビュー識別子はすべての画面で異なるため、プロトコルを使用するすべてのページオブジェクトは、それ自体でビューを宣言する必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewWaitable</span> </span>{
    <span class="hljs-keyword">var</span> view: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewWaitable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-meta">@discardableResult</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitView</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {<font></font>
        testWaiter.waitForElementToAppear(view)<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span>, <span class="hljs-title">ViewWaitable</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application.otherElements[<span class="hljs-type">Accessibility</span>.view].firstMatch<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hh.ruアプリケーションの別の例：多くの異なる画面に表示される空席のリストがあり、このリストが表示されるビューIDが唯一のIDです。このリストには、多くのアクションと大量のチェックが関連付けられています。それらに約10（このリストが表示される画面の数）を掛けて、コードの重複の規模を推定します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は再びプロトコルでした。プロトコルをさらに理解しやすく使用するために、リスト要素（VacancyListContainig）、セル要素（VacancyCellContainig）、チェック付きのメソッド（アサート、チェック）、および対話メソッド（アクション）を分割しました。この分離により、巨大なページオブジェクトのコンテンツの可読性の問題が完全に解決されました。最終的なアーキテクチャは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sx/zw/_j/sxzw_jfnqwufs2snkgohmzxawb4.png" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空席のリストが存在するページオブジェクトは、VacancyListPageObjectプロトコルへの準拠を追加できます。</font><font style="vertical-align: inherit;">したがって、このプロトコルの実装からのすべてのメソッドは、コードの重複なしに画面で使用できるようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchResultPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">ViewWaitable</span>, <span class="hljs-title">VacancyListPageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application<font></font>
        .otherElements[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.view].firstMatch
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> listView = application<font></font>
        .tables[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.tableView].firstMatch<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、DRYの原則に従うため、非常にクリーンできれいなページオブジェクト、同じメソッド名、および余分なコードがありません。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる画面で同じアラート//ソース</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムエラー、アラート、ボトムシートはリグレッションの不可欠な部分であり、自動テストで確実にカバーしたいと思います。エラーとアラートは、さまざまな画面で、さまざまなケースで、さまざまなアプリケーションの状態で発生しますが、要素自体は基本的に同じ識別子と動作を持っています。明らかに、2つのボタンを持つ同じタイプのアラート（たとえば、[OK] / [キャンセル]）は、1つの個別のページオブジェクトです。&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド呼び出しのチェーンを中断しないという願望に戻ります。同じアラートを開くことができる数十の画面があります。そのようなアラートを閉じるときは、それが開かれた元のページオブジェクトに戻る必要があります。同時に、これらの非常に多くの重複するメソッドを、そのようなアラートのページオブジェクトに記述したくありません。これらのメソッドは、返されるページオブジェクトのみが互いに異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単な解決策は、テストのスコアリングとブレークを1回行うことです。</font><font style="vertical-align: inherit;">それにも問題はありません。</font><font style="vertical-align: inherit;">だから、人生ははるかに単純です。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExample</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .closeAlert() <span class="hljs-comment">//      ,     </span><font></font>
        pageObjectFactory<font></font>
            .makeVacancyPageObject() <span class="hljs-comment">//   </span><font></font>
        …<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのソリューションはより複雑ですが、それがどれほど美しいかです！</font><font style="vertical-align: inherit;">アラートタイプパラメータ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のページオブジェクトを追加しました</font><font style="vertical-align: inherit;">。これは、アラートを開くページオブジェクトのタイプになります。</font><font style="vertical-align: inherit;">この場合、この画面のページオブジェクトは、初期化時にページオブジェクトアラートに渡され、汎用ソース変数として保存されます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように機能するかについての詳細：アラートを開いて（そして初期化して）いるとき、目的の画面をソース汎用変数に渡します。</font><font style="vertical-align: inherit;">これは、アラートを開くページオブジェクトメソッドで行われます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">VacancyPageObject</span>&gt; {<font></font>
        button.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAlertPageObject(from: <span class="hljs-keyword">self</span>) <span class="hljs-comment">//  source VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このソース（この例ではVacancyPageObject）は、テストに必要なすべてのメソッドを通過し、最終的にdismissAlert（）になります。</font><font style="vertical-align: inherit;">その結果、アラートを閉じるメソッドは必要な画面を返し、すぐにテストを続行できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dismissAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Source</span> {<font></font>
        cancelButton.tap()<font></font>
        <span class="hljs-keyword">return</span> source <span class="hljs-comment">//  ,     — VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、ページオブジェクトが必要な画面（ソース）を受け取って返すことができるように、ページオブジェクトの基本タイプに限定されたジェネリックタイプを割り当て、ページオブジェクトを使用して初期化する必要があります。ページオブジェクトは、最後に返す必要があります。 ：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-comment">// generic-          </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> source: <span class="hljs-type">Source</span><font></font>
 <font></font>
    <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
         application: <span class="hljs-type">XCUIApplication</span>,<font></font>
         source: <span class="hljs-type">Source</span>) {
        <span class="hljs-keyword">self</span>.source = source
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-comment">//  BasePageObject   ,      </span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>, application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"init(pageObjectsFactory:application:) has not been implemented. Use another init"</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリーでの汎用ページオブジェクトの初期化は次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAlertPageObject</span>&lt;Source: BasePageObject&gt;<span class="hljs-params">(
        from source: Source
    )</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">Source</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-type">AlertPageObject</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>,<font></font>
                                          application: application,<font></font>
                                          source: source)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターダー！</font><font style="vertical-align: inherit;">すべてが準備できたので、コールチェーンを中断することなくテストを続行できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleSourcesTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleSource</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .dismissAlert()<font></font>
            .checkVacancyScreenIsOpened() <span class="hljs-comment">//       ,         </span><font></font>
        …<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/rt/hs/gnrthsrb0jerc7jtimpsmfqeryw.jpeg" width="70%"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巨大なページオブジェクト、それを理解する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面はありますが、さまざまなコンテンツ、さまざまなインターフェース要素、個々の論理ブロックをホストします。同時に、それらはすべて同じ画面上にあり、この画面を説明するページオブジェクトを介してそれらと対話したいと思います。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、モバイルアプリケーションのメイン画面を見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2a/bc/v8/2abcv8sw0r9idx5m53mrj7hcf8u.jpeg" width="40%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この画面は、3つの完全に独立したセクションに分割できます。検索バー、検索履歴ブロック、および求人リストのタブです。 1つのページオブジェクトですべてを説明することは可能です（結局のところ、これは独立した本格的な画面です）。各セクションには独自のロジックや独自のチェックなどがあるため、これを使用するのはあまり便利ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ページオブジェクトを展開すると、遅かれ早かれ、メソッド名の問題が発生します。多くの異なるセル、タイトル、サブタイトルなどがあります。その結果、単純な名前の代わりに、それらが正確にどのようなものであるかを明確にして、長い名前を付ける必要があります。テストを書くことは非常に不便で困難になります。テストでメソッドを選択するたびに、ページオブジェクトコードを開いて、間違えないように慎重に調べる必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyListPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListCellByTitleExists</span><span class="hljs-params">(title: String)</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertRecommendationsListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertVacancyNearbyListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }<font></font>
    …  <font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ia/_g/zwia_gz_wjygrw7tpmis1_gnx8q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単な解決策は、問題を見ないことです。ページオブジェクトがどれほど大きくても、それを使用できます（特に慣れている場合）。でも、慣れたくありませんが、美しくて快適にしたいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、これらの「セクション」はコード内の異なるモジュールにすることができます。つまり、アプリケーションの異なる画面で再利用できます。ページオブジェクトを使用して同様のアーキテクチャを構築する場合、それらを再利用することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは強い意志で決断しました。今ではそのようなセクションのために、ページオブジェクトのさまざまなクラスを作成しています。それらのそれぞれに、統一された空のMainScreenSectionプロトコルに対応を追加します：BasePageObject {}。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、メイン画面の検索履歴セクションを見てください。そのページオブジェクトは次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchHistoryPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">MainScreenSection</span> </span>{
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的に、メイン画面を説明するMainScreenPageObjectのページオブジェクトは、テストからどのセクションで今すぐ何かを実行するかを示すメソッドを作成しました。</font><font style="vertical-align: inherit;">こんな感じです。&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">section</span>&lt;Section: MainScreenSection&gt;<span class="hljs-params">(<span class="hljs-number">_</span> section: Section.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">Section</span> {
        <span class="hljs-keyword">return</span> section.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドでは、セクションのタイプを渡します。内部では、ジェネリックファクトリメソッドを使用してページオブジェクトを初期化します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、テストが中断されず、巨大なページオブジェクトの不必要な初期化が行われず、コードが読みやすくなりました。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        “ ”</span>
    .openSearchTab() <span class="hljs-comment">//   MainScreenPageObject</span>
    .section(<span class="hljs-type">SearchHistoryPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//     </span>
    .waitHistoryIsLoad() <span class="hljs-comment">//   page object-  </span>
    .section(<span class="hljs-type">MainScreenPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//       </span>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まとめる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページオブジェクトのファクトリなしで自動テストを記述できます。このアプローチのページオブジェクトは、特に複雑な初期化を必要としない場合、非常に迅速かつ簡単に記述されます。しかし、その一方で、テストを作成するときは、非常に注意する必要があります。テストの一連のステップ、ページオブジェクトの初期化、一部のアクションに対するラッパーの欠如などの責任は、テスターに​​あります。アプリケーションがそれほど複雑でない場合は、複雑にする価値はなく、リストされているすべての問題は一般的に見えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の段階で、ファクトリーの作成について少し考えてみると、将来的には、最初に上記のすべての責任を負うことになります。次に、自動テストを作成するプロセスが非常にシンプルになり、ほとんどエラーの可能性がなくなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/i6/ta/uci6takmotdv_r0ujdl5kbv3_3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一の正しい決定はないので、決定するのはあなた次第です。</font><font style="vertical-align: inherit;">私たちは両方のアプローチを使い続けており、誰もが快適で元気です。</font><font style="vertical-align: inherit;">幸運と美しい自動テスト！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク：</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページオブジェクトパターンに関する記事</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動化におけるアーキテクチャの役割に関するクールな記事</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AndroidでのKotlin DSL、Fixtures、エレガントなUIテスト</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイス、プロトコル、および拡張機能/ Swiftと </font><font style="vertical-align: inherit;">コトリン</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swiftにおけるジェネリックの力</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja507032/index.html">「ポートフォリオを売る。デザイン学校で教えられていないこと」</a></li>
<li><a href="../ja507034/index.html">DockerコンテナーからのWebstorm NodeJsインタープリター</a></li>
<li><a href="../ja507040/index.html">強制賠償責任保険のもとでの損害の登録を数日から60分に減らす方法</a></li>
<li><a href="../ja507042/index.html">私はgamedevにしたい：8人のプロからの27件の返信</a></li>
<li><a href="../ja507044/index.html">SoC'om MCUおよびFPGAを試すための最も手頃なボード</a></li>
<li><a href="../ja507050/index.html">中空騎士のゲームデザインの分析。パート1.忘れられた交差点</a></li>
<li><a href="../ja507052/index.html">最もクールなデータサイエンティストは統計に時間を無駄にしません</a></li>
<li><a href="../ja507066/index.html">Google広告の広告を自動化する10の方法</a></li>
<li><a href="../ja507068/index.html">Windows Management Instrumentation（WMI）ガイド：WMI攻撃について</a></li>
<li><a href="../ja507074/index.html">SIMDチートシート、.NET Core用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>