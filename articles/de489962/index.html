<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏻 👨🏽‍🎓 👩🏾‍🤝‍👨🏼 Datenverteilung in Apache Ignite 🥝 ↩️ 🕡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Dieser Beitrag ist eine leicht gekürzte Version meines gleichnamigen Vortrags beim Apache Ignite- Community-Meeting . Sie können die vollständi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Datenverteilung in Apache Ignite</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/489962/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo! </font><font style="vertical-align: inherit;">Dieser Beitrag ist eine leicht gekürzte Version meines gleichnamigen Vortrags beim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Ignite-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Community-Meeting </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie können </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vollständige Videoversion mit Fragen und Antworten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier ansehen</font></a><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folien </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier herunterladen</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In dem Bericht habe ich versucht, anhand von Beispielen zu zeigen, wie Daten in Apache Ignite verteilt werden.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum müssen Sie etwas verteilen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ziemlich normale Geschichte der Entwicklung eines Systems, das Datenspeicherung und -verarbeitung erfordert, ist das Erreichen einer bestimmten Obergrenze. Entweder gibt es viele Daten und sie werden nicht physisch auf dem Speichergerät abgelegt, oder die Last wächst so schnell, dass ein Server eine solche Anzahl von Anforderungen nicht mehr verarbeiten kann. Es gibt häufige Fälle, in denen beide auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Regel gibt es eine von zwei Lösungen: entweder das Sharding des vorhandenen Speichers oder das Wechseln zu einer verteilten Datenbank. Beide Lösungen haben eine Reihe gemeinsamer Merkmale, von denen das offensichtlichste die Verwendung von mehr als einem Knoten für die Arbeit mit Daten ist. Außerdem werde ich viele Knoten Topologie nennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem der Datenverteilung zwischen Topologieknoten kann als eine Reihe von Anforderungen formuliert werden, die unsere Verteilung erfüllen muss:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird ein Algorithmus benötigt, mit dem alle Knoten der Topologie und der Clientanwendungen zu derselben Schlussfolgerung gelangen können, auf welchem ​​Knoten oder welchen Knoten sich das bestimmte Objekt (oder der bestimmte Schlüssel) befindet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichmäßige Verteilung. </font><font style="vertical-align: inherit;">Je gleichmäßiger die Daten auf die Knoten verteilt sind, desto gleichmäßiger wird die Belastung dieser Knoten verteilt. </font><font style="vertical-align: inherit;">Hier gehe ich davon aus, dass unsere Knoten ungefähr die gleichen Ressourcen haben.</font></font></li>
<li>  .      ,       ,    .   ,       ,       ,     .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erreichen der ersten beiden Anforderungen ist ziemlich einfach. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bekannter Ansatz, der häufig beim Lastausgleich zwischen funktional äquivalenten Servern verwendet wird, indem Modulo N geteilt wird, wobei N die Anzahl der Knoten in der Topologie ist und wir eine Eins-zu-Eins-Entsprechung zwischen der Knotennummer und ihrer Kennung haben. Dann müssen wir nur noch den Schlüssel des Objekts als numerischen Wert unter Verwendung einer Hash-Funktion darstellen und den Rest der Division durch N vom erhaltenen Wert nehmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zi/7x/ii/zi7xiiu8xmrjgaeghuc8xkekubk.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Diagramm zeigt die Verteilung von 16 Schlüsseln auf 3 Knoten. Es ist ersichtlich, dass diese Verteilung einheitlich ist und der Algorithmus zum Erhalten des Knotens für das Objekt einfach ist und garantiert, dass, wenn alle Knoten der Topologie diesen Algorithmus verwenden, dasselbe Ergebnis für denselben Schlüssel und dasselbe N erhalten wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was passiert, wenn wir den 4. Knoten in die Topologie einführen? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/ro/-i/82ro-ipa6d3lw8stb_fx7e9_wos.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Funktion hat sich geändert, jetzt nehmen wir den Rest der Division durch 4, nicht durch 3. Und wenn sich die Funktion geändert hat, hat sich die Verteilung geändert, und sehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird die vorherige Position der Objekte für die vorherige Version der Topologie von drei Knoten rot angezeigt, und die Position der Objekte für die neue Version der Topologie von vier Knoten ist grün. Dies ist den üblichen Diff-Dateien sehr ähnlich, aber anstelle von Dateien haben wir Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist leicht zu erkennen, dass die Daten nicht nur auf den neuen Knoten verschoben wurden, sondern auch ein Datenaustausch zwischen Knoten stattfand, die sich bereits in der Topologie befanden. Jene. Wir beobachten störenden Verkehr zwischen Knoten und die Anforderung einer minimalen Änderung der Verteilung ist nicht erfüllt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei beliebte Möglichkeiten zur Lösung des Problems der Datenverteilung unter Berücksichtigung der aufgeführten Anforderungen sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsistentes Hashing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größter Zufallsgewichtsalgorithmus (HRW), auch als Rendezvous-Hashing bekannt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beide Algorithmen sind sehr einfach. </font><font style="vertical-align: inherit;">Ihre Beschreibungen auf Wikipedia passen in mehrere Sätze. </font><font style="vertical-align: inherit;">Obwohl es schwierig ist, sie als offensichtlich zu bezeichnen. </font><font style="vertical-align: inherit;">Für Interessenten empfehle ich, die Originalartikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistent Hashing und Random Trees zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">: Distributed Caching Protocols zur Linderung von Hot Spots im World Wide Web</font></a><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein namensbasiertes Mapping-Schema für Rendezvous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Meiner Meinung nach </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">diesem Stanford-Kurs</font></a><font style="vertical-align: inherit;"> verständlicherweise die Idee eines konsistenten Hashing-Algorithmus </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">vermittelt</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns diese Algorithmen genauer an.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsequentes Hashing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Trick, der dem konsistenten Hashing-Algorithmus zugrunde liegt, besteht darin, sowohl Knoten als auch gespeicherte Objekte demselben Identifikatorraum zuzuordnen. </font><font style="vertical-align: inherit;">Dies macht unsere scheinbar unterschiedlichen Entitäten, Objekte und Knoten vergleichbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine solche Zuordnung zu erhalten, wenden wir einfach dieselbe Hash-Funktion auf die Schlüssel der Objekte und auf die Bezeichner der Knoten an. </font><font style="vertical-align: inherit;">Das Ergebnis der Hash-Funktion für den Knoten wird als Token bezeichnet. Dies wird uns später nützlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir stellen unseren Identifikatorraum in Form eines Kreises dar, d.h. </font><font style="vertical-align: inherit;">Wir nehmen einfach an, dass der maximale Bezeichnerwert unmittelbar auf den minimalen Bezeichnerwert folgt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nun zu bestimmen, auf welchem ​​Knoten sich das Objekt befindet, müssen Sie den Wert der Hash-Funktion von ihrem Schlüssel abrufen und sich dann einfach im Uhrzeigersinn um den Kreis bewegen, bis wir unterwegs auf das Token eines Knotens stoßen. Die Bewegungsrichtung ist unwichtig, muss aber festgelegt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die imaginäre Bewegung im Uhrzeigersinn entspricht funktional einer binären Suche in einem sortierten Array von Knoten-Token. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/dh/fy/cadhfyrlc9b_maoinnjw0kvp6fm.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Diagramm spiegelt jeder Sektor einer bestimmten Farbe den Identifizierungsraum wider, für den ein bestimmter Knoten verantwortlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir einen neuen Knoten hinzufügen, wird ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v7/an/3r/v7an3r9bwxn9hnziy-w7umr5viq.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... einer der Sektoren in zwei Teile geteilt und die entsprechenden Schlüssel vollständig übernommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel hat Knoten 3 einen Teil der Schlüssel von Knoten 1 übernommen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, führt dieser Ansatz zu einer ziemlich ungleichmäßigen Verteilung der Objekte auf die Knoten, weil Es hängt stark von den Kennungen der Knoten selbst ab. Wie kann dieser Ansatz verbessert werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Knoten mehr als ein Token zuweisen (normalerweise Hunderte). Dies kann zum Beispiel erreicht werden, indem viele Hash-Funktionen für den Knoten eingeführt werden (eine pro Token) oder wiederholt dieselbe Hash-Funktion auf das im vorherigen Schritt erhaltene Token angewendet wird. Aber wir dürfen die Kollisionen nicht vergessen. Es sollten nicht zwei Knoten mit demselben Token vorhanden sein. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7i/m2/ay/7im2ay5cr_ydc5hh62vlwcaqhp0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verfügt jeder Knoten über 4 Token.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was noch wichtig zu erwähnen ist: Wenn wir die Sicherheit von Daten für den Fall gewährleisten möchten, dass ein Knoten die Topologie verlässt, müssen wir die Schlüssel auf mehreren Knoten speichern (sogenannte Replikate oder Backups). </font><font style="vertical-align: inherit;">Im Fall des konsistenten Hashing-Algorithmus sind die Replikate die folgenden N-1-Knoten auf dem Kreis, wobei N der Replikationsfaktor ist. </font><font style="vertical-align: inherit;">Natürlich sollte die Reihenfolge der Knoten durch ein bestimmtes Token (zum Beispiel durch das erste) bestimmt werden, weil </font><font style="vertical-align: inherit;">Wenn für jeden von ihnen mehrere Token verwendet werden, kann die Anordnung der Knoten unterschiedlich sein. </font><font style="vertical-align: inherit;">Beachten Sie das Schema: Es gibt kein klares Muster für die Wiederholung von Knoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erfordernis einer minimalen Änderung der Verteilung beim Ändern der Topologie ist erfüllt, da die gegenseitige Reihenfolge der Knoten auf dem Kreis unverändert bleibt. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Durch Entfernen eines Knotens aus der Topologie wird die Ordnungsbeziehung zwischen den verbleibenden Knoten nicht geändert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendezvous-Hashing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rendezvous-Hashing-Algorithmus scheint noch einfacher zu sein als konsistentes Hashing. Der Algorithmus basiert auf dem gleichen Prinzip der Invarianz von Ordnungsbeziehungen. Anstatt Knoten und Objekte vergleichbar zu machen, machen wir nur Knoten für ein bestimmtes Objekt vergleichbar. Jene. Wir bestimmen die Ordnungsbeziehung zwischen Knoten für jedes Objekt unabhängig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch hier hilft uns das Hashing. Um nun das Gewicht des Knotens N für ein gegebenes Objekt O zu bestimmen, mischen wir nun die Kennung des Objekts mit der Kennung des Knotens und nehmen den Hash aus dieser Mischung. Nachdem wir diese Operation für jeden Knoten ausgeführt haben, erhalten wir eine Reihe von Gewichten, nach denen wir die Knoten sortieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Knoten, der sich als der erste herausstellte und für das Speichern des Objekts verantwortlich ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da alle Knoten der Topologie dieselben Eingabedaten verwenden, ist das Ergebnis für sie identisch. Welches erfüllt die erste Anforderung. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/hs/bw/oxhsbwgq8xrlfrirs8xupmx3hww.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispiel. Hier haben wir eine Ordnungsbeziehung zwischen drei Knoten für vier verschiedene Schlüssel. Gelb zeigt den Knoten mit dem höchsten Gewicht an, d.h. der Knoten, der letztendlich für einen bestimmten Schlüssel verantwortlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie der Topologie einen weiteren Knoten hinzu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hc/a9/4s/hca94sz_p5pz-lwflppuqlm7c54.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe es absichtlich auf die Diagonale gelegt, um alle möglichen Optionen zu berücksichtigen. Hier trat der grün dargestellte Knoten 3 in die Topologie ein. Daher hat sich die Gewichtsverteilung der Knoten für jeden der Schlüssel geändert. Rot zeigt die Knoten an, die ihre Position in der Liste für einen bestimmten Schlüssel geändert haben, weil Die Gewichte dieser Knoten waren geringer als das Gewicht des hinzugefügten Knotens. Diese Änderung betraf jedoch nur einen der Schlüssel, K3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Knoten auf verräterische Weise aus einer Topologie ableiten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/gr/d_/dsgrd_q9ai9yi9p5x08ubfgflem.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Änderungen betrafen erneut nur einen Schlüssel, diesmal K1. Die restlichen Objekte waren nicht betroffen. Der Grund ist, wie im Fall von konsistentem Hashing, die Invarianz der Ordnungsbeziehung zwischen einem Knotenpaar. Jene. Die Anforderung einer minimalen Änderung der Verteilung ist erfüllt und es gibt keinen störenden Verkehr zwischen Knoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verteilung für Rendezvous sieht ziemlich gut aus und erfordert keine zusätzlichen Tricks im Vergleich zu konsistentem Hashing wie Token. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die Replikation unterstützen möchten, ist der nächste Knoten in der Liste das erste Replikat für das Objekt, der nächste Knoten das zweite Replikat usw.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Rendezvous-Hashing in Apache Ignite verwendet wird</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die sogenannte Affinitätsfunktion ist für die Verteilung von Daten in Apache Ignite verantwortlich (siehe die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AffinityFunction-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><font style="vertical-align: inherit;">). Die Standardimplementierung ist Rendezvous-Hashing (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RendezvousAffinityFunction-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, worauf Sie achten müssen, ist, dass Apache Ignite gespeicherte Objekte nicht direkt Topologieknoten zuordnet. Stattdessen wird ein zusätzliches Konzept eingeführt - Partition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Partition ist ein Container für Objekte und eine Replikationseinheit. Darüber hinaus wird die Anzahl der Partitionen für einen bestimmten Cache (dies ist ein Analogon zur Tabelle in den bekannten Datenbanken) in der Konfigurationsphase festgelegt und ändert sich während des Cache-Lebenszyklus nicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können wir Objekte auf Partitionen mithilfe einer effektiven Modulo-Division anzeigen und mithilfe von Rendezvous-Hashing Partitionen auf Knoten anzeigen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/wr/vt/wdwrvtuau9ywcgq4uqk0hhqscu8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
weil Die Anzahl der Partitionen für den Cache ist eine Konstante. Dann können wir die Partitionsverteilung nach Knoten einmal berechnen und das Ergebnis zwischenspeichern, bis die Topologie geändert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Knoten berechnet diese Verteilung unabhängig, aber auf allen Knoten mit denselben Eingabedaten ist diese Verteilung identisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Partition kann mehrere Kopien haben, wir nennen sie Backups. Die primäre Partition wird als primäre Partition bezeichnet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die beste Verteilung von Schlüsseln zwischen Partitionen und Partitionen nach Knoten muss die folgende Regel erfüllt sein: Die Anzahl der Partitionen sollte erheblich größer sein als die Anzahl der Knoten. Die Anzahl der Schlüssel sollte wiederum erheblich größer sein als die Anzahl der Partitionen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caches in Ignite werden partitioniert und repliziert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem partitionierten Cache wird die Anzahl der Sicherungen in der Phase der Cacheerstellung festgelegt. Partitionen - Primär- und Sicherungen - werden gleichmäßig auf die Knoten verteilt. Ein solcher Cache eignet sich am besten für die Arbeit mit Betriebsdaten, wie z Bietet die beste Schreibleistung, die direkt von der Anzahl der Sicherungen abhängt. Je mehr Backups vorhanden sind, desto mehr Knoten müssen im Allgemeinen den Schlüsseldatensatz bestätigen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/fs/_u/hhfs_ujczi2m1p8kl4c5z3p2ra4.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verfügt der Cache über eine Sicherung. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Wir können einen Knoten verlieren und keine Daten verlieren, weil </font><font style="vertical-align: inherit;">Partitionssicherungen werden niemals auf demselben Knoten wie die primäre Partition oder ihre andere Sicherung gespeichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im replizierten Cache entspricht die Anzahl der Sicherungen immer der Anzahl der Topologieknoten minus 1. Das heißt, </font><font style="vertical-align: inherit;">Jeder Knoten enthält immer Kopien aller Partitionen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/fk/by/n-fkbyie-hipm40twvyg_erjjm0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solcher Cache eignet sich am besten für die Arbeit mit selten geänderten Daten (z. B. Verzeichnissen) und bietet die höchste Verfügbarkeit </font><font style="vertical-align: inherit;">Wir können N-1-Knoten (in diesem Fall 3) verlieren, ohne Daten zu verlieren. </font><font style="vertical-align: inherit;">Auch bei dieser Option erhalten wir maximale Leseleistung, wenn wir das Lesen von Daten sowohl von primären Partitionen als auch von Sicherungen zulassen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenkolokation in Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wichtiges Konzept für die beste Leistung ist die Kollokation. Colocation ist die Platzierung von Objekten an derselben Stelle. In unserem Fall sind Objekte Entitäten, die im Cache gespeichert sind, und ein Ort ist ein Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Objekte auf Partitionen derselben Affinitätsfunktion verteilt sind, ist es logisch, dass Objekte mit demselben Affinitätsschlüssel in dieselbe Partition und daher auf denselben Knoten fallen. In Ignite wird dies als Affinitätskolokation bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardmäßig ist ein Affinitätsschlüssel der Primärschlüssel eines Objekts. In Ignite können Sie jedoch jedes andere Feld eines Objekts als Affinitätsschlüssel verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Kollokation wird die Datenmenge, die zwischen Knoten gesendet wird, um Berechnungen oder SQL-Abfragen durchzuführen, erheblich reduziert, was natürlich zu einer Verringerung des Zeitaufwands für diese Aufgaben führt. Betrachten Sie dieses Konzept anhand eines Beispiels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie unser Datenmodell aus zwei Entitäten bestehen: order (Order) und order position (OrderItem). Eine Bestellung kann vielen Artikeln entsprechen. Die Bestell- und Artikelkennungen sind unabhängig, aber der Artikel verfügt über einen Fremdschlüssel, der auf die entsprechende Bestellung verweist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir müssen eine Aufgabe ausführen, nämlich Berechnungen für die Positionen dieser Bestellung für jede Bestellung durchzuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardmäßig ist ein Affinitätsschlüssel ein Primärschlüssel. Daher werden Befehle und Positionen gemäß ihren Primärschlüsseln, die, wie ich mich erinnere, unabhängig voneinander auf die Knoten verteilt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/q-/vq/tkq-vq1_sbghpcqdsz8ythpehim.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Diagramm werden Ordnungen durch Quadrate und Positionen in Kreisen dargestellt. Farbe zeigt an, dass der Artikel zur Bestellung gehört. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser Datenverteilung wird unsere hypothetische Aufgabe an den Knoten gesendet, an dem sich die gewünschte Reihenfolge befindet. Anschließend müssen die Positionen aller anderen Knoten gelesen oder eine Unteraufgabe an diese Knoten gesendet werden, um das Berechnungsergebnis zu erhalten. Dies ist eine unnötige Netzwerkinteraktion, die vermieden werden kann und sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist, wenn wir Ignite mitteilen, dass Bestellpositionen auf denselben Knoten wie die Bestellungen selbst platziert werden müssen, d. H. Daten sammeln? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Affinitätsschlüssel für die Position verwenden wir den Fremdschlüssel OrderId. Dieses Feld wird bei der Berechnung der Partition verwendet, zu der der Datensatz gehört. Darüber hinaus können wir unser Objekt innerhalb der Partition immer anhand des Primärschlüssels finden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/uq/kg/lvuqkgzf9gpoot8gjnr25uxb6ve.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn nun beide Caches (Order und OrderItem) dieselbe Affinitätsfunktion mit denselben Parametern verwenden, befinden sich unsere Daten in der Nähe und wir müssen nicht mehr im Netzwerk nach Bestellartikeln suchen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affinitätskonfiguration in Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der aktuellen Implementierung ist ein Affinitätsfunktionsobjekt ein Cache-Konfigurationsparameter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Affinitätsfunktion selbst verwendet beim Erstellen die folgenden Argumente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl der Partitionen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Sicherungen (tatsächlich ist dies auch der Konfigurationsparameter des Caches);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherungsfilter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flag excludeNeighbors.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Einstellungen können nicht geändert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Anzahl der Partitionen und Backups scheint alles klar zu sein. Ich werde etwas später über den Sicherungsfilter und das excludeNeighbors-Flag sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Laufzeit empfängt die Eingabe-Affinitätsfunktion die aktuelle Cluster-Topologie - im Wesentlichen eine Liste von Cluster-Knoten - und berechnet die Partitionsverteilung nach Knoten anhand der Beispiele, die ich gezeigt habe, als ich über den Rendezvous-Hashing-Algorithmus gesprochen habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sicherungsfilter ist ein Prädikat, mit dem Sie verhindern können, dass Affinitätsfunktionen Sicherungspartitionen einem Knoten zuweisen, für den das Prädikat false zurückgegeben hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, unsere physischen Knoten - Server - befinden sich im Rechenzentrum in verschiedenen Racks. Normalerweise hat jedes Rack seine eigene unabhängige Leistung ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/ts/wy/5etswypgpotv2e9exzu3gsyl9f8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und wenn wir das Rack verlieren, verlieren wir die Daten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/hy/5d/nzhy5dzl77t7pxhtxbtqubcbzek.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel haben wir die Hälfte der Partitionen verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch den richtigen Sicherungsfilter einstellen, ändert sich die Verteilung so, dass bei einem </font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/90/gy/2090gyzlg_0-80-dhkw8hvplftm.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verlust des Racks kein Datenverlust auftritt und diese weiterhin verfügbar sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/eg/k5/ooegk5vas7xhk7qzrergws5ieli.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Flag excludeNeighbors erfüllt eine ähnliche Funktion, und tatsächlich ist es eine Abkürzung für einen bestimmten Fall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oft werden mehrere Ignite-Knoten auf demselben physischen Host ausgeführt. Dieser Fall ist dem Beispiel mit Racks im Rechenzentrum sehr ähnlich. Erst jetzt bekämpfen wir den Datenverlust mit dem Verlust des Hosts, nicht der Racks. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/ze/wn/tkzewnmjc5iigjd_appzyvfoheo.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest ist der gleiche. Sie können dieses Verhalten mithilfe eines Sicherungsfilters implementieren. Diese Flagge ist ein historisches Erbe und kann in der nächsten Hauptversion von Ignite entfernt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass ich über die Affinitätsfunktion und Datenverteilung alles gesprochen habe, was ein Entwickler, der Apache Ignite verwendet, wissen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns abschließend ein Beispiel für die Verteilung von 16 Partitionen gemäß der Topologie von 3 Knoten betrachten. Der Einfachheit und Klarheit halber glauben wir, dass Partitionen keine Backups haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe gerade einen kleinen Test gemacht, der mir die tatsächliche Verteilung gebracht hat: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/lm/np/yylmnpenoifogzoo0lig3kzw_5g.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, ist die Gleichmäßigkeit der Verteilung nicht ideal. Der Fehler wird jedoch mit zunehmender Anzahl von Knoten und Partitionen merklich geringer sein. Die Hauptregel, die beachtet werden muss, ist, dass die Anzahl der Partitionen erheblich größer ist als die Anzahl der Knoten. In Ignite beträgt die Standardanzahl der Partitionen für einen partitionierten Cache 1024. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie der Topologie nun einen neuen Knoten hinzu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xd/xf/sp/xdxfspt29ky3x0gfceqi_xiswv0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Teil der Parteien zog zu ihm. Gleichzeitig wurde die Anforderung einer minimalen Änderung der Verteilung eingehalten: Der neue Knoten erhielt einen Teil der Partitionen, während die anderen Knoten keine Partitionen austauschten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir entfernen aus der Topologie den Knoten, der im Anfangsstadium darin vorhanden war: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b5/il/ymb5ilednyy4dxf6ynojfva7gao.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wurden alle Partitionen, die dem Nullknoten zugeordnet waren, auf andere Knoten der Topologie verteilt, ohne unsere Verteilungsanforderungen zu verletzen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, basiert die Lösung komplexer Probleme häufig auf ziemlich trivialen, wenn auch nicht ganz offensichtlichen Ideen. </font><font style="vertical-align: inherit;">Die beschriebenen Lösungen werden in den meisten verteilten Datenbanken verwendet und leisten gute Arbeit. </font><font style="vertical-align: inherit;">Diese Entscheidungen sind jedoch zufällig und daher ist die Gleichmäßigkeit der Verteilung alles andere als ideal. </font><font style="vertical-align: inherit;">Kann die Gleichmäßigkeit verbessert werden, ohne die Leistung und andere Verteilungsanforderungen zu beeinträchtigen? </font><font style="vertical-align: inherit;">Die Frage bleibt offen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489952/index.html">Live und motivierende Desktop-Hintergründe</a></li>
<li><a href="../de489954/index.html">Seagate SkyHawk AI - riesig und rachsüchtig</a></li>
<li><a href="../de489956/index.html">Wir animieren RecyclerView einfach, ohne zu ViewPager2 zu wechseln</a></li>
<li><a href="../de489958/index.html">Erklärung: Warum sich wc in Haskell als „schneller“ herausstellte als sein Gegenstück in C.</a></li>
<li><a href="../de489960/index.html">Automatisierte Erstellung einer Delphi-Anwendung</a></li>
<li><a href="../de489968/index.html">Wir erfassen die Verschlechterung von AA- und AAA-Batterien bei Strömen von 0,3 aus der Kapazität</a></li>
<li><a href="../de489970/index.html">Programmierer, Pack und John Steinbeck</a></li>
<li><a href="../de489974/index.html">Kha vs HTML5: Kompilieren von JavaScript in C ++</a></li>
<li><a href="../de489984/index.html">AMA über udalenka: fragen - wir antworten</a></li>
<li><a href="../de489986/index.html">Power Stage Designer-Dienstprogramm - Power Electronics Developer Tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>