<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèª üë®üèΩ‚Äçüéì üë©üèæ‚Äçü§ù‚Äçüë®üèº Datenverteilung in Apache Ignite ü•ù ‚Ü©Ô∏è üï°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Dieser Beitrag ist eine leicht gek√ºrzte Version meines gleichnamigen Vortrags beim Apache Ignite- Community-Meeting . Sie k√∂nnen die vollst√§ndi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Datenverteilung in Apache Ignite</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/489962/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo! </font><font style="vertical-align: inherit;">Dieser Beitrag ist eine leicht gek√ºrzte Version meines gleichnamigen Vortrags beim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Ignite-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Community-Meeting </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie k√∂nnen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vollst√§ndige Videoversion mit Fragen und Antworten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier ansehen</font></a><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folien </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier herunterladen</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In dem Bericht habe ich versucht, anhand von Beispielen zu zeigen, wie Daten in Apache Ignite verteilt werden.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum m√ºssen Sie etwas verteilen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ziemlich normale Geschichte der Entwicklung eines Systems, das Datenspeicherung und -verarbeitung erfordert, ist das Erreichen einer bestimmten Obergrenze. Entweder gibt es viele Daten und sie werden nicht physisch auf dem Speicherger√§t abgelegt, oder die Last w√§chst so schnell, dass ein Server eine solche Anzahl von Anforderungen nicht mehr verarbeiten kann. Es gibt h√§ufige F√§lle, in denen beide auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Regel gibt es eine von zwei L√∂sungen: entweder das Sharding des vorhandenen Speichers oder das Wechseln zu einer verteilten Datenbank. Beide L√∂sungen haben eine Reihe gemeinsamer Merkmale, von denen das offensichtlichste die Verwendung von mehr als einem Knoten f√ºr die Arbeit mit Daten ist. Au√üerdem werde ich viele Knoten Topologie nennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem der Datenverteilung zwischen Topologieknoten kann als eine Reihe von Anforderungen formuliert werden, die unsere Verteilung erf√ºllen muss:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird ein Algorithmus ben√∂tigt, mit dem alle Knoten der Topologie und der Clientanwendungen zu derselben Schlussfolgerung gelangen k√∂nnen, auf welchem ‚Äã‚ÄãKnoten oder welchen Knoten sich das bestimmte Objekt (oder der bestimmte Schl√ºssel) befindet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichm√§√üige Verteilung. </font><font style="vertical-align: inherit;">Je gleichm√§√üiger die Daten auf die Knoten verteilt sind, desto gleichm√§√üiger wird die Belastung dieser Knoten verteilt. </font><font style="vertical-align: inherit;">Hier gehe ich davon aus, dass unsere Knoten ungef√§hr die gleichen Ressourcen haben.</font></font></li>
<li>  .      ,       ,    .   ,       ,       ,     .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erreichen der ersten beiden Anforderungen ist ziemlich einfach. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bekannter Ansatz, der h√§ufig beim Lastausgleich zwischen funktional √§quivalenten Servern verwendet wird, indem Modulo N geteilt wird, wobei N die Anzahl der Knoten in der Topologie ist und wir eine Eins-zu-Eins-Entsprechung zwischen der Knotennummer und ihrer Kennung haben. Dann m√ºssen wir nur noch den Schl√ºssel des Objekts als numerischen Wert unter Verwendung einer Hash-Funktion darstellen und den Rest der Division durch N vom erhaltenen Wert nehmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zi/7x/ii/zi7xiiu8xmrjgaeghuc8xkekubk.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Diagramm zeigt die Verteilung von 16 Schl√ºsseln auf 3 Knoten. Es ist ersichtlich, dass diese Verteilung einheitlich ist und der Algorithmus zum Erhalten des Knotens f√ºr das Objekt einfach ist und garantiert, dass, wenn alle Knoten der Topologie diesen Algorithmus verwenden, dasselbe Ergebnis f√ºr denselben Schl√ºssel und dasselbe N erhalten wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was passiert, wenn wir den 4. Knoten in die Topologie einf√ºhren? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/ro/-i/82ro-ipa6d3lw8stb_fx7e9_wos.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Funktion hat sich ge√§ndert, jetzt nehmen wir den Rest der Division durch 4, nicht durch 3. Und wenn sich die Funktion ge√§ndert hat, hat sich die Verteilung ge√§ndert, und sehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird die vorherige Position der Objekte f√ºr die vorherige Version der Topologie von drei Knoten rot angezeigt, und die Position der Objekte f√ºr die neue Version der Topologie von vier Knoten ist gr√ºn. Dies ist den √ºblichen Diff-Dateien sehr √§hnlich, aber anstelle von Dateien haben wir Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist leicht zu erkennen, dass die Daten nicht nur auf den neuen Knoten verschoben wurden, sondern auch ein Datenaustausch zwischen Knoten stattfand, die sich bereits in der Topologie befanden. Jene. Wir beobachten st√∂renden Verkehr zwischen Knoten und die Anforderung einer minimalen √Ñnderung der Verteilung ist nicht erf√ºllt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei beliebte M√∂glichkeiten zur L√∂sung des Problems der Datenverteilung unter Ber√ºcksichtigung der aufgef√ºhrten Anforderungen sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsistentes Hashing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√∂√üter Zufallsgewichtsalgorithmus (HRW), auch als Rendezvous-Hashing bekannt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beide Algorithmen sind sehr einfach. </font><font style="vertical-align: inherit;">Ihre Beschreibungen auf Wikipedia passen in mehrere S√§tze. </font><font style="vertical-align: inherit;">Obwohl es schwierig ist, sie als offensichtlich zu bezeichnen. </font><font style="vertical-align: inherit;">F√ºr Interessenten empfehle ich, die Originalartikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistent Hashing und Random Trees zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">: Distributed Caching Protocols zur Linderung von Hot Spots im World Wide Web</font></a><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein namensbasiertes Mapping-Schema f√ºr Rendezvous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Meiner Meinung nach </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">diesem Stanford-Kurs</font></a><font style="vertical-align: inherit;"> verst√§ndlicherweise die Idee eines konsistenten Hashing-Algorithmus </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">vermittelt</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns diese Algorithmen genauer an.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsequentes Hashing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Trick, der dem konsistenten Hashing-Algorithmus zugrunde liegt, besteht darin, sowohl Knoten als auch gespeicherte Objekte demselben Identifikatorraum zuzuordnen. </font><font style="vertical-align: inherit;">Dies macht unsere scheinbar unterschiedlichen Entit√§ten, Objekte und Knoten vergleichbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine solche Zuordnung zu erhalten, wenden wir einfach dieselbe Hash-Funktion auf die Schl√ºssel der Objekte und auf die Bezeichner der Knoten an. </font><font style="vertical-align: inherit;">Das Ergebnis der Hash-Funktion f√ºr den Knoten wird als Token bezeichnet. Dies wird uns sp√§ter n√ºtzlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir stellen unseren Identifikatorraum in Form eines Kreises dar, d.h. </font><font style="vertical-align: inherit;">Wir nehmen einfach an, dass der maximale Bezeichnerwert unmittelbar auf den minimalen Bezeichnerwert folgt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nun zu bestimmen, auf welchem ‚Äã‚ÄãKnoten sich das Objekt befindet, m√ºssen Sie den Wert der Hash-Funktion von ihrem Schl√ºssel abrufen und sich dann einfach im Uhrzeigersinn um den Kreis bewegen, bis wir unterwegs auf das Token eines Knotens sto√üen. Die Bewegungsrichtung ist unwichtig, muss aber festgelegt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die imagin√§re Bewegung im Uhrzeigersinn entspricht funktional einer bin√§ren Suche in einem sortierten Array von Knoten-Token. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/dh/fy/cadhfyrlc9b_maoinnjw0kvp6fm.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Diagramm spiegelt jeder Sektor einer bestimmten Farbe den Identifizierungsraum wider, f√ºr den ein bestimmter Knoten verantwortlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir einen neuen Knoten hinzuf√ºgen, wird ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v7/an/3r/v7an3r9bwxn9hnziy-w7umr5viq.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... einer der Sektoren in zwei Teile geteilt und die entsprechenden Schl√ºssel vollst√§ndig √ºbernommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel hat Knoten 3 einen Teil der Schl√ºssel von Knoten 1 √ºbernommen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, f√ºhrt dieser Ansatz zu einer ziemlich ungleichm√§√üigen Verteilung der Objekte auf die Knoten, weil Es h√§ngt stark von den Kennungen der Knoten selbst ab. Wie kann dieser Ansatz verbessert werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen Knoten mehr als ein Token zuweisen (normalerweise Hunderte). Dies kann zum Beispiel erreicht werden, indem viele Hash-Funktionen f√ºr den Knoten eingef√ºhrt werden (eine pro Token) oder wiederholt dieselbe Hash-Funktion auf das im vorherigen Schritt erhaltene Token angewendet wird. Aber wir d√ºrfen die Kollisionen nicht vergessen. Es sollten nicht zwei Knoten mit demselben Token vorhanden sein. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7i/m2/ay/7im2ay5cr_ydc5hh62vlwcaqhp0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verf√ºgt jeder Knoten √ºber 4 Token.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was noch wichtig zu erw√§hnen ist: Wenn wir die Sicherheit von Daten f√ºr den Fall gew√§hrleisten m√∂chten, dass ein Knoten die Topologie verl√§sst, m√ºssen wir die Schl√ºssel auf mehreren Knoten speichern (sogenannte Replikate oder Backups). </font><font style="vertical-align: inherit;">Im Fall des konsistenten Hashing-Algorithmus sind die Replikate die folgenden N-1-Knoten auf dem Kreis, wobei N der Replikationsfaktor ist. </font><font style="vertical-align: inherit;">Nat√ºrlich sollte die Reihenfolge der Knoten durch ein bestimmtes Token (zum Beispiel durch das erste) bestimmt werden, weil </font><font style="vertical-align: inherit;">Wenn f√ºr jeden von ihnen mehrere Token verwendet werden, kann die Anordnung der Knoten unterschiedlich sein. </font><font style="vertical-align: inherit;">Beachten Sie das Schema: Es gibt kein klares Muster f√ºr die Wiederholung von Knoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erfordernis einer minimalen √Ñnderung der Verteilung beim √Ñndern der Topologie ist erf√ºllt, da die gegenseitige Reihenfolge der Knoten auf dem Kreis unver√§ndert bleibt. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Durch Entfernen eines Knotens aus der Topologie wird die Ordnungsbeziehung zwischen den verbleibenden Knoten nicht ge√§ndert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendezvous-Hashing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rendezvous-Hashing-Algorithmus scheint noch einfacher zu sein als konsistentes Hashing. Der Algorithmus basiert auf dem gleichen Prinzip der Invarianz von Ordnungsbeziehungen. Anstatt Knoten und Objekte vergleichbar zu machen, machen wir nur Knoten f√ºr ein bestimmtes Objekt vergleichbar. Jene. Wir bestimmen die Ordnungsbeziehung zwischen Knoten f√ºr jedes Objekt unabh√§ngig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch hier hilft uns das Hashing. Um nun das Gewicht des Knotens N f√ºr ein gegebenes Objekt O zu bestimmen, mischen wir nun die Kennung des Objekts mit der Kennung des Knotens und nehmen den Hash aus dieser Mischung. Nachdem wir diese Operation f√ºr jeden Knoten ausgef√ºhrt haben, erhalten wir eine Reihe von Gewichten, nach denen wir die Knoten sortieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Knoten, der sich als der erste herausstellte und f√ºr das Speichern des Objekts verantwortlich ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da alle Knoten der Topologie dieselben Eingabedaten verwenden, ist das Ergebnis f√ºr sie identisch. Welches erf√ºllt die erste Anforderung. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/hs/bw/oxhsbwgq8xrlfrirs8xupmx3hww.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispiel. Hier haben wir eine Ordnungsbeziehung zwischen drei Knoten f√ºr vier verschiedene Schl√ºssel. Gelb zeigt den Knoten mit dem h√∂chsten Gewicht an, d.h. der Knoten, der letztendlich f√ºr einen bestimmten Schl√ºssel verantwortlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie der Topologie einen weiteren Knoten hinzu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hc/a9/4s/hca94sz_p5pz-lwflppuqlm7c54.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe es absichtlich auf die Diagonale gelegt, um alle m√∂glichen Optionen zu ber√ºcksichtigen. Hier trat der gr√ºn dargestellte Knoten 3 in die Topologie ein. Daher hat sich die Gewichtsverteilung der Knoten f√ºr jeden der Schl√ºssel ge√§ndert. Rot zeigt die Knoten an, die ihre Position in der Liste f√ºr einen bestimmten Schl√ºssel ge√§ndert haben, weil Die Gewichte dieser Knoten waren geringer als das Gewicht des hinzugef√ºgten Knotens. Diese √Ñnderung betraf jedoch nur einen der Schl√ºssel, K3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Knoten auf verr√§terische Weise aus einer Topologie ableiten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/gr/d_/dsgrd_q9ai9yi9p5x08ubfgflem.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die √Ñnderungen betrafen erneut nur einen Schl√ºssel, diesmal K1. Die restlichen Objekte waren nicht betroffen. Der Grund ist, wie im Fall von konsistentem Hashing, die Invarianz der Ordnungsbeziehung zwischen einem Knotenpaar. Jene. Die Anforderung einer minimalen √Ñnderung der Verteilung ist erf√ºllt und es gibt keinen st√∂renden Verkehr zwischen Knoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verteilung f√ºr Rendezvous sieht ziemlich gut aus und erfordert keine zus√§tzlichen Tricks im Vergleich zu konsistentem Hashing wie Token. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die Replikation unterst√ºtzen m√∂chten, ist der n√§chste Knoten in der Liste das erste Replikat f√ºr das Objekt, der n√§chste Knoten das zweite Replikat usw.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Rendezvous-Hashing in Apache Ignite verwendet wird</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die sogenannte Affinit√§tsfunktion ist f√ºr die Verteilung von Daten in Apache Ignite verantwortlich (siehe die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AffinityFunction-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnittstelle </font><font style="vertical-align: inherit;">). Die Standardimplementierung ist Rendezvous-Hashing (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RendezvousAffinityFunction-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, worauf Sie achten m√ºssen, ist, dass Apache Ignite gespeicherte Objekte nicht direkt Topologieknoten zuordnet. Stattdessen wird ein zus√§tzliches Konzept eingef√ºhrt - Partition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Partition ist ein Container f√ºr Objekte und eine Replikationseinheit. Dar√ºber hinaus wird die Anzahl der Partitionen f√ºr einen bestimmten Cache (dies ist ein Analogon zur Tabelle in den bekannten Datenbanken) in der Konfigurationsphase festgelegt und √§ndert sich w√§hrend des Cache-Lebenszyklus nicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise k√∂nnen wir Objekte auf Partitionen mithilfe einer effektiven Modulo-Division anzeigen und mithilfe von Rendezvous-Hashing Partitionen auf Knoten anzeigen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/wr/vt/wdwrvtuau9ywcgq4uqk0hhqscu8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
weil Die Anzahl der Partitionen f√ºr den Cache ist eine Konstante. Dann k√∂nnen wir die Partitionsverteilung nach Knoten einmal berechnen und das Ergebnis zwischenspeichern, bis die Topologie ge√§ndert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Knoten berechnet diese Verteilung unabh√§ngig, aber auf allen Knoten mit denselben Eingabedaten ist diese Verteilung identisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Partition kann mehrere Kopien haben, wir nennen sie Backups. Die prim√§re Partition wird als prim√§re Partition bezeichnet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die beste Verteilung von Schl√ºsseln zwischen Partitionen und Partitionen nach Knoten muss die folgende Regel erf√ºllt sein: Die Anzahl der Partitionen sollte erheblich gr√∂√üer sein als die Anzahl der Knoten. Die Anzahl der Schl√ºssel sollte wiederum erheblich gr√∂√üer sein als die Anzahl der Partitionen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caches in Ignite werden partitioniert und repliziert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem partitionierten Cache wird die Anzahl der Sicherungen in der Phase der Cacheerstellung festgelegt. Partitionen - Prim√§r- und Sicherungen - werden gleichm√§√üig auf die Knoten verteilt. Ein solcher Cache eignet sich am besten f√ºr die Arbeit mit Betriebsdaten, wie z Bietet die beste Schreibleistung, die direkt von der Anzahl der Sicherungen abh√§ngt. Je mehr Backups vorhanden sind, desto mehr Knoten m√ºssen im Allgemeinen den Schl√ºsseldatensatz best√§tigen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/fs/_u/hhfs_ujczi2m1p8kl4c5z3p2ra4.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verf√ºgt der Cache √ºber eine Sicherung. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Wir k√∂nnen einen Knoten verlieren und keine Daten verlieren, weil </font><font style="vertical-align: inherit;">Partitionssicherungen werden niemals auf demselben Knoten wie die prim√§re Partition oder ihre andere Sicherung gespeichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im replizierten Cache entspricht die Anzahl der Sicherungen immer der Anzahl der Topologieknoten minus 1. Das hei√üt, </font><font style="vertical-align: inherit;">Jeder Knoten enth√§lt immer Kopien aller Partitionen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/fk/by/n-fkbyie-hipm40twvyg_erjjm0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solcher Cache eignet sich am besten f√ºr die Arbeit mit selten ge√§nderten Daten (z. B. Verzeichnissen) und bietet die h√∂chste Verf√ºgbarkeit </font><font style="vertical-align: inherit;">Wir k√∂nnen N-1-Knoten (in diesem Fall 3) verlieren, ohne Daten zu verlieren. </font><font style="vertical-align: inherit;">Auch bei dieser Option erhalten wir maximale Leseleistung, wenn wir das Lesen von Daten sowohl von prim√§ren Partitionen als auch von Sicherungen zulassen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenkolokation in Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wichtiges Konzept f√ºr die beste Leistung ist die Kollokation. Colocation ist die Platzierung von Objekten an derselben Stelle. In unserem Fall sind Objekte Entit√§ten, die im Cache gespeichert sind, und ein Ort ist ein Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Objekte auf Partitionen derselben Affinit√§tsfunktion verteilt sind, ist es logisch, dass Objekte mit demselben Affinit√§tsschl√ºssel in dieselbe Partition und daher auf denselben Knoten fallen. In Ignite wird dies als Affinit√§tskolokation bezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardm√§√üig ist ein Affinit√§tsschl√ºssel der Prim√§rschl√ºssel eines Objekts. In Ignite k√∂nnen Sie jedoch jedes andere Feld eines Objekts als Affinit√§tsschl√ºssel verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Kollokation wird die Datenmenge, die zwischen Knoten gesendet wird, um Berechnungen oder SQL-Abfragen durchzuf√ºhren, erheblich reduziert, was nat√ºrlich zu einer Verringerung des Zeitaufwands f√ºr diese Aufgaben f√ºhrt. Betrachten Sie dieses Konzept anhand eines Beispiels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie unser Datenmodell aus zwei Entit√§ten bestehen: order (Order) und order position (OrderItem). Eine Bestellung kann vielen Artikeln entsprechen. Die Bestell- und Artikelkennungen sind unabh√§ngig, aber der Artikel verf√ºgt √ºber einen Fremdschl√ºssel, der auf die entsprechende Bestellung verweist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir m√ºssen eine Aufgabe ausf√ºhren, n√§mlich Berechnungen f√ºr die Positionen dieser Bestellung f√ºr jede Bestellung durchzuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardm√§√üig ist ein Affinit√§tsschl√ºssel ein Prim√§rschl√ºssel. Daher werden Befehle und Positionen gem√§√ü ihren Prim√§rschl√ºsseln, die, wie ich mich erinnere, unabh√§ngig voneinander auf die Knoten verteilt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/q-/vq/tkq-vq1_sbghpcqdsz8ythpehim.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Diagramm werden Ordnungen durch Quadrate und Positionen in Kreisen dargestellt. Farbe zeigt an, dass der Artikel zur Bestellung geh√∂rt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser Datenverteilung wird unsere hypothetische Aufgabe an den Knoten gesendet, an dem sich die gew√ºnschte Reihenfolge befindet. Anschlie√üend m√ºssen die Positionen aller anderen Knoten gelesen oder eine Unteraufgabe an diese Knoten gesendet werden, um das Berechnungsergebnis zu erhalten. Dies ist eine unn√∂tige Netzwerkinteraktion, die vermieden werden kann und sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist, wenn wir Ignite mitteilen, dass Bestellpositionen auf denselben Knoten wie die Bestellungen selbst platziert werden m√ºssen, d. H. Daten sammeln? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Affinit√§tsschl√ºssel f√ºr die Position verwenden wir den Fremdschl√ºssel OrderId. Dieses Feld wird bei der Berechnung der Partition verwendet, zu der der Datensatz geh√∂rt. Dar√ºber hinaus k√∂nnen wir unser Objekt innerhalb der Partition immer anhand des Prim√§rschl√ºssels finden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/uq/kg/lvuqkgzf9gpoot8gjnr25uxb6ve.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn nun beide Caches (Order und OrderItem) dieselbe Affinit√§tsfunktion mit denselben Parametern verwenden, befinden sich unsere Daten in der N√§he und wir m√ºssen nicht mehr im Netzwerk nach Bestellartikeln suchen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affinit√§tskonfiguration in Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der aktuellen Implementierung ist ein Affinit√§tsfunktionsobjekt ein Cache-Konfigurationsparameter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Affinit√§tsfunktion selbst verwendet beim Erstellen die folgenden Argumente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl der Partitionen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Sicherungen (tats√§chlich ist dies auch der Konfigurationsparameter des Caches);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherungsfilter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flag excludeNeighbors.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Einstellungen k√∂nnen nicht ge√§ndert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Anzahl der Partitionen und Backups scheint alles klar zu sein. Ich werde etwas sp√§ter √ºber den Sicherungsfilter und das excludeNeighbors-Flag sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Laufzeit empf√§ngt die Eingabe-Affinit√§tsfunktion die aktuelle Cluster-Topologie - im Wesentlichen eine Liste von Cluster-Knoten - und berechnet die Partitionsverteilung nach Knoten anhand der Beispiele, die ich gezeigt habe, als ich √ºber den Rendezvous-Hashing-Algorithmus gesprochen habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sicherungsfilter ist ein Pr√§dikat, mit dem Sie verhindern k√∂nnen, dass Affinit√§tsfunktionen Sicherungspartitionen einem Knoten zuweisen, f√ºr den das Pr√§dikat false zur√ºckgegeben hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, unsere physischen Knoten - Server - befinden sich im Rechenzentrum in verschiedenen Racks. Normalerweise hat jedes Rack seine eigene unabh√§ngige Leistung ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/ts/wy/5etswypgpotv2e9exzu3gsyl9f8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und wenn wir das Rack verlieren, verlieren wir die Daten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/hy/5d/nzhy5dzl77t7pxhtxbtqubcbzek.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel haben wir die H√§lfte der Partitionen verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch den richtigen Sicherungsfilter einstellen, √§ndert sich die Verteilung so, dass bei einem </font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/90/gy/2090gyzlg_0-80-dhkw8hvplftm.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verlust des Racks kein Datenverlust auftritt und diese weiterhin verf√ºgbar sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/eg/k5/ooegk5vas7xhk7qzrergws5ieli.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Flag excludeNeighbors erf√ºllt eine √§hnliche Funktion, und tats√§chlich ist es eine Abk√ºrzung f√ºr einen bestimmten Fall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oft werden mehrere Ignite-Knoten auf demselben physischen Host ausgef√ºhrt. Dieser Fall ist dem Beispiel mit Racks im Rechenzentrum sehr √§hnlich. Erst jetzt bek√§mpfen wir den Datenverlust mit dem Verlust des Hosts, nicht der Racks. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/ze/wn/tkzewnmjc5iigjd_appzyvfoheo.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest ist der gleiche. Sie k√∂nnen dieses Verhalten mithilfe eines Sicherungsfilters implementieren. Diese Flagge ist ein historisches Erbe und kann in der n√§chsten Hauptversion von Ignite entfernt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass ich √ºber die Affinit√§tsfunktion und Datenverteilung alles gesprochen habe, was ein Entwickler, der Apache Ignite verwendet, wissen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns abschlie√üend ein Beispiel f√ºr die Verteilung von 16 Partitionen gem√§√ü der Topologie von 3 Knoten betrachten. Der Einfachheit und Klarheit halber glauben wir, dass Partitionen keine Backups haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe gerade einen kleinen Test gemacht, der mir die tats√§chliche Verteilung gebracht hat: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/lm/np/yylmnpenoifogzoo0lig3kzw_5g.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, ist die Gleichm√§√üigkeit der Verteilung nicht ideal. Der Fehler wird jedoch mit zunehmender Anzahl von Knoten und Partitionen merklich geringer sein. Die Hauptregel, die beachtet werden muss, ist, dass die Anzahl der Partitionen erheblich gr√∂√üer ist als die Anzahl der Knoten. In Ignite betr√§gt die Standardanzahl der Partitionen f√ºr einen partitionierten Cache 1024. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie der Topologie nun einen neuen Knoten hinzu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xd/xf/sp/xdxfspt29ky3x0gfceqi_xiswv0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Teil der Parteien zog zu ihm. Gleichzeitig wurde die Anforderung einer minimalen √Ñnderung der Verteilung eingehalten: Der neue Knoten erhielt einen Teil der Partitionen, w√§hrend die anderen Knoten keine Partitionen austauschten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir entfernen aus der Topologie den Knoten, der im Anfangsstadium darin vorhanden war: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b5/il/ymb5ilednyy4dxf6ynojfva7gao.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wurden alle Partitionen, die dem Nullknoten zugeordnet waren, auf andere Knoten der Topologie verteilt, ohne unsere Verteilungsanforderungen zu verletzen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, basiert die L√∂sung komplexer Probleme h√§ufig auf ziemlich trivialen, wenn auch nicht ganz offensichtlichen Ideen. </font><font style="vertical-align: inherit;">Die beschriebenen L√∂sungen werden in den meisten verteilten Datenbanken verwendet und leisten gute Arbeit. </font><font style="vertical-align: inherit;">Diese Entscheidungen sind jedoch zuf√§llig und daher ist die Gleichm√§√üigkeit der Verteilung alles andere als ideal. </font><font style="vertical-align: inherit;">Kann die Gleichm√§√üigkeit verbessert werden, ohne die Leistung und andere Verteilungsanforderungen zu beeintr√§chtigen? </font><font style="vertical-align: inherit;">Die Frage bleibt offen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489952/index.html">Live und motivierende Desktop-Hintergr√ºnde</a></li>
<li><a href="../de489954/index.html">Seagate SkyHawk AI - riesig und rachs√ºchtig</a></li>
<li><a href="../de489956/index.html">Wir animieren RecyclerView einfach, ohne zu ViewPager2 zu wechseln</a></li>
<li><a href="../de489958/index.html">Erkl√§rung: Warum sich wc in Haskell als ‚Äûschneller‚Äú herausstellte als sein Gegenst√ºck in C.</a></li>
<li><a href="../de489960/index.html">Automatisierte Erstellung einer Delphi-Anwendung</a></li>
<li><a href="../de489968/index.html">Wir erfassen die Verschlechterung von AA- und AAA-Batterien bei Str√∂men von 0,3 aus der Kapazit√§t</a></li>
<li><a href="../de489970/index.html">Programmierer, Pack und John Steinbeck</a></li>
<li><a href="../de489974/index.html">Kha vs HTML5: Kompilieren von JavaScript in C ++</a></li>
<li><a href="../de489984/index.html">AMA √ºber udalenka: fragen - wir antworten</a></li>
<li><a href="../de489986/index.html">Power Stage Designer-Dienstprogramm - Power Electronics Developer Tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>