<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐫 👨🏽‍🎤 👵 .NETでの非同期プログラミング：ベストプラクティス 👱 👩🏽‍🔧 ❣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C＃でのasync / awaitの出現により、単純で正しい並列コードの記述方法が再定義されました。多くの場合、非同期プログラミングを使用すると、プログラマーはスレッドに関する問題を解決するだけでなく、新しい問題も持ち込みます。デッドロックとフライトはどこにも行きません-診断が難しくなるだけです。
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NETでの非同期プログラミング：ベストプラクティス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃でのasync / awaitの出現により、単純で正しい並列コードの記述方法が再定義されました。多くの場合、非同期プログラミングを使用すると、プログラマーはスレッドに関する問題を解決するだけでなく、新しい問題も持ち込みます。デッドロックとフライトはどこにも行きません-診断が難しくなるだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov-ReSharperコアの元JetBrains Riderテクライドおよび開発者であるHuaweiのソフトウェア分析TeamLead：データ構造、キャッシュ、マルチスレッド、および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会議での定期的なスピーカー</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットシーンの下-DotNext 2019 Piterカンファレンスからのドミトリーのレポートのビデオ録画とテキストの筆記録。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">話者に代わってさらにナレーション。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
マルチスレッドまたは非同期コードでは、何かがしばしば壊れます。理由は、デッドロックとレースの両方である可能性があります。原則として、レースは1000回に1回、多くの場合ローカルではなく、ビルドサーバーでのみクラッシュし、それをキャッチするには数日かかります。多くの人にとって、これは身近な状況だと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、経験豊富な開発者でも非同期コードを見ると、3倍短く正確に書き込めるものがあると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、問題が人ではなく楽器にあることを示唆しています。</font><font style="vertical-align: inherit;">人々はツールを使って問題を解決したいと思っています。</font><font style="vertical-align: inherit;">ツール自体には、非常に多数の機能（場合によっては余分なものもあります）、設定、暗黙的なコンテキストがあり、誤って使用するのは非常に簡単です。</font><font style="vertical-align: inherit;">async / awaitを使用</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して.NETの</font><font style="vertical-align: inherit;">クラスを操作する方法を理解してみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予定</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / awaitで解決されるアプローチの問題。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物議を醸すデザインの例。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期で解決する実際のタスク。</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期/待ち、解決すべき問題</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜ非同期/待機が必要なのですか？共有共有メモリで動作するコードがあるとしましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業の開始時に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロッキングリクエストを使用して、ブロッキングキュー（インターネットやディスクなど）からリクエストを読み取ります</font><font style="vertical-align: inherit;">（ブロッキングリクエストは、例のある画像では赤でマークされています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは多くのスレッドを必要とし、各スレッドはリソースを必要とし、</font><i><font style="vertical-align: inherit;">スケジューラに</font></i><font style="vertical-align: inherit;">負荷をかけます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、これは主な問題ではありません。オペレーティングシステムを書き直して、これらのシステムが10万スレッドと100万スレッドの両方をサポートできるようにするとします。しかし、主な問題は、一部のスレッドを単純に取得できないことです。たとえば、ユーザーインターフェイススレッドがあります。データへのアクセスが1つのスレッドだけからではない、通常の適切なUIフレームワークはまだありません。 UIスレッドをブロックできません。そして、それをブロックしないためには、非同期コードが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2番目のタスクについて説明します。ファイルを読み取った後、何らかの方法で処理する必要があります。並行して行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列処理は非同期と同じではないと多くの人が聞いています。この場合、問題が発生します。非同期は、並列コードをよりコンパクトで美しく高速に作成するのに役立ちますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のタスクは、共有メモリを操作することです。</font><font style="vertical-align: inherit;">このメカニズムをロック、非同期コードへの同期でドラッグする必要がありますか、またはこれをどうにかして回避できますか？</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期/これを待つ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができます</font><font style="vertical-align: inherit;">か？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期/待機のパス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
世界と.NETにおける一般的な非同期プログラミングの進化を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">折り返し電話</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {…}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    …<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       …<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期プログラミングはコールバックから始まりました。</font><font style="vertical-align: inherit;">つまり、最初にコードの一部を同期的に呼び出し、2番目の部分を非同期的に呼び出す必要があります。</font><font style="vertical-align: inherit;">たとえば、ファイルから読み取り、データの準備ができると、何らかの形でデータが配信されます。</font><font style="vertical-align: inherit;">この非同期部分は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として渡され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他のコールバック</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、1つのコールバックから別の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を登録でき</font><font style="vertical-align: inherit;">、そこから3番目のコールバックを登録でき、最終的にはすべてが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック地獄に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変わり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック：例外</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外を処理するにはどうすればよいですか？たとえば、ReSharperは、例外と適切な実行に個別に応答する場合、最も美しいコードを示していません-例外的な状況と正常な継続のために別々のコールバックがあります。結果はこのような</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック地獄</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、線形ではなくツリーのようなもので、完全に混乱する可能性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETでは、最初のコールバックアプローチは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期プログラミングモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（APM）</font><font style="vertical-align: inherit;">と呼ばれます</font><font style="vertical-align: inherit;">。メソッドはと呼ばれ</font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、本質的にと同じ</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、このアプローチにはいくつかの機能があります。まず、メソッドは「Begin」という単語で始まります（ファイルからの読み取りはBeginReadです）</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼自身</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは、操作が完了し、メカニズムを備えていることを認識するハンドラーです</font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作が非同期的に完了するのを待って、待機</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことができます。一方、を呼び出すことができます</font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、</font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期して</font><font style="vertical-align: inherit;">make </font><font style="vertical-align: inherit;">とhang </font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実行できます</font><font style="vertical-align: inherit;">（これはプロパティとよく似ています</font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには多くの問題があります。第一に、それは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック地獄</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から私たちを守りません</font><font style="vertical-align: inherit;">。第二に、例外をどうするかは完全に不明確なままです。 3番目に、このコールバックが呼び出されるスレッドが明確ではありません-呼び出しを制御できません。第4に、コードの一部をコールバックと組み合わせる方法が問題になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のモデルは、</font><i><font style="vertical-align: inherit;">イベントベースの非同期パターン</font></i><font style="vertical-align: inherit;">と呼ばれます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これはリアクティブコールバックアプローチです。メソッドの考え方は、</font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントが完了したオブジェクトを</font><font style="vertical-align: inherit;">メソッドに渡し、</font><font style="vertical-align: inherit;">このイベントをサブスクライブすることです。お気づきのように、</font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がに変わります</font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。混乱は、次の2つのパターンが混在しているSocketクラスへ行くときに発生する可能性があります</font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャンセルするには電話が必要</font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。 .NETではこれが他の場所で見つからないため、通常、誰もが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationTokenを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">送信します</font><font style="vertical-align: inherit;">。したがって、ライブラリでで終わるメソッドを誤って検出した場合、そのメソッドが</font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必ずしもを返すとは限らない</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、同様の構造を返すことができること</font><font style="vertical-align: inherit;">を理解する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaで知られているモデルを考えてください</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先物</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、JavaScriptでは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、.NETでは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Asynchronous Patterns</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまり「タスク」。このメソッドは、いくつかの計算オブジェクトがあり、このオブジェクトのステータス（実行中または終了）を確認できることを前提としています。 .NETでは</font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タスクの開始とタスクの完了という2つのステータスの</font><font style="vertical-align: inherit;">いわゆる</font><font style="vertical-align: inherit;">便利な分離があります。一般的なエラーは、</font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常な継続ではなく</font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">を返す</font><font style="vertical-align: inherit;">タスク</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">メソッドが呼び出されたときに発生</font><font style="vertical-align: inherit;">します</font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、UIアプリケーションで「キャンセル」をクリックした結果は、例外（実行）の戻りとは異なるはずです。 .NETでは、区別が行われています。実行が保護したいミスである場合は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャンセルします。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-強制操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETでは、概念も導入されました。</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、タスクを実行する場所を指示する、スレッドの上の一種の抽象化です。この場合、キャンセルサポートは設計レベルで設計されました。 .NETのライブラリ内のほとんどすべての操作は、</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを渡すことができます。これはすべての言語で機能するわけではありません。たとえば、Kotlinではタスクを元に戻すことができますが、.NETではできません。解決策は、タスクをキャンセルする人とタスク自体の間の責任の分割かもしれません。タスクを受け取った場合、明示的に行う以外の方法でキャンセルすることはできません</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それを渡す必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別なオブジェクトを</font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントベースの非同期パターン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><i><font style="vertical-align: inherit;">非同期プログラミングモデルに</font></i><font style="vertical-align: inherit;">関連付けられている古いAPIを簡単に適合させることができます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">タスクでプログラミングする場合に読む必要があるドキュメントがあります。</font><font style="vertical-align: inherit;">タサに関するすべての合意について説明しています。</font><font style="vertical-align: inherit;">たとえば、タスクを返すすべてのメソッドは、実行中の状態でタスクを返す必要があります。つまり、その</font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような操作はすべてで終了する必要があり</font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継続を組み合わせる</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組み合わせに関しては、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック地獄</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を考慮に入れると、</font><font style="vertical-align: inherit;">最小限の変更で繰り返しコードの断片が存在するにもかかわらず、より線形の形で表示される可能性があります。</font><font style="vertical-align: inherit;">コードはこのように改善されているようですが、ここにも落とし穴があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクの開始と続行</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のタスクの起動中に3つのパラメーターを見てみましょう</font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。1つ</font><font style="vertical-align: inherit;">目はタスクを開始するためのオプション、2 </font><font style="vertical-align: inherit;">つ</font><font style="vertical-align: inherit;">目はタスクを起動するオプション</font><font style="vertical-align: inherit;">、3つ目は- </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskSchedulerは、タスクの開始場所を示し、独立してオーバーライドできるオブジェクトです。たとえば、メソッドをオーバーライドできます</font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そうした場合</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のために</font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この方法は、</font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から糸を取る</font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、そこにあなたのタスクを送信します。</font><font style="vertical-align: inherit;">メインスレッド</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を</font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引き継ぐと、すべてが1つのキューに入れられ、タスクはメインスレッドで順次実行されます。ただし、問題は、.NETではを渡さなくてもタスクを実行できること</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。問題が発生します。それでは、.NETは、渡されたタスクをどのように計算するのでしょうか。</font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">からタスクが開始するとき</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">プレゼント</font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したものに出品し</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデザインは、暗黙のコンテキストのため、かなり物議を醸しているようです。</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこかに非常に深く継承</font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、別のスケジューラと重複する</font><font style="vertical-align: inherit;">非同期コードが含ま</font><font style="vertical-align: inherit;">れていて、デッドロックにつながる</font><font style="vertical-align: inherit;">ケースがありました</font><font style="vertical-align: inherit;">。この場合、オプションを使用できます</font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設定</font><font style="vertical-align: inherit;">を上書きするオプションがあることを通知する警報ベルです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きはすべて同じです。疑問が生じます：</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継続のため</font><font style="vertical-align: inherit;">にどこから来るの</font><font style="vertical-align: inherit;">ですか？まず、開始した方法で取得します</font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadStaticから</font><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">取得されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / awaitの場合、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継続の動作が大きく異なる</font><font style="vertical-align: inherit;">ことが重要です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータ</font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とに目</font><font style="vertical-align: inherit;">を向けます</font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼らの主な問題はそれらの多くがあることです。これらのパラメータの一部は互いにキャンセルし、一部は相互に排他的です。これらのパラメータはすべて可能な組み合わせで使用できるため、あこがれで起こり得るすべてのことを覚えておくことは困難です。これらのオプションの一部は、完全に理解不能に機能します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、パラメータ</font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2つの可能なアプリケーションオプション</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">表しますが、継続を同期的に起動するか非同期的に起動するかは、あまり知らないことに依存します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例：タスクを起動し、継続を起動し、同時に2つのパラメーターを指定しました</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、非同期で継続を開始しました。</font><font style="vertical-align: inherit;">前のタスクが終了したのと同じスタックで実行されますか、それとも転送され</font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？</font><font style="vertical-align: inherit;">この場合、3番目のオプションがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考えてください</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。タスクを作成するときは、その結果を設定して</font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、以前の非同期パターンをタスクの世界に適応させます。あなた</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が要求</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことができ</font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">あなた</font><font style="vertical-align: inherit;">が</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出す</font><font style="vertical-align: inherit;">と、このタスクは状態</font><font style="vertical-align: inherit;">に入ります</font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、これを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドプール</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で実行すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><i><font style="vertical-align: inherit;">発生し</font></i><font style="vertical-align: inherit;">ます。問題は、同期でさえ何も書いていないのはなぜですか？</font><font style="vertical-align: inherit;">新しいタスク</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を作成し</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て開始すると、このタスクで何かを開始する2番目のスレッドがあります。それは過ぎて、100ミリ秒の間期待に落ちます。次に、メインスレッド（緑）が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。彼はスタックを解放し、スタックはハングし、継続で呼び出されるのを待っています</font></font><code>task.Wait</code><font style="vertical-align: inherit;"></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">露出した</font><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
青い糸で私たちはに行き</font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に最も興味深いものに</font><font style="vertical-align: inherit;">行き</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">.NETの内部の考慮事項に基づいて、彼</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれの継続は</font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期的に、つまり同じスタック上で直接実行でき、これ</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">同じスタック上で同期的に実行される</font><font style="vertical-align: inherit;">と信じてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">どこにも書いていないという事実にもかかわらず、これは非常に奇妙です</font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはおそらく、同期コードと非同期コードの混在に関する問題です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに関するもう1つの問題</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下で</font><font style="vertical-align: inherit;">呼び出すと、任意のコードを呼び出すことができないということです。ロックの下では、細かいアクティビティをいくつかしか実行できないためです。</font><font style="vertical-align: inherit;">いくつかの</font><i><font style="vertical-align: inherit;">アクションの</font></i><font style="vertical-align: inherit;">下で実行します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、彼らがどこから来たのかを知ることは不可能です。</font><font style="vertical-align: inherit;">この問題を解決するには？</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリ内の</font><i><font style="vertical-align: inherit;">タスク</font></i><font style="vertical-align: inherit;">コードで</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はなく、適応のためにのみ</font><font style="vertical-align: inherit;">
使用する</font><font style="vertical-align: inherit;">価値</font><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">それ以外のほとんどすべては、待つことで解決できます。</font><font style="vertical-align: inherit;">この場合、パラメーター</font><i><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"を</font></i><font style="vertical-align: inherit;">指定することを常に強くお勧めします</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ほとんどの場合、継続を非同期で実行する必要があります。</font><font style="vertical-align: inherit;">この場合、</font><font style="vertical-align: inherit;">何も起動されないものがあります。</font><font style="vertical-align: inherit;">
継続を同期的に実行する必要があるのはなぜですか？</font><font style="vertical-align: inherit;">それ</font><font style="vertical-align: inherit;">は以下の</font><font style="vertical-align: inherit;">ものを</font><font style="vertical-align: inherit;">指し</font><font style="vertical-align: inherit;">、私たちのものではないからです。</font><font style="vertical-align: inherit;">彼が私たちと関係するためには、次のように書く必要があります。</font><font style="vertical-align: inherit;">
この例は、パラメーターが直感的ではない方法、パラメーターが相互に交差する方法、認知の複雑さを導入する方法を示しています-書くのは非常に困難です。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"></font><code>ContinueWith</code><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親子階層</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don’t wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータを使用するための他のオプションがあります。たとえば、</font><font style="vertical-align: inherit;">1つのタスクを起動してその下で別のタスクを実行すると</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親子</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">階層が</font><font style="vertical-align: inherit;">発生</font><font style="vertical-align: inherit;">します。この場合、と書け</font><font style="vertical-align: inherit;">ば、内部で起動されるタスクを待つ</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こと</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが書く場合は</font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それが</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機します。このプロパティを製品で使用できます。誰もがタスクの階層があり、タスクがサブタスクを待機し、サブタスクがそのサブタスクを待機している例を考え出すことができると思います。どこにも書き込む必要はありません</font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この待機は非同期で発生します。つまり、親タスクの本体は終了し、その後、親タスクは完了したと見なされず、子タスクが機能するまで継続を開始しません。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクがのどこかに転送されるという問題がある可能性があります</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その後、開始したすべてのものが</font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この親タスクに追加されます。これは警報ベルです。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don’t wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、以前のオプションをキャンセルするオプションがあります</font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようなアプリケーションはかなり頻繁に発生します。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don’t wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始するための標準的な方法であり、デフォルトではを意味することを</font><font style="vertical-align: inherit;">覚えておく価値</font><font style="vertical-align: inherit;">があります</font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗黙的なコンテキストを</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入すると</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">複雑さが増します。コンテキストを知る必要があるため、タスクがどのように機能するかを理解していません。発生する可能性のある別の問題は、非同期/待機のアイドル状態に関連しています。これは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期/待機で</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はタスクではなくアクションがあるためです。継続は正直な仕事ではなく、行動です。 async / awaitコードを記述する場合</font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タスクを明示的に結び付けてawaitを待機するため、これ</font><font style="vertical-align: inherit;">を使用する必要はありません</font><font style="vertical-align: inherit;">。これは正しいアプローチです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継続を開始する方法には6つのオプションがあります。タスクを起動し、起動しました</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">質問：この継続にはどのようなステータスがありますか？</font><font style="vertical-align: inherit;">考えられる答えは5つあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な継続は正常に完了し、RunToCompletionが発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクはエラーになります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャンセルが発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクは完全には完了せず、ある種のリンボになります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション-「依存する」。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、タスクは「キャンセルされた」状態になりますが、「キャンセルされた」という単語はどこにもありません。</font><font style="vertical-align: inherit;">ここではレセプションをスローし、何もしません。</font><font style="vertical-align: inherit;">問題は、10分前にこれらのオプションを知っていたとしても、多くのオプションを使用して他の誰かのコードを読んだ場合でも、ここで何が起こるかを忘れてしまうことです。</font><font style="vertical-align: inherit;">だから書いてはいけない。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャンセル</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの開始時の3番目のパラメーターはキャンセルです。</font><font style="vertical-align: inherit;">あなたは書く</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「キャンセル」状態の特別なアクションそのプットタスクです。</font><font style="vertical-align: inherit;">この場合、すべて</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が等しい</font><font style="vertical-align: inherit;">わけではないため、タスクは「失敗」状態になり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが実行できるように</font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、CancellationTokenとともに</font><font style="vertical-align: inherit;">タスクを</font><font style="vertical-align: inherit;">スローする必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際には、これを明示的に行うことはありませんが、次のように行います。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cancelTokenを区別する必要はありますか？</font><font style="vertical-align: inherit;">タスクのどこかで、誰かがあなたを削除したことを確認します。スローキャンセルをスローすると、タスクがstate状態になり</font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">または、誰かが実行時に「キャンセル」をクリックしてタスクをキャンセルしました。</font><font style="vertical-align: inherit;">JetBrainsでの実践では、これらのトークンを区別する必要がないことを示しています。</font><font style="vertical-align: inherit;">あなたが取得する場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -一部キャンセルが発生したときに発生する特別な種類を、あなたはそれを区別することができます。</font><font style="vertical-align: inherit;">この場合は、タスクを正常に完了し、ログインせず、実行を受け取ったときにログインするだけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディープスタック</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが深いスタックを持っているとしましょう。これ</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、説明した唯一の明示的なパラメーターです。それは絶対にすべての階層を通じてどこにでも送信されなければなりません。深い階層の存在下で、レセプションを破棄するために、最低レベルのどこかでタスクをキャンセルする必要がある場合はどうすればよいですか？私たちが使う特別なトリックがあります。彼は呼ばれる</font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは同じですが、</font><font style="vertical-align: inherit;">非同期/コードのトリップを待機し</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た特別な</font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もの</font><font style="vertical-align: inherit;">のみ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">あなたのコードは非同期であり、あなたはこのキャンセレーションを持っているので、それをに入れ</font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、どこか深いレベルで " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">と言うことができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">繰り返しますが、これは</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード全体を完全に塗りつぶす必要</font><font style="vertical-align: inherit;">がある唯一のパラメーター</font><font style="vertical-align: inherit;">ですが、私の意見では、ほとんどのタスクでは</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">何が起こったかを知る必要があるだけであり、これから</font><font style="vertical-align: inherit;">、キャンセルまたは失敗のどちらであるかの結論を導き出します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認知の複雑さ</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの開始時にコードを読み取るのが難しいほど、エラーのリスクが高くなります。 1年後にコードを見ると、多数のパラメーターがあるため、コードの機能を忘れてしまいます。しかし、我々は持っている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimesの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリ</font><font style="vertical-align: inherit;">Startメソッドを書き換えたと近代的な寿命を提供しています、よく最適化されたCancellationToken、およびコードの断片を持つよう、解決された繰り返しの問題点</font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などを</font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りロックを使用してメインスレッドでタスクをスケジュールできる少数のスケジューラがあります。つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取りロックが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それは特別なスケジューラである、あなたが明示的に選択することを何かではないことと、メインスレッド上のスケジュールあなたのコードを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取りロック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および書き込みロック付きのメインスレッド、バックグラウンドスレッドと同様に、シャッフルを開始するためのメソッドが非常に簡単になります。同時に、ライフタイムはを介して自動的にキャンセルされる</font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、コードが大幅に簡素化されます。</font><i><font style="vertical-align: inherit;">非同期/待機が</font></i><font style="vertical-align: inherit;">これらの問題</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
をどのように</font><font style="vertical-align: inherit;">解決するか、そしてそれらが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もたらす</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を</font><font style="vertical-align: inherit;">見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、コードの一部が同期的に実行され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から、非同期コードを待ちます。まず、コードの繰り返し部分（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボイラープレート</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">がはるかに少ないのは良いこと</font><font style="vertical-align: inherit;">です。第2に、非同期コードが同期コードと非常によく似ているのは良いことです。これがまさに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期/待機の目的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。スレッドを使用せずに、同期で記述したのと同じ方法で非同期に記述できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、コンパイラは何を展開しますか？同期コードは同期的に実行され、その後、タスク</font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">同期的</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">実行さ</font><font style="vertical-align: inherit;">れます。特別なGetAwaiterオブジェクトはどこから取得されますか。この場合、私たちは興味があり</font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。あなたは絶対にどんなオブジェクトに対してもあなたのウェイターを書くことができます。その結果、タスクが完了するのを待ち</font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同期して実行し</font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。タスクが完了しなかった場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Context schedulerでスケジュールされ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。あなたが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を書いたとしても</font><font style="vertical-align: inherit;">、絶対にすべてが同期的に呼び出される</font><font style="vertical-align: inherit;">かもしれません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トリックが1つあり</font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、その待機者が常にあなたに戻るとは限らないことを保証する特別なタスクです</font><font style="vertical-align: inherit;">。したがって、</font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場所では同期的に呼び出されません。 UIスレッドの場合、このスレッドを長時間使用しないため、これは重要な場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継続するスレッドを選択するには？</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / awaitの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え方は</font><font style="vertical-align: inherit;">次のとおりです。同期と同じ非同期コードを記述します。あなたが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドプール</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持っている場合</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">それは</font><font style="vertical-align: inherit;">あなたに違い</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ません-continuationCodeは別のスレッドで実行されます。かかわらず、それがされたかどうかの</font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたが言ったときに完了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のawait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かどうか、あなたはUIスレッド上で実行するすべてのものを必要としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク待機のメカニズムは次のとおりです：取得され</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、呼び出されます</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それから作成され</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はPostメソッドを備えたもので、メソッドと非常によく似てい</font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">実際</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これは以前のバージョンで</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、Postを介し</font><font style="vertical-align: inherit;">て単純に</font><font style="vertical-align: inherit;">タスクを実行します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータを使用してこの動作を変更する方法があります</font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">.NETにある最も嫌なAPIはと呼ばれ</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この場合、APIは</font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、継続をシフトするものと</font><font style="vertical-align: inherit;">は異なる特別なawaiterを作成し</font><font style="vertical-align: inherit;">、メソッドが終了した同じコンテキストで同じスレッドで実行され</font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タスクが終了しました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターネットには非常に多くのアドバイスがあります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロックが発生し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている場合は、</font><font style="vertical-align: inherit;">ConfigureAwaitコードをすべて塗りつぶしてください。</font><font style="vertical-align: inherit;">これは間違った方法です。</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のライブラリメソッドで、パフォーマンスをわずかに向上させたい場合、またはメソッドの最後に使用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは古典的な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">UIスレッドでは、10秒待ってから待機しました</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたがしたことのために</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それ</font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は決して起動されません、</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それゆえ</font><font style="vertical-align: inherit;">、それ</font><font style="vertical-align: inherit;">は決して戻る</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">はありません。</font><font style="vertical-align: inherit;">それはすべて最初に行われます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが実際の活動であると想像してください。私たちはボタンをクリックし、それ</font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け取り</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">待機し</font></i><font style="vertical-align: inherit;">、次のように書きました</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：「UIストリームを閉じないでください。継続を実行してください。」問題は、2番目の部分</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もUIスレッドで実行されるようにすることです。これが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の哲学だから</font><font style="vertical-align: inherit;">です。つまり、非同期コードは同期コードと同じように見え、同じコンテキストで実行されます。もちろん、この場合はエラーになります。また</font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンテキストを想定するメソッド呼び出しがいくつあってもかまいません。この状況で何をすべきか？あなたはこれを行うことができます：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UI </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドでは、共通のメッセージキューを持つスレッドで</font><font style="vertical-align: inherit;">これ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">行うこと</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">禁止する必要があり</font><font style="vertical-align: inherit;">ます。を実行し</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たり書き込んだりする</font><font style="vertical-align: inherit;">代わりに、</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このメッセージのキューをポンプすることができます。同時に、連続体もポンプされます。同期コードと非同期コードを混在させることができない場合は、それらを混在させないでください。しかし、これは避けられないことがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、古いコードがあり、それらを混合する必要がある場合は、UIストリームをポンプします。 Visual Studioは期待に応じてUIスレッドをポンプします</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。少し変更されています。のいずれか</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">WaitHandleに入ると</font><font style="vertical-align: inherit;">、ハングすると、UIストリームがポンプされます。したがって、彼らは</font><font style="vertical-align: inherit;">人種を優先して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と人種の</font><font style="vertical-align: inherit;">どちらかを選択します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは理想的ではないAPIです。つまり、任意の場所でランダムな連続性を実行すると、ニュアンスが生じる可能性があります。</font><font style="vertical-align: inherit;">残念ながら他に方法はありません。</font><font style="vertical-align: inherit;">同期コードと非同期コードを混在させます。</font><font style="vertical-align: inherit;">どちらかと言えば、ライダー全体が古い場所に配置されているので、ニュアンスも時々あります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストを変更</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用する別の興味深い方法があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">あなたは書い</font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スレッドにジャンプ</font><font style="vertical-align: inherit;">することができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私はVisual Studioで投稿を読みましたが、メソッドの途中で前後にジャンプするのは良くないという長い間書いていましたが、今では自分で行っています。</font><font style="vertical-align: inherit;">Visual Studioには、スケジューラを介してスレッドにジャンプするAPIがあります。</font><font style="vertical-align: inherit;">通常の使用では、これを行うのはよくありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造化された並行性</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいコンテキストに没頭し、古いコンテキストに戻すのに便利なように、いくつかの構造的競合、または構造的並列処理を構築する必要があります。</font><font style="vertical-align: inherit;">たとえば、60年代には、GoTo演算子は構造に違反しているため、有害であると見なされていました。</font><font style="vertical-align: inherit;">だからここです。</font><font style="vertical-align: inherit;">スレッドでジャンプすると、構造に違反します。</font><font style="vertical-align: inherit;">驚いたことに、非同期状態マシンを使用することは良い方法のように思えます。</font><font style="vertical-align: inherit;">つまり、通常の構造に違反している場合、GoToにジャンプし、スレッド構造に違反する可能性が</font><font style="vertical-align: inherit;">あります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><i><font style="vertical-align: inherit;">て</font></i><font style="vertical-align: inherit;">、タグと</font><font style="vertical-align: inherit;">混ぜ</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">ください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行う必要がある場合、これは非常に奇妙でまれな状況です。</font><font style="vertical-align: inherit;">それでも、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が同じコンテキストに戻る</font><font style="vertical-align: inherit;">ときはより良い</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">したがって、スレッドプールには同じスレッドはありませんが、元のコンテキストと同じです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順次動作</font></font></h3><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaitが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列実行と同じで</font><font style="vertical-align: inherit;">
は</font><font style="vertical-align: inherit;">ないのは</font><font style="vertical-align: inherit;">なぜ</font><font style="vertical-align: inherit;">ですか？</font><font style="vertical-align: inherit;">待機実行は順次実行です。</font><font style="vertical-align: inherit;">この場合、最初のタスクを開始して待機し、2番目のタスクを開始します-待機します。</font><font style="vertical-align: inherit;">並列処理はありません。</font><font style="vertical-align: inherit;">ほとんどの場合、並列処理は必要ありません。</font><font style="vertical-align: inherit;">並列処理自体はシーケンスよりも複雑です。</font><font style="vertical-align: inherit;">シリアルコードはパラレルよりも単純で、公理です。</font><font style="vertical-align: inherit;">しかし、時には並列コードで何かを実行する必要があり、次のように実行します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時行動</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、タスクが並行して開始されます。</font><font style="vertical-align: inherit;">メソッドが実行状態ですぐにタスクを返すことができることは明らかです。そうすれば、並列処理はありません。</font><font style="vertical-align: inherit;">両方のタスクが実行をスローするとします。</font><font style="vertical-align: inherit;">そして、あなたは最初のタスクを待ってから、最初の待機で離陸しました。</font><font style="vertical-align: inherit;">つまり</font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あなたが</font><font style="vertical-align: inherit;">書いた直後に</font><font style="vertical-align: inherit;">、あなたは離陸し、処理しませんでした</font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">興味深いことに、これは絶対に有効なコードです。</font><font style="vertical-align: inherit;">そして、このコードが.NETを導いたのは、バージョン4.5で実行操作の動作が変更されたという事実です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外処理</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1’s exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don’t crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、未処理の実行は単にプロセスをスローし、一部の実行をキャッチしなかった場合</font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（これは</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケジューラにアタッチできる</font><font style="vertical-align: inherit;">もので</font><font style="vertical-align: inherit;">もあります）、このプロセスは実行されませんでした。これは絶対に有効なコードです。 .NETは動作を変更しましたが、動作を反対方向に戻す設定を保持していました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行の処理がどのように行われるかを確認します。</font><font style="vertical-align: inherit;">CancellationToken-sを送信する必要があります。すべてのコードをCancellationToken-sに「塗り付ける」必要があります。</font><font style="vertical-align: inherit;">asyncの通常の動作は</font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">どこもチェックしないことです</font><font style="vertical-align: inherit;">。同期コードと同じ方法で非同期コードを操作します。</font><font style="vertical-align: inherit;">つまり、キャンセルの場合は実行され、この場合は受信しても何も行われません</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CancelledとFaultedのステータスの違いは、</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではなく通常の実行を</font><font style="vertical-align: inherit;">受け取ったことです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そしてこの場合、私たちはそれを誓約することができます、あなたは実行を取得してこれに基づいて結論を出す必要があるだけです。</font><font style="vertical-align: inherit;">Taskを使用して明示的にタスクを開始した場合は、飛んでいることになります</font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして非同期では、彼らが</font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に最初の実行をスロー</font><font style="vertical-align: inherit;">した場合</font><font style="vertical-align: inherit;">（この場合- </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際には</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期方式</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、デーモンはReSharperで動作します-ReSharperは、ファイルに色を付けるエディタです。</font><font style="vertical-align: inherit;">ファイルがエディターで開かれている場合は、それをブロッキングキューに入れるアクティビティがいくつかあります。</font><font style="vertical-align: inherit;">私たちのプロセス</font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそこから読み取り、その後、このファイルを使用して一連のさまざまなタスクを実行し、色を付け、解析し、ビルドしてから、これらのファイルをに追加し</font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロック、その他の機構はすでにそれに取り組んでいます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期メソッド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期にコードを書き換える場合、まず、すべてのは、それに取って代わるだろう</font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後に必ず「非同期」と書いてください。</font><font style="vertical-align: inherit;">すべての非同期メソッドはAsyncで終わる必要があります-これは規則です。</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、私たちのもので何かをする必要があります</font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。明らかに、同期プリミティブがある場合は、非同期プリミティブが必要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプリミティブはチャネルと呼ばれます：パッケージに含まれるチャネル</font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。チャネルとキューを作成でき、制限付きと制限なしで非同期に待機できます。さらに、「ゼロ」の値を持つチャネルを作成できます。つまり、バッファがまったくありません。このようなチャネルはランデブーチャネルと呼ばれ、GoとKotlinで積極的に宣伝されています。原則として、非同期コードでチャネルを使用できる場合、これは非常に良いパターンです。つまり、メソッド</font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">があるチャネルにキューを変更します</font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ファイルの処理を実行してそれを変換する一連の並列コードです。</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">非同期は、非同期ではなく並列コードをよりコンパクトに記述するのに役立ちますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列コードを簡素化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードは次のように書き換えることができます：</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはどのように見えます</font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？たとえば、ファイルがあります。まず、それを語彙素に分割します。検索キャッシュの構築と構文ツリーの構築という2つのタスクを並行して行うことができます。その後、「セマンティックエラーを検索する」というタスクが続きます。ここで重要なことは、これらすべてのタスクが有向非循環グラフを形成することです。つまり、一部は並列​​スレッドで実行でき、一部は実行できず、他のタスクを待機する必要があるタスクには明らかに依存関係があります。このようなタスクのグラフが表示されたら、どういうわけかそれらをスレッドに沿って分散させます。エラーなしで美しく書くことは可能ですか？私たちのコードでは、この問題は数回、それぞれ異なる方法で解決されました。このコードがエラーなしで書かれている場合はめったに起こりません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタスクグラフを次のように定義します。各タスクが依存する他のタスクがあるとします。次に、ExecuteBefore辞書を使用して、メソッドのスケルトンを記述します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケルトンソリューション</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を正面から解決する場合は、このグラフのトポロジカルソートを行う必要があります。</font><font style="vertical-align: inherit;">次に、依存タスクのないタスクを実行し、それを実行し、ロックの下で構造を分析し、どのタスクに依存タスクがないかを確認します。</font><font style="vertical-align: inherit;">走って、何とかしてそれらを散らしてください</font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もう少しコンパクトに書きます。グラフのトポロジカルソート+異なるスレッドでのそのようなタスクの実行。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期レイジー</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
というパターンがあり</font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなアクションを実行する必要がある</font><font style="vertical-align: inherit;">ものを作成します</font><font style="vertical-align: inherit;">。辞書を作成してみましょう。各ステージ（Action ProcessedFile）をいくつかのタスク、またはむしろタスクからレイジーにフォーマットし、元のグラフに沿って実行します。変数</font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクション</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自体</font><font style="vertical-align: inherit;">があり、beforeListに</font><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">アクションの</font></i><font style="vertical-align: inherit;">前に実行する必要のあるアクションがあります。次に、</font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">作成</font><font style="vertical-align: inherit;">し</font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 Taskに書き込み</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。したがって、私たちはそれより前に完了しなければならないすべてのタスクを待っています。 beforeListで、</font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この辞書に</font><font style="vertical-align: inherit;">あるもの</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">選択します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは何も同期的に実行されないので、このコードは当てはまりません</font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私たちは以前のすべてのタスクを実行し、アクションによる検索を実行します</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、アクションを実行します。</font><font style="vertical-align: inherit;">最後に、各タスクを開始するように要求するだけでよく、そうでない場合、何かが開始されなかったかどうかはわかりません。</font><font style="vertical-align: inherit;">この場合、何も始まりませんでした。</font><font style="vertical-align: inherit;">これが解決策です。</font><font style="vertical-align: inherit;">このメソッドは10分で作成されますが、それは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、非同期コードが私たちの決断を下しました。最初は、複雑な競争力のあるコードがいくつかの画面を占めていました。</font><font style="vertical-align: inherit;">ここで彼は完全に一貫しています。</font><font style="vertical-align: inherit;">私はそれ</font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません。私はそれを競争的に書いていないので</font><font style="vertical-align: inherit;">、私は通常のものを使用し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">一貫した一貫したコードがあります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して並列コードを作成する問題を</font><font style="vertical-align: inherit;">美しく</font><font style="vertical-align: inherit;">解決します</font><font style="vertical-align: inherit;">。つまり、バグなしで解決します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックを取り除く</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期とこれらのロックを取得する価値はありますか？これで、あらゆる種類の非同期ロック、非同期セマフォ、つまり、同期コードと非同期コードにあるプリミティブを使用しようとする試みがあります。ロックを使用すると、並列実行から何かを保護するため、この概念は間違っているようです。私たちのタスクは、並列実行をシーケンシャルに変換することです。そして、それが単純であれば、エラーは少なくなります。</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのチャネルを作成し、そこにいくつかのFileとProcessedFileを置くことができます。</font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のいくつかのプロシージャが</font><font style="vertical-align: inherit;">このチャネル</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">処理</font><font style="vertical-align: inherit;">し、それを順番に実行します。ロック自体は、構造を保護することに加えて、基本的にアクセスを線形化します。この場所では、連続するスレッドからのすべてのスレッドが並列になります。そして、これを明示的にチャネルに置き換えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャは次のとおりです。ワーカーは、ファイルを取得</font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、どこかにプロセッサーに送信し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">プロセッサーは、すべてを順次処理します。並列処理はありません。コードははるかに単純に見えます。私はすべてがこのようにできるわけではないことを理解しています。このようなアーキテクチャは、データパイプを構築できる場合、常に機能するとは限りません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサーに入る2番目のチャネルがあり、チャネルから非循環有向グラフではなく、サイクルを持つグラフが形成されている可能性があります。</font><font style="vertical-align: inherit;">これは、2018年にローマンエリザロフがKotlinConfに伝えた例です。</font><font style="vertical-align: inherit;">彼はこれらのチャネルを使用してKotlinで例を書き、そこにサイクルがあり、この例はシャットダウンされました。</font><font style="vertical-align: inherit;">問題は、グラフにそのようなサイクルがある場合、非同期の世界ではすべてがより複雑になることでした。</font><font style="vertical-align: inherit;">非同期デッドロックは、スレッドのスタックがある場合、同期デッドロックよりも解決がはるかに困難であり、何が掛かっているのかは明らかです。</font><font style="vertical-align: inherit;">したがって、正しく使用する必要があるツールです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期コードでの同期を避けます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアルコードはパラレルコードよりも単純です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期コードは単純で、最小限のパラメーターとその動作を変更する暗黙のコンテキストを使用できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期コードを書く習慣を身につけた場合、非同期コードが同期コードと非常に似ていても、同期コードで慣れているプリミティブをそこにドラッグする必要はありません</font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。可能であればフィードを使用し、その他の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージ渡し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブを使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリアルコードはパラレルコードよりも単純です。並列コードを実行したりロックしたりせずに、シーケンシャルに見えるようにアーキテクチャを記述できる場合は、アーキテクチャをシーケンシャルに記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、タスクに関する多くの例から私たちが見た最後のもの。</font><font style="vertical-align: inherit;">システムを設計するときは、暗黙のコンテキストに依存しないようにしてください。</font><font style="vertical-align: inherit;">暗黙的なコンテキストは、コードで何が起こっているかについて誤解を招き、1年以内に暗黙的な問題を忘れることができます。</font><font style="vertical-align: inherit;">そして、別の人がこのコードに取り組み、その中の何かをやり直す場合、これはあなたがかつて知っていた困難につながり、暗黙のコンテキストのために新しいプログラマーは知らないかもしれません。</font><font style="vertical-align: inherit;">その結果、貧弱な設計は、多数のパラメーター、それらの組み合わせ、および暗黙のコンテキストによって特徴付けられます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何を読むか</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAPドキュメント</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期ガイダンス</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寿命</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491218/index.html">PlatformIOでのPVS-Studioの統合</a></li>
<li><a href="../ja491224/index.html">派遣サービスの自動化、またはサービス会社が輸送コストを30％削減する方法</a></li>
<li><a href="../ja491230/index.html">21学校への行き方と秘密の開示</a></li>
<li><a href="../ja491232/index.html">RPA +機械学習=インテリジェントオートメーション</a></li>
<li><a href="../ja491234/index.html">3Dプリント用にパーツをモデリングするためのSOLIDWORKSの操作に関する3つのコツ</a></li>
<li><a href="../ja491238/index.html">遺伝コード分析II</a></li>
<li><a href="../ja491240/index.html">クラウドへの道：昨日と今日のアドビ</a></li>
<li><a href="../ja491244/index.html">Abletonは必要ありません：Ableton Push 2をVCVラックに接続します</a></li>
<li><a href="../ja491246/index.html">DEFCON会議27.あなたの車は私の車です。パート2</a></li>
<li><a href="../ja491250/index.html">LEDランプGauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>