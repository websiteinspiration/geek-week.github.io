<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❔ 👐🏼 🍓 教科書よりも部分文字列検索を書く 🧑 👸🏼 👉🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="エンジニアの人生は驚きに満ちています。特に生産性に対処する必要がある場合はなおさらです。たとえば、このJavaコードを実行しようとするとどうなりますか？それはかなり無邪気に見えます：
 
 

// String.repeat JDK 11 : final var needle = "A".repe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>教科書よりも部分文字列検索を書く</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491750/"><img src="https://habrastorage.org/webt/ri/ei/to/rieitoeutxefbbjts6ag-carfqk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジニアの人生は驚きに満ちています。特に生産性に対処する必要がある場合はなおさらです。</font><font style="vertical-align: inherit;">たとえば、このJavaコードを実行しようとするとどうなりますか？</font><font style="vertical-align: inherit;">それはかなり無邪気に見えます：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//   String.repeat  JDK 11  :</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> needle = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">500000</span>) + <span class="hljs-string">"B"</span>;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> haystack = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">1000000</span>) + <span class="hljs-string">"B"</span>;<font></font>
System.out.println(haystack.indexOf(needle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
待つ、待つ、待つ...少なくとも私の2015 OpenJDK 13ラップトップでは、干し草の山から針を見つけるのに約1分かかります。</font><font style="vertical-align: inherit;">私たちの古き良きJVMは何十年ものパフォーマンスチューニングを経ており</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのための</font><font style="vertical-align: inherit;">組み込み関数などを効果的に実装</font><font style="vertical-align: inherit;">しています。</font><font style="vertical-align: inherit;">何が悪かったのでしょうか？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、著者である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LinasMedžiūnasの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好意によるいくつかの一連の記事の始まりであり</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WiX Engineering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> blogで最初に公開されました</font><font style="vertical-align: inherit;">。</font></font><br>
</blockquote><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力内容を詳しく見てみましょう。データは</font><font style="vertical-align: inherit;">、ナイーブな部分文字列検索アルゴリズム</font></font><code>O(nm)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">最悪の場合（</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は長さ</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は長さ</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">2次パフォーマンスを実現するように特別に選択されてい</font><font style="vertical-align: inherit;">ます。内のすべての文字</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を調べ、最初の文字と一致する場合</font><font style="vertical-align: inherit;">は、内側のループ</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から順に検索を開始し</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、最初の不一致文字まで続けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような入力データは特別に設計およびファイルされているため、この例は役に立たないと主張するかもしれませんが、実際にはこれは発生しません。考え直してください。ユーザーが任意の文字列をロードできるWebサービスで作業していて、サービスの後ろのどこかに実行されるコードがある場合はどうなるでしょうか。</font></font><code>indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの行に？次に、上記のようないくつかの悪意のあるリクエストだけで、サービスが危険にさらされます。少なくとも、入力データの最悪のケースについて知っておく価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いなことに、</font><font style="vertical-align: inherit;">線形複雑度（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を持つ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分文字列検索アルゴリズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります</font></font><code>O(n+m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。上記の例のデータに問題はありません。たとえば、次のScalaコードは同じことを行いますが、同じコンピューター、同じJVMでミリ秒単位で実行され、内部ではまったく同じものを使用します</font></font><code>java.lang.String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">val needle = <span class="hljs-string">"A"</span> * <span class="hljs-number">500000</span> + <span class="hljs-string">"B"</span>
val haystack = <span class="hljs-string">"A"</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">"B"</span>
println(haystack.indexOfSlice(needle))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きな違いの秘密</font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Scala標準ライブラリの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部である</font><font style="vertical-align: inherit;">メソッド内にあり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。巧妙な線形</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムを実装しています</font><font style="vertical-align: inherit;">。いいえ、私はX言語がY言語よりも優れていると言っているわけではありません。残念ながら、ここではすべてがはるかに複雑です！たとえば</font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Scalaでは、これは文字列だけでなく他の順次コレクションでも機能する一般化されたメソッドであり、文字だけでなく他の型の要素も比較できます。それよりもはるかに遅いはずです</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中間のJavaから（これについては後で説明します）。したがって、最悪の場合でもパフォーマンスがはるかに優れた効率的なアルゴリズムがありますが、定数部分がはるかに大きいため、平均すると低速になります。このようなジレンマは、パフォーマンスのチューニングにおける典型的な問題です。すべての問題を解決する魔法の薬はありません。問題を注意深く分析し、適切なマイクロベンチマークを作成する必要があります。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはまだ私と一緒ですか良い！ほら、これは単なる紹介です。アルゴリズムの理論的な複雑さと実際のパフォーマンスに対処するように動機づけたいと思いました。この記事の残りの部分では、いくつかの部分文字列検索アルゴリズムの実装とそのベンチマークについて見ていきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つの部分文字列検索アルゴリズムについて説明します。これらはすべて線形時間で動作し、長さに線形依存する前処理が必要です</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同じの計算は</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一度だけ必要であり、その後、いくつかの検索試行で再利用できます。多くの場合、同じ行を何度も検索する必要があるため、これは妥当です。また、これを行わなくても、事前計算はそれほど高価な操作ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のすべてのアルゴリズムは、各文字をバイパスします</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連続して1回だけ（インデックスによるランダムアクセスなし）、ストリーミングモードですべて正常に動作します。</font><font style="vertical-align: inherit;">この記事は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワークに基づくプロダクション用のプロキシサーバーに関する実際の作業中に発生したもの</font><font style="vertical-align: inherit;">であり、これはAPI設計の決定の一部に影響を与えました。</font><font style="vertical-align: inherit;">さらに、バイトバッファで検索を行う必要があるため、コードはで</font></font><code>Byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はなくで機能し</font></font><code>Char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt（KMPアルゴリズム）</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、前世紀の70年代にさかのぼる有名な部分文字列検索アルゴリズムです。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に詳しく説明されているので、ここでは詳しく説明しません。</font><font style="vertical-align: inherit;">ILCは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートマシンに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づいてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます。</font></a><font style="vertical-align: inherit;">予備計算フェーズでは、に基づいてリンクインデックスの配列が構築されます</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">検索中、マシンは入力</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で1つずつ</font><font style="vertical-align: inherit;">文字を受け入れ</font><font style="vertical-align: inherit;">、それに応じて内部状態を更新します（状態は関係テーブルにインデックスがあるだけです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scalaでの実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ部分文字列検索アルゴリズム</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、このアルゴリズムの名前を独自に考案する必要がありました。このようなものは文献のどこにも見たことがありません。その結果、「シフトビットマスク」という名前になりました。その後、このアルゴリズムとそのバリエーションは</font><font style="vertical-align: inherit;">、「Bitap」、「Shift-or」、「Shift-and」、「Baeza-Yates-Gonnet」などの</font><font style="vertical-align: inherit;">さまざまな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英語の名前で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1964年から知られていることが</font><font style="vertical-align: inherit;">わかりました。私のためにそれを見つけた読者に感謝します。この記事はこのニュースのずっと前に書かれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアルゴリズムは非常に単純なアイデアに基づいており、ジャンプがほとんどないため非常にうまく機能し、いくつかの基本的なバイナリ演算に基づいています。このため、</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索</font><font style="vertical-align: inherit;">する長さ</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">制限</font><font style="vertical-align: inherit;">があります。64バイトより長くすることはできません。この数は、単にビット数によって取得されました</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMで。</font><font style="vertical-align: inherit;">この制限は、多数の実際のタスクに対して十分に寛大です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はもともとこのアルゴリズムを自分で開発したので、このアルゴリズムについて詳しく説明します。</font><font style="vertical-align: inherit;">まず、目的のコンテキストの検索コンテキストを事前に計算します</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeBitMasks</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Array</span>[<span class="hljs-type">Long</span>] = {<font></font>
    require(needle.length &lt;= <span class="hljs-number">64</span>, <span class="hljs-string">"Maximum supported search pattern length is 64."</span>)
    <span class="hljs-keyword">val</span> bitMasks = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Long</span>](<span class="hljs-number">256</span>)
    <span class="hljs-keyword">var</span> bit = <span class="hljs-number">1</span>L
    <span class="hljs-keyword">for</span> (c &lt;- needle) {<font></font>
      bitMasks(toUnsignedInt(c)) |= bit<font></font>
      bit &lt;&lt;= <span class="hljs-number">1</span><font></font>
    }<font></font>
    bitMasks<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能なバイト値（256個</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">ごとに</font><font style="vertical-align: inherit;">
事前計算</font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（64ビット</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）します</font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一部のバイト値の場合</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>bitmask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての場所の単位が含ま</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">たとえば、文字列 "abracadabra"のビットマスクは次のとおりです</font><font style="vertical-align: inherit;">
。さらに、を事前に計算する必要があります</font><font style="vertical-align: inherit;">。これは、完全一致が見つかったことを理解するのに役立ちます。</font><font style="vertical-align: inherit;">それは値のように見え</font><font style="vertical-align: inherit;">、少し</font><font style="vertical-align: inherit;">位置が異なり</font><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<a rel="noopener noreferrer" href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/099/0d9/f95/0990d9f9590612cce258139fb7c287bd.png"></a><br>
<br><font style="vertical-align: inherit;"></font><code>successBitMask</code><font style="vertical-align: inherit;"></font><code>Long</code><font style="vertical-align: inherit;"></font><code>1</code><font style="vertical-align: inherit;"></font><code>needle.length — 1</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeSuccessBitMask</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Long</span> = {
    <span class="hljs-number">1</span>L &lt;&lt; (needle.length - <span class="hljs-number">1</span>)<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、実際には検索を行う必要があります。保存したい唯一の変更可能な状態は</font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）です。の各バイトについて</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">ビットを</font><font style="vertical-align: inherit;">左</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にシフト</font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その最下位ビットをに設定し</font><font style="vertical-align: inherit;">、現在の処理済みバイト値に対して計算された</font><font style="vertical-align: inherit;">結果との間で</font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビット単位</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で行い</font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（これ</font><font style="vertical-align: inherit;">により、現在の処理済みバイトと一致しない</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場所のすべてのビットがクリア</font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、各バイトを処理した後、適切な位置にあるビットのみが存続します。そして、各バイトが処理されると、すべてのビットが1ポジション左にシフトされます。長さに等しい反復回数の間にビットが「存続」する場合</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-私たちは一致を見つけました！そして、これを確認することができます</font></font><code>successBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(value: <span class="hljs-type">Byte</span>): <span class="hljs-type">Boolean</span> = {<font></font>
    currentMask = ((currentMask &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>) &amp; bitMasks(toUnsignedInt(value))<font></font>
    (currentMask &amp; successBitMask) == <span class="hljs-number">0</span>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：上記のメソッドは</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、何かが見つかると</font><font style="vertical-align: inherit;">戻り</font><font style="vertical-align: inherit;">、直観に反するように見えます。</font><font style="vertical-align: inherit;">これは、値</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が検索を続行する必要があることを意味するが、それを</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">停止する</font><font style="vertical-align: inherit;">ことで理解できます。</font><font style="vertical-align: inherit;">これは、上で書いたように、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APIが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nettyと互換性</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">があったため</font></a><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">検索の実行方法を知りたい場合</font><font style="vertical-align: inherit;">は、次の例を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、すべてのロジックは、いくつかの単純なプロセッサ命令に要約されます。</font><font style="vertical-align: inherit;">残念ながら、配列のインデックスの境界の完全に役に立たないチェックが残っており、</font></font><code>bitMasks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDKではこれを削除できません（いくつかの異なるJDKによって生成されたアセンブラを調べました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scalaで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">完全な実装</font></a><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アホコラシック</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font><font style="vertical-align: inherit;">、1975年以来知られて</font><font style="vertical-align: inherit;">いるもう1つの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なアルゴリズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。その際立った（そして時には非常に便利な）機能は、</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時に</font><font style="vertical-align: inherit;">複数</font><font style="vertical-align: inherit;">の文字</font><font style="vertical-align: inherit;">を検索できることですが、</font><font style="vertical-align: inherit;">からのすべての文字</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は1回だけバイパスされます（すばらしいと思います！）。これがすべて機能するという考えは、KMPアルゴリズムの拡張であり、</font><font style="vertical-align: inherit;">リンクへのリンクを含む（</font><font style="vertical-align: inherit;">いくつかのに基づいて構築された</font><font style="vertical-align: inherit;">）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレフィックスツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用した有限状態マシン</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">です</font></a><font style="vertical-align: inherit;">（</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KMPの1次元配列と比較してください）。これらのリンクに基づいて、オートマトンの内部状態は、処理された各シンボルの後に接頭辞ツリーのノード間で切り替えられ、一部のノードは特定の</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここでの事前計算フェーズはかなり複雑ですが、検索フェーズは予想外に非常に単純です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Scalaで</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
動作する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へのリンクを次に示し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、部分文字列検索アルゴリズムの完全に不完全なリストでした。</font><font style="vertical-align: inherit;">また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabin-Karp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boyer-Moore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム</font><font style="vertical-align: inherit;">も試しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これら2つのうち、Boyer-Mooreは同等のパフォーマンスを示しましたが、どちらも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーミング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスによる</font><font style="vertical-align: inherit;">ランダムアクセスを使用）</font><font style="vertical-align: inherit;">と互換性がない</font><font style="vertical-align: inherit;">ため、この調査から除外しました。</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマーク</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の3つのアルゴリズムをベンチマークし、さらにメソッド</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Java）と</font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Scala）</font><font style="vertical-align: inherit;">の結果を確認し</font><font style="vertical-align: inherit;">ます。正直なところ、これは完全に正しい比較ではありません。</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">動作し、他のすべてのメソッドはバイト配列にあるためです。しかし、これはそのような比較の結果を無効にするようには見えません。さらに、</font></font><code>Bytes.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グアバ（v.28.1）の</font><font style="vertical-align: inherit;">結果も含めました</font><font style="vertical-align: inherit;">。このメソッドはバイト配列で機能します。そして、彼らはそれをグーグルで書いた-彼らがそこに書いたものはすべて超高速で機能する、そうだろ？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはさまざまな方法でそれを変更し、入力に完全に異なるデータを送信することができますので、ベンチマークを書くことは、常に困難である-だけでなく、長さに</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけでなく、これらの行の内部コンテンツによっても異なります（一部のアルゴリズムに大きな影響を与える可能性があります）。実際には、実際のタスクからのデータに最も類似している入力データをチェックすることは常に価値があります（これは私たちのプロジェクトで行ったものです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を短くするために、2種類の入力のみを使用しました。それらの1つは、実際のケースを反映することを目的としています：</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約1.5 KB（人間が読めるテキストを含む）</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-9バイトで、</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このシーケンス</font><font style="vertical-align: inherit;">ではありません</font><font style="vertical-align: inherit;">（これは、アルゴリズムにフルスキャンを実行させるために必要です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二次アルゴリズムの最悪の場合の動作を取得するには、別のタイプの入力が必要です。これは、この記事の冒頭のデータよりもはるかに短いです。それ以外の場合、1分ほど待たなければならないでしょう、覚えていますか？アレイ</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式</font></font><code>"AA...AAB"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（最初のデータ型と同じ長さ</font><font style="vertical-align: inherit;">）で設定され、</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-64バイト（特にバイナリ部分文字列検索アルゴリズムがそれを処理する場合）同じ型の配列（一致は最後にのみ存在し</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JMHフレームワークで記述されたベンチマークは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここで何をどのように測定するかについて他のアイデアがある場合は、このリポジトリのクローンを作成し、何かを変更してコメントを投稿できます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウラジミール・シトニコフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の提案で</font><font style="vertical-align: inherit;">、私はのベンチマーク結果を追加しました</font></font><code>java.util.regex.Pattern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;彼は内部でボイヤー・ムーアアルゴリズムを使用しています。</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（翻訳者注：ちなみに、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウラジミール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シトニコフはJUG Ruグループのいくつかのプログラム委員会のメンバーであり、彼自身も興味深いレポートを作成しています。たとえば</font><font style="vertical-align: inherit;">、JPoint 2019 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼のレポートの「Javaが遅くなる：CodeCacheエディション」というタイトルの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ビデオは、リンクから入手できます</font></a><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマーク結果</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はミリ秒単位で与えられ、少ないほど良いです：</font><font style="vertical-align: inherit;">
ここではすべてが期待どおりです：</font></font><br>
<br>
<code># JMH version: 1.21<br>
# VM version: JDK 13.0.1, OpenJDK 64-Bit Server VM, 13.0.1+9<br>
Benchmark (searchInput) Mode Cnt Score Error Units<br>
javaIndexOf REGULAR avgt 5 0.622 ± 0.002 us/op<br>
shiftingBitMask REGULAR avgt 5 1.982 ± 0.017 us/op<br>
regexPattern REGULAR avgt 5 2.184 ± 0.006 us/op<br>
kmp REGULAR avgt 5 2.635 ± 0.016 us/op<br>
scalaIndexOfSlice REGULAR avgt 5 3.202 ± 0.009 us/op<br>
guavaIndexOf REGULAR avgt 5 3.696 ± 0.095 us/op<br>
ahoCorasic REGULAR avgt 5 7.063 ± 0.040 us/op<br>
shiftingBitMask WORST_CASE avgt 5 1.986 ± 0.010 us/op<br>
kmp WORST_CASE avgt 5 5.120 ± 0.006 us/op<br>
ahoCorasic WORST_CASE avgt 5 6.892 ± 0.025 us/op<br>
scalaIndexOfSlice WORST_CASE avgt 5 8.765 ± 0.007 us/op<br>
regexPattern WORST_CASE avgt 5 11.566 ± 0.086 us/op<br>
javaIndexOf WORST_CASE avgt 5 23.029 ± 0.124 us/op<br>
guavaIndexOf WORST_CASE avgt 5 52.927 ± 0.275 us/op<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のデータでは、</font></font><code>javaIndexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部で非常に効率的な組み込み関数を使用</font><font style="vertical-align: inherit;">している</font><font style="vertical-align: inherit;">ため、定数部分が小さいため</font><font style="vertical-align: inherit;">、それが支配</font><font style="vertical-align: inherit;">的です。</font></font></li>
<li>     ,  :     ,     (<code>O(nm)</code>)   <code>javaIndexOf</code>,           —      ,  <code>shiftingBitMask</code> (  )   .</li>
<li><code>guavaIndexOf</code>      ,    <code>javaIndexOf</code>;  ,        2  ,    <code>shiftingBitMask</code>;</li>
<li><code>scalaIndexOfSlice</code>  -  ,  <code>knuthMorrisPratt</code>,   ,      —   ,  ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスは最強の機能ではありません</font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または少なくともその実装ではありません。複数の行を一度に検索する機能と、別の記事のトピックに似ています）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力データ（および長さは</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、パフォーマンスに影響を与えなかった</font></font><code>shiftingBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、ベンチマークはさまざまな方法で機能します。</font><font style="vertical-align: inherit;">上記の結果は非常に示唆的であるように見えますが、常に自分で測定し、実際のタスクを反映するデータを測定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提示されたデータに基づいて、私は次の結論を出しました。</font></font><br>
<br>
<ul>
<li>    <code>String</code>-   ,           ,   <code>String.indexOf</code> ( <code>java.util.regex.Pattern</code> —      );</li>
<li>,   <code>needle</code>   64 ,    ;</li>
<li> ,   --;</li>
<li>   Scala        - (     ),   <code>indexOfSlice</code>    —    ;</li>
<li>    ,  -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です！</font><font style="vertical-align: inherit;">アルゴリズムやパフォーマンスなど（そしてScala、JVM、Java全般についても）を読むのが好きな方は、この記事の著者であるLinas Medziunas（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に登録してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事のすべてのコードを含むgithubリポジトリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<hr><br>
<img src="https://habrastorage.org/webt/_f/ku/xn/_fkuxncdimo0rsaeealkeqpe8f0.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事の翻訳は、JUG Ru Groupと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPoint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conferenceの支援を得て公開されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491740/index.html">Yandex.Cloudのモノのインターネット：Yandex IoT CoreとYandex Cloud Functionsサービスの配置方法</a></li>
<li><a href="../ja491742/index.html">シャーベット：人間工学に基づいたゲーミングキーボード</a></li>
<li><a href="../ja491744/index.html">イランのハッカーがVPNの脆弱性を悪用</a></li>
<li><a href="../ja491746/index.html">音声合成の歴史：電気的ソリューションの時代</a></li>
<li><a href="../ja491748/index.html">視覚障害者が英語を学ぶのを助ける技術</a></li>
<li><a href="../ja491754/index.html">KOMPAS-3D v18ホーム。3Dプリント用のミニコースデザイン。モデリングの基本からトップダウン3D設計まで</a></li>
<li><a href="../ja491756/index.html">CVE-2019-18683：Linux V4L2サブシステムの脆弱性の悪用</a></li>
<li><a href="../ja491760/index.html">Telegram。200行のコードのタクシー</a></li>
<li><a href="../ja491764/index.html">暗い宇宙。パート1</a></li>
<li><a href="../ja491766/index.html">C ++での関数と論理演算子の組み合わせ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>