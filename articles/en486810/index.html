<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèΩ ü•ú üç© New Odnoklassniki frontend: launching React in Java. Part II üõï üëÇ üòè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the story of how, inside Odnoklassniki, using GraalVM, we managed to make friends with Java and JavaScript and started migrating to a huge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>New Odnoklassniki frontend: launching React in Java. Part II</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/486810/"><img src="https://habrastorage.org/webt/sz/_g/7x/sz_g7xhw5t9siczpovdjhzzsgru.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We continue the story of how, inside Odnoklassniki, using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraalVM,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we managed to make friends with Java and JavaScript and started migrating to a huge system with a lot of legacy code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the second part of the article, we will talk in detail about the launch, assembly and integration of applications on the new stack, dive into the specifics of their work both on the client and on the server, as well as discuss the difficulties encountered on our way and describe solutions to help them overcome . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you have not read the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first part</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I highly recommend doing this. </font><font style="vertical-align: inherit;">From it you will learn about the history of the frontend in Odnoklassniki and get acquainted with its historical features, go through the path of finding a solution to the problems that have accumulated in our 13 years of the project, and at the very end you will plunge into the technical features of the server implementation of the decision we made.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI configuration</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To write the UI code, we chose the most advanced tools: React along with MobX, CSS Modules, ESLint, TypeScript, Lerna. </font><font style="vertical-align: inherit;">All this is collected using Webpack.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ed/tp/gx/edtpgxyuy6rxy4nvalwn_dhhkva.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As was written in the previous part of this article, in order to realize gradual migration, we will insert new components on the site in DOM elements with custom names that will work inside the new UI stack, while for the rest of the site it will look like a DOM element with its API. The contents of these elements can be rendered on the server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is it? Inside there is a cool, fashionable, modern MVC application running on React and providing the standard DOM API outward: attributes, methods on this DOM element, and events.</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/fg/um/dw/fgumdwotb43klsvwwtlvx4x1bd4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To run such components, we have developed a special mechanism. What is he doing? Firstly, it initializes the application according to its description. Secondly, it binds the component to the specific DOM node in which it starts. There are also two engines (for the client and for the server) that can find and render these components. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ln/dg/wz/lndgwzg5ggcfgsnnsfdnrdmue8u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is this needed? The fact is that when the whole site is made on React, then usually the site component is rendered into the root element of the page, and this component does not matter what is outside, but only what is inside is interesting.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, everything is more complicated: a number of applications need the opportunity to tell our page on the site "I am, and something is changing in me." For example, the calendar needs to throw an event that the user clicked on the button, and the date has changed, or outside you need the ability so that inside the calendar you can change the date. For this, the application engine implements facades in the basic functionality of the application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When delivering a component to a client, it is necessary that the engine of the old site can launch this component. To do this, during the build, the information necessary for its launch is collected.</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"events-calendar"</span>: {
        <span class="hljs-attr">"bundleName"</span>: <span class="hljs-string">"events-calendar"</span>,
        <span class="hljs-attr">"js"</span>: <span class="hljs-string">"events-calendar-h4h5m.js"</span>,
        <span class="hljs-attr">"css"</span>: <span class="hljs-string">"events-calendar-h4h5m.css"</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Special markers are added to the attributes of the component tag, which say that this application is of a new type, its code can be taken from a specific JS file. </font><font style="vertical-align: inherit;">At the same time, it has its own attributes that are needed to initialize this component: they form the initial state of the component in the store.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">events-calendar</span>	<span class="hljs-attr">data-module</span>=<span class="hljs-string">"react-loader"</span>
			<span class="hljs-attr">data-bundle</span>=<span class="hljs-string">"events-calendar.js"</span>
			<span class="hljs-attr">date</span>=<span class="hljs-string">".."</span>
			<span class="hljs-attr">marks</span>=<span class="hljs-string">"[{..}]"</span>
			‚Ä¶
/&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For rehydration, it is not a cast of the application state that is used, but attributes, which allows saving on traffic. </font><font style="vertical-align: inherit;">They come in a normalized form, and, as a rule, are smaller than the store that the application creates. </font><font style="vertical-align: inherit;">At the same time, the time to recreate the store from the attributes on the client is short, so they can usually be neglected. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, for the calendar, the attributes only have a highlighted date, and the store already has a matrix with full information for the month. </font><font style="vertical-align: inherit;">Obviously, it is pointless to transfer it from the server.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to run the code?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The concept was tested on simple functions that either give a line for the server or write innerHTML for the client. But in real code there are modules and TypeScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are standard solutions for the client, for example, collecting code using Webpack, which itself grinds everything and gives it to the client in the form of a bundle of bundles. And what to do for the server when using GraalVM?</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/sr/f7/yn/srf7ynd8airmxgybkgu4wnpe82c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's consider two options. The first is to type TypeScript in JavaScript, as they do for Node.js. This option, unfortunately, does not work in our configuration when JavaScript is the guest language in GraalVM. In this case, JavaScript does not have a modular system, or even asynchrony. Because modularity and work with asynchrony provides a specific runtime: NodeJS or a browser. And in our case, the server has JavaScript that can only execute code synchronously.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second option - you can simply run on the server code from the same files that were collected for the client. And this option works. But there is a problem that the server needs other implementations for a number of methods. For example, the renderToString () function will be called on the server to render the component, and ReactDOM.render () on the client. Or another example from the previous article: to obtain texts and settings on the server, the function that Java provides will be called, and on the client it will be an implementation in JS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a solution to this problem, you can use aliases from Webpack. They allow you to create two implementations of the class we need: for the client and server. Then, in the configuration files for the client and server, specify the appropriate implementation.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/rb/0o/carb0o0rvb1q0pw8eerxnsy4ova.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But two config files are two assemblies. </font><font style="vertical-align: inherit;">Each time, collecting everything separately for the server and for the client is long and difficult in support. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You need to come up with such a configuration so that everything is collected in one go.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webpack configuration to run JS on server and client</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To find a solution to this problem, let's see what parts the project consists of: </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/zh/mi/e9/zhmie9o6zghd5vgeyd10pjonffq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, the project has third-party runtime (vendors), the same for the client and for the server. </font><font style="vertical-align: inherit;">It almost never changes. </font><font style="vertical-align: inherit;">Rantime can be given to the user, and he will be cached on the client until we update the version of the third-party library. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, there is our runtime (core), which ensures the launch of the application. </font><font style="vertical-align: inherit;">It has methods with different implementations for the client and server. </font><font style="vertical-align: inherit;">For example, getting localization texts, settings, and so on. </font><font style="vertical-align: inherit;">This runtime also changes infrequently.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thirdly, there is a component code. </font><font style="vertical-align: inherit;">It is the same for the client and for the server, which allows you to debug the application code in the browser without starting the server at all. </font><font style="vertical-align: inherit;">If something went wrong on the client, you can see the errors in the browser console, bring everything to mind and be sure that there will be no errors when starting on the server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In total, three parts are obtained that need to be assembled. </font><font style="vertical-align: inherit;">We want:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separately configure the assembly of each part.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Put down the dependencies between them so that each part does not fall into what is in the other.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collect everything in one pass.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to describe separately the parts of which the assembly will consist? </font><font style="vertical-align: inherit;">There is a multiconfiguration in webpack: you simply give away an array of exports of the modules included in each part.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = [{
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./vendors.js'</span>,<font></font>
}, {<font></font>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./core.js'</span><font></font>
}, {<font></font>
 <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span><font></font>
}];<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything would be fine, but in each of these parts the code of those modules on which this part depends will be duplicated: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ut/am/ax/utamaxl7z4op6x8iivfcmufn7ec.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, in the basic set of webpack plugins there is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DllPlugin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows you to get a list of the modules included in it for each assembled part. For example, for vendor, you can find out which specific modules are included in this part. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When building another part, for example, core libraries, we can say that they depend on the vendor part. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/nv/lu/el/nvluelzxzvy_5oofujylu4wmufk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, during the webpack assembly, DllPlugin will see the dependence of core on some library that is already in vendor, and will not add it to core, but simply put a link to it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, three pieces are assembled at a time and depend on each other. </font><font style="vertical-align: inherit;">When the first application is downloaded to the client, the runtime and core libraries will be saved in the browser cache. </font><font style="vertical-align: inherit;">And since Odnoklassniki is a site, the tab with which the user can open ‚Äúforever‚Äù, crowding out will occur quite rarely. </font><font style="vertical-align: inherit;">In most cases, with releases of new versions of the site, only the application code will be updated.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resource Delivery</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the problem by the example of working with localized texts that are stored in a separate database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If earlier somewhere on the server you needed text in the component, you could call the function to get the text.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> pkg = l10n(<span class="hljs-string">'smiles'</span>);<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    : { pkg.getText('title') }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Getting text on the server is not difficult, because the server application can make a quick request to the database or even cache all texts in memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to get texts in components on a react that are rendered on a server in GraalVM? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As was discussed in the first part of the article, in the JS context, you can add methods to the global object that you want to access from JavaScript. </font><font style="vertical-align: inherit;">It was decided to make a class with all methods available for JavaScript.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerMethods</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <font></font>
    <span class="hljs-comment">/**
     *     
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">(String pkg, String key)</span> </span>{<font></font>
        ‚Ä¶<font></font>
    }<font></font>
    <font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then put an instance of this class in the global JavaScript context:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Java   </span>
js.putMember(<span class="hljs-string">"serverMethods"</span>, serverMethods);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, from JavaScript in the server implementation, we simply call the function:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getText</span>(<span class="hljs-params">pkg: string, key: string</span>): <span class="hljs-title">string</span> </span>{
    <span class="hljs-keyword">return</span> global.serverMethods.getText(pkg, key);<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, this will be a function call in Java that will return the requested text. Direct synchronous interaction and no HTTP calls. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the client, unfortunately, it takes a very long time to go over HTTP and receive texts for each call to the text insertion function in the components. You can pre-download all the texts to the client, but the texts alone weigh tens of megabytes, and there are other types of resources. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/6e/ij/lg6eijxb_rvzshqiyih2gyuvy5a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The user will get tired of waiting until everything is downloaded before starting the application. Therefore, this method is not suitable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would like to receive only those texts that are needed in a particular application. Our texts are broken into packages. Therefore, you can collect the packages needed for the application and download them along with the bundle. When the application starts, all texts will already be in the client cache.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to find out which texts an application needs? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We entered into an agreement that packages of texts in the code are obtained by calling the l10n () function, into which the package name is transmitted ONLY in the form of a string literal:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> pkg = l10n(<span class="hljs-string">'smiles'</span>);<font></font>
<font></font>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    { pkg.getLMsg('title') }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We wrote a webpack plugin that, by analyzing the AST tree of the component code tree, finds all calls to the l10n () function and collects package names from the arguments. </font><font style="vertical-align: inherit;">Similarly, the plugin collects information about other types of resources needed by the application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the output after assembly for each application, we get a config with its resources:</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"events-calendar"</span>: {
       <span class="hljs-attr">"pkg"</span>:  [
           <span class="hljs-string">"calendar"</span>,
           <span class="hljs-string">"dates"</span><font></font>
       ],<font></font>
       <span class="hljs-attr">"cfg"</span>:  [
           <span class="hljs-string">"config1"</span>,
           <span class="hljs-string">"config2"</span><font></font>
       ],<font></font>
       <span class="hljs-attr">"bundleName"</span>:  <span class="hljs-string">"events-calendar"</span>,
       <span class="hljs-attr">"js"</span>:  <span class="hljs-string">"events-calendar.js"</span>,
       <span class="hljs-attr">"css"</span>:  <span class="hljs-string">"events-calendar.css"</span>,<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And of course, we must not forget about updating the texts. </font><font style="vertical-align: inherit;">Because on the server all texts are always up-to-date, and the client needs a separate cache update mechanism, for example, watcher or push.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Old code in new</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a smooth transition, the problem arises of reusing the old code in new components, because there are large and complex components (for example, a video player), rewriting which will take a lot of time, and you need to use them in the new stack now. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jz/pg/te/jzpgtesmq75odhrqyvbg2grbw9u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What are the problems?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The old site and new React apps have completely different life cycles. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you paste the code of the old sample inside the React application, then this code will not start, because React does not know how to activate it. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to different life cycles, React and the old engine may simultaneously try to modify the contents of the old code, which can cause unpleasant side effects. </font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve these problems, a common base class was allocated for components containing old code. </font><font style="vertical-align: inherit;">The class allows heirs to coordinate the life cycles of React and old-style applications.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldCodeBase</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">T</span>&gt; </span>{<font></font>
<font></font>
    <span class="hljs-attr">ref</span>: React.RefObject&lt;HTMLElement&gt; = React.createRef();<font></font>
<font></font>
    componentDidMount() {<font></font>
        <span class="hljs-comment">//       DOM</span>
        <span class="hljs-keyword">this</span>.props.activate(<span class="hljs-keyword">this</span>.ref.current!); <font></font>
    }<font></font>
<font></font>
    componentWillUnmount() {<font></font>
        <span class="hljs-comment">//       DOM</span>
        <span class="hljs-keyword">this</span>.props.deactivate(<span class="hljs-keyword">this</span>.ref.current!); <font></font>
    }<font></font>
<font></font>
    shouldComponentUpdate() {<font></font>
        <span class="hljs-comment">// React     , </span>
        <span class="hljs-comment">//   React-. </span>
        <span class="hljs-comment">//     .</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.ref}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The class allows you to either create pieces of code that work in the old way, or destroy, while there will be no simultaneous interaction with them. </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paste old code on the server</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In practice, there is a need for wrapper components (for example, pop-ups), the contents of which can be any, including those made using old technologies. </font><font style="vertical-align: inherit;">You need to figure out how to embed any code on the server inside such components. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a previous article, we talked about using attributes to pass parameters to new components on the client and server.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span> <span class="hljs-attr">users</span>=<span class="hljs-string">"[1,2,3]"</span> /&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we still want to insert a piece of markup there, which in meaning is not an attribute. </font><font style="vertical-align: inherit;">For this, it was decided to use a system of slots.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ui:part</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"old-code"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>old component<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ui:part</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see in the example above, inside the code of the cool-app component, an old-code slot containing old components is described. </font><font style="vertical-align: inherit;">Then, inside the react component, the place where you want to paste the contents of this slot is indicated:</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">UiPart</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"old-code"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    );<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The server engine renders this react component and frames the contents of the slot in the &lt;ui-part&gt; tag, assigning the data-part-id = "old-code" attribute to it. </font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ui-part</span> <span class="hljs-attr">data-part-id</span>=<span class="hljs-string">"old-code"</span>&gt;</span><font></font>
            old code<font></font>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ui-part</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the server-side rendering of JS in GraalVM does not fit into the timeout, then we do fallback to client rendering. </font><font style="vertical-align: inherit;">To do this, the engine on the server gives only slots, framing them in the template tag so that the browser does not interact with their code.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cool-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ui-part</span> <span class="hljs-attr">data-part-id</span>=<span class="hljs-string">"old-code"</span>&gt;</span><font></font>
            old code<font></font>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ui-part</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cool-app</span>&gt;</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is happening on the client? </font><font style="vertical-align: inherit;">The client engine simply scans the component code, collects the &lt;ui-part&gt; tags, receives their contents in the form of strings, and passes them to the rendering function along with the rest of the parameters.</font></font><br>
 <br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> tagName = <span class="hljs-string">'cool-app'</span>;
<span class="hljs-keyword">var</span> reactComponent = components[tagName];<font></font>
reactComponent.render({<font></font>
       <span class="hljs-attr">tagName</span>: tagName,
       <span class="hljs-attr">attrs</span>: attrs,
       <span class="hljs-attr">parts</span>: parts,
       <span class="hljs-attr">node</span>: element<font></font>
});<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code of the component that inserts the slots into the desired location is as follows: </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OldCodeBase</span>&lt;<span class="hljs-title">IProps</span>&gt; </span>{<font></font>
<font></font>
	render() {<font></font>
		<span class="hljs-keyword">const</span> id = <span class="hljs-keyword">this</span>.props.id;
		<span class="hljs-keyword">const</span> parts = <span class="hljs-keyword">this</span>.props.parts;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!parts.hasOwnProperty(id)) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
		}<font></font>
<font></font>
		<span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'ui-part'</span>, {
			<span class="hljs-string">'data-part-id'</span>: id,
			<span class="hljs-attr">ref</span>: <span class="hljs-keyword">this</span>.ref,
			<span class="hljs-attr">dangerouslySetInnerHTML</span>: { <span class="hljs-attr">__html</span>: parts[id] }<font></font>
		});<font></font>
	}<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, it is inherited from the OldCodeBase class, which solves the problems of interaction between the old and the new stack. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/ge/cc/a3/gecca3dlxac9crp48u9pvoyc4vs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you can write a pop-up and populate it using the new stack or request from the server using the old approach. </font><font style="vertical-align: inherit;">In this case, the components will work correctly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This allows you to gradually migrate site components to a new stack. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just this was one of the main requirements for the new frontend.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everyone is wondering how fast GraalVM works. </font><font style="vertical-align: inherit;">Odnoklassniki developers conducted various tests with React applications. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simple function that returns a string after warming up takes about 1 microsecond. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Components (again after warming up) - from 0.5 to 6 milliseconds, depending on their size. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GraalVM accelerates more slowly than V8. </font><font style="vertical-align: inherit;">But for the time of its warming up, the situation is smoothed out thanks to the fallback for client rendering. </font><font style="vertical-align: inherit;">Since there are so many users, the virtual machine heats up quickly.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What did you manage to do</font></font></h3><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run JavaScript on the server in the Java world of Classmates.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make isomorphic code for UI.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use a modern stack that all front-end vendors know.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a common platform and a single approach for writing UI.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start a smooth transition without complicating the operation and not slowing down the server rendering.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We hope that the experiences of Odnoklassniki and examples will be useful to you and you will find them to use in your work.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486798/index.html">Is there a GameDev in Sakhalin? End</a></li>
<li><a href="../en486800/index.html">Cassandra. How not to die if you know only Oracle</a></li>
<li><a href="../en486802/index.html">People meet recommender systems. Factorization</a></li>
<li><a href="../en486804/index.html">Global Health Informatics: Cloud Technologies</a></li>
<li><a href="../en486808/index.html">Electronic pregnancy test from a pharmacy: how it works</a></li>
<li><a href="../en486814/index.html">Zabbix: network topology is clear and automatic</a></li>
<li><a href="../en486818/index.html">Porting Quake to iPod Classic</a></li>
<li><a href="../en486820/index.html">70 Javascript Interview Questions</a></li>
<li><a href="../en486822/index.html">[By the docks] Flutter. Part 4. For web developers</a></li>
<li><a href="../en486824/index.html">Bad advice when working with ANTLR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>