<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘” ğŸ‘¨ğŸ¾â€ğŸš€ ğŸ¿ Penyortiran halus ğŸŒµ ğŸ“ˆ ğŸ¤’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus membenamkan diri dalam berbagai tumpukan. 
 
 Hari ini kami akan menganalisis metode pemesanan yang elegan yang menggunakan tumpukan khusus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Penyortiran halus</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami terus membenamkan diri dalam berbagai tumpukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini kami akan menganalisis metode pemesanan yang elegan yang menggunakan tumpukan khusus berdasarkan nomor Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak yang telah mendengar tentang penyortiran ini, tetapi hanya sedikit orang yang tahu persis cara kerjanya. Hari ini kita akan melihat bahwa tidak ada yang rumit di dalamnya. </font><font style="vertical-align: inherit;">
Metode ini ditemukan oleh Edsger Dijkstra yang legendaris. Selain banyak pencapaian paling cemerlang dalam teori algoritma, ia juga merupakan penulis pernyataan yang sangat lucu: </font><i><font style="vertical-align: inherit;">â€œSiswa yang sebelumnya belajar Dasar, hampir tidak mungkin untuk mengajar pemrograman yang baik. Sebagai programmer potensial, mereka telah mengalami degradasi mental yang tidak dapat dipulihkan. â€</font></i><font style="vertical-align: inherit;"> 
Saya harap bukan penghujatan bahwa animasi dalam artikel dibuat menggunakan VBA :-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heap sorting itu sendiri sangat baik, karena kompleksitas waktunya adalah </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terlepas dari data. Agar tidak menjadi array, kompleksitas heapsort tidak pernah menurun ke </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dapat terjadi, misalnya, dengan penyortiran cepat. Sisi lain dari koin adalah bahwa penyortiran berdasarkan tumpukan biner tidak dapat dipercepat, </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kompleksitas </font><font style="vertical-align: inherit;">juga tidak dapat diharapkan (tetapi penyortiran cepat yang sama, dalam kondisi tertentu, dapat mencapai indikator tersebut). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, ada pertanyaan dalam agenda: apakah mungkin untuk merancang sehingga kompleksitas waktu menyortir berdasarkan tumpukan, di satu sisi, tidak lebih rendah dari</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi dalam skenario yang menguntungkan (khususnya, jika array yang hampir diurutkan diproses) meningkat menjadi </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah ini secara pribadi ditangani oleh Edsger Dijkstra sendiri, yang menemukan bahwa ya, itu mungkin. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diasumsikan bahwa mereka yang membaca artikel ini memahami bagaimana penyortiran berdasarkan tumpukan bekerja secara umum, mereka tahu apa itu penyortiran pohon dan mengapa penyaringan diperlukan. </font><font style="vertical-align: inherit;">Jika seseorang memiliki kesenjangan dalam pengetahuan ini, maka sebelum melanjutkan membaca, saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sarankan Anda membaca artikel sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang salah dengan tumpukan biner?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagaimana heapsort mengurutkan array yang hampir teratur dan melihat mengapa algoritma ini tidak memproses data yang masuk lebih cepat.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klik pada animasi untuk pergi ke artikel â€œMenyortir berdasarkan n-piramida.â€</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hal pertama yang menarik perhatian Anda adalah ketika menyaring, maxima terus-menerus didorong ke akar tumpukan, yang sesuai dengan elemen pertama array. Jika array input hampir dipesan, maka untuk algoritme ini hanya akan menambah sedikit kerja. Elemen yang lebih kecil akan tetap pertama turun pohon, yaitu bergerak lebih dekat ke ujung array, bukan ke awal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktor perlambatan kedua, yang tidak begitu jelas, adalah tumpukan biner standar itu sendiri selalu pohon seimbang. </font><font style="vertical-align: inherit;">Dalam kasus data yang awalnya dipesan, ini memainkan peran negatif. </font><font style="vertical-align: inherit;">Jika ada data acak dalam array asli, maka mereka didistribusikan secara merata di pohon seimbang, dan beberapa memilah melewati semua cabang kira-kira jumlah yang sama kali. </font><font style="vertical-align: inherit;">Untuk data yang hampir dipesan, pohon yang tidak seimbang lebih disukai - dalam hal ini, data pada bagian array yang sesuai dengan cabang-cabang pohon yang lebih panjang akan diproses lebih jarang daripada yang lain.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angka Leonardo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi kedua masalah, Dijkstra mengusulkan menggunakan tumpukan biner khusus berdasarkan nomor Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angka Leonardo hampir seperti angka Fibonacci, tetapi hanya lebih baik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serangkaian bilangan Leonardo diberikan secara rekursif: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
20 angka Leonardo pertama: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1, 1, 3, 5, 9, 15, 25, 41, 67 , 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benar-benar bilangan bulat mana pun dapat direpresentasikan sebagai jumlah bilangan Leonardo yang memiliki nomor seri berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini sangat berguna dalam kasus kami. Array </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen tidak selalu dapat direpresentasikan sebagai satu tumpukan Leonardo (jika </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bukan angka Leonardo). </font><font style="vertical-align: inherit;">Tetapi kemudian, array apa pun selalu dapat dibagi menjadi beberapa subarrays yang akan sesuai dengan nomor Leonardo yang berbeda, yaitu </font><font style="vertical-align: inherit;">menjadi tumpukan dari urutan yang berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah contoh array elemen ke-21, yang terdiri dari tiga tumpukan Leonard. </font><font style="vertical-align: inherit;">Di setiap tumpukan, jumlah node sesuai dengan sejumlah Leonardo.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin penting yang perlu diketahui:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap tumpukan Leonardov adalah pohon biner yang tidak seimbang.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akar setiap heap adalah elemen terakhir (dan bukan yang pertama, seperti pada heap biner biasa) dari subarray yang sesuai.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap simpul dengan semua turunannya juga merupakan tumpukan Leonard dengan urutan yang lebih kecil.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bangun dan bongkar tumpukan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam rumus perulangan untuk bilangan Leonardo, </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sangat senang dengan unit di akhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itulah kenapa. Misalkan kita memiliki dua subarrays yang berdekatan dalam array yang sesuai dengan tumpukan yang dibangun pada dua bilangan Leonardo yang berdekatan. Menggunakan elemen segera setelah subarrays ini, subarrays ini dapat digabungkan menjadi tumpukan umum, yang sesuai dengan nomor Leonard berikutnya.</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melalui elemen-elemen dalam array, kami membangun banyak tumpukan Leonard. Jika menggunakan elemen Anda dapat menggabungkan dua tumpukan sebelumnya (ini dimungkinkan jika dan hanya jika dua tumpukan sebelumnya sesuai dengan dua angka Leonardo berturut-turut), lalu gabungkan. Jika menggabungkan tidak mungkin (dua tumpukan sebelumnya tidak sesuai dengan dua angka Leonardo berturut-turut), maka elemen saat ini hanya membentuk tumpukan baru dari satu elemen yang sesuai dengan yang pertama (atau kedua, jika yang pertama digunakan sebelumnya) nomor Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap kedua algoritma, proses sebaliknya terjadi - kami mengurai tumpukan. Jika kita menghapus root di heap, maka kita mendapatkan dua heap yang lebih kecil sesuai dengan dua angka Leonardo sebelumnya. Ini dapat dilakukan karena: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dalam bilangan Fibonacci tidak ada unit yang berguna, oleh karena itu kami tidak menggunakan tumpukan Fibonacci.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortir Halus :: Smoothsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma terakhir:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Buat sekelompok tumpukan Leonard dari array, yang masing-masing adalah pohon penyortiran.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterasi elemen-elemen array dari kiri ke kanan.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memeriksa apakah menggunakan elemen saat ini adalah mungkin untuk menggabungkan dua tumpukan paling kiri di tumpukan Leonard yang ada:</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ya, maka kami menggabungkan dua tumpukan paling kiri menjadi satu, elemen saat ini menjadi akar tumpukan ini, kami menyaring tumpukan gabungan.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika tidak, tambahkan elemen saat ini sebagai tumpukan baru (terdiri dari satu simpul sejauh ini) ke tumpukan yang ada dari tumpukan Leonard.</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memindahkan elemen maksimum ke ujung, bagian array yang diurutkan meningkat, dan bagian yang tidak disortir berkurang. </font><font style="vertical-align: inherit;">Ulangi langkah II.1-II.4 untuk bagian array yang belum disortir.</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh implementasi python</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas waktu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita mengambil array yang hampir dipesan sebagai input, maka visualisasi menunjukkan mengapa array tersebut diproses lebih cepat.</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penghematan hanya terjadi karena penyaringan. Dalam data yang hampir dipesan, saringan tenggelam dangkal di pohon, termasuk setelah tumpukan secara bertahap dibubarkan di tahap kedua. Dalam data awalnya acak, pengayakan lebih mahal, karena sering kali jatuh ke level terakhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita perkirakan kompleksitas waktu total. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap pertama, kita beralih pada n elemen, menambahkannya ke tumpukan yang sudah ada di sebelah kiri. Menambahkan ke heap itu sendiri dilewati di O (1), tetapi kemudian untuk heap Anda perlu membuat ayak. Dalam data yang dipesan, pengayakan dangkal sering kali menghabiskan biaya O (1) untuk satu elemen yang ditambahkan ke heap. Dalam data yang tidak berurutan, pengayakan untuk setiap penambahan dihitung biayanya dalam </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena sebagai akibat dari keacakan, pengayakan harus melalui tingkat pohon sering ke bagian paling bawah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, pada tahap pertama, kompleksitas waktu terbaik adalah: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk data yang hampir dipesan - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk data acak - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk tahap kedua, situasinya mirip. Saat bertukar maksimum berikutnya, Anda lagi perlu menyaring tumpukan di root itu. Dan metrik penyaringan untuk data yang dipesan dan tidak teratur akan berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap kedua, kompleksitas waktu terbaik sama dengan pada tahap pertama: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk data yang hampir dipesan - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk data acak - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menambahkan kompleksitas waktu untuk tahap pertama dan kedua: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk data yang hampir dipesan - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk data acak - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, kompleksitas waktu terburuk dan rata-rata untuk pemilahan halus adalah O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra dalam perhitungannya (yang tidak akan membuat saya bosan dengan Anda) membuktikan bahwa kompleksitas terbaik </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan lancar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cenderung ke </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daripada data yang masuk lebih teratur. </font><font style="vertical-align: inherit;">Oleh karena itu nama - pemilahan halus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas memori ekstra</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menguraikan data menjadi banyak tumpukan Leonard, Anda hanya perlu mengingat persis angka Leonardo mana yang terlibat di setiap langkah. </font><font style="vertical-align: inherit;">Mengetahui angka-angka ini, tumpukan itu sendiri disejajarkan secara algoritmik. </font><font style="vertical-align: inherit;">Seri angka ini tumbuh sangat cepat, sehingga bahkan untuk array besar Anda akan memerlukan satu set angka Leonard yang sangat kecil.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial heap sort :: Binomial heap sort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada struktur pohon, sangat mirip dengan yang kami susun - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tumpukan binomial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini juga banyak tumpukan ukuran yang berbeda, di mana masing-masing jumlah node adalah kekuatan dua. </font><font style="vertical-align: inherit;">Setiap array dari sejumlah elemen dapat diperluas ke tumpukan ini, karena setiap bilangan alami didekomposisi menjadi jumlah dua-dua derajat yang berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada prinsipnya, Anda dapat melakukan pemilahan berdasarkan binomial:</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah ini akan bekerja lebih cepat? </font><font style="vertical-align: inherit;">Hampir tidak. </font><font style="vertical-align: inherit;">Tumpukan binomial bukan biner, dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam artikel terakhir kami menemukan bahwa meningkatkan jumlah keturunan tidak mempercepat, tetapi memperlambat layar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Selain itu, Anda dapat melihat bahwa tumpukan binomial memiliki cabang yang lebih panjang, itulah sebabnya daerah-daerah tetangga yang tertata dari array akan sedikit lebih lambat untuk terhubung satu sama lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak diketahui apakah tumpukan binomial Dijkstra secara umum dianggap sebagai dasar yang mungkin untuk algoritmanya. </font><font style="vertical-align: inherit;">Namun, tumpukan Leonardov mungkin lebih optimal.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer Seri Berikutnya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, bahkan jika tumpukan binomial bukan pilihan terbaik untuk pemilahan yang halus, Anda tidak harus membuangnya sepenuhnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika pohon binomial </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sedikit dimodifikasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan ide yang sangat berbeda (sangat tebal) digunakan untuk mengitarinya, kita mendapatkan algoritma asli dan efektif yang memiliki kelebihannya sendiri. </font><font style="vertical-align: inherit;">Apa yang akan kita bicarakan lain kali?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klik pada animasi untuk pergi ke artikel dengan penyortiran berikutnya dengan tumpukan.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smooth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghaluskan </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo Nomor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binomial tumpukan</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel Seri:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplikasi Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertukaran macam</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan Penyisipan</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortir berdasarkan pilihan</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Piramida</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap sort: heap lemah</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bunch Sorts: Cartesian Tree</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyortiran tumpukan lainnya: tumpukan cermin, tumpukan mini, pengayakan bottom-up</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gabungkan Urusan</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutkan berdasarkan distribusi</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortasi Hibrid</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penyortiran halus hari ini telah ditambahkan ke aplikasi AlgoLab. </font><font style="vertical-align: inherit;">Serta bonus - dan menyortir dengan tumpukan binomial. </font><font style="vertical-align: inherit;">Jadi siapa yang ingin secara pribadi menggerakkan data di heap heaps - perbarui file excel dengan macro.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496840/index.html">Musk percaya bahwa 12 ribu satelit tidak akan mengganggu para astronom. Pendapatnya tidak konsisten dengan model</a></li>
<li><a href="../id496842/index.html">Model epidemi sederhana dengan alat Python dasar</a></li>
<li><a href="../id496846/index.html">Mekanika bahasa tumpukan dan pointer</a></li>
<li><a href="../id496848/index.html">Intisari materi menarik untuk pengembang seluler # 340 (pada 6 - 12 April)</a></li>
<li><a href="../id496850/index.html">Plugin Maven untuk JPackage dari Java 14</a></li>
<li><a href="../id496856/index.html">Rumah pintar tanpa remote, tetapi dengan kubus</a></li>
<li><a href="../id496858/index.html">Berita FOSS No. 11 - ulasan perangkat lunak bebas dan sumber terbuka untuk 6-12 April 2020</a></li>
<li><a href="../id496860/index.html">DI Pertama: DI Pertama di Antarmuka untuk Aplikasi Script</a></li>
<li><a href="../id496862/index.html">Tampilan Gelembung Arduino</a></li>
<li><a href="../id496868/index.html">Simfoni Ruang Kecil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>