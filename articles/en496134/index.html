<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏿 👃 👨🏾‍⚕️ How to get rid of blurry photos using Python 🐡 🎒 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When we take a large series of shots, some of them are fuzzy. A large automobile company faced the same problem. Some of the photographs during the in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How to get rid of blurry photos using Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496134/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we take a large series of shots, some of them are fuzzy. </font><font style="vertical-align: inherit;">A large automobile company faced the same problem. </font><font style="vertical-align: inherit;">Some of the photographs during the inspection of the car turned out blurry, which could negatively affect sales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Low-quality images directly reduce profits.</font></font></i><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does an application recognize fuzzy photos at the algorithm level?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to measure the clarity of an RGB image?</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/be/p7/1g/bep71gaawmaf4thhfl5j7ig-1ze.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulation of the problem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I work as an analyst in a large automobile company. </font><font style="vertical-align: inherit;">When inspecting a car, when inspecting a car, they take a lot of photos through a special application, which are immediately sent to the database. </font><font style="vertical-align: inherit;">Some images are blurry, which is bad for sales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From here the problem arises: “how to recognize fuzzy pictures at the algorithm level?” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Developed an algorithm based on a sample of 1200 photos of different elements of cars. </font><font style="vertical-align: inherit;">A feature of the sample is that it is not labeled, because </font><font style="vertical-align: inherit;">it’s hard to pinpoint which pictures are clear and which are not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that learning the ML model “with a teacher” is not applicable to the solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the course of work I used tools:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Libraries: numpy, matplotlib, cv2;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jupyter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> notebook.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the article I will describe the solution to the problem to which I came.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description of the approach to solving the problem</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage 1. Defining the boundaries</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What photo can be called clear? </font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One in which the boundaries of objects are pronounced. </font><font style="vertical-align: inherit;">In fuzzy shots, the borders of objects are blurred. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to determine the boundaries of objects in the picture? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Borders where we see the greatest color difference. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that to determine the clarity of the image, first you need to determine the boundaries of the objects of photographs, then evaluate their size, thickness, number, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The photo consists of a three-dimensional array of numbers from 0 to 255: (width, height, 3 colors). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I defined the boundaries by applying a filter as in creating a deep neural network: by multiplying a three-dimensional array by matrices (for each color):</font></font><br>
<br>
<pre><code class="plaintext hljs">    │ 1 -1 │<font></font>
    │ 1 -1 │<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a color difference, the resulting array will produce a high modulus number. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So we define the vertical and horizontal boundaries. </font><font style="vertical-align: inherit;">The arithmetic mean shows the common borders of the photograph.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage 2. Analysis of boundaries for clarity</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The boundaries are defined. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to distinguish the border of a fuzzy image from the border of a clear? </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Going through different options, I found the following approach:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define the boundaries of the original photo (described in step 1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur the original image;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define the boundaries of the blurry image (described in step 1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we consider the ratio of the arithmetic mean of paragraph 1 and paragraph 2;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the resulting coefficient characterizes the clarity of the image.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The logic is simple: in clear photographs, the change in borders will occur more significantly than in fuzzy ones, which means that the coefficient will be higher.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python implementation of the algorithm</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve the problem directly, we use the following libraries:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> cv2
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the parameters for determining the boundaries, we define the matrix definition function:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edges</span>(<span class="hljs-params">n, orient</span>):</span>
    edges = np.ones((<span class="hljs-number">2</span>*n, <span class="hljs-number">2</span>*n, <span class="hljs-number">3</span>))<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> orient == <span class="hljs-string">'vert'</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>*n):<font></font>
            edges[i][n: <span class="hljs-number">2</span>*n] *= <span class="hljs-number">-1</span>
    <span class="hljs-keyword">elif</span> orient == <span class="hljs-string">'horiz'</span>:<font></font>
        edges[n: <span class="hljs-number">2</span>*n] *= <span class="hljs-number">-1</span><font></font>
    <font></font>
    <span class="hljs-keyword">return</span> edges
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the parameter n, we specify the number of pixels that we include in the bounds estimate. </font><font style="vertical-align: inherit;">The orientation of the matrix can be horizontal or vertical. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further functions are similar to a deep neural network layer:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Apply one filter defined by parameters W and single slice</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv_single_step</span>(<span class="hljs-params">a_slice_prev, W</span>):</span><font></font>
    s = W * a_slice_prev<font></font>
    Z = np.sum(s)<font></font>
    Z = np.abs(Z)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> Z<font></font>
   <font></font>
<span class="hljs-comment"># Full edge filter</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conv_forward</span>(<span class="hljs-params">A_prev, W, hparameters</span>):</span><font></font>
    m = len(A_prev)<font></font>
    (f, f, n_C) = W.shape<font></font>
    stride = hparameters[<span class="hljs-string">'stride'</span>]<font></font>
    pad = hparameters[<span class="hljs-string">'pad'</span>]<font></font>
    <font></font>
    Z = list()<font></font>
    flag = <span class="hljs-number">0</span>
    z_max = hparameters[<span class="hljs-string">'z_max'</span>]<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> len(z_max) == <span class="hljs-number">0</span>:<font></font>
        z_max = list()<font></font>
        flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<font></font>
        <font></font>
        (x0, x1, x2) = A_prev[i].shape<font></font>
        A_prev_pad = A_prev[i][ <font></font>
                            int(x0 / <span class="hljs-number">4</span>) : int(x0 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
                            int(x1 / <span class="hljs-number">4</span>) : int(x1 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
                            :]<font></font>
        <font></font>
        (n_H_prev, n_W_prev, n_C_prev) = A_prev_pad.shape<font></font>
        n_H = int((n_H_prev - f + <span class="hljs-number">2</span>*pad) / stride) + <span class="hljs-number">1</span>
        n_W = int((n_W_prev - f + <span class="hljs-number">2</span>*pad) / stride) + <span class="hljs-number">1</span><font></font>
        z = np.zeros((n_H, n_W))<font></font>
        <font></font>
        a_prev_pad = A_prev_pad<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n_H):<font></font>
            vert_start = h * stride<font></font>
            vert_end = h * stride + f<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n_W):<font></font>
                horiz_start = w * stride<font></font>
                horiz_end = w * stride + f<font></font>
                <font></font>
               <font></font>
                a_slice_prev = a_prev_pad[vert_start: vert_end, horiz_start: horiz_end, :]<font></font>
<font></font>
                weights = W[:, :, :]<font></font>
                z[h, w] = conv_single_step(a_slice_prev, weights)<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
            z_max.append(np.max(z))<font></font>
        Z.append(z / z_max[i])<font></font>
        <font></font>
    cache = (A_prev, W, hparameters)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> Z, z_max, cache<font></font>
<font></font>
<span class="hljs-comment"># pooling</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pool_forward</span>(<span class="hljs-params">A_prev, hparameters, mode = <span class="hljs-string">'max'</span></span>):</span><font></font>
    m = len(A_prev)<font></font>
    f = hparameters[<span class="hljs-string">'f'</span>]<font></font>
    stride = hparameters[<span class="hljs-string">'stride'</span>]<font></font>
    <font></font>
    A = list()<font></font>
    <font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<font></font>
        (n_H_prev, n_W_prev) = A_prev[i].shape<font></font>
        <font></font>
        n_H = int(<span class="hljs-number">1</span> + (n_H_prev - f) / stride)<font></font>
        n_W = int(<span class="hljs-number">1</span> + (n_W_prev - f) / stride)<font></font>
        <font></font>
        a = np.zeros((n_H, n_W))<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n_H):<font></font>
            vert_start = h * stride<font></font>
            vert_end = h * stride + f<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n_W):<font></font>
                horiz_start = w * stride<font></font>
                horiz_end = w * stride + f<font></font>
                <font></font>
                a_prev_slice = A_prev[i][vert_start: vert_end, horiz_start: horiz_end]<font></font>
<font></font>
                <span class="hljs-keyword">if</span> mode == <span class="hljs-string">'max'</span>:<font></font>
                    a[h, w] = np.max(a_prev_slice)<font></font>
                <span class="hljs-keyword">elif</span> mode == <span class="hljs-string">'avg'</span>:<font></font>
                    a[h, w] = np.mean(a_prev_slice)<font></font>
                        <font></font>
        A.append(a)<font></font>
<font></font>
    cache = (A_prev, hparameters)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> A, cache
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
conv_single_step - one multiplication of the image colors by matrices revealing the border. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
conv_forward - A complete definition of the borders in the whole photo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pool_forward - reduce the size of the resulting array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Separately, I note the value of the lines in the conv_forward function:</font></font><br>
<br>
<pre><code class="python hljs">(x0, x1, x2) = A_prev[i].shape<font></font>
A_prev_pad = A_prev[i][ <font></font>
    int(x0 / <span class="hljs-number">4</span>) : int(x0 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
    int(x1 / <span class="hljs-number">4</span>) : int(x1 * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>), <font></font>
    :]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For analysis, we use not the whole image, but only its central part, because </font><font style="vertical-align: inherit;">the camera focuses more often on the center. </font><font style="vertical-align: inherit;">If the picture is clear, then the center will be clear. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following function determines the boundaries of objects in the image using the previous functions:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># main layer</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">borders</span>(<span class="hljs-params">images, filter_size = <span class="hljs-number">1</span>, stride = <span class="hljs-number">1</span>, pool_stride = <span class="hljs-number">2</span>, pool_size = <span class="hljs-number">2</span>, z_max = []</span>):</span>
    Wv = edges(filter_size, <span class="hljs-string">'vert'</span>)<font></font>
    hparameters = {<span class="hljs-string">'pad'</span>: pad, <span class="hljs-string">'stride'</span>: stride, <span class="hljs-string">'pool_stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size, <span class="hljs-string">'z_max'</span>: z_max}<font></font>
    Z, z_max_v, _ = conv_forward(images, Wv, hparameters)<font></font>
    <font></font>
    print(<span class="hljs-string">'edge filter applied'</span>)<font></font>
    <font></font>
    hparameters_pool = {<span class="hljs-string">'stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size}<font></font>
    Av, _ = pool_forward(Z, hparameters_pool, mode = <span class="hljs-string">'max'</span>)<font></font>
    <font></font>
    print(<span class="hljs-string">'vertical filter applied'</span>)<font></font>
    <font></font>
    Wh = edges(filter_size, <span class="hljs-string">'horiz'</span>)<font></font>
    hparameters = {<span class="hljs-string">'pad'</span>: pad, <span class="hljs-string">'stride'</span>: stride, <span class="hljs-string">'pool_stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size, <span class="hljs-string">'z_max'</span>: z_max}<font></font>
    Z, z_max_h, _ = conv_forward(images, Wh, hparameters)<font></font>
    <font></font>
    print(<span class="hljs-string">'edge filter applied'</span>)<font></font>
    <font></font>
    hparameters_pool = {<span class="hljs-string">'stride'</span>: pool_stride, <span class="hljs-string">'f'</span>: pool_size}<font></font>
    Ah, _ = pool_forward(Z, hparameters_pool, mode = <span class="hljs-string">'max'</span>)<font></font>
    <font></font>
    print(<span class="hljs-string">'horizontal filter applied'</span>)   <font></font>
    <font></font>
    <span class="hljs-keyword">return</span> [(Av[i] + Ah[i]) / <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(Av))], list(map(np.max, zip(z_max_v, z_max_h)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function determines the vertical boundaries, then the horizontal ones, and returns the arithmetic mean of both arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the main function for issuing the definition parameter:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># calculate borders of original and blurred images</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orig_blur</span>(<span class="hljs-params">images, filter_size = <span class="hljs-number">1</span>, stride = <span class="hljs-number">3</span>, pool_stride = <span class="hljs-number">2</span>, pool_size = <span class="hljs-number">2</span>, blur = <span class="hljs-number">57</span></span>):</span><font></font>
    z_max = []<font></font>
<font></font>
    img, z_max = borders(images, <font></font>
                         filter_size = filter_size, <font></font>
                         stride = stride, <font></font>
                         pool_stride = pool_stride, <font></font>
                         pool_size = pool_size<font></font>
                        )<font></font>
    print(<span class="hljs-string">'original image borders is calculated'</span>)<font></font>
    <font></font>
    blurred_img = [cv2.GaussianBlur(x, (blur, blur), <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> images]<font></font>
    print(<span class="hljs-string">'images blurred'</span>)<font></font>
    <font></font>
    blurred, z_max = borders(blurred_img, <font></font>
                             filter_size = filter_size, <font></font>
                             stride = stride, <font></font>
                             pool_stride = pool_stride, <font></font>
                             pool_size = pool_size, <font></font>
                             z_max = z_max<font></font>
                            )<font></font>
    print(<span class="hljs-string">'blurred image borders is calculated'</span>)<font></font>
<font></font>
    <span class="hljs-keyword">return</span> [np.mean(orig) / np.mean(blurred) <span class="hljs-keyword">for</span> (orig, blurred) <span class="hljs-keyword">in</span> zip(img, blurred)], img, blurred</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we determine the boundaries of the original image, then blur the image, then we determine the boundaries of the blurry photo, and, finally, we consider the ratio of the arithmetic mean boundaries of the original image and the blurred. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function returns a list of definition factors, an array of borders of the original image and an array of borders of blurry.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithm Operation Example</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For analysis, I took pictures from the freepik.com photo stock. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/be/p7/1g/bep71gaawmaf4thhfl5j7ig-1ze.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/bx/q_/zt/bxq_ztaqhom_1utv10_fiik2qbw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/k_/fa/x4/k_fax4jhbwyxzqhth0a7gdquwuk.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/zw/hc/fo/zwhcfoypmkq78gcvae5nxejwhkc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We determine the boundaries of the first picture before and after blurring: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/mu/tz/fw/mutzfwpy7abfonej9aowhiffg1s.jpeg"><img src="https://habrastorage.org/webt/z2/3u/xi/z23uxi_ei9xh9ql1qnhf9zaoz4i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Second: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/xi/fj/5c/xifj5chec5sccukkrgg2rhjj73e.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ye/8n/ei/ye8neincmrszl7nf6cexjzmy6aa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Third: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/x5/1z/js/x51zjshztdvw40frgdzknx09tic.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/r6/l6/uu/r6l6uum_2u9oee8vqacw0s5fvgo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fourth: </font></font><br>
<br>
<img align="left" src="https://habrastorage.org/webt/yp/4n/jy/yp4njywmsdj9p-wi7syid1srtgq.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/jc/dn/mv/jcdnmv7t8nontgodlfjd4robqaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The images show that the change in the borders of clear pictures (3rd and 4th) is stronger than that of fuzzy (1st and 2nd). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the calculations, we obtain the coefficients: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[5.92918651681958, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.672756123184502, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10.695051017699232, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11.901115749698139] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The coefficients confirm the conclusions: the larger the coefficient, the sharper the photo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moreover, the second picture is less clear than the first, which is reflected in the coefficients.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approach features</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the sharper the picture, the stronger the border changes, which means the higher the parameter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for different needs, different clarity is needed. </font><font style="vertical-align: inherit;">Therefore, it is necessary to determine the boundaries of clarity on your own: somewhere, the coefficient of sufficient clear photos will be above 7, somewhere only above 10;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the coefficient depends on the brightness of the photo. </font><font style="vertical-align: inherit;">The borders of dark photos will change weaker, which means that the coefficient will be less. </font><font style="vertical-align: inherit;">It turns out that the boundaries of clarity must be determined taking into account the lighting, that is, for standard photographs;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A working algorithm can be found on my </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> account </font><font style="vertical-align: inherit;">.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en496118/index.html">Why are there so many data centers in Amsterdam</a></li>
<li><a href="../en496122/index.html">Caring for your homework: backup your laptop or desktop using the free Veeam Agents</a></li>
<li><a href="../en496126/index.html">Crazy Logs</a></li>
<li><a href="../en496128/index.html">How SEO optimization and Google algorithms destroyed the real Internet</a></li>
<li><a href="../en496130/index.html">Mirror of the soul: the history of TV from the “box” to intelligence</a></li>
<li><a href="../en496136/index.html">Using the ColorPicker library in Android to implement flexible color selection</a></li>
<li><a href="../en496138/index.html">Take and join in musical programming - languages ​​that will help to do this</a></li>
<li><a href="../en496144/index.html">The fruits of isolation: COVID-19 interactive map with historical schedules and migration restrictions</a></li>
<li><a href="../en496146/index.html">Lua on STM32</a></li>
<li><a href="../en496148/index.html">Structural design patterns in ES6 + on the example of the Game of Thrones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>