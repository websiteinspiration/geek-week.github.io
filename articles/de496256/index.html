<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏾 🤕 🧜🏽 Maschinelles Lernen auf R: Expertentechniken für die prädiktive Analyse 💻 👷 😱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Die R-Sprache bietet eine Reihe leistungsstarker Methoden für maschinelles Lernen, mit denen Sie Ihre Daten schnell und nicht triv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen auf R: Expertentechniken für die prädiktive Analyse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo habrozhiteli! Die R-Sprache bietet eine Reihe leistungsstarker Methoden für maschinelles Lernen, mit denen Sie Ihre Daten schnell und nicht trivial analysieren können. Das Buch ist ein Leitfaden, der dabei hilft, Methoden des maschinellen Lernens anzuwenden, um alltägliche Probleme zu lösen. Brett Lanz bringt Ihnen alles bei, was Sie für die Datenanalyse, Prognose und Datenvisualisierung benötigen. Hier finden Sie Informationen zu neuen und verbesserten Bibliotheken, Tipps zu ethischen Aspekten des maschinellen Lernens und zu Voreingenommenheit sowie ausführliche Schulungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Buch - Grundlagen des maschinellen Lernens und Funktionen des Computertrainings an Beispielen. </font><font style="vertical-align: inherit;">- Vorbereitung von Daten zur Verwendung beim maschinellen Lernen mittels der Sprache R. - Klassifizierung der Signifikanz der Ergebnisse. </font><font style="vertical-align: inherit;">- Vorhersage von Ereignissen mithilfe von Entscheidungsbäumen, Regeln und Referenzvektoren. </font><font style="vertical-align: inherit;">- Vorhersage numerischer Daten und Bewertung von Finanzdaten mithilfe von Regressionsmethoden. </font><font style="vertical-align: inherit;">- Die Modellierung komplexer Prozesse mithilfe neuronaler Netze ist die Grundlage für tiefes Lernen. </font><font style="vertical-align: inherit;">- Bewertung von Modellen und Verbesserung ihrer Leistung. </font><font style="vertical-align: inherit;">- Die neuesten Technologien zur Verarbeitung von Big Data, insbesondere R 3.6, Spark, H2O und TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für wen ist das Buch?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Buch richtet sich an Personen, die Daten in einem bestimmten Bereich verwenden möchten. </font><font style="vertical-align: inherit;">Sie sind vielleicht schon ein wenig mit maschinellem Lernen vertraut, haben aber noch nie mit der R-Sprache gearbeitet. </font><font style="vertical-align: inherit;">oder umgekehrt wissen Sie ein wenig über R, wissen aber fast nichts über maschinelles Lernen. </font><font style="vertical-align: inherit;">In jedem Fall hilft Ihnen dieses Buch, schnell loszulegen. </font><font style="vertical-align: inherit;">Es wäre nützlich, die Grundkonzepte der Mathematik und Programmierung ein wenig aufzufrischen, aber es wären keine Vorkenntnisse erforderlich. </font><font style="vertical-align: inherit;">Alles was Sie brauchen ist der Wunsch zu lernen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was werden Sie in der Publikation lesen?</font></font></b><div class="spoiler_text"> 1 «   »    ,          ,      ,   ,     .<br>
<br>
 2 «    »            R.         ,   ,    .<br>
<br>
 3 « :      »      ,           :     .<br>
<br>
 4 « :      »     ,       .    ,      .<br>
<br>
 5 «  :       »    ,     ,    .      ,    .<br>
<br>
 6 «  :  »     ,    .        ,     ,     .<br>
<br>
 7 « “ ”:      »   ,     .        ,    ,    .<br>
<br>
 8 « :       »  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 «  :   k-»      .         -.<br>
<br>
 10 «  »    ,                  .<br>
<br>
 11 «  »  ,  ,        .                ,         .<br>
<br>
 12 «   »    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel: Modellierung der Betonfestigkeit mithilfe eines neuronalen Netzwerks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Bereich des Bauingenieurwesens ist es äußerst wichtig, genaue Schätzungen der Wirksamkeit von Baustoffen zu haben. </font><font style="vertical-align: inherit;">Diese Bewertungen sind erforderlich, um Sicherheitsregeln für die Verwendung von Materialien beim Bau von Gebäuden, Brücken und Straßen zu entwickeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von besonderem Interesse ist die Beurteilung der Betonfestigkeit. </font><font style="vertical-align: inherit;">Beton wird in fast jeder Konstruktion verwendet. Die Leistungsmerkmale von Beton sind sehr unterschiedlich, da er aus einer Vielzahl von Bestandteilen besteht, die in einem Komplex zusammenwirken. </font><font style="vertical-align: inherit;">Infolgedessen ist es schwierig, genau zu sagen, wie stark das fertige Produkt sein wird. </font><font style="vertical-align: inherit;">Ein Modell, mit dem die Festigkeit von Beton unter Berücksichtigung der Zusammensetzung der Ausgangsmaterialien sicher bestimmt werden kann, könnte ein höheres Sicherheitsniveau für Baustellen bieten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 1. Datenerfassung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diese Analyse verwenden wir die konkreten Druckfestigkeitsdaten, die I-Cheng Yeh dem UCI Machine Learning Repository (http://archive.ics.uci.edu/ml) zur Verfügung gestellt hat. </font><font style="vertical-align: inherit;">Da Ai-Cheng Ye erfolgreich neuronale Netze zur Modellierung dieser Daten verwendet hat, werden wir versuchen, seine Arbeit durch Anwendung eines einfachen neuronalen Netzmodells in R zu reproduzieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Standort zu urteilen, enthält dieser Datensatz 1030 Aufzeichnungen über verschiedene Betonsorten mit acht Merkmalen, die die für die Zusammensetzung der Betonmischung verwendeten Komponenten beschreiben. </font><font style="vertical-align: inherit;">Es wird angenommen, dass diese Eigenschaften die endgültige Druckfestigkeit beeinflussen. </font><font style="vertical-align: inherit;">Dazu gehören: die Menge (in Kilogramm pro Kubikmeter) Zement, Wasser, verschiedene Zusatzstoffe, große und kleine Zuschlagstoffe wie Schotter und Sand, die im Endprodukt verwendet werden, sowie die Abbindezeit (in Tagen).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie zum Ausführen dieses Beispiels die Dateicrete.csv herunter und speichern Sie sie im Arbeitsverzeichnis R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 2. Recherche und Datenaufbereitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie üblich starten wir die Analyse, indem wir die Daten mit der Funktion read.csv () in das R-Objekt laden und sicherstellen, dass das Ergebnis der erwarteten Struktur entspricht:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neun Variablen im Datenrahmen entsprechen acht Merkmalen und einem erwarteten Ergebnis, es wurde jedoch offensichtlich, dass ein Problem vorliegt. </font><font style="vertical-align: inherit;">Neuronale Netze funktionieren am besten, wenn die Eingabedaten auf einen engen Bereich um 0 skaliert werden. Hier sehen wir Werte im Bereich von 0 bis mehr als 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Regel besteht die Lösung für dieses Problem darin, die Daten mithilfe der Normalisierungs- oder Standardisierungsfunktion zu skalieren. Wenn die Datenverteilung einer glockenförmigen Kurve entspricht (Normalverteilung, siehe Kapitel 2), kann es sinnvoll sein, die Standardisierung mit der integrierten Funktion scale () zu verwenden. Wenn die Datenverteilung nahezu gleichmäßig ist oder sich stark von der Normalverteilung unterscheidet, ist eine Normalisierung auf den Bereich von 0 bis 1 möglicherweise besser geeignet. In diesem Fall verwenden wir die letztere Option. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Kapitel 3 haben wir unsere eigene normalize () -Funktion erstellt:</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) — min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem dieser Code ausgeführt wurde, können Sie die Funktion normalize () mit der Funktion lapply () auf alle Spalten des ausgewählten Datenrahmens anwenden: </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu überprüfen, ob die Normalisierung funktioniert hat, können Sie überprüfen, ob die Minimal- und Maximalwerte des </font><font style="vertical-align: inherit;">Stärkeattributs </font><font style="vertical-align: inherit;">0 bzw. 1 sind:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Vergleich: Die anfänglichen Minimal- und Maximalwerte dieses Attributs betrugen 2,33 bzw. 82,60:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Konvertierung, die vor dem Training des Modells auf die Daten angewendet wird, sollte anschließend in umgekehrter Reihenfolge angewendet werden, um das Attribut wieder in die ursprünglichen Einheiten zu konvertieren. </font><font style="vertical-align: inherit;">Um die Skalierung zu erleichtern, ist es ratsam, die Quelldaten oder zumindest eine Zusammenfassung der Statistiken der Quelldaten zu speichern.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem von Ye im Originalartikel beschriebenen Szenario werden wir die Daten in einen Trainingssatz, der 75% aller Beispiele enthält, und einen Testsatz, der aus 25% besteht, aufteilen. </font><font style="vertical-align: inherit;">Die verwendete CSV-Datei ist in zufälliger Reihenfolge sortiert, sodass wir sie nur in zwei Teile unterteilen können: </font><font style="vertical-align: inherit;">
Wir werden einen Trainingsdatensatz verwenden, um ein neuronales Netzwerk aufzubauen, und einen Testdatensatz, um zu bewerten, wie gut das Modell für zukünftige Ergebnisse verallgemeinert wird. </font><font style="vertical-align: inherit;">Da das neuronale Netz leicht in einen Umschulungszustand versetzt werden kann, ist dieser Schritt sehr wichtig.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 3. Trainieren Sie das Modell anhand von Daten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Beziehung zwischen den bei der Betonherstellung verwendeten Inhaltsstoffen und der Festigkeit des Endprodukts zu modellieren, werden wir ein mehrschichtiges neuronales Netzwerk mit direkter Verteilung aufbauen. Das von Stefan Fritsch und Frauke Guenther entwickelte Neuralnet-Paket bietet eine standardmäßige und benutzerfreundliche Implementierung solcher Netzwerke. Dieses Paket enthält auch eine Funktion zum Erstellen einer Netzwerktopologie. Die Implementierung von Neuralnet ist ein guter Weg, um zusätzliche Informationen über neuronale Netze zu erhalten, obwohl dies nicht bedeutet, dass es auch nicht für echte Arbeit verwendet werden kann - wie Sie gleich sehen werden, ist es ein ziemlich leistungsfähiges Werkzeug.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    —  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das Neuralnet-Paket nicht in der Basis R enthalten ist, müssen Sie es installieren, indem Sie install.packages ("neuralnet") eingeben und es mit dem Befehl library (neuralnet) herunterladen. </font><font style="vertical-align: inherit;">Die Funktion neuralnet () im Paket kann verwendet werden, um neuronale Netze in numerischer Vorhersage unter Verwendung der folgenden Syntax zu trainieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax des neuronalen Netzwerks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden der Funktion neuralnet () aus dem Neuralnet-Paket Erstellen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eines Modells:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• Ziel - ein Modell, das als Ergebnis des Trainings im mydata-Datenrahmen erstellt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• Prädiktoren - R-Formel, die die Merkmale aus dem Mydata-Datenrahmen bestimmt, die für die Prognose verwendet werden sollen; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• Daten - Datenrahmen, zu dem Ziel und Prädiktoren gehören; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• versteckt - Die Anzahl der Neuronen in der verborgenen Ebene (Standard ist 1). Hinweis: Um mehrere verborgene Schichten zu beschreiben, wird ein Vektor von ganzen Zahlen verwendet, z. B. c (2, 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• act.fct - Aktivierungsfunktion: "logistic" oder "tanh". Hinweis: Es kann auch jede andere differenzierbare Funktion verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion gibt ein neuronales Netzwerkobjekt zurück, das für die Vorhersage verwendet werden kann. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorhersage:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- berechnen (m, Test)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• m - Modell, das mit der Funktion neuralnet () trainiert wurde; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• test - Ein Datenrahmen, der Testdaten mit denselben Eigenschaften wie die Trainingsdaten enthält, die zur Erstellung des Klassifikators verwendet wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion gibt eine Liste zurück, die aus zwei Komponenten besteht: $ neuron, in der Neuronen für jede Netzwerkschicht gespeichert sind, und $ net.result, in der die mit diesem Modell vorhergesagten Werte gespeichert sind.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Training des einfachsten mehrstufigen Direktverteilungsnetzwerks mit Standardparametern, das nur einen versteckten Knoten hat:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann, wie in Abb. </font><font style="vertical-align: inherit;">7.11 können Sie die Netzwerktopologie mit der Funktion plot () visualisieren und das resultierende Modellobjekt übergeben:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem einfachen Modell gibt es einen Eingangsknoten für jedes der acht Merkmale, dann gibt es einen versteckten und einen Ausgangsknoten, die eine Vorhersage der konkreten Festigkeit geben. </font><font style="vertical-align: inherit;">Das Diagramm zeigt auch die Gewichte für jede Verbindung und den Versatzwert, der für die mit der Nummer 1 gekennzeichneten Knoten angegeben ist. Der Versatzwert ist eine numerische Konstante, mit der Sie den Wert im angegebenen Knoten nach oben oder unten verschieben können, ungefähr wie eine Verschiebung in einer linearen Gleichung.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein neuronales Netzwerk mit einem versteckten Knoten kann als „Cousin“ der in Kapitel 6 diskutierten linearen Regressionsmodelle betrachtet werden. Die Gewichte zwischen den Eingabeknoten und dem versteckten Knoten ähneln den Beta-Koeffizienten, und das Offsetgewicht ist wie eine Verschiebung.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am unteren Rand der Abbildung werden die Anzahl der Trainingsschritte und die Größe des Fehlers angezeigt - der mittlere quadratische Gesamtfehler (Summe der quadratischen Fehler, SSE), der erwartungsgemäß die Summe der quadratischen Differenzen zwischen den vorhergesagten und den tatsächlichen Werten ist. </font><font style="vertical-align: inherit;">Je kleiner die SSE ist, desto genauer stimmt das Modell mit den Trainingsdaten überein. Dies zeigt die Wirksamkeit dieser Daten an, sagt jedoch wenig darüber aus, wie das Modell mit unbekannten Daten funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 4. Bewertung der Wirksamkeit des Modells</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Netzwerktopologiediagramm bietet die Möglichkeit, einen Blick in die „Black Box“ eines neuronalen Netzwerks zu werfen, bietet jedoch nicht viele Informationen darüber, wie gut das Modell mit zukünftigen Daten übereinstimmt. Um Vorhersagen für einen Testdatensatz zu generieren, können Sie die </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktion </font><font style="vertical-align: inherit;">compute () </font><font style="vertical-align: inherit;">verwenden </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Die Funktion compute () funktioniert etwas anders als die bisher verwendeten Funktionen prognost (). Es gibt eine Liste zurück, die aus zwei Komponenten besteht: $ neuron, in der Neuronen für jede Netzwerkschicht gespeichert sind, und $ net.result, in der vorhergesagte Werte gespeichert sind. Es ist $ net.result, das wir brauchen:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir die Aufgabe der numerischen Vorhersage und nicht der Klassifizierung haben, können wir die Inkonsistenzmatrix nicht verwenden, um die Genauigkeit des Modells zu überprüfen. </font><font style="vertical-align: inherit;">Wir messen die Korrelation zwischen dem vorhergesagten und dem wahren Wert der Betonfestigkeit. </font><font style="vertical-align: inherit;">Wenn die vorhergesagten und tatsächlichen Werte stark korrelieren, ist das Modell wahrscheinlich nützlich, um die Festigkeit von Beton zu bestimmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte Sie daran erinnern, dass die Funktion cor () verwendet wird, um die Korrelation zwischen zwei numerischen Vektoren zu erhalten:</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seien Sie nicht beunruhigt, wenn Ihr Ergebnis von unserem abweicht. </font><font style="vertical-align: inherit;">Da das neuronale Netzwerk mit zufälligen Gewichten arbeitet, können die im Buch dargestellten Vorhersagen für verschiedene Modelle unterschiedlich sein. </font><font style="vertical-align: inherit;">Wenn Sie die Ergebnisse genau abgleichen möchten, versuchen Sie den Befehl set.seed (12345), bevor Sie mit dem Aufbau eines neuronalen Netzwerks beginnen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Korrelation nahe bei 1 liegt, weist dies auf eine starke lineare Beziehung zwischen den beiden Variablen hin. </font><font style="vertical-align: inherit;">Eine Korrelation von ungefähr 0,806 zeigt daher eine ziemlich starke Beziehung an. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Modell auch mit einem einzelnen versteckten Knoten recht gut funktioniert. </font><font style="vertical-align: inherit;">Da wir nur einen versteckten Knoten verwendet haben, ist es wahrscheinlich, dass wir die Effizienz des Modells verbessern können, was wir versuchen werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 5. Verbesserung der Modelleffizienz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Netzwerke mit einer komplexeren Topologie komplexere Konzepte untersuchen können, wollen wir sehen, was passiert, wenn Sie die Anzahl der versteckten Knoten auf fünf erhöhen. </font><font style="vertical-align: inherit;">Wir werden die Funktion neuralnet () wie zuvor verwenden, aber den Parameter hidden = 5 hinzufügen:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie das Netzwerkdiagramm erneut erstellt haben (Abb. 7.12), wird die Anzahl der Verbindungen stark zunehmen. Wie hat sich dies auf die Effizienz ausgewirkt? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass der resultierende Fehler (erneut gemessen als SSE) von 5,08 im Vorgängermodell auf 1,63 gesunken ist. Darüber hinaus stieg die Anzahl der Trainingsstufen von 4882 auf 86.849 - was angesichts der Kompliziertheit des Modells nicht verwunderlich ist. Je komplexer das Netzwerk ist, desto mehr Iterationen sind erforderlich, um die optimalen Gewichte zu finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir dieselben Schritte anwenden, um die vorhergesagten Werte mit den wahren zu vergleichen, erhalten wir eine Korrelation von etwa 0,92, was im Vergleich zum vorherigen Ergebnis von 0,80 für ein Netzwerk mit einem versteckten Knoten viel besser ist:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz erheblicher Verbesserungen können Sie die Effektivität des Modells noch weiter steigern. Insbesondere ist es möglich, zusätzliche verborgene Schichten einzuführen und die Netzwerkaktivierungsfunktion zu ändern. Mit diesen Änderungen legen wir den Grundstein für den Aufbau eines einfachen tiefen neuronalen Netzwerks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wahl der Aktivierungsfunktion ist für tiefes Lernen sehr wichtig. Die beste Funktion für eine bestimmte Lernaufgabe wird normalerweise experimentell gefunden und dann von der Gemeinschaft der Forscher für maschinelles Lernen häufig verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit ist die Aktivierungsfunktion, die als Destillationsfunktion oder Gleichrichter bezeichnet wird, aufgrund ihrer erfolgreichen Anwendung bei komplexen Aufgaben wie der Bilderkennung sehr beliebt geworden. Ein neuronaler Netzwerkknoten, in dem ein Gleichrichter als Aktivierungsfunktion verwendet wird, wird als Rectified Linear Unit (ReLU) bezeichnet. Wie in Abb. In 7.13 wird die Aktivierungsfunktion vom Gleichrichtertyp so beschrieben, dass x zurückgegeben wird, wenn x größer oder gleich 0 ist, und ansonsten 0. Die Bedeutung dieser Funktion besteht darin, dass sie einerseits nicht linear ist und andererseits einfache mathematische Eigenschaften aufweist, die sie rechnerisch kostengünstig und für den Gradientenabstieg hocheffizient machen. Leider ist für x = 0 die Gleichrichterableitung nicht definiert,Daher kann der Gleichrichter nicht in Verbindung mit der Funktion neuralnet () verwendet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen können Sie eine geglättete Approximation von ReLU verwenden, die als softplus oder SmoothReLU bezeichnet wird, eine Aktivierungsfunktion, die als log (1 + ex) definiert ist. </font><font style="vertical-align: inherit;">Wie in Abb. </font><font style="vertical-align: inherit;">7.13 ist die Softplus-Funktion für x-Werte kleiner als 0 nahe Null und für x größer als 0 ungefähr gleich x.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Funktion softplus () in R zu definieren, verwenden wir den folgenden Code: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Aktivierungsfunktion kann dem eingegebenen neuralnet () mit dem Parameter act.fct bereitgestellt werden. </font><font style="vertical-align: inherit;">Zusätzlich fügen wir eine zweite verborgene Schicht hinzu, die aus fünf Knoten besteht, und weisen dem verborgenen Parameter den Wert des ganzzahligen Vektors c (5, 5) zu. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir ein zweischichtiges Netzwerk, von dem jede fünf Knoten hat und alle die Softplus-Aktivierungsfunktion verwenden:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach wie vor kann das Netzwerk visualisiert werden (Abb. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Korrelation zwischen der vorhergesagten und der tatsächlichen Festigkeit von Beton kann wie folgt berechnet werden:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Korrelation zwischen der vorhergesagten und der tatsächlichen Stärke betrug 0,935, was der bisher beste erhaltene Indikator ist. Interessanterweise berichtete Ye in der Originalveröffentlichung über eine Korrelation von 0,885. Dies bedeutet, dass wir mit relativ geringem Aufwand ein vergleichbares Ergebnis erzielen und sogar die Ergebnisse eines Experten auf diesem Gebiet übertreffen konnten. Die Ergebnisse von Ye wurden zwar 1998 veröffentlicht, was uns einen Vorsprung auf mehr als 20 Jahre zusätzlicher Forschung auf dem Gebiet der neuronalen Netze verschaffte! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres wichtiges Detail sollte berücksichtigt werden: Da wir die Daten vor dem Training des Modells normalisiert haben, liegen die Vorhersagen auch im normalisierten Intervall von 0 bis 1. Der folgende Code zeigt beispielsweise einen Datenrahmen, der die konkreten Festigkeitswerte aus dem Anfangsdatensatz zeilenweise mit den entsprechenden Vorhersagen vergleicht:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir </font><font style="vertical-align: inherit;">
die Korrelation untersuchen, sehen wir, dass die Auswahl normalisierter oder abnormalisierter Daten keinen Einfluss auf die berechnete Leistungsstatistik hat - genau wie zuvor beträgt die Korrelation 0,935: </font><font style="vertical-align: inherit;">Wenn wir jedoch einen anderen Leistungsindikator berechnet haben, beispielsweise die absolute Differenz zwischen den vorhergesagten und den tatsächlichen Werten, dann Die Wahl des Maßstabs wäre sehr wichtig. </font><font style="vertical-align: inherit;">
In diesem Sinne können Sie die Funktion unnormalize () erstellen, die die Umkehrung der Minimax-Normalisierung ausführt und es Ihnen ermöglicht, normalisierte Vorhersagen in den ursprünglichen Maßstab umzuwandeln:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Anwendung der Funktion unnormalize (), die wir für Prognosen geschrieben haben, wird deutlich, dass der Maßstab der neuen Prognosen den Anfangswerten der Betonfestigkeit ähnlich ist. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie den aussagekräftigen Wert des absoluten Fehlers berechnen. </font><font style="vertical-align: inherit;">Darüber hinaus bleibt die Korrelation zwischen abnormalen und anfänglichen Festigkeitswerten unverändert:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new — strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie neuronale Netze auf Ihre Projekte anwenden, müssen Sie eine ähnliche Abfolge von Schritten ausführen, um die Daten auf ihren ursprünglichen Maßstab zurückzusetzen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise stellen Sie auch fest, dass neuronale Netze schnell komplexer werden, da sie für immer schwierigere Lernaufgaben verwendet werden. Beispielsweise können Sie auf das sogenannte "verschwindende" kleine Gradientenproblem und das eng verwandte "explodierende" Gradientenproblem stoßen, wenn der Rückausbreitungsalgorithmus keine nützliche Lösung findet, da er nicht in einer angemessenen Zeit konvergiert. Um diese Probleme zu lösen, können Sie versuchen, die Anzahl der ausgeblendeten Knoten zu ändern, verschiedene Aktivierungsfunktionen wie ReLU anzuwenden, die Lerngeschwindigkeit anzupassen usw. Auf der Hilfeseite für die Neuralnet-Funktion finden Sie zusätzliche Informationen zu den verschiedenen Parametern, die konfiguriert werden können. Dies führt jedoch zu einem anderen Problem:wenn der Engpass beim Aufbau eines hocheffizienten Modells darin besteht, eine große Anzahl von Parametern zu überprüfen. Dies ist der Preis für die Verwendung neuronaler Netze und vor allem für Deep-Learning-Netze: Ihr großes Potenzial erfordert viel Zeit und Rechenleistung.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die SVM-Methode (Support Vector Machine) kann als Oberfläche dargestellt werden, die die Grenze zwischen Datenpunkten bildet, die in einem mehrdimensionalen Raum dargestellt sind und Beispiele und Werte ihrer Attribute beschreiben. Das Ziel von SVM ist es, eine flache Grenze zu bauen - eine Hyperebene, die den Raum so teilt, dass sich auf beiden Seiten homogene Gruppen bilden. Daher kombiniert das SVM-Training Aspekte des Trainings für den nächsten Nachbarn basierend auf den in Kapitel 3 beschriebenen Instanzen und der in Kapitel 6 beschriebenen linearen Regressionsmodellierung. Dies ist eine äußerst leistungsstarke Kombination, mit der SVMs sehr komplexe Beziehungen modellieren können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass die grundlegende Mathematik, die SVM zugrunde liegt, seit Jahrzehnten besteht, hat das Interesse an diesen Methoden erheblich zugenommen, nachdem sie auf ML angewendet wurden. Die Popularität dieser Methoden stieg nach hochkarätigen Erfolgsgeschichten bei der Lösung komplexer Lernprobleme sowie nach der Entwicklung von SVM-Algorithmen, die in gut unterstützten Bibliotheken in vielen Programmiersprachen, einschließlich R, vergeben und implementiert wurden. Danach wurden SVM-Methoden von einem breiten Publikum akzeptiert. Andernfalls wäre es wahrscheinlich unmöglich, die komplexe Mathematik anzuwenden, die zur Implementierung von SVM erforderlich ist. Die gute Nachricht ist, dass die Mathematik zwar möglicherweise komplex ist, die Grundkonzepte jedoch gut verstanden werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SVM-Methoden können für nahezu jede Art von Trainingsaufgabe angepasst werden, einschließlich Klassifizierung und numerischer Vorhersage. </font><font style="vertical-align: inherit;">Viele der wichtigsten Erfolge dieses Algorithmus beziehen sich auf die Mustererkennung. </font><font style="vertical-align: inherit;">Die bekanntesten Anwendungen für diese Methoden umfassen Folgendes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassifizierung von Daten zur Expression von Microarray-Genen in der Bioinformatik zum Nachweis von Krebs und anderen genetischen Erkrankungen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textkategorisierung, z. B. Bestimmen der in einem Dokument verwendeten Sprache oder Klassifizieren von Dokumenten nach Themen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erkennung seltener, aber wichtiger Ereignisse wie Ausfall eines Verbrennungsmotors, Sicherheitsverletzung oder Erdbeben.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SVM-Methoden sind am einfachsten anhand der binären Klassifizierung als Beispiel zu verstehen - so werden sie normalerweise verwendet. </font><font style="vertical-align: inherit;">Daher konzentrieren wir uns in den verbleibenden Abschnitten nur auf SVM-Klassifizierer. </font><font style="vertical-align: inherit;">Ähnliche Prinzipien wie die hier vorgestellten werden auch bei der Anpassung von SVM-Methoden für die numerische Vorhersage verwendet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über den Autor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) verwendet seit mehr als einem Jahrzehnt innovative Datenverarbeitungstechniken, um menschliches Verhalten zu untersuchen. </font><font style="vertical-align: inherit;">Als ausgebildeter Soziologe interessierte sich Brett zunächst für maschinelles Lernen, während er eine große Datenbank mit Jugendprofilen in sozialen Netzwerken durchsuchte. </font><font style="vertical-align: inherit;">Brett ist Lehrer bei DataCamp und hält häufig Präsentationen auf Konferenzen und Seminaren zum maschinellen Lernen auf der ganzen Welt. </font><font style="vertical-align: inherit;">Er ist ein bekannter Enthusiast auf dem Gebiet der praktischen Anwendung der Datenwissenschaft im Bereich Sport, unbemannte Fahrzeuge, Fremdsprachen- und Modestudien sowie in vielen anderen Branchen. </font><font style="vertical-align: inherit;">Brett hofft, eines Tages auf dataspelunking.com darüber schreiben zu können, einen Wissensaustausch über das Finden von Mustern in Daten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über Science Editor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - leitender Forscher einer der weltweit größten Gesundheitsorganisationen. Er ist in der Forschung und Entwicklung von Unternehmenslösungen tätig, die auf maschinellem Lernen, tiefem Lernen und Verarbeitung natürlicher Sprachen für den Einsatz im Gesundheitswesen und in der Versicherung basieren. In seiner vorherigen Position bei Intel nahm er an proaktiven Initiativen auf dem Gebiet der Informationstechnologie teil, die auf Big Data basieren und natürliche Sprachverarbeitung, tiefes Lernen und traditionelle statistische Methoden verwenden. Bei American Express arbeitete er im Bereich digitales Engagement und Kundenbindung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav ist Autor mehrerer Bücher, die von führenden Verlagen veröffentlicht wurden. </font><font style="vertical-align: inherit;">Sein neuestes Buch handelt von der neuesten Transferstudie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav absolvierte das Internationale Institut für Informationstechnologie in Bangalore und hat einen Master-Abschluss (Honours Degree). </font><font style="vertical-align: inherit;">In diesen seltenen Momenten, in denen er nicht gerade damit beschäftigt ist, wissenschaftliche Probleme zu lösen, liest und fotografiert Raghav gerne alles hintereinander. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Weitere Informationen zum Buch finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
für Khabrozhiteley 25% Rabatt auf den Gutschein - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschinelles Lernen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496242/index.html">Cyberpunk ist bereits da: Schüler lernen bei Minecraft und Schüler machen physische Tests in CS: GO</a></li>
<li><a href="../de496248/index.html">Herausforderungen, kahle Köpfe und Wein. Wie wir bei HFLabs Selbstisolation ertragen</a></li>
<li><a href="../de496250/index.html">Wie seltsamer Code verbirgt Fehler? TensorFlow.NET-Analyse</a></li>
<li><a href="../de496252/index.html">Aerodynamisch versetzte Zentrierflugzeuge</a></li>
<li><a href="../de496254/index.html">Wie Rostelecom den Datenverkehr fälschlicherweise an Google, AWS, Cloudflare usw. umleitete</a></li>
<li><a href="../de496258/index.html">Online-Holivar: Ein neues Format für den Erfahrungsaustausch. Diesen Samstag</a></li>
<li><a href="../de496260/index.html">Tipps zur Cybersicherheit für die Arbeit von zu Hause aus</a></li>
<li><a href="../de496262/index.html">CVE-ID abrufen</a></li>
<li><a href="../de496266/index.html">Коронавирус: мы все умрём?</a></li>
<li><a href="../de496268/index.html">Huawei Enterprise Netzwerkprodukte und -lösungen für Unternehmenskunden im Jahr 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>