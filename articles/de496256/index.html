<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèæ ü§ï üßúüèΩ Maschinelles Lernen auf R: Expertentechniken f√ºr die pr√§diktive Analyse üíª üë∑ üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Die R-Sprache bietet eine Reihe leistungsstarker Methoden f√ºr maschinelles Lernen, mit denen Sie Ihre Daten schnell und nicht triv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen auf R: Expertentechniken f√ºr die pr√§diktive Analyse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo habrozhiteli! Die R-Sprache bietet eine Reihe leistungsstarker Methoden f√ºr maschinelles Lernen, mit denen Sie Ihre Daten schnell und nicht trivial analysieren k√∂nnen. Das Buch ist ein Leitfaden, der dabei hilft, Methoden des maschinellen Lernens anzuwenden, um allt√§gliche Probleme zu l√∂sen. Brett Lanz bringt Ihnen alles bei, was Sie f√ºr die Datenanalyse, Prognose und Datenvisualisierung ben√∂tigen. Hier finden Sie Informationen zu neuen und verbesserten Bibliotheken, Tipps zu ethischen Aspekten des maschinellen Lernens und zu Voreingenommenheit sowie ausf√ºhrliche Schulungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Buch - Grundlagen des maschinellen Lernens und Funktionen des Computertrainings an Beispielen. </font><font style="vertical-align: inherit;">- Vorbereitung von Daten zur Verwendung beim maschinellen Lernen mittels der Sprache R. - Klassifizierung der Signifikanz der Ergebnisse. </font><font style="vertical-align: inherit;">- Vorhersage von Ereignissen mithilfe von Entscheidungsb√§umen, Regeln und Referenzvektoren. </font><font style="vertical-align: inherit;">- Vorhersage numerischer Daten und Bewertung von Finanzdaten mithilfe von Regressionsmethoden. </font><font style="vertical-align: inherit;">- Die Modellierung komplexer Prozesse mithilfe neuronaler Netze ist die Grundlage f√ºr tiefes Lernen. </font><font style="vertical-align: inherit;">- Bewertung von Modellen und Verbesserung ihrer Leistung. </font><font style="vertical-align: inherit;">- Die neuesten Technologien zur Verarbeitung von Big Data, insbesondere R 3.6, Spark, H2O und TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr wen ist das Buch?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Buch richtet sich an Personen, die Daten in einem bestimmten Bereich verwenden m√∂chten. </font><font style="vertical-align: inherit;">Sie sind vielleicht schon ein wenig mit maschinellem Lernen vertraut, haben aber noch nie mit der R-Sprache gearbeitet. </font><font style="vertical-align: inherit;">oder umgekehrt wissen Sie ein wenig √ºber R, wissen aber fast nichts √ºber maschinelles Lernen. </font><font style="vertical-align: inherit;">In jedem Fall hilft Ihnen dieses Buch, schnell loszulegen. </font><font style="vertical-align: inherit;">Es w√§re n√ºtzlich, die Grundkonzepte der Mathematik und Programmierung ein wenig aufzufrischen, aber es w√§ren keine Vorkenntnisse erforderlich. </font><font style="vertical-align: inherit;">Alles was Sie brauchen ist der Wunsch zu lernen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was werden Sie in der Publikation lesen?</font></font></b><div class="spoiler_text"> 1 ¬´   ¬ª    ,          ,      ,   ,     .<br>
<br>
 2 ¬´    ¬ª            R.         ,   ,    .<br>
<br>
 3 ¬´ :      ¬ª      ,           :     .<br>
<br>
 4 ¬´ :      ¬ª     ,       .    ,      .<br>
<br>
 5 ¬´  :       ¬ª    ,     ,    .      ,    .<br>
<br>
 6 ¬´  :  ¬ª     ,    .        ,     ,     .<br>
<br>
 7 ¬´ ‚Äú ‚Äù:      ¬ª   ,     .        ,    ,    .<br>
<br>
 8 ¬´ :       ¬ª  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 ¬´  :   k-¬ª      .         -.<br>
<br>
 10 ¬´  ¬ª    ,                  .<br>
<br>
 11 ¬´  ¬ª  ,  ,        .                ,         .<br>
<br>
 12 ¬´   ¬ª    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel: Modellierung der Betonfestigkeit mithilfe eines neuronalen Netzwerks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Bereich des Bauingenieurwesens ist es √§u√üerst wichtig, genaue Sch√§tzungen der Wirksamkeit von Baustoffen zu haben. </font><font style="vertical-align: inherit;">Diese Bewertungen sind erforderlich, um Sicherheitsregeln f√ºr die Verwendung von Materialien beim Bau von Geb√§uden, Br√ºcken und Stra√üen zu entwickeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von besonderem Interesse ist die Beurteilung der Betonfestigkeit. </font><font style="vertical-align: inherit;">Beton wird in fast jeder Konstruktion verwendet. Die Leistungsmerkmale von Beton sind sehr unterschiedlich, da er aus einer Vielzahl von Bestandteilen besteht, die in einem Komplex zusammenwirken. </font><font style="vertical-align: inherit;">Infolgedessen ist es schwierig, genau zu sagen, wie stark das fertige Produkt sein wird. </font><font style="vertical-align: inherit;">Ein Modell, mit dem die Festigkeit von Beton unter Ber√ºcksichtigung der Zusammensetzung der Ausgangsmaterialien sicher bestimmt werden kann, k√∂nnte ein h√∂heres Sicherheitsniveau f√ºr Baustellen bieten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 1. Datenerfassung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diese Analyse verwenden wir die konkreten Druckfestigkeitsdaten, die I-Cheng Yeh dem UCI Machine Learning Repository (http://archive.ics.uci.edu/ml) zur Verf√ºgung gestellt hat. </font><font style="vertical-align: inherit;">Da Ai-Cheng Ye erfolgreich neuronale Netze zur Modellierung dieser Daten verwendet hat, werden wir versuchen, seine Arbeit durch Anwendung eines einfachen neuronalen Netzmodells in R zu reproduzieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Standort zu urteilen, enth√§lt dieser Datensatz 1030 Aufzeichnungen √ºber verschiedene Betonsorten mit acht Merkmalen, die die f√ºr die Zusammensetzung der Betonmischung verwendeten Komponenten beschreiben. </font><font style="vertical-align: inherit;">Es wird angenommen, dass diese Eigenschaften die endg√ºltige Druckfestigkeit beeinflussen. </font><font style="vertical-align: inherit;">Dazu geh√∂ren: die Menge (in Kilogramm pro Kubikmeter) Zement, Wasser, verschiedene Zusatzstoffe, gro√üe und kleine Zuschlagstoffe wie Schotter und Sand, die im Endprodukt verwendet werden, sowie die Abbindezeit (in Tagen).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie zum Ausf√ºhren dieses Beispiels die Dateicrete.csv herunter und speichern Sie sie im Arbeitsverzeichnis R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 2. Recherche und Datenaufbereitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie √ºblich starten wir die Analyse, indem wir die Daten mit der Funktion read.csv () in das R-Objekt laden und sicherstellen, dass das Ergebnis der erwarteten Struktur entspricht:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neun Variablen im Datenrahmen entsprechen acht Merkmalen und einem erwarteten Ergebnis, es wurde jedoch offensichtlich, dass ein Problem vorliegt. </font><font style="vertical-align: inherit;">Neuronale Netze funktionieren am besten, wenn die Eingabedaten auf einen engen Bereich um 0 skaliert werden. Hier sehen wir Werte im Bereich von 0 bis mehr als 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Regel besteht die L√∂sung f√ºr dieses Problem darin, die Daten mithilfe der Normalisierungs- oder Standardisierungsfunktion zu skalieren. Wenn die Datenverteilung einer glockenf√∂rmigen Kurve entspricht (Normalverteilung, siehe Kapitel 2), kann es sinnvoll sein, die Standardisierung mit der integrierten Funktion scale () zu verwenden. Wenn die Datenverteilung nahezu gleichm√§√üig ist oder sich stark von der Normalverteilung unterscheidet, ist eine Normalisierung auf den Bereich von 0 bis 1 m√∂glicherweise besser geeignet. In diesem Fall verwenden wir die letztere Option. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Kapitel 3 haben wir unsere eigene normalize () -Funktion erstellt:</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) ‚Äî min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem dieser Code ausgef√ºhrt wurde, k√∂nnen Sie die Funktion normalize () mit der Funktion lapply () auf alle Spalten des ausgew√§hlten Datenrahmens anwenden: </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu √ºberpr√ºfen, ob die Normalisierung funktioniert hat, k√∂nnen Sie √ºberpr√ºfen, ob die Minimal- und Maximalwerte des </font><font style="vertical-align: inherit;">St√§rkeattributs </font><font style="vertical-align: inherit;">0 bzw. 1 sind:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Vergleich: Die anf√§nglichen Minimal- und Maximalwerte dieses Attributs betrugen 2,33 bzw. 82,60:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Konvertierung, die vor dem Training des Modells auf die Daten angewendet wird, sollte anschlie√üend in umgekehrter Reihenfolge angewendet werden, um das Attribut wieder in die urspr√ºnglichen Einheiten zu konvertieren. </font><font style="vertical-align: inherit;">Um die Skalierung zu erleichtern, ist es ratsam, die Quelldaten oder zumindest eine Zusammenfassung der Statistiken der Quelldaten zu speichern.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem von Ye im Originalartikel beschriebenen Szenario werden wir die Daten in einen Trainingssatz, der 75% aller Beispiele enth√§lt, und einen Testsatz, der aus 25% besteht, aufteilen. </font><font style="vertical-align: inherit;">Die verwendete CSV-Datei ist in zuf√§lliger Reihenfolge sortiert, sodass wir sie nur in zwei Teile unterteilen k√∂nnen: </font><font style="vertical-align: inherit;">
Wir werden einen Trainingsdatensatz verwenden, um ein neuronales Netzwerk aufzubauen, und einen Testdatensatz, um zu bewerten, wie gut das Modell f√ºr zuk√ºnftige Ergebnisse verallgemeinert wird. </font><font style="vertical-align: inherit;">Da das neuronale Netz leicht in einen Umschulungszustand versetzt werden kann, ist dieser Schritt sehr wichtig.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 3. Trainieren Sie das Modell anhand von Daten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Beziehung zwischen den bei der Betonherstellung verwendeten Inhaltsstoffen und der Festigkeit des Endprodukts zu modellieren, werden wir ein mehrschichtiges neuronales Netzwerk mit direkter Verteilung aufbauen. Das von Stefan Fritsch und Frauke Guenther entwickelte Neuralnet-Paket bietet eine standardm√§√üige und benutzerfreundliche Implementierung solcher Netzwerke. Dieses Paket enth√§lt auch eine Funktion zum Erstellen einer Netzwerktopologie. Die Implementierung von Neuralnet ist ein guter Weg, um zus√§tzliche Informationen √ºber neuronale Netze zu erhalten, obwohl dies nicht bedeutet, dass es auch nicht f√ºr echte Arbeit verwendet werden kann - wie Sie gleich sehen werden, ist es ein ziemlich leistungsf√§higes Werkzeug.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    ‚Äî  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das Neuralnet-Paket nicht in der Basis R enthalten ist, m√ºssen Sie es installieren, indem Sie install.packages ("neuralnet") eingeben und es mit dem Befehl library (neuralnet) herunterladen. </font><font style="vertical-align: inherit;">Die Funktion neuralnet () im Paket kann verwendet werden, um neuronale Netze in numerischer Vorhersage unter Verwendung der folgenden Syntax zu trainieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax des neuronalen Netzwerks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden der Funktion neuralnet () aus dem Neuralnet-Paket Erstellen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eines Modells:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Ziel - ein Modell, das als Ergebnis des Trainings im mydata-Datenrahmen erstellt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Pr√§diktoren - R-Formel, die die Merkmale aus dem Mydata-Datenrahmen bestimmt, die f√ºr die Prognose verwendet werden sollen; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ Daten - Datenrahmen, zu dem Ziel und Pr√§diktoren geh√∂ren; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ versteckt - Die Anzahl der Neuronen in der verborgenen Ebene (Standard ist 1). Hinweis: Um mehrere verborgene Schichten zu beschreiben, wird ein Vektor von ganzen Zahlen verwendet, z. B. c (2, 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ act.fct - Aktivierungsfunktion: "logistic" oder "tanh". Hinweis: Es kann auch jede andere differenzierbare Funktion verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion gibt ein neuronales Netzwerkobjekt zur√ºck, das f√ºr die Vorhersage verwendet werden kann. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorhersage:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- berechnen (m, Test)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ m - Modell, das mit der Funktion neuralnet () trainiert wurde; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¢ test - Ein Datenrahmen, der Testdaten mit denselben Eigenschaften wie die Trainingsdaten enth√§lt, die zur Erstellung des Klassifikators verwendet wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion gibt eine Liste zur√ºck, die aus zwei Komponenten besteht: $ neuron, in der Neuronen f√ºr jede Netzwerkschicht gespeichert sind, und $ net.result, in der die mit diesem Modell vorhergesagten Werte gespeichert sind.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit dem Training des einfachsten mehrstufigen Direktverteilungsnetzwerks mit Standardparametern, das nur einen versteckten Knoten hat:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann, wie in Abb. </font><font style="vertical-align: inherit;">7.11 k√∂nnen Sie die Netzwerktopologie mit der Funktion plot () visualisieren und das resultierende Modellobjekt √ºbergeben:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem einfachen Modell gibt es einen Eingangsknoten f√ºr jedes der acht Merkmale, dann gibt es einen versteckten und einen Ausgangsknoten, die eine Vorhersage der konkreten Festigkeit geben. </font><font style="vertical-align: inherit;">Das Diagramm zeigt auch die Gewichte f√ºr jede Verbindung und den Versatzwert, der f√ºr die mit der Nummer 1 gekennzeichneten Knoten angegeben ist. Der Versatzwert ist eine numerische Konstante, mit der Sie den Wert im angegebenen Knoten nach oben oder unten verschieben k√∂nnen, ungef√§hr wie eine Verschiebung in einer linearen Gleichung.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein neuronales Netzwerk mit einem versteckten Knoten kann als ‚ÄûCousin‚Äú der in Kapitel 6 diskutierten linearen Regressionsmodelle betrachtet werden. Die Gewichte zwischen den Eingabeknoten und dem versteckten Knoten √§hneln den Beta-Koeffizienten, und das Offsetgewicht ist wie eine Verschiebung.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am unteren Rand der Abbildung werden die Anzahl der Trainingsschritte und die Gr√∂√üe des Fehlers angezeigt - der mittlere quadratische Gesamtfehler (Summe der quadratischen Fehler, SSE), der erwartungsgem√§√ü die Summe der quadratischen Differenzen zwischen den vorhergesagten und den tats√§chlichen Werten ist. </font><font style="vertical-align: inherit;">Je kleiner die SSE ist, desto genauer stimmt das Modell mit den Trainingsdaten √ºberein. Dies zeigt die Wirksamkeit dieser Daten an, sagt jedoch wenig dar√ºber aus, wie das Modell mit unbekannten Daten funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 4. Bewertung der Wirksamkeit des Modells</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Netzwerktopologiediagramm bietet die M√∂glichkeit, einen Blick in die ‚ÄûBlack Box‚Äú eines neuronalen Netzwerks zu werfen, bietet jedoch nicht viele Informationen dar√ºber, wie gut das Modell mit zuk√ºnftigen Daten √ºbereinstimmt. Um Vorhersagen f√ºr einen Testdatensatz zu generieren, k√∂nnen Sie die </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktion </font><font style="vertical-align: inherit;">compute () </font><font style="vertical-align: inherit;">verwenden </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Die Funktion compute () funktioniert etwas anders als die bisher verwendeten Funktionen prognost (). Es gibt eine Liste zur√ºck, die aus zwei Komponenten besteht: $ neuron, in der Neuronen f√ºr jede Netzwerkschicht gespeichert sind, und $ net.result, in der vorhergesagte Werte gespeichert sind. Es ist $ net.result, das wir brauchen:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir die Aufgabe der numerischen Vorhersage und nicht der Klassifizierung haben, k√∂nnen wir die Inkonsistenzmatrix nicht verwenden, um die Genauigkeit des Modells zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wir messen die Korrelation zwischen dem vorhergesagten und dem wahren Wert der Betonfestigkeit. </font><font style="vertical-align: inherit;">Wenn die vorhergesagten und tats√§chlichen Werte stark korrelieren, ist das Modell wahrscheinlich n√ºtzlich, um die Festigkeit von Beton zu bestimmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte Sie daran erinnern, dass die Funktion cor () verwendet wird, um die Korrelation zwischen zwei numerischen Vektoren zu erhalten:</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seien Sie nicht beunruhigt, wenn Ihr Ergebnis von unserem abweicht. </font><font style="vertical-align: inherit;">Da das neuronale Netzwerk mit zuf√§lligen Gewichten arbeitet, k√∂nnen die im Buch dargestellten Vorhersagen f√ºr verschiedene Modelle unterschiedlich sein. </font><font style="vertical-align: inherit;">Wenn Sie die Ergebnisse genau abgleichen m√∂chten, versuchen Sie den Befehl set.seed (12345), bevor Sie mit dem Aufbau eines neuronalen Netzwerks beginnen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Korrelation nahe bei 1 liegt, weist dies auf eine starke lineare Beziehung zwischen den beiden Variablen hin. </font><font style="vertical-align: inherit;">Eine Korrelation von ungef√§hr 0,806 zeigt daher eine ziemlich starke Beziehung an. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Modell auch mit einem einzelnen versteckten Knoten recht gut funktioniert. </font><font style="vertical-align: inherit;">Da wir nur einen versteckten Knoten verwendet haben, ist es wahrscheinlich, dass wir die Effizienz des Modells verbessern k√∂nnen, was wir versuchen werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 5. Verbesserung der Modelleffizienz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Netzwerke mit einer komplexeren Topologie komplexere Konzepte untersuchen k√∂nnen, wollen wir sehen, was passiert, wenn Sie die Anzahl der versteckten Knoten auf f√ºnf erh√∂hen. </font><font style="vertical-align: inherit;">Wir werden die Funktion neuralnet () wie zuvor verwenden, aber den Parameter hidden = 5 hinzuf√ºgen:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie das Netzwerkdiagramm erneut erstellt haben (Abb. 7.12), wird die Anzahl der Verbindungen stark zunehmen. Wie hat sich dies auf die Effizienz ausgewirkt? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass der resultierende Fehler (erneut gemessen als SSE) von 5,08 im Vorg√§ngermodell auf 1,63 gesunken ist. Dar√ºber hinaus stieg die Anzahl der Trainingsstufen von 4882 auf 86.849 - was angesichts der Kompliziertheit des Modells nicht verwunderlich ist. Je komplexer das Netzwerk ist, desto mehr Iterationen sind erforderlich, um die optimalen Gewichte zu finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir dieselben Schritte anwenden, um die vorhergesagten Werte mit den wahren zu vergleichen, erhalten wir eine Korrelation von etwa 0,92, was im Vergleich zum vorherigen Ergebnis von 0,80 f√ºr ein Netzwerk mit einem versteckten Knoten viel besser ist:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz erheblicher Verbesserungen k√∂nnen Sie die Effektivit√§t des Modells noch weiter steigern. Insbesondere ist es m√∂glich, zus√§tzliche verborgene Schichten einzuf√ºhren und die Netzwerkaktivierungsfunktion zu √§ndern. Mit diesen √Ñnderungen legen wir den Grundstein f√ºr den Aufbau eines einfachen tiefen neuronalen Netzwerks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wahl der Aktivierungsfunktion ist f√ºr tiefes Lernen sehr wichtig. Die beste Funktion f√ºr eine bestimmte Lernaufgabe wird normalerweise experimentell gefunden und dann von der Gemeinschaft der Forscher f√ºr maschinelles Lernen h√§ufig verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit ist die Aktivierungsfunktion, die als Destillationsfunktion oder Gleichrichter bezeichnet wird, aufgrund ihrer erfolgreichen Anwendung bei komplexen Aufgaben wie der Bilderkennung sehr beliebt geworden. Ein neuronaler Netzwerkknoten, in dem ein Gleichrichter als Aktivierungsfunktion verwendet wird, wird als Rectified Linear Unit (ReLU) bezeichnet. Wie in Abb. In 7.13 wird die Aktivierungsfunktion vom Gleichrichtertyp so beschrieben, dass x zur√ºckgegeben wird, wenn x gr√∂√üer oder gleich 0 ist, und ansonsten 0. Die Bedeutung dieser Funktion besteht darin, dass sie einerseits nicht linear ist und andererseits einfache mathematische Eigenschaften aufweist, die sie rechnerisch kosteng√ºnstig und f√ºr den Gradientenabstieg hocheffizient machen. Leider ist f√ºr x = 0 die Gleichrichterableitung nicht definiert,Daher kann der Gleichrichter nicht in Verbindung mit der Funktion neuralnet () verwendet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen k√∂nnen Sie eine gegl√§ttete Approximation von ReLU verwenden, die als softplus oder SmoothReLU bezeichnet wird, eine Aktivierungsfunktion, die als log (1 + ex) definiert ist. </font><font style="vertical-align: inherit;">Wie in Abb. </font><font style="vertical-align: inherit;">7.13 ist die Softplus-Funktion f√ºr x-Werte kleiner als 0 nahe Null und f√ºr x gr√∂√üer als 0 ungef√§hr gleich x.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Funktion softplus () in R zu definieren, verwenden wir den folgenden Code: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Aktivierungsfunktion kann dem eingegebenen neuralnet () mit dem Parameter act.fct bereitgestellt werden. </font><font style="vertical-align: inherit;">Zus√§tzlich f√ºgen wir eine zweite verborgene Schicht hinzu, die aus f√ºnf Knoten besteht, und weisen dem verborgenen Parameter den Wert des ganzzahligen Vektors c (5, 5) zu. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir ein zweischichtiges Netzwerk, von dem jede f√ºnf Knoten hat und alle die Softplus-Aktivierungsfunktion verwenden:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach wie vor kann das Netzwerk visualisiert werden (Abb. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Korrelation zwischen der vorhergesagten und der tats√§chlichen Festigkeit von Beton kann wie folgt berechnet werden:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Korrelation zwischen der vorhergesagten und der tats√§chlichen St√§rke betrug 0,935, was der bisher beste erhaltene Indikator ist. Interessanterweise berichtete Ye in der Originalver√∂ffentlichung √ºber eine Korrelation von 0,885. Dies bedeutet, dass wir mit relativ geringem Aufwand ein vergleichbares Ergebnis erzielen und sogar die Ergebnisse eines Experten auf diesem Gebiet √ºbertreffen konnten. Die Ergebnisse von Ye wurden zwar 1998 ver√∂ffentlicht, was uns einen Vorsprung auf mehr als 20 Jahre zus√§tzlicher Forschung auf dem Gebiet der neuronalen Netze verschaffte! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres wichtiges Detail sollte ber√ºcksichtigt werden: Da wir die Daten vor dem Training des Modells normalisiert haben, liegen die Vorhersagen auch im normalisierten Intervall von 0 bis 1. Der folgende Code zeigt beispielsweise einen Datenrahmen, der die konkreten Festigkeitswerte aus dem Anfangsdatensatz zeilenweise mit den entsprechenden Vorhersagen vergleicht:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir </font><font style="vertical-align: inherit;">
die Korrelation untersuchen, sehen wir, dass die Auswahl normalisierter oder abnormalisierter Daten keinen Einfluss auf die berechnete Leistungsstatistik hat - genau wie zuvor betr√§gt die Korrelation 0,935: </font><font style="vertical-align: inherit;">Wenn wir jedoch einen anderen Leistungsindikator berechnet haben, beispielsweise die absolute Differenz zwischen den vorhergesagten und den tats√§chlichen Werten, dann Die Wahl des Ma√üstabs w√§re sehr wichtig. </font><font style="vertical-align: inherit;">
In diesem Sinne k√∂nnen Sie die Funktion unnormalize () erstellen, die die Umkehrung der Minimax-Normalisierung ausf√ºhrt und es Ihnen erm√∂glicht, normalisierte Vorhersagen in den urspr√ºnglichen Ma√üstab umzuwandeln:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Anwendung der Funktion unnormalize (), die wir f√ºr Prognosen geschrieben haben, wird deutlich, dass der Ma√üstab der neuen Prognosen den Anfangswerten der Betonfestigkeit √§hnlich ist. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie den aussagekr√§ftigen Wert des absoluten Fehlers berechnen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus bleibt die Korrelation zwischen abnormalen und anf√§nglichen Festigkeitswerten unver√§ndert:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new ‚Äî strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie neuronale Netze auf Ihre Projekte anwenden, m√ºssen Sie eine √§hnliche Abfolge von Schritten ausf√ºhren, um die Daten auf ihren urspr√ºnglichen Ma√üstab zur√ºckzusetzen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√∂glicherweise stellen Sie auch fest, dass neuronale Netze schnell komplexer werden, da sie f√ºr immer schwierigere Lernaufgaben verwendet werden. Beispielsweise k√∂nnen Sie auf das sogenannte "verschwindende" kleine Gradientenproblem und das eng verwandte "explodierende" Gradientenproblem sto√üen, wenn der R√ºckausbreitungsalgorithmus keine n√ºtzliche L√∂sung findet, da er nicht in einer angemessenen Zeit konvergiert. Um diese Probleme zu l√∂sen, k√∂nnen Sie versuchen, die Anzahl der ausgeblendeten Knoten zu √§ndern, verschiedene Aktivierungsfunktionen wie ReLU anzuwenden, die Lerngeschwindigkeit anzupassen usw. Auf der Hilfeseite f√ºr die Neuralnet-Funktion finden Sie zus√§tzliche Informationen zu den verschiedenen Parametern, die konfiguriert werden k√∂nnen. Dies f√ºhrt jedoch zu einem anderen Problem:wenn der Engpass beim Aufbau eines hocheffizienten Modells darin besteht, eine gro√üe Anzahl von Parametern zu √ºberpr√ºfen. Dies ist der Preis f√ºr die Verwendung neuronaler Netze und vor allem f√ºr Deep-Learning-Netze: Ihr gro√ües Potenzial erfordert viel Zeit und Rechenleistung.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die SVM-Methode (Support Vector Machine) kann als Oberfl√§che dargestellt werden, die die Grenze zwischen Datenpunkten bildet, die in einem mehrdimensionalen Raum dargestellt sind und Beispiele und Werte ihrer Attribute beschreiben. Das Ziel von SVM ist es, eine flache Grenze zu bauen - eine Hyperebene, die den Raum so teilt, dass sich auf beiden Seiten homogene Gruppen bilden. Daher kombiniert das SVM-Training Aspekte des Trainings f√ºr den n√§chsten Nachbarn basierend auf den in Kapitel 3 beschriebenen Instanzen und der in Kapitel 6 beschriebenen linearen Regressionsmodellierung. Dies ist eine √§u√üerst leistungsstarke Kombination, mit der SVMs sehr komplexe Beziehungen modellieren k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass die grundlegende Mathematik, die SVM zugrunde liegt, seit Jahrzehnten besteht, hat das Interesse an diesen Methoden erheblich zugenommen, nachdem sie auf ML angewendet wurden. Die Popularit√§t dieser Methoden stieg nach hochkar√§tigen Erfolgsgeschichten bei der L√∂sung komplexer Lernprobleme sowie nach der Entwicklung von SVM-Algorithmen, die in gut unterst√ºtzten Bibliotheken in vielen Programmiersprachen, einschlie√ülich R, vergeben und implementiert wurden. Danach wurden SVM-Methoden von einem breiten Publikum akzeptiert. Andernfalls w√§re es wahrscheinlich unm√∂glich, die komplexe Mathematik anzuwenden, die zur Implementierung von SVM erforderlich ist. Die gute Nachricht ist, dass die Mathematik zwar m√∂glicherweise komplex ist, die Grundkonzepte jedoch gut verstanden werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SVM-Methoden k√∂nnen f√ºr nahezu jede Art von Trainingsaufgabe angepasst werden, einschlie√ülich Klassifizierung und numerischer Vorhersage. </font><font style="vertical-align: inherit;">Viele der wichtigsten Erfolge dieses Algorithmus beziehen sich auf die Mustererkennung. </font><font style="vertical-align: inherit;">Die bekanntesten Anwendungen f√ºr diese Methoden umfassen Folgendes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassifizierung von Daten zur Expression von Microarray-Genen in der Bioinformatik zum Nachweis von Krebs und anderen genetischen Erkrankungen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textkategorisierung, z. B. Bestimmen der in einem Dokument verwendeten Sprache oder Klassifizieren von Dokumenten nach Themen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erkennung seltener, aber wichtiger Ereignisse wie Ausfall eines Verbrennungsmotors, Sicherheitsverletzung oder Erdbeben.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SVM-Methoden sind am einfachsten anhand der bin√§ren Klassifizierung als Beispiel zu verstehen - so werden sie normalerweise verwendet. </font><font style="vertical-align: inherit;">Daher konzentrieren wir uns in den verbleibenden Abschnitten nur auf SVM-Klassifizierer. </font><font style="vertical-align: inherit;">√Ñhnliche Prinzipien wie die hier vorgestellten werden auch bei der Anpassung von SVM-Methoden f√ºr die numerische Vorhersage verwendet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber den Autor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) verwendet seit mehr als einem Jahrzehnt innovative Datenverarbeitungstechniken, um menschliches Verhalten zu untersuchen. </font><font style="vertical-align: inherit;">Als ausgebildeter Soziologe interessierte sich Brett zun√§chst f√ºr maschinelles Lernen, w√§hrend er eine gro√üe Datenbank mit Jugendprofilen in sozialen Netzwerken durchsuchte. </font><font style="vertical-align: inherit;">Brett ist Lehrer bei DataCamp und h√§lt h√§ufig Pr√§sentationen auf Konferenzen und Seminaren zum maschinellen Lernen auf der ganzen Welt. </font><font style="vertical-align: inherit;">Er ist ein bekannter Enthusiast auf dem Gebiet der praktischen Anwendung der Datenwissenschaft im Bereich Sport, unbemannte Fahrzeuge, Fremdsprachen- und Modestudien sowie in vielen anderen Branchen. </font><font style="vertical-align: inherit;">Brett hofft, eines Tages auf dataspelunking.com dar√ºber schreiben zu k√∂nnen, einen Wissensaustausch √ºber das Finden von Mustern in Daten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber Science Editor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - leitender Forscher einer der weltweit gr√∂√üten Gesundheitsorganisationen. Er ist in der Forschung und Entwicklung von Unternehmensl√∂sungen t√§tig, die auf maschinellem Lernen, tiefem Lernen und Verarbeitung nat√ºrlicher Sprachen f√ºr den Einsatz im Gesundheitswesen und in der Versicherung basieren. In seiner vorherigen Position bei Intel nahm er an proaktiven Initiativen auf dem Gebiet der Informationstechnologie teil, die auf Big Data basieren und nat√ºrliche Sprachverarbeitung, tiefes Lernen und traditionelle statistische Methoden verwenden. Bei American Express arbeitete er im Bereich digitales Engagement und Kundenbindung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav ist Autor mehrerer B√ºcher, die von f√ºhrenden Verlagen ver√∂ffentlicht wurden. </font><font style="vertical-align: inherit;">Sein neuestes Buch handelt von der neuesten Transferstudie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav absolvierte das Internationale Institut f√ºr Informationstechnologie in Bangalore und hat einen Master-Abschluss (Honours Degree). </font><font style="vertical-align: inherit;">In diesen seltenen Momenten, in denen er nicht gerade damit besch√§ftigt ist, wissenschaftliche Probleme zu l√∂sen, liest und fotografiert Raghav gerne alles hintereinander. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬ªWeitere Informationen zum Buch finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
f√ºr Khabrozhiteley 25% Rabatt auf den Gutschein - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschinelles Lernen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496242/index.html">Cyberpunk ist bereits da: Sch√ºler lernen bei Minecraft und Sch√ºler machen physische Tests in CS: GO</a></li>
<li><a href="../de496248/index.html">Herausforderungen, kahle K√∂pfe und Wein. Wie wir bei HFLabs Selbstisolation ertragen</a></li>
<li><a href="../de496250/index.html">Wie seltsamer Code verbirgt Fehler? TensorFlow.NET-Analyse</a></li>
<li><a href="../de496252/index.html">Aerodynamisch versetzte Zentrierflugzeuge</a></li>
<li><a href="../de496254/index.html">Wie Rostelecom den Datenverkehr f√§lschlicherweise an Google, AWS, Cloudflare usw. umleitete</a></li>
<li><a href="../de496258/index.html">Online-Holivar: Ein neues Format f√ºr den Erfahrungsaustausch. Diesen Samstag</a></li>
<li><a href="../de496260/index.html">Tipps zur Cybersicherheit f√ºr die Arbeit von zu Hause aus</a></li>
<li><a href="../de496262/index.html">CVE-ID abrufen</a></li>
<li><a href="../de496266/index.html">–ö–æ—Ä–æ–Ω–∞–≤–∏—Ä—É—Å: –º—ã –≤—Å–µ —É–º—Ä—ë–º?</a></li>
<li><a href="../de496268/index.html">Huawei Enterprise Netzwerkprodukte und -l√∂sungen f√ºr Unternehmenskunden im Jahr 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>