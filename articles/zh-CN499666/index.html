<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐂 👨🏻‍🚒 😫 PEP 572（Python 3.8中的赋值表达式） 👵🏿 🤘🏿 📤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha 这次，我们将讨论PEP 572，它讨论赋值表达式。如果您仍然对“：=”运算符表示怀疑，或者不完全了解其使用规则，那么本文适合您。在这里，您会找到许多示例和问题答案：“为什么会这样？” 事实证明，本文尽可能完整，如果您没有时间，请看一下我撰写的部分。在开始时，主要的“主题”是通过分配表达式来进...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572（Python 3.8中的赋值表达式）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha </font><font style="vertical-align: inherit;">这次，我们将讨论PEP 572，它讨论赋值表达式。</font><font style="vertical-align: inherit;">如果您仍然对“：=”运算符表示怀疑，或者不完全了解其使用规则，那么本文适合您。</font><font style="vertical-align: inherit;">在这里，您会找到许多示例和问题答案：“为什么会这样？” </font><font style="vertical-align: inherit;">事实证明，本文尽可能完整，如果您没有时间，请看一下我撰写的部分。</font><font style="vertical-align: inherit;">在开始时，主要的“主题”是通过分配表达式来进行舒适的工作的。</font><font style="vertical-align: inherit;">如果您发现错误，请事先原谅我（将它们写给我，我会解决）。</font><font style="vertical-align: inherit;">开始吧：</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572-赋值表达式</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标题：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作业表达</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;gmail.com上的rosuav&gt;，蒂姆·彼得斯&lt;gmail.com上的tim.peters&gt;，Guido van Rossum &lt;python.org上的guido&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论：</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python.org上的doc-sig</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公认</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建时间：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年2月28日</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python版本：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发表故事：</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年2月28日，2018年3月2日，2018年3月23日，2018年4月4日，2018年4月17日，2018年4月25日，2018年7月9日，2019年8月5日</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准采用标准：</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（使用VPN的时间很长，但是会加载）</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注解</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理由</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法和语义</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施过程中的规格变更</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒绝的选择</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经常异议</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">风格建议</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢谢</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录A：Tim Peters的结论</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录B：生成器的粗糙代码解释器</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录C：范围语义未更改</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版权</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我这边</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注解</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该约定将使用新的符号NAME：= expr讨论表达式内部赋值的可能性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为创新的一部分，已更新了计算字典生成器（词典理解）的过程。这样可以确保在值表达式之前先评估键表达式（这使您可以将键绑定到变量，然后在计算对应于键的值时重用创建的变量）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在讨论此PEP期间，该运算符被非正式地称为“海象运算符”。构造的正式名称为“赋值表达式”（根据PEP：赋值表达式标题），但可以称为“命名表达式”。例如，CPython中的引用实现使用此名称。</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理由</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命名是编程的重要组成部分，它使您可以使用“描述性”名称代替较长的表达式，还可以轻松重用值。</font><font style="vertical-align: inherit;">当前，这只能以指令的形式完成，这使得在生成列表（列表理解）以及其他表达式时此操作不可用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，通过提供用于显示提示和中间结果的工具，对大型表达式的各个部分进行命名可以帮助进行交互式调试。</font><font style="vertical-align: inherit;">由于无法捕获嵌套表达式的结果，您将需要更改源代码，但是使用赋值表达式，您只需要插入一些“名称：=表达式”形式的“标记”。</font><font style="vertical-align: inherit;">这消除了不必要的重构，因此减少了调试期间意外代码更改的可能性（Heisenbugs的常见原因是在调试期间更改代码属性并在生产中意外出现的错误），并且该代码对于其他代码更易理解。给程序员。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实代码的重要性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此PEP的开发过程中，许多人（支持者和批评家）一方面过于关注玩具示例，另一方面过于关注玩具示例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
玩具示例的危险有两个方面：它们过于抽象，以至于不能让人说“哦，这是不可抗拒的”，并且它们也很容易被拒绝，并带有“我永远不会写那个”的字眼。过于复杂的示例的危险在于，它们为批评家建议删除此功能提供了便利的环境（此类人士说：“这太令人困惑了”）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，此类示例很有用：它们有助于阐明预期的语义。因此，我们将在下面给出其中一些。但是，</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令人信服的是</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，示例必须基于</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无需考虑此PEP而编写的</font><b><font style="vertical-align: inherit;">真实</font></b><font style="vertical-align: inherit;">代码。也就是说，该代码是真正有用的应用程序的一部分（没有什么区别：无论大小）。蒂姆·彼得斯（Tim Peters）通过查看他的个人存储库并选择他编写的代码示例为我们提供了很多帮助（如果认为）（使用狂热主义）使用赋值表达式对其进行了重写，那么这样做（在他看来）会更容易理解。他的结论是：当前的更改将对其代码的某些部分进行适度但明显的改进。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真实代码的另一个示例是对程序员如何重视紧凑性的间接观察。 Guido van Rossum检查了Dropbox代码库，发现一些证据表明程序员比使用一些小表达式更喜欢编写更少的代码行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例子：Guido在程序员重复一个子表达式（从而减慢了程序速度）时发现了几个说明性要点，但是节省了额外的代码行。</font><font style="vertical-align: inherit;">例如，代替编写：</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序员首选此选项：</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是另一个示例，表明程序员有时愿意做更多的工作来保持缩进的“先前级别”：</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使pattern1已经匹配，此代码也会计算pattern2（在这种情况下，第二个子条件将永远不会被满足）。</font><font style="vertical-align: inherit;">因此，以下解决方案更有效，但吸引力较小：</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法和语义</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大多数情况下，Python使用任意表达式，您现在可以使用赋值表达式。</font><font style="vertical-align: inherit;">它们的形式为NAME：= expr，其中expr是任何有效的Python表达式，但未加括号的元组除外，而NAME是标识符。</font><font style="vertical-align: inherit;">这样的表达式的值与原始值一致，但另外的效果是将值分配给目标对象：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊情况</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了避免用户之间的歧义或混淆，在很多地方都不允许使用赋值表达式：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“上”级别禁止未用括号括起来的赋值表达式：</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该规则将使程序员更容易在赋值运算符和赋值表达式之间进行选择-不会出现两个选项都相等的句法情况。</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赋值表达式不会引入新的作用域。在大多数情况下，创建变量的范围不需要解释：它将是最新的。如果变量以前使用过非本地或全局关键字，则赋值表达式将对此加以考虑。为此，只有lambda（作为函数的匿名定义）被认为是单独的范围。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一种特殊情况：在列表，集合，字典的生成器中或在“生成器的表达式”本身中发生的赋值表达式（以下统称为“生成器”（理解））将变量绑定到生成器包含的范围，并观察globab修饰符或非全局（如果存在）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种特殊情况的理由是双重的。</font><font style="vertical-align: inherit;">首先，它使我们可以方便地捕获any（）和all（）表达式中的“成员”，例如：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，它提供了一种紧凑的方式来更新生成器中的变量，例如：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，赋值表达式中的变量名称不能与for循环中已在生成器中使用的名称匹配。</font><font style="vertical-align: inherit;">姓氏对于出现它们的生成器来说是本地的。</font><font style="vertical-align: inherit;">如果赋值表达式也引用生成器中的范围，那将是不一致的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，[i：= i + 1 for range in 5（5）]是无效的：for循环确定i对生成器而言是本地的，但“ i：= i + 1”部分坚持认为i是来自外部的变量范围 </font><font style="vertical-align: inherit;">出于相同的原因，以下示例将不起作用：</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管在技术上可以为此类情况指定一致的语义，但是很难确定我们对这种语义的理解方式是否可以在您的实际代码中使用。这就是为什么参考实现可确保此类情况引发SyntaxError而不是根据未定义的行为执行，具体取决于特定的硬件实现。即使从未执行赋值表达式，此限制也适用：</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于生成器主体（第一个关键字“ for”之前的部分）和过滤器表达式（“ if”之后以及任何嵌套的“ for”之前的部分），此限制仅适用于同时用作迭代变量的变量名称。正如我们已经说过的，Lambda表达式引入了函数的新的显式范围，因此可以在生成器的表达式中使用而没有其他限制。 [大约再次，除非在这种情况下：[i代表i在（2，（lambda：（s：= 2）（）））的范围内]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于参考实现中的设计限制（符号表分析器无法识别生成器左侧的名称是否在可迭代表达式所在的其余部分中使用），因此，完全禁止将赋值表达式作为可迭代表达式的一部分（在每个“ in”和“ in”之后的部分中）在任何后续关键字“ if”或“ for”之前）。</font><font style="vertical-align: inherit;">也就是说，所有这些情况都是不可接受的：</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当在类范围内的生成器中使用赋值表达式时，会发生另一个异常。</font><font style="vertical-align: inherit;">如果在使用上述规则时，应该创建在范围内重新测量的类，则这样的赋值表达式无效并且将导致SyntaxError：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（最后一个例外的原因是生成器创建的函数的隐式范围-当前没有函数的运行时机制来引用位于类范围内的变量，因此我们不想添加这种机制。如果解决了此问题，则该特殊情况（可能）将从赋值表达式的规范中删除。请注意，即使您在类的作用域中较早地创建了变量，并尝试使用生成器中的赋值表达式对其进行更改，也会出现此问题。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关示例的示例，请参见附录B。生成器中找到的赋值表达式将转换为等效代码。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相对优先级：=</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在可能的所有句法位置，将= =运算符分组为比逗号强，但比所有其他运算符（包括or，和，非条件条件表达式，A和C，否则为B）弱。如上文“例外情况”部分所述，赋值表达式永远无法在与经典赋值=相同的“级别”下工作。如果需要不同的操作顺序，请使用括号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运算符：=可以在调用函数的位置参数时直接使用。但是，这不能直接在参数中使用。一些示例阐明了技术上允许的和不可能的：</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不建议在实践中使用以上大多数“有效”示例，因为快速扫描您的源代码的人可能无法正确理解其含义。</font><font style="vertical-align: inherit;">但是在简单的情况下，这是允许的：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该PEP建议您</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绝对在以下位置</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加上空格：=，类似于PEP 8对于=的经典分配建议。</font><font style="vertical-align: inherit;">（最后一个建议的区别是它禁止在=周围使用空格，该空格用于将键参数传递给函数。）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改计算顺序。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了具有明确定义的语义，此协议要求明确定义评估过程。</font><font style="vertical-align: inherit;">从技术上讲，这不是新要求。</font><font style="vertical-align: inherit;">Python已经有一个规则，即通常从左到右评估子表达式。</font><font style="vertical-align: inherit;">但是，赋值表达式使这些“副作用”更加明显，我们建议对当前的计算顺序进行一次更改：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在字典生成器{X：Y for ...}中，当前会在X之前评估Y。我们建议更改此值，以便在Y之前计算X。（在经典dict中，例如{X：Y}以及dict （（……的（X，Y））已经实现。因此，字典生成器必须遵守此机制。）</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赋值表达式和赋值指令之间的差异。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最重要的是，“：=”是一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这意味着它可以在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无效的</font><font style="vertical-align: inherit;">情况下</font><b><font style="vertical-align: inherit;">使用</font></b><font style="vertical-align: inherit;">，包括lambda函数和生成器。</font><font style="vertical-align: inherit;">相反，</font><font style="vertical-align: inherit;">赋值</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不支持可在</font><font style="vertical-align: inherit;">赋值</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指令中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用的扩展功能</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不直接支持级联分配</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除简单变量名称NAME之外，不支持单独的“目标”：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能和围绕逗号的优先级有所不同：</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开箱价和装箱价没有``纯''等价物或根本不被支持</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不支持内联类型注释：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有简化的操作形式：</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施过程中的规格变更</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本PEP首次编写之后以及Python 3.8发行之前，根据我们的经验和其他分析进行了以下更改：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确保与其他类似异常的一致性，并且不引入可能对最终用户不方便的新名称，最初建议的SyntaxError的TargetScopeError子类已被删除，并减少为通常的SyntaxError。</font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于解析CPython字符表的限制，赋值表达式的引用实现为迭代器内的所有使用引发SyntaxError。</font><font style="vertical-align: inherit;">以前，仅当要创建的变量的名称与迭代表达式中已使用的名称一致时，才会发生此异常。</font><font style="vertical-align: inherit;">如果有足够有说服力的示例，可以对此进行修订，但是对于纯粹的“假设”用例而言，额外的复杂性似乎不合适。</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python标准库示例</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base仅在条件中使用，因此可以将分配作为逻辑块的“头”放置在其中。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前代码：</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进的代码：</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以避免嵌套的ifs，从而消除一级缩进。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前代码：</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进的代码：</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复制</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码看起来更经典，并且避免了条件语句的多重嵌套。</font><font style="vertical-align: inherit;">（请参阅附录A，以了解有关此示例来源的更多信息。）</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前代码：</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进的代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz仅用于s + = tz。</font><font style="vertical-align: inherit;">向内移动它有助于显示其合理的使用范围。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前代码：</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进的代码：</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在if循环中，在while循环中将fp.readline（）作为“条件”来调用（以及调用.match（）方法），使代码更紧凑，而不会增加对其的理解。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进的代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化列表生成器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，可以通过“捕获”条件来有效地过滤列表生成器：</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，该变量可以在另一个表达式中重用：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请再次注意，在两种情况下，变量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与变量result和stuff的作用域相同。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在条件下获取价值</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赋值表达式可以在if或while语句的条件下有效使用：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尤其是，这种方法可以消除创建无限循环，分配和条件检查的需要。</font><font style="vertical-align: inherit;">它还允许您在使用函数调用作为其条件的循环以及不仅检查条件，还使用将来函数返回的实际值的循环之间绘制平滑的并行关系。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叉子</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UNIX底层世界的一个示例：</font><font style="vertical-align: inherit;">Fork（）是类Unix操作系统上的系统调用，它相对于父级创建一个新的子进程。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒绝的选择</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，类似的建议在python社区中非常普遍。</font><font style="vertical-align: inherit;">下面是赋值表达式的许多替代语法，这些语法太过具体而难以理解，因此已被拒绝使用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改生成器的范围</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此PEP的先前版本中，建议对生成器的作用域规则进行细微更改，以使其更适合在类的作用域中使用。</font><font style="vertical-align: inherit;">但是，这些建议将导致向后不兼容，因此被拒绝。</font><font style="vertical-align: inherit;">因此，该PEP仅能够完全专注于赋值表达式。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替代拼写</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，建议的赋值表达式具有相同的语义，但编写方式不同。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以名称的身份浏览：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这句法不太可能与他人发生冲突比</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（除非你从EXC结构加薪EXC），但在其他方面可以媲美他们。</font><font style="vertical-align: inherit;">该选项不是将expr作为目标的并行：（这可能有用，但也可能造成混淆），该选项根本没有与任何并行的内容，但是令人惊讶的是，它记忆犹新。</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件语句中的特殊情况</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赋值表达式最常见的用例之一是if和while语句。</font><font style="vertical-align: inherit;">代替使用更通用的解决方案，使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过添加一种捕获要比较的值的方式来改进这两个语句的语法：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这可以正常工作，但是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当所需条件基于返回值的“正确性”时才有效。</font><font style="vertical-align: inherit;">因此，此方法在特定情况下有效（检查正则表达式，读取套接字，在执行结束时返回空字符串），在更复杂的情况下（例如，当条件为f（x）&lt;0且您想要保存f（x）的值）。</font><font style="vertical-align: inherit;">同样，这在列表生成器中没有意义。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：没有句法歧义。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：即使仅在if / while语句中使用它，它也仅在某些情况下有效。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发电机的特殊情况</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赋值表达式的另一个常见用例是生成器（列表/集合/字典和genexps）。</font><font style="vertical-align: inherit;">如上所述，针对具体解决方案提出了建议。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在哪里，让，或给定：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此方法在for循环和主表达式之间产生子表达式。</font><font style="vertical-align: inherit;">它还引入了一个附加的语言关键字，该关键字可能会产生冲突。</font><font style="vertical-align: inherit;">在这三个选项中，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最干净，最易读的，但是仍然存在潜在的冲突（例如，SQLAlchemy和numpy拥有其where方法，以及标准库中的tkinter.dnd.Icon）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NAME = EXPR：</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论选择哪种方法，都会通过for循环在生成器及其部署版本之间引入明显的语义差异。</font><font style="vertical-align: inherit;">如果不处理创建变量的阶段，就不可能将循环包装在生成器中。</font><font style="vertical-align: inherit;">可以为此任务重定向的唯一关键字是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但这将在代码的不同部分赋予它不同的语义，这意味着您需要创建一个新的关键字，但这会涉及很多成本。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低操作员优先级</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：=运算符具有两个逻辑优先级。或者它应该具有尽可能低的优先级（与赋值运算符相当）。或者它应该比比较运算符具有更高的优先级。将其优先级放在比较运算符和算术运算之间（准确地说：略低于按位OR）将使您在大多数情况下（如果使用）不使用方括号，因为您更有可能希望保留某对象的值之前如何对其进行比较：</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦find（）返回-1，循环就结束了。</font><font style="vertical-align: inherit;">如果：=与=一样自由地绑定操作数，则find（）的结果将首先被“捕获”到比较运算符中，并且通常将返回True或False，这用处不大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管此行为在许多情况下在实践中会很方便，但将更难以解释。</font><font style="vertical-align: inherit;">因此，我们可以说“运算符：=的行为与通常的赋值运算符相同”。</font><font style="vertical-align: inherit;">也就是说，为：=设置的优先级应尽可能接近运算符=（除了：=的优先级高于逗号）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您在右边加上逗号</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些批评家认为，赋值表达式应在不添加方括号的情况下识别元组，以便使两个条目等效：</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（在标准的当前版本中，最后一条记录将与表达式（（point：= x），y）等效。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在这种情况下，当在函数调用中使用赋值表达式时，它的优先级也比逗号低，这是合乎逻辑的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下是令人困惑的等效项：</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，我们得到了唯一不那么令人困惑的出路：将：=运算符的优先级设置为比逗号低的优先级。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总是需要括号</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一直建议将赋值表达式括起来。</font><font style="vertical-align: inherit;">这将为我们节省许多歧义。</font><font style="vertical-align: inherit;">实际上，通常需要使用括号来提取所需的值。</font><font style="vertical-align: inherit;">但是在以下情况下，括号在我们看来显然是多余的：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经常异议</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么不只将赋值语句转换为表达式？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C和类似语言将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符定义</font><font style="vertical-align: inherit;">为表达式，而不是指令，就像Python一样。</font><font style="vertical-align: inherit;">这允许在许多情况下进行分配，包括比较变量的地方。</font><font style="vertical-align: inherit;">if（x == y）和if（x = y）之间的句法相似之处与它们截然不同的语义相矛盾。</font><font style="vertical-align: inherit;">因此，此PEP引入了运算符：=来阐明它们之间的差异。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果存在</font><font style="vertical-align: inherit;">分配</font><i><font style="vertical-align: inherit;">指令，</font></i><font style="vertical-align: inherit;">为什么还要麻烦</font><font style="vertical-align: inherit;">分配</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这两种形式具有不同的灵活性。</font><font style="vertical-align: inherit;">运算符：=可以在较大的表达式内使用，而在=运算符中，可以由类型“ + =”的“小型运算符族”使用。</font><font style="vertical-align: inherit;">Also =允许您通过属性和索引分配值。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么不使用本地范围并防止名称空间污染？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该标准的先前版本包括一个用于赋值表达式的实际局部范围（仅限于一条语句），可防止名称泄漏和名称空间污染。</font><font style="vertical-align: inherit;">尽管在某些情况下这提供了一定的优势，但在其他情况下却使任务变得复杂，并且现有方法的优势并不能证明其优势。</font><font style="vertical-align: inherit;">这样做是为了简化语言。</font><font style="vertical-align: inherit;">您不再需要此变量？</font><font style="vertical-align: inherit;">有一个解决方案：使用del关键字删除变量，或在其名称下添加一个下划线。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（作者要感谢Guido van Rossum和Christophe Groth提出的朝这个方向发展PEP标准的建议。[2]）</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">风格建议</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于赋值表达式有时可以与赋值运算符同等使用，因此出现了一个问题，哪个仍然是首选？..根据其他样式约定（例如PEP 8），有两个建议：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您可以同时使用两个分配选项，请优先选择运算符。</font><font style="vertical-align: inherit;">他们最清楚地表达了您的意图。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果使用赋值表达式导致执行顺序不明确，请使用经典运算符重写代码。</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢谢</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该标准的作者要感谢Nick Coghlan和Steven D'Aprano对本PEP所做的重要贡献，并感谢Python Core Mentorship成员为实现这一目标所提供的帮助。</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录A：Tim Peters的结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是蒂姆·彼得斯（Tim Peters）撰写的有关该主题的简短文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不喜欢“混淆”的代码，也不喜欢将概念上不相关的逻辑放在一行上。</font><font style="vertical-align: inherit;">因此，例如，代替：</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我更喜欢这样写：</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我想我会找到几个要使用赋值表达式的地方。</font><font style="vertical-align: inherit;">我什至不想谈论它们在已经拉伸到一半屏幕的表达式中的用法。</font><font style="vertical-align: inherit;">在其他情况下，这种行为如下：</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明显优于此：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这两个代码具有完全不同的概念，将它们混合会很疯狂。</font><font style="vertical-align: inherit;">在其他情况下，组合逻辑表达式会使代码的理解复杂化。</font><font style="vertical-align: inherit;">例如，重写：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，我们失去了“逻辑”。</font><font style="vertical-align: inherit;">您需要了解此代码的工作方式。</font><font style="vertical-align: inherit;">我的大脑不想这样做：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是这种情况很少见。</font><font style="vertical-align: inherit;">保存结果的任务非常普遍，“稀疏胜于稠密”并不意味着“几乎空着胜于稀疏”。</font><font style="vertical-align: inherit;">Zen Python的参考]。</font><font style="vertical-align: inherit;">例如，我有许多函数返回None或0表示“我没有任何用处，但是由于这种情况经常发生，因此我不想因异常而困扰您”。</font><font style="vertical-align: inherit;">实际上，这种机制也用在没有匹配项时返回None的正则表达式中。</font><font style="vertical-align: inherit;">因此，在此示例中，有很多代码：</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我发现以下选项更容易理解，当然也更具可读性：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
刚开始我对此并不十分重视，但是如此短的结构经常出现，以至于很快就使我烦恼，以至于我无法使用它。</font><font style="vertical-align: inherit;">这让我感到惊讶！</font><font style="vertical-align: inherit;">[大约 </font><font style="vertical-align: inherit;">显然，这是在Python 3.8正式发布之前编写的。] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在其他情况下，赋值表达式实际上是“错误的”。</font><font style="vertical-align: inherit;">Kirill Balunov不再在我的代码中反复翻腾，而是给出了标准copy.py库中copy（）函数的一个很好的示例：</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不断增加的缩进具有误导性：毕竟，逻辑是平坦的：第一个成功的测试“获胜”：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赋值表达式的简单使用使代码的视觉结构可以强调逻辑的“平面”。</font><font style="vertical-align: inherit;">但是，不断增加的缩进使其隐含。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是代码中的另一个小示例，这使我非常高兴，因为它使我可以将内部相关的逻辑放在一行上，并消除了烦人的“人造”缩进级别。</font><font style="vertical-align: inherit;">这正是我从if语句中获得的结果，它使阅读更加轻松。</font><font style="vertical-align: inherit;">如下代码：</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转换成：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在大多数发生变量赋值的行中，我不会使用赋值表达式。</font><font style="vertical-align: inherit;">但是这种设计是如此频繁，以至于我仍然有很多地方可以利用这个机会。</font><font style="vertical-align: inherit;">在最近的情况下，我经常赢了一点。</font><font style="vertical-align: inherit;">在其余的子部分中，这导致了中等或较大的改进。</font><font style="vertical-align: inherit;">因此，如果使用赋值表达式，则比使用三重表达式要多得多，但比扩展赋值[大约。</font><font style="vertical-align: inherit;">简短选项：* =，/ =，+ =等）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数值例子</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我还有另一个使我印象深刻的例子。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果所有变量都是正整数，并且变量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大于x的第n个根，则此算法返回x的第n个根的“较低”舍入（并使每次迭代的精确位数大约加倍）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原因尚不清楚，但是这种算法的变体要比带有条件分支中断的无限循环（循环半）不那么明显。在不依靠数学陈述（“算术平均值-几何平均值不等式”）并且不了解嵌套舍入函数如何向下行为的一些重要问题上，也很难证明这种实现的正确性。但是这里的问题已经在数学中，而不是编程中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，如果您了解所有这些，那么使用赋值表达式的选项就很容易阅读，就像一个简单的句子：“检查当前的”猜测”，如果它太大，则减小它”，该条件允许您立即从循环条件中保存中间值。我认为经典形式更难理解：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录B：生成器的粗糙代码解释器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本附录试图阐明（尽管未指定）在生成器表达式中创建变量的规则。</font><font style="vertical-align: inherit;">对于许多说明性示例，我们显示了源代码，其中将生成器替换为等效函数并结合了一些“脚手架”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于[x for ...]等同于list（x for ...），因此这些示例不会失去通用性。</font><font style="vertical-align: inherit;">而且，由于这些示例仅旨在阐明一般规则，因此它们并不声称是现实的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：现在，通过创建嵌套的生成器函数（类似于本附录中给出的函数）来实现生成器。</font><font style="vertical-align: inherit;">这些示例显示了新的部分，该部分添加了适当的功能来处理赋值表达式的范围（这种范围就好像赋值是在包含最外部生成器的块中执行的一样）。</font><font style="vertical-align: inherit;">为了简化“类型推断”，这些说明性示例未考虑赋值表达式是可选的（但它们考虑了在生成器内部创建的变量的范围）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们首先回想一下没有赋值表达式的生成器“在幕后”生成的代码：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码（EXPR最常使用VAR变量）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换后的代码（不用担心名称冲突）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们添加一个简单的赋值表达式。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换后的代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们将全局TARGET语句添加到f（）函数的声明中。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换后的代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反之亦然，让我们将非本地TARGET添加到f（）函数的声明中。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换后的代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，让我们放入两个生成器。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换后的代码：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录C：范围语义未更改</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，在Python中，作用域语义没有改变。</font><font style="vertical-align: inherit;">局部函数的范围仍在编译时确定，并且在运行时（关闭）具有不确定的时间范围。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念验证的实施</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论赋值表达式的语义</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（VPN严格但已加载）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对PEP 572中TargetScopeError的讨论</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（与上一个类似地加载）</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版权</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该文档已公开发布。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
资料来源：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我这边</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们总结一下：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了避免</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人们试图</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除语义对偶性，在很多可以同时使用“ =”和“：=”的“经典”地方，都有一些限制，因此运算符:: =必须经常放在方括号中。</font><font style="vertical-align: inherit;">这些情况将必须在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">描述基本用法</font></a><font style="vertical-align: inherit;">的部分中进行审查</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赋值表达式的优先级略高于逗号。</font><font style="vertical-align: inherit;">因此，在分配过程中不会形成元组。</font><font style="vertical-align: inherit;">将参数传递给函数时，还可以使用：=运算符。</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我想说我喜欢新的运算符。</font><font style="vertical-align: inherit;">它使您可以在条件，“过滤器”列表中编写更扁平的代码，并（最终）在if之前删除“相同”的孤独行。</font><font style="vertical-align: inherit;">如果人们将赋值表达式用于其预期目的，那么这将是一个非常方便的工具，它将增加代码的可读性和美观性（尽管对于任何功能语言来说都可以这么说……）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499654/index.html">如何在远程站点上实施CRM并获胜？</a></li>
<li><a href="../zh-CN499656/index.html">PID温度控制器仿真</a></li>
<li><a href="../zh-CN499658/index.html">用人工代替测试员？在2020年研究硒是否值得？</a></li>
<li><a href="../zh-CN499662/index.html">物联网和其他物联网安全趋势的信任根</a></li>
<li><a href="../zh-CN499664/index.html">将API移植到TypeScript作为问题解决者</a></li>
<li><a href="../zh-CN499668/index.html">地狱JavaScript依赖之路</a></li>
<li><a href="../zh-CN499670/index.html">Я перехожу на JavaScript</a></li>
<li><a href="../zh-CN499674/index.html">光学计算机的又一步</a></li>
<li><a href="../zh-CN499676/index.html">适用于Kubernetes的90多种有用工具：部署，管理，监控，安全等</a></li>
<li><a href="../zh-CN499680/index.html">学习Kubernetes：基础5月14日至16日，高级5月18日至20日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>