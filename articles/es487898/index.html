<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 👂 💪 Medición de ancho de banda de memoria en la rodilla 👨‍🎓 👩🏾‍🎨 👔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unas semanas, en una conversación durante la cena, un colega se quejó de algún tipo de proceso lento. Calculó la cantidad de bytes generados, la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Medición de ancho de banda de memoria en la rodilla</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hace unas semanas, en una conversación durante la cena, un colega se quejó de algún tipo de proceso lento. Calculó la cantidad de bytes generados, la cantidad de ciclos de procesamiento y, en última instancia, la cantidad de RAM. Un colega dijo que una GPU moderna con un ancho de banda de memoria de más de 500 GB / s consumiría su tarea y no se ahogaría. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me pareció que este es un enfoque interesante. Personalmente, no he evaluado previamente los objetivos de rendimiento desde esta perspectiva. Sí, sé sobre la diferencia en el rendimiento del procesador y la memoria. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sé cómo escribir código que hace un uso intensivo del caché. Sé las cifras aproximadas de retraso. Pero esto no es suficiente para evaluar de inmediato el ancho de banda de la memoria.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un experimento mental. </font><font style="vertical-align: inherit;">Imagine en la memoria una matriz continua de mil millones de enteros de 32 bits. </font><font style="vertical-align: inherit;">Esto es de 4 gigabytes. </font><font style="vertical-align: inherit;">¿Cuánto tiempo llevará iterar sobre esta matriz y sumar los valores? </font><font style="vertical-align: inherit;">¿Cuántos bytes por segundo puede leer la CPU de la RAM? </font><font style="vertical-align: inherit;">¿Datos continuos? </font><font style="vertical-align: inherit;">¿Acceso aleatorio? </font><font style="vertical-align: inherit;">¿Qué tan bien se puede paralelizar este proceso? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dirás que estas son preguntas inútiles. </font><font style="vertical-align: inherit;">Los programas reales son demasiado complejos para hacer un hito tan ingenuo. </font><font style="vertical-align: inherit;">¡Y ahí está! </font><font style="vertical-align: inherit;">La verdadera respuesta es "dependiendo de la situación". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, creo que vale la pena explorar este tema. </font><font style="vertical-align: inherit;">No estoy tratando de encontrar la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">respuesta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero creo que podemos definir algunos límites superiores e inferiores, algunos puntos interesantes en el medio y aprender algo en el proceso.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los números que todo programador debe saber</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si lees blogs de programación, probablemente encuentres "números que todo programador debería saber". </font><font style="vertical-align: inherit;">Se ven algo así:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace a caché L1 0.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Predicción incorrecta de 5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a caché L2 7 ns 14x a caché L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex Capture / Release 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a memoria principal 100 ns 20x a caché L2, 200x a caché L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprima 1000 bytes con Zippy 3000 ns 3 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envío de 1000 bytes a través de una red de 1 Gbps 10,000 ns 10 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lectura aleatoria 4000 con SSD 150,000 ns 150 μs ~ 1GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea 1 MB secuencialmente de 250,000 ns 250 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paquete de ida y vuelta dentro del centro de datos 500,000 ns 500 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 MB de lectura secuencial en SSD 1,000,000 ns 1,000 μs 1 ms ~ 1 GB / s SSD, 4x memoria</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Búsqueda de disco 10,000,000 ns 10,000 μs 10 ms 20x al centro de datos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea 1 MB secuencialmente desde el disco 20,000,000 ns 20,000 μs 20 ms 80x en memoria, 20x en SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envío de paquetes CA-&gt; Países Bajos-&gt; CA 150,000,000 ns 150,000 μs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Gran lista. </font><font style="vertical-align: inherit;">Aparece en HackerNews al menos una vez al año. </font><font style="vertical-align: inherit;">Todo programador debe saber estos números. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero estos números son sobre otra cosa. </font><font style="vertical-align: inherit;">La latencia y el ancho de banda no son lo mismo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retraso en 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esa lista fue compilada en 2012, y este artículo de 2020, los tiempos han cambiado. </font><font style="vertical-align: inherit;">Estos son los números de Intel i7 con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hit en caché L1, ~ 4 ciclos (2.1 - 1.2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit en el caché L2, ~ 10 ciclos (5.3 - 3.0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit en el caché L3, para un solo núcleo ~ 40 ciclos (21.4 - 12.0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit en caché L3, juntos por otro kernel ~ 65 ciclos (34.8 - 19.5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Golpee el caché L3, con un cambio para otro kernel ~ 75 ciclos (40.2 - 22.5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM local ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Interesante! </font><font style="vertical-align: inherit;">¿Qué cambió?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 se ha vuelto más lento; </font></font><code>0,5 → 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 más rápido; </font></font><code>7 → 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La relación de L1 y L2 se reduce mucho; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(¡Guau!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El caché L3 ahora se ha convertido en el estándar; </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM se ha vuelto más rápido; </font></font><code>100 → 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No sacaremos conclusiones de largo alcance. </font><font style="vertical-align: inherit;">No está claro cómo se calcularon los números originales. </font><font style="vertical-align: inherit;">No compararemos manzanas con naranjas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay algunas cifras de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre el ancho de banda y el tamaño de caché de mi procesador.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ancho de banda de memoria: 39,74 gigabytes por segundo</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caché L1: 192 kilobytes (32 KB por núcleo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caché L2: 1.5 megabytes (256 KB por núcleo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caché L3: 12 megabytes (compartido; 2 MB por núcleo)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qué quiero saber:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Límite superior de rendimiento de RAM</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">límite inferior</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Límites de caché L1 / L2 / L3</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarking ingenuo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hagamos algunas pruebas. </font><font style="vertical-align: inherit;">Para medir el ancho de banda, escribí un programa simple de C ++. </font><font style="vertical-align: inherit;">Muy aproximadamente ella se ve así.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se omiten algunos detalles. Pero entendiste la idea. Crea una gran variedad continua de elementos. Divida la matriz en fragmentos separados. Procese cada fragmento en un hilo separado. Acumular resultados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También necesita medir el acceso aleatorio. Es muy difícil. Lo intenté de varias maneras, finalmente decidí mezclar índices precalculados. Cada índice existe exactamente una vez. Luego, el bucle interno itera sobre los índices y los cálculos </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al calcular el rendimiento, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> considero la memoria de la matriz de índice. </font><font style="vertical-align: inherit;">Solo se cuentan los bytes que contribuyen al total </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No comparo mi hardware, pero evalúo la capacidad de trabajar con conjuntos de datos de diferentes tamaños y con diferentes esquemas de acceso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizaremos pruebas con tres tipos de datos: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el entero principal de 32 bits </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- contiene </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">cabe en una línea de caché de 64 bytes </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: utiliza herramientas integradas</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gran cuadra</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi primera prueba funciona con un gran bloque de memoria. Un bloque de </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos </font><font style="vertical-align: inherit;">de 1 GB </font><font style="vertical-align: inherit;">se resalta y se llena con pequeños valores aleatorios. Un bucle simple itera sobre una matriz N veces, por lo que accede a la memoria con un volumen </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular la suma </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Varios subprocesos dividen la matriz, y cada uno tiene acceso al mismo número de elementos. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TA-dah! En este gráfico, tomamos el tiempo de ejecución promedio de la operación de suma y lo convertimos de </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muy buen resultado. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede leer secuencialmente 11 GB / s en una sola secuencia. Se escala linealmente hasta que alcanza 38 GB / s. Pruebas </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más rápido, pero descansa contra el mismo techo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe un límite claro y obvio sobre la cantidad de datos que podemos leer de la RAM por segundo. </font><font style="vertical-align: inherit;">En mi sistema, esto es aproximadamente 40 GB / s. </font><font style="vertical-align: inherit;">Esto cumple con las especificaciones actuales enumeradas anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A juzgar por los tres gráficos inferiores, el acceso aleatorio es lento. </font><font style="vertical-align: inherit;">Muy, muy lento. </font><font style="vertical-align: inherit;">El rendimiento de </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un </font><font style="vertical-align: inherit;">solo subproceso </font><font style="vertical-align: inherit;">es insignificante 0.46 GB / s. </font><font style="vertical-align: inherit;">¡Esto es 24 veces más lento que el apilamiento secuencial a 11.03 GB / s! </font><font style="vertical-align: inherit;">La prueba </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra el mejor resultado, porque se ejecuta en líneas de caché completas. </font><font style="vertical-align: inherit;">Pero sigue siendo de cuatro a siete veces más lento que el acceso secuencial y alcanza un máximo de solo 8 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloque pequeño: lectura secuencial</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mi sistema, el tamaño de caché L1 / L2 / L3 para cada transmisión es de 32 KB, 256 KB y 2 MB. ¿Qué sucede si tomas un bloque de elementos de 32 kilobytes y lo repites 125,000 veces? Esto es 4 GB de memoria, pero siempre iremos al caché. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Increíble! El rendimiento de subproceso único es similar a la lectura de un bloque grande, aproximadamente 12 GB / s. Excepto que esta vez, el multihilo rompe el techo de 40 GB / s. Que tiene sentido. Los datos permanecen en la memoria caché, por lo que el cuello de botella de RAM no aparece. Para los datos que no cabían en el caché L3, se aplica el mismo límite máximo de aproximadamente 38 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prueba </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra resultados similares al circuito, pero aún más rápido; 31 GB / s en modo de subproceso único, 171 GB / s en modo de subproceso múltiple. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora echemos un vistazo </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Presta atención al eje y.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizado excepcionalmente rápido. </font><font style="vertical-align: inherit;">Es 10 veces más rápido que </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¡En un bloque de 16 KB, incluso rompe 1000 GB / s! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, esta es una prueba de superficie sintética. </font><font style="vertical-align: inherit;">La mayoría de las aplicaciones no realizan la misma operación con los mismos datos un millón de veces seguidas. </font><font style="vertical-align: inherit;">La prueba no muestra el rendimiento en el mundo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero la lección es clara. </font><font style="vertical-align: inherit;">Dentro del caché, los datos se procesan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rápidamente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Con un techo muy alto cuando se usa SIMD: más de 100 GB / s en modo de subproceso único, más de 1000 GB / s en subproceso múltiple. </font><font style="vertical-align: inherit;">Escribir datos en el caché es lento y tiene un límite estricto de aproximadamente 40 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloque pequeño: lectura aleatoria</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hagamos lo mismo, pero ahora con acceso aleatorio. </font><font style="vertical-align: inherit;">Esta es mi parte favorita del artículo. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lectura de valores aleatorios de la RAM es lenta, solo 0.46 GB / s. </font><font style="vertical-align: inherit;">Leer valores aleatorios del caché L1 es muy rápido: 13 GB / s. </font><font style="vertical-align: inherit;">Esto es más rápido que leer datos en serie </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la RAM (11 GB / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prueba </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra un resultado similar para la misma plantilla, pero aproximadamente el doble de rápido que </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El acceso aleatorio es </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">increíblemente rápido.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de acceso aleatorio</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lectura libre de la memoria es lenta. </font><font style="vertical-align: inherit;">Catastróficamente lento. </font><font style="vertical-align: inherit;">Menos de 1 GB / s para ambos casos de prueba </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al mismo tiempo, las lecturas aleatorias del caché son sorprendentemente rápidas. </font><font style="vertical-align: inherit;">Es comparable a la </font><font style="vertical-align: inherit;">lectura </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secuencial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesita ser digerido. </font><font style="vertical-align: inherit;">El acceso aleatorio al caché es comparable en velocidad al acceso secuencial a la RAM. </font><font style="vertical-align: inherit;">La caída de L1 16 KB a L2 256 KB es solo la mitad o menos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que esto tendrá profundas consecuencias.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las listas enlazadas se consideran dañinas.</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perseguir un puntero (saltar sobre punteros) es malo. </font><font style="vertical-align: inherit;">Muy muy mal. </font><font style="vertical-align: inherit;">¿Cuánto está disminuyendo el rendimiento? </font><font style="vertical-align: inherit;">Ver por ti mismo. </font><font style="vertical-align: inherit;">Hice una prueba adicional que se envuelve </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada acceso pasa por un puntero. </font><font style="vertical-align: inherit;">Aquí hay un resultado terrible, simplemente catastrófico.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 hilo | </font><font style="vertical-align: inherit;">matriz4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Seq | </font><font style="vertical-align: inherit;">14,8 GB / s | </font><font style="vertical-align: inherit;">0.8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">31,6 GB / s | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">22,2 GB / s | </font><font style="vertical-align: inherit;">1,9 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Rand | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">0.1 GB / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">23,2 GB / s | </font><font style="vertical-align: inherit;">1,7 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">15,2 GB / s | </font><font style="vertical-align: inherit;">0.8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 hilos | </font><font style="vertical-align: inherit;">matriz4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Seq | </font><font style="vertical-align: inherit;">34,4 GB / s | </font><font style="vertical-align: inherit;">2.5 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">154,8 GB / s | </font><font style="vertical-align: inherit;">8.0 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">111,6 GB / s | </font><font style="vertical-align: inherit;">5,7 GB / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Rand | </font><font style="vertical-align: inherit;">7,1 GB / s | </font><font style="vertical-align: inherit;">0.4 GB / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">95.0 GB / s | </font><font style="vertical-align: inherit;">7.8 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">58,3 GB / s | </font><font style="vertical-align: inherit;">1,6 GB / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La suma secuencial de los valores detrás del puntero se realiza a una velocidad de menos de 1 GB / s. </font><font style="vertical-align: inherit;">La velocidad de acceso aleatorio de doble salto del caché es de solo 0.1 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persiguiendo un puntero ralentiza la ejecución del código 10-20 veces. </font><font style="vertical-align: inherit;">No dejes que tus amigos usen listas vinculadas. </font><font style="vertical-align: inherit;">Por favor, piense en el caché.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimación de presupuesto para marcos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es común que los desarrolladores de juegos establezcan un límite (presupuesto) para la carga en la CPU y la cantidad de memoria. Pero nunca he visto un presupuesto de ancho de banda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los juegos modernos, FPS continúa creciendo. Ahora está a 60 FPS. VR opera a una frecuencia de 90 Hz. Tengo un monitor de juego de 144 Hz. Es increíble, por lo que el 60 FPS parece una mierda. Nunca volveré al viejo monitor. Esports y streamers Twitch monitorea 240 Hz. Este año, Asus presentó un monstruo de 360 ​​Hz en el CES. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi procesador tiene un límite superior de aproximadamente 40 GB / s. ¡Eso parece un gran número! Sin embargo, a una frecuencia de 240 Hz, solo se obtienen 167 MB por cuadro. Una aplicación realista puede generar 5 GB / s de tráfico a 144 Hz, que es solo 69 MB por cuadro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay una tabla con algunos números.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        El | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 </font><font style="vertical-align: inherit;">60 </font><font style="vertical-align: inherit;">90 </font><font style="vertical-align: inherit;">144 </font><font style="vertical-align: inherit;">240 </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB / s | </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1.3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB / s | </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB / s | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me parece que es útil evaluar los problemas desde esta perspectiva. </font><font style="vertical-align: inherit;">Esto deja en claro que algunas ideas no son factibles. </font><font style="vertical-align: inherit;">Alcanzar 240 Hz no es fácil. </font><font style="vertical-align: inherit;">Esto no sucederá por sí solo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los números que todo programador debe saber (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lista anterior está desactualizada. </font><font style="vertical-align: inherit;">Ahora debe actualizarse y ponerse en conformidad para 2020. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay algunos números para la computadora de mi casa. </font><font style="vertical-align: inherit;">Esta es una mezcla de AIDA64, Sandra y mis puntos de referencia. </font><font style="vertical-align: inherit;">Las figuras no dan una imagen completa y son solo un punto de partida.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latencia L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retardo L2: 2.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retardo L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Latencia RAM: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(por hilo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L1: 210 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L2: 80 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L3: 60 GB / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(sistema completo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda RAM: 45 GB / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sería bueno crear un punto de referencia de código abierto pequeño y simple. </font><font style="vertical-align: inherit;">Algunos archivos C que se pueden ejecutar en computadoras de escritorio, servidores, dispositivos móviles, consolas, etc. Pero no soy el tipo de persona que escribe dicha herramienta.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denegación de responsabilidad</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Medir el ancho de banda de la memoria es difícil. </font><font style="vertical-align: inherit;">Muy dificil. </font><font style="vertical-align: inherit;">Probablemente hay errores en mi código. </font><font style="vertical-align: inherit;">Muchos factores no contabilizados. </font><font style="vertical-align: inherit;">Si tiene alguna crítica a mi técnica, probablemente tenga razón. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En definitiva, creo que esto es normal. </font><font style="vertical-align: inherit;">Este artículo no trata sobre el rendimiento exacto de mi escritorio. </font><font style="vertical-align: inherit;">Esta es una declaración del problema desde cierto punto de vista. </font><font style="vertical-align: inherit;">Y sobre cómo aprender a hacer algunos cálculos matemáticos aproximados.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un colega compartió conmigo una opinión interesante sobre el ancho de banda de la memoria de la GPU y el rendimiento de la aplicación. </font><font style="vertical-align: inherit;">Esto me llevó a estudiar el rendimiento de la memoria en las computadoras modernas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cálculos aproximados, aquí hay algunos números para un escritorio moderno:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento RAM</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Máximo: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En promedio, aproximadamente: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mínimo: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento de caché L1 / L2 / L3 (por núcleo)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Máximo (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En promedio, aproximadamente: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mínimo: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las clasificaciones de muestra están relacionadas con el rendimiento </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El código real nunca será tan simple. </font><font style="vertical-align: inherit;">Pero para los cálculos en una servilleta, este es un punto de partida razonable. </font><font style="vertical-align: inherit;">Debe ajustar esta cifra en función de los patrones de acceso a la memoria en su programa, las características de su equipo y el código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, lo más importante es una nueva forma de pensar sobre los problemas. </font><font style="vertical-align: inherit;">Presentar el problema en bytes por segundo o bytes por cuadro es otra lente para mirar. </font><font style="vertical-align: inherit;">Esta es una herramienta útil por si acaso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias por leer.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Más investigación</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artículo solo tocó ligeramente el tema. </font><font style="vertical-align: inherit;">Probablemente no voy a entrar en eso. </font><font style="vertical-align: inherit;">Pero si lo hiciera, entonces podría cubrir algunos de los siguientes aspectos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabación de rendimiento</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intercambio falso</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(o falta del mismo)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contadores de rendimiento</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento TLB</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos de caché</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especificaciones del Sistema</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pruebas se realizaron en la PC de mi casa. </font><font style="vertical-align: inherit;">Solo configuraciones de stock, sin overclocking.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SO: Windows 10 v1903 compilación 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU: Intel i7-8700k @ 3.70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 @ 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placa base: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es487884/index.html">5 cosas que me gustaría saber antes de desarrollar el intercambio</a></li>
<li><a href="../es487888/index.html">CSRF en Umbraco CMS</a></li>
<li><a href="../es487890/index.html">Traducir voz a texto en iOS usando el marco de voz</a></li>
<li><a href="../es487894/index.html">BarsUP.AM: cómo desarrollamos una herramienta para proteger la información de las aplicaciones web</a></li>
<li><a href="../es487896/index.html">Cuando la muerte se convierte en arte: epitafios de personajes famosos con un profundo significado en inglés</a></li>
<li><a href="../es487900/index.html">pyqtdeploy, o empaquetamos el programa Python en exe'shnik ... de la manera difícil</a></li>
<li><a href="../es487902/index.html">De fuego a fuego: electrolito refractario de estado sólido para baterías de iones de litio</a></li>
<li><a href="../es487906/index.html">El libro "Redes informáticas. Principios, tecnologías, protocolos: edición de aniversario »</a></li>
<li><a href="../es487908/index.html">El comienzo de la guerra de los procesos tecnológicos: 5 nm y 3 nm.</a></li>
<li><a href="../es487910/index.html">Leyes naturales y matemáticas elegantes: problemas y soluciones.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>