<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèø üëÇ üí™ Medici√≥n de ancho de banda de memoria en la rodilla üë®‚Äçüéì üë©üèæ‚Äçüé® üëî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unas semanas, en una conversaci√≥n durante la cena, un colega se quej√≥ de alg√∫n tipo de proceso lento. Calcul√≥ la cantidad de bytes generados, la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Medici√≥n de ancho de banda de memoria en la rodilla</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hace unas semanas, en una conversaci√≥n durante la cena, un colega se quej√≥ de alg√∫n tipo de proceso lento. Calcul√≥ la cantidad de bytes generados, la cantidad de ciclos de procesamiento y, en √∫ltima instancia, la cantidad de RAM. Un colega dijo que una GPU moderna con un ancho de banda de memoria de m√°s de 500 GB / s consumir√≠a su tarea y no se ahogar√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me pareci√≥ que este es un enfoque interesante. Personalmente, no he evaluado previamente los objetivos de rendimiento desde esta perspectiva. S√≠, s√© sobre la diferencia en el rendimiento del procesador y la memoria. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√© c√≥mo escribir c√≥digo que hace un uso intensivo del cach√©. S√© las cifras aproximadas de retraso. Pero esto no es suficiente para evaluar de inmediato el ancho de banda de la memoria.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ hay un experimento mental. </font><font style="vertical-align: inherit;">Imagine en la memoria una matriz continua de mil millones de enteros de 32 bits. </font><font style="vertical-align: inherit;">Esto es de 4 gigabytes. </font><font style="vertical-align: inherit;">¬øCu√°nto tiempo llevar√° iterar sobre esta matriz y sumar los valores? </font><font style="vertical-align: inherit;">¬øCu√°ntos bytes por segundo puede leer la CPU de la RAM? </font><font style="vertical-align: inherit;">¬øDatos continuos? </font><font style="vertical-align: inherit;">¬øAcceso aleatorio? </font><font style="vertical-align: inherit;">¬øQu√© tan bien se puede paralelizar este proceso? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dir√°s que estas son preguntas in√∫tiles. </font><font style="vertical-align: inherit;">Los programas reales son demasiado complejos para hacer un hito tan ingenuo. </font><font style="vertical-align: inherit;">¬°Y ah√≠ est√°! </font><font style="vertical-align: inherit;">La verdadera respuesta es "dependiendo de la situaci√≥n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, creo que vale la pena explorar este tema. </font><font style="vertical-align: inherit;">No estoy tratando de encontrar la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">respuesta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero creo que podemos definir algunos l√≠mites superiores e inferiores, algunos puntos interesantes en el medio y aprender algo en el proceso.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los n√∫meros que todo programador debe saber</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si lees blogs de programaci√≥n, probablemente encuentres "n√∫meros que todo programador deber√≠a saber". </font><font style="vertical-align: inherit;">Se ven algo as√≠:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace a cach√© L1 0.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Predicci√≥n incorrecta de 5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a cach√© L2 7 ns 14x a cach√© L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex Capture / Release 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a memoria principal 100 ns 20x a cach√© L2, 200x a cach√© L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprima 1000 bytes con Zippy 3000 ns 3 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Env√≠o de 1000 bytes a trav√©s de una red de 1 Gbps 10,000 ns 10 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lectura aleatoria 4000 con SSD 150,000 ns 150 Œºs ~ 1GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea 1 MB secuencialmente de 250,000 ns 250 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paquete de ida y vuelta dentro del centro de datos 500,000 ns 500 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 MB de lectura secuencial en SSD 1,000,000 ns 1,000 Œºs 1 ms ~ 1 GB / s SSD, 4x memoria</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B√∫squeda de disco 10,000,000 ns 10,000 Œºs 10 ms 20x al centro de datos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea 1 MB secuencialmente desde el disco 20,000,000 ns 20,000 Œºs 20 ms 80x en memoria, 20x en SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Env√≠o de paquetes CA-&gt; Pa√≠ses Bajos-&gt; CA 150,000,000 ns 150,000 Œºs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Gran lista. </font><font style="vertical-align: inherit;">Aparece en HackerNews al menos una vez al a√±o. </font><font style="vertical-align: inherit;">Todo programador debe saber estos n√∫meros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero estos n√∫meros son sobre otra cosa. </font><font style="vertical-align: inherit;">La latencia y el ancho de banda no son lo mismo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retraso en 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esa lista fue compilada en 2012, y este art√≠culo de 2020, los tiempos han cambiado. </font><font style="vertical-align: inherit;">Estos son los n√∫meros de Intel i7 con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hit en cach√© L1, ~ 4 ciclos (2.1 - 1.2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit en el cach√© L2, ~ 10 ciclos (5.3 - 3.0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit en el cach√© L3, para un solo n√∫cleo ~ 40 ciclos (21.4 - 12.0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit en cach√© L3, juntos por otro kernel ~ 65 ciclos (34.8 - 19.5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Golpee el cach√© L3, con un cambio para otro kernel ~ 75 ciclos (40.2 - 22.5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM local ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Interesante! </font><font style="vertical-align: inherit;">¬øQu√© cambi√≥?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 se ha vuelto m√°s lento; </font></font><code>0,5 ‚Üí 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 m√°s r√°pido; </font></font><code>7 ‚Üí 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La relaci√≥n de L1 y L2 se reduce mucho; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(¬°Guau!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cach√© L3 ahora se ha convertido en el est√°ndar; </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM se ha vuelto m√°s r√°pido; </font></font><code>100 ‚Üí 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No sacaremos conclusiones de largo alcance. </font><font style="vertical-align: inherit;">No est√° claro c√≥mo se calcularon los n√∫meros originales. </font><font style="vertical-align: inherit;">No compararemos manzanas con naranjas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ hay algunas cifras de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre el ancho de banda y el tama√±o de cach√© de mi procesador.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ancho de banda de memoria: 39,74 gigabytes por segundo</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cach√© L1: 192 kilobytes (32 KB por n√∫cleo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cach√© L2: 1.5 megabytes (256 KB por n√∫cleo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cach√© L3: 12 megabytes (compartido; 2 MB por n√∫cleo)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu√© quiero saber:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√≠mite superior de rendimiento de RAM</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≠mite inferior</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√≠mites de cach√© L1 / L2 / L3</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarking ingenuo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hagamos algunas pruebas. </font><font style="vertical-align: inherit;">Para medir el ancho de banda, escrib√≠ un programa simple de C ++. </font><font style="vertical-align: inherit;">Muy aproximadamente ella se ve as√≠.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se omiten algunos detalles. Pero entendiste la idea. Crea una gran variedad continua de elementos. Divida la matriz en fragmentos separados. Procese cada fragmento en un hilo separado. Acumular resultados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n necesita medir el acceso aleatorio. Es muy dif√≠cil. Lo intent√© de varias maneras, finalmente decid√≠ mezclar √≠ndices precalculados. Cada √≠ndice existe exactamente una vez. Luego, el bucle interno itera sobre los √≠ndices y los c√°lculos </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al calcular el rendimiento, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> considero la memoria de la matriz de √≠ndice. </font><font style="vertical-align: inherit;">Solo se cuentan los bytes que contribuyen al total </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No comparo mi hardware, pero eval√∫o la capacidad de trabajar con conjuntos de datos de diferentes tama√±os y con diferentes esquemas de acceso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizaremos pruebas con tres tipos de datos: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el entero principal de 32 bits </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- contiene </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">cabe en una l√≠nea de cach√© de 64 bytes </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: utiliza herramientas integradas</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gran cuadra</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi primera prueba funciona con un gran bloque de memoria. Un bloque de </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos </font><font style="vertical-align: inherit;">de 1 GB </font><font style="vertical-align: inherit;">se resalta y se llena con peque√±os valores aleatorios. Un bucle simple itera sobre una matriz N veces, por lo que accede a la memoria con un volumen </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular la suma </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Varios subprocesos dividen la matriz, y cada uno tiene acceso al mismo n√∫mero de elementos. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TA-dah! En este gr√°fico, tomamos el tiempo de ejecuci√≥n promedio de la operaci√≥n de suma y lo convertimos de </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muy buen resultado. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede leer secuencialmente 11 GB / s en una sola secuencia. Se escala linealmente hasta que alcanza 38 GB / s. Pruebas </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s r√°pido, pero descansa contra el mismo techo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe un l√≠mite claro y obvio sobre la cantidad de datos que podemos leer de la RAM por segundo. </font><font style="vertical-align: inherit;">En mi sistema, esto es aproximadamente 40 GB / s. </font><font style="vertical-align: inherit;">Esto cumple con las especificaciones actuales enumeradas anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A juzgar por los tres gr√°ficos inferiores, el acceso aleatorio es lento. </font><font style="vertical-align: inherit;">Muy, muy lento. </font><font style="vertical-align: inherit;">El rendimiento de </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un </font><font style="vertical-align: inherit;">solo subproceso </font><font style="vertical-align: inherit;">es insignificante 0.46 GB / s. </font><font style="vertical-align: inherit;">¬°Esto es 24 veces m√°s lento que el apilamiento secuencial a 11.03 GB / s! </font><font style="vertical-align: inherit;">La prueba </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra el mejor resultado, porque se ejecuta en l√≠neas de cach√© completas. </font><font style="vertical-align: inherit;">Pero sigue siendo de cuatro a siete veces m√°s lento que el acceso secuencial y alcanza un m√°ximo de solo 8 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloque peque√±o: lectura secuencial</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mi sistema, el tama√±o de cach√© L1 / L2 / L3 para cada transmisi√≥n es de 32 KB, 256 KB y 2 MB. ¬øQu√© sucede si tomas un bloque de elementos de 32 kilobytes y lo repites 125,000 veces? Esto es 4 GB de memoria, pero siempre iremos al cach√©. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Incre√≠ble! El rendimiento de subproceso √∫nico es similar a la lectura de un bloque grande, aproximadamente 12 GB / s. Excepto que esta vez, el multihilo rompe el techo de 40 GB / s. Que tiene sentido. Los datos permanecen en la memoria cach√©, por lo que el cuello de botella de RAM no aparece. Para los datos que no cab√≠an en el cach√© L3, se aplica el mismo l√≠mite m√°ximo de aproximadamente 38 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prueba </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra resultados similares al circuito, pero a√∫n m√°s r√°pido; 31 GB / s en modo de subproceso √∫nico, 171 GB / s en modo de subproceso m√∫ltiple. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora echemos un vistazo </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Presta atenci√≥n al eje y.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizado excepcionalmente r√°pido. </font><font style="vertical-align: inherit;">Es 10 veces m√°s r√°pido que </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¬°En un bloque de 16 KB, incluso rompe 1000 GB / s! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, esta es una prueba de superficie sint√©tica. </font><font style="vertical-align: inherit;">La mayor√≠a de las aplicaciones no realizan la misma operaci√≥n con los mismos datos un mill√≥n de veces seguidas. </font><font style="vertical-align: inherit;">La prueba no muestra el rendimiento en el mundo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero la lecci√≥n es clara. </font><font style="vertical-align: inherit;">Dentro del cach√©, los datos se procesan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√°pidamente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Con un techo muy alto cuando se usa SIMD: m√°s de 100 GB / s en modo de subproceso √∫nico, m√°s de 1000 GB / s en subproceso m√∫ltiple. </font><font style="vertical-align: inherit;">Escribir datos en el cach√© es lento y tiene un l√≠mite estricto de aproximadamente 40 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloque peque√±o: lectura aleatoria</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hagamos lo mismo, pero ahora con acceso aleatorio. </font><font style="vertical-align: inherit;">Esta es mi parte favorita del art√≠culo. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lectura de valores aleatorios de la RAM es lenta, solo 0.46 GB / s. </font><font style="vertical-align: inherit;">Leer valores aleatorios del cach√© L1 es muy r√°pido: 13 GB / s. </font><font style="vertical-align: inherit;">Esto es m√°s r√°pido que leer datos en serie </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la RAM (11 GB / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prueba </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra un resultado similar para la misma plantilla, pero aproximadamente el doble de r√°pido que </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El acceso aleatorio es </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incre√≠blemente r√°pido.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de acceso aleatorio</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lectura libre de la memoria es lenta. </font><font style="vertical-align: inherit;">Catastr√≥ficamente lento. </font><font style="vertical-align: inherit;">Menos de 1 GB / s para ambos casos de prueba </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al mismo tiempo, las lecturas aleatorias del cach√© son sorprendentemente r√°pidas. </font><font style="vertical-align: inherit;">Es comparable a la </font><font style="vertical-align: inherit;">lectura </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secuencial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesita ser digerido. </font><font style="vertical-align: inherit;">El acceso aleatorio al cach√© es comparable en velocidad al acceso secuencial a la RAM. </font><font style="vertical-align: inherit;">La ca√≠da de L1 16 KB a L2 256 KB es solo la mitad o menos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que esto tendr√° profundas consecuencias.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las listas enlazadas se consideran da√±inas.</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perseguir un puntero (saltar sobre punteros) es malo. </font><font style="vertical-align: inherit;">Muy muy mal. </font><font style="vertical-align: inherit;">¬øCu√°nto est√° disminuyendo el rendimiento? </font><font style="vertical-align: inherit;">Ver por ti mismo. </font><font style="vertical-align: inherit;">Hice una prueba adicional que se envuelve </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada acceso pasa por un puntero. </font><font style="vertical-align: inherit;">Aqu√≠ hay un resultado terrible, simplemente catastr√≥fico.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 hilo | </font><font style="vertical-align: inherit;">matriz4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Seq | </font><font style="vertical-align: inherit;">14,8 GB / s | </font><font style="vertical-align: inherit;">0.8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">31,6 GB / s | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">22,2 GB / s | </font><font style="vertical-align: inherit;">1,9 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Rand | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">0.1 GB / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">23,2 GB / s | </font><font style="vertical-align: inherit;">1,7 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">15,2 GB / s | </font><font style="vertical-align: inherit;">0.8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 hilos | </font><font style="vertical-align: inherit;">matriz4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Seq | </font><font style="vertical-align: inherit;">34,4 GB / s | </font><font style="vertical-align: inherit;">2.5 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">154,8 GB / s | </font><font style="vertical-align: inherit;">8.0 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">111,6 GB / s | </font><font style="vertical-align: inherit;">5,7 GB / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloque grande - Rand | </font><font style="vertical-align: inherit;">7,1 GB / s | </font><font style="vertical-align: inherit;">0.4 GB / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">95.0 GB / s | </font><font style="vertical-align: inherit;">7.8 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">58,3 GB / s | </font><font style="vertical-align: inherit;">1,6 GB / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La suma secuencial de los valores detr√°s del puntero se realiza a una velocidad de menos de 1 GB / s. </font><font style="vertical-align: inherit;">La velocidad de acceso aleatorio de doble salto del cach√© es de solo 0.1 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persiguiendo un puntero ralentiza la ejecuci√≥n del c√≥digo 10-20 veces. </font><font style="vertical-align: inherit;">No dejes que tus amigos usen listas vinculadas. </font><font style="vertical-align: inherit;">Por favor, piense en el cach√©.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimaci√≥n de presupuesto para marcos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es com√∫n que los desarrolladores de juegos establezcan un l√≠mite (presupuesto) para la carga en la CPU y la cantidad de memoria. Pero nunca he visto un presupuesto de ancho de banda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los juegos modernos, FPS contin√∫a creciendo. Ahora est√° a 60 FPS. VR opera a una frecuencia de 90 Hz. Tengo un monitor de juego de 144 Hz. Es incre√≠ble, por lo que el 60 FPS parece una mierda. Nunca volver√© al viejo monitor. Esports y streamers Twitch monitorea 240 Hz. Este a√±o, Asus present√≥ un monstruo de 360 ‚Äã‚ÄãHz en el CES. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi procesador tiene un l√≠mite superior de aproximadamente 40 GB / s. ¬°Eso parece un gran n√∫mero! Sin embargo, a una frecuencia de 240 Hz, solo se obtienen 167 MB por cuadro. Una aplicaci√≥n realista puede generar 5 GB / s de tr√°fico a 144 Hz, que es solo 69 MB por cuadro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ hay una tabla con algunos n√∫meros.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        El | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 </font><font style="vertical-align: inherit;">60 </font><font style="vertical-align: inherit;">90 </font><font style="vertical-align: inherit;">144 </font><font style="vertical-align: inherit;">240 </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB / s | </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1.3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB / s | </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB / s | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me parece que es √∫til evaluar los problemas desde esta perspectiva. </font><font style="vertical-align: inherit;">Esto deja en claro que algunas ideas no son factibles. </font><font style="vertical-align: inherit;">Alcanzar 240 Hz no es f√°cil. </font><font style="vertical-align: inherit;">Esto no suceder√° por s√≠ solo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los n√∫meros que todo programador debe saber (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lista anterior est√° desactualizada. </font><font style="vertical-align: inherit;">Ahora debe actualizarse y ponerse en conformidad para 2020. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ hay algunos n√∫meros para la computadora de mi casa. </font><font style="vertical-align: inherit;">Esta es una mezcla de AIDA64, Sandra y mis puntos de referencia. </font><font style="vertical-align: inherit;">Las figuras no dan una imagen completa y son solo un punto de partida.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latencia L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retardo L2: 2.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retardo L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Latencia RAM: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(por hilo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L1: 210 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L2: 80 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda L3: 60 GB / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(sistema completo)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banda RAM: 45 GB / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ser√≠a bueno crear un punto de referencia de c√≥digo abierto peque√±o y simple. </font><font style="vertical-align: inherit;">Algunos archivos C que se pueden ejecutar en computadoras de escritorio, servidores, dispositivos m√≥viles, consolas, etc. Pero no soy el tipo de persona que escribe dicha herramienta.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denegaci√≥n de responsabilidad</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Medir el ancho de banda de la memoria es dif√≠cil. </font><font style="vertical-align: inherit;">Muy dificil. </font><font style="vertical-align: inherit;">Probablemente hay errores en mi c√≥digo. </font><font style="vertical-align: inherit;">Muchos factores no contabilizados. </font><font style="vertical-align: inherit;">Si tiene alguna cr√≠tica a mi t√©cnica, probablemente tenga raz√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En definitiva, creo que esto es normal. </font><font style="vertical-align: inherit;">Este art√≠culo no trata sobre el rendimiento exacto de mi escritorio. </font><font style="vertical-align: inherit;">Esta es una declaraci√≥n del problema desde cierto punto de vista. </font><font style="vertical-align: inherit;">Y sobre c√≥mo aprender a hacer algunos c√°lculos matem√°ticos aproximados.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un colega comparti√≥ conmigo una opini√≥n interesante sobre el ancho de banda de la memoria de la GPU y el rendimiento de la aplicaci√≥n. </font><font style="vertical-align: inherit;">Esto me llev√≥ a estudiar el rendimiento de la memoria en las computadoras modernas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para c√°lculos aproximados, aqu√≠ hay algunos n√∫meros para un escritorio moderno:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento RAM</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°ximo: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En promedio, aproximadamente: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√≠nimo: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento de cach√© L1 / L2 / L3 (por n√∫cleo)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°ximo (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En promedio, aproximadamente: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√≠nimo: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las clasificaciones de muestra est√°n relacionadas con el rendimiento </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El c√≥digo real nunca ser√° tan simple. </font><font style="vertical-align: inherit;">Pero para los c√°lculos en una servilleta, este es un punto de partida razonable. </font><font style="vertical-align: inherit;">Debe ajustar esta cifra en funci√≥n de los patrones de acceso a la memoria en su programa, las caracter√≠sticas de su equipo y el c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, lo m√°s importante es una nueva forma de pensar sobre los problemas. </font><font style="vertical-align: inherit;">Presentar el problema en bytes por segundo o bytes por cuadro es otra lente para mirar. </font><font style="vertical-align: inherit;">Esta es una herramienta √∫til por si acaso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias por leer.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s investigaci√≥n</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo solo toc√≥ ligeramente el tema. </font><font style="vertical-align: inherit;">Probablemente no voy a entrar en eso. </font><font style="vertical-align: inherit;">Pero si lo hiciera, entonces podr√≠a cubrir algunos de los siguientes aspectos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabaci√≥n de rendimiento</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intercambio falso</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(o falta del mismo)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contadores de rendimiento</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento TLB</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos de cach√©</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especificaciones del Sistema</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pruebas se realizaron en la PC de mi casa. </font><font style="vertical-align: inherit;">Solo configuraciones de stock, sin overclocking.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SO: Windows 10 v1903 compilaci√≥n 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU: Intel i7-8700k @ 3.70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 @ 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placa base: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es487884/index.html">5 cosas que me gustar√≠a saber antes de desarrollar el intercambio</a></li>
<li><a href="../es487888/index.html">CSRF en Umbraco CMS</a></li>
<li><a href="../es487890/index.html">Traducir voz a texto en iOS usando el marco de voz</a></li>
<li><a href="../es487894/index.html">BarsUP.AM: c√≥mo desarrollamos una herramienta para proteger la informaci√≥n de las aplicaciones web</a></li>
<li><a href="../es487896/index.html">Cuando la muerte se convierte en arte: epitafios de personajes famosos con un profundo significado en ingl√©s</a></li>
<li><a href="../es487900/index.html">pyqtdeploy, o empaquetamos el programa Python en exe'shnik ... de la manera dif√≠cil</a></li>
<li><a href="../es487902/index.html">De fuego a fuego: electrolito refractario de estado s√≥lido para bater√≠as de iones de litio</a></li>
<li><a href="../es487906/index.html">El libro "Redes inform√°ticas. Principios, tecnolog√≠as, protocolos: edici√≥n de aniversario ¬ª</a></li>
<li><a href="../es487908/index.html">El comienzo de la guerra de los procesos tecnol√≥gicos: 5 nm y 3 nm.</a></li>
<li><a href="../es487910/index.html">Leyes naturales y matem√°ticas elegantes: problemas y soluciones.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>