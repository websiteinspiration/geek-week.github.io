<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚔 👨‍🏭 🥓 L'ingénierie inverse du rendu de The Witcher 3: divers effets du ciel 📝 😲 🌝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Parties précédentes de l'analyse: première , deuxième et troisième .]
 
 Partie 1. Nuages ​​de Cirrus
 Lorsque le jeu se déroule dans des espaces ouv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>L'ingénierie inverse du rendu de The Witcher 3: divers effets du ciel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489118/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Parties précédentes de l'analyse: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">première</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxième</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">troisième</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .]</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1. Nuages ​​de Cirrus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le jeu se déroule dans des espaces ouverts, l'un des facteurs déterminant la crédibilité du monde est le ciel. Pensez-y - la plupart du temps, le ciel occupe littéralement environ 40 à 50% de tout l'écran. Le ciel est bien plus qu'un beau dégradé. Il a des étoiles, le soleil, la lune et enfin des nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que les tendances actuelles semblent consister en un rendu volumétrique des nuages ​​à l'aide du raymarching (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cet article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), les nuages ​​dans The Witcher 3 sont entièrement basés sur la texture. Je les ai déjà examinés auparavant, mais il s'est avéré qu'avec eux, tout est plus compliqué que ce à quoi je m'attendais à l'origine. Si vous avez suivi ma série d'articles, vous savez qu'il y a une différence entre le DLC Blood and Wine et le reste du jeu. Et, comme vous pouvez le deviner, il y a quelques changements dans le travail avec les nuages ​​dans le DLC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Witcher 3 a plusieurs couches de nuages. Selon la météo, il ne peut s'agir que de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cirrus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cumulus élevés</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , éventuellement de quelques nuages ​​de la famille des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuages ​​en couches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (par exemple lors d'une tempête). En fin de compte, il peut ne pas y avoir de nuages ​​du tout.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains calques diffèrent en termes de textures et de shaders utilisés pour les rendre. De toute évidence, cela affecte la complexité et la longueur du code assembleur pour le pixel shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré toute cette diversité, il existe certains modèles communs qui peuvent être observés lors du rendu des nuages ​​dans Witcher 3. Tout d'abord, ils sont tous rendus dans une passe proactive, et c'est le choix parfait. Tous utilisent le mélange (voir ci-dessous). Cela rend beaucoup plus facile de contrôler la façon dont un calque séparé recouvre le ciel - cela est affecté par la valeur alpha du pixel shader.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus intéressant, certains calques sont rendus deux fois avec les mêmes paramètres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir regardé le code, j'ai choisi le shader le plus court afin (1) d'effectuer probablement son reverse engineering complet, (2) de comprendre tous ses aspects. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai regardé de plus près les nuages ​​de cirrus de Witcher 3: Blood and Wine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple de cadre:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f81/eb8/a49/f81eb8a49dc315ef04d72b582fba869b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant le rendu</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/b27/206/885b2720624e7a455987bb6239d0e371.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après la première passe de rendu</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après la deuxième passe de rendu</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans ce cadre particulier, les nuages ​​de cirrus sont la première couche du rendu. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, il est rendu deux fois, ce qui augmente sa luminosité.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader géométrique et vertex</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant le pixel shader, nous parlerons brièvement des shaders géométriques et vertex utilisés. </font><font style="vertical-align: inherit;">Le maillage pour l'affichage des nuages ​​est un peu comme un dôme de ciel ordinaire:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/774/8de/b4c7748de95ad07f2dddfc090e62e0d2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les sommets sont dans l'intervalle [0-1], donc pour centrer le maillage sur le point (0,0,0), la mise à l'échelle et la déviation sont utilisées avant la conversion en worldViewProj (nous connaissons déjà ce modèle des parties précédentes de la série). </font><font style="vertical-align: inherit;">Dans le cas des nuages, le maillage s'étire fortement le long du plan XY (l'axe Z pointe vers le haut) pour couvrir plus d'espace que la pyramide de visibilité. </font><font style="vertical-align: inherit;">Le résultat est le suivant:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/0ca/95e/3410ca95ea9f0b3ef1fafe62cb5dba13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, le maillage a des vecteurs normaux et tangents. </font><font style="vertical-align: inherit;">Le vertex shader calcule également le vecteur bi-tangent par le produit vectoriel - les trois sont affichés sous une forme normalisée. </font><font style="vertical-align: inherit;">Il y a aussi un calcul supérieur du brouillard (sa couleur et sa luminosité).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code d'assemblage du pixel shader ressemble à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">238</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">13</span>], immediateIndexed  <font></font>
    dcl_sampler s0, <span class="hljs-function">mode_default  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    dcl_input_ps linear v0.xyzw  
    dcl_input_ps linear v1.xyzw  
    dcl_input_ps linear v2.w  
    dcl_input_ps linear v3.xyzw  
    dcl_input_ps linear v4.xyz  
    dcl_input_ps linear v5.xyz  
    dcl_output o0.xyzw  
    dcl_temps 4  
   0: mul r0.xyz, cb0[9].xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
   1: dp3 r0.w, r0.xyzx, r0.xyzx  
   2: rsq r0.w, r0.w  
   3: mul r0.xyz, r0.wwww, r0.xyzx  
   4: mul r1.xy, cb0[0].xxxx, cb4[5].xyxx  
   5: mad r1.xy, v1.xyxx, cb4[4].xyxx, r1.xyxx  
   6: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.xyzw, r1.xyxx, t0.xyzw, s0  
   7: add r1.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)</span>  
   8: add r1.xyz, r1.xyzx, r1.xyzx  
   9: dp3 r0.w, r1.xyzx, r1.xyzx  
  10: rsq r0.w, r0.w  
  11: mul r1.xyz, r0.wwww, r1.xyzx  
  12: mul r2.xyz, r1.yyyy, v3.xyzx  
  13: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  14: mov r3.xy, v1.zwzz  
  15: mov r3.z, v3.w  
  16: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  
  17: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  18: add r0.y, -cb4[2].x, cb4[3].x  
  19: mad r0.x, r0.x, r0.y, cb4[2].x  
  20: dp2 r0.y, -cb0[9].xyxx, -cb0[9].xyxx  
  21: rsq r0.y, r0.y  
  22: mul r0.yz, r0.yyyy, -cb0[9].xxyx  
  23: add r1.xyz, -v4.xyzx, cb1[8].xyzx  
  24: dp3 r0.w, r1.xyzx, r1.xyzx  
  25: rsq r1.z, r0.w  
  26: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  27: add r0.w, r0.w, -cb4[7].x  
  28: mul r1.xy, r1.zzzz, r1.xyxx  
  29: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  30: add r0.y, r0.y, r0.y  
  31: min r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  32: add r0.z, -cb4[0].x, cb4[1].x  
  33: mad r0.z, r0.y, r0.z, cb4[0].x  
  34: mul r0.x, r0.x, r0.z  
  35: <span class="hljs-built_in">log</span> r0.x, r0.x  
  36: mul r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.200000</span>)</span>  
  37: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  38: add r1.xyz, cb12[236].xyzx, -cb12[237].xyzx  
  39: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[237].xyzx  
  40: mul r2.xyz, r0.xxxx, r1.xyzx  
  41: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  42: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  
  43: add r1.x, -cb4[7].x, cb4[8].x  
  44: div_sat r0.w, r0.w, r1.x  
  45: mul r1.x, r1.w, cb4[9].x  
  46: mad r1.y, -cb4[9].x, r1.w, r1.w  
  47: mad r0.w, r0.w, r1.y, r1.x  
  48: mul r1.xy, cb0[0].xxxx, cb4[11].xyxx  
  49: mad r1.xy, v1.xyxx, cb4[10].xyxx, r1.xyxx  
  50: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r1.xyxx, t1.xyzw, s0  
  51: mad r1.x, r1.x, cb4[12].x, -cb4[12].x  
  52: mad_sat r1.x, cb4[12].x, v2.w, r1.x  
  53: mul r0.w, r0.w, r1.x  
  54: mul_sat r0.w, r0.w, cb4[6].x  
  55: mul o0.xyz, r0.wwww, r0.xyzx  
  56: mov o0.w, r0.w  
  57: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux textures sans couture sont entrées. </font><font style="vertical-align: inherit;">L'un d'eux contient une carte normale (canaux </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xyz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et une forme de nuage (canal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Le second est le bruit qui déforme la forme.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f3/c27/a5e/1f3c27a5eea1412d5fa1fa632861a342.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte normale, propriété CD Projekt Red</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37b/a53/d41/37ba53d412d20f476ddf71e81892b62a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forme de nuage, propriété CD Projekt Red</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/1bb/edd/05e1bbedded7c16acefc1f67d5b3fd49.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture de bruit, propriété de CD Projekt Red</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le tampon principal des constantes avec paramètres de nuage est cb4. </font><font style="vertical-align: inherit;">Pour ce cadre, il a les significations suivantes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/229/4de/9422294de7d9ead5e2bec154eb897c7a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, d'autres valeurs provenant d'autres tampons sont utilisées. </font><font style="vertical-align: inherit;">Ne vous inquiétez pas, nous les considérerons également.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lumière du soleil inversée direction Z</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose qui se produit dans le shader est le calcul de la direction normalisée de la lumière solaire inversée le long de l'axe Z:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">0</span>: mul r0.xyz, cb0[<span class="hljs-number">9</span>].xyzx, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)  
   <span class="hljs-number">1</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
   <span class="hljs-number">2</span>: rsq r0.w, r0.w  
   <span class="hljs-number">3</span>: mul r0.xyz, r0.wwww, r0.xyzx  <font></font>
<font></font>
   float3 invertedSunlightDir = normalize(lightDir * float3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionné précédemment, l'axe Z est dirigé vers le haut et cb0 [9] est la direction de la lumière solaire. </font><font style="vertical-align: inherit;">Ce vecteur est destiné </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soleil - c'est important! </font><font style="vertical-align: inherit;">Vous pouvez le vérifier en écrivant un shader de calcul simple qui exécute un NdotL simple et en l'insérant dans la passe de shader différée.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Échantillonnage de la texture des nuages</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'étape suivante consiste à calculer des texcoords pour échantillonner la texture du nuage, décompresser le vecteur normal et le normaliser.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">4</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">5</span>].xyxx   
   <span class="hljs-number">5</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">4</span>].xyxx, r1.xyxx   
   <span class="hljs-number">6</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyzw, r1.xyxx, t0.xyzw, s0   
   <span class="hljs-number">7</span>: add r1.xyz, r1.xyzx, l(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)   
   <span class="hljs-number">8</span>: add r1.xyz, r1.xyzx, r1.xyzx   
   <span class="hljs-number">9</span>: dp3 r0.w, r1.xyzx, r1.xyzx   
  <span class="hljs-number">10</span>: rsq r0.w, r0.w   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords  </span><font></font>
   float2 cloudTextureUV = Texcoords * textureScale + elapsedTime * speedFactors;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span><font></font>
   float4 cloudTextureValue = texture0.Sample( sampler0, cloudTextureUV ).rgba;  <font></font>
   float3 normalMap = cloudTextureValue.xyz;  <font></font>
   <span class="hljs-keyword">float</span> cloudShape = cloudTextureValue.a;  <font></font>
   <font></font>
   <span class="hljs-comment">// Unpack normal and normalize it  </span>
   float3 unpackedNormal = (normalMap - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;  <font></font>
   unpackedNormal = normalize(unpackedNormal);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traitons-le progressivement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour obtenir le mouvement des nuages, nous avons besoin du temps écoulé en secondes ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) multiplié par le coefficient de vitesse, ce qui affecte la vitesse à laquelle les nuages ​​se déplacent dans le ciel ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [5] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit plus tôt, les UV sont étirés le long de la géométrie du dôme du ciel, et nous avons également besoin de facteurs d'échelle de texture qui affectent la taille des nuages ​​( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [4] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La formule finale est:</font></font><br>
<br>
<pre><code class="cpp hljs">samplingUV = Input.TextureUV * textureScale + time * speedMultiplier;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir échantillonné les 4 canaux, nous avons une carte normale (canaux RVB) et une forme de nuage (canal a). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour décompresser la carte normale de l'intervalle [0; </font><font style="vertical-align: inherit;">1] dans l'intervalle [-1; </font><font style="vertical-align: inherit;">1] nous utilisons la formule suivante:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = (packedNormal - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également utiliser ceci:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = packedNormal * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, nous normalisons le vecteur normal décompressé.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposer les normales</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant les vecteurs normaux, les vecteurs tangents et bi-tangents du vertex shader et le vecteur normal de la carte normale, nous cartographions normalement les normales.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: mul r1.xyz, r0.wwww, r1.xyzx  
  <span class="hljs-number">12</span>: mul r2.xyz, r1.yyyy, v3.xyzx  
  <span class="hljs-number">13</span>: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  <span class="hljs-number">14</span>: mov r3.xy, v1.zwzz  
  <span class="hljs-number">15</span>: mov r3.z, v3.w  
  <span class="hljs-number">16</span>: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  <font></font>
    <font></font>
   <span class="hljs-comment">// Perform bump mapping  </span><font></font>
   float3 SkyTangent = Input.Tangent;  <font></font>
   float3 SkyNormal = (float3( Input.Texcoords.zw, Input.param3.w ));  <font></font>
   float3 SkyBitangent = Input.param3.xyz;  <font></font>
        <font></font>
   float3x3 TBN = float3x3(SkyTangent, SkyBitangent, SkyNormal);  <font></font>
   float3 finalNormal = (float3)mul( unpackedNormal, (TBN) );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luminosité (1)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'étape suivante, le calcul NdotL est appliqué et cela affecte la quantité d'éclairage d'un pixel spécifique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez le code assembleur suivant:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">17</span>: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  <span class="hljs-number">18</span>: add r0.y, -cb4[<span class="hljs-number">2</span>].x, cb4[<span class="hljs-number">3</span>].x  
  <span class="hljs-number">19</span>: mad r0.x, r0.x, r0.y, cb4[<span class="hljs-number">2</span>].x  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la visualisation de NdotL sur la trame en question:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/f29/1a1/283f291a18105785a51af59dbbe8905a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce produit scalaire (avec saturation) est utilisé pour interpoler entre minIntensity et maxIntensity. </font><font style="vertical-align: inherit;">Grâce à cela, les parties des nuages ​​éclairées par la lumière du soleil seront plus lumineuses.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Calculate cosine between normal and up-inv lightdir  </span>
   <span class="hljs-keyword">float</span> NdotL = saturate( dot(invertedSunlightDir, finalNormal) );  <font></font>
   <font></font>
   <span class="hljs-comment">// Param 1, line 19, r0.x  </span>
   <span class="hljs-keyword">float</span> intensity1 = lerp( param1Min, param1Max, NdotL );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luminosité (2)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre facteur affecte la luminosité des nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les nuages ​​situés dans la partie du ciel où se trouve le soleil devraient être davantage mis en évidence. </font><font style="vertical-align: inherit;">Pour ce faire, nous calculons le gradient sur la base du plan XY. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce gradient est utilisé pour calculer l'interpolation linéaire entre les valeurs min / max, similaire à ce qui se passe dans la partie (1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, nous pouvons théoriquement demander d'assombrir les nuages ​​situés de l'autre côté du soleil, mais cela ne se produit pas dans ce cadre particulier, car </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [1] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sont définis sur 1.0f.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">20</span>: dp2 r0.y, -cb0[<span class="hljs-number">9</span>].xyxx, -cb0[<span class="hljs-number">9</span>].xyxx  
  <span class="hljs-number">21</span>: rsq r0.y, r0.y  
  <span class="hljs-number">22</span>: mul r0.yz, r0.yyyy, -cb0[<span class="hljs-number">9</span>].xxyx  
  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  
  <span class="hljs-number">28</span>: mul r1.xy, r1.zzzz, r1.xyxx  
  <span class="hljs-number">29</span>: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  <span class="hljs-number">30</span>: add r0.y, r0.y, r0.y  
  <span class="hljs-number">31</span>: min r0.y, r0.y, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">32</span>: add r0.z, -cb4[<span class="hljs-number">0</span>].x, cb4[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">33</span>: mad r0.z, r0.y, r0.z, cb4[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">34</span>: mul r0.x, r0.x, r0.z  
  <span class="hljs-number">35</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">36</span>: mul r0.x, r0.x, l(<span class="hljs-number">2.200000</span>)  
  <span class="hljs-number">37</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate normalized -lightDir.xy (20-22)  </span><font></font>
   float2 lightDirXY = normalize( -lightDir.xy );  <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate world to camera  </span><font></font>
   float3 vWorldToCamera = ( CameraPos - WorldPos );  <font></font>
   <span class="hljs-keyword">float</span> worldToCamera_distance = length(vWorldToCamera);  <font></font>
        <font></font>
   <span class="hljs-comment">// normalize vector  </span><font></font>
   vWorldToCamera = normalize( vWorldToCamera );  <font></font>
        <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> LdotV = saturate( dot(lightDirXY, vWorldToCamera.xy) );  
   <span class="hljs-keyword">float</span> highlightedSkySection = saturate( <span class="hljs-number">2</span>*LdotV );  
   <span class="hljs-keyword">float</span> intensity2 = lerp( param2Min, param2Max, highlightedSkySection );  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> finalIntensity = <span class="hljs-built_in">pow</span>( intensity2 *intensity1, <span class="hljs-number">2.2</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la toute fin, nous multiplions les deux luminosités et élevons le résultat à une puissance de 2,2.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur des nuages</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le calcul de la couleur des nuages ​​commence par l'obtention des constantes tampons de deux valeurs indiquant la couleur des nuages ​​près du soleil et des nuages ​​de l'autre côté du ciel. </font><font style="vertical-align: inherit;">Entre eux, une interpolation linéaire est effectuée sur la base de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optionSkySection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat est ensuite multiplié par </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalIntensity</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et au final, le résultat est mélangé au brouillard (pour des raisons de performances, il a été calculé par le vertex shader).</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">38</span>: add r1.xyz, cb12[<span class="hljs-number">236</span>].xyzx, -cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">39</span>: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">40</span>: mul r2.xyz, r0.xxxx, r1.xyzx  
  <span class="hljs-number">41</span>: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  <span class="hljs-number">42</span>: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  <font></font>
   <font></font>
  float3 cloudsColor = lerp( cloudsColorBack, cloudsColorFront, highlightedSunSection );  <font></font>
  cloudsColor *= finalIntensity;  <font></font>
  cloudsColor = lerp( cloudsColor, FogColor, FogAmount );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre les nuages ​​de cirrus plus visibles à l'horizon</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas très visible sur le cadre, mais en fait cette couche est plus visible près de l'horizon qu'au-dessus de la tête de Geralt. </font><font style="vertical-align: inherit;">Voici comment procéder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pourriez remarquer que lors du calcul de la deuxième luminosité, nous avons calculé la longueur du vecteur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worldToCamera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trouvons les occurrences suivantes de cette longueur dans le code:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  <font></font>
  ...  <font></font>
  <span class="hljs-number">43</span>: add r1.x, -cb4[<span class="hljs-number">7</span>].x, cb4[<span class="hljs-number">8</span>].x  
  <span class="hljs-number">44</span>: div_sat r0.w, r0.w, r1.x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, qu'est-ce que c'est avec nous? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cb [7] .x et cb [8] .x ont les valeurs 2000.0 et 7000.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que c'est le résultat de l'utilisation de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linstep</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elle reçoit trois paramètres: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min / max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - intervalle et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - valeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne comme suit: si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est dans l'intervalle [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], alors la fonction renvoie une interpolation linéaire dans l'intervalle [0,0 - 1,0]. </font><font style="vertical-align: inherit;">D'un autre côté, si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est hors limites, alors linstep renvoie 0,0 ou 1,0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple simple:</font></font><br>
<br>
<pre><code class="cpp hljs">linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">999.0</span>) = <span class="hljs-number">0.0</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">1500.0</span>) = <span class="hljs-number">0.5</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">2000.0</span>) = <span class="hljs-number">1.0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, il est assez similaire au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de HLSL, sauf que dans ce cas, au lieu de l'interpolation hermitienne, linéaire est effectuée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linstep n'est pas une fonctionnalité de HLSL, mais il est très utile. </font><font style="vertical-align: inherit;">Cela vaut la peine de l'avoir dans votre boîte à outils.</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-comment">// linstep:  </span>
 <span class="hljs-comment">//  </span>
 <span class="hljs-comment">// Returns a linear interpolation between 0 and 1 if t is in the range [min, max]   </span>
 <span class="hljs-comment">// if "v" is &lt;= min, the output is 0  </span>
 <span class="hljs-comment">// if "v" i &gt;= max, the output is 1  </span><font></font>
   <font></font>
 <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">( <span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v )</span>  
 </span>{  
   <span class="hljs-keyword">return</span> saturate( (v - min) / (max - min) );  <font></font>
 } </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons à Witcher 3: après avoir calculé cet indicateur, signalé à quelle distance une partie du ciel est de Geralt, nous l'utilisons pour affaiblir la luminosité des nuages:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">45</span>: mul r1.x, r1.w, cb4[<span class="hljs-number">9</span>].x  
  <span class="hljs-number">46</span>: mad r1.y, -cb4[<span class="hljs-number">9</span>].x, r1.w, r1.w  
  <span class="hljs-number">47</span>: mad r0.w, r0.w, r1.y, r1.x  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> distanceAttenuation = linstep( fadeDistanceStart, fadeDistanceEnd, worldToCamera_distance );  <font></font>
    <font></font>
   <span class="hljs-keyword">float</span> fadedCloudShape = closeCloudsHidingFactor * cloudShape;  <font></font>
   cloudShape = lerp( fadedCloudShape, cloudShape, distanceAttenuation );</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudShape</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le canal .a de la première texture, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closeCloudsHidingFactor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une valeur tampon constante qui contrôle la visibilité des nuages ​​au-dessus de la tête de Geralt. </font><font style="vertical-align: inherit;">Dans toutes les images que j'ai testées, elle était égale à 0,0, ce qui équivaut à l'absence de nuages. </font><font style="vertical-align: inherit;">Lorsque l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atténuation de la distance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> approche de 1,0 (la distance entre la caméra et le dôme du ciel augmente), les nuages ​​deviennent plus visibles.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Échantillonnage de la texture du bruit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calcul des coordonnées de la texture du bruit d'échantillonnage calculs similaires pour la texture des nuages, sauf que vous utilisez un ensemble différent de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textureScale</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speedMultiplier</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, un sampler avec le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mode d' </font><font style="vertical-align: inherit;">adressage activé est utilisé pour échantillonner toutes ces textures </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">48</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">11</span>].xyxx  
  <span class="hljs-number">49</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">10</span>].xyxx, r1.xyxx  
  <span class="hljs-number">50</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.x, r1.xyxx, t1.xyzw, s0  <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords for noise  </span><font></font>
   float2 noiseTextureUV = Texcoords * textureScaleNoise + elapsedTime * speedFactorsNoise;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;</code></pre> <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettre tous ensemble</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir reçu la valeur du bruit, nous devons la combiner avec cloudShape. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai eu quelques problèmes pour comprendre ces lignes, où il y a param2.w (qui est toujours 1.0) et noiseMult (a une valeur de 5.0, tirée du tampon constant). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quoi qu'il en soit, la chose la plus importante ici est la valeur finale de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalCloudsVisibility</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui affecte la visibilité des nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez également un œil à la valeur finale du bruit. </font><font style="vertical-align: inherit;">La couleur de sortie de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudsColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est multipliée par le bruit final, qui est également émis vers le canal alpha.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">51</span>: mad r1.x, r1.x, cb4[<span class="hljs-number">12</span>].x, -cb4[<span class="hljs-number">12</span>].x
  <span class="hljs-number">52</span>: mad_sat r1.x, cb4[<span class="hljs-number">12</span>].x, v2.w, r1.x
  <span class="hljs-number">53</span>: mul r0.w, r0.w, r1.x
  <span class="hljs-number">54</span>: mul_sat r0.w, r0.w, cb4[<span class="hljs-number">6</span>].x
  <span class="hljs-number">55</span>: mul o0.xyz, r0.wwww, r0.xyzx
  <span class="hljs-number">56</span>: mov o0.w, r0.w
  <span class="hljs-number">57</span>: ret   <font></font>
<font></font>
   <span class="hljs-comment">// Sample noise texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;  <font></font>
   noiseTextureValue = noiseTextureValue * noiseMult - noiseMult;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> noiseValue = saturate( noiseMult * Input.param2.w + noiseTextureValue);  <font></font>
   noiseValue *= cloudShape;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> finalNoise = saturate( noiseValue * generalCloudsVisibility);  <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> float4( cloudsColor*finalNoise, finalNoise ); </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat final semble très crédible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez comparer. </font><font style="vertical-align: inherit;">La première image est mon shader, la seconde est le shader du jeu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4cc/331/897/4cc3318976e9c1c54178683a2fee44c0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous êtes curieux, le shader est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2. Brouillard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le brouillard peut être mis en œuvre de différentes manières. Cependant, les moments où nous pouvions appliquer un simple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brouillard dépendant de la distance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et le supprimer étaient pour toujours dans le passé (très probablement). Vivre dans le monde des shaders programmables a ouvert la porte à de nouvelles solutions folles, mais plus importantes encore, physiquement précises et visuellement réalistes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les tendances actuelles du rendu du brouillard sont basées sur des shaders de calcul (pour plus de détails, voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> présentation de Bart Wronsky). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le fait que cette présentation soit apparue en 2014 et que The Witcher 3 soit sorti en 2015/2016, le brouillard dans la dernière partie des aventures de Geralt dépend complètement de l'écran et est implémenté comme un post-traitement typique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer la prochaine session de rétro-ingénierie, je dois dire qu'au cours de la dernière année, j'ai essayé de comprendre le brouillard de Witcher 3 au moins cinq fois, et chaque fois a échoué. Le code assembleur, comme vous le verrez bientôt, est assez compliqué, ce qui rend le processus de création d'un shader de brouillard lisible sur HLSL presque impossible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, j'ai réussi à trouver un shader de brouillard sur Internet qui a immédiatement attiré mon attention en raison de sa similitude avec le brouillard The Witcher 3 en termes de noms de variables et de l'ordre général des instructions. Ce shader n'était pas exactement le même que dans le jeu, j'ai donc dû le retravailler un peu. Je tiens à dire que la partie principale du code HLSL que vous voyez ici, à deux exceptions près, n'a pas été créée / analysée par moi. N'oubliez pas cela.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici le code assembleur pour le pixel fog shader - il convient de noter qu'il est le même pour tout le jeu (la partie principale de 2015 et les deux DLC):</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb3[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">214</span>], <span class="hljs-function">immediateIndexed  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t2  
    dcl_input_ps_siv v0.xy, position  
    dcl_output o0.xyzw  
    dcl_temps 7  
   0: ftou r0.xy, v0.xyxx  
   1: mov r0.zw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
   2: <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r0.xyww, t0.xyzw  
   3: mad r1.y, r1.x, cb12[22].x, cb12[22].y  
   4: lt r1.y, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
   5: if_nz r1.y  
   6:  utof r1.yz, r0.xxyx  
   7:  mul r2.xyzw, r1.zzzz, cb12[211].xyzw  
   8:  mad r2.xyzw, cb12[210].xyzw, r1.yyyy, r2.xyzw  
   9:  mad r1.xyzw, cb12[212].xyzw, r1.xxxx, r2.xyzw  
  10:  add r1.xyzw, r1.xyzw, cb12[213].xyzw  
  11:  div r1.xyz, r1.xyzx, r1.wwww  
  12:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r2.xyz, r0.xyww, t1.xyzw  
  13:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r0.x, r0.xyzw, t2.xyzw  
  14:  max r0.x, r0.x, cb3[1].x  
  15:  add r0.yzw, r1.xxyz, -cb12[0].xxyz  
  16:  dp3 r1.x, r0.yzwy, r0.yzwy  
  17:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  18:  add r1.y, r1.x, -cb3[0].x  
  19:  add r1.zw, -cb3[0].xxxz, cb3[0].yyyw  
  20:  div_sat r1.y, r1.y, r1.z  
  21:  mad r1.y, r1.y, r1.w, cb3[0].z  
  22:  add r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  23:  mad r0.x, r1.y, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  24:  div r0.yzw, r0.yyzw, r1.xxxx  
  25:  mad r1.y, r0.w, cb12[22].z, cb12[0].z  
  26:  add r1.x, r1.x, -cb12[22].z  
  27:  max r1.x, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  28:  min r1.x, r1.x, cb12[42].z  
  29:  mul r1.z, r0.w, r1.x  
  30:  mul r1.w, r1.x, cb12[43].x  
  31:  mul r1.zw, r1.zzzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.062500</span>, <span class="hljs-number">0.062500</span>)</span>  
  32:  dp3 r0.y, cb12[38].xyzx, r0.yzwy  
  33:  add r0.z, r0.y, cb12[42].x  
  34:  add r0.w, cb12[42].x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  35:  div_sat r0.z, r0.z, r0.w  
  36:  add r0.w, -cb12[43].z, cb12[43].y  
  37:  mad r0.z, r0.z, r0.w, cb12[43].z  
  38:  mul r0.w, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>  
  39:  mad_sat r2.w, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.002000</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.300000</span>)</span>  
  40:  mul r0.w, r0.w, r2.w  
  41:  lt r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, r0.y  
  42:  movc r3.xyz, r0.yyyy, cb12[39].xyzx, cb12[41].xyzx  
  43:  add r3.xyz, r3.xyzx, -cb12[40].xyzx  
  44:  mad r3.xyz, r0.wwww, r3.xyzx, cb12[40].xyzx  
  45:  movc r4.xyz, r0.yyyy, cb12[45].xyzx, cb12[47].xyzx  
  46:  add r4.xyz, r4.xyzx, -cb12[46].xyzx  
  47:  mad r4.xyz, r0.wwww, r4.xyzx, cb12[46].xyzx  
  48:  ge r0.y, r1.x, cb12[48].y  
  49:  if_nz r0.y  
  50:   add r0.y, r1.y, cb12[42].y  
  51:   mul r0.w, r0.z, r0.y  
  52:   mul r1.y, r0.z, r1.z  
  53:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>)</span>, r0.wwww  
  54:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  55:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  56:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  57:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  58:   mul r1.z, r5.y, r5.x  
  59:   mul r1.z, r5.z, r1.z  
  60:   mul r1.z, r5.w, r1.z  
  61:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>)</span>, r0.wwww  
  62:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  63:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  64:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  65:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  66:   mul r1.z, r1.z, r5.x  
  67:   mul r1.z, r5.y, r1.z  
  68:   mul r1.z, r5.z, r1.z  
  69:   mul r1.z, r5.w, r1.z  
  70:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>)</span>, r0.wwww  
  71:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  72:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  73:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  74:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  75:   mul r1.z, r1.z, r5.x  
  76:   mul r1.z, r5.y, r1.z  
  77:   mul r1.z, r5.z, r1.z  
  78:   mul r1.z, r5.w, r1.z  
  79:   mad r5.xy, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>, r0.wwww  
  80:   max r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  81:   add r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  82:   div_sat r5.xy, r1.wwww, r5.xyxx  
  83:   add r5.xy, -r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  84:   mul r1.z, r1.z, r5.x  
  85:   mul r1.z, r5.y, r1.z  
  86:   mad r0.w, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.000000</span>)</span>, r0.w  
  87:   max r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  88:   add r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  89:   div_sat r0.w, r1.w, r0.w  
  90:   add r0.w, -r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  91:   mul r0.w, r0.w, r1.z  
  92:   mad r0.y, r0.y, r0.z, r1.y  
  93:   max r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  94:   add r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  95:   div_sat r0.y, r1.w, r0.y  
  96:   add r0.y, -r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  97:   mad r0.y, -r0.w, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  98:   add r0.z, r1.x, -cb12[48].y  
  99:   mul_sat r0.z, r0.z, cb12[48].z  
  100:  <span class="hljs-keyword">else</span>  
  101:   mov r0.yz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  102:  endif  
  103:  <span class="hljs-built_in">log</span> r0.y, r0.y  
  104:  mul r0.w, r0.y, cb12[42].w  
  105:  <span class="hljs-built_in">exp</span> r0.w, r0.w  
  106:  mul r0.y, r0.y, cb12[48].x  
  107:  <span class="hljs-built_in">exp</span> r0.y, r0.y  
  108:  mul r0.yw, r0.yyyw, r0.zzzz  
  109:  mad_sat r1.xy, r0.wwww, cb12[189].xzxx, cb12[189].ywyy  
  110:  add r5.xyz, -r3.xyzx, cb12[188].xyzx  
  111:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  112:  add r0.z, cb12[188].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  113:  mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  114:  mul_sat r5.w, r0.z, r0.w  
  115:  lt r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, cb12[192].x  
  116:  if_nz r0.z  
  117:   mad_sat r1.xy, r0.wwww, cb12[191].xzxx, cb12[191].ywyy  
  118:   add r6.xyz, -r3.xyzx, cb12[190].xyzx  
  119:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  120:   add r0.z, cb12[190].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  121:   mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  122:   mul_sat r3.w, r0.z, r0.w  
  123:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  124:   mad r5.xyzw, cb12[192].xxxx, r1.xyzw, r5.xyzw  
  125:  endif  
  126:  mul r0.z, r0.x, r5.w  
  127:  mul r0.x, r0.x, r0.y  
  128:  dp3 r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>)</span>, r2.xyzx  
  129:  mad r1.xyz, r0.yyyy, r4.xyzx, -r2.xyzx  
  130:  mad r0.xyw, r0.xxxx, r1.xyxz, r2.xyxz  
  131:  add r1.xyz, -r0.xywx, r5.xyzx  
  132:  mad r0.xyz, r0.zzzz, r1.xyzx, r0.xywx  
  133: <span class="hljs-keyword">else</span>  
  134:  mov r0.xyz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  135: endif  
  136: mov o0.xyz, r0.xyzx  
  137: mov o0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  138: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honnêtement, le shader est assez long. </font><font style="vertical-align: inherit;">Probablement trop long pour un processus d'ingénierie inverse efficace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple d'une scène de coucher de soleil avec du brouillard:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetons un coup d'œil à l'entrée: en ce </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
qui concerne les textures, nous avons un tampon de profondeur, une occlusion ambiante et un tampon de couleur HDR.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/24d/ff0/9ea24dff07dad409a78834272d553b29.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampon de profondeur entrant</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Occlusion ambiante entrante</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/51f/f3c/74851ff3ce8d38b77d9319329a334d4f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tampon de couleur HDR entrant</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
... et le résultat de l'application du shader de brouillard dans cette scène ressemble à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture HDR après application du brouillard.Le</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
tampon de profondeur est utilisé pour recréer la position dans le monde. C'est le modèle standard pour les shaders Witcher 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avoir des données d'occlusion ambiante (si activées) nous permet d'obscurcir le brouillard. Une idée très intelligente, peut-être évidente, mais je n'y ai jamais pensé de cette façon. Je reviendrai sur cet aspect plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un shader commence par déterminer si un pixel est dans le ciel. Dans le cas où le pixel se trouve dans le ciel (profondeur == 1.0), le shader retourne le noir. Si le pixel est dans la scène (profondeur &lt;1.0), alors nous recréons la position dans le monde en utilisant le tampon de profondeur (lignes 7-11) et continuons à calculer le brouillard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le passage du brouillard se produit peu de temps après le processus d'ombrage retardé. </font><font style="vertical-align: inherit;">Vous remarquerez peut-être que certains éléments liés à la marche avant ne sont pas encore disponibles. </font><font style="vertical-align: inherit;">Dans cette scène particulière, des volumes d'éclairage différés ont été appliqués, puis nous avons rendu les cheveux / visage / yeux de Geralt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose que vous devez savoir sur le brouillard dans «The Witcher 3»: il se compose de deux parties - «couleur du brouillard» et «couleur de l'atmosphère».</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FogResult</span>  
 {</span>  
    float4 paramsFog;     <span class="hljs-comment">// RGB: color, A: influence  </span>
    float4 paramsAerial;  <span class="hljs-comment">// RGB: color, A: influence  </span>
 };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour chaque pièce, il existe trois couleurs: avant, milieu et arrière. </font><font style="vertical-align: inherit;">Autrement dit, dans le tampon constant, il y a des données telles que "FogColorFront", "FogColorMiddle", "AerialColorBack", etc ... Regardons les données entrantes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cd0/55d/0b2cd055d9f6876c57527b9934b3b6ad.png"></div><br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// *** Inputs *** //  </span><font></font>
   float3 FogSunDir = cb12_v38.xyz;  <font></font>
   float3 FogColorFront = cb12_v39.xyz;  <font></font>
   float3 FogColorMiddle = cb12_v40.xyz;  <font></font>
   float3 FogColorBack = cb12_v41.xyz;  <font></font>
     <font></font>
   float4 FogBaseParams = cb12_v42;  <font></font>
   float4 FogDensityParamsScene = cb12_v43;  <font></font>
   float4 FogDensityParamsSky = cb12_v44;  <font></font>
     <font></font>
   float3 AerialColorFront = cb12_v45.xyz;  <font></font>
   float3 AerialColorMiddle = cb12_v46.xyz;  <font></font>
   float3 AerialColorBack = cb12_v47.xyz;  <font></font>
   float4 AerialParams = cb12_v48;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de calculer les couleurs finales, nous devons calculer les vecteurs et les produits scalaires. </font><font style="vertical-align: inherit;">Le shader a accès à la position des pixels dans le monde, à la position de la caméra (cb12 [0] .xyz) et à la direction du brouillard / éclairage (cb12 [38] .xyz). </font><font style="vertical-align: inherit;">Cela nous permet de calculer le produit scalaire du vecteur de la forme et de la direction du brouillard.</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 frag_vec = fragPosWorldSpace.xyz - customCameraPos.xyz;  
   <span class="hljs-keyword">float</span> frag_dist = length(frag_vec);  <font></font>
     <font></font>
   float3 frag_dir = frag_vec / frag_dist;  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> dot_fragDirSunDir = dot(GlobalLightDirection.xyz, frag_dir);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour calculer le gradient de mélange, vous devez utiliser le carré du produit scalaire absolu, puis multiplier à nouveau le résultat par un paramètre qui dépend de la distance:</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 curr_col_fog;  <font></font>
   float3 curr_col_aerial;  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> _dot = dot_fragDirSunDir;  <font></font>
   <font></font>
     <span class="hljs-keyword">float</span> _dd = _dot;  <font></font>
     {  <font></font>
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distOffset = <span class="hljs-number">-150</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distRange = <span class="hljs-number">500</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _mul = <span class="hljs-number">1.0</span> / _distRange;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _bias = _distOffset * _mul;  <font></font>
   <font></font>
       _dd = <span class="hljs-built_in">abs</span>(_dd);  <font></font>
       _dd *= _dd;  <font></font>
       _dd *= saturate( frag_dist * _mul + _bias );  <font></font>
     }  <font></font>
   <font></font>
     curr_col_fog = lerp( FogColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? FogColorFront.xyz : FogColorBack.xyz), _dd );  <font></font>
     curr_col_aerial = lerp( AerialColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? AerialColorFront.xyz : AerialColorBack.xyz), _dd );  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce bloc de code nous indique clairement d'où proviennent ces 0,002 et -0,300. </font><font style="vertical-align: inherit;">Comme on peut le voir, le produit scalaire entre les vecteurs de vue et d'éclairage est responsable du choix entre les couleurs «avant» et «arrière». </font><font style="vertical-align: inherit;">Intelligent! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une visualisation du gradient final résultant (_dd).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f03/ca0/d43f03ca005d504abd5cd236007f34f4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, le calcul de l'effet de l'atmosphère / du brouillard est beaucoup plus compliqué. Comme vous pouvez le voir, nous avons beaucoup plus d'options que les couleurs RVB. Ils incluent, par exemple, la densité des scènes. Nous utilisons le raymarching (16 étapes, et c'est pourquoi le cycle peut être étendu) pour déterminer la taille du brouillard et le facteur d'échelle: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ayant un vecteur [caméra ---&gt; monde], nous pouvons diviser toutes ses composantes en 16 - ce sera une étape de raymarching. Comme nous le voyons ci-dessous, seule la composante .z (hauteur) ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curr_pos_z_step</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est </font><font style="vertical-align: inherit;">impliquée dans les calculs </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En savoir plus sur le brouillard mis en œuvre par raymarching, par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> fog_amount = <span class="hljs-number">1</span>;  
   <span class="hljs-keyword">float</span> fog_amount_scale = <span class="hljs-number">0</span>;  <font></font>
   [branch]  <font></font>
   <span class="hljs-keyword">if</span> ( frag_dist &gt;= AerialParams.y )  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> curr_pos_z_base = (customCameraPos.z + FogBaseParams.y) * density_factor;  
     <span class="hljs-keyword">float</span> curr_pos_z_step = frag_step.z * density_factor;  <font></font>
   <font></font>
     [unroll]  <font></font>
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i=<span class="hljs-number">16</span>; i&gt;<span class="hljs-number">0</span>; --i )  <font></font>
     {  <font></font>
       fog_amount *= <span class="hljs-number">1</span> - saturate( density_sample_scale / (<span class="hljs-number">1</span> + max( <span class="hljs-number">0.0</span>, curr_pos_z_base + (i) * curr_pos_z_step ) ) );  <font></font>
     }  <font></font>
   <font></font>
     fog_amount = <span class="hljs-number">1</span> - fog_amount;  <font></font>
     fog_amount_scale = saturate( (frag_dist - AerialParams.y) * AerialParams.z );  <font></font>
   }  <font></font>
   <font></font>
   FogResult ret;  <font></font>
   <font></font>
   ret.paramsFog = float4 ( curr_col_fog, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_fog ) );  <font></font>
   ret.paramsAerial = float4 ( curr_col_aerial, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_aerial ) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La quantité de brouillard dépend évidemment de la hauteur (composants .z), à la fin la quantité de brouillard est élevée au degré de brouillard / atmosphère. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_fog</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_aerial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont extraits du tampon constant; </font><font style="vertical-align: inherit;">ils vous permettent de contrôler comment les couleurs du brouillard et de l'atmosphère affectent le monde avec une altitude croissante.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contournement de brouillard</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le shader que j'ai trouvé n'a pas le fragment de code d'assembly suivant:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">109</span>:  mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">110</span>:  add r5.xyz, -r3.xyzx, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">111</span>:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  <span class="hljs-number">112</span>:  add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">188</span>].w  
  <span class="hljs-number">113</span>:  mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">114</span>:  mul_sat r5.w, r0.w, r0.z  
  <span class="hljs-number">115</span>:  lt r0.z, l(<span class="hljs-number">0.000000</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">116</span>:  if_nz r0.z  
  <span class="hljs-number">117</span>:   mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">118</span>:   add r6.xyz, -r3.xyzx, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">119</span>:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  <span class="hljs-number">120</span>:   add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">190</span>].w  
  <span class="hljs-number">121</span>:   mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">122</span>:   mul_sat r3.w, r0.w, r0.z  
  <span class="hljs-number">123</span>:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  <span class="hljs-number">124</span>:   mad r5.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r1.xyzw, r5.xyzw  
  <span class="hljs-number">125</span>:  endif</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À en juger par ce que j'ai pu comprendre, cela revient à redéfinir la couleur et l'effet du brouillard: la </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
plupart du temps, une seule redéfinition est effectuée (cb12_v192.x est 0,0), mais dans ce cas particulier, sa valeur est ~ 0,22, nous faisons donc le deuxième remplacement.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc7/2bd/1b8/cc72bd1b8cff0742cf4aad51a7e6ab3f.png"></div><br>
<pre><code class="cpp hljs"> <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OVERRIDE_FOG  </span><font></font>
     <font></font>
   <span class="hljs-comment">// Override  </span>
   <span class="hljs-keyword">float</span> fog_influence = ret.paramsFog.w; <span class="hljs-comment">// r0.w  </span><font></font>
   <font></font>
   <span class="hljs-keyword">float</span> override1ColorScale = cb12_v189.x;  
   <span class="hljs-keyword">float</span> override1ColorBias = cb12_v189.y;  <font></font>
   float3 override1Color = cb12_v188.rgb;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1InfluenceScale = cb12_v189.z;  
   <span class="hljs-keyword">float</span> override1InfluenceBias = cb12_v189.w;  
   <span class="hljs-keyword">float</span> override1Influence = cb12_v188.w;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1ColorAmount = saturate(fog_influence * override1ColorScale + override1ColorBias);  
   <span class="hljs-keyword">float</span> override1InfluenceAmount = saturate(fog_influence * override1InfluenceScale + override1InfluenceBias);    <font></font>
     <font></font>
<font></font>
   float4 paramsFogOverride;  <font></font>
   paramsFogOverride.rgb = lerp(curr_col_fog, override1Color, override1ColorAmount ); <span class="hljs-comment">// ***r5.xyz   </span><font></font>
     <font></font>
   <span class="hljs-keyword">float</span> param1 = lerp(<span class="hljs-number">1.0</span>, override1Influence, override1InfluenceAmount); <span class="hljs-comment">// r0.x  </span>
   paramsFogOverride.w = saturate(param1 * fog_influence ); <span class="hljs-comment">// ** r5.w  </span><font></font>
   <font></font>
     <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> extraFogOverride = cb12_v192.x;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (extraFogOverride &gt; <span class="hljs-number">0.0</span>)  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> override2ColorScale = cb12_v191.x;  
     <span class="hljs-keyword">float</span> override2ColorBias = cb12_v191.y;  <font></font>
     float3 override2Color = cb12_v190.rgb;  <font></font>
     <font></font>
     <span class="hljs-keyword">float</span> override2InfluenceScale = cb12_v191.z;  
     <span class="hljs-keyword">float</span> override2InfluenceBias = cb12_v191.w;  
     <span class="hljs-keyword">float</span> override2Influence = cb12_v190.w;  <font></font>
       <font></font>
     <span class="hljs-keyword">float</span> override2ColorAmount = saturate(fog_influence * override2ColorScale + override2ColorBias);  
     <span class="hljs-keyword">float</span> override2InfluenceAmount = saturate(fog_influence * override2InfluenceScale + override2InfluenceBias);  <font></font>
      <font></font>
<font></font>
     float4 paramsFogOverride2;  <font></font>
     paramsFogOverride2.rgb = lerp(curr_col_fog, override2Color, override2ColorAmount); <span class="hljs-comment">// r3.xyz   </span><font></font>
           <font></font>
     <span class="hljs-keyword">float</span> ov_param1 = lerp(<span class="hljs-number">1.0</span>, override2Influence, override2InfluenceAmount); <span class="hljs-comment">// r0.z  </span>
     paramsFogOverride2.w = saturate(ov_param1 * fog_influence); <span class="hljs-comment">// r3.w  </span><font></font>
   <font></font>
     paramsFogOverride = lerp(paramsFogOverride, paramsFogOverride2, extraFogOverride);  <font></font>
   <font></font>
   }  <font></font>
   ret.paramsFog = paramsFogOverride;  <font></font>
     <font></font>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici notre prix fini sans redéfinition du brouillard (première image), avec une redéfinition (deuxième image) et une double redéfinition (troisième image, résultat final):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/011/3c8/3b90113c8ad27f287cdb29a25a37470d.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03a/791/d39/03a791d39e2082b80e86ea8daa488a64.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Régulation de l'occlusion ambiante</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le shader que j'ai trouvé n'utilisait pas du tout d'occlusion ambiante. </font><font style="vertical-align: inherit;">Jetons un coup d'œil à la texture d'AO et au code qui nous intéresse:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<pre><code class="cpp hljs">  <span class="hljs-number">13</span>:  ld_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r0.x, r0.xyzw, t2.xyzw  
  <span class="hljs-number">14</span>:  max r0.x, r0.x, cb3[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">15</span>:  add r0.yzw, r1.xxyz, -cb12[<span class="hljs-number">0</span>].xxyz  
  <span class="hljs-number">16</span>:  dp3 r1.x, r0.yzwy, r0.yzwy  
  <span class="hljs-number">17</span>:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  <span class="hljs-number">18</span>:  add r1.y, r1.x, -cb3[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">19</span>:  add r1.zw, -cb3[<span class="hljs-number">0</span>].xxxz, cb3[<span class="hljs-number">0</span>].yyyw  
  <span class="hljs-number">20</span>:  div_sat r1.y, r1.y, r1.z  
  <span class="hljs-number">21</span>:  mad r1.y, r1.y, r1.w, cb3[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">22</span>:  add r0.x, r0.x, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">23</span>:  mad r0.x, r1.y, r0.x, l(<span class="hljs-number">1.000000</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette scène n'est peut-être pas le meilleur exemple, car on ne voit pas les détails sur une île lointaine. </font><font style="vertical-align: inherit;">Cependant, jetons un œil au tampon constant, qui est utilisé pour définir la valeur d'occlusion ambiante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/343/c52/af4/343c52af44338628770912801bc3b32c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons par charger AO à partir de la texture, puis exécutons l'instruction max. Dans cette scène, cb3_v1.x est très élevé (0,96888), ce qui rend l'AO très faible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie suivante du code calcule la distance entre les positions de la caméra et les pixels dans le monde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je crois que le code parle parfois de lui-même, alors regardons HLSL, qui fait l'essentiel de cette configuration:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">AdjustAmbientOcclusion</span><span class="hljs-params">(in <span class="hljs-keyword">float</span> inputAO, in <span class="hljs-keyword">float</span> worldToCameraDistance)</span>  
 </span>{  
   <span class="hljs-comment">// *** Inputs *** //  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceStart = cb3_v0.x;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceEnd = cb3_v0.y;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthStart = cb3_v0.z;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthEnd = cb3_v0.w;  <font></font>
      <font></font>
   <span class="hljs-comment">// * Adjust AO  </span>
   <span class="hljs-keyword">float</span> aoDistanceIntensity = linstep( aoDistanceStart, aoDistanceEnd, worldToCameraDistance );  
   <span class="hljs-keyword">float</span> aoStrength = lerp(aoStrengthStart, aoStrengthEnd, aoDistanceIntensity);   
   <span class="hljs-keyword">float</span> adjustedAO = lerp(<span class="hljs-number">1.0</span>, inputAO, aoStrength);  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> adjustedAO;   <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La distance calculée entre la caméra et le monde est utilisée pour la fonction Linstep. </font><font style="vertical-align: inherit;">Nous connaissons déjà cette fonction, elle est apparue dans le shader de nuage de cirrus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, dans le tampon constant, nous avons les valeurs de distance de début / fin AO. </font><font style="vertical-align: inherit;">La sortie de linstep affecte la force de l'AO (ainsi que de cbuffer), et la force affecte la sortie de l'AO. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bref exemple: le pixel est loin, par exemple, la distance est de 500. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linstep renvoie 1,0; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aoStrength est égal à aoStrengthEnd; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il en résulte un retour AO, qui représente environ 77% (force finale) de la valeur d'entrée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'AO entrant pour cette fonction était auparavant soumis à l'opération max.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettre tous ensemble</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir reçu la couleur et l'effet de la couleur du brouillard et de la couleur de l'atmosphère, vous pouvez enfin les combiner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons par atténuer l'effet avec l'AO résultant:</font></font><br>
<br>
<pre><code class="cpp hljs">   ...<font></font>
   FogResult fog = CalculateFog( worldPos, CameraPosition, fogStart, ao, <span class="hljs-literal">false</span> );  <font></font>
      <font></font>
   <span class="hljs-comment">// Apply AO to influence  </span><font></font>
   fog.paramsFog.w *= ao;  <font></font>
   fog.paramsAerial.w *= ao; <font></font>
      <font></font>
   <span class="hljs-comment">// Mix fog with scene color  </span>
   outColor = ApplyFog(fog, colorHDR);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute la magie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opère</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la fonction </font><b><font style="vertical-align: inherit;">ApplyFog</font></b><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function">float3 <span class="hljs-title">ApplyFog</span><span class="hljs-params">(FogResult fog, float3 color)</span>  
 </span>{  
   <span class="hljs-keyword">const</span> float3 LuminanceFactors = float3(<span class="hljs-number">0.333f</span>, <span class="hljs-number">0.555f</span>, <span class="hljs-number">0.222f</span>);  <font></font>
   <font></font>
   float3 aerialColor = dot(LuminanceFactors, color) * fog.paramsAerial.xyz;  <font></font>
   color = lerp(color, aerialColor, fog.paramsAerial.w);  <font></font>
   color = lerp(color, fog.paramsFog.xyz, fog.paramsFog.w);  <font></font>
    <font></font>
   <span class="hljs-keyword">return</span> color.xyz;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous calculons la luminosité des pixels:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bd/b00/570/6bdb005708a11953aeb8ce711a942f0d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous le multiplions par la couleur de l'atmosphère:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/f89/f04/e7df89f04524c4e547a91a645317a387.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous combinons la couleur HDR avec la couleur de l'atmosphère:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/40a/912/cae40a9124b33e97aa38ac5b72b9a5ae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière étape consiste à combiner le résultat intermédiaire avec la couleur du brouillard:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques captures d'écran de débogage</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/b08/e69/012b08e69615702c9267f24f167dfa98.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effet atmosphérique</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/c3a/f2c/b1bc3af2c5d59db606570a54e861659b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur de l'atmosphère</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/b17/0ab/d10b170ab255b3ff9b4d6fad60e1c1e3.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effet de brouillard</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9ae/dde/d769aedde1917ab6024e524d9c99625d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur de brouillard</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/b15/0dd/7adb150dddf4df73c8dc75e51aa9e138.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scène terminée sans brouillard</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/fdc/507/f53fdc5076e000acb24a775ba7558e8a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scène prête à l'emploi avec du brouillard uniquement</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad1/223/e4a/ad1223e4aabc3dc3f07a77125b54211f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La scène terminée n'est que le brouillard principal</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scène prête à l'emploi avec tout le brouillard pour faciliter la comparaison</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que vous pouvez comprendre beaucoup de ce qui précède, si vous regardez le shader, il est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je peux dire avec plaisir que ce shader </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est exactement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le même que celui d'origine - il me fait très plaisir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, le résultat final dépend fortement des valeurs transmises au shader. Ce n'est pas une solution «magique» qui donne des couleurs parfaites pour la sortie, elle nécessite de nombreuses itérations et artistes pour que le résultat final soit décent. Je pense que cela peut être un long processus, mais une fois terminé, le résultat sera très convaincant, tout comme cette scène de coucher de soleil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Witcher 3 Sky Shader utilise également des calculs de brouillard pour créer une transition en douceur des couleurs près de l'horizon. </font><font style="vertical-align: inherit;">Cependant, un ensemble différent de coefficients de densité est transmis au shader du ciel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de vous rappeler - la plupart de ce shader n'a pas été créé / analysé par moi. </font><font style="vertical-align: inherit;">Tous les remerciements doivent être envoyés à CD PROJEKT RED. </font><font style="vertical-align: inherit;">Soutenez-les, ils font un excellent travail.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 3. Étoiles filantes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans The Witcher 3, il y a un détail petit mais curieux - les étoiles filantes. </font><font style="vertical-align: inherit;">Fait intéressant, ils ne semblent pas figurer dans le DLC Blood and Wine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la vidéo, vous pouvez voir à quoi ils ressemblent:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IWtutrr6ilE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment nous avons réussi à obtenir cet effet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, le corps d'une étoile filante est beaucoup plus lumineux que la queue. </font><font style="vertical-align: inherit;">Il s'agit d'une propriété importante que nous utiliserons plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre programme est assez familier: je vais d'abord décrire les propriétés générales, puis je parlerai de sujets liés à la géométrie, et à la fin nous passerons au pixel shader, où les choses les plus intéressantes se produisent.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Aperçu général</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Décrivez brièvement ce qui se passe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les étoiles filantes sont dessinées dans un passage proactif, immédiatement après le dôme du ciel, du ciel et de la lune:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/a71/7db/1c5a717dbd047aeaa183ce2a25e394d9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (720) - le dôme du ciel, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (2160) - la sphère pour le ciel / la lune, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (36) - n'a pas d'importance, ressemble à un parallélépipède de l'occlusion du soleil (?) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (12) - l'étoile filante </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexedInstanced (1116, 1) - nuages ​​cirrus </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les nuages ​​cirrus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , chaque étoile filante est dessinée deux fois de suite.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/27d/e4c/baa27de4ced017770e9c89a01e136abd.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant le premier appel de tirage</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/78b/cef/cc878bcef6dcc4b58e85f3a62f90be31.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat du premier appel de tirage</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ee/33f/f6c/0ee33ff6cef3d11ca7cd460f21dc2b3f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat du deuxième appel de tirage</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En outre, comme dans de nombreux éléments de la passe préemptive de ce jeu, l'état de mélange suivant est utilisé:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Géométrie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes de géométrie, la première chose à mentionner est que chaque étoile filante est représentée par un quadrilatère mince avec texcoords: 4 sommets, 6 indices. </font><font style="vertical-align: inherit;">C'est le quad le plus simple possible.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fbf/96b/82cfbf96bbc652ea5ac32a5e568434a3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quad approximatif d'une étoile filante. Le quadruple approximatif d'une étoile filante est </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/83c/59e/3f7/83c59e3f7e685d6e7f2080e88ff5be25.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encore plus proche. </font><font style="vertical-align: inherit;">Vous pouvez voir l'affichage filaire d'une ligne indiquant deux triangles. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attendez une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il y a </font><i><font style="vertical-align: inherit;">DrawIndexed (12)</font></i><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Est-ce à dire que nous dessinons deux étoiles filantes en même temps? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/b39/bb2/d55b39bb2d2ea5908f4576d6396455fa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cadre, l'une des étoiles filantes est complètement en dehors de la pyramide de visibilité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le code assembleur du vertex shader:</font></font><br>
<br>
<pre><code class="cpp hljs"> vs_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">193</span>], immediateIndexed  <font></font>
    dcl_input v0.xyz  <font></font>
    dcl_input v1.xyzw  <font></font>
    dcl_input v2.xy  <font></font>
    dcl_input v3.xy  <font></font>
    dcl_input v4.xy  <font></font>
    dcl_input v5.xyz  <font></font>
    dcl_input v6.x  <font></font>
    dcl_input v7.x  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_output o1.xyzw  <font></font>
    dcl_output o2.xy  <font></font>
    dcl_output o3.xyzw  <font></font>
    dcl_output_siv o4.xyzw, position  <font></font>
    dcl_temps <span class="hljs-number">5</span>  
   <span class="hljs-number">0</span>: mov r0.xyz, v0.xyzx  
   <span class="hljs-number">1</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
   <span class="hljs-number">2</span>: dp4 r1.x, r0.xyzw, cb2[<span class="hljs-number">0</span>].xyzw  
   <span class="hljs-number">3</span>: dp4 r1.y, r0.xyzw, cb2[<span class="hljs-number">1</span>].xyzw  
   <span class="hljs-number">4</span>: dp4 r1.z, r0.xyzw, cb2[<span class="hljs-number">2</span>].xyzw  
   <span class="hljs-number">5</span>: add r0.x, v2.x, v2.y  
   <span class="hljs-number">6</span>: add r0.y, -v2.y, v2.x  
   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx  
  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  
  <span class="hljs-number">30</span>: add r0.xyz, r0.xyzx, -cb12[<span class="hljs-number">0</span>].xyzx  
  <span class="hljs-number">31</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
  <span class="hljs-number">32</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">33</span>: div r0.xyz, r0.xyzx, r0.wwww  
  <span class="hljs-number">34</span>: add r0.w, r0.w, -cb12[<span class="hljs-number">22</span>].z  
  <span class="hljs-number">35</span>: max r0.w, r0.w, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">36</span>: min r0.w, r0.w, cb12[<span class="hljs-number">42</span>].z  
  <span class="hljs-number">37</span>: dp3 r0.x, cb12[<span class="hljs-number">38</span>].xyzx, r0.xyzx  
  <span class="hljs-number">38</span>: mul r0.y, <span class="hljs-built_in">abs</span>(r0.x), <span class="hljs-built_in">abs</span>(r0.x)  
  <span class="hljs-number">39</span>: mad_sat r1.x, r0.w, l(<span class="hljs-number">0.002000</span>), l(<span class="hljs-number">-0.300000</span>)  
  <span class="hljs-number">40</span>: mul r0.y, r0.y, r1.x  
  <span class="hljs-number">41</span>: lt r1.x, l(<span class="hljs-number">0</span>), r0.x  
  <span class="hljs-number">42</span>: movc r1.yzw, r1.xxxx, cb12[<span class="hljs-number">39</span>].xxyz, cb12[<span class="hljs-number">41</span>].xxyz  
  <span class="hljs-number">43</span>: add r1.yzw, r1.yyzw, -cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">44</span>: mad r1.yzw, r0.yyyy, r1.yyzw, cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">45</span>: movc r2.xyz, r1.xxxx, cb12[<span class="hljs-number">45</span>].xyzx, cb12[<span class="hljs-number">47</span>].xyzx  
  <span class="hljs-number">46</span>: add r2.xyz, r2.xyzx, -cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">47</span>: mad o0.xyz, r0.yyyy, r2.xyzx, cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">48</span>: ge r0.y, r0.w, cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">49</span>: if_nz r0.y  
  <span class="hljs-number">50</span>:  mad r0.y, r0.z, cb12[<span class="hljs-number">22</span>].z, cb12[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">51</span>:  mul r0.z, r0.w, r0.z  
  <span class="hljs-number">52</span>:  mul r0.z, r0.z, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">53</span>:  mul r1.x, r0.w, cb12[<span class="hljs-number">43</span>].x  
  <span class="hljs-number">54</span>:  mul r1.x, r1.x, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">55</span>:  add r0.x, r0.x, cb12[<span class="hljs-number">42</span>].x  
  <span class="hljs-number">56</span>:  add r2.x, cb12[<span class="hljs-number">42</span>].x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>:  div_sat r0.x, r0.x, r2.x  
  <span class="hljs-number">58</span>:  add r2.x, -cb12[<span class="hljs-number">43</span>].z, cb12[<span class="hljs-number">43</span>].y  
  <span class="hljs-number">59</span>:  mad r0.x, r0.x, r2.x, cb12[<span class="hljs-number">43</span>].z  
  <span class="hljs-number">60</span>:  add r0.y, r0.y, cb12[<span class="hljs-number">42</span>].y  
  <span class="hljs-number">61</span>:  mul r2.x, r0.x, r0.y  
  <span class="hljs-number">62</span>:  mul r0.z, r0.x, r0.z  
  <span class="hljs-number">63</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>), r2.xxxx  
  <span class="hljs-number">64</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">65</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">66</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">67</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">68</span>:  mul r2.y, r3.y, r3.x  
  <span class="hljs-number">69</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">70</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">71</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>), r2.xxxx  
  <span class="hljs-number">72</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">73</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">74</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">75</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">76</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">77</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">78</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">79</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">80</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>), r2.xxxx  
  <span class="hljs-number">81</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">82</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">83</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">84</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">85</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">86</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">87</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">88</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">89</span>:  mad r2.zw, r0.zzzz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>), r2.xxxx  
  <span class="hljs-number">90</span>:  max r2.zw, r2.zzzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">91</span>:  add r2.zw, r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">92</span>:  div_sat r2.zw, r1.xxxx, r2.zzzw  
  <span class="hljs-number">93</span>:  add r2.zw, -r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">94</span>:  mul r2.y, r2.z, r2.y  
  <span class="hljs-number">95</span>:  mul r2.y, r2.w, r2.y  
  <span class="hljs-number">96</span>:  mad r2.x, r0.z, l(<span class="hljs-number">2.000000</span>), r2.x  
  <span class="hljs-number">97</span>:  max r2.x, r2.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">98</span>:  add r2.x, r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">99</span>:  div_sat r2.x, r1.x, r2.x  
  <span class="hljs-number">100</span>:  add r2.x, -r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">101</span>:  mul r2.x, r2.x, r2.y  
  <span class="hljs-number">102</span>:  mad r0.x, r0.y, r0.x, r0.z  
  <span class="hljs-number">103</span>:  max r0.x, r0.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">104</span>:  add r0.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">105</span>:  div_sat r0.x, r1.x, r0.x  
  <span class="hljs-number">106</span>:  add r0.x, -r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">107</span>:  mad r0.x, -r2.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">108</span>:  add r0.y, r0.w, -cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">109</span>:  mul_sat r0.y, r0.y, cb12[<span class="hljs-number">48</span>].z  
  <span class="hljs-number">110</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">111</span>:  mov r0.xy, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">112</span>: endif  
  <span class="hljs-number">113</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">114</span>: mul r0.z, r0.x, cb12[<span class="hljs-number">42</span>].w  
  <span class="hljs-number">115</span>: <span class="hljs-built_in">exp</span> r0.z, r0.z  
  <span class="hljs-number">116</span>: mul r0.z, r0.z, r0.y  
  <span class="hljs-number">117</span>: mul r0.x, r0.x, cb12[<span class="hljs-number">48</span>].x  
  <span class="hljs-number">118</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  <span class="hljs-number">119</span>: mul o0.w, r0.x, r0.y  
  <span class="hljs-number">120</span>: mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">121</span>: add r2.xyz, -r1.yzwy, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">122</span>: mad r2.xyz, r0.xxxx, r2.xyzx, r1.yzwy  
  <span class="hljs-number">123</span>: add r0.x, cb12[<span class="hljs-number">188</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">124</span>: mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">125</span>: mul_sat r2.w, r0.x, r0.z  
  <span class="hljs-number">126</span>: lt r0.x, l(<span class="hljs-number">0</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">127</span>: if_nz r0.x  
  <span class="hljs-number">128</span>:  mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">129</span>:  add r3.xyz, -r1.yzwy, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">130</span>:  mad r1.xyz, r0.xxxx, r3.xyzx, r1.yzwy  
  <span class="hljs-number">131</span>:  add r0.x, cb12[<span class="hljs-number">190</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">132</span>:  mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">133</span>:  mul_sat r1.w, r0.x, r0.z  
  <span class="hljs-number">134</span>:  add r0.xyzw, -r2.xyzw, r1.xyzw  
  <span class="hljs-number">135</span>:  mad o1.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r0.xyzw, r2.xyzw  
  <span class="hljs-number">136</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">137</span>:  mov o1.xyzw, r2.xyzw  
  <span class="hljs-number">138</span>: endif  
  <span class="hljs-number">139</span>: mov o3.xyzw, v1.xyzw  
  <span class="hljs-number">140</span>: mov o2.xy, v4.yxyy  
  <span class="hljs-number">141</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, le calcul du brouillard peut immédiatement attirer l'attention (lignes 30-138). Le calcul du sommet du brouillard est logique pour des raisons de performances. De plus, nous n'avons pas besoin d'une telle précision du brouillard - les météorites survolent généralement la tête de Geralt et n'atteignent pas l'horizon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les paramètres atmosphériques (rgb = couleur, a = influence) sont stockés dans o0.xyzw, et les paramètres de brouillard dans o1.xyzw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o2.xy (ligne 140) est juste des texcoords. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o3.xyzw (ligne 139) n'est pas pertinent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, disons quelques mots sur le calcul d'une position dans le monde. Les vertex shaders effectuent des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panneaux d'affichage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout d'abord, les données entrantes pour les panneaux d'affichage proviennent du tampon de vertex - jetons-y un œil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les premières données sont Position:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/470/7d5/99a4707d5f914222e7d55e2435f5692f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionné ci-dessus, nous avons ici 2 quad-a: 8 sommets, 12 indices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pourquoi la position est-elle la même pour chaque quad? </font><font style="vertical-align: inherit;">Assez simple - c'est la position du centre du quad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, chaque sommet a un décalage du centre vers le bord du quad:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cde/fdf/7e0/cdefdf7e0e5cfe91c4b9d20257b529b4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que chaque étoile filante a une taille de (400, 3) unités dans l'espace mondial. </font><font style="vertical-align: inherit;">(sur le plan XY, dans Witcher 3, l'axe Z est dirigé vers le haut) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le dernier élément de chaque sommet est un vecteur de direction unitaire dans l'espace mondial qui contrôle le mouvement d'une étoile filante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/416/06d/71a/41606d71a99d2f751f8b1d5a609b6c96.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que les données proviennent du CPU, il est difficile de comprendre comment elles sont calculées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant au code d'affichage. </font><font style="vertical-align: inherit;">L'idée est assez simple - vous obtenez d'abord un vecteur unitaire du centre du quad à la caméra:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous obtenons un seul vecteur tangent qui contrôle le mouvement de l'étoile filante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etant donné que ce vecteur est déjà normalisé côté CPU, cette normalisation est redondante.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il y a deux vecteurs, un produit vectoriel est utilisé pour déterminer le vecteur bi-tangent perpendiculaire aux deux vecteurs entrants.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant des vecteurs normalisés </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangents</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r3.xyz) et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitangents</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r2.xyz). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduisons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xsize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ysize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondant à l'élément entrant TEXCOORD1, donc par exemple (-200, 1.50). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le calcul final de la position dans l'espace mondial est effectué comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que r0.x, r0.y et r0.z sont égaux à 1,0, le calcul final est simplifié: </font></font><br>
<br>
<code>worldSpacePosition = quadCenter + tangent * Xsize + bitangent * Ysize</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière partie est une simple multiplication d'une position dans l'espace mondial par une matrice de projection de vue pour obtenir SV_Position:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Pixel Shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme indiqué dans la section Présentation générale, l'état de fusion suivant est utilisé: </font><font style="vertical-align: inherit;">
où </font><i><font style="vertical-align: inherit;">SrcColor</font></i><font style="vertical-align: inherit;"> et </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> sont respectivement les composants .rgb et .a du pixel shader et </font><i><font style="vertical-align: inherit;">DestColor est la</font></i><font style="vertical-align: inherit;"> couleur </font><i><font style="vertical-align: inherit;">.rgb</font></i><font style="vertical-align: inherit;"> actuellement dans le rendu cible. </font><font style="vertical-align: inherit;">
Le principal indicateur qui contrôle la transparence est </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> . De nombreux shaders de jeu proactifs le calculent comme l'opacité et l'appliquent à la fin comme suit: Le </font><font style="vertical-align: inherit;">
shader d'étoiles filantes ne fait pas exception. En suivant ce modèle, nous considérons trois cas dans lesquels l' </font><i><font style="vertical-align: inherit;">opacité</font></i><font style="vertical-align: inherit;"> est de 1,0, 0,1 et 0,0.</font></font><br>
<br>
<code>FinalColor = SrcColor * One + DestColor * (1.0 - SrcAlpha) =<br>
FinalColor = SrcColor + DestColor * (1.0 - SrcAlpha)</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>return float4( color * opacity, opacity )</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>a) opacity = 1.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = color = SrcColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/934/711/31c/93471131c99ec7b2249cff6edb698859.jpg"></div><br>
<code>b) opacity = 0.1<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = 0.1 * color + 0.9 * DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/269/b24/d90/269b24d90592abb5065fba0f2a0aaf9f.jpg"></div><br>
<code>c) opacity = 0.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/191/75e/b6e/19175eb6e6757c04a0a063e75bad96f2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'idée sous-jacente de ce shader est de modéliser et d'utiliser l'opacité de la fonction d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacité (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui contrôle l'opacité d'un pixel le long d'une étoile filante. La principale exigence est que l'opacité atteigne des valeurs maximales à l'extrémité de l'étoile (son «corps») et passe progressivement à 0,0 (à sa «queue»). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous commençons à comprendre le code assembleur du pixel shader, cela devient évident:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_input_ps linear v0.xyzw  <font></font>
    dcl_input_ps linear v1.xyzw  <font></font>
    dcl_input_ps linear v2.y  <font></font>
    dcl_input_ps linear v3.w  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_temps <span class="hljs-number">4</span>  
   <span class="hljs-number">0</span>: mov_sat r0.x, v2.y  
   <span class="hljs-number">1</span>: ge r0.y, r0.x, l(<span class="hljs-number">0.052579</span>)  
   <span class="hljs-number">2</span>: ge r0.z, l(<span class="hljs-number">0.965679</span>), r0.x  
   <span class="hljs-number">3</span>: <span class="hljs-keyword">and</span> r0.y, r0.z, r0.y  
   <span class="hljs-number">4</span>: if_nz r0.y  
   <span class="hljs-number">5</span>:  ge r0.y, l(<span class="hljs-number">0.878136</span>), r0.x  
   <span class="hljs-number">6</span>:  add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)  
   <span class="hljs-number">7</span>:  mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)  
   <span class="hljs-number">8</span>:  mov_sat r0.z, r1.w  
   <span class="hljs-number">9</span>:  mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">10</span>:  mul r0.z, r0.z, r0.z  
  <span class="hljs-number">11</span>:  mul r0.z, r0.z, r0.w  
  <span class="hljs-number">12</span>:  mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">13</span>:  mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">14</span>:  movc r2.yzw, r0.yyyy, r1.yyzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">15</span>:  <span class="hljs-keyword">not</span> r0.z, r0.y  
  <span class="hljs-number">16</span>:  if_z r0.y  
  <span class="hljs-number">17</span>:   ge r0.y, l(<span class="hljs-number">0.924339</span>), r0.x  
  <span class="hljs-number">18</span>:   add r0.w, r0.x, l(<span class="hljs-number">-0.878136</span>)  
  <span class="hljs-number">19</span>:   mul r1.w, r0.w, l(<span class="hljs-number">21.643608</span>)  
  <span class="hljs-number">20</span>:   mov_sat r0.w, r1.w  
  <span class="hljs-number">21</span>:   mad r3.x, r0.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">22</span>:   mul r0.w, r0.w, r0.w  
  <span class="hljs-number">23</span>:   mul r0.w, r0.w, r3.x  
  <span class="hljs-number">24</span>:   mad r1.x, r0.w, l(<span class="hljs-number">0.889658</span>), l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">25</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">26</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">27</span>:  <span class="hljs-keyword">else</span>  
  <span class="hljs-number">28</span>:   mov r2.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">29</span>:   mov r0.y, l(<span class="hljs-number">-1</span>)  
  <span class="hljs-number">30</span>:  endif  
  <span class="hljs-number">31</span>:  <span class="hljs-keyword">not</span> r0.w, r0.y  
  <span class="hljs-number">32</span>:  <span class="hljs-keyword">and</span> r0.z, r0.w, r0.z  
  <span class="hljs-number">33</span>:  if_nz r0.z  
  <span class="hljs-number">34</span>:   ge r0.y, r0.x, l(<span class="hljs-number">0.924339</span>)  
  <span class="hljs-number">35</span>:   add r0.x, r0.x, l(<span class="hljs-number">-0.924339</span>)  
  <span class="hljs-number">36</span>:   mul r1.w, r0.x, l(<span class="hljs-number">24.189651</span>)  
  <span class="hljs-number">37</span>:   mov_sat r0.x, r1.w  
  <span class="hljs-number">38</span>:   mad r0.z, r0.x, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">39</span>:   mul r0.x, r0.x, r0.x  
  <span class="hljs-number">40</span>:   mul r0.x, r0.x, r0.z  
  <span class="hljs-number">41</span>:   mad r1.x, r0.x, l(<span class="hljs-number">-0.974300</span>), l(<span class="hljs-number">0.974300</span>)  
  <span class="hljs-number">42</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">43</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">44</span>:  endif  
  <span class="hljs-number">45</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">46</span>:  mov r2.yzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">47</span>:  mov r0.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">48</span>: endif  
  <span class="hljs-number">49</span>: mov_sat r2.w, r2.w  
  <span class="hljs-number">50</span>: mad r0.x, r2.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">51</span>: mul r0.z, r2.w, r2.w  
  <span class="hljs-number">52</span>: mul r0.x, r0.z, r0.x  
  <span class="hljs-number">53</span>: add r0.z, -r2.y, r2.z  
  <span class="hljs-number">54</span>: mad r0.x, r0.x, r0.z, r2.y  
  <span class="hljs-number">55</span>: movc r0.x, r0.y, r2.x, r0.x  
  <span class="hljs-number">56</span>: mad r0.y, cb4[<span class="hljs-number">1</span>].x, -cb0[<span class="hljs-number">9</span>].w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>: mul_sat r0.y, r0.y, v3.w  
  <span class="hljs-number">58</span>: mul r0.x, r0.y, r0.x  
  <span class="hljs-number">59</span>: mul r0.yzw, cb2[<span class="hljs-number">2</span>].xxyz, cb4[<span class="hljs-number">0</span>].xxxx  
  <span class="hljs-number">60</span>: mul r0.x, r0.x, cb2[<span class="hljs-number">2</span>].w  
  <span class="hljs-number">61</span>: dp3 r1.x, l(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>), r0.yzwy  
  <span class="hljs-number">62</span>: mad r1.xyz, r1.xxxx, v0.xyzx, -r0.yzwy  
  <span class="hljs-number">63</span>: mad r0.yzw, v0.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">64</span>: add r1.xyz, -r0.yzwy, v1.xyzx  
  <span class="hljs-number">65</span>: mad r0.yzw, v1.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">66</span>: mul o0.xyz, r0.xxxx, r0.yzwy  
  <span class="hljs-number">67</span>: mov o0.w, r0.x  
  <span class="hljs-number">68</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, le shader est un peu trop compliqué et il était difficile pour moi de comprendre ce qui s'y passait. </font><font style="vertical-align: inherit;">Par exemple, d'où viennent toutes les valeurs comme 1.211303, 21.643608 et 24.189651? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous parlons de la fonction d'opacité, nous avons besoin d'une valeur d'entrée. </font><font style="vertical-align: inherit;">C'est assez simple - texcoord dans la plage de [0,1] (ligne 0) sera utile ici, afin que nous puissions appliquer la fonction à toute la longueur du météoroïde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction d'opacité a trois segments / intervalles définis par quatre points de contrôle:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// current status: no idea how these are generated  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint0 = <span class="hljs-number">0.052579</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint1 = <span class="hljs-number">0.878136</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint2 = <span class="hljs-number">0.924339</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint3 = <span class="hljs-number">0.965679</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai aucune idée de la façon dont ils ont été sélectionnés / calculés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous pouvons le voir dans le code assembleur, la première condition est simplement de vérifier si la valeur d'entrée est dans la plage [controlPoint0 - controlPoint3]. </font><font style="vertical-align: inherit;">Sinon, l'opacité n'est que de 0,0.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Input for the opacity function</span>
   <span class="hljs-keyword">float</span> y = saturate(Input.Texcoords.y);  <span class="hljs-comment">// r0.x</span><font></font>
     <font></font>
   <span class="hljs-comment">// Value of opacity function.  </span>
   <span class="hljs-comment">// 0 - no change  </span>
   <span class="hljs-comment">// 1 - full color  </span>
   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
      ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le déchiffrement du code assembleur ci-dessous est </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessaire</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si nous voulons comprendre comment fonctionne la fonction d'opacité:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">6</span>: add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)   
   <span class="hljs-number">7</span>: mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)   
   <span class="hljs-number">8</span>: mov_sat r0.z, r1.w   
   <span class="hljs-number">9</span>: mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)   
  <span class="hljs-number">10</span>: mul r0.z, r0.z, r0.z   
  <span class="hljs-number">11</span>: mul r0.z, r0.z, r0.w   
  <span class="hljs-number">12</span>: mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ligne 9 a les coefficients «-2,0» et «3,0», ce qui indique l'utilisation de la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Oui, c'est une bonne supposition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction HLSL smoothstep avec prototype: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ret smoothstep (min, max, x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limite toujours </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x à</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. Du point de vue de l'assembleur, cela soustrait </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la valeur d'entrée (c'est-à-dire de r0.z sur la ligne 9), mais il n'y a rien de tel dans le code. Pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cela implique une multiplication de la valeur d'entrée, mais il n'y a rien de tel que «mul_sat» dans le code. Au lieu de cela, il y a «mov_sat». Cela nous dit que les fonctions </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du smoothstep sont 0 et 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons maintenant que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être dans l'intervalle [0, 1]. Comme indiqué ci-dessus, la fonction d'opacité comprend trois segments. Cela indique clairement que le code cherche où nous en sommes dans l'intervalle [segmentStart-segmentEnd]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La réponse est la fonction Linstep!</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">(<span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v)</span>  
 </span>{  
   <span class="hljs-keyword">return</span> ( (v-min) / (max-min) );  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, prenons le premier segment: [0,052579 - 0,878136]. </font><font style="vertical-align: inherit;">La soustraction est sur la ligne 6. Si nous remplaçons la division par la multiplication -&gt; 1,0 / (0,878136 - 0,052579) = 1,0 / 0,825557 = ~ 1,211303. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat du lissage est dans la plage [0, 1]. </font><font style="vertical-align: inherit;">La multiplication sur la ligne 12 est le poids du segment. </font><font style="vertical-align: inherit;">Chaque segment a son propre poids, vous permettant de contrôler l'opacité maximale de ce segment particulier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que pour le premier segment [0,052579 - 0,878136], l'opacité est dans la plage [0 - 0,084642]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction HLSL qui calcule l'opacité pour un segment arbitraire peut être écrite comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getOpacityFunctionValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> cpLeft, <span class="hljs-keyword">float</span> cpRight, <span class="hljs-keyword">float</span> weight)</span>  
 </span>{  
   <span class="hljs-keyword">float</span> val = smoothstep( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, linstep(cpLeft, cpRight, x) );  
   <span class="hljs-keyword">return</span> val * weight;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, le but est simplement d'appeler cette fonction pour le segment correspondant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez un œil aux poids:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight0 = <span class="hljs-number">0.084642</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight1 = <span class="hljs-number">0.889658</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight2 = <span class="hljs-number">0.974300</span>; <span class="hljs-comment">// note: weight0+weight1 = weight2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon le code assembleur, la fonction d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacité (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">calculée comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
     <span class="hljs-comment">// Range of v: [0, weight0]  </span>
     <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint0, controlPoint1, weight0);  <font></font>
     opacity = v;  <font></font>
     <font></font>
     [branch]  <font></font>
     <span class="hljs-keyword">if</span> ( y &gt;= controlPoint1 )  <font></font>
     {  <font></font>
       <span class="hljs-comment">// Range of v: [0, weight1]  </span>
       <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint1, controlPoint2, weight1);  <font></font>
       opacity = weight0 + v;  <font></font>
   <font></font>
       [branch]  <font></font>
       <span class="hljs-keyword">if</span> (y &gt;= controlPoint2)  <font></font>
       {  <font></font>
         <span class="hljs-comment">// Range of v: [0, weight2]  </span>
         <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint2, controlPoint3, weight2);<font></font>
         opacity = weight2 - v;          <font></font>
       }  <font></font>
     }  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un graphique de la fonction d'opacité. </font><font style="vertical-align: inherit;">Vous pouvez facilement voir une forte augmentation de l'opacité, indiquant le début du corps d'une étoile filante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/326/1f0/5da3261f0f88fa41ac963ca84fc79f99.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction d'opacité du graphique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal rouge - valeur d'opacité </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal vert - points de contrôle </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal bleu - poids</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Après le calcul de l'opacité, tout le reste n'est que la touche finale. </font><font style="vertical-align: inherit;">Il y a ensuite des multiplications supplémentaires: l'opacité des étoiles, la couleur de l'étoile filante et l'influence du brouillard. </font><font style="vertical-align: inherit;">Comme d'habitude dans les shaders TW3, vous pouvez également trouver des multiplications redondantes par 1.0 ici:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// cb4_v1.x = 1.0  </span>
   <span class="hljs-keyword">float</span> starsOpacity = <span class="hljs-number">1.0</span> - cb0_v9.w * cb4_v1.x;    <font></font>
   opacity *= starsOpacity;  <font></font>
<font></font>
   <span class="hljs-comment">// Calculate color of a shooting star  </span>
   <span class="hljs-comment">// cb4_v0.x = 10.0</span>
   <span class="hljs-comment">// cb2_v2.rgb = (1.0, 1.0, 1.0)</span><font></font>
   float3 color = cb2_v2.rgb * cb4_v0.x;<font></font>
     <font></font>
   <span class="hljs-comment">// cb2_v2.w = 1  </span><font></font>
   opacity *= cb2_v2.w;<font></font>
     <font></font>
   FogResult fr = { Input.FogParams, Input.AerialParams };  <font></font>
   color = ApplyFog(fr, color);<font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4( color*opacity, opacity);  <font></font>
 }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Résumé</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La principale difficulté réside dans la partie avec la fonction d'opacité. Après l'avoir décodé, tout le reste est assez simple à comprendre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai dit plus haut que le pixel shader était un peu trop compliqué. En fait, nous nous soucions uniquement de la valeur de la fonction d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacité (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est stockée dans r2.x (à partir de la ligne 49). Cependant, la fonction d'opacité dans le code assembleur crée trois variables supplémentaires: minRange (r2.y), maxRange (r2.z) et value (r2.w). Tous sont des paramètres utilisés pour calculer l'opacité lorsque l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacité (x) n'est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas utilisée: </font></font><br>
<br>
<code>lerp( minRange, maxRange, smoothstep(0, 1, value) );</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en fait, la valeur finale de l'opacité est obtenue dans la branche conditionnelle de la ligne 55 - si la valeur d'entrée est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est dans la plage [controlPoint0 - controlPoint3], cela signifie que la fonction d'opacité est utilisée, donc r2.x est sélectionné. </font><font style="vertical-align: inherit;">Sinon, lorsque </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est en dehors de l'intervalle, l'opacité est calculée à partir de r0.x, c'est-à-dire selon l'équation ci-dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai débogué quelques pixels en dehors de l'intervalle [controlPoint0 - controlPoint3], et l'opacité finale s'est toujours avérée être nulle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout pour aujourd'hui. </font><font style="vertical-align: inherit;">Et comme toujours, merci d'avoir lu.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489092/index.html">Comment j'ai indépendamment appris une nouvelle langue en 12 mois: un guide complet</a></li>
<li><a href="../fr489100/index.html">Analyse des données sur le coronavirus du SRAS-CoV-2 (2019-nCov)</a></li>
<li><a href="../fr489102/index.html">Fausses vie d'écran. "Oui, je connais personnellement Madonna"</a></li>
<li><a href="../fr489106/index.html">Comment j'ai quitté le journalisme et suis devenu programmeur</a></li>
<li><a href="../fr489108/index.html">Ajout de vos champs à un rapport Pytest</a></li>
<li><a href="../fr489122/index.html">Requêtes OData typées dans TypeScript</a></li>
<li><a href="../fr489128/index.html">Internationalisation: comment amener le produit sur le marché international (et ne pas devenir fou)</a></li>
<li><a href="../fr489132/index.html">Points forts des systèmes intégrés Europe 2020</a></li>
<li><a href="../fr489134/index.html">Recherche des équipes de conception dans les entreprises alimentaires russes</a></li>
<li><a href="../fr489136/index.html">Gagner avec vingt lignes Haskell: écrire votre Wc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>