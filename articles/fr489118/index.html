<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöî üë®‚Äçüè≠ ü•ì L'ing√©nierie inverse du rendu de The Witcher 3: divers effets du ciel üìù üò≤ üåù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Parties pr√©c√©dentes de l'analyse: premi√®re , deuxi√®me et troisi√®me .]
 
 Partie 1. Nuages ‚Äã‚Äãde Cirrus
 Lorsque le jeu se d√©roule dans des espaces ouv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>L'ing√©nierie inverse du rendu de The Witcher 3: divers effets du ciel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489118/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Parties pr√©c√©dentes de l'analyse: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premi√®re</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxi√®me</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">troisi√®me</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .]</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1. Nuages ‚Äã‚Äãde Cirrus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le jeu se d√©roule dans des espaces ouverts, l'un des facteurs d√©terminant la cr√©dibilit√© du monde est le ciel. Pensez-y - la plupart du temps, le ciel occupe litt√©ralement environ 40 √† 50% de tout l'√©cran. Le ciel est bien plus qu'un beau d√©grad√©. Il a des √©toiles, le soleil, la lune et enfin des nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que les tendances actuelles semblent consister en un rendu volum√©trique des nuages ‚Äã‚Äã√† l'aide du raymarching (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cet article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), les nuages ‚Äã‚Äãdans The Witcher 3 sont enti√®rement bas√©s sur la texture. Je les ai d√©j√† examin√©s auparavant, mais il s'est av√©r√© qu'avec eux, tout est plus compliqu√© que ce √† quoi je m'attendais √† l'origine. Si vous avez suivi ma s√©rie d'articles, vous savez qu'il y a une diff√©rence entre le DLC Blood and Wine et le reste du jeu. Et, comme vous pouvez le deviner, il y a quelques changements dans le travail avec les nuages ‚Äã‚Äãdans le DLC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Witcher 3 a plusieurs couches de nuages. Selon la m√©t√©o, il ne peut s'agir que de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cirrus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cumulus √©lev√©s</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √©ventuellement de quelques nuages ‚Äã‚Äãde la famille des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuages ‚Äã‚Äãen couches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (par exemple lors d'une temp√™te). En fin de compte, il peut ne pas y avoir de nuages ‚Äã‚Äãdu tout.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains calques diff√®rent en termes de textures et de shaders utilis√©s pour les rendre. De toute √©vidence, cela affecte la complexit√© et la longueur du code assembleur pour le pixel shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgr√© toute cette diversit√©, il existe certains mod√®les communs qui peuvent √™tre observ√©s lors du rendu des nuages ‚Äã‚Äãdans Witcher 3. Tout d'abord, ils sont tous rendus dans une passe proactive, et c'est le choix parfait. Tous utilisent le m√©lange (voir ci-dessous). Cela rend beaucoup plus facile de contr√¥ler la fa√ßon dont un calque s√©par√© recouvre le ciel - cela est affect√© par la valeur alpha du pixel shader.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus int√©ressant, certains calques sont rendus deux fois avec les m√™mes param√®tres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir regard√© le code, j'ai choisi le shader le plus court afin (1) d'effectuer probablement son reverse engineering complet, (2) de comprendre tous ses aspects. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai regard√© de plus pr√®s les nuages ‚Äã‚Äãde cirrus de Witcher 3: Blood and Wine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple de cadre:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f81/eb8/a49/f81eb8a49dc315ef04d72b582fba869b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant le rendu</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/b27/206/885b2720624e7a455987bb6239d0e371.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s la premi√®re passe de rendu</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s la deuxi√®me passe de rendu</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans ce cadre particulier, les nuages ‚Äã‚Äãde cirrus sont la premi√®re couche du rendu. </font><font style="vertical-align: inherit;">Comme vous pouvez le voir, il est rendu deux fois, ce qui augmente sa luminosit√©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader g√©om√©trique et vertex</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant le pixel shader, nous parlerons bri√®vement des shaders g√©om√©triques et vertex utilis√©s. </font><font style="vertical-align: inherit;">Le maillage pour l'affichage des nuages ‚Äã‚Äãest un peu comme un d√¥me de ciel ordinaire:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/774/8de/b4c7748de95ad07f2dddfc090e62e0d2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les sommets sont dans l'intervalle [0-1], donc pour centrer le maillage sur le point (0,0,0), la mise √† l'√©chelle et la d√©viation sont utilis√©es avant la conversion en worldViewProj (nous connaissons d√©j√† ce mod√®le des parties pr√©c√©dentes de la s√©rie). </font><font style="vertical-align: inherit;">Dans le cas des nuages, le maillage s'√©tire fortement le long du plan XY (l'axe Z pointe vers le haut) pour couvrir plus d'espace que la pyramide de visibilit√©. </font><font style="vertical-align: inherit;">Le r√©sultat est le suivant:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/0ca/95e/3410ca95ea9f0b3ef1fafe62cb5dba13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, le maillage a des vecteurs normaux et tangents. </font><font style="vertical-align: inherit;">Le vertex shader calcule √©galement le vecteur bi-tangent par le produit vectoriel - les trois sont affich√©s sous une forme normalis√©e. </font><font style="vertical-align: inherit;">Il y a aussi un calcul sup√©rieur du brouillard (sa couleur et sa luminosit√©).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code d'assemblage du pixel shader ressemble √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">238</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">13</span>], immediateIndexed  <font></font>
    dcl_sampler s0, <span class="hljs-function">mode_default  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    dcl_input_ps linear v0.xyzw  
    dcl_input_ps linear v1.xyzw  
    dcl_input_ps linear v2.w  
    dcl_input_ps linear v3.xyzw  
    dcl_input_ps linear v4.xyz  
    dcl_input_ps linear v5.xyz  
    dcl_output o0.xyzw  
    dcl_temps 4  
   0: mul r0.xyz, cb0[9].xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
   1: dp3 r0.w, r0.xyzx, r0.xyzx  
   2: rsq r0.w, r0.w  
   3: mul r0.xyz, r0.wwww, r0.xyzx  
   4: mul r1.xy, cb0[0].xxxx, cb4[5].xyxx  
   5: mad r1.xy, v1.xyxx, cb4[4].xyxx, r1.xyxx  
   6: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.xyzw, r1.xyxx, t0.xyzw, s0  
   7: add r1.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)</span>  
   8: add r1.xyz, r1.xyzx, r1.xyzx  
   9: dp3 r0.w, r1.xyzx, r1.xyzx  
  10: rsq r0.w, r0.w  
  11: mul r1.xyz, r0.wwww, r1.xyzx  
  12: mul r2.xyz, r1.yyyy, v3.xyzx  
  13: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  14: mov r3.xy, v1.zwzz  
  15: mov r3.z, v3.w  
  16: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  
  17: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  18: add r0.y, -cb4[2].x, cb4[3].x  
  19: mad r0.x, r0.x, r0.y, cb4[2].x  
  20: dp2 r0.y, -cb0[9].xyxx, -cb0[9].xyxx  
  21: rsq r0.y, r0.y  
  22: mul r0.yz, r0.yyyy, -cb0[9].xxyx  
  23: add r1.xyz, -v4.xyzx, cb1[8].xyzx  
  24: dp3 r0.w, r1.xyzx, r1.xyzx  
  25: rsq r1.z, r0.w  
  26: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  27: add r0.w, r0.w, -cb4[7].x  
  28: mul r1.xy, r1.zzzz, r1.xyxx  
  29: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  30: add r0.y, r0.y, r0.y  
  31: min r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  32: add r0.z, -cb4[0].x, cb4[1].x  
  33: mad r0.z, r0.y, r0.z, cb4[0].x  
  34: mul r0.x, r0.x, r0.z  
  35: <span class="hljs-built_in">log</span> r0.x, r0.x  
  36: mul r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.200000</span>)</span>  
  37: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  38: add r1.xyz, cb12[236].xyzx, -cb12[237].xyzx  
  39: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[237].xyzx  
  40: mul r2.xyz, r0.xxxx, r1.xyzx  
  41: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  42: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  
  43: add r1.x, -cb4[7].x, cb4[8].x  
  44: div_sat r0.w, r0.w, r1.x  
  45: mul r1.x, r1.w, cb4[9].x  
  46: mad r1.y, -cb4[9].x, r1.w, r1.w  
  47: mad r0.w, r0.w, r1.y, r1.x  
  48: mul r1.xy, cb0[0].xxxx, cb4[11].xyxx  
  49: mad r1.xy, v1.xyxx, cb4[10].xyxx, r1.xyxx  
  50: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r1.xyxx, t1.xyzw, s0  
  51: mad r1.x, r1.x, cb4[12].x, -cb4[12].x  
  52: mad_sat r1.x, cb4[12].x, v2.w, r1.x  
  53: mul r0.w, r0.w, r1.x  
  54: mul_sat r0.w, r0.w, cb4[6].x  
  55: mul o0.xyz, r0.wwww, r0.xyzx  
  56: mov o0.w, r0.w  
  57: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux textures sans couture sont entr√©es. </font><font style="vertical-align: inherit;">L'un d'eux contient une carte normale (canaux </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xyz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et une forme de nuage (canal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Le second est le bruit qui d√©forme la forme.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f3/c27/a5e/1f3c27a5eea1412d5fa1fa632861a342.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte normale, propri√©t√© CD Projekt Red</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37b/a53/d41/37ba53d412d20f476ddf71e81892b62a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forme de nuage, propri√©t√© CD Projekt Red</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/1bb/edd/05e1bbedded7c16acefc1f67d5b3fd49.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture de bruit, propri√©t√© de CD Projekt Red</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le tampon principal des constantes avec param√®tres de nuage est cb4. </font><font style="vertical-align: inherit;">Pour ce cadre, il a les significations suivantes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/229/4de/9422294de7d9ead5e2bec154eb897c7a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, d'autres valeurs provenant d'autres tampons sont utilis√©es. </font><font style="vertical-align: inherit;">Ne vous inqui√©tez pas, nous les consid√©rerons √©galement.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lumi√®re du soleil invers√©e direction Z</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re chose qui se produit dans le shader est le calcul de la direction normalis√©e de la lumi√®re solaire invers√©e le long de l'axe Z:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">0</span>: mul r0.xyz, cb0[<span class="hljs-number">9</span>].xyzx, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)  
   <span class="hljs-number">1</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
   <span class="hljs-number">2</span>: rsq r0.w, r0.w  
   <span class="hljs-number">3</span>: mul r0.xyz, r0.wwww, r0.xyzx  <font></font>
<font></font>
   float3 invertedSunlightDir = normalize(lightDir * float3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionn√© pr√©c√©demment, l'axe Z est dirig√© vers le haut et cb0 [9] est la direction de la lumi√®re solaire. </font><font style="vertical-align: inherit;">Ce vecteur est destin√© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soleil - c'est important! </font><font style="vertical-align: inherit;">Vous pouvez le v√©rifier en √©crivant un shader de calcul simple qui ex√©cute un NdotL simple et en l'ins√©rant dans la passe de shader diff√©r√©e.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âchantillonnage de la texture des nuages</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©tape suivante consiste √† calculer des texcoords pour √©chantillonner la texture du nuage, d√©compresser le vecteur normal et le normaliser.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">4</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">5</span>].xyxx   
   <span class="hljs-number">5</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">4</span>].xyxx, r1.xyxx   
   <span class="hljs-number">6</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyzw, r1.xyxx, t0.xyzw, s0   
   <span class="hljs-number">7</span>: add r1.xyz, r1.xyzx, l(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)   
   <span class="hljs-number">8</span>: add r1.xyz, r1.xyzx, r1.xyzx   
   <span class="hljs-number">9</span>: dp3 r0.w, r1.xyzx, r1.xyzx   
  <span class="hljs-number">10</span>: rsq r0.w, r0.w   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords  </span><font></font>
   float2 cloudTextureUV = Texcoords * textureScale + elapsedTime * speedFactors;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span><font></font>
   float4 cloudTextureValue = texture0.Sample( sampler0, cloudTextureUV ).rgba;  <font></font>
   float3 normalMap = cloudTextureValue.xyz;  <font></font>
   <span class="hljs-keyword">float</span> cloudShape = cloudTextureValue.a;  <font></font>
   <font></font>
   <span class="hljs-comment">// Unpack normal and normalize it  </span>
   float3 unpackedNormal = (normalMap - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;  <font></font>
   unpackedNormal = normalize(unpackedNormal);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traitons-le progressivement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour obtenir le mouvement des nuages, nous avons besoin du temps √©coul√© en secondes ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) multipli√© par le coefficient de vitesse, ce qui affecte la vitesse √† laquelle les nuages ‚Äã‚Äãse d√©placent dans le ciel ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [5] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit plus t√¥t, les UV sont √©tir√©s le long de la g√©om√©trie du d√¥me du ciel, et nous avons √©galement besoin de facteurs d'√©chelle de texture qui affectent la taille des nuages ‚Äã‚Äã( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [4] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La formule finale est:</font></font><br>
<br>
<pre><code class="cpp hljs">samplingUV = Input.TextureUV * textureScale + time * speedMultiplier;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir √©chantillonn√© les 4 canaux, nous avons une carte normale (canaux RVB) et une forme de nuage (canal a). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour d√©compresser la carte normale de l'intervalle [0; </font><font style="vertical-align: inherit;">1] dans l'intervalle [-1; </font><font style="vertical-align: inherit;">1] nous utilisons la formule suivante:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = (packedNormal - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez √©galement utiliser ceci:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = packedNormal * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, nous normalisons le vecteur normal d√©compress√©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposer les normales</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant les vecteurs normaux, les vecteurs tangents et bi-tangents du vertex shader et le vecteur normal de la carte normale, nous cartographions normalement les normales.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: mul r1.xyz, r0.wwww, r1.xyzx  
  <span class="hljs-number">12</span>: mul r2.xyz, r1.yyyy, v3.xyzx  
  <span class="hljs-number">13</span>: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  <span class="hljs-number">14</span>: mov r3.xy, v1.zwzz  
  <span class="hljs-number">15</span>: mov r3.z, v3.w  
  <span class="hljs-number">16</span>: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  <font></font>
    <font></font>
   <span class="hljs-comment">// Perform bump mapping  </span><font></font>
   float3 SkyTangent = Input.Tangent;  <font></font>
   float3 SkyNormal = (float3( Input.Texcoords.zw, Input.param3.w ));  <font></font>
   float3 SkyBitangent = Input.param3.xyz;  <font></font>
        <font></font>
   float3x3 TBN = float3x3(SkyTangent, SkyBitangent, SkyNormal);  <font></font>
   float3 finalNormal = (float3)mul( unpackedNormal, (TBN) );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luminosit√© (1)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'√©tape suivante, le calcul NdotL est appliqu√© et cela affecte la quantit√© d'√©clairage d'un pixel sp√©cifique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez le code assembleur suivant:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">17</span>: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  <span class="hljs-number">18</span>: add r0.y, -cb4[<span class="hljs-number">2</span>].x, cb4[<span class="hljs-number">3</span>].x  
  <span class="hljs-number">19</span>: mad r0.x, r0.x, r0.y, cb4[<span class="hljs-number">2</span>].x  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la visualisation de NdotL sur la trame en question:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/f29/1a1/283f291a18105785a51af59dbbe8905a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce produit scalaire (avec saturation) est utilis√© pour interpoler entre minIntensity et maxIntensity. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, les parties des nuages ‚Äã‚Äã√©clair√©es par la lumi√®re du soleil seront plus lumineuses.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Calculate cosine between normal and up-inv lightdir  </span>
   <span class="hljs-keyword">float</span> NdotL = saturate( dot(invertedSunlightDir, finalNormal) );  <font></font>
   <font></font>
   <span class="hljs-comment">// Param 1, line 19, r0.x  </span>
   <span class="hljs-keyword">float</span> intensity1 = lerp( param1Min, param1Max, NdotL );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luminosit√© (2)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre facteur affecte la luminosit√© des nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les nuages ‚Äã‚Äãsitu√©s dans la partie du ciel o√π se trouve le soleil devraient √™tre davantage mis en √©vidence. </font><font style="vertical-align: inherit;">Pour ce faire, nous calculons le gradient sur la base du plan XY. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce gradient est utilis√© pour calculer l'interpolation lin√©aire entre les valeurs min / max, similaire √† ce qui se passe dans la partie (1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, nous pouvons th√©oriquement demander d'assombrir les nuages ‚Äã‚Äãsitu√©s de l'autre c√¥t√© du soleil, mais cela ne se produit pas dans ce cadre particulier, car </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [1] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sont d√©finis sur 1.0f.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">20</span>: dp2 r0.y, -cb0[<span class="hljs-number">9</span>].xyxx, -cb0[<span class="hljs-number">9</span>].xyxx  
  <span class="hljs-number">21</span>: rsq r0.y, r0.y  
  <span class="hljs-number">22</span>: mul r0.yz, r0.yyyy, -cb0[<span class="hljs-number">9</span>].xxyx  
  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  
  <span class="hljs-number">28</span>: mul r1.xy, r1.zzzz, r1.xyxx  
  <span class="hljs-number">29</span>: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  <span class="hljs-number">30</span>: add r0.y, r0.y, r0.y  
  <span class="hljs-number">31</span>: min r0.y, r0.y, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">32</span>: add r0.z, -cb4[<span class="hljs-number">0</span>].x, cb4[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">33</span>: mad r0.z, r0.y, r0.z, cb4[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">34</span>: mul r0.x, r0.x, r0.z  
  <span class="hljs-number">35</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">36</span>: mul r0.x, r0.x, l(<span class="hljs-number">2.200000</span>)  
  <span class="hljs-number">37</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate normalized -lightDir.xy (20-22)  </span><font></font>
   float2 lightDirXY = normalize( -lightDir.xy );  <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate world to camera  </span><font></font>
   float3 vWorldToCamera = ( CameraPos - WorldPos );  <font></font>
   <span class="hljs-keyword">float</span> worldToCamera_distance = length(vWorldToCamera);  <font></font>
        <font></font>
   <span class="hljs-comment">// normalize vector  </span><font></font>
   vWorldToCamera = normalize( vWorldToCamera );  <font></font>
        <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> LdotV = saturate( dot(lightDirXY, vWorldToCamera.xy) );  
   <span class="hljs-keyword">float</span> highlightedSkySection = saturate( <span class="hljs-number">2</span>*LdotV );  
   <span class="hljs-keyword">float</span> intensity2 = lerp( param2Min, param2Max, highlightedSkySection );  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> finalIntensity = <span class="hljs-built_in">pow</span>( intensity2 *intensity1, <span class="hljs-number">2.2</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä la toute fin, nous multiplions les deux luminosit√©s et √©levons le r√©sultat √† une puissance de 2,2.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur des nuages</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le calcul de la couleur des nuages ‚Äã‚Äãcommence par l'obtention des constantes tampons de deux valeurs indiquant la couleur des nuages ‚Äã‚Äãpr√®s du soleil et des nuages ‚Äã‚Äãde l'autre c√¥t√© du ciel. </font><font style="vertical-align: inherit;">Entre eux, une interpolation lin√©aire est effectu√©e sur la base de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optionSkySection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le r√©sultat est ensuite multipli√© par </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalIntensity</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et au final, le r√©sultat est m√©lang√© au brouillard (pour des raisons de performances, il a √©t√© calcul√© par le vertex shader).</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">38</span>: add r1.xyz, cb12[<span class="hljs-number">236</span>].xyzx, -cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">39</span>: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">40</span>: mul r2.xyz, r0.xxxx, r1.xyzx  
  <span class="hljs-number">41</span>: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  <span class="hljs-number">42</span>: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  <font></font>
   <font></font>
  float3 cloudsColor = lerp( cloudsColorBack, cloudsColorFront, highlightedSunSection );  <font></font>
  cloudsColor *= finalIntensity;  <font></font>
  cloudsColor = lerp( cloudsColor, FogColor, FogAmount );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre les nuages ‚Äã‚Äãde cirrus plus visibles √† l'horizon</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas tr√®s visible sur le cadre, mais en fait cette couche est plus visible pr√®s de l'horizon qu'au-dessus de la t√™te de Geralt. </font><font style="vertical-align: inherit;">Voici comment proc√©der. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pourriez remarquer que lors du calcul de la deuxi√®me luminosit√©, nous avons calcul√© la longueur du vecteur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worldToCamera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trouvons les occurrences suivantes de cette longueur dans le code:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  <font></font>
  ...  <font></font>
  <span class="hljs-number">43</span>: add r1.x, -cb4[<span class="hljs-number">7</span>].x, cb4[<span class="hljs-number">8</span>].x  
  <span class="hljs-number">44</span>: div_sat r0.w, r0.w, r1.x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, qu'est-ce que c'est avec nous? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cb [7] .x et cb [8] .x ont les valeurs 2000.0 et 7000.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'av√®re que c'est le r√©sultat de l'utilisation de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linstep</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elle re√ßoit trois param√®tres: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min / max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - intervalle et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - valeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne comme suit: si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est dans l'intervalle [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], alors la fonction renvoie une interpolation lin√©aire dans l'intervalle [0,0 - 1,0]. </font><font style="vertical-align: inherit;">D'un autre c√¥t√©, si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est hors limites, alors linstep renvoie 0,0 ou 1,0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple simple:</font></font><br>
<br>
<pre><code class="cpp hljs">linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">999.0</span>) = <span class="hljs-number">0.0</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">1500.0</span>) = <span class="hljs-number">0.5</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">2000.0</span>) = <span class="hljs-number">1.0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, il est assez similaire au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de HLSL, sauf que dans ce cas, au lieu de l'interpolation hermitienne, lin√©aire est effectu√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linstep n'est pas une fonctionnalit√© de HLSL, mais il est tr√®s utile. </font><font style="vertical-align: inherit;">Cela vaut la peine de l'avoir dans votre bo√Æte √† outils.</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-comment">// linstep:  </span>
 <span class="hljs-comment">//  </span>
 <span class="hljs-comment">// Returns a linear interpolation between 0 and 1 if t is in the range [min, max]   </span>
 <span class="hljs-comment">// if "v" is &lt;= min, the output is 0  </span>
 <span class="hljs-comment">// if "v" i &gt;= max, the output is 1  </span><font></font>
   <font></font>
 <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">( <span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v )</span>  
 </span>{  
   <span class="hljs-keyword">return</span> saturate( (v - min) / (max - min) );  <font></font>
 } </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons √† Witcher 3: apr√®s avoir calcul√© cet indicateur, signal√© √† quelle distance une partie du ciel est de Geralt, nous l'utilisons pour affaiblir la luminosit√© des nuages:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">45</span>: mul r1.x, r1.w, cb4[<span class="hljs-number">9</span>].x  
  <span class="hljs-number">46</span>: mad r1.y, -cb4[<span class="hljs-number">9</span>].x, r1.w, r1.w  
  <span class="hljs-number">47</span>: mad r0.w, r0.w, r1.y, r1.x  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> distanceAttenuation = linstep( fadeDistanceStart, fadeDistanceEnd, worldToCamera_distance );  <font></font>
    <font></font>
   <span class="hljs-keyword">float</span> fadedCloudShape = closeCloudsHidingFactor * cloudShape;  <font></font>
   cloudShape = lerp( fadedCloudShape, cloudShape, distanceAttenuation );</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudShape</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le canal .a de la premi√®re texture, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closeCloudsHidingFactor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une valeur tampon constante qui contr√¥le la visibilit√© des nuages ‚Äã‚Äãau-dessus de la t√™te de Geralt. </font><font style="vertical-align: inherit;">Dans toutes les images que j'ai test√©es, elle √©tait √©gale √† 0,0, ce qui √©quivaut √† l'absence de nuages. </font><font style="vertical-align: inherit;">Lorsque l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">att√©nuation de la distance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> approche de 1,0 (la distance entre la cam√©ra et le d√¥me du ciel augmente), les nuages ‚Äã‚Äãdeviennent plus visibles.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âchantillonnage de la texture du bruit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calcul des coordonn√©es de la texture du bruit d'√©chantillonnage calculs similaires pour la texture des nuages, sauf que vous utilisez un ensemble diff√©rent de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textureScale</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speedMultiplier</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, un sampler avec le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mode d' </font><font style="vertical-align: inherit;">adressage activ√© est utilis√© pour √©chantillonner toutes ces textures </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">48</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">11</span>].xyxx  
  <span class="hljs-number">49</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">10</span>].xyxx, r1.xyxx  
  <span class="hljs-number">50</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.x, r1.xyxx, t1.xyzw, s0  <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords for noise  </span><font></font>
   float2 noiseTextureUV = Texcoords * textureScaleNoise + elapsedTime * speedFactorsNoise;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;</code></pre> <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettre tous ensemble</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir re√ßu la valeur du bruit, nous devons la combiner avec cloudShape. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai eu quelques probl√®mes pour comprendre ces lignes, o√π il y a param2.w (qui est toujours 1.0) et noiseMult (a une valeur de 5.0, tir√©e du tampon constant). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quoi qu'il en soit, la chose la plus importante ici est la valeur finale de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalCloudsVisibility</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui affecte la visibilit√© des nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez √©galement un ≈ìil √† la valeur finale du bruit. </font><font style="vertical-align: inherit;">La couleur de sortie de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudsColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est multipli√©e par le bruit final, qui est √©galement √©mis vers le canal alpha.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">51</span>: mad r1.x, r1.x, cb4[<span class="hljs-number">12</span>].x, -cb4[<span class="hljs-number">12</span>].x
  <span class="hljs-number">52</span>: mad_sat r1.x, cb4[<span class="hljs-number">12</span>].x, v2.w, r1.x
  <span class="hljs-number">53</span>: mul r0.w, r0.w, r1.x
  <span class="hljs-number">54</span>: mul_sat r0.w, r0.w, cb4[<span class="hljs-number">6</span>].x
  <span class="hljs-number">55</span>: mul o0.xyz, r0.wwww, r0.xyzx
  <span class="hljs-number">56</span>: mov o0.w, r0.w
  <span class="hljs-number">57</span>: ret   <font></font>
<font></font>
   <span class="hljs-comment">// Sample noise texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;  <font></font>
   noiseTextureValue = noiseTextureValue * noiseMult - noiseMult;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> noiseValue = saturate( noiseMult * Input.param2.w + noiseTextureValue);  <font></font>
   noiseValue *= cloudShape;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> finalNoise = saturate( noiseValue * generalCloudsVisibility);  <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> float4( cloudsColor*finalNoise, finalNoise ); </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le r√©sultat final semble tr√®s cr√©dible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez comparer. </font><font style="vertical-align: inherit;">La premi√®re image est mon shader, la seconde est le shader du jeu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4cc/331/897/4cc3318976e9c1c54178683a2fee44c0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous √™tes curieux, le shader est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2. Brouillard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le brouillard peut √™tre mis en ≈ìuvre de diff√©rentes mani√®res. Cependant, les moments o√π nous pouvions appliquer un simple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brouillard d√©pendant de la distance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et le supprimer √©taient pour toujours dans le pass√© (tr√®s probablement). Vivre dans le monde des shaders programmables a ouvert la porte √† de nouvelles solutions folles, mais plus importantes encore, physiquement pr√©cises et visuellement r√©alistes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les tendances actuelles du rendu du brouillard sont bas√©es sur des shaders de calcul (pour plus de d√©tails, voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pr√©sentation de Bart Wronsky). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgr√© le fait que cette pr√©sentation soit apparue en 2014 et que The Witcher 3 soit sorti en 2015/2016, le brouillard dans la derni√®re partie des aventures de Geralt d√©pend compl√®tement de l'√©cran et est impl√©ment√© comme un post-traitement typique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer la prochaine session de r√©tro-ing√©nierie, je dois dire qu'au cours de la derni√®re ann√©e, j'ai essay√© de comprendre le brouillard de Witcher 3 au moins cinq fois, et chaque fois a √©chou√©. Le code assembleur, comme vous le verrez bient√¥t, est assez compliqu√©, ce qui rend le processus de cr√©ation d'un shader de brouillard lisible sur HLSL presque impossible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, j'ai r√©ussi √† trouver un shader de brouillard sur Internet qui a imm√©diatement attir√© mon attention en raison de sa similitude avec le brouillard The Witcher 3 en termes de noms de variables et de l'ordre g√©n√©ral des instructions. Ce shader n'√©tait pas exactement le m√™me que dans le jeu, j'ai donc d√ª le retravailler un peu. Je tiens √† dire que la partie principale du code HLSL que vous voyez ici, √† deux exceptions pr√®s, n'a pas √©t√© cr√©√©e / analys√©e par moi. N'oubliez pas cela.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici le code assembleur pour le pixel fog shader - il convient de noter qu'il est le m√™me pour tout le jeu (la partie principale de 2015 et les deux DLC):</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb3[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">214</span>], <span class="hljs-function">immediateIndexed  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t2  
    dcl_input_ps_siv v0.xy, position  
    dcl_output o0.xyzw  
    dcl_temps 7  
   0: ftou r0.xy, v0.xyxx  
   1: mov r0.zw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
   2: <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r0.xyww, t0.xyzw  
   3: mad r1.y, r1.x, cb12[22].x, cb12[22].y  
   4: lt r1.y, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
   5: if_nz r1.y  
   6:  utof r1.yz, r0.xxyx  
   7:  mul r2.xyzw, r1.zzzz, cb12[211].xyzw  
   8:  mad r2.xyzw, cb12[210].xyzw, r1.yyyy, r2.xyzw  
   9:  mad r1.xyzw, cb12[212].xyzw, r1.xxxx, r2.xyzw  
  10:  add r1.xyzw, r1.xyzw, cb12[213].xyzw  
  11:  div r1.xyz, r1.xyzx, r1.wwww  
  12:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r2.xyz, r0.xyww, t1.xyzw  
  13:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r0.x, r0.xyzw, t2.xyzw  
  14:  max r0.x, r0.x, cb3[1].x  
  15:  add r0.yzw, r1.xxyz, -cb12[0].xxyz  
  16:  dp3 r1.x, r0.yzwy, r0.yzwy  
  17:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  18:  add r1.y, r1.x, -cb3[0].x  
  19:  add r1.zw, -cb3[0].xxxz, cb3[0].yyyw  
  20:  div_sat r1.y, r1.y, r1.z  
  21:  mad r1.y, r1.y, r1.w, cb3[0].z  
  22:  add r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  23:  mad r0.x, r1.y, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  24:  div r0.yzw, r0.yyzw, r1.xxxx  
  25:  mad r1.y, r0.w, cb12[22].z, cb12[0].z  
  26:  add r1.x, r1.x, -cb12[22].z  
  27:  max r1.x, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  28:  min r1.x, r1.x, cb12[42].z  
  29:  mul r1.z, r0.w, r1.x  
  30:  mul r1.w, r1.x, cb12[43].x  
  31:  mul r1.zw, r1.zzzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.062500</span>, <span class="hljs-number">0.062500</span>)</span>  
  32:  dp3 r0.y, cb12[38].xyzx, r0.yzwy  
  33:  add r0.z, r0.y, cb12[42].x  
  34:  add r0.w, cb12[42].x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  35:  div_sat r0.z, r0.z, r0.w  
  36:  add r0.w, -cb12[43].z, cb12[43].y  
  37:  mad r0.z, r0.z, r0.w, cb12[43].z  
  38:  mul r0.w, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>  
  39:  mad_sat r2.w, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.002000</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.300000</span>)</span>  
  40:  mul r0.w, r0.w, r2.w  
  41:  lt r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, r0.y  
  42:  movc r3.xyz, r0.yyyy, cb12[39].xyzx, cb12[41].xyzx  
  43:  add r3.xyz, r3.xyzx, -cb12[40].xyzx  
  44:  mad r3.xyz, r0.wwww, r3.xyzx, cb12[40].xyzx  
  45:  movc r4.xyz, r0.yyyy, cb12[45].xyzx, cb12[47].xyzx  
  46:  add r4.xyz, r4.xyzx, -cb12[46].xyzx  
  47:  mad r4.xyz, r0.wwww, r4.xyzx, cb12[46].xyzx  
  48:  ge r0.y, r1.x, cb12[48].y  
  49:  if_nz r0.y  
  50:   add r0.y, r1.y, cb12[42].y  
  51:   mul r0.w, r0.z, r0.y  
  52:   mul r1.y, r0.z, r1.z  
  53:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>)</span>, r0.wwww  
  54:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  55:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  56:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  57:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  58:   mul r1.z, r5.y, r5.x  
  59:   mul r1.z, r5.z, r1.z  
  60:   mul r1.z, r5.w, r1.z  
  61:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>)</span>, r0.wwww  
  62:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  63:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  64:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  65:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  66:   mul r1.z, r1.z, r5.x  
  67:   mul r1.z, r5.y, r1.z  
  68:   mul r1.z, r5.z, r1.z  
  69:   mul r1.z, r5.w, r1.z  
  70:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>)</span>, r0.wwww  
  71:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  72:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  73:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  74:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  75:   mul r1.z, r1.z, r5.x  
  76:   mul r1.z, r5.y, r1.z  
  77:   mul r1.z, r5.z, r1.z  
  78:   mul r1.z, r5.w, r1.z  
  79:   mad r5.xy, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>, r0.wwww  
  80:   max r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  81:   add r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  82:   div_sat r5.xy, r1.wwww, r5.xyxx  
  83:   add r5.xy, -r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  84:   mul r1.z, r1.z, r5.x  
  85:   mul r1.z, r5.y, r1.z  
  86:   mad r0.w, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.000000</span>)</span>, r0.w  
  87:   max r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  88:   add r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  89:   div_sat r0.w, r1.w, r0.w  
  90:   add r0.w, -r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  91:   mul r0.w, r0.w, r1.z  
  92:   mad r0.y, r0.y, r0.z, r1.y  
  93:   max r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  94:   add r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  95:   div_sat r0.y, r1.w, r0.y  
  96:   add r0.y, -r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  97:   mad r0.y, -r0.w, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  98:   add r0.z, r1.x, -cb12[48].y  
  99:   mul_sat r0.z, r0.z, cb12[48].z  
  100:  <span class="hljs-keyword">else</span>  
  101:   mov r0.yz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  102:  endif  
  103:  <span class="hljs-built_in">log</span> r0.y, r0.y  
  104:  mul r0.w, r0.y, cb12[42].w  
  105:  <span class="hljs-built_in">exp</span> r0.w, r0.w  
  106:  mul r0.y, r0.y, cb12[48].x  
  107:  <span class="hljs-built_in">exp</span> r0.y, r0.y  
  108:  mul r0.yw, r0.yyyw, r0.zzzz  
  109:  mad_sat r1.xy, r0.wwww, cb12[189].xzxx, cb12[189].ywyy  
  110:  add r5.xyz, -r3.xyzx, cb12[188].xyzx  
  111:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  112:  add r0.z, cb12[188].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  113:  mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  114:  mul_sat r5.w, r0.z, r0.w  
  115:  lt r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, cb12[192].x  
  116:  if_nz r0.z  
  117:   mad_sat r1.xy, r0.wwww, cb12[191].xzxx, cb12[191].ywyy  
  118:   add r6.xyz, -r3.xyzx, cb12[190].xyzx  
  119:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  120:   add r0.z, cb12[190].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  121:   mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  122:   mul_sat r3.w, r0.z, r0.w  
  123:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  124:   mad r5.xyzw, cb12[192].xxxx, r1.xyzw, r5.xyzw  
  125:  endif  
  126:  mul r0.z, r0.x, r5.w  
  127:  mul r0.x, r0.x, r0.y  
  128:  dp3 r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>)</span>, r2.xyzx  
  129:  mad r1.xyz, r0.yyyy, r4.xyzx, -r2.xyzx  
  130:  mad r0.xyw, r0.xxxx, r1.xyxz, r2.xyxz  
  131:  add r1.xyz, -r0.xywx, r5.xyzx  
  132:  mad r0.xyz, r0.zzzz, r1.xyzx, r0.xywx  
  133: <span class="hljs-keyword">else</span>  
  134:  mov r0.xyz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  135: endif  
  136: mov o0.xyz, r0.xyzx  
  137: mov o0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  138: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honn√™tement, le shader est assez long. </font><font style="vertical-align: inherit;">Probablement trop long pour un processus d'ing√©nierie inverse efficace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple d'une sc√®ne de coucher de soleil avec du brouillard:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetons un coup d'≈ìil √† l'entr√©e: en ce </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
qui concerne les textures, nous avons un tampon de profondeur, une occlusion ambiante et un tampon de couleur HDR.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/24d/ff0/9ea24dff07dad409a78834272d553b29.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampon de profondeur entrant</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Occlusion ambiante entrante</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/51f/f3c/74851ff3ce8d38b77d9319329a334d4f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tampon de couleur HDR entrant</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
... et le r√©sultat de l'application du shader de brouillard dans cette sc√®ne ressemble √† ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture HDR apr√®s application du brouillard.Le</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
tampon de profondeur est utilis√© pour recr√©er la position dans le monde. C'est le mod√®le standard pour les shaders Witcher 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avoir des donn√©es d'occlusion ambiante (si activ√©es) nous permet d'obscurcir le brouillard. Une id√©e tr√®s intelligente, peut-√™tre √©vidente, mais je n'y ai jamais pens√© de cette fa√ßon. Je reviendrai sur cet aspect plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un shader commence par d√©terminer si un pixel est dans le ciel. Dans le cas o√π le pixel se trouve dans le ciel (profondeur == 1.0), le shader retourne le noir. Si le pixel est dans la sc√®ne (profondeur &lt;1.0), alors nous recr√©ons la position dans le monde en utilisant le tampon de profondeur (lignes 7-11) et continuons √† calculer le brouillard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le passage du brouillard se produit peu de temps apr√®s le processus d'ombrage retard√©. </font><font style="vertical-align: inherit;">Vous remarquerez peut-√™tre que certains √©l√©ments li√©s √† la marche avant ne sont pas encore disponibles. </font><font style="vertical-align: inherit;">Dans cette sc√®ne particuli√®re, des volumes d'√©clairage diff√©r√©s ont √©t√© appliqu√©s, puis nous avons rendu les cheveux / visage / yeux de Geralt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re chose que vous devez savoir sur le brouillard dans ¬´The Witcher 3¬ª: il se compose de deux parties - ¬´couleur du brouillard¬ª et ¬´couleur de l'atmosph√®re¬ª.</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FogResult</span>  
 {</span>  
    float4 paramsFog;     <span class="hljs-comment">// RGB: color, A: influence  </span>
    float4 paramsAerial;  <span class="hljs-comment">// RGB: color, A: influence  </span>
 };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour chaque pi√®ce, il existe trois couleurs: avant, milieu et arri√®re. </font><font style="vertical-align: inherit;">Autrement dit, dans le tampon constant, il y a des donn√©es telles que "FogColorFront", "FogColorMiddle", "AerialColorBack", etc ... Regardons les donn√©es entrantes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cd0/55d/0b2cd055d9f6876c57527b9934b3b6ad.png"></div><br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// *** Inputs *** //  </span><font></font>
   float3 FogSunDir = cb12_v38.xyz;  <font></font>
   float3 FogColorFront = cb12_v39.xyz;  <font></font>
   float3 FogColorMiddle = cb12_v40.xyz;  <font></font>
   float3 FogColorBack = cb12_v41.xyz;  <font></font>
     <font></font>
   float4 FogBaseParams = cb12_v42;  <font></font>
   float4 FogDensityParamsScene = cb12_v43;  <font></font>
   float4 FogDensityParamsSky = cb12_v44;  <font></font>
     <font></font>
   float3 AerialColorFront = cb12_v45.xyz;  <font></font>
   float3 AerialColorMiddle = cb12_v46.xyz;  <font></font>
   float3 AerialColorBack = cb12_v47.xyz;  <font></font>
   float4 AerialParams = cb12_v48;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de calculer les couleurs finales, nous devons calculer les vecteurs et les produits scalaires. </font><font style="vertical-align: inherit;">Le shader a acc√®s √† la position des pixels dans le monde, √† la position de la cam√©ra (cb12 [0] .xyz) et √† la direction du brouillard / √©clairage (cb12 [38] .xyz). </font><font style="vertical-align: inherit;">Cela nous permet de calculer le produit scalaire du vecteur de la forme et de la direction du brouillard.</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 frag_vec = fragPosWorldSpace.xyz - customCameraPos.xyz;  
   <span class="hljs-keyword">float</span> frag_dist = length(frag_vec);  <font></font>
     <font></font>
   float3 frag_dir = frag_vec / frag_dist;  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> dot_fragDirSunDir = dot(GlobalLightDirection.xyz, frag_dir);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour calculer le gradient de m√©lange, vous devez utiliser le carr√© du produit scalaire absolu, puis multiplier √† nouveau le r√©sultat par un param√®tre qui d√©pend de la distance:</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 curr_col_fog;  <font></font>
   float3 curr_col_aerial;  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> _dot = dot_fragDirSunDir;  <font></font>
   <font></font>
     <span class="hljs-keyword">float</span> _dd = _dot;  <font></font>
     {  <font></font>
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distOffset = <span class="hljs-number">-150</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distRange = <span class="hljs-number">500</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _mul = <span class="hljs-number">1.0</span> / _distRange;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _bias = _distOffset * _mul;  <font></font>
   <font></font>
       _dd = <span class="hljs-built_in">abs</span>(_dd);  <font></font>
       _dd *= _dd;  <font></font>
       _dd *= saturate( frag_dist * _mul + _bias );  <font></font>
     }  <font></font>
   <font></font>
     curr_col_fog = lerp( FogColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? FogColorFront.xyz : FogColorBack.xyz), _dd );  <font></font>
     curr_col_aerial = lerp( AerialColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? AerialColorFront.xyz : AerialColorBack.xyz), _dd );  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce bloc de code nous indique clairement d'o√π proviennent ces 0,002 et -0,300. </font><font style="vertical-align: inherit;">Comme on peut le voir, le produit scalaire entre les vecteurs de vue et d'√©clairage est responsable du choix entre les couleurs ¬´avant¬ª et ¬´arri√®re¬ª. </font><font style="vertical-align: inherit;">Intelligent! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une visualisation du gradient final r√©sultant (_dd).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f03/ca0/d43f03ca005d504abd5cd236007f34f4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, le calcul de l'effet de l'atmosph√®re / du brouillard est beaucoup plus compliqu√©. Comme vous pouvez le voir, nous avons beaucoup plus d'options que les couleurs RVB. Ils incluent, par exemple, la densit√© des sc√®nes. Nous utilisons le raymarching (16 √©tapes, et c'est pourquoi le cycle peut √™tre √©tendu) pour d√©terminer la taille du brouillard et le facteur d'√©chelle: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ayant un vecteur [cam√©ra ---&gt; monde], nous pouvons diviser toutes ses composantes en 16 - ce sera une √©tape de raymarching. Comme nous le voyons ci-dessous, seule la composante .z (hauteur) ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curr_pos_z_step</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est </font><font style="vertical-align: inherit;">impliqu√©e dans les calculs </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En savoir plus sur le brouillard mis en ≈ìuvre par raymarching, par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> fog_amount = <span class="hljs-number">1</span>;  
   <span class="hljs-keyword">float</span> fog_amount_scale = <span class="hljs-number">0</span>;  <font></font>
   [branch]  <font></font>
   <span class="hljs-keyword">if</span> ( frag_dist &gt;= AerialParams.y )  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> curr_pos_z_base = (customCameraPos.z + FogBaseParams.y) * density_factor;  
     <span class="hljs-keyword">float</span> curr_pos_z_step = frag_step.z * density_factor;  <font></font>
   <font></font>
     [unroll]  <font></font>
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i=<span class="hljs-number">16</span>; i&gt;<span class="hljs-number">0</span>; --i )  <font></font>
     {  <font></font>
       fog_amount *= <span class="hljs-number">1</span> - saturate( density_sample_scale / (<span class="hljs-number">1</span> + max( <span class="hljs-number">0.0</span>, curr_pos_z_base + (i) * curr_pos_z_step ) ) );  <font></font>
     }  <font></font>
   <font></font>
     fog_amount = <span class="hljs-number">1</span> - fog_amount;  <font></font>
     fog_amount_scale = saturate( (frag_dist - AerialParams.y) * AerialParams.z );  <font></font>
   }  <font></font>
   <font></font>
   FogResult ret;  <font></font>
   <font></font>
   ret.paramsFog = float4 ( curr_col_fog, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_fog ) );  <font></font>
   ret.paramsAerial = float4 ( curr_col_aerial, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_aerial ) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La quantit√© de brouillard d√©pend √©videmment de la hauteur (composants .z), √† la fin la quantit√© de brouillard est √©lev√©e au degr√© de brouillard / atmosph√®re. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_fog</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_aerial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont extraits du tampon constant; </font><font style="vertical-align: inherit;">ils vous permettent de contr√¥ler comment les couleurs du brouillard et de l'atmosph√®re affectent le monde avec une altitude croissante.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contournement de brouillard</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le shader que j'ai trouv√© n'a pas le fragment de code d'assembly suivant:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">109</span>:  mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">110</span>:  add r5.xyz, -r3.xyzx, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">111</span>:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  <span class="hljs-number">112</span>:  add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">188</span>].w  
  <span class="hljs-number">113</span>:  mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">114</span>:  mul_sat r5.w, r0.w, r0.z  
  <span class="hljs-number">115</span>:  lt r0.z, l(<span class="hljs-number">0.000000</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">116</span>:  if_nz r0.z  
  <span class="hljs-number">117</span>:   mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">118</span>:   add r6.xyz, -r3.xyzx, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">119</span>:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  <span class="hljs-number">120</span>:   add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">190</span>].w  
  <span class="hljs-number">121</span>:   mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">122</span>:   mul_sat r3.w, r0.w, r0.z  
  <span class="hljs-number">123</span>:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  <span class="hljs-number">124</span>:   mad r5.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r1.xyzw, r5.xyzw  
  <span class="hljs-number">125</span>:  endif</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä en juger par ce que j'ai pu comprendre, cela revient √† red√©finir la couleur et l'effet du brouillard: la </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
plupart du temps, une seule red√©finition est effectu√©e (cb12_v192.x est 0,0), mais dans ce cas particulier, sa valeur est ~ 0,22, nous faisons donc le deuxi√®me remplacement.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc7/2bd/1b8/cc72bd1b8cff0742cf4aad51a7e6ab3f.png"></div><br>
<pre><code class="cpp hljs"> <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OVERRIDE_FOG  </span><font></font>
     <font></font>
   <span class="hljs-comment">// Override  </span>
   <span class="hljs-keyword">float</span> fog_influence = ret.paramsFog.w; <span class="hljs-comment">// r0.w  </span><font></font>
   <font></font>
   <span class="hljs-keyword">float</span> override1ColorScale = cb12_v189.x;  
   <span class="hljs-keyword">float</span> override1ColorBias = cb12_v189.y;  <font></font>
   float3 override1Color = cb12_v188.rgb;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1InfluenceScale = cb12_v189.z;  
   <span class="hljs-keyword">float</span> override1InfluenceBias = cb12_v189.w;  
   <span class="hljs-keyword">float</span> override1Influence = cb12_v188.w;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1ColorAmount = saturate(fog_influence * override1ColorScale + override1ColorBias);  
   <span class="hljs-keyword">float</span> override1InfluenceAmount = saturate(fog_influence * override1InfluenceScale + override1InfluenceBias);    <font></font>
     <font></font>
<font></font>
   float4 paramsFogOverride;  <font></font>
   paramsFogOverride.rgb = lerp(curr_col_fog, override1Color, override1ColorAmount ); <span class="hljs-comment">// ***r5.xyz   </span><font></font>
     <font></font>
   <span class="hljs-keyword">float</span> param1 = lerp(<span class="hljs-number">1.0</span>, override1Influence, override1InfluenceAmount); <span class="hljs-comment">// r0.x  </span>
   paramsFogOverride.w = saturate(param1 * fog_influence ); <span class="hljs-comment">// ** r5.w  </span><font></font>
   <font></font>
     <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> extraFogOverride = cb12_v192.x;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (extraFogOverride &gt; <span class="hljs-number">0.0</span>)  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> override2ColorScale = cb12_v191.x;  
     <span class="hljs-keyword">float</span> override2ColorBias = cb12_v191.y;  <font></font>
     float3 override2Color = cb12_v190.rgb;  <font></font>
     <font></font>
     <span class="hljs-keyword">float</span> override2InfluenceScale = cb12_v191.z;  
     <span class="hljs-keyword">float</span> override2InfluenceBias = cb12_v191.w;  
     <span class="hljs-keyword">float</span> override2Influence = cb12_v190.w;  <font></font>
       <font></font>
     <span class="hljs-keyword">float</span> override2ColorAmount = saturate(fog_influence * override2ColorScale + override2ColorBias);  
     <span class="hljs-keyword">float</span> override2InfluenceAmount = saturate(fog_influence * override2InfluenceScale + override2InfluenceBias);  <font></font>
      <font></font>
<font></font>
     float4 paramsFogOverride2;  <font></font>
     paramsFogOverride2.rgb = lerp(curr_col_fog, override2Color, override2ColorAmount); <span class="hljs-comment">// r3.xyz   </span><font></font>
           <font></font>
     <span class="hljs-keyword">float</span> ov_param1 = lerp(<span class="hljs-number">1.0</span>, override2Influence, override2InfluenceAmount); <span class="hljs-comment">// r0.z  </span>
     paramsFogOverride2.w = saturate(ov_param1 * fog_influence); <span class="hljs-comment">// r3.w  </span><font></font>
   <font></font>
     paramsFogOverride = lerp(paramsFogOverride, paramsFogOverride2, extraFogOverride);  <font></font>
   <font></font>
   }  <font></font>
   ret.paramsFog = paramsFogOverride;  <font></font>
     <font></font>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici notre prix fini sans red√©finition du brouillard (premi√®re image), avec une red√©finition (deuxi√®me image) et une double red√©finition (troisi√®me image, r√©sultat final):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/011/3c8/3b90113c8ad27f287cdb29a25a37470d.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03a/791/d39/03a791d39e2082b80e86ea8daa488a64.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©gulation de l'occlusion ambiante</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le shader que j'ai trouv√© n'utilisait pas du tout d'occlusion ambiante. </font><font style="vertical-align: inherit;">Jetons un coup d'≈ìil √† la texture d'AO et au code qui nous int√©resse:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<pre><code class="cpp hljs">  <span class="hljs-number">13</span>:  ld_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r0.x, r0.xyzw, t2.xyzw  
  <span class="hljs-number">14</span>:  max r0.x, r0.x, cb3[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">15</span>:  add r0.yzw, r1.xxyz, -cb12[<span class="hljs-number">0</span>].xxyz  
  <span class="hljs-number">16</span>:  dp3 r1.x, r0.yzwy, r0.yzwy  
  <span class="hljs-number">17</span>:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  <span class="hljs-number">18</span>:  add r1.y, r1.x, -cb3[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">19</span>:  add r1.zw, -cb3[<span class="hljs-number">0</span>].xxxz, cb3[<span class="hljs-number">0</span>].yyyw  
  <span class="hljs-number">20</span>:  div_sat r1.y, r1.y, r1.z  
  <span class="hljs-number">21</span>:  mad r1.y, r1.y, r1.w, cb3[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">22</span>:  add r0.x, r0.x, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">23</span>:  mad r0.x, r1.y, r0.x, l(<span class="hljs-number">1.000000</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette sc√®ne n'est peut-√™tre pas le meilleur exemple, car on ne voit pas les d√©tails sur une √Æle lointaine. </font><font style="vertical-align: inherit;">Cependant, jetons un ≈ìil au tampon constant, qui est utilis√© pour d√©finir la valeur d'occlusion ambiante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/343/c52/af4/343c52af44338628770912801bc3b32c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commen√ßons par charger AO √† partir de la texture, puis ex√©cutons l'instruction max. Dans cette sc√®ne, cb3_v1.x est tr√®s √©lev√© (0,96888), ce qui rend l'AO tr√®s faible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie suivante du code calcule la distance entre les positions de la cam√©ra et les pixels dans le monde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je crois que le code parle parfois de lui-m√™me, alors regardons HLSL, qui fait l'essentiel de cette configuration:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">AdjustAmbientOcclusion</span><span class="hljs-params">(in <span class="hljs-keyword">float</span> inputAO, in <span class="hljs-keyword">float</span> worldToCameraDistance)</span>  
 </span>{  
   <span class="hljs-comment">// *** Inputs *** //  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceStart = cb3_v0.x;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceEnd = cb3_v0.y;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthStart = cb3_v0.z;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthEnd = cb3_v0.w;  <font></font>
      <font></font>
   <span class="hljs-comment">// * Adjust AO  </span>
   <span class="hljs-keyword">float</span> aoDistanceIntensity = linstep( aoDistanceStart, aoDistanceEnd, worldToCameraDistance );  
   <span class="hljs-keyword">float</span> aoStrength = lerp(aoStrengthStart, aoStrengthEnd, aoDistanceIntensity);   
   <span class="hljs-keyword">float</span> adjustedAO = lerp(<span class="hljs-number">1.0</span>, inputAO, aoStrength);  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> adjustedAO;   <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La distance calcul√©e entre la cam√©ra et le monde est utilis√©e pour la fonction Linstep. </font><font style="vertical-align: inherit;">Nous connaissons d√©j√† cette fonction, elle est apparue dans le shader de nuage de cirrus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, dans le tampon constant, nous avons les valeurs de distance de d√©but / fin AO. </font><font style="vertical-align: inherit;">La sortie de linstep affecte la force de l'AO (ainsi que de cbuffer), et la force affecte la sortie de l'AO. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bref exemple: le pixel est loin, par exemple, la distance est de 500. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linstep renvoie 1,0; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aoStrength est √©gal √† aoStrengthEnd; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il en r√©sulte un retour AO, qui repr√©sente environ 77% (force finale) de la valeur d'entr√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'AO entrant pour cette fonction √©tait auparavant soumis √† l'op√©ration max.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettre tous ensemble</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir re√ßu la couleur et l'effet de la couleur du brouillard et de la couleur de l'atmosph√®re, vous pouvez enfin les combiner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commen√ßons par att√©nuer l'effet avec l'AO r√©sultant:</font></font><br>
<br>
<pre><code class="cpp hljs">   ...<font></font>
   FogResult fog = CalculateFog( worldPos, CameraPosition, fogStart, ao, <span class="hljs-literal">false</span> );  <font></font>
      <font></font>
   <span class="hljs-comment">// Apply AO to influence  </span><font></font>
   fog.paramsFog.w *= ao;  <font></font>
   fog.paramsAerial.w *= ao; <font></font>
      <font></font>
   <span class="hljs-comment">// Mix fog with scene color  </span>
   outColor = ApplyFog(fog, colorHDR);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute la magie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√®re</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la fonction </font><b><font style="vertical-align: inherit;">ApplyFog</font></b><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function">float3 <span class="hljs-title">ApplyFog</span><span class="hljs-params">(FogResult fog, float3 color)</span>  
 </span>{  
   <span class="hljs-keyword">const</span> float3 LuminanceFactors = float3(<span class="hljs-number">0.333f</span>, <span class="hljs-number">0.555f</span>, <span class="hljs-number">0.222f</span>);  <font></font>
   <font></font>
   float3 aerialColor = dot(LuminanceFactors, color) * fog.paramsAerial.xyz;  <font></font>
   color = lerp(color, aerialColor, fog.paramsAerial.w);  <font></font>
   color = lerp(color, fog.paramsFog.xyz, fog.paramsFog.w);  <font></font>
    <font></font>
   <span class="hljs-keyword">return</span> color.xyz;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous calculons la luminosit√© des pixels:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bd/b00/570/6bdb005708a11953aeb8ce711a942f0d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous le multiplions par la couleur de l'atmosph√®re:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/f89/f04/e7df89f04524c4e547a91a645317a387.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous combinons la couleur HDR avec la couleur de l'atmosph√®re:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/40a/912/cae40a9124b33e97aa38ac5b72b9a5ae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La derni√®re √©tape consiste √† combiner le r√©sultat interm√©diaire avec la couleur du brouillard:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques captures d'√©cran de d√©bogage</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/b08/e69/012b08e69615702c9267f24f167dfa98.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effet atmosph√©rique</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/c3a/f2c/b1bc3af2c5d59db606570a54e861659b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur de l'atmosph√®re</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/b17/0ab/d10b170ab255b3ff9b4d6fad60e1c1e3.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effet de brouillard</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9ae/dde/d769aedde1917ab6024e524d9c99625d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur de brouillard</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/b15/0dd/7adb150dddf4df73c8dc75e51aa9e138.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sc√®ne termin√©e sans brouillard</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/fdc/507/f53fdc5076e000acb24a775ba7558e8a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sc√®ne pr√™te √† l'emploi avec du brouillard uniquement</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad1/223/e4a/ad1223e4aabc3dc3f07a77125b54211f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sc√®ne termin√©e n'est que le brouillard principal</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sc√®ne pr√™te √† l'emploi avec tout le brouillard pour faciliter la comparaison</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que vous pouvez comprendre beaucoup de ce qui pr√©c√®de, si vous regardez le shader, il est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je peux dire avec plaisir que ce shader </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est exactement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le m√™me que celui d'origine - il me fait tr√®s plaisir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En g√©n√©ral, le r√©sultat final d√©pend fortement des valeurs transmises au shader. Ce n'est pas une solution ¬´magique¬ª qui donne des couleurs parfaites pour la sortie, elle n√©cessite de nombreuses it√©rations et artistes pour que le r√©sultat final soit d√©cent. Je pense que cela peut √™tre un long processus, mais une fois termin√©, le r√©sultat sera tr√®s convaincant, tout comme cette sc√®ne de coucher de soleil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Witcher 3 Sky Shader utilise √©galement des calculs de brouillard pour cr√©er une transition en douceur des couleurs pr√®s de l'horizon. </font><font style="vertical-align: inherit;">Cependant, un ensemble diff√©rent de coefficients de densit√© est transmis au shader du ciel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de vous rappeler - la plupart de ce shader n'a pas √©t√© cr√©√© / analys√© par moi. </font><font style="vertical-align: inherit;">Tous les remerciements doivent √™tre envoy√©s √† CD PROJEKT RED. </font><font style="vertical-align: inherit;">Soutenez-les, ils font un excellent travail.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 3. √âtoiles filantes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans The Witcher 3, il y a un d√©tail petit mais curieux - les √©toiles filantes. </font><font style="vertical-align: inherit;">Fait int√©ressant, ils ne semblent pas figurer dans le DLC Blood and Wine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la vid√©o, vous pouvez voir √† quoi ils ressemblent:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IWtutrr6ilE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment nous avons r√©ussi √† obtenir cet effet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, le corps d'une √©toile filante est beaucoup plus lumineux que la queue. </font><font style="vertical-align: inherit;">Il s'agit d'une propri√©t√© importante que nous utiliserons plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre programme est assez familier: je vais d'abord d√©crire les propri√©t√©s g√©n√©rales, puis je parlerai de sujets li√©s √† la g√©om√©trie, et √† la fin nous passerons au pixel shader, o√π les choses les plus int√©ressantes se produisent.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Aper√ßu g√©n√©ral</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©crivez bri√®vement ce qui se passe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les √©toiles filantes sont dessin√©es dans un passage proactif, imm√©diatement apr√®s le d√¥me du ciel, du ciel et de la lune:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/a71/7db/1c5a717dbd047aeaa183ce2a25e394d9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (720) - le d√¥me du ciel, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (2160) - la sph√®re pour le ciel / la lune, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (36) - n'a pas d'importance, ressemble √† un parall√©l√©pip√®de de l'occlusion du soleil (?) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (12) - l'√©toile filante </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexedInstanced (1116, 1) - nuages ‚Äã‚Äãcirrus </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les nuages ‚Äã‚Äãcirrus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , chaque √©toile filante est dessin√©e deux fois de suite.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/27d/e4c/baa27de4ced017770e9c89a01e136abd.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant le premier appel de tirage</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/78b/cef/cc878bcef6dcc4b58e85f3a62f90be31.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat du premier appel de tirage</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ee/33f/f6c/0ee33ff6cef3d11ca7cd460f21dc2b3f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat du deuxi√®me appel de tirage</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En outre, comme dans de nombreux √©l√©ments de la passe pr√©emptive de ce jeu, l'√©tat de m√©lange suivant est utilis√©:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. G√©om√©trie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes de g√©om√©trie, la premi√®re chose √† mentionner est que chaque √©toile filante est repr√©sent√©e par un quadrilat√®re mince avec texcoords: 4 sommets, 6 indices. </font><font style="vertical-align: inherit;">C'est le quad le plus simple possible.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fbf/96b/82cfbf96bbc652ea5ac32a5e568434a3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quad approximatif d'une √©toile filante. Le quadruple approximatif d'une √©toile filante est </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/83c/59e/3f7/83c59e3f7e685d6e7f2080e88ff5be25.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encore plus proche. </font><font style="vertical-align: inherit;">Vous pouvez voir l'affichage filaire d'une ligne indiquant deux triangles. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attendez une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il y a </font><i><font style="vertical-align: inherit;">DrawIndexed (12)</font></i><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Est-ce √† dire que nous dessinons deux √©toiles filantes en m√™me temps? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/b39/bb2/d55b39bb2d2ea5908f4576d6396455fa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cadre, l'une des √©toiles filantes est compl√®tement en dehors de la pyramide de visibilit√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le code assembleur du vertex shader:</font></font><br>
<br>
<pre><code class="cpp hljs"> vs_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">193</span>], immediateIndexed  <font></font>
    dcl_input v0.xyz  <font></font>
    dcl_input v1.xyzw  <font></font>
    dcl_input v2.xy  <font></font>
    dcl_input v3.xy  <font></font>
    dcl_input v4.xy  <font></font>
    dcl_input v5.xyz  <font></font>
    dcl_input v6.x  <font></font>
    dcl_input v7.x  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_output o1.xyzw  <font></font>
    dcl_output o2.xy  <font></font>
    dcl_output o3.xyzw  <font></font>
    dcl_output_siv o4.xyzw, position  <font></font>
    dcl_temps <span class="hljs-number">5</span>  
   <span class="hljs-number">0</span>: mov r0.xyz, v0.xyzx  
   <span class="hljs-number">1</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
   <span class="hljs-number">2</span>: dp4 r1.x, r0.xyzw, cb2[<span class="hljs-number">0</span>].xyzw  
   <span class="hljs-number">3</span>: dp4 r1.y, r0.xyzw, cb2[<span class="hljs-number">1</span>].xyzw  
   <span class="hljs-number">4</span>: dp4 r1.z, r0.xyzw, cb2[<span class="hljs-number">2</span>].xyzw  
   <span class="hljs-number">5</span>: add r0.x, v2.x, v2.y  
   <span class="hljs-number">6</span>: add r0.y, -v2.y, v2.x  
   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx  
  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  
  <span class="hljs-number">30</span>: add r0.xyz, r0.xyzx, -cb12[<span class="hljs-number">0</span>].xyzx  
  <span class="hljs-number">31</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
  <span class="hljs-number">32</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">33</span>: div r0.xyz, r0.xyzx, r0.wwww  
  <span class="hljs-number">34</span>: add r0.w, r0.w, -cb12[<span class="hljs-number">22</span>].z  
  <span class="hljs-number">35</span>: max r0.w, r0.w, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">36</span>: min r0.w, r0.w, cb12[<span class="hljs-number">42</span>].z  
  <span class="hljs-number">37</span>: dp3 r0.x, cb12[<span class="hljs-number">38</span>].xyzx, r0.xyzx  
  <span class="hljs-number">38</span>: mul r0.y, <span class="hljs-built_in">abs</span>(r0.x), <span class="hljs-built_in">abs</span>(r0.x)  
  <span class="hljs-number">39</span>: mad_sat r1.x, r0.w, l(<span class="hljs-number">0.002000</span>), l(<span class="hljs-number">-0.300000</span>)  
  <span class="hljs-number">40</span>: mul r0.y, r0.y, r1.x  
  <span class="hljs-number">41</span>: lt r1.x, l(<span class="hljs-number">0</span>), r0.x  
  <span class="hljs-number">42</span>: movc r1.yzw, r1.xxxx, cb12[<span class="hljs-number">39</span>].xxyz, cb12[<span class="hljs-number">41</span>].xxyz  
  <span class="hljs-number">43</span>: add r1.yzw, r1.yyzw, -cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">44</span>: mad r1.yzw, r0.yyyy, r1.yyzw, cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">45</span>: movc r2.xyz, r1.xxxx, cb12[<span class="hljs-number">45</span>].xyzx, cb12[<span class="hljs-number">47</span>].xyzx  
  <span class="hljs-number">46</span>: add r2.xyz, r2.xyzx, -cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">47</span>: mad o0.xyz, r0.yyyy, r2.xyzx, cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">48</span>: ge r0.y, r0.w, cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">49</span>: if_nz r0.y  
  <span class="hljs-number">50</span>:  mad r0.y, r0.z, cb12[<span class="hljs-number">22</span>].z, cb12[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">51</span>:  mul r0.z, r0.w, r0.z  
  <span class="hljs-number">52</span>:  mul r0.z, r0.z, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">53</span>:  mul r1.x, r0.w, cb12[<span class="hljs-number">43</span>].x  
  <span class="hljs-number">54</span>:  mul r1.x, r1.x, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">55</span>:  add r0.x, r0.x, cb12[<span class="hljs-number">42</span>].x  
  <span class="hljs-number">56</span>:  add r2.x, cb12[<span class="hljs-number">42</span>].x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>:  div_sat r0.x, r0.x, r2.x  
  <span class="hljs-number">58</span>:  add r2.x, -cb12[<span class="hljs-number">43</span>].z, cb12[<span class="hljs-number">43</span>].y  
  <span class="hljs-number">59</span>:  mad r0.x, r0.x, r2.x, cb12[<span class="hljs-number">43</span>].z  
  <span class="hljs-number">60</span>:  add r0.y, r0.y, cb12[<span class="hljs-number">42</span>].y  
  <span class="hljs-number">61</span>:  mul r2.x, r0.x, r0.y  
  <span class="hljs-number">62</span>:  mul r0.z, r0.x, r0.z  
  <span class="hljs-number">63</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>), r2.xxxx  
  <span class="hljs-number">64</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">65</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">66</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">67</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">68</span>:  mul r2.y, r3.y, r3.x  
  <span class="hljs-number">69</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">70</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">71</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>), r2.xxxx  
  <span class="hljs-number">72</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">73</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">74</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">75</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">76</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">77</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">78</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">79</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">80</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>), r2.xxxx  
  <span class="hljs-number">81</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">82</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">83</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">84</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">85</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">86</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">87</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">88</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">89</span>:  mad r2.zw, r0.zzzz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>), r2.xxxx  
  <span class="hljs-number">90</span>:  max r2.zw, r2.zzzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">91</span>:  add r2.zw, r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">92</span>:  div_sat r2.zw, r1.xxxx, r2.zzzw  
  <span class="hljs-number">93</span>:  add r2.zw, -r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">94</span>:  mul r2.y, r2.z, r2.y  
  <span class="hljs-number">95</span>:  mul r2.y, r2.w, r2.y  
  <span class="hljs-number">96</span>:  mad r2.x, r0.z, l(<span class="hljs-number">2.000000</span>), r2.x  
  <span class="hljs-number">97</span>:  max r2.x, r2.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">98</span>:  add r2.x, r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">99</span>:  div_sat r2.x, r1.x, r2.x  
  <span class="hljs-number">100</span>:  add r2.x, -r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">101</span>:  mul r2.x, r2.x, r2.y  
  <span class="hljs-number">102</span>:  mad r0.x, r0.y, r0.x, r0.z  
  <span class="hljs-number">103</span>:  max r0.x, r0.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">104</span>:  add r0.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">105</span>:  div_sat r0.x, r1.x, r0.x  
  <span class="hljs-number">106</span>:  add r0.x, -r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">107</span>:  mad r0.x, -r2.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">108</span>:  add r0.y, r0.w, -cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">109</span>:  mul_sat r0.y, r0.y, cb12[<span class="hljs-number">48</span>].z  
  <span class="hljs-number">110</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">111</span>:  mov r0.xy, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">112</span>: endif  
  <span class="hljs-number">113</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">114</span>: mul r0.z, r0.x, cb12[<span class="hljs-number">42</span>].w  
  <span class="hljs-number">115</span>: <span class="hljs-built_in">exp</span> r0.z, r0.z  
  <span class="hljs-number">116</span>: mul r0.z, r0.z, r0.y  
  <span class="hljs-number">117</span>: mul r0.x, r0.x, cb12[<span class="hljs-number">48</span>].x  
  <span class="hljs-number">118</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  <span class="hljs-number">119</span>: mul o0.w, r0.x, r0.y  
  <span class="hljs-number">120</span>: mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">121</span>: add r2.xyz, -r1.yzwy, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">122</span>: mad r2.xyz, r0.xxxx, r2.xyzx, r1.yzwy  
  <span class="hljs-number">123</span>: add r0.x, cb12[<span class="hljs-number">188</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">124</span>: mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">125</span>: mul_sat r2.w, r0.x, r0.z  
  <span class="hljs-number">126</span>: lt r0.x, l(<span class="hljs-number">0</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">127</span>: if_nz r0.x  
  <span class="hljs-number">128</span>:  mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">129</span>:  add r3.xyz, -r1.yzwy, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">130</span>:  mad r1.xyz, r0.xxxx, r3.xyzx, r1.yzwy  
  <span class="hljs-number">131</span>:  add r0.x, cb12[<span class="hljs-number">190</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">132</span>:  mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">133</span>:  mul_sat r1.w, r0.x, r0.z  
  <span class="hljs-number">134</span>:  add r0.xyzw, -r2.xyzw, r1.xyzw  
  <span class="hljs-number">135</span>:  mad o1.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r0.xyzw, r2.xyzw  
  <span class="hljs-number">136</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">137</span>:  mov o1.xyzw, r2.xyzw  
  <span class="hljs-number">138</span>: endif  
  <span class="hljs-number">139</span>: mov o3.xyzw, v1.xyzw  
  <span class="hljs-number">140</span>: mov o2.xy, v4.yxyy  
  <span class="hljs-number">141</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, le calcul du brouillard peut imm√©diatement attirer l'attention (lignes 30-138). Le calcul du sommet du brouillard est logique pour des raisons de performances. De plus, nous n'avons pas besoin d'une telle pr√©cision du brouillard - les m√©t√©orites survolent g√©n√©ralement la t√™te de Geralt et n'atteignent pas l'horizon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les param√®tres atmosph√©riques (rgb = couleur, a = influence) sont stock√©s dans o0.xyzw, et les param√®tres de brouillard dans o1.xyzw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o2.xy (ligne 140) est juste des texcoords. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o3.xyzw (ligne 139) n'est pas pertinent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, disons quelques mots sur le calcul d'une position dans le monde. Les vertex shaders effectuent des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panneaux d'affichage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout d'abord, les donn√©es entrantes pour les panneaux d'affichage proviennent du tampon de vertex - jetons-y un ≈ìil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les premi√®res donn√©es sont Position:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/470/7d5/99a4707d5f914222e7d55e2435f5692f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionn√© ci-dessus, nous avons ici 2 quad-a: 8 sommets, 12 indices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pourquoi la position est-elle la m√™me pour chaque quad? </font><font style="vertical-align: inherit;">Assez simple - c'est la position du centre du quad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, chaque sommet a un d√©calage du centre vers le bord du quad:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cde/fdf/7e0/cdefdf7e0e5cfe91c4b9d20257b529b4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que chaque √©toile filante a une taille de (400, 3) unit√©s dans l'espace mondial. </font><font style="vertical-align: inherit;">(sur le plan XY, dans Witcher 3, l'axe Z est dirig√© vers le haut) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le dernier √©l√©ment de chaque sommet est un vecteur de direction unitaire dans l'espace mondial qui contr√¥le le mouvement d'une √©toile filante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/416/06d/71a/41606d71a99d2f751f8b1d5a609b6c96.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que les donn√©es proviennent du CPU, il est difficile de comprendre comment elles sont calcul√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant au code d'affichage. </font><font style="vertical-align: inherit;">L'id√©e est assez simple - vous obtenez d'abord un vecteur unitaire du centre du quad √† la cam√©ra:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous obtenons un seul vecteur tangent qui contr√¥le le mouvement de l'√©toile filante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etant donn√© que ce vecteur est d√©j√† normalis√© c√¥t√© CPU, cette normalisation est redondante.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il y a deux vecteurs, un produit vectoriel est utilis√© pour d√©terminer le vecteur bi-tangent perpendiculaire aux deux vecteurs entrants.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant des vecteurs normalis√©s </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangents</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r3.xyz) et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitangents</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r2.xyz). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduisons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xsize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ysize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondant √† l'√©l√©ment entrant TEXCOORD1, donc par exemple (-200, 1.50). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le calcul final de la position dans l'espace mondial est effectu√© comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que r0.x, r0.y et r0.z sont √©gaux √† 1,0, le calcul final est simplifi√©: </font></font><br>
<br>
<code>worldSpacePosition = quadCenter + tangent * Xsize + bitangent * Ysize</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La derni√®re partie est une simple multiplication d'une position dans l'espace mondial par une matrice de projection de vue pour obtenir SV_Position:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Pixel Shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme indiqu√© dans la section Pr√©sentation g√©n√©rale, l'√©tat de fusion suivant est utilis√©: </font><font style="vertical-align: inherit;">
o√π </font><i><font style="vertical-align: inherit;">SrcColor</font></i><font style="vertical-align: inherit;"> et </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> sont respectivement les composants .rgb et .a du pixel shader et </font><i><font style="vertical-align: inherit;">DestColor est la</font></i><font style="vertical-align: inherit;"> couleur </font><i><font style="vertical-align: inherit;">.rgb</font></i><font style="vertical-align: inherit;"> actuellement dans le rendu cible. </font><font style="vertical-align: inherit;">
Le principal indicateur qui contr√¥le la transparence est </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> . De nombreux shaders de jeu proactifs le calculent comme l'opacit√© et l'appliquent √† la fin comme suit: Le </font><font style="vertical-align: inherit;">
shader d'√©toiles filantes ne fait pas exception. En suivant ce mod√®le, nous consid√©rons trois cas dans lesquels l' </font><i><font style="vertical-align: inherit;">opacit√©</font></i><font style="vertical-align: inherit;"> est de 1,0, 0,1 et 0,0.</font></font><br>
<br>
<code>FinalColor = SrcColor * One + DestColor * (1.0 - SrcAlpha) =<br>
FinalColor = SrcColor + DestColor * (1.0 - SrcAlpha)</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>return float4( color * opacity, opacity )</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>a) opacity = 1.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = color = SrcColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/934/711/31c/93471131c99ec7b2249cff6edb698859.jpg"></div><br>
<code>b) opacity = 0.1<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = 0.1 * color + 0.9 * DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/269/b24/d90/269b24d90592abb5065fba0f2a0aaf9f.jpg"></div><br>
<code>c) opacity = 0.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/191/75e/b6e/19175eb6e6757c04a0a063e75bad96f2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e sous-jacente de ce shader est de mod√©liser et d'utiliser l'opacit√© de la fonction d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacit√© (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui contr√¥le l'opacit√© d'un pixel le long d'une √©toile filante. La principale exigence est que l'opacit√© atteigne des valeurs maximales √† l'extr√©mit√© de l'√©toile (son ¬´corps¬ª) et passe progressivement √† 0,0 (√† sa ¬´queue¬ª). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous commen√ßons √† comprendre le code assembleur du pixel shader, cela devient √©vident:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_input_ps linear v0.xyzw  <font></font>
    dcl_input_ps linear v1.xyzw  <font></font>
    dcl_input_ps linear v2.y  <font></font>
    dcl_input_ps linear v3.w  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_temps <span class="hljs-number">4</span>  
   <span class="hljs-number">0</span>: mov_sat r0.x, v2.y  
   <span class="hljs-number">1</span>: ge r0.y, r0.x, l(<span class="hljs-number">0.052579</span>)  
   <span class="hljs-number">2</span>: ge r0.z, l(<span class="hljs-number">0.965679</span>), r0.x  
   <span class="hljs-number">3</span>: <span class="hljs-keyword">and</span> r0.y, r0.z, r0.y  
   <span class="hljs-number">4</span>: if_nz r0.y  
   <span class="hljs-number">5</span>:  ge r0.y, l(<span class="hljs-number">0.878136</span>), r0.x  
   <span class="hljs-number">6</span>:  add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)  
   <span class="hljs-number">7</span>:  mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)  
   <span class="hljs-number">8</span>:  mov_sat r0.z, r1.w  
   <span class="hljs-number">9</span>:  mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">10</span>:  mul r0.z, r0.z, r0.z  
  <span class="hljs-number">11</span>:  mul r0.z, r0.z, r0.w  
  <span class="hljs-number">12</span>:  mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">13</span>:  mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">14</span>:  movc r2.yzw, r0.yyyy, r1.yyzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">15</span>:  <span class="hljs-keyword">not</span> r0.z, r0.y  
  <span class="hljs-number">16</span>:  if_z r0.y  
  <span class="hljs-number">17</span>:   ge r0.y, l(<span class="hljs-number">0.924339</span>), r0.x  
  <span class="hljs-number">18</span>:   add r0.w, r0.x, l(<span class="hljs-number">-0.878136</span>)  
  <span class="hljs-number">19</span>:   mul r1.w, r0.w, l(<span class="hljs-number">21.643608</span>)  
  <span class="hljs-number">20</span>:   mov_sat r0.w, r1.w  
  <span class="hljs-number">21</span>:   mad r3.x, r0.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">22</span>:   mul r0.w, r0.w, r0.w  
  <span class="hljs-number">23</span>:   mul r0.w, r0.w, r3.x  
  <span class="hljs-number">24</span>:   mad r1.x, r0.w, l(<span class="hljs-number">0.889658</span>), l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">25</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">26</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">27</span>:  <span class="hljs-keyword">else</span>  
  <span class="hljs-number">28</span>:   mov r2.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">29</span>:   mov r0.y, l(<span class="hljs-number">-1</span>)  
  <span class="hljs-number">30</span>:  endif  
  <span class="hljs-number">31</span>:  <span class="hljs-keyword">not</span> r0.w, r0.y  
  <span class="hljs-number">32</span>:  <span class="hljs-keyword">and</span> r0.z, r0.w, r0.z  
  <span class="hljs-number">33</span>:  if_nz r0.z  
  <span class="hljs-number">34</span>:   ge r0.y, r0.x, l(<span class="hljs-number">0.924339</span>)  
  <span class="hljs-number">35</span>:   add r0.x, r0.x, l(<span class="hljs-number">-0.924339</span>)  
  <span class="hljs-number">36</span>:   mul r1.w, r0.x, l(<span class="hljs-number">24.189651</span>)  
  <span class="hljs-number">37</span>:   mov_sat r0.x, r1.w  
  <span class="hljs-number">38</span>:   mad r0.z, r0.x, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">39</span>:   mul r0.x, r0.x, r0.x  
  <span class="hljs-number">40</span>:   mul r0.x, r0.x, r0.z  
  <span class="hljs-number">41</span>:   mad r1.x, r0.x, l(<span class="hljs-number">-0.974300</span>), l(<span class="hljs-number">0.974300</span>)  
  <span class="hljs-number">42</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">43</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">44</span>:  endif  
  <span class="hljs-number">45</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">46</span>:  mov r2.yzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">47</span>:  mov r0.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">48</span>: endif  
  <span class="hljs-number">49</span>: mov_sat r2.w, r2.w  
  <span class="hljs-number">50</span>: mad r0.x, r2.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">51</span>: mul r0.z, r2.w, r2.w  
  <span class="hljs-number">52</span>: mul r0.x, r0.z, r0.x  
  <span class="hljs-number">53</span>: add r0.z, -r2.y, r2.z  
  <span class="hljs-number">54</span>: mad r0.x, r0.x, r0.z, r2.y  
  <span class="hljs-number">55</span>: movc r0.x, r0.y, r2.x, r0.x  
  <span class="hljs-number">56</span>: mad r0.y, cb4[<span class="hljs-number">1</span>].x, -cb0[<span class="hljs-number">9</span>].w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>: mul_sat r0.y, r0.y, v3.w  
  <span class="hljs-number">58</span>: mul r0.x, r0.y, r0.x  
  <span class="hljs-number">59</span>: mul r0.yzw, cb2[<span class="hljs-number">2</span>].xxyz, cb4[<span class="hljs-number">0</span>].xxxx  
  <span class="hljs-number">60</span>: mul r0.x, r0.x, cb2[<span class="hljs-number">2</span>].w  
  <span class="hljs-number">61</span>: dp3 r1.x, l(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>), r0.yzwy  
  <span class="hljs-number">62</span>: mad r1.xyz, r1.xxxx, v0.xyzx, -r0.yzwy  
  <span class="hljs-number">63</span>: mad r0.yzw, v0.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">64</span>: add r1.xyz, -r0.yzwy, v1.xyzx  
  <span class="hljs-number">65</span>: mad r0.yzw, v1.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">66</span>: mul o0.xyz, r0.xxxx, r0.yzwy  
  <span class="hljs-number">67</span>: mov o0.w, r0.x  
  <span class="hljs-number">68</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En g√©n√©ral, le shader est un peu trop compliqu√© et il √©tait difficile pour moi de comprendre ce qui s'y passait. </font><font style="vertical-align: inherit;">Par exemple, d'o√π viennent toutes les valeurs comme 1.211303, 21.643608 et 24.189651? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous parlons de la fonction d'opacit√©, nous avons besoin d'une valeur d'entr√©e. </font><font style="vertical-align: inherit;">C'est assez simple - texcoord dans la plage de [0,1] (ligne 0) sera utile ici, afin que nous puissions appliquer la fonction √† toute la longueur du m√©t√©oro√Øde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction d'opacit√© a trois segments / intervalles d√©finis par quatre points de contr√¥le:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// current status: no idea how these are generated  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint0 = <span class="hljs-number">0.052579</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint1 = <span class="hljs-number">0.878136</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint2 = <span class="hljs-number">0.924339</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint3 = <span class="hljs-number">0.965679</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai aucune id√©e de la fa√ßon dont ils ont √©t√© s√©lectionn√©s / calcul√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous pouvons le voir dans le code assembleur, la premi√®re condition est simplement de v√©rifier si la valeur d'entr√©e est dans la plage [controlPoint0 - controlPoint3]. </font><font style="vertical-align: inherit;">Sinon, l'opacit√© n'est que de 0,0.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Input for the opacity function</span>
   <span class="hljs-keyword">float</span> y = saturate(Input.Texcoords.y);  <span class="hljs-comment">// r0.x</span><font></font>
     <font></font>
   <span class="hljs-comment">// Value of opacity function.  </span>
   <span class="hljs-comment">// 0 - no change  </span>
   <span class="hljs-comment">// 1 - full color  </span>
   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
      ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le d√©chiffrement du code assembleur ci-dessous est </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessaire</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si nous voulons comprendre comment fonctionne la fonction d'opacit√©:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">6</span>: add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)   
   <span class="hljs-number">7</span>: mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)   
   <span class="hljs-number">8</span>: mov_sat r0.z, r1.w   
   <span class="hljs-number">9</span>: mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)   
  <span class="hljs-number">10</span>: mul r0.z, r0.z, r0.z   
  <span class="hljs-number">11</span>: mul r0.z, r0.z, r0.w   
  <span class="hljs-number">12</span>: mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ligne 9 a les coefficients ¬´-2,0¬ª et ¬´3,0¬ª, ce qui indique l'utilisation de la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Oui, c'est une bonne supposition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction HLSL smoothstep avec prototype: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ret smoothstep (min, max, x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limite toujours </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x √†</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. Du point de vue de l'assembleur, cela soustrait </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la valeur d'entr√©e (c'est-√†-dire de r0.z sur la ligne 9), mais il n'y a rien de tel dans le code. Pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cela implique une multiplication de la valeur d'entr√©e, mais il n'y a rien de tel que ¬´mul_sat¬ª dans le code. Au lieu de cela, il y a ¬´mov_sat¬ª. Cela nous dit que les fonctions </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du smoothstep sont 0 et 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons maintenant que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit √™tre dans l'intervalle [0, 1]. Comme indiqu√© ci-dessus, la fonction d'opacit√© comprend trois segments. Cela indique clairement que le code cherche o√π nous en sommes dans l'intervalle [segmentStart-segmentEnd]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La r√©ponse est la fonction Linstep!</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">(<span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v)</span>  
 </span>{  
   <span class="hljs-keyword">return</span> ( (v-min) / (max-min) );  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, prenons le premier segment: [0,052579 - 0,878136]. </font><font style="vertical-align: inherit;">La soustraction est sur la ligne 6. Si nous rempla√ßons la division par la multiplication -&gt; 1,0 / (0,878136 - 0,052579) = 1,0 / 0,825557 = ~ 1,211303. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le r√©sultat du lissage est dans la plage [0, 1]. </font><font style="vertical-align: inherit;">La multiplication sur la ligne 12 est le poids du segment. </font><font style="vertical-align: inherit;">Chaque segment a son propre poids, vous permettant de contr√¥ler l'opacit√© maximale de ce segment particulier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que pour le premier segment [0,052579 - 0,878136], l'opacit√© est dans la plage [0 - 0,084642]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction HLSL qui calcule l'opacit√© pour un segment arbitraire peut √™tre √©crite comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getOpacityFunctionValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> cpLeft, <span class="hljs-keyword">float</span> cpRight, <span class="hljs-keyword">float</span> weight)</span>  
 </span>{  
   <span class="hljs-keyword">float</span> val = smoothstep( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, linstep(cpLeft, cpRight, x) );  
   <span class="hljs-keyword">return</span> val * weight;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, le but est simplement d'appeler cette fonction pour le segment correspondant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez un ≈ìil aux poids:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight0 = <span class="hljs-number">0.084642</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight1 = <span class="hljs-number">0.889658</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight2 = <span class="hljs-number">0.974300</span>; <span class="hljs-comment">// note: weight0+weight1 = weight2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon le code assembleur, la fonction d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacit√© (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">calcul√©e comme suit:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
     <span class="hljs-comment">// Range of v: [0, weight0]  </span>
     <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint0, controlPoint1, weight0);  <font></font>
     opacity = v;  <font></font>
     <font></font>
     [branch]  <font></font>
     <span class="hljs-keyword">if</span> ( y &gt;= controlPoint1 )  <font></font>
     {  <font></font>
       <span class="hljs-comment">// Range of v: [0, weight1]  </span>
       <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint1, controlPoint2, weight1);  <font></font>
       opacity = weight0 + v;  <font></font>
   <font></font>
       [branch]  <font></font>
       <span class="hljs-keyword">if</span> (y &gt;= controlPoint2)  <font></font>
       {  <font></font>
         <span class="hljs-comment">// Range of v: [0, weight2]  </span>
         <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint2, controlPoint3, weight2);<font></font>
         opacity = weight2 - v;          <font></font>
       }  <font></font>
     }  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un graphique de la fonction d'opacit√©. </font><font style="vertical-align: inherit;">Vous pouvez facilement voir une forte augmentation de l'opacit√©, indiquant le d√©but du corps d'une √©toile filante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/326/1f0/5da3261f0f88fa41ac963ca84fc79f99.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction d'opacit√© du graphique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal rouge - valeur d'opacit√© </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal vert - points de contr√¥le </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal bleu - poids</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Apr√®s le calcul de l'opacit√©, tout le reste n'est que la touche finale. </font><font style="vertical-align: inherit;">Il y a ensuite des multiplications suppl√©mentaires: l'opacit√© des √©toiles, la couleur de l'√©toile filante et l'influence du brouillard. </font><font style="vertical-align: inherit;">Comme d'habitude dans les shaders TW3, vous pouvez √©galement trouver des multiplications redondantes par 1.0 ici:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// cb4_v1.x = 1.0  </span>
   <span class="hljs-keyword">float</span> starsOpacity = <span class="hljs-number">1.0</span> - cb0_v9.w * cb4_v1.x;    <font></font>
   opacity *= starsOpacity;  <font></font>
<font></font>
   <span class="hljs-comment">// Calculate color of a shooting star  </span>
   <span class="hljs-comment">// cb4_v0.x = 10.0</span>
   <span class="hljs-comment">// cb2_v2.rgb = (1.0, 1.0, 1.0)</span><font></font>
   float3 color = cb2_v2.rgb * cb4_v0.x;<font></font>
     <font></font>
   <span class="hljs-comment">// cb2_v2.w = 1  </span><font></font>
   opacity *= cb2_v2.w;<font></font>
     <font></font>
   FogResult fr = { Input.FogParams, Input.AerialParams };  <font></font>
   color = ApplyFog(fr, color);<font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4( color*opacity, opacity);  <font></font>
 }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. R√©sum√©</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La principale difficult√© r√©side dans la partie avec la fonction d'opacit√©. Apr√®s l'avoir d√©cod√©, tout le reste est assez simple √† comprendre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai dit plus haut que le pixel shader √©tait un peu trop compliqu√©. En fait, nous nous soucions uniquement de la valeur de la fonction d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacit√© (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est stock√©e dans r2.x (√† partir de la ligne 49). Cependant, la fonction d'opacit√© dans le code assembleur cr√©e trois variables suppl√©mentaires: minRange (r2.y), maxRange (r2.z) et value (r2.w). Tous sont des param√®tres utilis√©s pour calculer l'opacit√© lorsque l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacit√© (x) n'est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas utilis√©e: </font></font><br>
<br>
<code>lerp( minRange, maxRange, smoothstep(0, 1, value) );</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en fait, la valeur finale de l'opacit√© est obtenue dans la branche conditionnelle de la ligne 55 - si la valeur d'entr√©e est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est dans la plage [controlPoint0 - controlPoint3], cela signifie que la fonction d'opacit√© est utilis√©e, donc r2.x est s√©lectionn√©. </font><font style="vertical-align: inherit;">Sinon, lorsque </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est en dehors de l'intervalle, l'opacit√© est calcul√©e √† partir de r0.x, c'est-√†-dire selon l'√©quation ci-dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai d√©bogu√© quelques pixels en dehors de l'intervalle [controlPoint0 - controlPoint3], et l'opacit√© finale s'est toujours av√©r√©e √™tre nulle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout pour aujourd'hui. </font><font style="vertical-align: inherit;">Et comme toujours, merci d'avoir lu.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489092/index.html">Comment j'ai ind√©pendamment appris une nouvelle langue en 12 mois: un guide complet</a></li>
<li><a href="../fr489100/index.html">Analyse des donn√©es sur le coronavirus du SRAS-CoV-2 (2019-nCov)</a></li>
<li><a href="../fr489102/index.html">Fausses vie d'√©cran. "Oui, je connais personnellement Madonna"</a></li>
<li><a href="../fr489106/index.html">Comment j'ai quitt√© le journalisme et suis devenu programmeur</a></li>
<li><a href="../fr489108/index.html">Ajout de vos champs √† un rapport Pytest</a></li>
<li><a href="../fr489122/index.html">Requ√™tes OData typ√©es dans TypeScript</a></li>
<li><a href="../fr489128/index.html">Internationalisation: comment amener le produit sur le march√© international (et ne pas devenir fou)</a></li>
<li><a href="../fr489132/index.html">Points forts des syst√®mes int√©gr√©s Europe 2020</a></li>
<li><a href="../fr489134/index.html">Recherche des √©quipes de conception dans les entreprises alimentaires russes</a></li>
<li><a href="../fr489136/index.html">Gagner avec vingt lignes Haskell: √©crire votre Wc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>