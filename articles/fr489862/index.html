<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê± üë∏üèΩ üë®üèª‚Äçüé® Planning in Go: Part II - The Go Scheduler üë©üèæ‚Äç‚öïÔ∏è üïå ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Il s'agit du deuxi√®me article d'une s√©rie en trois parties, qui donnera une id√©e de la m√©canique et de la s√©mantique du travail de l'or...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planning in Go: Part II - The Go Scheduler</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font><font style="vertical-align: inherit;">Il s'agit du deuxi√®me article d'une s√©rie en trois parties, qui donnera une id√©e de la m√©canique et de la s√©mantique du travail de l'ordonnanceur dans Go. </font><font style="vertical-align: inherit;">Ce message concerne le planificateur Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premi√®re partie de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette s√©rie, j'ai expliqu√© les aspects du planificateur du syst√®me d'exploitation qui, √† mon avis, sont importants pour comprendre et √©valuer la s√©mantique du planificateur Go. </font><font style="vertical-align: inherit;">Dans cet article, je vais expliquer √† un niveau s√©mantique comment fonctionne le planificateur Go. </font><font style="vertical-align: inherit;">Le Go Scheduler est un syst√®me complexe et les petits d√©tails m√©caniques ne sont pas importants. </font><font style="vertical-align: inherit;">Il est important d'avoir un bon mod√®le de fonctionnement et de comportement de tout. </font><font style="vertical-align: inherit;">Cela vous permettra de prendre les meilleures d√©cisions d'ing√©nierie.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre programme d√©marre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque votre programme Go d√©marre, un processeur logique (P) lui est attribu√© pour chaque c≈ìur virtuel d√©fini sur la machine h√¥te. Si vous avez un processeur avec plusieurs threads mat√©riels par noyau physique (Hyper-Threading), chaque thread mat√©riel sera pr√©sent√© √† votre programme comme un noyau virtuel. Pour mieux comprendre cela, consultez le rapport syst√®me de mon MacBook Pro. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez voir que j'ai un processeur avec 4 c≈ìurs physiques. Ce rapport ne divulgue pas le nombre de threads mat√©riels par c≈ìur physique. Le processeur Intel Core i7 dispose de la technologie Hyper-Threading, ce qui signifie que le noyau physique poss√®de 2 threads mat√©riels. Cela indique √† Go que 8 c≈ìurs virtuels sont disponibles pour ex√©cuter des threads de syst√®me d'exploitation en parall√®le. Pour v√©rifier cela, envisagez le programme suivant:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque j'ex√©cute ce programme sur mon ordinateur, le r√©sultat de l'appel de la fonction NumCPU () sera 8. Tout programme Go que j'ex√©cute sur mon ordinateur obtiendra 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se voit attribuer un flux OS ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ce thread est toujours g√©r√© par l'OS, et l'OS est toujours responsable de placer le thread dans le noyau pour l'ex√©cution. Cela signifie que lorsque je lance Go sur mon ordinateur, j'ai 8 threads disponibles pour faire mon travail, chacun √©tant li√© individuellement √† P. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque programme Go re√ßoit √©galement une Goroutine initiale ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine est essentiellement Coroutine, mais c'est Go, donc nous rempla√ßons la lettre C par G et obtenons le mot Goroutine. Vous pouvez consid√©rer les Goroutines comme des threads au niveau de l'application, et ils ressemblent beaucoup aux threads du syst√®me d'exploitation. Tout comme les threads du syst√®me d'exploitation sont activ√©s et d√©sactiv√©s par le noyau, les programmes de contexte sont activ√©s et d√©sactiv√©s par le contexte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le dernier casse-t√™te concerne les files d'attente d'ex√©cution. </font><font style="vertical-align: inherit;">Il existe deux files d'attente d'ex√©cution diff√©rentes dans le planificateur Go: la file d'attente d'ex√©cution globale (GRQ) et la file d'attente d'ex√©cution locale (LRQ). </font><font style="vertical-align: inherit;">Chaque P se voit attribuer un LRQ qui contr√¥le les goroutins affect√©s √† l'ex√©cution dans le contexte de P. Ces goroutines s'allument et s'√©teignent √† partir du contexte M attribu√© √† ce P. GRQ est destin√© aux goroutines qui n'ont pas √©t√© attribu√©es √† P. Il existe un processus pour d√©placer les goroutines de GRQ √† LRQ, dont nous discuterons plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'image montre tous ces composants ensemble.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planificateur coop√©ratif</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons dit dans le premier article, le planificateur OS est un planificateur pr√©emptif. Essentiellement, cela signifie que vous ne pouvez pas pr√©dire ce que le planificateur va faire √† un moment donn√©. Le noyau prend des d√©cisions et tout n'est pas d√©terministe. Les applications ex√©cut√©es au-dessus du syst√®me d'exploitation ne contr√¥lent pas ce qui se passe √† l'int√©rieur du noyau avec la planification, sauf si elles utilisent des primitives de synchronisation telles que des instructions atomiques et des appels mutex.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Go Scheduler fait partie du Go Runtime et le Go Runtime est int√©gr√© √† votre application. Cela signifie que le planificateur Go fonctionne dans l'espace utilisateur du noyau. L'impl√©mentation actuelle du planificateur Go n'est pas un pr√©emptif, mais un planificateur interactif. √ätre un planificateur coop√©ratif signifie que le planificateur a besoin d'√©v√©nements clairement d√©finis dans l'espace utilisateur qui se produisent √† des points s√ªrs du code pour prendre des d√©cisions de planification.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est bien avec le planificateur collaboratif de Go, c'est qu'il a l'air et se sent proactif. </font><font style="vertical-align: inherit;">Vous ne pouvez pas pr√©dire ce que le planificateur Go va faire. </font><font style="vertical-align: inherit;">Cela est d√ª au fait que la prise de d√©cision pour ce planificateur ne d√©pend pas des d√©veloppeurs, mais du temps d'ex√©cution de Go. </font><font style="vertical-align: inherit;">Il est important de consid√©rer le planificateur Go comme un planificateur proactif, et puisque le planificateur n'est pas d√©terministe, il n'est pas trop difficile.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtats de Gorutin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout comme les flux, les goroutines ont les m√™mes trois √©tats de haut niveau. Ils d√©terminent le r√¥le que le planificateur Go joue avec n'importe quel goroutine. Goroutin peut √™tre dans l'un des trois √©tats: en attente, pr√™t ou satisfaisant. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cela signifie que le goroutine est arr√™t√© et attend que quelque chose continue. Cela peut se produire pour des raisons telles que l'attente du syst√®me d'exploitation (appels syst√®me) ou la synchronisation des appels (op√©rations atomiques et mutex). Ces types de retards sont la principale cause de mauvaises performances. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√©paration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: cela signifie que goroutine veut du temps pour suivre les instructions assign√©es. </font><font style="vertical-align: inherit;">Si vous avez beaucoup de goroutines qui ont besoin de temps, alors les goroutines devront attendre plus longtemps pour avoir du temps. </font><font style="vertical-align: inherit;">De plus, le temps individuel que chaque goroutine re√ßoit est r√©duit √† mesure que de plus en plus de goroutines se disputent le temps. </font><font style="vertical-align: inherit;">Ce type de retard de planification peut √©galement entra√Æner de mauvaises performances. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accomplissement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cela signifie que la goroutine a √©t√© plac√©e dans M et suit ses instructions. </font><font style="vertical-align: inherit;">Le travail associ√© √† la demande est termin√©. </font><font style="vertical-align: inherit;">C'est ce que tout le monde veut.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changement de contexte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Go Scheduler n√©cessite des √©v√©nements d'espace utilisateur bien d√©finis qui se produisent √† des points s√©curis√©s du code pour changer de contexte. </font><font style="vertical-align: inherit;">Ces √©v√©nements et points de s√©curit√© apparaissent dans les appels de fonction. </font><font style="vertical-align: inherit;">Les appels de fonction sont essentiels aux performances du planificateur Go. </font><font style="vertical-align: inherit;">Si vous ex√©cutez des boucles √©troites qui n'effectuent pas d'appels de fonction, vous provoquerez des retards dans le planificateur et la r√©cup√©ration de place. </font><font style="vertical-align: inherit;">Il est imp√©ratif que les appels de fonction se produisent dans un d√©lai raisonnable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe quatre classes d'√©v√©nements qui se produisent dans vos programmes Go qui permettent au planificateur de prendre des d√©cisions de planification. </font><font style="vertical-align: inherit;">Cela ne signifie pas que cela se produira toujours lors de l'un de ces √©v√©nements. </font><font style="vertical-align: inherit;">Cela signifie que le planificateur obtient l'opportunit√©.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation du mot cl√© go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âboueur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appels syst√®me</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utiliser le</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
mot cl√© </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> Le mot cl√© </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> est la fa√ßon dont vous cr√©ez goroutine. </font><font style="vertical-align: inherit;">D√®s qu'un nouveau goroutine est cr√©√©, il donne au planificateur la possibilit√© de prendre une d√©cision de planification. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage Collector (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Puisque le GC fonctionne avec son propre ensemble de goroutines, ces gorutins ont besoin de temps sur M pour fonctionner. </font><font style="vertical-align: inherit;">Cela oblige le GC √† cr√©er beaucoup de chaos dans la planification. </font><font style="vertical-align: inherit;">Cependant, le planificateur est tr√®s intelligent dans ce que fait le goroutine, et il s'en servira pour prendre des d√©cisions. </font><font style="vertical-align: inherit;">Une solution raisonnable consiste √† basculer le contexte vers goroutine, qui veut acc√©der √† la ressource syst√®me, et √† personne d'autre que lui pendant la r√©cup√©ration de place. </font><font style="vertical-align: inherit;">Lorsque le GC fonctionne, de nombreuses d√©cisions de planification sont prises. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appels syst√®me</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si goroutine effectue un appel syst√®me qui le bloquera M, l'ordonnanceur peut basculer le contexte vers un autre goroutine, vers le m√™me M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si un appel √† une op√©ration atomique, un mutex ou un canal provoque le blocage de goroutine, l'ordonnanceur peut changer de contexte pour d√©marrer un nouveau goroutine. </font><font style="vertical-align: inherit;">Une fois que le goroutine peut fonctionner √† nouveau, il peut √™tre mis en file d'attente et √©ventuellement revenir √† M.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appels syst√®me asynchrones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le syst√®me d'exploitation sur lequel vous travaillez a la capacit√© de traiter un appel syst√®me de mani√®re asynchrone, ce que l'on appelle un scrutateur r√©seau peut √™tre utilis√© pour traiter l'appel syst√®me plus efficacement. </font><font style="vertical-align: inherit;">Ceci est r√©alis√© en utilisant kqueue (MacOS), epoll (Linux) ou iocp (Windows) dans ces syst√®mes d'exploitation respectifs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les appels syst√®me r√©seau peuvent √™tre trait√©s de mani√®re asynchrone par de nombreux syst√®mes d'exploitation que nous utilisons aujourd'hui. C'est l√† que le scrutateur de r√©seau se montre, car son objectif principal est de traiter les op√©rations r√©seau. En utilisant l'interrogateur de r√©seau pour les appels syst√®me r√©seau, le planificateur peut emp√™cher les goroutines de bloquer M pendant ces appels syst√®me. Cela permet de garder M disponible pour ex√©cuter d'autres goroutines dans LRQ P sans avoir besoin de cr√©er un nouveau M. Cela permet de r√©duire la charge de planification dans le syst√®me d'exploitation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La meilleure fa√ßon de voir comment cela fonctionne est de regarder un exemple. La figure montre notre sch√©ma de planification de base. Gorutin-1 est ex√©cut√© sur M, et 3 autres Gorutins attendent dans LRQ pour obtenir leur temps sur M. Le poller du r√©seau est inactif, et il n'a rien √† faire.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure suivante, Gorutin-1 (G1) souhaite effectuer un appel syst√®me r√©seau, donc G1 se d√©place vers l'interrogateur r√©seau et est trait√© comme un appel syst√®me r√©seau asynchrone. </font><font style="vertical-align: inherit;">Une fois que G1 a √©t√© d√©plac√© vers le scrutateur r√©seau, M est maintenant disponible pour ex√©cuter un autre goroutine √† partir de LRQ. </font><font style="vertical-align: inherit;">Dans ce cas, Gorutin-2 passe √† M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure suivante, l'appel r√©seau syst√®me se termine par un appel r√©seau asynchrone et G1 revient √† LRQ pour P. Apr√®s que G1 puisse √™tre bascul√© √† nouveau sur M, le code associ√© √† Go, pour lequel il r√©pond peut s'ex√©cuter √† nouveau. </font><font style="vertical-align: inherit;">La grande victoire est qu'aucune Mme suppl√©mentaire n'est requise pour effectuer des appels syst√®me r√©seau. </font><font style="vertical-align: inherit;">Le poller r√©seau a un thread OS, et il traite via une boucle d'√©v√©nement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appels syst√®me synchrones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il lorsque goroutine souhaite effectuer un appel syst√®me qui ne peut pas √™tre ex√©cut√© de mani√®re asynchrone? </font><font style="vertical-align: inherit;">Dans ce cas, l'interrogateur r√©seau ne peut pas √™tre utilis√©, et le goroutine effectuant l'appel syst√®me bloquera M. C'est mauvais, mais il n'y a aucun moyen d'emp√™cher cela. </font><font style="vertical-align: inherit;">Un exemple d'appel syst√®me qui ne peut pas √™tre effectu√© de mani√®re asynchrone est les appels syst√®me bas√©s sur des fichiers. </font><font style="vertical-align: inherit;">Si vous utilisez CGO, il peut y avoir d'autres situations o√π l'appel de fonctions C bloque √©galement M.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le syst√®me d'exploitation Windows peut effectuer des appels syst√®me asynchrones bas√©s sur des fichiers. </font><font style="vertical-align: inherit;">Techniquement, lorsque vous travaillez sous Windows, vous pouvez utiliser l'interrogateur r√©seau.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons ce qui se passe avec un appel syst√®me synchrone (par exemple, des E / S de fichiers) qui bloquera M. La figure montre notre sch√©ma de planification de base, mais cette fois G1 va effectuer un appel syst√®me synchrone qui bloquera M1. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure suivante, le planificateur peut d√©terminer que G1 a provoqu√© un verrouillage M. √Ä ce stade, le planificateur d√©connecte M1 de P avec un blocage G1 toujours attach√©. L'ordonnanceur introduit ensuite un nouveau M2 pour servir P. √Ä ce stade, G2 peut √™tre s√©lectionn√© dans LRQ et inclus dans le contexte M2. Si M existe d√©j√† en raison d'un √©change pr√©c√©dent, cette transition est plus rapide que la n√©cessit√© de cr√©er un nouveau M.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©tape suivante termine l'appel syst√®me de verrouillage effectu√© par G1. </font><font style="vertical-align: inherit;">√Ä ce stade, G1 peut retourner √† LRQ et √™tre servi √† nouveau par P. M1 puis se met de c√¥t√© pour une utilisation future si ce sc√©nario devait √™tre r√©p√©t√©.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vol de travail</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre aspect de l'ordonnanceur est qu'il s'agit d'un planificateur de vol de goroutine. Cela aide dans plusieurs domaines √† soutenir une planification efficace. Premi√®rement, la derni√®re chose dont vous avez besoin est que M passe en √©tat de veille, car d√®s que cela se produit, le syst√®me d'exploitation basculera M du noyau en utilisant le contexte. Cela signifie que P ne peut faire aucun travail, m√™me s'il y a une Goroutine dans un √©tat sain, jusqu'√† ce que M revienne au noyau. Gorutin Theft aide √©galement √† √©quilibrer les intervalles de temps entre tous les Ps afin que le travail soit mieux r√©parti et ex√©cut√© plus efficacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure, nous avons un programme Go multi-thread avec deux Ps servant chacun quatre G et un G dans GRQ. Que se passe-t-il si l'un des P dessert rapidement tous ses G?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, P1 n'a plus de goroutines √† ex√©cuter. Mais il y a des goroutines en √©tat de marche, aussi bien en LRQ pour P2 qu'en GRQ. C'est le moment o√π P1 a besoin de voler de la goroutine. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les r√®gles pour voler des goroutines sont les suivantes. Tout le code peut √™tre consult√© dans les sources d'ex√©cution.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, sur la base de ces r√®gles, P1 devrait v√©rifier P2 la pr√©sence de goroutines dans son LRQ et prendre la moiti√© de ce qu'il trouve. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il si P2 finit de servir tous ses programmes et P1 n'a plus rien dans LRQ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 a termin√© tout son travail et doit maintenant voler les goroutines. </font><font style="vertical-align: inherit;">Tout d'abord, il examinera le LRQ P1, mais ne trouvera aucun Goroutine. </font><font style="vertical-align: inherit;">Il examinera ensuite GRQ. </font><font style="vertical-align: inherit;">L√†, il trouvera le G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 vole G9 √† GRQ et commence √† faire le travail. </font><font style="vertical-align: inherit;">Ce qui est bien avec tout ce vol, c'est qu'il permet √† M de rester occup√© et de ne pas √™tre inactif.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple pratique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec la m√©canique et la s√©mantique, je veux vous montrer comment tout cela se r√©unit pour que le planificateur Go puisse faire plus de travail au fil du temps. Imaginez une application multithread √©crite en C, dans laquelle le programme g√®re deux threads de syst√®me d'exploitation qui s'envoient des messages. Il y a 2 fils dans l'image qui envoient le message dans les deux sens. Le thread 1 re√ßoit le noyau 1 contextuel et est maintenant en cours d'ex√©cution, ce qui permet au thread 1 d'envoyer son message au thread 2.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, lorsque le thread 1 termine d'envoyer le message, il doit maintenant attendre une r√©ponse. Cela entra√Ænera la d√©connexion du thread 1 du contexte du noyau 1 et sa mise en attente. D√®s que le thread 2 re√ßoit une notification de message, il passe dans un √©tat sain. Maintenant, le syst√®me d'exploitation peut effectuer un changement de contexte et ex√©cuter le thread 2 sur le noyau, qui se r√©v√®le √™tre le noyau 2. Ensuite, le thread 2 traite le message et renvoie un nouveau message au thread 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, le flux repasse au contexte lorsque le message du flux 2 est re√ßu par le flux 1. Maintenant, le flux 2 bascule de l'√©tat d'ex√©cution √† l'√©tat de veille, et le flux 1 passe de l'√©tat de veille √† l'√©tat pr√™t et revient finalement √† l'√©tat d'ex√©cution, ce qui lui permet de traiter et renvoyer un nouveau message. Tous ces changements de contexte et changements d'√©tat prennent du temps, ce qui limite la vitesse du travail. √âtant donn√© que chaque changement de contexte entra√Æne un d√©lai d'environ 1000 nanosecondes et que nous esp√©rons que le mat√©riel ex√©cute 12 instructions par nanoseconde, vous examinez 12 000 instructions qui ne sont plus ou moins ex√©cut√©es lors de ces changements de contexte. √âtant donn√© que ces flux se croisent √©galement entre diff√©rents noyaux,La probabilit√© d'un d√©lai suppl√©mentaire de manque de ligne de cache est √©galement √©lev√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la figure, il y a deux gorutins qui sont en harmonie l'un avec l'autre, transmettant le message d'avant en arri√®re. G1 obtient le commutateur de contexte M1, qui s'ex√©cute sur Core 1, ce qui permet √† G1 de faire son travail. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, lorsque G1 a fini d'envoyer le message, il doit maintenant attendre une r√©ponse. Cela entra√Ænera la d√©connexion de G1 du contexte M1 et sa mise en veille. D√®s que G2 est averti du message, il passe dans un √©tat sain. Le planificateur Go peut maintenant effectuer un changement de contexte et ex√©cuter G2 sur M1, qui s'ex√©cute toujours sur Core 1. Ensuite, G2 traite le message et renvoie un nouveau message √† G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'√©tape suivante, tout bascule √† nouveau lorsque le message envoy√© par G2 est re√ßu par G1. Maintenant, le contexte G2 passe de l'√©tat d'ex√©cution √† l'√©tat d'attente, et le contexte G1 passe de l'√©tat d'attente √† l'√©tat d'ex√©cution et, enfin, revient √† l'√©tat d'ex√©cution, ce qui lui permet de traiter et de renvoyer un nouveau message. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les choses en surface ne semblent pas √™tre diff√©rentes. Tous les m√™mes changements de contexte et changements d'√©tat se produisent, que vous utilisiez Streams ou Goroutines. Cependant, il existe une grande diff√©rence entre l'utilisation de Streams et de Gorutin, qui peut ne pas √™tre √©vident √† premi√®re vue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si goroutine est utilis√©, les m√™mes threads et noyau du syst√®me d'exploitation sont utilis√©s pour tous les traitements. Cela signifie que du point de vue du syst√®me d'exploitation, OS Flow ne passe jamais dans un √©tat d'attente; jamais. Par cons√©quent, toutes ces instructions que nous avons perdues lors du changement de contexte lors de l'utilisation de flux ne sont pas perdues lors de l'utilisation de goroutin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essentiellement, Go a transform√© le travail d'E / S / blocage en un travail li√© au processeur au niveau du syst√®me d'exploitation. √âtant donn√© que tout changement de contexte se produit au niveau de l'application, nous ne perdons pas les m√™mes ~ 12 000 instructions (en moyenne) sur le changement de contexte que nous avons perdues lors de l'utilisation de flux. Dans Go, les m√™mes changements de contexte vous co√ªtent ~ 200 nanosecondes ou ~ 2.4 mille commandes. Le planificateur permet √©galement d'am√©liorer les performances de mise en cache des cha√Ænes et de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est pourquoi nous n'avons pas besoin de plus de threads que de c≈ìurs virtuels. </font><font style="vertical-align: inherit;">Go peut faire plus de travail au fil du temps, car le planificateur Go essaie d'utiliser moins de threads et d'en faire plus sur chaque thread, ce qui permet de r√©duire la charge sur le syst√®me d'exploitation et le mat√©riel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Go Scheduler est vraiment incroyable dans la fa√ßon dont il prend en compte les subtilit√©s du syst√®me d'exploitation et du mat√©riel. La possibilit√© de transformer le fonctionnement des E / S / verrouillage en une op√©ration li√©e au processeur au niveau du syst√®me d'exploitation nous permet d'obtenir de gros gains en utilisant plus de puissance du processeur au fil du temps. C'est pourquoi vous n'avez pas besoin de plus de threads d'OS que de noyaux virtuels. Vous pouvez raisonnablement vous attendre √† ce que tout votre travail se fasse (avec liaison CPU et E / S / verrous) avec un thread OS par noyau virtuel. Cela est possible pour les applications r√©seau et autres applications qui n'ont pas besoin d'appels syst√®me qui bloquent les threads du syst√®me d'exploitation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que d√©veloppeur, vous devez toujours comprendre ce que fait votre application en termes de type de travail. </font><font style="vertical-align: inherit;">Vous ne pouvez pas cr√©er un nombre illimit√© de goroutines et vous attendre √† des performances incroyables. </font><font style="vertical-align: inherit;">Moins c'est toujours plus, mais avec une compr√©hension de cette s√©mantique du planificateur Go, vous pouvez prendre de meilleures d√©cisions d'ing√©nierie.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489852/index.html">Authentification transparente dans ASP.Net Core sous Linux</a></li>
<li><a href="../fr489854/index.html">Redux vs MobX sans confusion</a></li>
<li><a href="../fr489856/index.html">Banach-Tarski reverse paradox ou comment r√©duire de cinq fois le volume de donn√©es stock√©es</a></li>
<li><a href="../fr489858/index.html">Internationalisation: rendre le Web accessible √† tous</a></li>
<li><a href="../fr489860/index.html">L'histoire de Telefunken: le ph√©nix de l'√©lectronique allemande de Guillaume II et Goebbels aux Beatles et aujourd'hui</a></li>
<li><a href="../fr489868/index.html">Gel de Mozilla WebThings</a></li>
<li><a href="../fr489870/index.html">Intensif hors ligne gratuit par Node.js √† Nizhny Novgorod</a></li>
<li><a href="../fr489872/index.html">Comment le syst√®me DLP et le module OCR ont emp√™ch√© les employ√©s de falsifier les num√©risations de passeport</a></li>
<li><a href="../fr489874/index.html">Compilation crois√©e des ex√©cutables Rust pour Windows √† partir de Linux</a></li>
<li><a href="../fr489876/index.html">Comment nous avons r√©solu le probl√®me de trois monolithes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>