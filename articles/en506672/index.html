<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👞 🧓🏽 🔆 SwiftUI on the shelves: Animation, part 2 👧🏾 👩🏻‍🤝‍👨🏾 👨🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of the animation story in SwiftUI. In the first article, we looked at simple examples for the basics of how animation works in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI on the shelves: Animation, part 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the second part of the animation story in SwiftUI. In the first </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we looked at simple examples for the basics of how animation works in SwiftUI. In this part, we will go further, and we will analyze in detail the announced example with rainbow animation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cut you will find an analysis of the timing of the animation, creating your own timing curve mechanism for working in a looped linear animation, examples of the implementation of different gradients and some interesting techniques that will help to understand the animation under the hood.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let me remind you that I spied the idea to implement such an animation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There, the authors took the path of least resistance, and implemented the most obvious way to implement this concept by animating the shape. The principle is simple: each wave is a contour outlined by a Bezier curve, and the “time” parameter affects the position of the right boundary of this wave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how the finished animation looks: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity, I will spread the waves a little vertically. This is easy to do, I just added at the end of NotchWave moving the entire contour down to the height of the wave, in accordance with the current phase of the animation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well and also .drowingGroup () it is necessary not to forget to disconnect - it does not mean the image goes beyond the borders of the fixed frame. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The approach is simple, it produces the desired result ... but it seemed to me too boring. </font><font style="vertical-align: inherit;">My path turned out to be much longer, and I would not say that the end result would be at least somewhat better, but it would be interesting along the way. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are still not very well aware of the principles of animation work in SwiftUI, I highly recommend reading the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And I want to delve into the source code on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work with gradients</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the very beginning, I chose a different approach. I found it much more useful to deal with the animation of the displacement of objects than with the animation of the forms (I still call the shape structure of the form). Offset can work with anything - various shapes, images, other View. As an educational task, I wanted to implement a smooth color transition from one wave to another. In the original concept, something like that was like that. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In total, SwiftIUI offers three possible uses of the gradient - linear, circular and angular. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In code, this looks like some kind of block constructor. Notice how the whole wave is segmented.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A linear gradient is characterized by a start and end point for the gradient. </font><font style="vertical-align: inherit;">These are not CGPoint points with absolute coordinates (x: y :), but UnitPoint points, i.e. </font><font style="vertical-align: inherit;">relative coordinates, where x: y: are specified in fractions of the width and height of the area selected for this View. </font><font style="vertical-align: inherit;">There are also predefined points corresponding to the corners (.topLeading, .bottomTrailing, etc.) and the midpoints of the sides (.top, .trailing, etc.).</font></font><br>
<br>
<pre><code class="swift hljs"><font></font>
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The linear gradient segment is “rubber”. </font><font style="vertical-align: inherit;">It has a fixed width, but its height is not specified. </font><font style="vertical-align: inherit;">Thus, it will fill the entire amount provided. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A slightly more complicated story with a circular gradient. </font><font style="vertical-align: inherit;">We indicate the point - the center of the circle, the radius of the beginning of the gradient and the radius of the end of the gradient. </font><font style="vertical-align: inherit;">The radii are already in absolute terms, i.e. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">points</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The center of the circle is still set as UnitPoint.</font></font><br>
<br>
<pre><code class="swift hljs"><font></font>
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A piece with a top circle has a fixed height, but stretches horizontally. After all, we set specific fixed radii in points, so there is no need to glue an additional stretching rectangle of the base color, as is the case with a linear gradient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most difficult to apply is an angular gradient. It is given by the start and end angle, as well as the direction. As you can see from the code listing, working with corners is not very convenient. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You have to remember the school course of trigonometry in order to calculate the required angle, if you need to start the angular gradient at one point and finish at another.</font></font><br>
<br>
<pre><code class="swift hljs">       <font></font>
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{<font></font>
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)<font></font>
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero<font></font>
        <span class="hljs-keyword">switch</span> gradientPart{<font></font>
            <span class="hljs-keyword">case</span> start: angle = angleOf.start<font></font>
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle<font></font>
            <span class="hljs-keyword">case</span> end: angle = angleOf.end<font></font>
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){<font></font>
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius<font></font>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)<font></font>
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)<font></font>
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))<font></font>
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)<font></font>
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)<font></font>
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)<font></font>
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{<font></font>
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x<font></font>
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y<font></font>
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{<font></font>
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{<font></font>
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The angular gradient, which is the tail of the wave, is also rubber, but already in width - it occupies half the remaining size. Actually, that's why there is so much trigonometry. I know the position of specific points on the border of the screen where a certain color should be (since I am gluing a circular gradient with an angular one). Moreover, the values ​​of the angles depend not only on the radii of the lower gradient, but also on the width of the block itself with the gradient. For the first time since school, I picked up a pencil and recalled algebra :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All three options use a single description of colors within the gradient. </font><font style="vertical-align: inherit;">This is a simple listing of colors in an array. </font><font style="vertical-align: inherit;">Their distribution will be uniform over a given segment. </font><font style="vertical-align: inherit;">You can refine the distribution using an array of Stop elements. </font><font style="vertical-align: inherit;">In fact, this is the same enumeration of colors, only for each of them the coordinate on a single segment where it will be located is also indicated. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, I created a wave of approximately the same shape as in the original concept. </font><font style="vertical-align: inherit;">However, the transition from one color to another is now not sharp, but smoothed, which should potentially make the animation smoother.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color is not what it seems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one point related to Color. </font><font style="vertical-align: inherit;">To create the effect of a rolling wave, I decided to make the transition between colors not quite linear. </font><font style="vertical-align: inherit;">If you look closely, you will notice that the gradient is sharper at the edge itself, and the farther from the edge, the smoother it flows into the main color. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I achieved this by calculating the intermediate color, and creating a gradient with this distribution:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial color - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
intermediate color - 0.3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
final color - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem arose with calculating the average of two colors. SwiftUI means using the Color object for gradients, and I was seduced. In fact, if you want to work with colors just like with RGB objects, initially use UIColor in your model, because Color does not have direct access to color. You can’t easily convert it back to UIColor either. The only </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(not)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adequate solution that I found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is to get Mirror reflection with an analysis of its string representation. Such a boilerplate, but there are no other options yet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And this is not a mistake, not an omission. </font><font style="vertical-align: inherit;">The point is that the SwiftUI in the Color object does not duplicate the functionality of UIColor. </font><font style="vertical-align: inherit;">If you need work with rgb channels - use it. </font><font style="vertical-align: inherit;">Color in SwiftUI is a View that has some basic color, the specific value of which may vary slightly depending on the location of the stars in the sky - a specific rgb color is determined only at the time of drawing on the screen. </font><font style="vertical-align: inherit;">The documentation says</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI only resolves it to a concrete value just before using it in a given environment.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but what is meant by environment: the color of the wall behind the user’s back, or the iOS design theme is not clear. </font><font style="vertical-align: inherit;">If this doesn't suit you, use UIColor natively.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endless animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation is specified by the .animation () modifier and starts after View is initialized in the modifier </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by changing the </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. </font><font style="vertical-align: inherit;">As a result, the modifier </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subscribes to receive animatableData in the interval from “was” to “became”, consistent with the system timer. </font><font style="vertical-align: inherit;">We talked about this in the last part.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span><font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By running endless animation in this way, you should understand that any subsequent change to animated modifiers will “break” it. </font><font style="vertical-align: inherit;">For example, if after starting, for some reason, you change the value of angle to 0, you get this effect:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why? The answer is in the animation mechanism of the transition from one animation to another. In our example, when the first appearance of the View on the screen, we started an animated transition from 0 to 90. The View actually stores only the final value of 90, and the original value of 0 is not stored anywhere. The animation engine knows the current time position of the animation, and the current value of AnimatableData. At time point 0.5, it will be 45. What happens if at this moment the user changes the value to 0? Answer: the animation of changing the value from 45 to 0 will begin. Everything is still looped. But only visually, the cycle is not closed, but broken.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, there are cases when the animation also "breaks" if your View uses @ObservedObject, or other parameters that cause the View to be rendered again. To solve this problem, the .animation modifier has a .animation (: value :) parameter. Passing the value there, we indicate to the renderer that the animation restart is needed only when this value changes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, let's figure out how to stop the animation if we no longer need it. To do this, you need to provide two things. Obviously, we must tell SwiftUI that the endless animation is no longer needed, replacing it with the usual, final. But this is not enough. The .animation () modifier is an instruction on which timings to use, but the rotation itself is described inside the .rotationEffect () modifier, and it is already subscribed to receive new values ​​of the rotation angle by timer. To stop rotation, we need to change its value as well.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span><font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {<font></font>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{<font></font>
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span><font></font>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span><font></font>
                }<span class="hljs-keyword">else</span>{<font></font>
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As before, changing the value of angle led to the start of a new animation (which looked broken), this change will also be animated, but now with the timings of normal animation. That is why, our square stops rotating not instantly, but as if with a slowdown. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same can be written a little more succinctly, if you suspend all the functionality on one </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable of the on / off type:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span><font></font>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {<font></font>
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Up to this point, everything was relatively easy. But note that all events here are generated inside the View. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is called by the system, and </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, of course, by the user. However, what if you want to encapsulate the entire animation inside one View, passing it on / off only? SwiftUI does not imply the possibility of any parent methods from the parent view. Theoretically, you can store the child View as a structure and call its mutating methods, but </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables of the child View cannot be changed in this way, I tried it - it does not work. The only way to do something like this is to use the Combine's PassthroughSubject, as you did in the article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, everything is much simpler. If clearly laid on the shelves in the head, that</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this is the internal state of the View, and not trying to manipulate it from the outside, the correct solution will be very simple:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{<font></font>
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span><font></font>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span><font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)<font></font>
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {<font></font>
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, we do not need a </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subscription to update the View inside the child view - it is already updated as a whole when the parameter external to it changes. </font><font style="vertical-align: inherit;">Sometimes it’s not convenient. </font><font style="vertical-align: inherit;">Sometimes we would not want to initialize the child view once again - for example, so as not to break the animation, or in init () some complex and resource-intensive calculations (queries, for example) occur. </font><font style="vertical-align: inherit;">In these cases, it is better to use object entities, the changes of which can be monitored using the onReceive modifier.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifying state during view update</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one more thing worthy of coverage. We operated with only two values ​​of 0 and 90 degrees. Turning off the animation resets the angle to 0. But is it possible to pause the animation right at the moment we clicked the button and continue it from the same place again when resuming? Let's look at the code that allows this:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span><font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span><font></font>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span><font></font>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){<font></font>
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted<font></font>
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span><font></font>
        <span class="hljs-type">DispatchQueue</span>.main.async {<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{<font></font>
                <span class="hljs-comment">// print("stop animation")</span><font></font>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)<font></font>
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))<font></font>
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed<font></font>
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span><font></font>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span><font></font>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {<font></font>
             <span class="hljs-comment">//    print("start animation")</span><font></font>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span><font></font>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main idea is to track the time at the start of the animation. After some time, when it is up to us to stop the animation, we will be able to check how many complete animation cycles have passed, and to guess what angle of rotation of the square we are seeing at the moment. After that, we can assign </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactly this value to the rotation angle variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this approach to work, we need to track the start and end of the animation. Init () will not work. We cannot access existing </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters to get the previous start time of the animation. This is a token of </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables. Inside init, you can set only the initial state of this variable, but at the end of initialization, if View already existed before init (), the value of the </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables will be restored.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, here the let externalStarted parameter is implemented (which we control from the outside), and the internal parameter </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var internalStarted, with which we directly control the animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There was only one missing - some modifier that would check their compliance and update if necessary, like .onRecieve (), only to work out with each rendering. </font><font style="vertical-align: inherit;">And then I thought - after all, the body is called for every drawing, so why not do this check directly in it? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turned out that SwiftUI swears very much, if during the rendering process the View changes the value of the </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables, it gives</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifying state during view update, this will cause undefined behavior.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and blocks such a change. Then I went for a dirty hack, and used DispatchQueue.main.async. But let's see why this is a dirty hack, and why should this never be done? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is actually the problem. If we write inside the body some obvious stupidity like i + = 1, where i is some kind of</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable, then we get an infinite loop. At the time of rendering, we make the View in memory not relevant - because we changed the initial data for rendering. This means that immediately after the rendering is complete, our View will be queued for re-rendering, but even then we will immediately make it irrelevant again. We create an endless cycle with our own hands. An asynchronous call in this case does not change anything. It only slightly shifts the initiation of the next round to the moment “immediately after rendering”. Thus, an asynchronous call does not solve the problem, but only disguises it, preventing SwiftUI from poking us with its nose. It’s like in a car the “check engine” light bulb is torn off.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the one hand, what's wrong with that? In any programming language, there are tons of ways to shoot yourself in the foot if you don’t understand what you are doing. But on the other hand, this approach is not at all how SwiftUI should work. Working with View in runtime is bad. Yes, you can beat your heels in the chest, ensuring that you always write the right code that will never end up in an endless loop ... But it’s like with an insecure retrieval of an option — it's just bad practice. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I said, in such cases, you should use Combine, passing a new value using PassthroughSubject. But you can get by with the usual ObservableObject by subscribing to its willChange event.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span><font></font>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span><font></font>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-type">VStack</span>{<font></font>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted<font></font>
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{<font></font>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)<font></font>
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))<font></font>
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed<font></font>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span><font></font>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span><font></font>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {<font></font>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The controversial point here is the use of the values ​​of the object itself in the subscription to the notification that the object will only be changed. </font><font style="vertical-align: inherit;">So far, in my examples, I have an already modified object. </font><font style="vertical-align: inherit;">Apparently, notifications come with some lag. </font><font style="vertical-align: inherit;">But I can’t guarantee that this will always be the case, therefore I advise either to use the self-made didChange notifications, or PassthroughSubject, passing the new value through it.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation Animation Changes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see on the gif, the animation does not stop instantly. </font><font style="vertical-align: inherit;">She needs some time. </font><font style="vertical-align: inherit;">This is because when we assign an intermediate value to the angle, we also use a certain animation - the default one.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This leads to unusual behavior. </font><font style="vertical-align: inherit;">Despite the relative simplicity of everything that I describe, a bunch of nuances of interaction remain under the hood so that the picture always looks smooth, even if the careless programmer did not indicate something. </font><font style="vertical-align: inherit;">Therefore, the default animation is spring. </font><font style="vertical-align: inherit;">It is most suitable for simulating the laws of physics. </font><font style="vertical-align: inherit;">And this is a rather short animation, about 0.2 seconds. </font><font style="vertical-align: inherit;">If the animation of the transition to a new state (the angle calculated and indicated by us) does not have time to beautifully fit into the default 0.2 seconds so as to switch from the current animation speed with a beautiful slowdown to a complete stop, SwiftUI itself will add another loop of endless animation, played in the accelerated version.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To avoid this, it is enough not to use the default animation. </font><font style="vertical-align: inherit;">For the bottom square, I turned off the rotation stop animation like this:</font></font><br>
<br>
<pre><code class="swift hljs">                <font></font>
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Or, you can more accurately calculate the required value of the parameter at the time of stopping, but for this you need to not only approximately assume the current moment of the animation, but know it exactly. </font><font style="vertical-align: inherit;">I will show below how to do this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The movement of several waves in one animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back to the rainbow animation. </font><font style="vertical-align: inherit;">So, we have the waves themselves, let's teach them to move. </font><font style="vertical-align: inherit;">The first thing I would like to do is run an endless animation. </font><font style="vertical-align: inherit;">I decided to do it this way: I will have one </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable responsible for the current position of the animation. </font><font style="vertical-align: inherit;">At state 0, the first wave will be at the very beginning, and the last at the very end. </font><font style="vertical-align: inherit;">The waves themselves will overlap. </font><font style="vertical-align: inherit;">Thus, the length of the visible part of each wave will depend on the number of waves. </font><font style="vertical-align: inherit;">I implemented this using ZStack, which lists all the waves, and my own .wavePosition modifier, inside which I calculate the current position of each wave at the moment of the animation, and the order in which they overlap.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a lot of code</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first time the View is displayed on the screen, we change the state from 0 to 1, which, taking into account the declared linear animation, makes the waves run endlessly around the screen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the edge of the wave reaches the right edge, its next position will be at the very beginning, beyond the edge of the screen. It will look as if it will simply disappear from the end of the wave, exposing the background substrate, which we would like to avoid. For this purpose, the if {...} block appeared in the modifier, in the body () function, in which a copy of the first wave missing from the screen is drawn.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that I had to transfer the geometric characteristics of each wave in the form of modifier parameters. </font><font style="vertical-align: inherit;">The problem was that I needed to redefine the z-index of each wave based on the current animation phase. </font><font style="vertical-align: inherit;">I could extract the width of the visible region by using the GeometryReader {} modifier inside, however, I was faced with the fact that it blocks changing the order of the superposition of waves. </font><font style="vertical-align: inherit;">The .zIndex () modifier works only in the context of the first ZStack {} container up the View hierarchy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader cuts off this connection, and zIndex () stops working. </font><font style="vertical-align: inherit;">If up to this point you thought that GeometryReader is a harmless way to get data about the size of the current View, this is not entirely true.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another important point is understanding the animation of the built-in modifiers inside your own modifiers. At some point, each wave approaches the edge of the screen, getting the maximum horizontal offset, and then goes to the starting position, getting the minimum offset. This is the same change as any other, and it is animated, even inside the animation. After all, animation is just a very frequent transfer of values ​​to the modifier, and it will also be performed with the animation, no matter how strange it sounds. It turns out that inside the animation, passing a new value inside this modifier, we only change the end point of the current motion animation. It turns out that each wave, reaching the edge of the screen, turns around and floats back. But it doesn’t reach the start either, but sooner or later it’s catching up with the required position,and then starts moving from left to right again.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can solve this problem by inserting the .animation (nil) modifier. Thus, I turn off the animation of all modifiers applied above in the text. This is the general logic of the work of any modifier: it changes what is on its input, and on the input we have the result of all previous modifiers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generally speaking, a whole hierarchy of different animations works here. The default is the one that will be used to display changes to all modifiers, unless you specify otherwise for your View. We have a thread of execution (let's say this is main), within which the body is called. We assume that it has the .animation parameter, which is checked every time a modifier receives a new value. If the modifier supports animation (complies with the AnimatableModifier protocol), and animation is enabled for the stream (some specific animation is used, not .none or nil), then the change will be animated. This is what we do, enclosing some code for changing </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters in the withAnimation {} block - we prescribe a certain animation in the current thread, and then we make some kind of change</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. In this case, withAnimation {}, this is a kind of transaction equivalent, and all changes made to this transaction will be animated. As a result, inside the same stream, a cycle of translating these changes to all dependent View starts, the modifiers of these View receive a new value, and subscribe to receive intermediate values ​​of AnimatableData. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, there are elements on the animation of which you cannot influence. For example, the position of the slider is animated by itself, by internal mechanisms, and there is nothing to be done about it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, withAnimation () is a way to start the default animation for the action being performed. But for certain Views, you can explicitly specify your own animation using the .animation () modifier. In this case, the modifiers and forms that make up the content passed to .animation () (everything that is listed in the code before applying .animation ()) receive the timing you describe and ignore the stream animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In my WavePosition modifier, I use .animation (nil) to get rid of the built-in offset animation, thus instructing me to ignore the current stream animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same story with the end cap. Let me remind you of the conclusions from the last article. In fact, we have N WavePosition modifier structures in our memory, one for each wave. And they all get a new position value from the system timer, calculating the position of each wave at a given point in time. This means that we also have N end caps for each wave. It's just that only one of them is shown at any given time, thanks to the if {} block. However, the same block lays us a pig. The disappearance and appearance of the View is also performed with the animation of the stream. This means that the .transition modifier is used to animate the appearance and disappearance of the View after changing the condition. Usually, .opacity is used by default, however for some reason .slide was used instead for me. Neither one suits me, so I just canceled this animation,using .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd. </font><font style="vertical-align: inherit;">While I was preparing the article, Xcode 11.4 came out, in which, it seems, the transition was reworked by default. </font><font style="vertical-align: inherit;">At least now I commented out .transition (.identity) without any problems and did not receive the problem that caused me to add it.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation timings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we finally come to the most interesting question: how to make the waves move accelerated? </font><font style="vertical-align: inherit;">As usual, I’ll come from far away.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actually, Animation is a description of the speed of a given animation. We can determine the route from point A to point B inside the modifier itself, but SwiftUI decides when and what kind of AnimatableData value to pass to it. He does this with a timing curve. Suppose we take point A as the origin, and mark point B as a point with coordinates (1; 1). Horizontal we will mark the elapsed time (the movement from point A to point B takes exactly 1 unit of time). Vertical - the distance traveled in fractions of a unit. When using linear animation, we get direct. If we want to get the movement a little bit similar to the present, then first we need to spend a little time on acceleration, and in the end on braking. Right </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can play around with different options by drawing your own curve and comparing its motion animation with the standard ones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In SwiftUI, Bezier curves are used for various types of animation. </font><font style="vertical-align: inherit;">In any case, it should begin at (0; 0) and end at (1; 1). </font><font style="vertical-align: inherit;">The curvature of the line is determined by the control points.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nested timing curve inside linear endless animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, what do we need to do to achieve the accelerated movement of each wave (easeIn) inside a linear looped animation? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most broken-down option that I could come up with was to implement my own timing curve, and convert the linear flow of time with it to a kind of .easeIn. </font><font style="vertical-align: inherit;">With this example, you can very well understand how this works.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea is simple. We will make our own class, based on path - the Bezier curve with which we will determine the distance from point A to point B, which needs to be shown at each specific point in time. In fact, this is exactly how animation works in SwiftUI, and in any other framework with similar functionality. Using a timing curve, real seconds and milliseconds (which most often flow, nevertheless, linearly) are converted into fractions of the distance (more precisely, fractions of the animated segment - the AnimatableData vector, which represents the change made). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is my first implementation:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration<font></font>
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath<font></font>
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{<font></font>
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)<font></font>
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span><font></font>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}<font></font>
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}<font></font>
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparently, I was a little foolish. By definition, I have to find a point on the curve corresponding to the given value of X and return it to Y. I could not find any standard built-in method for solving this problem, or a popular pattern, so I decided to adapt the existing trim method for these purposes ( ) I decided that I could very well reconsider the approach, and get the desired point by getting the part of the path corresponding to the fraction of the distance traveled. For zero, this method will return 0, for 1 it will return 1, well, in the middle, probably, everything will also be approximately correct.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I was aware that such an approach would not give a very accurate result, however, the severity of the problem surfaced later when I tried to reproduce exactly the same animation in a standard way. I was surprised how different it is, and decided to check on the graph how far the points obtained in this way will be from the original curve. The result did not please me. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not only are the points far from the desired curve, the very nature of the curve is distorted. There is an extra kink, which I do not need at all. As a result, I still had to come up with a relatively accurate way to find a point on a Bezier curve, knowing only one coordinate:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I had to store in memory a lot of segments, the ends of which lie on a given curve. A search for Y by a given X with this approach is a search for the corresponding segment, its division in half, if necessary, until one of the boundaries of such a segment lies sufficiently close to the desired point. In this case, we find the point with the required X coordinate lying on this segment and return it Y. If you know simpler ways of finding a point lying on an arbitrary Bezier curve, using one given coordinate, write in the comments. I think it can be useful to many. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the points are pretty close to the chart:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I made a singlton object to create a timing curve for control points and cache the array of segments with which Y is searched. Thus, all I need to find a specific point on the curve is to find the segment inside which this point will lie, divide it into halves until one of the ends of the segment is close enough to this point to fall into a given error, and then linearly interpolate the value of Y over the given X, replacing part of the curve by this segment. I do not claim that this is the best way, and that it will work in all cases. Again, write in the comments if you know better ways.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the help of such a tool, the transformation of linear animation into non-linear becomes simple. </font><font style="vertical-align: inherit;">All that is needed is to describe the curve by two control points, and recalculate the position on the segment according to this curve. </font><font style="vertical-align: inherit;">If animation of various durations is required, we still use a unit curve using the appropriate coefficient for the X-coordinate.</font></font><br>
<br>
<pre><code class="swift hljs">        <font></font>
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)<font></font>
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how the animation looks like, along with our timing curve: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the full code, welcome to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , watch the TimingCurveView file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having understood this example, you will 100% understand how animation timings are arranged. </font><font style="vertical-align: inherit;">By the way, you can use this knowledge, because SwiftUI allows you to create your own timing curve for control points using the timingCurve () function, and use it like any other animation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, we have a tolerable endless animation. It remains only to figure out how it should turn on and off. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea of ​​animating the appearance is to make the animation block just appear on the place already turned on, but the curtain would be pulled back from it, like a curtain in the theater. If we synchronize the speed of the curtain with the speed of the waves inside the animation, and in the curtain itself make a gradient from the background color to the color of the current incident wave, we get a visual effect, as if this curtain is the first rolling wave. To synchronize the speed of movement, we simply use the same timingCurve as for animating the movement of the wave. Fortunately, we now know how to do this.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),<font></font>
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),<font></font>
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),<font></font>
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve (x: y :) allows you to set your own animation timing based on the control points of Bezier curves. </font><font style="vertical-align: inherit;">At the output we get a full-fledged Animation object, such as the familiar .linear (duration: 1), which can be used without restrictions. </font><font style="vertical-align: inherit;">And considering that I use exactly the same control points for wave animation, the animation will be synchronous.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it would be more convenient to organize the code ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          …     ,     ,     .  -  ,        —    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disabling the animation can be done in the same way, only the curtain should creep onto the animation block, gradually closing it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first problem arose at the moment when I needed to get the current state of the animation in order to choose the color of the curtain. </font><font style="vertical-align: inherit;">To do this, I created an ObservableObject, which I pass inside the modifier, and which I change inside the AnimatableData setter. </font><font style="vertical-align: inherit;">It is important to understand here that changing @Published property 60 times per second is not at all what you need. </font><font style="vertical-align: inherit;">This is how to change </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables inside a body block. </font><font style="vertical-align: inherit;">We do not need to initiate anything when the state of the animation changes. </font><font style="vertical-align: inherit;">But if we need to, we can find out the state of the animation at any time.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {<font></font>
        <span class="hljs-keyword">get</span> { time}<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            <span class="hljs-keyword">if</span> animationHandler.isStarted{<font></font>
                <span class="hljs-keyword">self</span>.time = newValue<font></font>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{<font></font>
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))<font></font>
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is why I did not sign up SharpRainbowView to track AnimationHendler changes: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span><font></font>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span><font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To illustrate the operation of these curtains, I will turn on the display of what is happening outside the View by commenting out .clipped (). In addition, I will move the curtain slightly above the animation, for clarity. Now it’s clearer, isn't it? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The curtains had to be short so that the path traveled by each wave and curtain coincided (otherwise it would turn out an asynchronous animation), but at the same time, she managed to completely disappear from the screen. At the same time, the curtain is arranged as a gradient of three colors. This is clearly visible on the closing curtain. This is because of the long tails that I liked so much in the beginning.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The thing is that the first wave is the gradient of the last and first colors of the transmitted array. None of them may match the background color. Therefore, there was a need for curtains in general. To make the curtain two-tone, from the background color to the base color of the first wave, the length of the curtain prevented me. It simply does not overlap the long tail of the first wave, and a border of one color is obtained, and the tail of another. Therefore, I had to make the curtain as much as three-color - first from the background to the color of the last wave, and then from the color of the last wave to the first. Then the tail of the first wave fits well with the border of the curtain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For about the same reasons, they made the closing curtain also tricolor. Otherwise, the border looked unnatural. But as a result, the first “wave” (and now we know that this is actually the curtain described in Transition.truncate) turned out to be short. And although it moves completely synchronously with the first wave, i.e. accelerated, and not linear, its width does not change with time, although the width of subsequent waves visually increases. This can be defeated by dynamically changing the width of the curtain, but I was frankly lazy. Let's consider this as homework for those who want to dive into these mechanisms and smoke a code (I apologize to such people in advance, there are a lot of traces of my experiments that can confuse you).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one problem. </font><font style="vertical-align: inherit;">If you press the button at an unsuccessful time, the closing curtain will barely cover the next wave. </font><font style="vertical-align: inherit;">It doesn’t look very good. </font><font style="vertical-align: inherit;">You can solve the problem by introducing a slight delay in hiding the View with animation. </font><font style="vertical-align: inherit;">We have a way to find out the current position of the animation, we just need to postpone the beginning of the transition a little, and the last wave will always be fully shown.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span><font></font>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{<font></font>
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)<font></font>
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)<font></font>
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)<font></font>
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {<font></font>
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, you can also make the curtain of variable width to create the illusion of different speeds of the border between the background and the curtain, and the curtain and the first wave, but now the first wave looks a little unnatural, but I'm already too lazy to bother.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition loves lining a pig</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, animations of appearance and disappearance, as for me, are a very cool tool. But it seems that this concept is new, and not all tools normally handle it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the .rotation3DEffect () modifier quite successfully reverses the View with some complex animations inside, but .transition it does not know how to invert. It was so disappointing to write a concise code, see how your waves scatter away from the center of the screen, and then see that on the left View the curtains run from left to right. I had to write a bunch of boilerplate so that the transition modifier could work in both directions.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, the drowingGroup () modifier, with which you can connect Metal to transfer to the GPU a ZStack rendering with a large number of nested View, especially View with gradients, does not know how to transition. </font><font style="vertical-align: inherit;">He does not understand the animation of appearance and disappearance described by you and replaces it with some of his own.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But how do we hide the status bar?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Very simple. SwiftUI has the .statisBar (hidden :) modifier. Here are just the api for controlling the transition for the status bar SwiftUI does not provide. To do this, we will have to take advantage of the capabilities of UIKit. The SceneDelegate file uses the UIHostingController to turn the SwiftUI View into a UIKit ViewController. It is at this stage that it is most convenient to use some global UIKit functions, such as working with the status bar, or disabling system gestures associated with the edge of the screen (preferredScreenEdgesDeferringSystemGestures). You can inherit from UIHostingController by overriding the values ​​of some system properties, and use this descendant to pass your View to rootViewController. Unfortunately, only a limited number of transitions can accept a statusbar: .fade, .slide, and .none. The default is fade,and it fits here best, so let’s leave it as it is. Let's hope that this functionality will still be expanded.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to synchronize the hiding and the appearance of the status bar with the movement of the wave, I created a separate View, inside of which I pause changing the value of this parameter:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{<font></font>
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span><font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span><font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{<font></font>
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{<font></font>
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){<font></font>
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{<font></font>
            <span class="hljs-type">DispatchQueue</span>.main.async(){<font></font>
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, a simple Spacer () is formed here, which I already needed, but the statusBar modifier is wound on top of it. In general, of course, it was illogical for Apple to output this functionality to modifiers, as this does not apply to the specific View that you are modifying, but apparently just did not figure out how to do it better. Much more interesting is another. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It uses the same dirty hack that we considered earlier: inside the body, I perform some actions in runtime, while changing the value of the </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. The logic as a whole is the same, there is a structure parameter that is transmitted from outside, and a </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable that is modified after some time, causing the status bar to disappear or appear.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, I needed this hack because controlling the status bar animation is a UIKit functionality that is still pretty poorly developed in SwiftUI. </font><font style="vertical-align: inherit;">In theory, I would screw the delayed start animation to the .statusBar (hidden :) modifier, but this does not work. </font><font style="vertical-align: inherit;">The animation of hiding and the appearance of the status bar is fixed, and cannot be changed by SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, nothing prevented me from making the same change asynchronously with the desired delay, not inside this View, but in the parent, even when the user clicked the button - but let us leave this as a monument to my attempts to figure out what's what (and another reason to tell that this should not be done).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And how was the size and position of the status bar stuffed into @Environment?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment (not to be confused with @EnvironmentObject) is a wrapper that gives access to a fixed list of variables that reflect the environment of our application. For example, screen orientation, or OS color theme. The same wrapper allows your view to be subscribed to change these parameters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This list can be expanded. I figured that having @Environment had access to the size and position of the status bar would be right. Here is how I did it:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {<font></font>
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{<font></font>
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{<font></font>
        <span class="hljs-keyword">get</span> {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I created a structure with a static default value. </font><font style="vertical-align: inherit;">Then, I expanded the SystemValues ​​system structure by adding my own computed property, the getter and setter of which refer to the type I created. </font><font style="vertical-align: inherit;">The type is used here, because EnvironmentValues ​​implements a subscript into which you pass the type and get the stored value corresponding to this type. </font><font style="vertical-align: inherit;">Not the value of this type, but the value stored in the conditional dictionary, where the type itself is the key. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The value in @Environment is accessed using keyPath \ .statusBarFrame. </font><font style="vertical-align: inherit;">For example, to pass the environment value to all view down the hierarchy:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in the View itself to retrieve the value from the store:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, for working with the status bar in the UIWindowScene object in IOS 13, the statusBarManager attribute has appeared. </font><font style="vertical-align: inherit;">Some parameters can be drawn from it. </font><font style="vertical-align: inherit;">But now you can’t manage them. </font><font style="vertical-align: inherit;">As I understand it, earlier it was possible to access the ViewController status bar and add a subView to it. </font><font style="vertical-align: inherit;">Apparently, they closed the bench. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generally speaking, I would transfer the functionality of the .statusBar (hidden :) modifier exactly here, here it would be more appropriate, as for me. </font><font style="vertical-align: inherit;">I think sooner or later, the developers will get to this point.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, I think on this fascinating example, an excursion into Animation using SwiftUI tools can be considered complete. Using simple examples, I talked about the main animation tools, told how exactly they work under the hood, how they should be used and why exactly. Using more complex examples, I showed typical difficulties that you may encounter and ways to overcome them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Did my code, in comparison with the example from the above article, be cleaner, clearer, shorter, or maybe it is easier to maintain? Perhaps not. Does it consume less resources? Alas, no. Perhaps my approach is more universal, but this is not accurate. However, there is one task that he definitely performs better. It illustrates much deeper the operation of SwiftUI under the hood. With it, you can put the animation on the shelves in your head and freely apply it in your applications.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI is actively sawn. </font><font style="vertical-align: inherit;">Even now, two weeks after writing the code for the first article, now, checking the code on the current version of Xcode, I see how some bugs that I had to circumvent were already fixed. </font><font style="vertical-align: inherit;">Therefore, I stayed a bit with the article. </font><font style="vertical-align: inherit;">Something had to be cut for irrelevance, and everything else - to double-check. </font><font style="vertical-align: inherit;">And it pleases. </font><font style="vertical-align: inherit;">SwiftUI is definitely the future of native iOS development, and it is very informative to stand at its origins and observe how it develops.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afterword</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the process of preparing the materials for this article, I also put a lot of things into my head in my head. </font><font style="vertical-align: inherit;">I found out a lot of nuances that I had no idea about when I just started writing it. </font><font style="vertical-align: inherit;">Therefore, I urge everyone who already has experience in SwiftUI development - do not be shy, share your experience and knowledge. </font><font style="vertical-align: inherit;">This is very useful both for the community and for completeness of your own knowledge. </font><font style="vertical-align: inherit;">This is cooler than </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the duckling method</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and there is also a need to formulate the answer. </font><font style="vertical-align: inherit;">The main thing is not to be lazy to look for such an answer so that it is not embarrassing for the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boys to show</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en506648/index.html">Laravel Digest (June 8-14, 2020)</a></li>
<li><a href="../en506658/index.html">GitLab 13.0 released with Gitaly clusters, epic hierarchy on roadmaps and automatic deployment for ECS</a></li>
<li><a href="../en506662/index.html">Adaptive partition of 2nd and 3rd order Bezier curves</a></li>
<li><a href="../en506664/index.html">The digest of fresh materials from the world of the front-end for the last week No. 419 (June 8-14, 2020)</a></li>
<li><a href="../en506666/index.html">ORM textures, but is it worth it?</a></li>
<li><a href="../en506676/index.html">Qatar: world center for transplants and night city</a></li>
<li><a href="../en506680/index.html">.NET Core vs Node.js. Arguments and Facts</a></li>
<li><a href="../en506684/index.html">How I transferred dedic.ru to github pages and was satisfied</a></li>
<li><a href="../en506686/index.html">Digital events in Moscow from June 15 to 21</a></li>
<li><a href="../en506688/index.html">Digital events in St. Petersburg from June 15 to 21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>