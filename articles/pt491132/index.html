<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚾 👵 🤦🏾 Quando o filtro bloom não se encaixa 👈🏿 🧖🏽 🚼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu sabia da universidade sobre o filtro Bloom , uma estrutura probabilística de dados com o nome de Burton Bloom. Mas não tive a oportunidade de usá-l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Quando o filtro bloom não se encaixa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu sabia da universidade sobre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o filtro Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , uma estrutura probabilística de dados com o nome de Burton Bloom. Mas não tive a oportunidade de usá-lo. No mês passado, essa oportunidade apareceu - e essa estrutura literalmente me fascinou. No entanto, logo encontrei algumas falhas nela. Este artigo é uma história sobre meu breve caso de amor com o filtro Bloom.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No processo de pesquisa de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsificação de IP,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> foi necessário verificar os endereços IP nos pacotes recebidos, comparando-os com a localização geográfica de nossos data centers. Por exemplo, pacotes da Itália não devem ir ao data center brasileiro. Esse problema pode parecer simples, mas no cenário em constante mudança da Internet está longe de ser simples. Basta dizer que, no final, acumulei muitos arquivos de texto grandes com aproximadamente o seguinte conteúdo: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que uma solicitação do endereço IP resolvido 192.0.2.1 foi registrada no datacenter número 107 do Cloudflare. Esses dados vieram de várias fontes, incluindo nossas amostras ativas e passivas, os logs de alguns domínios que possuímos (por exemplo,</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), fontes abertas (por exemplo, tabelas BGP) etc. A mesma linha geralmente é repetida em vários arquivos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, recebi um conjunto de dados gigantesco desse tipo. </font><font style="vertical-align: inherit;">Em algum momento, em todas as fontes coletadas, contei 1 bilhão de linhas. </font><font style="vertical-align: inherit;">Normalmente, escrevo scripts bash para pré-processar dados de entrada, mas nessa escala essa abordagem não funcionou. </font><font style="vertical-align: inherit;">Por exemplo, a remoção de duplicatas a partir deste minúsculo arquivo de 600 MiB e 40 milhões de linhas leva ... a eternidade: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
basta dizer que as linhas de duplicação com comandos comuns do tipo </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em várias configurações (ver </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) não era o melhor para tal um grande conjunto de dados.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtros Bloom</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustração de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em domínio público</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Então me dei conta: não ordene as linhas! Você precisa remover duplicatas, para que algum tipo de estrutura de dados 'definida' funcione muito mais rápido. Além disso, eu sei aproximadamente o tamanho do arquivo de entrada (o número de linhas únicas) e a perda de alguns dados não é crítica, ou seja, a estrutura probabilística dos dados é bastante adequada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é perfeito para filtros Bloom!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto você lê a</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia sobre filtros Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, é assim que eu olho para essa estrutura de dados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você implementaria</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a pluralidade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Dada uma função de hash ideal e memória infinita, podemos simplesmente criar um bitmap infinito e definir um número de bit para cada elemento</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso fornece a estrutura de dados ideal para a "multidão". </font><font style="vertical-align: inherit;">Direita? </font><font style="vertical-align: inherit;">Trivialmente. </font><font style="vertical-align: inherit;">Infelizmente, as funções de hash colidem, e a memória infinita não existe; portanto, em nossa realidade, precisamos comprometer. </font><font style="vertical-align: inherit;">Mas podemos calcular a probabilidade de colisões e gerenciar esse valor. </font><font style="vertical-align: inherit;">Por exemplo, temos uma boa função de hash e 128 GB de memória. </font><font style="vertical-align: inherit;">Podemos calcular que a probabilidade de colisão para cada novo elemento é de 1 a 1099511627776. Quando você adiciona mais elementos, a probabilidade aumenta à medida que o bitmap é preenchido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, podemos aplicar mais de uma função de hash e obter um bitmap mais denso. </font><font style="vertical-align: inherit;">É aqui que o filtro Bloom funciona bem, que é um conjunto de dados matemáticos com quatro variáveis:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - número de elementos inseridos (número cardinal)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - memória usada pelo bitmap</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - o número de funções hash calculadas para cada entrada</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - probabilidade de coincidência falso positiva</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado o número cardinal </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a probabilidade desejada de um falso positivo </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o filtro Bloom retorna a memória necessária </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o número necessário de funções de hash </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Confira esta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente visualização de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">de</font></a><font style="vertical-align: inherit;"> como os parâmetros se afetam.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guiado pela intuição, adicionei a ferramenta probabilística mmuniq-bloom ao meu arsenal, que recebe a entrada STDIN e retorna apenas linhas exclusivas no STDOUT. </font><font style="vertical-align: inherit;">Deve ser muito mais rápido que uma combinação de </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ali está ele:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar e agilizar, defini inicialmente alguns parâmetros. Primeiro, a menos que seja indicado de outra forma, o mmuniq-bloom usa oito funções de hash k = 8. Parece estar perto do número ideal para o tamanho dos nossos dados, e a função hash pode produzir rapidamente oito hashes decentes. Em seguida, alinhamos a memória </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no bitmap à potência de dois para evitar uma operação cara </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que no assembler diminui a velocidade </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se o array for igual à potência de dois, podemos simplesmente usar AND bit a bit (por diversão, leia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como os compiladores otimizam algumas operações de divisão multiplicando por uma constante mágica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos executá-lo no mesmo arquivo de dados que usamos anteriormente:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, isso é muito melhor! 12 segundos em vez de dois minutos. O programa usa uma estrutura de dados otimizada, uma quantidade relativamente limitada de memória, análise de linha otimizada e bom buffer de saída ... e com tudo isso, 12 segundos parecem uma eternidade em comparação com a ferramenta </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que está acontecendo? Entendo que contar seqüências de caracteres é </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais fácil do que calcular seqüências únicas, mas a diferença de 26 horas é realmente justificada? O que a CPU absorve </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deve ser para hashes de computação. O utilitário </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não gasta o processador, fazendo toda essa matemática estranha para cada uma das 40 milhões de linhas. Eu uso uma função hash não trivial </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, com certeza queima o processador, certo? Vamos verificar executando apenas a função hash, mas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não executando operações com o filtro Bloom: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é estranho. </font><font style="vertical-align: inherit;">O cálculo da função hash leva apenas cerca de dois segundos, embora todo o programa na execução anterior tenha sido executado por 12 segundos. </font><font style="vertical-align: inherit;">Um filtro Bloom funciona por 10 segundos? </font><font style="vertical-align: inherit;">Como isso é possível? </font><font style="vertical-align: inherit;">Essa é uma estrutura de dados tão simples ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arma Secreta - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É hora de aplicar a ferramenta certa para esta tarefa - vamos executar o criador de perfil e ver no que o processador está trabalhando. Primeiro, vamos correr </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para verificar se não há chamadas inesperadas do sistema: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tudo parece bom. Dez chamadas para </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms cada (3971 μs) são intrigantes, mas tudo bem. Nós preenchemos a memória com </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para evitar erros posteriormente devido à falta de uma página. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual é o próximo passo? Claro que sim </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então vamos ver o resultado: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, nós realmente queimamos 87,2% dos ciclos no código principal. Vamos ver exatamente onde. A equipe </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imediatamente mostra algo inesperado. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que 26,90% do processador queimaram em</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Mas isso não é tudo! O compilador insere corretamente a função e expande o loop. Acontece que a maioria dos ciclos vai para isso </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou para a linha </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, perf está errado, como uma string tão simples pode ocupar tantos recursos? Mas repetir o teste com qualquer outro gerador de perfil mostra o mesmo problema. Por exemplo, eu gosto de usar o google-perftools com o kcachegrind devido aos diagramas coloridos: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado da visualização é o seguinte: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me resumir o que descobrimos até agora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O utilitário padrão </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processa um arquivo 600 MiB por 0,45 s. Nossa ferramenta otimizada </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dura 12 segundos. O processador é gravado em uma instrução </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, desreferenciando a memória ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagem de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! Como eu poderia esquecer. O acesso aleatório à memória é</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lento! Muito, muito, muito devagar!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com os</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">números que todo programador deve saber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um único acesso à RAM leva cerca de 100 ns. Vamos contar: 40 milhões de linhas, 8 hashes cada. Como nosso filtro Bloom tem um tamanho de 128 MiB, em</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nosso hardware antigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele não se encaixa no cache L3! Os hashes são distribuídos uniformemente por uma ampla faixa de memória - cada um deles gera uma falha de cache. Coloque tudo junto, e acontece ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece que 32 segundos queimam apenas em acessos à memória. O programa real cabe em apenas 12 segundos, já que o filtro Bloom ainda se beneficia do cache. É fácil ver com isso </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, deveríamos ter tido pelo menos 320 milhões de erros de cache (LLC-load-misses), mas apenas 280 milhões ocorreram: isso ainda não explica por que o programa funcionou em apenas 12 segundos. Mas não importa. É importante que o número de falhas de cache seja um problema real, e só podemos resolvê-lo reduzindo o número de acessos à memória. Vamos tentar configurar o filtro Bloom para usar apenas uma função de hash: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! Isso realmente dói! Para obter uma probabilidade de colisão de 1 por 10.000 linhas, o filtro Bloom exigia 64 gigabytes de memória. É horrível!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, não parece que a velocidade tenha aumentado significativamente. </font><font style="vertical-align: inherit;">O sistema operacional levou 22 segundos para preparar a memória para nós, mas ainda gastamos 11 segundos no espaço do usuário. </font><font style="vertical-align: inherit;">Acredito que agora todas as vantagens de um acesso mais raro à memória são compensadas por uma menor probabilidade de entrar no cache devido a um tamanho de memória bastante aumentado. </font><font style="vertical-align: inherit;">Antes, 128 MiB eram suficientes para o filtro Bloom!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recusando filtros Bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso está ficando ridículo. </font><font style="vertical-align: inherit;">Para reduzir a probabilidade de falsos positivos, você deve usar muitos hashes no filtro Bloom (por exemplo, oito) com muitos acessos de memória ou deixar uma função de hash, mas use grandes quantidades de memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, não temos um limite de memória, queremos minimizar o número de chamadas para ele. </font><font style="vertical-align: inherit;">Precisamos de uma estrutura de dados que custe no máximo uma falta de cache por elemento e use menos de 64 gigabytes de RAM ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É claro que você pode implementar estruturas de dados complexas, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um filtro de cuco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas certamente existe uma opção mais fácil. </font><font style="vertical-align: inherit;">E a boa e antiga tabela de hash de sondagem linear? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustração de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conheça mmuniq-hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a nova versão do mmuniq-bloom usando uma tabela de hash:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez dos bits do filtro Bloom, agora armazenamos hashes de 64 bits da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">função 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Isso fornece uma proteção muito melhor contra colisões de hash: muito melhor que uma por 10.000 linhas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos contar. </font><font style="vertical-align: inherit;">Adicionar um novo item a uma tabela de hash, digamos, com 40 milhões de entradas, dá a chance de colisões de hash </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso é cerca de 1 em 461 bilhões - uma probabilidade bastante baixa. </font><font style="vertical-align: inherit;">Mas não adicionamos um elemento ao conjunto pré-preenchido! </font><font style="vertical-align: inherit;">Em vez disso, adicionamos 40 milhões de linhas ao conjunto inicialmente vazio. </font><font style="vertical-align: inherit;">De acordo com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o paradoxo do aniversário</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , isso aumenta muito a probabilidade de colisões. </font><font style="vertical-align: inherit;">Uma aproximação razoável seria uma estimativa </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no nosso caso, é</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Acontece uma chance em 23.000. Em outras palavras, com uma boa função de hash, esperamos uma colisão em um dos 23.000 conjuntos aleatórios de 40 milhões de elementos. Essa é uma probabilidade diferente de zero, mas ainda melhor do que no filtro Bloom, e é completamente tolerável para o nosso caso de uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código com uma tabela de hash funciona mais rápido, possui melhores padrões de acesso à memória e menor probabilidade de falsos positivos do que no filtro Bloom.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não se assuste com a linha de “conflitos de hash”, ela mostra o quão cheia a tabela de hash está. </font><font style="vertical-align: inherit;">Usamos o sensor linear, portanto, quando entramos no conjunto completo, pegamos o próximo vazio. </font><font style="vertical-align: inherit;">No nosso caso, temos que pular uma média de 0,7 conjuntos para encontrar um ponto vazio na tabela. </font><font style="vertical-align: inherit;">Isto é normal. </font><font style="vertical-align: inherit;">Como iteramos os conjuntos em uma ordem linear, a memória deve estar qualitativamente cheia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo anterior, sabemos que nossa função hash leva cerca de dois segundos. </font><font style="vertical-align: inherit;">Concluímos que 40 milhões de acessos à memória levam cerca de quatro segundos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lições aprendidas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os processadores modernos são realmente bons no acesso seqüencial à memória quando é possível prever padrões de amostragem (consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pré-busca em cache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). O acesso aleatório à memória, por outro lado, é muito caro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estruturas de dados avançadas são muito interessantes, mas tenha cuidado. Computadores modernos exigem o uso de algoritmos otimizados para cache. Ao trabalhar com grandes conjuntos de dados que não cabem no L3, é preferível a otimização sobre o número de ocorrências, em vez da otimização sobre a quantidade de memória usada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É justo dizer que os filtros Bloom têm um ótimo desempenho quando colocados no cache L3. Mas se não, então eles são terríveis. Isso não é novidade: os filtros Bloom são otimizados para a quantidade de memória, não o número de chamadas. Por exemplo, veja</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo científico sobre filtros de cuco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra coisa são discussões intermináveis ​​sobre funções de hash. Honestamente, na maioria dos casos isso não importa. O custo de contar até funções complexas de hash parece ser </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pequeno comparado ao custo do acesso aleatório à memória. No nosso caso, simplificar a função hash trará apenas um pequeno benefício. O tempo de CPU é desperdiçado em outro lugar - aguardando memória! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um colega costuma dizer: “Pode-se supor que os processadores modernos sejam infinitamente rápidos. Eles trabalham em velocidade infinita, até </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descansarem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contra a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">parede da memória</font></a><font style="vertical-align: inherit;"> ". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, não repita meu erro. Você sempre precisa primeiro criar perfis com</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e veja o contador do IPC (instruções por ciclo). </font><font style="vertical-align: inherit;">Se for menor que um, isso geralmente significa que o programa está parado aguardando memória. </font><font style="vertical-align: inherit;">Os valores ótimos estão acima de dois. </font><font style="vertical-align: inherit;">Isso significa que a carga de trabalho está principalmente na CPU. </font><font style="vertical-align: inherit;">Infelizmente, em minhas tarefas, o IPC ainda é baixo ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mmuniq superior</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a ajuda de colegas, escrevi uma versão aprimorada da ferramenta mmuniq com base em uma tabela de hash. </font><font style="vertical-align: inherit;">Aqui está o código:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele pode alterar dinamicamente o tamanho da tabela de hash, suporta entrada com um número cardinal arbitrário. </font><font style="vertical-align: inherit;">Em seguida, processa os dados em pacotes, efetivamente usando a dica </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na CPU, que acelera o programa em 35-40%. </font><font style="vertical-align: inherit;">Tenha cuidado, o uso abundante </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no código raramente produz efeito. </font><font style="vertical-align: inherit;">Para usar essa função, reordenei especialmente os algoritmos. </font><font style="vertical-align: inherit;">Com todas as melhorias, o tempo de execução foi reduzido para 2,1 segundos:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o fim</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A criação de uma ferramenta básica que tenta superar a combinação 'sort / uniq' revelou alguns recursos ocultos da computação moderna. </font><font style="vertical-align: inherit;">Depois de suar um pouco, aceleramos o programa de mais de dois minutos para dois segundos. </font><font style="vertical-align: inherit;">Durante o desenvolvimento, aprendemos sobre o atraso no acesso aleatório à memória, bem como sobre o poder das estruturas de dados amigáveis ​​ao cache. </font><font style="vertical-align: inherit;">Estruturas de dados bizarras atraem a atenção, mas na prática geralmente é mais eficiente reduzir o número de acessos aleatórios à memória.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491116/index.html">Padrões de identificação modernos: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../pt491118/index.html">Coração do desenvolvedor: Devkits da 5ª geração de consoles (Parte 1)</a></li>
<li><a href="../pt491120/index.html">$ mol: 4 anos depois</a></li>
<li><a href="../pt491122/index.html">Análise forense de backups do HiSuite</a></li>
<li><a href="../pt491130/index.html">Recursos do Vue para lembrar</a></li>
<li><a href="../pt491134/index.html">5 estágios de inevitabilidade da adoção da certificação ISO / IEC 27001. Negação</a></li>
<li><a href="../pt491136/index.html">Projetando conteúdo na documentação angular ou perdida de conteúdo ng</a></li>
<li><a href="../pt491138/index.html">Integração via satélite e torre Ansible</a></li>
<li><a href="../pt491146/index.html">UML para desenvolvedores</a></li>
<li><a href="../pt491150/index.html">Como eu invadi os golpistas ou apenas o interior dos painéis de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>