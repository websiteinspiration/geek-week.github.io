<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöæ üëµ ü§¶üèæ Quando o filtro bloom n√£o se encaixa üëàüèø üßñüèΩ üöº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu sabia da universidade sobre o filtro Bloom , uma estrutura probabil√≠stica de dados com o nome de Burton Bloom. Mas n√£o tive a oportunidade de us√°-l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Quando o filtro bloom n√£o se encaixa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu sabia da universidade sobre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o filtro Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , uma estrutura probabil√≠stica de dados com o nome de Burton Bloom. Mas n√£o tive a oportunidade de us√°-lo. No m√™s passado, essa oportunidade apareceu - e essa estrutura literalmente me fascinou. No entanto, logo encontrei algumas falhas nela. Este artigo √© uma hist√≥ria sobre meu breve caso de amor com o filtro Bloom.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No processo de pesquisa de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsifica√ß√£o de IP,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> foi necess√°rio verificar os endere√ßos IP nos pacotes recebidos, comparando-os com a localiza√ß√£o geogr√°fica de nossos data centers. Por exemplo, pacotes da It√°lia n√£o devem ir ao data center brasileiro. Esse problema pode parecer simples, mas no cen√°rio em constante mudan√ßa da Internet est√° longe de ser simples. Basta dizer que, no final, acumulei muitos arquivos de texto grandes com aproximadamente o seguinte conte√∫do: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que uma solicita√ß√£o do endere√ßo IP resolvido 192.0.2.1 foi registrada no datacenter n√∫mero 107 do Cloudflare. Esses dados vieram de v√°rias fontes, incluindo nossas amostras ativas e passivas, os logs de alguns dom√≠nios que possu√≠mos (por exemplo,</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), fontes abertas (por exemplo, tabelas BGP) etc. A mesma linha geralmente √© repetida em v√°rios arquivos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, recebi um conjunto de dados gigantesco desse tipo. </font><font style="vertical-align: inherit;">Em algum momento, em todas as fontes coletadas, contei 1 bilh√£o de linhas. </font><font style="vertical-align: inherit;">Normalmente, escrevo scripts bash para pr√©-processar dados de entrada, mas nessa escala essa abordagem n√£o funcionou. </font><font style="vertical-align: inherit;">Por exemplo, a remo√ß√£o de duplicatas a partir deste min√∫sculo arquivo de 600 MiB e 40 milh√µes de linhas leva ... a eternidade: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
basta dizer que as linhas de duplica√ß√£o com comandos comuns do tipo </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em v√°rias configura√ß√µes (ver </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) n√£o era o melhor para tal um grande conjunto de dados.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtros Bloom</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustra√ß√£o de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em dom√≠nio p√∫blico</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ent√£o me dei conta: n√£o ordene as linhas! Voc√™ precisa remover duplicatas, para que algum tipo de estrutura de dados 'definida' funcione muito mais r√°pido. Al√©m disso, eu sei aproximadamente o tamanho do arquivo de entrada (o n√∫mero de linhas √∫nicas) e a perda de alguns dados n√£o √© cr√≠tica, ou seja, a estrutura probabil√≠stica dos dados √© bastante adequada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© perfeito para filtros Bloom!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto voc√™ l√™ a</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia sobre filtros Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© assim que eu olho para essa estrutura de dados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ implementaria</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a pluralidade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Dada uma fun√ß√£o de hash ideal e mem√≥ria infinita, podemos simplesmente criar um bitmap infinito e definir um n√∫mero de bit para cada elemento</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso fornece a estrutura de dados ideal para a "multid√£o". </font><font style="vertical-align: inherit;">Direita? </font><font style="vertical-align: inherit;">Trivialmente. </font><font style="vertical-align: inherit;">Infelizmente, as fun√ß√µes de hash colidem, e a mem√≥ria infinita n√£o existe; portanto, em nossa realidade, precisamos comprometer. </font><font style="vertical-align: inherit;">Mas podemos calcular a probabilidade de colis√µes e gerenciar esse valor. </font><font style="vertical-align: inherit;">Por exemplo, temos uma boa fun√ß√£o de hash e 128 GB de mem√≥ria. </font><font style="vertical-align: inherit;">Podemos calcular que a probabilidade de colis√£o para cada novo elemento √© de 1 a 1099511627776. Quando voc√™ adiciona mais elementos, a probabilidade aumenta √† medida que o bitmap √© preenchido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, podemos aplicar mais de uma fun√ß√£o de hash e obter um bitmap mais denso. </font><font style="vertical-align: inherit;">√â aqui que o filtro Bloom funciona bem, que √© um conjunto de dados matem√°ticos com quatro vari√°veis:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - n√∫mero de elementos inseridos (n√∫mero cardinal)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - mem√≥ria usada pelo bitmap</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - o n√∫mero de fun√ß√µes hash calculadas para cada entrada</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - probabilidade de coincid√™ncia falso positiva</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado o n√∫mero cardinal </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a probabilidade desejada de um falso positivo </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o filtro Bloom retorna a mem√≥ria necess√°ria </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o n√∫mero necess√°rio de fun√ß√µes de hash </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Confira esta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente visualiza√ß√£o de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">de</font></a><font style="vertical-align: inherit;"> como os par√¢metros se afetam.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guiado pela intui√ß√£o, adicionei a ferramenta probabil√≠stica mmuniq-bloom ao meu arsenal, que recebe a entrada STDIN e retorna apenas linhas exclusivas no STDOUT. </font><font style="vertical-align: inherit;">Deve ser muito mais r√°pido que uma combina√ß√£o de </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ali est√° ele:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar e agilizar, defini inicialmente alguns par√¢metros. Primeiro, a menos que seja indicado de outra forma, o mmuniq-bloom usa oito fun√ß√µes de hash k = 8. Parece estar perto do n√∫mero ideal para o tamanho dos nossos dados, e a fun√ß√£o hash pode produzir rapidamente oito hashes decentes. Em seguida, alinhamos a mem√≥ria </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no bitmap √† pot√™ncia de dois para evitar uma opera√ß√£o cara </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que no assembler diminui a velocidade </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se o array for igual √† pot√™ncia de dois, podemos simplesmente usar AND bit a bit (por divers√£o, leia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como os compiladores otimizam algumas opera√ß√µes de divis√£o multiplicando por uma constante m√°gica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos execut√°-lo no mesmo arquivo de dados que usamos anteriormente:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, isso √© muito melhor! 12 segundos em vez de dois minutos. O programa usa uma estrutura de dados otimizada, uma quantidade relativamente limitada de mem√≥ria, an√°lise de linha otimizada e bom buffer de sa√≠da ... e com tudo isso, 12 segundos parecem uma eternidade em compara√ß√£o com a ferramenta </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que est√° acontecendo? Entendo que contar seq√º√™ncias de caracteres √© </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais f√°cil do que calcular seq√º√™ncias √∫nicas, mas a diferen√ßa de 26 horas √© realmente justificada? O que a CPU absorve </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deve ser para hashes de computa√ß√£o. O utilit√°rio </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o gasta o processador, fazendo toda essa matem√°tica estranha para cada uma das 40 milh√µes de linhas. Eu uso uma fun√ß√£o hash n√£o trivial </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, com certeza queima o processador, certo? Vamos verificar executando apenas a fun√ß√£o hash, mas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o executando opera√ß√µes com o filtro Bloom: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© estranho. </font><font style="vertical-align: inherit;">O c√°lculo da fun√ß√£o hash leva apenas cerca de dois segundos, embora todo o programa na execu√ß√£o anterior tenha sido executado por 12 segundos. </font><font style="vertical-align: inherit;">Um filtro Bloom funciona por 10 segundos? </font><font style="vertical-align: inherit;">Como isso √© poss√≠vel? </font><font style="vertical-align: inherit;">Essa √© uma estrutura de dados t√£o simples ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arma Secreta - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â hora de aplicar a ferramenta certa para esta tarefa - vamos executar o criador de perfil e ver no que o processador est√° trabalhando. Primeiro, vamos correr </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para verificar se n√£o h√° chamadas inesperadas do sistema: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tudo parece bom. Dez chamadas para </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms cada (3971 Œºs) s√£o intrigantes, mas tudo bem. N√≥s preenchemos a mem√≥ria com </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para evitar erros posteriormente devido √† falta de uma p√°gina. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual √© o pr√≥ximo passo? Claro que sim </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o vamos ver o resultado: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, n√≥s realmente queimamos 87,2% dos ciclos no c√≥digo principal. Vamos ver exatamente onde. A equipe </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imediatamente mostra algo inesperado. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que 26,90% do processador queimaram em</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Mas isso n√£o √© tudo! O compilador insere corretamente a fun√ß√£o e expande o loop. Acontece que a maioria dos ciclos vai para isso </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou para a linha </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, perf est√° errado, como uma string t√£o simples pode ocupar tantos recursos? Mas repetir o teste com qualquer outro gerador de perfil mostra o mesmo problema. Por exemplo, eu gosto de usar o google-perftools com o kcachegrind devido aos diagramas coloridos: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado da visualiza√ß√£o √© o seguinte: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me resumir o que descobrimos at√© agora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O utilit√°rio padr√£o </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processa um arquivo 600 MiB por 0,45 s. Nossa ferramenta otimizada </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dura 12 segundos. O processador √© gravado em uma instru√ß√£o </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, desreferenciando a mem√≥ria ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagem de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! Como eu poderia esquecer. O acesso aleat√≥rio √† mem√≥ria √©</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lento! Muito, muito, muito devagar!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com os</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√∫meros que todo programador deve saber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um √∫nico acesso √† RAM leva cerca de 100 ns. Vamos contar: 40 milh√µes de linhas, 8 hashes cada. Como nosso filtro Bloom tem um tamanho de 128 MiB, em</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nosso hardware antigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele n√£o se encaixa no cache L3! Os hashes s√£o distribu√≠dos uniformemente por uma ampla faixa de mem√≥ria - cada um deles gera uma falha de cache. Coloque tudo junto, e acontece ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece que 32 segundos queimam apenas em acessos √† mem√≥ria. O programa real cabe em apenas 12 segundos, j√° que o filtro Bloom ainda se beneficia do cache. √â f√°cil ver com isso </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, dever√≠amos ter tido pelo menos 320 milh√µes de erros de cache (LLC-load-misses), mas apenas 280 milh√µes ocorreram: isso ainda n√£o explica por que o programa funcionou em apenas 12 segundos. Mas n√£o importa. √â importante que o n√∫mero de falhas de cache seja um problema real, e s√≥ podemos resolv√™-lo reduzindo o n√∫mero de acessos √† mem√≥ria. Vamos tentar configurar o filtro Bloom para usar apenas uma fun√ß√£o de hash: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! Isso realmente d√≥i! Para obter uma probabilidade de colis√£o de 1 por 10.000 linhas, o filtro Bloom exigia 64 gigabytes de mem√≥ria. √â horr√≠vel!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, n√£o parece que a velocidade tenha aumentado significativamente. </font><font style="vertical-align: inherit;">O sistema operacional levou 22 segundos para preparar a mem√≥ria para n√≥s, mas ainda gastamos 11 segundos no espa√ßo do usu√°rio. </font><font style="vertical-align: inherit;">Acredito que agora todas as vantagens de um acesso mais raro √† mem√≥ria s√£o compensadas por uma menor probabilidade de entrar no cache devido a um tamanho de mem√≥ria bastante aumentado. </font><font style="vertical-align: inherit;">Antes, 128 MiB eram suficientes para o filtro Bloom!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recusando filtros Bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso est√° ficando rid√≠culo. </font><font style="vertical-align: inherit;">Para reduzir a probabilidade de falsos positivos, voc√™ deve usar muitos hashes no filtro Bloom (por exemplo, oito) com muitos acessos de mem√≥ria ou deixar uma fun√ß√£o de hash, mas use grandes quantidades de mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, n√£o temos um limite de mem√≥ria, queremos minimizar o n√∫mero de chamadas para ele. </font><font style="vertical-align: inherit;">Precisamos de uma estrutura de dados que custe no m√°ximo uma falta de cache por elemento e use menos de 64 gigabytes de RAM ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â claro que voc√™ pode implementar estruturas de dados complexas, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um filtro de cuco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas certamente existe uma op√ß√£o mais f√°cil. </font><font style="vertical-align: inherit;">E a boa e antiga tabela de hash de sondagem linear? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustra√ß√£o de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conhe√ßa mmuniq-hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° a nova vers√£o do mmuniq-bloom usando uma tabela de hash:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez dos bits do filtro Bloom, agora armazenamos hashes de 64 bits da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√£o 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Isso fornece uma prote√ß√£o muito melhor contra colis√µes de hash: muito melhor que uma por 10.000 linhas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos contar. </font><font style="vertical-align: inherit;">Adicionar um novo item a uma tabela de hash, digamos, com 40 milh√µes de entradas, d√° a chance de colis√µes de hash </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso √© cerca de 1 em 461 bilh√µes - uma probabilidade bastante baixa. </font><font style="vertical-align: inherit;">Mas n√£o adicionamos um elemento ao conjunto pr√©-preenchido! </font><font style="vertical-align: inherit;">Em vez disso, adicionamos 40 milh√µes de linhas ao conjunto inicialmente vazio. </font><font style="vertical-align: inherit;">De acordo com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o paradoxo do anivers√°rio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , isso aumenta muito a probabilidade de colis√µes. </font><font style="vertical-align: inherit;">Uma aproxima√ß√£o razo√°vel seria uma estimativa </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no nosso caso, √©</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Acontece uma chance em 23.000. Em outras palavras, com uma boa fun√ß√£o de hash, esperamos uma colis√£o em um dos 23.000 conjuntos aleat√≥rios de 40 milh√µes de elementos. Essa √© uma probabilidade diferente de zero, mas ainda melhor do que no filtro Bloom, e √© completamente toler√°vel para o nosso caso de uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo com uma tabela de hash funciona mais r√°pido, possui melhores padr√µes de acesso √† mem√≥ria e menor probabilidade de falsos positivos do que no filtro Bloom.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o se assuste com a linha de ‚Äúconflitos de hash‚Äù, ela mostra o qu√£o cheia a tabela de hash est√°. </font><font style="vertical-align: inherit;">Usamos o sensor linear, portanto, quando entramos no conjunto completo, pegamos o pr√≥ximo vazio. </font><font style="vertical-align: inherit;">No nosso caso, temos que pular uma m√©dia de 0,7 conjuntos para encontrar um ponto vazio na tabela. </font><font style="vertical-align: inherit;">Isto √© normal. </font><font style="vertical-align: inherit;">Como iteramos os conjuntos em uma ordem linear, a mem√≥ria deve estar qualitativamente cheia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo anterior, sabemos que nossa fun√ß√£o hash leva cerca de dois segundos. </font><font style="vertical-align: inherit;">Conclu√≠mos que 40 milh√µes de acessos √† mem√≥ria levam cerca de quatro segundos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√µes aprendidas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os processadores modernos s√£o realmente bons no acesso seq√ºencial √† mem√≥ria quando √© poss√≠vel prever padr√µes de amostragem (consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©-busca em cache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). O acesso aleat√≥rio √† mem√≥ria, por outro lado, √© muito caro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estruturas de dados avan√ßadas s√£o muito interessantes, mas tenha cuidado. Computadores modernos exigem o uso de algoritmos otimizados para cache. Ao trabalhar com grandes conjuntos de dados que n√£o cabem no L3, √© prefer√≠vel a otimiza√ß√£o sobre o n√∫mero de ocorr√™ncias, em vez da otimiza√ß√£o sobre a quantidade de mem√≥ria usada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â justo dizer que os filtros Bloom t√™m um √≥timo desempenho quando colocados no cache L3. Mas se n√£o, ent√£o eles s√£o terr√≠veis. Isso n√£o √© novidade: os filtros Bloom s√£o otimizados para a quantidade de mem√≥ria, n√£o o n√∫mero de chamadas. Por exemplo, veja</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo cient√≠fico sobre filtros de cuco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra coisa s√£o discuss√µes intermin√°veis ‚Äã‚Äãsobre fun√ß√µes de hash. Honestamente, na maioria dos casos isso n√£o importa. O custo de contar at√© fun√ß√µes complexas de hash parece ser </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pequeno comparado ao custo do acesso aleat√≥rio √† mem√≥ria. No nosso caso, simplificar a fun√ß√£o hash trar√° apenas um pequeno benef√≠cio. O tempo de CPU √© desperdi√ßado em outro lugar - aguardando mem√≥ria! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um colega costuma dizer: ‚ÄúPode-se supor que os processadores modernos sejam infinitamente r√°pidos. Eles trabalham em velocidade infinita, at√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descansarem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contra a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">parede da mem√≥ria</font></a><font style="vertical-align: inherit;"> ". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, n√£o repita meu erro. Voc√™ sempre precisa primeiro criar perfis com</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e veja o contador do IPC (instru√ß√µes por ciclo). </font><font style="vertical-align: inherit;">Se for menor que um, isso geralmente significa que o programa est√° parado aguardando mem√≥ria. </font><font style="vertical-align: inherit;">Os valores √≥timos est√£o acima de dois. </font><font style="vertical-align: inherit;">Isso significa que a carga de trabalho est√° principalmente na CPU. </font><font style="vertical-align: inherit;">Infelizmente, em minhas tarefas, o IPC ainda √© baixo ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mmuniq superior</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a ajuda de colegas, escrevi uma vers√£o aprimorada da ferramenta mmuniq com base em uma tabela de hash. </font><font style="vertical-align: inherit;">Aqui est√° o c√≥digo:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele pode alterar dinamicamente o tamanho da tabela de hash, suporta entrada com um n√∫mero cardinal arbitr√°rio. </font><font style="vertical-align: inherit;">Em seguida, processa os dados em pacotes, efetivamente usando a dica </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na CPU, que acelera o programa em 35-40%. </font><font style="vertical-align: inherit;">Tenha cuidado, o uso abundante </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no c√≥digo raramente produz efeito. </font><font style="vertical-align: inherit;">Para usar essa fun√ß√£o, reordenei especialmente os algoritmos. </font><font style="vertical-align: inherit;">Com todas as melhorias, o tempo de execu√ß√£o foi reduzido para 2,1 segundos:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o fim</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A cria√ß√£o de uma ferramenta b√°sica que tenta superar a combina√ß√£o 'sort / uniq' revelou alguns recursos ocultos da computa√ß√£o moderna. </font><font style="vertical-align: inherit;">Depois de suar um pouco, aceleramos o programa de mais de dois minutos para dois segundos. </font><font style="vertical-align: inherit;">Durante o desenvolvimento, aprendemos sobre o atraso no acesso aleat√≥rio √† mem√≥ria, bem como sobre o poder das estruturas de dados amig√°veis ‚Äã‚Äãao cache. </font><font style="vertical-align: inherit;">Estruturas de dados bizarras atraem a aten√ß√£o, mas na pr√°tica geralmente √© mais eficiente reduzir o n√∫mero de acessos aleat√≥rios √† mem√≥ria.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491116/index.html">Padr√µes de identifica√ß√£o modernos: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../pt491118/index.html">Cora√ß√£o do desenvolvedor: Devkits da 5¬™ gera√ß√£o de consoles (Parte 1)</a></li>
<li><a href="../pt491120/index.html">$ mol: 4 anos depois</a></li>
<li><a href="../pt491122/index.html">An√°lise forense de backups do HiSuite</a></li>
<li><a href="../pt491130/index.html">Recursos do Vue para lembrar</a></li>
<li><a href="../pt491134/index.html">5 est√°gios de inevitabilidade da ado√ß√£o da certifica√ß√£o ISO / IEC 27001. Nega√ß√£o</a></li>
<li><a href="../pt491136/index.html">Projetando conte√∫do na documenta√ß√£o angular ou perdida de conte√∫do ng</a></li>
<li><a href="../pt491138/index.html">Integra√ß√£o via sat√©lite e torre Ansible</a></li>
<li><a href="../pt491146/index.html">UML para desenvolvedores</a></li>
<li><a href="../pt491150/index.html">Como eu invadi os golpistas ou apenas o interior dos pain√©is de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>