<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏻 💂 ☃️ Messung der Speicherbandbreite am Knie 💆🏽 😠 ⚾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Wochen beschwerte sich ein Kollege in einem Gespräch beim Abendessen über einen langsamen Prozess. Er berechnete die Anzahl der generierte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Messung der Speicherbandbreite am Knie</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor einigen Wochen beschwerte sich ein Kollege in einem Gespräch beim Abendessen über einen langsamen Prozess. Er berechnete die Anzahl der generierten Bytes, die Anzahl der Verarbeitungszyklen und letztendlich die Größe des RAM. Ein Kollege sagte, dass eine moderne GPU mit einer Speicherbandbreite von mehr als 500 GB / s ihre Aufgabe verschlingen und nicht ersticken würde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es schien mir, dass dies ein interessanter Ansatz ist. Persönlich habe ich Leistungsziele aus dieser Perspektive bisher nicht bewertet. Ja, ich kenne den Unterschied in der Prozessor- und Speicherleistung. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich weiß, wie man Code schreibt, der den Cache stark nutzt. Ich kenne die ungefähren Verzögerungszahlen. Dies reicht jedoch nicht aus, um die Speicherbandbreite sofort zu bewerten.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Gedankenexperiment. </font><font style="vertical-align: inherit;">Stellen Sie sich im Speicher ein kontinuierliches Array von einer Milliarde 32-Bit-Ganzzahlen vor. </font><font style="vertical-align: inherit;">Das sind 4 Gigabyte. </font><font style="vertical-align: inherit;">Wie lange dauert es, dieses Array zu durchlaufen und die Werte zu addieren? </font><font style="vertical-align: inherit;">Wie viele Bytes pro Sekunde kann die CPU aus dem RAM lesen? </font><font style="vertical-align: inherit;">Kontinuierliche Daten? </font><font style="vertical-align: inherit;">Direktzugriff? </font><font style="vertical-align: inherit;">Wie gut kann dieser Prozess parallelisiert werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden sagen, dass dies nutzlose Fragen sind. </font><font style="vertical-align: inherit;">Echte Programme sind zu komplex, um einen so naiven Meilenstein zu setzen. </font><font style="vertical-align: inherit;">So ist es! </font><font style="vertical-align: inherit;">Die eigentliche Antwort lautet "je nach Situation". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke jedoch, dass es sich lohnt, dieses Problem zu untersuchen. </font><font style="vertical-align: inherit;">Ich versuche nicht, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antwort</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu finden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber ich denke, wir können einige obere und untere Grenzen definieren, einige interessante Punkte in der Mitte und dabei etwas lernen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahlen, die jeder Programmierer kennen sollte</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Programmierblogs lesen, sind Sie wahrscheinlich auf "Zahlen gestoßen, die jeder Programmierer kennen sollte". </font><font style="vertical-align: inherit;">Sie sehen ungefähr so ​​aus:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum L1-Cache 0,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Falsche 5 ns Vorhersage</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zum L2-Cache 7 ns 14x zum L1-Cache</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex Capture / Release 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verbindung zum Hauptspeicher 100 ns 20x zum L2-Cache, 200x zum L1-Cache</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komprimieren Sie 1000 Bytes mit Zippy 3000 ns 3 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Senden von 1000 Bytes über ein 1-Gbit / s-Netzwerk 10.000 ns 10 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Random Read 4000 mit SSD 150.000 ns 150 μs ~ 1 GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie nacheinander 1 MB aus 250.000 ns und 250 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Roundtrip-Paket im Rechenzentrum 500.000 ns 500 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 MB sequentielles Einlesen der SSD 1.000.000 ns 1.000 μs 1 ms ~ 1 GB / s SSD, 4x Speicher</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Festplattensuche 10.000.000 ns 10.000 μs 10 ms 20x zum Rechenzentrum</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie 1 MB nacheinander von der Festplatte 20.000.000 ns 20.000 μs 20 ms 80x in den Speicher, 20x in die SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paket senden CA-&gt; Niederlande-&gt; CA 150.000.000 ns 150.000 μs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Große Liste. </font><font style="vertical-align: inherit;">Er taucht mindestens einmal im Jahr bei HackerNews auf. </font><font style="vertical-align: inherit;">Jeder Programmierer sollte diese Zahlen kennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber diese Zahlen handeln von etwas anderem. </font><font style="vertical-align: inherit;">Latenz und Bandbreite sind nicht dasselbe.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzögerung im Jahr 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Liste wurde 2012 erstellt, und dieser Artikel von 2020 hat sich geändert. </font><font style="vertical-align: inherit;">Hier sind die Zahlen für Intel i7 mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treffer im L1-Cache, ~ 4 Zyklen (2,1 - 1,2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Treffer im L2-Cache, ~ 10 Zyklen (5,3 - 3,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit im L3-Cache für einen einzelnen Kern ~ 40 Zyklen (21,4 - 12,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit im L3-Cache, zusammen für einen weiteren Kernel ~ 65 Zyklen (34,8 - 19,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Treffen Sie den L3-Cache mit einer Änderung für einen weiteren Kernel ~ 75 Zyklen (40,2 - 22,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lokaler RAM ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessant! </font><font style="vertical-align: inherit;">Was hat sich geändert?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 ist langsamer geworden; </font></font><code>0,5 → 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 schneller; </font></font><code>7 → 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verhältnis von L1 und L2 ist stark reduziert; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Beeindruckend!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der L3-Cache ist mittlerweile zum Standard geworden. </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM ist schneller geworden; </font></font><code>100 → 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden keine weitreichenden Schlussfolgerungen ziehen. </font><font style="vertical-align: inherit;">Es ist unklar, wie die ursprünglichen Zahlen berechnet wurden. </font><font style="vertical-align: inherit;">Wir werden Äpfel nicht mit Orangen vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind einige Zahlen von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Bandbreite und Cache-Größe meines Prozessors.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherbandbreite: 39,74 Gigabyte pro Sekunde</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1-Cache: 192 Kilobyte (32 KB pro Kern)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2-Cache: 1,5 Megabyte (256 KB pro Kern)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3-Cache: 12 Megabyte (gemeinsam genutzt; 2 MB pro Kern)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ich wissen will:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obergrenze der RAM-Leistung</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untere Grenze</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3-Cache-Grenzen</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naives Benchmarking</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einige Tests machen. </font><font style="vertical-align: inherit;">Um die Bandbreite zu messen, habe ich ein einfaches C ++ - Programm geschrieben. </font><font style="vertical-align: inherit;">Sehr ungefähr sieht sie so aus.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Details werden weggelassen. Aber du hast die Idee verstanden. Erstellen Sie ein großes, kontinuierliches Array von Elementen. Teilen Sie das Array in separate Fragmente. Verarbeiten Sie jedes Fragment in einem separaten Thread. Ergebnisse akkumulieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen auch den Direktzugriff messen. Das ist sehr schwer. Ich habe verschiedene Möglichkeiten ausprobiert und mich schließlich entschlossen, vorberechnete Indizes zu mischen. Jeder Index existiert genau einmal. Dann durchläuft die innere Schleife die Indizes und berechnet </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Berechnung des Durchsatzes </font><font style="vertical-align: inherit;">berücksichtige </font><font style="vertical-align: inherit;">ich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Speicher des Indexarrays. </font><font style="vertical-align: inherit;">Es werden nur Bytes gezählt, die zur Gesamtsumme beitragen </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich vergleiche meine Hardware nicht, sondern bewerte die Fähigkeit, mit Datensätzen unterschiedlicher Größe und mit unterschiedlichen Zugriffsschemata zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden Tests mit drei Datentypen durchführen: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die 32-Bit-Hauptzahl </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- enthält </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">passt in eine 64-Byte-Cache-Zeile </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- verwendet integrierte Tools</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Großer Block</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein erster Test funktioniert mit einem großen Speicherblock. Ein 1-GB-Block von </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elementen wird hervorgehoben und mit kleinen Zufallswerten gefüllt. Eine einfache Schleife durchläuft ein Array N-mal, sodass sie mit einem Volume auf den Speicher zugreift </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Summe zu berechnen </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mehrere Threads teilen das Array auf und jeder erhält Zugriff auf die gleiche Anzahl von Elementen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TA Dah! In diesem Diagramm nehmen wir die durchschnittliche Ausführungszeit der Summierungsoperation und konvertieren sie von </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ziemlich gutes Ergebnis. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nacheinander 11 GB / s in einem einzelnen Stream lesen. Es skaliert linear, bis es 38 GB / s erreicht. Tests </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schneller, aber an der gleichen Decke ruhen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine klare und offensichtliche Obergrenze dafür, wie viele Daten pro Sekunde aus dem RAM gelesen werden können. </font><font style="vertical-align: inherit;">Auf meinem System sind dies ungefähr 40 GB / s. </font><font style="vertical-align: inherit;">Dies entspricht den oben aufgeführten aktuellen Spezifikationen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemessen an den unteren drei Diagrammen ist der Direktzugriff langsam. </font><font style="vertical-align: inherit;">Sehr sehr langsam. </font><font style="vertical-align: inherit;">Die Single-Threaded-Leistung </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beträgt vernachlässigbare 0,46 GB / s. </font><font style="vertical-align: inherit;">Dies ist 24-mal langsamer als sequentielles Stapeln mit 11,03 GB / s! </font><font style="vertical-align: inherit;">Der Test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt das beste Ergebnis, da er in vollen Cache-Zeilen ausgeführt wird. </font><font style="vertical-align: inherit;">Es ist jedoch immer noch vier- bis siebenmal langsamer als der sequentielle Zugriff und erreicht Spitzenwerte von nur 8 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleiner Block: sequentielles Lesen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf meinem System beträgt die L1 / L2 / L3-Cache-Größe für jeden Stream 32 KB, 256 KB und 2 MB. Was passiert, wenn Sie einen 32-Kilobyte-Block von Elementen nehmen und 125.000 Mal darüber iterieren? Dies sind 4 GB Speicher, aber wir werden immer in den Cache gehen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genial! Die Single-Thread-Leistung ähnelt dem Lesen eines großen Blocks mit etwa 12 GB / s. Abgesehen davon, dass diesmal Multithreading die Obergrenze von 40 GB / s durchbricht. Es ergibt Sinn. Die Daten verbleiben im Cache, sodass der RAM-Engpass nicht auftritt. Für Daten, die nicht in den L3-Cache passen, gilt die gleiche Obergrenze von ca. 38 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt ähnliche Ergebnisse wie die Schaltung, jedoch noch schneller; 31 GB / s im Single-Thread-Modus, 171 GB / s im Multithread-Modus. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun schauen wir uns an </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Achten Sie auf die y-Achse.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">außergewöhnlich schnell durchgeführt. </font><font style="vertical-align: inherit;">Es ist 10 mal schneller als </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei einem 16-KB-Block werden sogar 1000 GB / s durchbrochen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich ist dies ein Oberflächensynthesetest. </font><font style="vertical-align: inherit;">Die meisten Anwendungen führen nicht millionenfach hintereinander denselben Vorgang mit denselben Daten aus. </font><font style="vertical-align: inherit;">Der Test zeigt keine Leistung in der realen Welt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber die Lektion ist klar. </font><font style="vertical-align: inherit;">Im Cache werden Daten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schnell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verarbeitet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit einer sehr hohen Obergrenze bei Verwendung von SIMD: mehr als 100 GB / s im Single-Thread-Modus, mehr als 1000 GB / s im Multithread-Modus. </font><font style="vertical-align: inherit;">Das Schreiben von Daten in den Cache ist langsam und mit einer harten Grenze von etwa 40 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleiner Block: zufälliges Lesen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Machen wir dasselbe, aber jetzt mit wahlfreiem Zugriff. </font><font style="vertical-align: inherit;">Dies ist mein Lieblingsteil des Artikels. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Lesen von Zufallswerten aus dem RAM ist langsam, nur 0,46 GB / s. </font><font style="vertical-align: inherit;">Das Lesen von Zufallswerten aus dem L1-Cache ist sehr schnell: 13 GB / s. </font><font style="vertical-align: inherit;">Dies ist schneller als das Lesen serieller Daten </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem RAM (11 GB / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt ein ähnliches Ergebnis für dieselbe Vorlage, jedoch ungefähr doppelt so schnell wie </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Direktzugriff ist </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wahnsinnig schnell.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse des wahlfreien Zugriffs</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das freie Lesen aus dem Speicher ist langsam. </font><font style="vertical-align: inherit;">Katastrophal langsam. </font><font style="vertical-align: inherit;">Weniger als 1 GB / s für beide Testfälle </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gleichzeitig sind zufällige Lesevorgänge aus dem Cache überraschend schnell. </font><font style="vertical-align: inherit;">Es ist vergleichbar mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequentiellen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lesen aus dem RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es muss verdaut werden. </font><font style="vertical-align: inherit;">Der zufällige Zugriff auf den Cache ist in seiner Geschwindigkeit mit dem sequentiellen Zugriff auf den RAM vergleichbar. </font><font style="vertical-align: inherit;">Der Rückgang von L1 16 KB auf L2 256 KB beträgt nur die Hälfte oder weniger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, dass dies tiefgreifende Konsequenzen haben wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verknüpfte Listen gelten als schädlich</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfolgen eines Zeigers (Springen auf Zeiger) ist schlecht. </font><font style="vertical-align: inherit;">Sehr sehr schlecht. </font><font style="vertical-align: inherit;">Um wie viel nimmt die Leistung ab? </font><font style="vertical-align: inherit;">Überzeugen Sie sich selbst. </font><font style="vertical-align: inherit;">Ich habe einen zusätzlichen Test, wickelt </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jeder Zugriff erfolgt über einen Zeiger. </font><font style="vertical-align: inherit;">Hier ist ein schreckliches, nur katastrophales Ergebnis.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 Thread | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großer Block - Seq | </font><font style="vertical-align: inherit;">14,8 GB / s | </font><font style="vertical-align: inherit;">0,8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">31,6 GB / s | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">22,2 GB / s | </font><font style="vertical-align: inherit;">1,9 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großer Block - Rand | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">0,1 GB / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">23,2 GB / s | </font><font style="vertical-align: inherit;">1,7 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">15,2 GB / s | </font><font style="vertical-align: inherit;">0,8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 Fäden | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großer Block - Seq | </font><font style="vertical-align: inherit;">34,4 GB / s | </font><font style="vertical-align: inherit;">2,5 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">154,8 GB / s | </font><font style="vertical-align: inherit;">8,0 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">111,6 GB / s | </font><font style="vertical-align: inherit;">5,7 GB / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großer Block - Rand | </font><font style="vertical-align: inherit;">7,1 GB / s | </font><font style="vertical-align: inherit;">0,4 GB / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">95,0 GB / s | </font><font style="vertical-align: inherit;">7,8 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">58,3 GB / s | </font><font style="vertical-align: inherit;">1,6 GB / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die sequentielle Summierung der Werte hinter dem Zeiger erfolgt mit einer Geschwindigkeit von weniger als 1 GB / s. </font><font style="vertical-align: inherit;">Die doppelt übersprungene Direktzugriffsgeschwindigkeit des Caches beträgt nur 0,1 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfolgen eines Zeigers verlangsamt die Codeausführung 10 bis 20 Mal. </font><font style="vertical-align: inherit;">Lassen Sie Ihre Freunde keine verknüpften Listen verwenden. </font><font style="vertical-align: inherit;">Bitte denken Sie an den Cache.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Budgetschätzung für Frames</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist üblich, dass Spieleentwickler ein Limit (Budget) für die Belastung der CPU und die Speichermenge festlegen. Aber ich habe noch nie ein Bandbreitenbudget gesehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In modernen Spielen wächst FPS weiter. Jetzt ist es bei 60 FPS. VR arbeitet mit einer Frequenz von 90 Hz. Ich habe einen 144-Hz-Gaming-Monitor. Es ist großartig, also scheinen die 60 FPS wie Scheiße zu sein. Ich werde niemals zum alten Monitor zurückkehren. Esports und Streamer Twitch überwacht 240 Hz. In diesem Jahr stellte Asus auf der CES ein 360-Hz-Monster vor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein Prozessor hat eine Obergrenze von ca. 40 GB / s. Das scheint eine große Zahl zu sein! Bei einer Frequenz von 240 Hz werden jedoch nur 167 MB pro Bild erhalten. Eine realistische Anwendung kann 5 GB / s Verkehr mit 144 Hz erzeugen, was nur 69 MB pro Frame entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine Tabelle mit einigen Zahlen.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 | </font><font style="vertical-align: inherit;">60 | </font><font style="vertical-align: inherit;">90 | </font><font style="vertical-align: inherit;">144 | </font><font style="vertical-align: inherit;">240 | </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB / s | </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1,3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB / s | </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB / s | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint mir nützlich, Probleme aus dieser Perspektive zu bewerten. </font><font style="vertical-align: inherit;">Dies macht deutlich, dass einige Ideen nicht realisierbar sind. </font><font style="vertical-align: inherit;">240 Hz zu erreichen ist nicht einfach. </font><font style="vertical-align: inherit;">Dies wird nicht von alleine passieren.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahlen, die jeder Programmierer kennen sollte (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vorherige Liste ist veraltet. </font><font style="vertical-align: inherit;">Jetzt muss es aktualisiert und bis 2020 in Übereinstimmung gebracht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind einige Zahlen für meinen Heimcomputer. </font><font style="vertical-align: inherit;">Dies ist eine Mischung aus AIDA64, Sandra und meinen Benchmarks. </font><font style="vertical-align: inherit;">Die Zahlen geben kein vollständiges Bild und sind nur ein Ausgangspunkt.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latenz L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2-Verzögerung: 2,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verzögerung L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM-Latenz: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(pro Thread)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1-Band: 210 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2-Band: 80 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3-Band: 60 GB / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(das ganze System)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM-Band: 45 GB / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wäre schön, einen kleinen, einfachen Open-Source-Benchmark zu erstellen. </font><font style="vertical-align: inherit;">Einige C-Dateien, die auf Desktop-Computern, Servern, Mobilgeräten, Konsolen usw. ausgeführt werden können. Aber ich bin nicht die Art von Person, die ein solches Tool schreibt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweigerung der Verantwortung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Messen der Speicherbandbreite ist schwierig. </font><font style="vertical-align: inherit;">Sehr kompliziert. </font><font style="vertical-align: inherit;">Es gibt wahrscheinlich Fehler in meinem Code. </font><font style="vertical-align: inherit;">Viele unerklärliche Faktoren. </font><font style="vertical-align: inherit;">Wenn Sie Kritik an meiner Technik haben, haben Sie wahrscheinlich Recht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich halte ich das für normal. </font><font style="vertical-align: inherit;">In diesem Artikel geht es nicht um die genaue Leistung meines Desktops. </font><font style="vertical-align: inherit;">Dies ist unter bestimmten Gesichtspunkten eine Problemstellung. </font><font style="vertical-align: inherit;">Und darüber, wie man lernt, wie man grobe mathematische Berechnungen durchführt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Kollege teilte mir eine interessante Meinung über die GPU-Speicherbandbreite und die Anwendungsleistung mit. </font><font style="vertical-align: inherit;">Dies veranlasste mich, die Speicherleistung auf modernen Computern zu untersuchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für ungefähre Berechnungen sind hier einige Zahlen für einen modernen Desktop:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM-Leistung</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximal: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Durchschnitt ungefähr: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3-Cache-Leistung (pro Kern)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Durchschnitt ungefähr: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Stichprobenbewertungen beziehen sich auf die Leistung </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Echter Code wird niemals so einfach sein. </font><font style="vertical-align: inherit;">Für Berechnungen auf einer Serviette ist dies jedoch ein vernünftiger Ausgangspunkt. </font><font style="vertical-align: inherit;">Sie müssen diese Zahl basierend auf den Speicherzugriffsmustern in Ihrem Programm, den Eigenschaften Ihrer Ausrüstung und dem Code anpassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste ist jedoch eine neue Art, über Probleme nachzudenken. </font><font style="vertical-align: inherit;">Die Darstellung des Problems in Bytes pro Sekunde oder Bytes pro Frame ist eine weitere Linse, durch die man schauen muss. </font><font style="vertical-align: inherit;">Dies ist ein nützliches Werkzeug für alle Fälle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danke fürs Lesen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Nachforschungen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel hat das Thema nur geringfügig berührt. </font><font style="vertical-align: inherit;">Ich werde wahrscheinlich nicht darauf eingehen. </font><font style="vertical-align: inherit;">Wenn er dies tun würde, könnte er einige der folgenden Aspekte abdecken:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufnahmeleistung</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsches Teilen</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(oder deren Fehlen)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistungsindikatoren</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLB-Leistung</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Protokolle</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemspezifikationen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tests wurden auf meinem Heim-PC durchgeführt. </font><font style="vertical-align: inherit;">Nur Lagereinstellungen, kein Übertakten.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betriebssystem: Windows 10 v1903 Build 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU: Intel i7-8700k bei 3,70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 bei 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptplatine: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487884/index.html">5 Dinge, die ich vor der Entwicklung des Austauschs gerne wissen würde</a></li>
<li><a href="../de487888/index.html">CSRF bei Umbraco CMS</a></li>
<li><a href="../de487890/index.html">Übersetzen Sie Sprache unter iOS mit dem Speech Framework in Text</a></li>
<li><a href="../de487894/index.html">BarsUP.AM: Wie wir ein Tool zum Schutz von Informationen von Webanwendungen entwickelt haben</a></li>
<li><a href="../de487896/index.html">Wenn der Tod zur Kunst wird: Epitaphien berühmter Persönlichkeiten mit einer tiefen englischen Bedeutung</a></li>
<li><a href="../de487900/index.html">pyqtdeploy, oder wir packen das Python-Programm in exe'shnik ... auf die harte Tour</a></li>
<li><a href="../de487902/index.html">Von Feuer zu Feuer: Feuerfester Festkörperelektrolyt für Lithium-Ionen-Batterien</a></li>
<li><a href="../de487906/index.html">Das Buch "Computernetzwerke. Prinzipien, Technologien, Protokolle: Jubiläumsausgabe »</a></li>
<li><a href="../de487908/index.html">Der Beginn des Krieges der technologischen Prozesse: 5 nm und 3 nm</a></li>
<li><a href="../de487910/index.html">Naturgesetze und elegante Mathematik: Probleme und Lösungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>