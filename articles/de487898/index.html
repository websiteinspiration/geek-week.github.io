<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèª üíÇ ‚òÉÔ∏è Messung der Speicherbandbreite am Knie üíÜüèΩ üò† ‚öæÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Wochen beschwerte sich ein Kollege in einem Gespr√§ch beim Abendessen √ºber einen langsamen Prozess. Er berechnete die Anzahl der generierte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Messung der Speicherbandbreite am Knie</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor einigen Wochen beschwerte sich ein Kollege in einem Gespr√§ch beim Abendessen √ºber einen langsamen Prozess. Er berechnete die Anzahl der generierten Bytes, die Anzahl der Verarbeitungszyklen und letztendlich die Gr√∂√üe des RAM. Ein Kollege sagte, dass eine moderne GPU mit einer Speicherbandbreite von mehr als 500 GB / s ihre Aufgabe verschlingen und nicht ersticken w√ºrde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es schien mir, dass dies ein interessanter Ansatz ist. Pers√∂nlich habe ich Leistungsziele aus dieser Perspektive bisher nicht bewertet. Ja, ich kenne den Unterschied in der Prozessor- und Speicherleistung. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü, wie man Code schreibt, der den Cache stark nutzt. Ich kenne die ungef√§hren Verz√∂gerungszahlen. Dies reicht jedoch nicht aus, um die Speicherbandbreite sofort zu bewerten.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Gedankenexperiment. </font><font style="vertical-align: inherit;">Stellen Sie sich im Speicher ein kontinuierliches Array von einer Milliarde 32-Bit-Ganzzahlen vor. </font><font style="vertical-align: inherit;">Das sind 4 Gigabyte. </font><font style="vertical-align: inherit;">Wie lange dauert es, dieses Array zu durchlaufen und die Werte zu addieren? </font><font style="vertical-align: inherit;">Wie viele Bytes pro Sekunde kann die CPU aus dem RAM lesen? </font><font style="vertical-align: inherit;">Kontinuierliche Daten? </font><font style="vertical-align: inherit;">Direktzugriff? </font><font style="vertical-align: inherit;">Wie gut kann dieser Prozess parallelisiert werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden sagen, dass dies nutzlose Fragen sind. </font><font style="vertical-align: inherit;">Echte Programme sind zu komplex, um einen so naiven Meilenstein zu setzen. </font><font style="vertical-align: inherit;">So ist es! </font><font style="vertical-align: inherit;">Die eigentliche Antwort lautet "je nach Situation". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke jedoch, dass es sich lohnt, dieses Problem zu untersuchen. </font><font style="vertical-align: inherit;">Ich versuche nicht, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antwort</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu finden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber ich denke, wir k√∂nnen einige obere und untere Grenzen definieren, einige interessante Punkte in der Mitte und dabei etwas lernen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahlen, die jeder Programmierer kennen sollte</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Programmierblogs lesen, sind Sie wahrscheinlich auf "Zahlen gesto√üen, die jeder Programmierer kennen sollte". </font><font style="vertical-align: inherit;">Sie sehen ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum L1-Cache 0,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Falsche 5 ns Vorhersage</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zum L2-Cache 7 ns 14x zum L1-Cache</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex Capture / Release 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verbindung zum Hauptspeicher 100 ns 20x zum L2-Cache, 200x zum L1-Cache</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komprimieren Sie 1000 Bytes mit Zippy 3000 ns 3 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Senden von 1000 Bytes √ºber ein 1-Gbit / s-Netzwerk 10.000 ns 10 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Random Read 4000 mit SSD 150.000 ns 150 Œºs ~ 1 GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie nacheinander 1 MB aus 250.000 ns und 250 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Roundtrip-Paket im Rechenzentrum 500.000 ns 500 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 MB sequentielles Einlesen der SSD 1.000.000 ns 1.000 Œºs 1 ms ~ 1 GB / s SSD, 4x Speicher</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Festplattensuche 10.000.000 ns 10.000 Œºs 10 ms 20x zum Rechenzentrum</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie 1 MB nacheinander von der Festplatte 20.000.000 ns 20.000 Œºs 20 ms 80x in den Speicher, 20x in die SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paket senden CA-&gt; Niederlande-&gt; CA 150.000.000 ns 150.000 Œºs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Gro√üe Liste. </font><font style="vertical-align: inherit;">Er taucht mindestens einmal im Jahr bei HackerNews auf. </font><font style="vertical-align: inherit;">Jeder Programmierer sollte diese Zahlen kennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber diese Zahlen handeln von etwas anderem. </font><font style="vertical-align: inherit;">Latenz und Bandbreite sind nicht dasselbe.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verz√∂gerung im Jahr 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Liste wurde 2012 erstellt, und dieser Artikel von 2020 hat sich ge√§ndert. </font><font style="vertical-align: inherit;">Hier sind die Zahlen f√ºr Intel i7 mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treffer im L1-Cache, ~ 4 Zyklen (2,1 - 1,2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Treffer im L2-Cache, ~ 10 Zyklen (5,3 - 3,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit im L3-Cache f√ºr einen einzelnen Kern ~ 40 Zyklen (21,4 - 12,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit im L3-Cache, zusammen f√ºr einen weiteren Kernel ~ 65 Zyklen (34,8 - 19,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Treffen Sie den L3-Cache mit einer √Ñnderung f√ºr einen weiteren Kernel ~ 75 Zyklen (40,2 - 22,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lokaler RAM ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessant! </font><font style="vertical-align: inherit;">Was hat sich ge√§ndert?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 ist langsamer geworden; </font></font><code>0,5 ‚Üí 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 schneller; </font></font><code>7 ‚Üí 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verh√§ltnis von L1 und L2 ist stark reduziert; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Beeindruckend!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der L3-Cache ist mittlerweile zum Standard geworden. </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM ist schneller geworden; </font></font><code>100 ‚Üí 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden keine weitreichenden Schlussfolgerungen ziehen. </font><font style="vertical-align: inherit;">Es ist unklar, wie die urspr√ºnglichen Zahlen berechnet wurden. </font><font style="vertical-align: inherit;">Wir werden √Ñpfel nicht mit Orangen vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind einige Zahlen von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Bandbreite und Cache-Gr√∂√üe meines Prozessors.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherbandbreite: 39,74 Gigabyte pro Sekunde</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1-Cache: 192 Kilobyte (32 KB pro Kern)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2-Cache: 1,5 Megabyte (256 KB pro Kern)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3-Cache: 12 Megabyte (gemeinsam genutzt; 2 MB pro Kern)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ich wissen will:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obergrenze der RAM-Leistung</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untere Grenze</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3-Cache-Grenzen</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naives Benchmarking</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einige Tests machen. </font><font style="vertical-align: inherit;">Um die Bandbreite zu messen, habe ich ein einfaches C ++ - Programm geschrieben. </font><font style="vertical-align: inherit;">Sehr ungef√§hr sieht sie so aus.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Details werden weggelassen. Aber du hast die Idee verstanden. Erstellen Sie ein gro√ües, kontinuierliches Array von Elementen. Teilen Sie das Array in separate Fragmente. Verarbeiten Sie jedes Fragment in einem separaten Thread. Ergebnisse akkumulieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie m√ºssen auch den Direktzugriff messen. Das ist sehr schwer. Ich habe verschiedene M√∂glichkeiten ausprobiert und mich schlie√ülich entschlossen, vorberechnete Indizes zu mischen. Jeder Index existiert genau einmal. Dann durchl√§uft die innere Schleife die Indizes und berechnet </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Berechnung des Durchsatzes </font><font style="vertical-align: inherit;">ber√ºcksichtige </font><font style="vertical-align: inherit;">ich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Speicher des Indexarrays. </font><font style="vertical-align: inherit;">Es werden nur Bytes gez√§hlt, die zur Gesamtsumme beitragen </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich vergleiche meine Hardware nicht, sondern bewerte die F√§higkeit, mit Datens√§tzen unterschiedlicher Gr√∂√üe und mit unterschiedlichen Zugriffsschemata zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden Tests mit drei Datentypen durchf√ºhren: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die 32-Bit-Hauptzahl </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- enth√§lt </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">passt in eine 64-Byte-Cache-Zeile </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- verwendet integrierte Tools</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√üer Block</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein erster Test funktioniert mit einem gro√üen Speicherblock. Ein 1-GB-Block von </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elementen wird hervorgehoben und mit kleinen Zufallswerten gef√ºllt. Eine einfache Schleife durchl√§uft ein Array N-mal, sodass sie mit einem Volume auf den Speicher zugreift </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Summe zu berechnen </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mehrere Threads teilen das Array auf und jeder erh√§lt Zugriff auf die gleiche Anzahl von Elementen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TA Dah! In diesem Diagramm nehmen wir die durchschnittliche Ausf√ºhrungszeit der Summierungsoperation und konvertieren sie von </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ziemlich gutes Ergebnis. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nacheinander 11 GB / s in einem einzelnen Stream lesen. Es skaliert linear, bis es 38 GB / s erreicht. Tests </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schneller, aber an der gleichen Decke ruhen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine klare und offensichtliche Obergrenze daf√ºr, wie viele Daten pro Sekunde aus dem RAM gelesen werden k√∂nnen. </font><font style="vertical-align: inherit;">Auf meinem System sind dies ungef√§hr 40 GB / s. </font><font style="vertical-align: inherit;">Dies entspricht den oben aufgef√ºhrten aktuellen Spezifikationen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemessen an den unteren drei Diagrammen ist der Direktzugriff langsam. </font><font style="vertical-align: inherit;">Sehr sehr langsam. </font><font style="vertical-align: inherit;">Die Single-Threaded-Leistung </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">betr√§gt vernachl√§ssigbare 0,46 GB / s. </font><font style="vertical-align: inherit;">Dies ist 24-mal langsamer als sequentielles Stapeln mit 11,03 GB / s! </font><font style="vertical-align: inherit;">Der Test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt das beste Ergebnis, da er in vollen Cache-Zeilen ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Es ist jedoch immer noch vier- bis siebenmal langsamer als der sequentielle Zugriff und erreicht Spitzenwerte von nur 8 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleiner Block: sequentielles Lesen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf meinem System betr√§gt die L1 / L2 / L3-Cache-Gr√∂√üe f√ºr jeden Stream 32 KB, 256 KB und 2 MB. Was passiert, wenn Sie einen 32-Kilobyte-Block von Elementen nehmen und 125.000 Mal dar√ºber iterieren? Dies sind 4 GB Speicher, aber wir werden immer in den Cache gehen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genial! Die Single-Thread-Leistung √§hnelt dem Lesen eines gro√üen Blocks mit etwa 12 GB / s. Abgesehen davon, dass diesmal Multithreading die Obergrenze von 40 GB / s durchbricht. Es ergibt Sinn. Die Daten verbleiben im Cache, sodass der RAM-Engpass nicht auftritt. F√ºr Daten, die nicht in den L3-Cache passen, gilt die gleiche Obergrenze von ca. 38 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt √§hnliche Ergebnisse wie die Schaltung, jedoch noch schneller; 31 GB / s im Single-Thread-Modus, 171 GB / s im Multithread-Modus. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun schauen wir uns an </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Achten Sie auf die y-Achse.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au√üergew√∂hnlich schnell durchgef√ºhrt. </font><font style="vertical-align: inherit;">Es ist 10 mal schneller als </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei einem 16-KB-Block werden sogar 1000 GB / s durchbrochen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich ist dies ein Oberfl√§chensynthesetest. </font><font style="vertical-align: inherit;">Die meisten Anwendungen f√ºhren nicht millionenfach hintereinander denselben Vorgang mit denselben Daten aus. </font><font style="vertical-align: inherit;">Der Test zeigt keine Leistung in der realen Welt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber die Lektion ist klar. </font><font style="vertical-align: inherit;">Im Cache werden Daten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schnell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verarbeitet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit einer sehr hohen Obergrenze bei Verwendung von SIMD: mehr als 100 GB / s im Single-Thread-Modus, mehr als 1000 GB / s im Multithread-Modus. </font><font style="vertical-align: inherit;">Das Schreiben von Daten in den Cache ist langsam und mit einer harten Grenze von etwa 40 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleiner Block: zuf√§lliges Lesen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Machen wir dasselbe, aber jetzt mit wahlfreiem Zugriff. </font><font style="vertical-align: inherit;">Dies ist mein Lieblingsteil des Artikels. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Lesen von Zufallswerten aus dem RAM ist langsam, nur 0,46 GB / s. </font><font style="vertical-align: inherit;">Das Lesen von Zufallswerten aus dem L1-Cache ist sehr schnell: 13 GB / s. </font><font style="vertical-align: inherit;">Dies ist schneller als das Lesen serieller Daten </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem RAM (11 GB / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt ein √§hnliches Ergebnis f√ºr dieselbe Vorlage, jedoch ungef√§hr doppelt so schnell wie </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Direktzugriff ist </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wahnsinnig schnell.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse des wahlfreien Zugriffs</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das freie Lesen aus dem Speicher ist langsam. </font><font style="vertical-align: inherit;">Katastrophal langsam. </font><font style="vertical-align: inherit;">Weniger als 1 GB / s f√ºr beide Testf√§lle </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gleichzeitig sind zuf√§llige Lesevorg√§nge aus dem Cache √ºberraschend schnell. </font><font style="vertical-align: inherit;">Es ist vergleichbar mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequentiellen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lesen aus dem RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es muss verdaut werden. </font><font style="vertical-align: inherit;">Der zuf√§llige Zugriff auf den Cache ist in seiner Geschwindigkeit mit dem sequentiellen Zugriff auf den RAM vergleichbar. </font><font style="vertical-align: inherit;">Der R√ºckgang von L1 16 KB auf L2 256 KB betr√§gt nur die H√§lfte oder weniger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, dass dies tiefgreifende Konsequenzen haben wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkn√ºpfte Listen gelten als sch√§dlich</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfolgen eines Zeigers (Springen auf Zeiger) ist schlecht. </font><font style="vertical-align: inherit;">Sehr sehr schlecht. </font><font style="vertical-align: inherit;">Um wie viel nimmt die Leistung ab? </font><font style="vertical-align: inherit;">√úberzeugen Sie sich selbst. </font><font style="vertical-align: inherit;">Ich habe einen zus√§tzlichen Test, wickelt </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jeder Zugriff erfolgt √ºber einen Zeiger. </font><font style="vertical-align: inherit;">Hier ist ein schreckliches, nur katastrophales Ergebnis.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 Thread | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üer Block - Seq | </font><font style="vertical-align: inherit;">14,8 GB / s | </font><font style="vertical-align: inherit;">0,8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">31,6 GB / s | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">22,2 GB / s | </font><font style="vertical-align: inherit;">1,9 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üer Block - Rand | </font><font style="vertical-align: inherit;">2,2 GB / s | </font><font style="vertical-align: inherit;">0,1 GB / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">23,2 GB / s | </font><font style="vertical-align: inherit;">1,7 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">15,2 GB / s | </font><font style="vertical-align: inherit;">0,8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 F√§den | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üer Block - Seq | </font><font style="vertical-align: inherit;">34,4 GB / s | </font><font style="vertical-align: inherit;">2,5 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">154,8 GB / s | </font><font style="vertical-align: inherit;">8,0 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">111,6 GB / s | </font><font style="vertical-align: inherit;">5,7 GB / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üer Block - Rand | </font><font style="vertical-align: inherit;">7,1 GB / s | </font><font style="vertical-align: inherit;">0,4 GB / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">95,0 GB / s | </font><font style="vertical-align: inherit;">7,8 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">58,3 GB / s | </font><font style="vertical-align: inherit;">1,6 GB / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die sequentielle Summierung der Werte hinter dem Zeiger erfolgt mit einer Geschwindigkeit von weniger als 1 GB / s. </font><font style="vertical-align: inherit;">Die doppelt √ºbersprungene Direktzugriffsgeschwindigkeit des Caches betr√§gt nur 0,1 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfolgen eines Zeigers verlangsamt die Codeausf√ºhrung 10 bis 20 Mal. </font><font style="vertical-align: inherit;">Lassen Sie Ihre Freunde keine verkn√ºpften Listen verwenden. </font><font style="vertical-align: inherit;">Bitte denken Sie an den Cache.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Budgetsch√§tzung f√ºr Frames</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist √ºblich, dass Spieleentwickler ein Limit (Budget) f√ºr die Belastung der CPU und die Speichermenge festlegen. Aber ich habe noch nie ein Bandbreitenbudget gesehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In modernen Spielen w√§chst FPS weiter. Jetzt ist es bei 60 FPS. VR arbeitet mit einer Frequenz von 90 Hz. Ich habe einen 144-Hz-Gaming-Monitor. Es ist gro√üartig, also scheinen die 60 FPS wie Schei√üe zu sein. Ich werde niemals zum alten Monitor zur√ºckkehren. Esports und Streamer Twitch √ºberwacht 240 Hz. In diesem Jahr stellte Asus auf der CES ein 360-Hz-Monster vor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein Prozessor hat eine Obergrenze von ca. 40 GB / s. Das scheint eine gro√üe Zahl zu sein! Bei einer Frequenz von 240 Hz werden jedoch nur 167 MB pro Bild erhalten. Eine realistische Anwendung kann 5 GB / s Verkehr mit 144 Hz erzeugen, was nur 69 MB pro Frame entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine Tabelle mit einigen Zahlen.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 | </font><font style="vertical-align: inherit;">60 | </font><font style="vertical-align: inherit;">90 | </font><font style="vertical-align: inherit;">144 | </font><font style="vertical-align: inherit;">240 | </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB / s | </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1,3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB / s | </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB / s | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint mir n√ºtzlich, Probleme aus dieser Perspektive zu bewerten. </font><font style="vertical-align: inherit;">Dies macht deutlich, dass einige Ideen nicht realisierbar sind. </font><font style="vertical-align: inherit;">240 Hz zu erreichen ist nicht einfach. </font><font style="vertical-align: inherit;">Dies wird nicht von alleine passieren.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahlen, die jeder Programmierer kennen sollte (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vorherige Liste ist veraltet. </font><font style="vertical-align: inherit;">Jetzt muss es aktualisiert und bis 2020 in √úbereinstimmung gebracht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind einige Zahlen f√ºr meinen Heimcomputer. </font><font style="vertical-align: inherit;">Dies ist eine Mischung aus AIDA64, Sandra und meinen Benchmarks. </font><font style="vertical-align: inherit;">Die Zahlen geben kein vollst√§ndiges Bild und sind nur ein Ausgangspunkt.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latenz L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2-Verz√∂gerung: 2,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verz√∂gerung L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM-Latenz: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(pro Thread)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1-Band: 210 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2-Band: 80 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3-Band: 60 GB / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(das ganze System)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM-Band: 45 GB / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es w√§re sch√∂n, einen kleinen, einfachen Open-Source-Benchmark zu erstellen. </font><font style="vertical-align: inherit;">Einige C-Dateien, die auf Desktop-Computern, Servern, Mobilger√§ten, Konsolen usw. ausgef√ºhrt werden k√∂nnen. Aber ich bin nicht die Art von Person, die ein solches Tool schreibt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweigerung der Verantwortung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Messen der Speicherbandbreite ist schwierig. </font><font style="vertical-align: inherit;">Sehr kompliziert. </font><font style="vertical-align: inherit;">Es gibt wahrscheinlich Fehler in meinem Code. </font><font style="vertical-align: inherit;">Viele unerkl√§rliche Faktoren. </font><font style="vertical-align: inherit;">Wenn Sie Kritik an meiner Technik haben, haben Sie wahrscheinlich Recht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich halte ich das f√ºr normal. </font><font style="vertical-align: inherit;">In diesem Artikel geht es nicht um die genaue Leistung meines Desktops. </font><font style="vertical-align: inherit;">Dies ist unter bestimmten Gesichtspunkten eine Problemstellung. </font><font style="vertical-align: inherit;">Und dar√ºber, wie man lernt, wie man grobe mathematische Berechnungen durchf√ºhrt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Kollege teilte mir eine interessante Meinung √ºber die GPU-Speicherbandbreite und die Anwendungsleistung mit. </font><font style="vertical-align: inherit;">Dies veranlasste mich, die Speicherleistung auf modernen Computern zu untersuchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr ungef√§hre Berechnungen sind hier einige Zahlen f√ºr einen modernen Desktop:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM-Leistung</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximal: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Durchschnitt ungef√§hr: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3-Cache-Leistung (pro Kern)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Durchschnitt ungef√§hr: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Stichprobenbewertungen beziehen sich auf die Leistung </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Echter Code wird niemals so einfach sein. </font><font style="vertical-align: inherit;">F√ºr Berechnungen auf einer Serviette ist dies jedoch ein vern√ºnftiger Ausgangspunkt. </font><font style="vertical-align: inherit;">Sie m√ºssen diese Zahl basierend auf den Speicherzugriffsmustern in Ihrem Programm, den Eigenschaften Ihrer Ausr√ºstung und dem Code anpassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste ist jedoch eine neue Art, √ºber Probleme nachzudenken. </font><font style="vertical-align: inherit;">Die Darstellung des Problems in Bytes pro Sekunde oder Bytes pro Frame ist eine weitere Linse, durch die man schauen muss. </font><font style="vertical-align: inherit;">Dies ist ein n√ºtzliches Werkzeug f√ºr alle F√§lle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danke f√ºrs Lesen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Nachforschungen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel hat das Thema nur geringf√ºgig ber√ºhrt. </font><font style="vertical-align: inherit;">Ich werde wahrscheinlich nicht darauf eingehen. </font><font style="vertical-align: inherit;">Wenn er dies tun w√ºrde, k√∂nnte er einige der folgenden Aspekte abdecken:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufnahmeleistung</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsches Teilen</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(oder deren Fehlen)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistungsindikatoren</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLB-Leistung</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Protokolle</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemspezifikationen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tests wurden auf meinem Heim-PC durchgef√ºhrt. </font><font style="vertical-align: inherit;">Nur Lagereinstellungen, kein √úbertakten.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betriebssystem: Windows 10 v1903 Build 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU: Intel i7-8700k bei 3,70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 bei 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptplatine: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487884/index.html">5 Dinge, die ich vor der Entwicklung des Austauschs gerne wissen w√ºrde</a></li>
<li><a href="../de487888/index.html">CSRF bei Umbraco CMS</a></li>
<li><a href="../de487890/index.html">√úbersetzen Sie Sprache unter iOS mit dem Speech Framework in Text</a></li>
<li><a href="../de487894/index.html">BarsUP.AM: Wie wir ein Tool zum Schutz von Informationen von Webanwendungen entwickelt haben</a></li>
<li><a href="../de487896/index.html">Wenn der Tod zur Kunst wird: Epitaphien ber√ºhmter Pers√∂nlichkeiten mit einer tiefen englischen Bedeutung</a></li>
<li><a href="../de487900/index.html">pyqtdeploy, oder wir packen das Python-Programm in exe'shnik ... auf die harte Tour</a></li>
<li><a href="../de487902/index.html">Von Feuer zu Feuer: Feuerfester Festk√∂rperelektrolyt f√ºr Lithium-Ionen-Batterien</a></li>
<li><a href="../de487906/index.html">Das Buch "Computernetzwerke. Prinzipien, Technologien, Protokolle: Jubil√§umsausgabe ¬ª</a></li>
<li><a href="../de487908/index.html">Der Beginn des Krieges der technologischen Prozesse: 5 nm und 3 nm</a></li>
<li><a href="../de487910/index.html">Naturgesetze und elegante Mathematik: Probleme und L√∂sungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>