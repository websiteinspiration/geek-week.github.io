<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏼 🍐 🙎🏻 Algoritmo de representación de volumen rápido y fácil 🤦🏽 👩🏿‍🔬 ♈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente escribí un pequeño ShaderToy que hace una representación volumétrica simple, y luego decidí publicar una publicación explicando su traba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmo de representación de volumen rápido y fácil</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente escribí un pequeño ShaderToy que hace una representación volumétrica simple, y luego decidí publicar una publicación explicando su trabajo. </font><font style="vertical-align: inherit;">El ShaderToy interactivo se puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si está leyendo desde un teléfono o computadora portátil, le recomiendo ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versión rápida. </font><font style="vertical-align: inherit;">Incluí fragmentos de código en la publicación que lo ayudarán a comprender el rendimiento de ShaderToy a un alto nivel, pero no tienen todos los detalles. </font><font style="vertical-align: inherit;">Si desea profundizar, le recomiendo consultar con el código ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi ShaderToy tenía tres tareas principales:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecución en tiempo real</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sencillez</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrección física (... o algo así)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzaré con esta escena de código en blanco. </font><font style="vertical-align: inherit;">No entraré en detalles de la implementación, porque no es muy interesante, pero te diré brevemente por dónde comenzamos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trazado de rayos de objetos opacos. </font><font style="vertical-align: inherit;">Todos los objetos son primitivos con intersecciones simples con rayos (1 plano y 3 esferas)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular la iluminación, se usa el sombreado de Phong, y en tres fuentes de luz esféricas, se usa un coeficiente de atenuación de luz personalizado. </font><font style="vertical-align: inherit;">No se requieren rayos de sombras, porque iluminamos solo el plano.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ve:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Captura de pantalla de ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Representaremos el volumen como un pasaje separado que se mezcla con una escena opaca; </font><font style="vertical-align: inherit;">Esto es similar a cómo todos los motores de renderizado en tiempo real procesan individualmente superficies opacas y translúcidas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1: simular volumen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero primero, antes de que podamos comenzar la representación volumétrica, ¡necesitamos este mismo volumen! Para simular el volumen, decidí usar funciones de distancia con signo (SDF). ¿Por qué precisamente las funciones de los campos de distancia? Porque no soy un artista, pero te permiten crear formas muy orgánicas en solo unas pocas líneas de código. No hablaré en detalle sobre las funciones de distancias con un signo, porque Iñigo Kiles ya las ha explicado maravillosamente. Si tiene curiosidad, entonces </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> una gran lista de diferentes funciones de letreros y modificadores. Y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hay otro artículo sobre estos SDF raymarching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con uno simple y agreguemos una esfera aquí:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora agregaremos otra esfera y utilizaremos una conjugación suave para fusionar las funciones de distancia de las esferas. </font><font style="vertical-align: inherit;">Este código lo tomé directamente de la página de Íñigo, pero para mayor claridad, lo insertaré aquí:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El emparejamiento suave es una herramienta extremadamente poderosa, porque puedes obtener algo bastante interesante simplemente combinándolo con algunas formas simples. </font><font style="vertical-align: inherit;">Así es como se ven mis muchas esferas suavemente conjugadas:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos algo en forma de lágrima, pero necesitamos algo más como una nube que una gota. Una gran característica de SDF es lo fácil que es distorsionar la superficie simplemente agregando un poco de ruido al SDF. Así que agreguemos algo de movimiento browniano fractal (fBM) encima del ruido, usando la posición para indexar la función de ruido. Iñigo Kiles también cubrió este tema en un excelente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artículo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre el ruido fBM. Así se verá la imagen con ruido fBM superpuesto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Multa! </font><font style="vertical-align: inherit;">Gracias al ruido fBM, el objeto de repente comenzó a parecer mucho más interesante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesitamos crear la ilusión de que el volumen interactúa con el plano de la tierra. </font><font style="vertical-align: inherit;">Para hacer esto, agregué una distancia del plano firmado ligeramente por debajo del plano de tierra y reutilicé la combinación de emparejamiento suave con un valor de emparejamiento muy agresivo (parámetro k). </font><font style="vertical-align: inherit;">Después de eso, tenemos esta imagen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El toque final será el cambio en el índice xz del ruido fBM a lo largo del tiempo, de modo que el volumen se vea como una niebla en remolino. </font><font style="vertical-align: inherit;">En movimiento, ¡se ve muy bien!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Genial, tenemos algo así como una nube! </font><font style="vertical-align: inherit;">El código de cálculo SDF también es bastante compacto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto solo representa un objeto opaco. ¡Necesitamos una hermosa niebla magnífica! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo lo representamos en forma de volumen y no como un objeto opaco? Primero hablemos de la física que simulamos. El volumen es una gran cantidad de partículas en un área determinada del espacio. Y cuando digo "enorme", me refiero a "ENORME". Tanto es así que modelar cada una de estas partículas hoy es una tarea imposible, incluso para el renderizado sin conexión. Buenos ejemplos de esto son el fuego, la niebla y las nubes. Estrictamente hablando, todo es volumen, pero en aras de la velocidad de los cálculos, es más fácil cerrar los ojos y fingir que no lo es. Representamos la acumulación de estas partículas como valores de densidad que generalmente se almacenan en algún tipo de cuadrícula 3D (o algo más complejo, por ejemplo, en OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando la luz pasa a través de un volumen, pueden ocurrir un par de fenómenos cuando la luz colisiona con una partícula. </font><font style="vertical-align: inherit;">Puede dispersarse e ir en la otra dirección, o parte de la luz puede ser absorbida por la partícula y disolverse. </font><font style="vertical-align: inherit;">Para cumplir con el requisito de ejecución en tiempo real, realizaremos lo que se denomina dispersión única. </font><font style="vertical-align: inherit;">Esto significa lo siguiente: asumiremos que la luz se dispersa solo una vez, cuando la luz colisiona con una partícula y vuela hacia la cámara. </font><font style="vertical-align: inherit;">Es decir, no podremos simular los efectos de la dispersión múltiple, por ejemplo, niebla, en la que los objetos a distancia generalmente se ven más vagos. </font><font style="vertical-align: inherit;">Pero para nuestro sistema esto es suficiente. </font><font style="vertical-align: inherit;">Así es como se ve la dispersión única al raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El pseudocódigo para esto se ve más o menos así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, estamos tratando con cálculos con complejidad O (n * m * k). </font><font style="vertical-align: inherit;">Entonces la GPU tendrá que trabajar duro.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos la absorcion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, veamos la absorción de la luz en el volumen a lo largo del haz de la cámara (es decir, todavía no realicemos el marcado de rayos en la dirección de las fuentes de luz). </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos dos acciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realizar raymarching dentro del volumen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcule la absorción / iluminación en cada paso</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para calcular cuánta luz se absorbe en cada punto, utilizamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la ley de Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que describe la atenuación de la luz al pasar a través de un material. </font><font style="vertical-align: inherit;">Los cálculos son sorprendentemente simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El coeficiente de absorción es un parámetro material. </font><font style="vertical-align: inherit;">Por ejemplo, en un volumen transparente, por ejemplo, en agua, este valor será bajo, y para algo más grueso, por ejemplo, leche, el coeficiente será más alto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para realizar el marcado de rayos por volumen, simplemente tomamos pasos de un tamaño fijo a lo largo del haz y obtenemos absorción en cada paso. </font><font style="vertical-align: inherit;">Es posible que no entienda por qué tomar pasos fijos en lugar de algo más rápido, por ejemplo, trazar una esfera, pero si recuerda que la densidad dentro del volumen es heterogénea, entonces todo se vuelve claro. </font><font style="vertical-align: inherit;">A continuación se muestra el código de absorción de raymarching y acumulación. </font><font style="vertical-align: inherit;">Algunas variables están fuera del alcance de este fragmento de código, así que revisa la implementación completa en ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y esto es lo que obtenemos con esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Parece algodón de azúcar! </font><font style="vertical-align: inherit;">¡Quizás para algunos efectos esto sea suficiente! </font><font style="vertical-align: inherit;">Pero nos faltan las sombras. </font><font style="vertical-align: inherit;">La luz alcanza todas las partes del volumen por igual. </font><font style="vertical-align: inherit;">Pero esto no es físicamente correcto, dependiendo del tamaño del volumen entre el punto renderizado y la fuente de luz, recibiremos una cantidad diferente de luz entrante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto sombreado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya hemos hecho lo más difícil. </font><font style="vertical-align: inherit;">Necesitamos hacer lo mismo que hicimos para calcular la absorción a lo largo del haz de la cámara, pero solo a lo largo del haz de luz. </font><font style="vertical-align: inherit;">El código para calcular la cantidad de luz que llega a cada punto será esencialmente una repetición del código, pero duplicarlo es más fácil que piratear HLSL para obtener la recurrencia que necesitamos. </font><font style="vertical-align: inherit;">Así que así es como se verá:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregar auto-sombreado nos da lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Captura de pantalla de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suavizar los bordes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por el momento, ya me gusta bastante nuestro volumen. </font><font style="vertical-align: inherit;">Se lo mostré al talentoso líder del departamento de efectos visuales de The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Inmediatamente notó que los bordes del volumen se veían demasiado afilados. </font><font style="vertical-align: inherit;">Y esto es absolutamente cierto: los objetos como las nubes están constantemente dispersos en el espacio a su alrededor, por lo que sus bordes se mezclan con el espacio vacío alrededor del volumen, lo que debería conducir a la creación de bordes muy suaves. </font><font style="vertical-align: inherit;">James me ofreció una gran idea: reducir la densidad según lo cerca que estemos del borde. </font><font style="vertical-align: inherit;">Y como estamos trabajando con funciones de distancia con un signo, ¡es muy fácil de implementar! </font><font style="vertical-align: inherit;">Entonces, agreguemos una función que se pueda usar para solicitar densidad en cualquier punto del volumen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y luego simplemente lo colapsamos en el valor de absorción:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y así es como se ve:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Captura de pantalla de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Función de densidad</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que tenemos la función de densidad, puede agregar fácilmente un poco de ruido al volumen para darle detalles adicionales y esplendor. </font><font style="vertical-align: inherit;">En este caso, solo reutilizo la función fBM que utilizamos para ajustar la forma del volumen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y así obtuvimos lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Captura de pantalla de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opaco auto-sombreado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡El volumen ya se ve muy bonito! </font><font style="vertical-align: inherit;">Pero aún se filtra una pequeña luz. </font><font style="vertical-align: inherit;">Aquí vemos cómo se filtra el color verde donde el volumen definitivamente debería absorberlo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto sucede porque los objetos opacos se procesan antes de que se procese el volumen, por lo que no tienen en cuenta el sombreado causado por el volumen. </font><font style="vertical-align: inherit;">Esto es bastante fácil de solucionar: tenemos una función GetLightVisiblity que se puede usar para calcular el sombreado, por lo que solo debemos llamarla para iluminar un objeto opaco. </font><font style="vertical-align: inherit;">Obtenemos lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de crear hermosas sombras multicolores, esto ayuda a mejorar las sombras y aumentar el volumen de la escena. </font><font style="vertical-align: inherit;">Además, gracias a los bordes suaves del volumen, obtenemos sombras suaves, a pesar de que, estrictamente hablando, trabajamos con fuentes puntuales de iluminación. </font><font style="vertical-align: inherit;">¡Eso es todo! </font><font style="vertical-align: inherit;">Aquí se puede hacer mucho más, pero me parece que he logrado la calidad visual que necesito, conservando la relativa simplicidad del ejemplo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaciones</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, enumeraré brevemente algunas posibles optimizaciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de realizar el marcado de rayos en la dirección de la fuente de luz, es necesario verificar por el valor de la extinción de la luz si una cantidad significativa de esta luz realmente alcanza el punto en cuestión. </font><font style="vertical-align: inherit;">En mi implementación, miro el brillo de la luz multiplicado por el albedo del material, y me aseguro de que el valor sea lo suficientemente grande como para realizar el marcado de rayos.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Eso es todo! </font><font style="vertical-align: inherit;">Personalmente, me sorprendió que pueda crear algo físicamente correcto en una cantidad de código tan pequeña (aproximadamente 500 líneas). </font><font style="vertical-align: inherit;">Gracias por leer, espero que haya sido interesante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y una nota más: aquí hay un cambio divertido: agregué emisión de luz en función de la distancia SDF para crear un efecto de explosión. </font><font style="vertical-align: inherit;">Después de todo, las explosiones nunca son muchas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Captura de pantalla de ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es500896/index.html">¿Qué ver en cuarentena? Una selección de materiales de Technostream (parte 3)</a></li>
<li><a href="../es500898/index.html">Crazy Moon SpaceX Plan? Evaluación del programa por U / S_Hirangy (reddit)</a></li>
<li><a href="../es500902/index.html">El resumen de materiales interesantes para el desarrollador móvil # 343 (27 de abril - 3 de mayo)</a></li>
<li><a href="../es500904/index.html">Quién es quién en el ecosistema de pagos 2020. Parte 1</a></li>
<li><a href="../es500910/index.html">Sistema de comunicaciones espaciales de largo alcance de China</a></li>
<li><a href="../es500918/index.html">A qué prestamos atención al calcular la significación estadística de la prueba A / B</a></li>
<li><a href="../es500920/index.html">Antigüedades: ZX Spectrum y el antiguo igrozhur</a></li>
<li><a href="../es500922/index.html">Un lobo con piel de cordero: cómo atrapar a un pirata informático que se disfraza cuidadosamente como un usuario común</a></li>
<li><a href="../es500924/index.html">Reunión en línea JUG.ru "Spring-builder" con Evgeny Borisov</a></li>
<li><a href="../es500926/index.html">La escritura dinámica no es una herramienta de desarrollo. Esto no tiene sentido (pésimo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>