<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèº üçê üôéüèª Algoritmo de representaci√≥n de volumen r√°pido y f√°cil ü§¶üèΩ üë©üèø‚Äçüî¨ ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente escrib√≠ un peque√±o ShaderToy que hace una representaci√≥n volum√©trica simple, y luego decid√≠ publicar una publicaci√≥n explicando su traba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmo de representaci√≥n de volumen r√°pido y f√°cil</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente escrib√≠ un peque√±o ShaderToy que hace una representaci√≥n volum√©trica simple, y luego decid√≠ publicar una publicaci√≥n explicando su trabajo. </font><font style="vertical-align: inherit;">El ShaderToy interactivo se puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si est√° leyendo desde un tel√©fono o computadora port√°til, le recomiendo ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versi√≥n r√°pida. </font><font style="vertical-align: inherit;">Inclu√≠ fragmentos de c√≥digo en la publicaci√≥n que lo ayudar√°n a comprender el rendimiento de ShaderToy a un alto nivel, pero no tienen todos los detalles. </font><font style="vertical-align: inherit;">Si desea profundizar, le recomiendo consultar con el c√≥digo ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi ShaderToy ten√≠a tres tareas principales:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecuci√≥n en tiempo real</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sencillez</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correcci√≥n f√≠sica (... o algo as√≠)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzar√© con esta escena de c√≥digo en blanco. </font><font style="vertical-align: inherit;">No entrar√© en detalles de la implementaci√≥n, porque no es muy interesante, pero te dir√© brevemente por d√≥nde comenzamos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trazado de rayos de objetos opacos. </font><font style="vertical-align: inherit;">Todos los objetos son primitivos con intersecciones simples con rayos (1 plano y 3 esferas)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular la iluminaci√≥n, se usa el sombreado de Phong, y en tres fuentes de luz esf√©ricas, se usa un coeficiente de atenuaci√≥n de luz personalizado. </font><font style="vertical-align: inherit;">No se requieren rayos de sombras, porque iluminamos solo el plano.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como se ve:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Captura de pantalla de ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Representaremos el volumen como un pasaje separado que se mezcla con una escena opaca; </font><font style="vertical-align: inherit;">Esto es similar a c√≥mo todos los motores de renderizado en tiempo real procesan individualmente superficies opacas y transl√∫cidas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1: simular volumen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero primero, antes de que podamos comenzar la representaci√≥n volum√©trica, ¬°necesitamos este mismo volumen! Para simular el volumen, decid√≠ usar funciones de distancia con signo (SDF). ¬øPor qu√© precisamente las funciones de los campos de distancia? Porque no soy un artista, pero te permiten crear formas muy org√°nicas en solo unas pocas l√≠neas de c√≥digo. No hablar√© en detalle sobre las funciones de distancias con un signo, porque I√±igo Kiles ya las ha explicado maravillosamente. Si tiene curiosidad, entonces </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> una gran lista de diferentes funciones de letreros y modificadores. Y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hay otro art√≠culo sobre estos SDF raymarching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con uno simple y agreguemos una esfera aqu√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora agregaremos otra esfera y utilizaremos una conjugaci√≥n suave para fusionar las funciones de distancia de las esferas. </font><font style="vertical-align: inherit;">Este c√≥digo lo tom√© directamente de la p√°gina de √ç√±igo, pero para mayor claridad, lo insertar√© aqu√≠:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El emparejamiento suave es una herramienta extremadamente poderosa, porque puedes obtener algo bastante interesante simplemente combin√°ndolo con algunas formas simples. </font><font style="vertical-align: inherit;">As√≠ es como se ven mis muchas esferas suavemente conjugadas:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos algo en forma de l√°grima, pero necesitamos algo m√°s como una nube que una gota. Una gran caracter√≠stica de SDF es lo f√°cil que es distorsionar la superficie simplemente agregando un poco de ruido al SDF. As√≠ que agreguemos algo de movimiento browniano fractal (fBM) encima del ruido, usando la posici√≥n para indexar la funci√≥n de ruido. I√±igo Kiles tambi√©n cubri√≥ este tema en un excelente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre el ruido fBM. As√≠ se ver√° la imagen con ruido fBM superpuesto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Multa! </font><font style="vertical-align: inherit;">Gracias al ruido fBM, el objeto de repente comenz√≥ a parecer mucho m√°s interesante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesitamos crear la ilusi√≥n de que el volumen interact√∫a con el plano de la tierra. </font><font style="vertical-align: inherit;">Para hacer esto, agregu√© una distancia del plano firmado ligeramente por debajo del plano de tierra y reutilic√© la combinaci√≥n de emparejamiento suave con un valor de emparejamiento muy agresivo (par√°metro k). </font><font style="vertical-align: inherit;">Despu√©s de eso, tenemos esta imagen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El toque final ser√° el cambio en el √≠ndice xz del ruido fBM a lo largo del tiempo, de modo que el volumen se vea como una niebla en remolino. </font><font style="vertical-align: inherit;">En movimiento, ¬°se ve muy bien!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Genial, tenemos algo as√≠ como una nube! </font><font style="vertical-align: inherit;">El c√≥digo de c√°lculo SDF tambi√©n es bastante compacto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto solo representa un objeto opaco. ¬°Necesitamos una hermosa niebla magn√≠fica! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo lo representamos en forma de volumen y no como un objeto opaco? Primero hablemos de la f√≠sica que simulamos. El volumen es una gran cantidad de part√≠culas en un √°rea determinada del espacio. Y cuando digo "enorme", me refiero a "ENORME". Tanto es as√≠ que modelar cada una de estas part√≠culas hoy es una tarea imposible, incluso para el renderizado sin conexi√≥n. Buenos ejemplos de esto son el fuego, la niebla y las nubes. Estrictamente hablando, todo es volumen, pero en aras de la velocidad de los c√°lculos, es m√°s f√°cil cerrar los ojos y fingir que no lo es. Representamos la acumulaci√≥n de estas part√≠culas como valores de densidad que generalmente se almacenan en alg√∫n tipo de cuadr√≠cula 3D (o algo m√°s complejo, por ejemplo, en OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando la luz pasa a trav√©s de un volumen, pueden ocurrir un par de fen√≥menos cuando la luz colisiona con una part√≠cula. </font><font style="vertical-align: inherit;">Puede dispersarse e ir en la otra direcci√≥n, o parte de la luz puede ser absorbida por la part√≠cula y disolverse. </font><font style="vertical-align: inherit;">Para cumplir con el requisito de ejecuci√≥n en tiempo real, realizaremos lo que se denomina dispersi√≥n √∫nica. </font><font style="vertical-align: inherit;">Esto significa lo siguiente: asumiremos que la luz se dispersa solo una vez, cuando la luz colisiona con una part√≠cula y vuela hacia la c√°mara. </font><font style="vertical-align: inherit;">Es decir, no podremos simular los efectos de la dispersi√≥n m√∫ltiple, por ejemplo, niebla, en la que los objetos a distancia generalmente se ven m√°s vagos. </font><font style="vertical-align: inherit;">Pero para nuestro sistema esto es suficiente. </font><font style="vertical-align: inherit;">As√≠ es como se ve la dispersi√≥n √∫nica al raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El pseudoc√≥digo para esto se ve m√°s o menos as√≠:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, estamos tratando con c√°lculos con complejidad O (n * m * k). </font><font style="vertical-align: inherit;">Entonces la GPU tendr√° que trabajar duro.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos la absorcion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, veamos la absorci√≥n de la luz en el volumen a lo largo del haz de la c√°mara (es decir, todav√≠a no realicemos el marcado de rayos en la direcci√≥n de las fuentes de luz). </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos dos acciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realizar raymarching dentro del volumen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcule la absorci√≥n / iluminaci√≥n en cada paso</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para calcular cu√°nta luz se absorbe en cada punto, utilizamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la ley de Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que describe la atenuaci√≥n de la luz al pasar a trav√©s de un material. </font><font style="vertical-align: inherit;">Los c√°lculos son sorprendentemente simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El coeficiente de absorci√≥n es un par√°metro material. </font><font style="vertical-align: inherit;">Por ejemplo, en un volumen transparente, por ejemplo, en agua, este valor ser√° bajo, y para algo m√°s grueso, por ejemplo, leche, el coeficiente ser√° m√°s alto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para realizar el marcado de rayos por volumen, simplemente tomamos pasos de un tama√±o fijo a lo largo del haz y obtenemos absorci√≥n en cada paso. </font><font style="vertical-align: inherit;">Es posible que no entienda por qu√© tomar pasos fijos en lugar de algo m√°s r√°pido, por ejemplo, trazar una esfera, pero si recuerda que la densidad dentro del volumen es heterog√©nea, entonces todo se vuelve claro. </font><font style="vertical-align: inherit;">A continuaci√≥n se muestra el c√≥digo de absorci√≥n de raymarching y acumulaci√≥n. </font><font style="vertical-align: inherit;">Algunas variables est√°n fuera del alcance de este fragmento de c√≥digo, as√≠ que revisa la implementaci√≥n completa en ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y esto es lo que obtenemos con esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Parece algod√≥n de az√∫car! </font><font style="vertical-align: inherit;">¬°Quiz√°s para algunos efectos esto sea suficiente! </font><font style="vertical-align: inherit;">Pero nos faltan las sombras. </font><font style="vertical-align: inherit;">La luz alcanza todas las partes del volumen por igual. </font><font style="vertical-align: inherit;">Pero esto no es f√≠sicamente correcto, dependiendo del tama√±o del volumen entre el punto renderizado y la fuente de luz, recibiremos una cantidad diferente de luz entrante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto sombreado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya hemos hecho lo m√°s dif√≠cil. </font><font style="vertical-align: inherit;">Necesitamos hacer lo mismo que hicimos para calcular la absorci√≥n a lo largo del haz de la c√°mara, pero solo a lo largo del haz de luz. </font><font style="vertical-align: inherit;">El c√≥digo para calcular la cantidad de luz que llega a cada punto ser√° esencialmente una repetici√≥n del c√≥digo, pero duplicarlo es m√°s f√°cil que piratear HLSL para obtener la recurrencia que necesitamos. </font><font style="vertical-align: inherit;">As√≠ que as√≠ es como se ver√°:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregar auto-sombreado nos da lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Captura de pantalla de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suavizar los bordes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por el momento, ya me gusta bastante nuestro volumen. </font><font style="vertical-align: inherit;">Se lo mostr√© al talentoso l√≠der del departamento de efectos visuales de The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Inmediatamente not√≥ que los bordes del volumen se ve√≠an demasiado afilados. </font><font style="vertical-align: inherit;">Y esto es absolutamente cierto: los objetos como las nubes est√°n constantemente dispersos en el espacio a su alrededor, por lo que sus bordes se mezclan con el espacio vac√≠o alrededor del volumen, lo que deber√≠a conducir a la creaci√≥n de bordes muy suaves. </font><font style="vertical-align: inherit;">James me ofreci√≥ una gran idea: reducir la densidad seg√∫n lo cerca que estemos del borde. </font><font style="vertical-align: inherit;">Y como estamos trabajando con funciones de distancia con un signo, ¬°es muy f√°cil de implementar! </font><font style="vertical-align: inherit;">Entonces, agreguemos una funci√≥n que se pueda usar para solicitar densidad en cualquier punto del volumen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y luego simplemente lo colapsamos en el valor de absorci√≥n:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y as√≠ es como se ve:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Captura de pantalla de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funci√≥n de densidad</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que tenemos la funci√≥n de densidad, puede agregar f√°cilmente un poco de ruido al volumen para darle detalles adicionales y esplendor. </font><font style="vertical-align: inherit;">En este caso, solo reutilizo la funci√≥n fBM que utilizamos para ajustar la forma del volumen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y as√≠ obtuvimos lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Captura de pantalla de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opaco auto-sombreado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°El volumen ya se ve muy bonito! </font><font style="vertical-align: inherit;">Pero a√∫n se filtra una peque√±a luz. </font><font style="vertical-align: inherit;">Aqu√≠ vemos c√≥mo se filtra el color verde donde el volumen definitivamente deber√≠a absorberlo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto sucede porque los objetos opacos se procesan antes de que se procese el volumen, por lo que no tienen en cuenta el sombreado causado por el volumen. </font><font style="vertical-align: inherit;">Esto es bastante f√°cil de solucionar: tenemos una funci√≥n GetLightVisiblity que se puede usar para calcular el sombreado, por lo que solo debemos llamarla para iluminar un objeto opaco. </font><font style="vertical-align: inherit;">Obtenemos lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Captura de pantalla de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de crear hermosas sombras multicolores, esto ayuda a mejorar las sombras y aumentar el volumen de la escena. </font><font style="vertical-align: inherit;">Adem√°s, gracias a los bordes suaves del volumen, obtenemos sombras suaves, a pesar de que, estrictamente hablando, trabajamos con fuentes puntuales de iluminaci√≥n. </font><font style="vertical-align: inherit;">¬°Eso es todo! </font><font style="vertical-align: inherit;">Aqu√≠ se puede hacer mucho m√°s, pero me parece que he logrado la calidad visual que necesito, conservando la relativa simplicidad del ejemplo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaciones</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, enumerar√© brevemente algunas posibles optimizaciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de realizar el marcado de rayos en la direcci√≥n de la fuente de luz, es necesario verificar por el valor de la extinci√≥n de la luz si una cantidad significativa de esta luz realmente alcanza el punto en cuesti√≥n. </font><font style="vertical-align: inherit;">En mi implementaci√≥n, miro el brillo de la luz multiplicado por el albedo del material, y me aseguro de que el valor sea lo suficientemente grande como para realizar el marcado de rayos.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Eso es todo! </font><font style="vertical-align: inherit;">Personalmente, me sorprendi√≥ que pueda crear algo f√≠sicamente correcto en una cantidad de c√≥digo tan peque√±a (aproximadamente 500 l√≠neas). </font><font style="vertical-align: inherit;">Gracias por leer, espero que haya sido interesante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y una nota m√°s: aqu√≠ hay un cambio divertido: agregu√© emisi√≥n de luz en funci√≥n de la distancia SDF para crear un efecto de explosi√≥n. </font><font style="vertical-align: inherit;">Despu√©s de todo, las explosiones nunca son muchas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Captura de pantalla de ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es500896/index.html">¬øQu√© ver en cuarentena? Una selecci√≥n de materiales de Technostream (parte 3)</a></li>
<li><a href="../es500898/index.html">Crazy Moon SpaceX Plan? Evaluaci√≥n del programa por U / S_Hirangy (reddit)</a></li>
<li><a href="../es500902/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 343 (27 de abril - 3 de mayo)</a></li>
<li><a href="../es500904/index.html">Qui√©n es qui√©n en el ecosistema de pagos 2020. Parte 1</a></li>
<li><a href="../es500910/index.html">Sistema de comunicaciones espaciales de largo alcance de China</a></li>
<li><a href="../es500918/index.html">A qu√© prestamos atenci√≥n al calcular la significaci√≥n estad√≠stica de la prueba A / B</a></li>
<li><a href="../es500920/index.html">Antig√ºedades: ZX Spectrum y el antiguo igrozhur</a></li>
<li><a href="../es500922/index.html">Un lobo con piel de cordero: c√≥mo atrapar a un pirata inform√°tico que se disfraza cuidadosamente como un usuario com√∫n</a></li>
<li><a href="../es500924/index.html">Reuni√≥n en l√≠nea JUG.ru "Spring-builder" con Evgeny Borisov</a></li>
<li><a href="../es500926/index.html">La escritura din√°mica no es una herramienta de desarrollo. Esto no tiene sentido (p√©simo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>