<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍞 🏅 🍍 キノポイスクからのレビューの感情的な色分けの分析 🕐 🔫 👩🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 自然言語処理（NLP）は、機械学習の人気があり重要な領域です。このハブでは、Pythonで書かれた映画レビューの感情的な色付けの分析に関連する私の最初のプロジェクトについて説明します。感情分析のタスクは、NLPの基本概念を習得したい人々の間で非常に一般的であり、この領域の「Hello wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>キノポイスクからのレビューの感情的な色分けの分析</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467081/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然言語処理（NLP）は、機械学習の人気があり重要な領域です。</font><font style="vertical-align: inherit;">このハブでは、Pythonで書かれた映画レビューの感情的な色付けの分析に関連する私の最初のプロジェクトについて説明します。</font><font style="vertical-align: inherit;">感情分析のタスクは、NLPの基本概念を習得したい人々の間で非常に一般的であり、この領域の「Hello world」の類似物になることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、データサイエンスプロセスのすべての主要な段階について説明します。独自のデータセットの作成、それの処理、NLTKライブラリを使用した特徴の抽出、最後にscikit-learnを使用したモデルの学習と調整を行います。</font><font style="vertical-align: inherit;">タスク自体は、レビューをネガティブ、ニュートラル、ポジティブの3つのクラスに分類することです。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データコーパスの形成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、IMDBからのフィードバックを含む既製の注釈付きデータ本文を使用できます。その多くはGitHubにあります。しかし、キノポイスクから取られたロシア語のレビューであなた自身のものを作成することになりました。手動でコピーしないように、Webパーサーを作成します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエスト</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリを使用してhttp </font><i><font style="vertical-align: inherit;">リクエスト</font></i><font style="vertical-align: inherit;">を送信し</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeautifulSoup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">htmlファイルを処理します</font><font style="vertical-align: inherit;">。まず、映画のレビューへのリンクを取得して取得する関数を定義します。 Kinopoiskがボットを認識しないようにするには</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">requests.get</font></i><font style="vertical-align: inherit;">関数で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">headers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">指定する必要があります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ブラウザの操作をシミュレートします。</font><font style="vertical-align: inherit;">辞書には、User-Agent、Accept-language、Acceptというキーを使用して辞書を渡す必要があります。これらの値は、ブラウザーの開発者ツールで確認できます。</font><font style="vertical-align: inherit;">次に、パーサーが作成され、レビューがページから取得され、_reachbanner_ htmlマークアップクラスに格納されます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> os<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_data</span>(<span class="hljs-params">url</span>):</span>
    r = requests.get(url, headers = headers) <span class="hljs-comment">#  http </span>
    soup = BeautifulSoup(r.text, <span class="hljs-string">'html.parser'</span>)<span class="hljs-comment">#  html </span>
    reviews = soup.find_all(class_=<span class="hljs-string">'_reachbanner_'</span>)<span class="hljs-comment">#   </span><font></font>
    reviews_clean = []<font></font>
    <span class="hljs-keyword">for</span> review <span class="hljs-keyword">in</span> reviews:<span class="hljs-comment">#    html </span>
        reviews_clean.append(review.find_all(text=<span class="hljs-literal">True</span>))
    <span class="hljs-keyword">return</span> reviews_clean
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTMLマークアップを削除しましたが、レビューはまだ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeautifulSoup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトですが、</font><font style="vertical-align: inherit;">文字列に変換する必要があります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">はまさにそれを行います。</font><font style="vertical-align: inherit;">また、後でレビューを保存するために使用される映画の名前を取得する関数を作成します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span>(<span class="hljs-params">reviews</span>):</span> <span class="hljs-comment">#    </span><font></font>
    review_converted = []<font></font>
    <span class="hljs-keyword">for</span> review <span class="hljs-keyword">in</span> reviews:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> review:<font></font>
            map(str, i)<font></font>
        review = <span class="hljs-string">''</span>.join(review)<font></font>
        review_converted.append(review)<font></font>
    <span class="hljs-keyword">return</span> review_converted
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span>(<span class="hljs-params">url</span>):</span> <span class="hljs-comment">#   </span><font></font>
    r = requests.get(url, headers = headers)<font></font>
    soup = BeautifulSoup(r.text, <span class="hljs-string">'html.parser'</span>)<font></font>
    name = soup.find(class_=<span class="hljs-string">'alternativeHeadline'</span>)<font></font>
    name_clean = name.find_all(text = <span class="hljs-literal">True</span>)
    <span class="hljs-comment">#   , . .    </span>
    <span class="hljs-keyword">return</span> str(name_clean[<span class="hljs-number">0</span>]) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサーの最後の関数は、映画のメインページ、レビュークラス、およびレビューを保存する方法へのリンクを取得します。この関数は</font><font style="vertical-align: inherit;">、禁止を回避するために必要な要求間の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も定義します</font><font style="vertical-align: inherit;">。この関数には、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">load_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">が空のリストを抽出</font><font style="vertical-align: inherit;">して存在しないページが</font><i><font style="vertical-align: inherit;">見つかる</font></i><font style="vertical-align: inherit;">まで、最初のページからレビューを取得して保存するループが含まれて</font><font style="vertical-align: inherit;">おり、ループは中断します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parsing</span>(<span class="hljs-params">url, status, path</span>):</span>
    page = <span class="hljs-number">1</span>
    delays = [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">11.5</span>, <span class="hljs-number">12.5</span>, <span class="hljs-number">13.5</span>, <span class="hljs-number">11.2</span>, <span class="hljs-number">12.3</span>, <span class="hljs-number">11.8</span>]<font></font>
    name = get_name(url)<font></font>
    time.sleep(np.random.choice(delays)) <span class="hljs-comment">#   </span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        loaded_data = load_data(url + <span class="hljs-string">'reviews/ord/date/status/{}/perpage/200/page/{}/'</span>.format(status, page))
        <span class="hljs-keyword">if</span> loaded_data == []:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># E     ,   </span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(path + <span class="hljs-string">r'\{}'</span>.format(status)):<font></font>
                os.makedirs(path + <span class="hljs-string">r'\{}'</span>.format(status))<font></font>
            converted_data = convert(loaded_data)<font></font>
            <span class="hljs-comment">#  </span>
            <span class="hljs-keyword">for</span> i, review <span class="hljs-keyword">in</span> enumerate(converted_data):
                <span class="hljs-keyword">with</span> open(path + <span class="hljs-string">r'\{}\{}_{}_{}.txt'</span>.format(status, name, page, i), <span class="hljs-string">'w'</span>, encoding = <span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> output:<font></font>
                    output.write(review)<font></font>
            page += <span class="hljs-number">1</span><font></font>
            time.sleep(np.random.choice(delays))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、次のサイクルを使用して、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストにある映画からレビューを抽出できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">映画のリストは手動で作成する必要があります。</font><font style="vertical-align: inherit;">たとえば、手動で行わないように、映画検索の上位250の映画からリンクを抽出する関数を記述して、映画へのリンクのリストを取得することは可能ですが、15〜20の映画で、クラスごとに数千のレビューの小さなデータセットを形成できます。</font><font style="vertical-align: inherit;">また、禁止された場合、プログラムはパーサーが禁止を通過した後に同じ場所から続行するために停止した映画とクラスを表示します。</font></font><br>
<br>
<pre><code class="python hljs">path = <span class="hljs-comment">#   </span>
urles = <span class="hljs-comment">#   </span>
statuses = [<span class="hljs-string">'good'</span>, <span class="hljs-string">'bad'</span>, <span class="hljs-string">'neutral'</span>]<font></font>
delays = [<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">13</span>, <span class="hljs-number">18</span>, <span class="hljs-number">12.5</span>, <span class="hljs-number">13.5</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12.3</span>, <span class="hljs-number">23</span>]
<span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urles:
    <span class="hljs-keyword">for</span> status <span class="hljs-keyword">in</span> statuses:
        <span class="hljs-keyword">try</span>:<font></font>
            parsing(url = url, status = status, path=path)<font></font>
            print(<span class="hljs-string">'one category done'</span>)<font></font>
            time.sleep(np.random.choice(delays))<font></font>
<span class="hljs-comment">#       AttributeError</span>
        <span class="hljs-keyword">except</span> AttributeError:<font></font>
            print(<span class="hljs-string">' : {}, {}'</span>.format(url, status))
            <span class="hljs-keyword">break</span>
<span class="hljs-comment">#  else  ,     </span>
<span class="hljs-comment">#    ,    </span>
    <span class="hljs-keyword">else</span>:<font></font>
        print(<span class="hljs-string">'one url done'</span>)
        <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">break</span>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予備処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサーを作成し、彼のためにランダムな映画と映画検索からのいくつかの禁止を想起した後、私はフォルダー内のレビューを混合し、トレーニングのために各クラスから900のレビューを選択し、コントロールグループの残りをレビューしました。</font><font style="vertical-align: inherit;">ここで、ハウジングを前処理する、つまり、トークン化して正規化する必要があります。</font><font style="vertical-align: inherit;">トークン化とは、テキストをコンポーネントに分解することを意味します。ここでは単語のバッグの表現を使用するため、この場合は単語に分解します。</font><font style="vertical-align: inherit;">そして、正規化は、単語を小文字に変換し、ストップワードと余分なノイズを取り除き、スタミングや、記号のスペースを減らすのに役立つその他のトリックで構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なライブラリをインポートします。</font></font><br>
 <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隠しテキスト</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> PlaintextCorpusReader
<span class="hljs-keyword">from</span> nltk.stem.snowball <span class="hljs-keyword">import</span> SnowballStemmer
<span class="hljs-keyword">from</span> nltk.probability  <span class="hljs-keyword">import</span> FreqDist
<span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> RegexpTokenizer
<span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> bigrams
<span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> pos_tag
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report, accuracy_score
<span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> MultinomialNB
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV
<span class="hljs-keyword">from</span> sklearn.utils <span class="hljs-keyword">import</span> shuffle
<span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> scipy.sparse <span class="hljs-keyword">import</span> csr_matrix
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、テキストの前処理用にいくつかの小さな関数を定義します。</font><font style="vertical-align: inherit;">最初の1つは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lower_pos_tag</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">、単語のリストを</font><i><font style="vertical-align: inherit;">受け取り、</font></i><font style="vertical-align: inherit;">それらを小文字に変換し、各トークンを品詞を含むタプルに保存します。</font><font style="vertical-align: inherit;">単語の品詞を追加する操作は、品詞（POS）タグ付けと呼ばれ、NLPでエンティティを抽出するためによく使用されます。</font><font style="vertical-align: inherit;">この場合、次の関数で品詞を使用して単語をフィルタリングします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_pos_tag</span>(<span class="hljs-params">words</span>):</span><font></font>
    lower_words = []<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> words:<font></font>
        lower_words.append(i.lower())<font></font>
    pos_words = pos_tag(lower_words, lang=<span class="hljs-string">'rus'</span>)
    <span class="hljs-keyword">return</span> pos_words
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テキストには、モデルに役立たないほど頻繁に検出される多数の単語（いわゆるストップワード）が含まれています。</font><font style="vertical-align: inherit;">基本的に、これらは前置詞、接続詞、代名詞であり、どのクラスリコールが参照しているかを判別することは不可能です。</font><i><font style="vertical-align: inherit;">クリーン</font></i><font style="vertical-align: inherit;">機能</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名詞、形容詞、動詞、副詞のみを残します。モデル自体には必要ないため、品詞は削除されます。また、この関数はスタミングを使用していることにも気づくでしょう。その本質は、単語から接尾辞と接頭辞を削除することです。これにより、記号の次元を減らすことができます。これは、異なる属とケースを持つ単語が同じトークンに削減されるためです。スタミングのより強力な類似物があります-見出し語化、それは単語の最初の形を復元することを可能にします。ただし、スタミングよりも動作が遅く、さらに、NLTKにはロシア語の見出し語がありません。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean</span>(<span class="hljs-params">words</span>):</span>
    stemmer = SnowballStemmer(<span class="hljs-string">"russian"</span>)<font></font>
    cleaned_words = []<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> words:
        <span class="hljs-keyword">if</span> i[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">'S'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'ADV'</span>]:<font></font>
            cleaned_words.append(stemmer.stem(i[<span class="hljs-number">0</span>]))
    <span class="hljs-keyword">return</span> cleaned_words
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、クラスラベルを取得し、このクラスですべてのレビューを取得する最終的な関数を記述します。ケースを読み取るには、</font><i><font style="vertical-align: inherit;">PlaintextCorpusReader</font></i><font style="vertical-align: inherit;">オブジェクトの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを使用し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。これにより、指定したファイルからテキストを抽出できます。次に、正規化に基づいて動作するRegexpTokenizerをトークン化に使用します。個々の単語に加えて、隣接するすべての単語の組み合わせであるモデルバイグラムを追加しました。この関数も</font><i><font style="vertical-align: inherit;">FreqDist</font></i><font style="vertical-align: inherit;">オブジェクトを使用します</font><i><font style="vertical-align: inherit;">。</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、単語の出現頻度を返します。</font><font style="vertical-align: inherit;">ここでは、特定のクラスのすべてのレビューに1度だけ現れる単語（ハパクとも呼ばれます）を削除するために使用されます。</font><font style="vertical-align: inherit;">したがって、この関数は、単語の袋として提示されたドキュメントと、特定のクラスのすべての単語のリストを含む辞書を返します。</font></font><br>
<br>
<pre><code class="python hljs">corpus_root = <span class="hljs-comment">#   </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">label</span>):</span>
    <span class="hljs-comment"># Wordmatrix -    </span>
    <span class="hljs-comment"># All words -   </span>
    data = {<span class="hljs-string">'Word_matrix'</span>: [], <span class="hljs-string">'All_words'</span>: []}
    <span class="hljs-comment">#     </span><font></font>
    templist_allwords = []<font></font>
    <span class="hljs-comment">#       </span>
    corpus = PlaintextCorpusReader(corpus_root + <span class="hljs-string">'\\'</span> + label, <span class="hljs-string">'.*'</span>, encoding=<span class="hljs-string">'utf-8'</span>)
    <span class="hljs-comment">#      </span><font></font>
    names = corpus.fileids()<font></font>
    <span class="hljs-comment">#  </span>
    tokenizer = RegexpTokenizer(<span class="hljs-string">r'\w+|[^\w\s]+'</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(names)): <span class="hljs-comment">#  </span><font></font>
        bag_words = tokenizer.tokenize(corpus.raw(names[i]))<font></font>
        lower_words = lower_pos_tag(bag_words)<font></font>
        cleaned_words = clean(lower_words)<font></font>
        finalist = list(bigrams(cleaned_words)) + cleaned_words<font></font>
        data[<span class="hljs-string">'Word_matrix'</span>].append(final_words)<font></font>
        templist_allwords.extend(cleaned_words)<font></font>
    <span class="hljs-comment">#  </span><font></font>
    templistfreq = FreqDist(templist_allwords)<font></font>
    hapaxes = templistfreq.hapaxes()<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> templist_allwords:
        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hapaxes:<font></font>
            data[<span class="hljs-string">'All_words'</span>].append(word)
    <span class="hljs-keyword">return</span> {label: data}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前処理段階が最も長いため、ケースの処理を並列化することは理にかなっています。</font><font style="vertical-align: inherit;">これは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチプロセッシング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールを使用して行うことができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次のプログラムコードでは、異なるクラスの3つのフォルダーを同時に処理する3つのプロセスを開始します。</font><font style="vertical-align: inherit;">次に、結果が1つの辞書に収集されます。</font><font style="vertical-align: inherit;">この前処理は完了です。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    data = {}<font></font>
    labels = [<span class="hljs-string">'neutral'</span>, <span class="hljs-string">'bad'</span>, <span class="hljs-string">'good'</span>]<font></font>
    p = Pool(<span class="hljs-number">3</span>)<font></font>
    result = p.map(process, labels)<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<font></font>
        data.update(i)<font></font>
    p.close()<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケースを前処理した後、クラスラベルごとに、トークン化、正規化、バイグラムで強化されたレビューのリスト、およびこのクラスのすべてのレビューからの単語のリストがある辞書があります。モデルは自然言語を私たちのように認識することができないため、ここでのタスクは、レビューを数値形式で提示することです。これを行うには、一意のトークンで構成される共通の語彙を作成し、それを使用して各レビューをベクトル化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、すべてのクラスのレビューとそのラベルを含むリストを作成します。次に、</font><font style="vertical-align: inherit;">同じ</font><i><font style="vertical-align: inherit;">FreqDistの</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">most_common</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを使用して、各クラスから最も一般的な単語の10,000を取り、共通の語彙を作成します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その結果、約17,000語からなる語彙が得られました。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#     :</span>
<span class="hljs-comment"># [([  ], _)]</span>
labels = [<span class="hljs-string">'neutral'</span>, <span class="hljs-string">'bad'</span>, <span class="hljs-string">'good'</span>]<font></font>
labeled_data = []<font></font>
<span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels:
    <span class="hljs-keyword">for</span> document <span class="hljs-keyword">in</span> data[label][<span class="hljs-string">'Word_matrix'</span>]:<font></font>
        labeled_data.append((document, label))<font></font>
<font></font>
<span class="hljs-comment">#     </span><font></font>
all_words = [] <font></font>
<span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels:<font></font>
    frequency = FreqDist(data[label][<span class="hljs-string">'All_words'</span>]<font></font>
    common_words = frequency.most_common(<span class="hljs-number">10000</span>)<font></font>
    words = [i[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> common_words]<font></font>
    all_words.extend(words)<font></font>
<span class="hljs-comment">#   </span><font></font>
unique_words = list(OrderedDict.fromkeys(all_words))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テキストをベクトル化する方法はいくつかあります。それらの中で最も人気のあるもの：TF-IDF、直接および周波数コーディング。私は周波数コーディングを使用しました。その本質は、各レビューをベクトルとして提示することです。その要素は、語彙からの各単語の出現回数です。で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NLTK</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたがそれらを使用することができ、その修飾子を持っているが、彼らは、より遅い類似体である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、学びscikit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と少ないのオプションがあります。以下は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NLTK</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をコーディングするコードです</font><font style="vertical-align: inherit;">。ただし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scikit-learnの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naive Bayesモデルを使用し</font><font style="vertical-align: inherit;">てレビューをエンコードし、属性を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SciPyの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スパースマトリックスに</font><font style="vertical-align: inherit;">、クラスラベルを別の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列に格納し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#     nltk  :</span>
<span class="hljs-comment"># # [({ : -   },  )]</span><font></font>
prepared_data = []<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> labeled_data:<font></font>
    d = defaultdict(int)<font></font>
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> unique_words:
        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> x[<span class="hljs-number">0</span>]:<font></font>
            d[word] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> x[<span class="hljs-number">0</span>]:<font></font>
            d[word] = <span class="hljs-number">0</span>
    prepared_data.append((d, x[<span class="hljs-number">1</span>]))
<span class="hljs-comment">#     scikit-learn</span>
<span class="hljs-comment">#    </span><font></font>
matrix_vec = csr_matrix((len(labeled_data), len(unique_words)), dtype=np.int8).toarray()<font></font>
<span class="hljs-comment">#    </span>
target = np.zeros(len(labeled_data), <span class="hljs-string">'str'</span>)
<span class="hljs-keyword">for</span> index_doc, document <span class="hljs-keyword">in</span> enumerate(labeled_data):
    <span class="hljs-keyword">for</span> index_word, word <span class="hljs-keyword">in</span> enumerate(unique_words):
        <span class="hljs-comment">#  -    </span>
        matrix_vec[index_doc, index_word] = document[<span class="hljs-number">0</span>].count(word)<font></font>
    target[index_doc] = document[<span class="hljs-number">1</span>]
<span class="hljs-comment">#  </span><font></font>
X, Y = shuffle(matrix_vec, target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットでは、特定のタグが付いたレビューが次々と表示されるため、最初はすべて中立、次にすべてが否定というように、それらを混在させる必要があります。</font><font style="vertical-align: inherit;">これを行うには</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">scikit-learn</font></i><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shuffle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">2つの配列を同時に使用できるため、標識とクラスラベルが異なる配列にある場合に適しています。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルトレーニング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、モデルをトレーニングし、コントロールグループでその精度を確認することが残ります。モデルとして、単純ベイズ分類器のモデルを使用します。で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scikit-学ぶ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ナイーブベイズの3つのモデルは、データの分布に応じて、あります：バイナリ、離散と連続。特徴の分布は離散的であるため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultinomialNB</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を選択します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベイジアン分類器にはハイパーパラメータ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alphaがあります</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはモデルの平滑化を担当します。 Naive Bayesは、特定のクラスに属しているという条件で、すべてのレビューワードの出現の条件付き確率を乗算するために、すべてのクラスに属する各レビューの確率を計算します。ただし、トレーニングデータセットでレビューワードが見つからなかった場合、その条件付き確率はゼロになり、レビューが任意のクラスに属する確率が無効になります。これを回避するために、デフォルトでは、すべての条件付き単語の確率に1が追加されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は1です。ただし、この値は最適ではない場合があります。</font><font style="vertical-align: inherit;">グリッド検索と交差検証を使用</font><font style="vertical-align: inherit;">して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">選択することができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">parameter = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0001</span>]<font></font>
param_grid = {<span class="hljs-string">'alpha'</span>: parameter}<font></font>
grid_search = GridSearchCV(MultinomialNB(), param_grid, cv=<span class="hljs-number">5</span>)<font></font>
grid_search.fit(X, Y)<font></font>
Alpha, best_score = grid_search.best_params_, grid_search.best_score_<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の場合、グリッド炉床はハイパーパラメーターの最適値を0に等しく、0.965の精度で提供します。</font><font style="vertical-align: inherit;">ただし、そのような値は明らかに、コントロールデータセットには最適ではありません。これは、以前にトレーニングセットで見つけられなかった多数の単語が存在するためです。</font><font style="vertical-align: inherit;">参照データセットの場合、このモデルの精度は0.598です。</font><font style="vertical-align: inherit;">ただし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を0.1に</font><font style="vertical-align: inherit;">増やす</font><font style="vertical-align: inherit;">と、トレーニングデータの精度は0.82に低下し、コントロールデータの精度は0.62に向上します。</font><font style="vertical-align: inherit;">最も可能性が高いのは、より大きなデータセットでは、違いがより大きくなることです。</font></font><br>
<br>
<pre><code class="python hljs">model = MultinomialNB(<span class="hljs-number">0.1</span>)<font></font>
model.fit(X, Y)<font></font>
<span class="hljs-comment"># X_control, Y_control   ,   X  Y</span>
<span class="hljs-comment">#       </span><font></font>
predicted = model.predict(X_control)<font></font>
<span class="hljs-comment">#    </span><font></font>
score_test = accuracy_score(Y_control, predicted)<font></font>
<span class="hljs-comment">#  </span><font></font>
report = classification_report(Y_control, predicted)<font></font>
</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルは、語彙を形成するために使用されなかった単語のレビューを予測するために使用する必要があると想定されています。したがって、モデルの品質は、データの制御部分の精度（0.62）によって推定できます。これは、推測するよりも2倍近く優れていますが、精度はまだかなり低くなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分類レポートによると、モデルは中立的な色のレビューで最悪の事態に対処していることは明らかです（正の精度は0.47対0.68、負の精度は0.76）。</font><font style="vertical-align: inherit;">実際、中立的なレビューには、肯定的レビューと否定的レビューの両方に特徴的な言葉が含まれています。</font><font style="vertical-align: inherit;">おそらく、データセットのボリュームを増やすことにより、モデルの精度を向上させることができます。</font><font style="vertical-align: inherit;">また、問題をレビューのポジティブとネガティブのバイナリ分類に減らすことも可能であり、これにより精度も向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読んでくれてありがとう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS自分で練習したい場合は、リンクの下に私のデータセットをダウンロードできます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットへのリンク</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467061/index.html">バビロニア列：建設業における5つのセキュリティ問題</a></li>
<li><a href="../ja467063/index.html">データセンターのディーゼル発電機の燃料監視-それを行う方法とそれがなぜそれほど重要なのですか？</a></li>
<li><a href="../ja467065/index.html">小学生のための物理学におけるオリンピック問題のアーカイブ</a></li>
<li><a href="../ja467073/index.html">「西洋では、40歳未満のアートディレクターはいません。私たちの場合、最大30です。」ITのデザイナーになるのはどうですか</a></li>
<li><a href="../ja467079/index.html">CSSとJavascript Antカルーセル</a></li>
<li><a href="../ja467083/index.html">奇妙なpopcount命令が最新のプロセッサでどのように使用されているか</a></li>
<li><a href="../ja467085/index.html">C、C ++およびDotNet逆コンパイルは、逆の基本です。r0ot-miで逆転するための問題を解決します。パート1</a></li>
<li><a href="../ja467089/index.html">パッチを適用したExim-再度パッチを適用します。1回のリクエストでExim 4.92の新しいリモートコマンド実行</a></li>
<li><a href="../ja467091/index.html">Angular開発者の観点からのSvelteの簡単な紹介</a></li>
<li><a href="../ja467093/index.html">Straceを使用したプログラムのスパイ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>