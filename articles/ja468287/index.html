<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📠 🍯 😲 C＃属性：すべての側面について 💪🏻 😨 🐖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="読者こんにちは。この記事では、すべての側面からの属性について説明します。属性の仕様、意味、定義から、独自の属性を作成して操作し、最後にランタイムに属性を追加して、最も有用で興味深い既存の属性を追加します。C＃の属性のトピックに興味がある場合は、catへようこそ。
 
 
 コンテンツ
 

1. 前...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C＃属性：すべての側面について</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者こんにちは。</font><font style="vertical-align: inherit;">この記事では、すべての側面からの属性について説明します。属性の仕様、意味、定義から、独自の属性を作成して操作し、最後にランタイムに属性を追加して、最も有用で興味深い既存の属性を追加します。</font><font style="vertical-align: inherit;">C＃の属性のトピックに興味がある場合は、catへようこそ。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き </font><font style="vertical-align: inherit;">属性の定義と割り当て</font></font></li>
<li>     .        ,           .      ,     (     )</li>
<li>   ,   </li>
<li>     .     </li>
</ol><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつものように、定義と仕様から始めます。これは、すべてのレベルの属性を理解して理解するのに役立ちます。これは、適切なアプリケーションを見つけるために非常に役立ちます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メタデータを定義することから始めます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタデータ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><abbr title="共通型システム"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTS</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって定義されたタイプを記述および参照するデータです</font><font style="vertical-align: inherit;">。メタデータは、特定のプログラミング言語に依存しない方法で格納されます。したがって、メタデータは、プログラムに関する情報を、それを必要とするツール（コンパイラーとデバッガー、およびプログラム自体）間、および</font></font><abbr title="仮想実行システム"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VES</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間で交換するための一般的なメカニズムを提供します</font><font style="vertical-align: inherit;">。メタデータは、アセンブリマニフェストに含まれています。</font><abbr title="中級言語"><font style="vertical-align: inherit;">IL</font></abbr><font style="vertical-align: inherit;">と共に</font></font><abbr title="ポータブル実行ファイル"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルに</font><font style="vertical-align: inherit;">保存できます</font></font><abbr title="中級言語"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードまたは別のPEファイル。アセンブリマニフェストのみです。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、タイプまたはそのメンバー（または他の言語構造）の特性であり、記述情報が含まれています。</font><font style="vertical-align: inherit;">最も一般的な属性は事前定義されており、メタデータに特定の形式がありますが、カスタム属性をメタデータに追加することもできます。</font><font style="vertical-align: inherit;">属性は可換的です。</font><font style="vertical-align: inherit;">要素に対する宣言の順序は重要ではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（メタデータの）構文の観点から、次の属性があります。</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILで特別な構文を使用します。</font><font style="vertical-align: inherit;">たとえば、キーワードは属性です。</font><font style="vertical-align: inherit;">そしてそれらのために、ILには特別な構文があります。</font><font style="vertical-align: inherit;">それらはかなりたくさんあります;すべてをリストすることは意味がありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般化された構文を使用します。</font><font style="vertical-align: inherit;">これらには、ユーザー属性とライブラリ属性が含まれます。</font></font></li>
<li> .    ,   SecurityAttribute (  ).    .       IL,    xml,    </li>
</ol><br>
<h4></h4><br>
<div class="spoiler"><b class="spoiler_title">  C#     </b><div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span>]<font></font>
[<span class="hljs-meta">Serializable</span>]<font></font>
[<span class="hljs-meta">Obsolete</span>]<font></font>
[<span class="hljs-meta">SecurityPermission(SecurityAction.Assert)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span><font></font>
{<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"> IL</b><div class="spoiler_text"><pre><code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit<font></font>
  AttributeSamples.Sample<font></font>
    extends [System.Runtime]System.Object<font></font>
{<font></font>
  .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor()<font></font>
    = (01 00 00 00 )<font></font>
  .permissionset assert  = {<font></font>
    class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}}<font></font>
<font></font>
  .method public hidebysig specialname rtspecialname instance void<font></font>
    .ctor() cil managed {/*constructor body*/}<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ILでは「明示的」として表されるため、StructLayoutAttributeには特別な構文があります。 ObsoleteAttributeは一般的な構文を使用します-ILでは「.custom」で始まります。セキュリティ属性としてのSecurityPermissionAttributeが「.permissionset assert」に変わりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザー属性は、ユーザー情報をメタデータに追加します。このメカニズムを使用して、コンパイル時にアプリケーション固有の情報を格納し、実行時にアクセスしたり、別のツールで読み取りおよび分析したりできます。任意のユーザー定義型を属性として使用できますが、</font></font><abbr title="共通言語仕様"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLSに</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準拠</font><font style="vertical-align: inherit;">するには、属性がSystem.Attributeから継承する必要があります。</font></font><abbr title="共通言語インフラ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の属性を事前定義し、それらを使用して実行時の動作を制御します。一部の言語は、CTSで直接表現されない言語機能を表す属性を定義します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、属性はメタデータに格納され、メタデータはコンパイル段階で生成されます。</font><font style="vertical-align: inherit;">PEファイルに入力されます（通常は* .dll）。</font><font style="vertical-align: inherit;">したがって、実行時に実行可能ファイルを変更することによってのみ、実行時に属性を追加できます（ただし、自己変更プログラムの時代は長い間ありませんでした）。</font><font style="vertical-align: inherit;">したがって、実行段階では追加できませんが、これは完全に正確ではありません。</font><font style="vertical-align: inherit;">アセンブリを作成し、その中に型を定義すると、実行の段階で新しい型を作成してその上に属性をぶら下げることができます。</font><font style="vertical-align: inherit;">したがって、正式には、実行時に属性を追加できます（例は一番下にあります）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして今、制限について少し</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの理由で、名前とNameAtributeという名前の同じアセンブリに2つの属性がある場合、最初の属性を配置することができなくなります。 [名前]を使用する場合（つまり、サフィックスがない場合）、コンパイラーは不確実であると判断します。 [NameAttribute]を使用する場合、論理的なNameAttributeを配置します。名前を付けるときに想像力が欠けているそのような神秘的な状況には特別な構文があります。接尾辞なしの最初のバージョンを配置するには、属性名[@Name]の前に犬の記号（つまり、[名前]-冗談、必要ありません）を指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタム属性は、カスタム属性以外に追加できます。</font><font style="vertical-align: inherit;">これはメタデータ、つまり </font><font style="vertical-align: inherit;">C＃で属性クラスの上に属性を置くと、メタデータではクラスを参照します。</font><font style="vertical-align: inherit;">ただし、「public」に属性を追加することはできません。</font><font style="vertical-align: inherit;">ただし、アセンブリ、モジュール、クラス、値の型、列挙型、コンストラクター、メソッド、プロパティ、フィールド、イベント、インターフェース、パラメーター、デリゲート、戻り値、または一般化されたパラメーターを使用できます。</font><font style="vertical-align: inherit;">以下の例は、特定の構造に属性を配置する方法の明白な例を示しています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性宣言構文</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Runtime.InteropServices;
<span class="hljs-keyword">using</span> System.Security.Permissions;
<span class="hljs-keyword">using</span> AttributeSamples;<font></font>
<font></font>
[<span class="hljs-meta">assembly:All</span>]<font></font>
[<span class="hljs-meta">module:All</span>]<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">AttributeSamples</span><font></font>
{<font></font>
    [<span class="hljs-meta">AttributeUsage(AttributeTargets.All)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AllAttribute</span> : <span class="hljs-title">Attribute</span><font></font>
    {<font></font>
    }<font></font>
<font></font>
    [<span class="hljs-meta">All</span>] <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Usage</span><font></font>
    {<font></font>
        [<span class="hljs-meta">All</span>] <span class="hljs-comment">//  </span>
        [<span class="hljs-meta">return:All</span>] <span class="hljs-comment">//    </span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> GiveMeInt&lt;[All]T&gt;([All]<span class="hljs-keyword">int</span> param)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> + param;<font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">All</span>] <span class="hljs-comment">//  </span>
        [<span class="hljs-meta">field:All</span>] <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action Event;<font></font>
<font></font>
        [<span class="hljs-meta">All</span>] <span class="hljs-comment">//  </span>
        [<span class="hljs-meta">field: All</span>] <span class="hljs-comment">//      </span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Action { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性には、名前付きと位置の2種類のパラメーターがあります。</font><font style="vertical-align: inherit;">定位置パラメーターには、コンストラクター・パラメーターが含まれます。</font><font style="vertical-align: inherit;">名前付きのものへ-アクセス可能なセッターを持つパブリックプロパティ。</font><font style="vertical-align: inherit;">さらに、これらは単なる正式な名前ではなく、名前の後に属性を角かっこで宣言するときにすべてのパラメーターを示すことができます。</font><font style="vertical-align: inherit;">名前付きのものはオプションです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータのタイプ</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AttrParamsAttribute</span> : <span class="hljs-title">Attribute</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AttrParamsAttribute</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> positional</span>) <span class="hljs-comment">// </span></span><font></font>
    {<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Named { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } <span class="hljs-comment">// </span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">AttrParams(1)</span>]<font></font>
[<span class="hljs-meta">AttrParams(1, Named = 2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AttrParams</span> { }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性の有効なパラメーター（両方のタイプの）は、次のタイプのいずれかである必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool、byte、char、double、float、int、long、short、string、さらに10進数を除くプリミティブ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムタイプ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙型</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のタイプのいずれかの1次元配列</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは主に、それがコンパイル時の定数でなければならないという事実によるものであり、上記の型はこの定数を受け入れることができます（intを渡すことができるオブジェクトを受け入れることにより）。ただし、論理的な観点からは可能ですが、何らかの理由で、引数をValueType型にすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタム属性に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、元のユーザー属性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（正規のカスタム属性）と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">疑似ユーザー（疑似カスタム）の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2種類があります</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは同じに見えますが（角括弧内の言語構造の上に示されています）、処理方法は異なります。</font></font><br>
<br>
<ol>
<li>      ;     .            ( ,      )</li>
<li>-  ,         .  ,       ,            ,         .       ,             .</li>
</ol><br>
<div class="spoiler"><b class="spoiler_title">-    </b><div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta">Serializable</span>]<font></font>
[<span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomPseudoCustom</span> { }<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
	    <span class="hljs-keyword">var</span> onlyCustom = <span class="hljs-keyword">typeof</span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment">// SerializableAttribute</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのユーザー属性は言語レベルで導入されます。</font><font style="vertical-align: inherit;">これらはランタイムによって格納および返されますが、ランタイムはこれらの属性の意味について何も知りません。</font><font style="vertical-align: inherit;">ただし、すべての疑似ユーザー属性といくつかのカスタム属性は、コンパイラーとCLIにとって特に重要です。</font><font style="vertical-align: inherit;">それでは、次のセクションに進みます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムをサポートする属性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションは参考情報です。ランタイムの使用に関心がない場合は、次のセクションにスクロールできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の表に、疑似ユーザー属性と特別なユーザー属性を示します（CLIまたはコンパイラーは、それらを特別な方法で処理します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑似ユーザー属性（リフレクションでは取得できません）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CLI属性：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AssemblyAlgorithmIDAttribute</font></font></td>
<td>    .   Assembly.HashAlgId</td>
</tr>
<tr>
<td>AssemblyFlagsAttribute</td>
<td>    .   Assembly.Flags</td>
</tr>
<tr>
<td>DllImportAttribute</td>
<td>   ,    .  Method.Flags.PinvokeImpl   ;     ImplMap (  MappingFlags, MemberForwarded, ImportName  ImportScope)</td>
</tr>
<tr>
<td>StructLayoutAttribute</td>
<td>         .   TypeDef.Flags.LayoutMask  .     TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize  ClassLayout.ClassSize</td>
</tr>
<tr>
<td>FieldOffsetAttribute</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照または重要な型のフィールドのバイトオフセットを定義します。</font><font style="vertical-align: inherit;">対応するメソッドのFieldLayout.OffSetの値を設定します。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性なし</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータが[in]引数として渡されることを示します。</font><font style="vertical-align: inherit;">対応するパラメーターのParam.Flags.Inビットを設定します。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータが[out]引数として渡されることを示します。</font><font style="vertical-align: inherit;">対応するパラメーターのParam.Flags.Outビットを設定します。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マーシャラサ属性</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マネージコードとアンマネージコード間でデータをマーシャリングする方法を定義します。</font><font style="vertical-align: inherit;">フィールドのField.Flags.HasFieldMarshalビットを設定します（またはパラメーターのParam.Flags.HasFieldMarshalビット）。</font><font style="vertical-align: inherit;">FieldMarshalテーブルにエントリを追加します（ParentおよびNativeTypeの値を設定します）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodImplAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの実装の詳細を定義します。</font><font style="vertical-align: inherit;">対応するメソッドのMethod.ImplFlagsの値を設定します</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CLS属性-言語はそれらをサポートする必要があります：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AttributeUsageAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性の使用方法を示すために使用されます。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ObsoleteAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテムを使用しないことを示します。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLSCompliantAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテムがCLS準拠として宣言されているかどうかを示します。</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他の興味深い</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadStaticAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム関連の型フィールドを提供します</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConditionalAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイル条件（/ defineで指定）に基づいてメソッドを呼び出されるようにマークします。</font><font style="vertical-align: inherit;">条件が満たされない場合、メソッドは呼び出されません（ILにコンパイルされません）。</font><font style="vertical-align: inherit;">タグを付けることができるのはvoidメソッドのみです。</font><font style="vertical-align: inherit;">そうしないと、コンパイルエラーが発生します。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DecimalConstantAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10進定数値をメタデータに格納します</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DefaultMemberAttribute</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvokeMemberメソッドでデフォルトで使用するクラスのメンバーを定義します。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CompilationRelaxationsAttribute</font></font></td>
<td>,         .        NoStringInterning,         .       </td>
</tr>
<tr>
<td>FlagsAttribute</td>
<td>, ,   enum    </td>
</tr>
<tr>
<td>IndexerNameAttribute</td>
<td> ,        ,     ​​ </td>
</tr>
<tr>
<td>ParamArrayAttribute</td>
<td>,      </td>
</tr>
</tbody></table></div><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェア製品開発の不可欠な部分はデバッグです。また、大規模で複雑なシステムでは、多くの場合、同じメソッドを実行してオブジェクトの状態を監視するのに数十から数百回かかります。同時に、20の時点で、1つのオブジェクトの値を400倍に拡張して1つの変数の値を確認し、メソッドを再起動する必要性が具体的に高まっています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より静かで高速なデバッグのために、デバッガの動作を変更する属性を使用できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DebuggerDisplayAttribute</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、タイプまたはそのメンバーがデバッガー変数ウィンドウに表示される方法を示します（だけでなく）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクターへの唯一の引数は、表示形式の文字列です。</font><font style="vertical-align: inherit;">ブレースの間に何があるかが計算されます。</font><font style="vertical-align: inherit;">形式は、ドルを除いた補間された文字列に似ています。</font><font style="vertical-align: inherit;">計算値ではポインターを使用できません。</font><font style="vertical-align: inherit;">ちなみに、オーバーライドされたToStringがある場合、その値はこの属性にあるかのように表示されます。</font><font style="vertical-align: inherit;">ToStringと属性の両方がある場合、値は属性から取得されます。</font></font><br>
<img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DebuggerBrowsableAttribute</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、フィールドまたはプロパティがデバッガー変数ウィンドウに表示される方法を定義します。</font><font style="vertical-align: inherit;">3つのオプションがあるDebuggerBrowsableStateを受け入れます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never-デバッグ中、フィールドはまったく表示されません。</font><font style="vertical-align: inherit;">オブジェクトの階層を展開すると、このフィールドは表示されません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">折りたたみ-フィールドは未解決ですが、展開できます。</font><font style="vertical-align: inherit;">これがデフォルトの動作です。</font></font></li>
<li>RootHidden —    ,  ,    ,  (   )</li>
</ul><br>
<img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DebuggerTypeProxy-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトがデバッガで1日に数百回表示される場合、混乱し、ソースオブジェクトを適切に表示するプロキシオブジェクトの作成に3分かかります。通常、表示するプロキシオブジェクトは内部クラスです。実際には、ターゲットオブジェクトの代わりに表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他の有用な属性</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadStatic-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各スレッドに対して静的変数を独自に作成できる属性。これを行うには、静的フィールドの上に属性を配置します。重要なニュアンスを覚えておくことは価値があります-静的コンストラクターによる初期化は一度だけ実行され、変数は静的コンストラクターが実行するスレッドで変更されます。残りでは、デフォルトのままになります。 （PS。この動作が必要な場合は、ThreadLocalクラスに目を向けることをお勧めします）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジンルームのニュアンスについて少し。</font><font style="vertical-align: inherit;">LinuxとWindowsの両方に、ストリームにローカルなメモリ領域があります（</font><font style="vertical-align: inherit;">それぞれ</font></font><abbr title="スレッドローカルストレージ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><abbr title="スレッド固有のデータ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">ただし、これらの領域自体は非常に小さいです。</font><font style="vertical-align: inherit;">したがって、TLSに配置されるポインターであるThreadLocalInfo構造が作成されます。</font><font style="vertical-align: inherit;">したがって、1つのスロットのみが使用されます。</font><font style="vertical-align: inherit;">構造自体には、Thread、AppDomain、ClrTlsInfoの3つのフィールドがあります。</font><font style="vertical-align: inherit;">最初に興味があります。</font><font style="vertical-align: inherit;">このためにThreadLocalBlockとThreadLocalModuleを使用して、メモリ内のフロースタティックのストレージを編成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法では：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照型-ヒープにあり、ThreadLocalBlockクラスによってサポートされるThreadStaticHandleTableはそれらへのリンクを保持します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体-パッケージ化され、マネージヒープに格納されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ型は、ThreadLocalModuleの一部であるアンマネージメモリの領域に格納されます</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、これについて話しているので、非同期メソッドについて言及する価値があります。</font><font style="vertical-align: inherit;">注意深い読者が気づくかもしれませんが、非同期を使用する場合、継続は必ずしも同じスレッドで実行されるとは限りません（スレッドではなく実行コンテキストに影響を与える可能性があります）。</font><font style="vertical-align: inherit;">したがって、ThreadLocalを使用すると、がらくたになります。</font><font style="vertical-align: inherit;">この場合、AsyncLocalを使用することをお勧めします。</font><font style="vertical-align: inherit;">しかし、記事はこれについてではないので、さらに進んだ。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InternalsVisibleTo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internalと</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マークされた要素に表示されるアセンブリを指定できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一部のアセンブリが特定のタイプとそのメンバーを必要とする場合は、単にそれらを</font><i><font style="vertical-align: inherit;">パブリックとして</font></i><font style="vertical-align: inherit;">マークできる</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蒸しません。しかし、優れたアーキテクチャは、実装の詳細を隠すことを意味します。それにもかかわらず、それらは、たとえばテストプロジェクトなど、一部のインフラストラクチャの事柄に必要になる場合があります。この属性を使用すると、カプセル化と必要なテストカバレッジの割合の両方をサポートできます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandleProcessCorruptedStateExceptions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-臆病なプログラマを怖がらせ、損傷した状態の例外をキャッチすることができます。</font><font style="vertical-align: inherit;">既定では、このような例外の場合、CLRはトラップしません。</font><font style="vertical-align: inherit;">一般的に、最善の解決策は、アプリケーションをクラッシュさせることです。</font><font style="vertical-align: inherit;">これらは、プロセスメモリが破損していることを示す危険な例外であるため、この属性を使用することは非常に悪い考えです。</font><font style="vertical-align: inherit;">ただし、場合によっては可能です。ローカル開発の場合は、しばらくこの属性を設定すると便利です。</font><font style="vertical-align: inherit;">損傷した状態の例外をキャッチするには、この属性をメソッドの上に置くだけです。</font><font style="vertical-align: inherit;">また、この属性の使用にすでに達している場合は、（いつものように）特定の例外をキャッチすることをお勧めします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DisablePrivateReflection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-アセンブリのすべてのプライベートメンバーをリフレクションに到達できなくします。</font><font style="vertical-align: inherit;">属性はアセンブリに配置されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性を定義する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションが最後だからというだけではありません。</font><font style="vertical-align: inherit;">結局のところ、どのような場合に属性を使用することが有益であるかを理解する最良の方法は、すでに使用されている属性を調べることです。</font><font style="vertical-align: inherit;">自分の属性について考える必要があるとき、正式なルールを言うのは困難です。</font><font style="vertical-align: inherit;">多くの場合、完全に異なるエンティティに共通するタイプ/そのメンバーまたは別の言語構成に関する追加情報として使用されます。</font><font style="vertical-align: inherit;">例として、シリアル化/ ORM /フォーマットなどに使用されるすべての属性 </font><font style="vertical-align: inherit;">これらのメカニズムは完全に異なるタイプに広範囲に適用されるため、対応するメカニズムの開発者には知られていないことが多いため、属性を使用すると、ユーザーがこのメカニズムの宣言情報を提供できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性の使用は、2つの部分に分けることができます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性を作成して使用する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性を取得して処理する</font></font></li>
</ol><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性を作成して使用する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性を作成するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Attribute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から継承するだけで十分</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">この場合、前述の命名スタイルに従うことをお勧めします-属性のクラス名を終了します。</font><font style="vertical-align: inherit;">ただし、このサフィックスを省略しても間違いはありません。</font><font style="vertical-align: inherit;">前述のように、属性には、位置と名前の2種類のパラメーターを指定できます。</font><font style="vertical-align: inherit;">それらのアプリケーションのロジックは、クラスのコンストラクターのプロパティとパラメーターと同じです-適切な「デフォルト」がないオブジェクトを作成するために必要な値は、定位置に配置されます（つまり、コンストラクター）。</font><font style="vertical-align: inherit;">よく使用される合理的にデフォルトにできるものは、名前付きのもの（つまり、プロパティ）に区別されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性を作成する上で重要なのは、その使用場所を制限することです。</font><font style="vertical-align: inherit;">これにはAttributeUsageAttributeが使用されます。</font><font style="vertical-align: inherit;">必須パラメーター（定位置）は、属性が使用される場所（メソッド、アセンブリーなど）を決定するAttributeTargetです。</font><font style="vertical-align: inherit;">オプションの（名前付き）パラメータは次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AllowMultiple-アプリケーションの場所に複数の属性を配置できるかどうかを示します。</font><font style="vertical-align: inherit;">デフォルトではfalse</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inherited-この属性がクラスの継承者（基本クラスに配置する場合）およびオーバーライドされたメソッド（メソッドに配置する場合）に属するかどうかを決定します。</font><font style="vertical-align: inherit;">デフォルトはtrueです。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、ペイロードを使用して属性をロードできます。属性は宣言的な情報です。つまり、属性で定義されているものはすべて、それが関連する構造を記述している必要があります。属性には深いロジックを含めないでください。定義する属性の処理については、それらを処理するだけの特別なサービスが責任を負う必要があります。ただし、属性にロジックが含まれていないという事実は、属性にメソッドが含まれていないことを意味するものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド（関数）も情報であり、構造を記述することもできます。</font><font style="vertical-align: inherit;">また、属性にポリモーフィズムを使用すると、ユーザーがツールで使用される情報と、実行および処理の特定の段階の両方に影響を与えることができる非常に強力で便利なツールを提供できます。</font><font style="vertical-align: inherit;">同時に、クラスを作成したり、依存関係を挿入したり、これらのクラスを作成するインターフェースやコストファクトリ、およびそれらのインターフェースを挿入したりする必要はありません。</font><font style="vertical-align: inherit;">関連する要素の操作の詳細をカプセル化する単一の継承クラスを作成するだけで十分です。</font><font style="vertical-align: inherit;">ただし、原則として、いくつかのプロパティを持つ通常のROSO属性で十分です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性の取得と処理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受け取った属性の処理は特定のケースに依存し、完全に異なる方法で行うことができます。これに役立つ機能やコツを与えるのは難しい。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
属性は、リフレクションを使用して実行時に取得されます。特定の要素から属性を取得するには、さまざまな方法があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべては</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスから</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">発生し</font></a><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。 Assembly、MemberInfo、Module、ParameterInfoなどのタイプによって実装されます。次に、MemberInfoの後継は、Type、EventInfo、FieldInfo、MethodBase、PropertyInfoです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースには3つの機能しかなく、あまり便利ではありません。これらは配列で動作し（属性が1つしかないことがわかっている場合でも）、タイプによってパラメーター化されません（オブジェクトを使用します）。したがって、このインターフェイスの機能に直接アクセスする必要はほとんどありません（カテゴリにしたくないので、私はそれを言ったことはありません）。使いやすくするために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">があります。この</font><font style="vertical-align: inherit;">クラスには、</font><font style="vertical-align: inherit;">キャストや単一の値の選択などの単純な操作を実行するあらゆる種類の拡張メソッドが多数含まれているため、開発者はこのニーズから解放されます。また、これらのメソッドは、継承クラスを無視する最も便利な機能を備えたAttributeクラスで静的として使用できます（非準拠者向け）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用される主な機能は以下のとおりです。</font><font style="vertical-align: inherit;">メソッドを拡張するタイプを示す最初のパラメーターは省略しました。</font><font style="vertical-align: inherit;">また、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool inherit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータが</font><i><font style="vertical-align: inherit;">指定されている</font></i><font style="vertical-align: inherit;">場合は常に、それなしで（デフォルト値は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trueで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">オーバーロードがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このパラメーターは、メソッドの実行時に親クラスまたは基本メソッドの属性を考慮する必要があるかどうかを示します（オーバーライドされたメソッドで使用する場合）。</font><font style="vertical-align: inherit;">属性</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inherit = flaseの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、</font><font style="vertical-align: inherit;">それをtrueに設定しても、基本クラスの属性を考慮するのに役立ちません</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド名</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCustomAttributes &lt;LogAttribute&gt;（ブール継承）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定したタイプの属性の列挙を取得します。</font><font style="vertical-align: inherit;">属性が1の場合、1要素の列挙が返されます</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCustomAttribute &lt;LogAttribute&gt;（ブール継承）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定されたタイプの単一の属性を返します。</font><font style="vertical-align: inherit;">複数ある場合は、</font><i><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchExceptionを</font></i><font style="vertical-align: inherit;">スローし</font><i><font style="vertical-align: inherit;">ます。同じタイプの複数のカスタム属性が</font></i><font style="vertical-align: inherit;">例外を</font><i><font style="vertical-align: inherit;">検出しまし</font></i><font style="vertical-align: inherit;">た</font></font><i><font style="vertical-align: inherit;"></font></i></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCustomAttributes（）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのタイプの属性の列挙を返します</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCustomAttributesData（）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙型CustomAttributeDataを返します。ここには、コンストラクター、パラメーター（名前と位置）、コンストラクター引数を取得できるプロパティがあります。</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsDefined（タイプattrType、ブール継承）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素に対して属性が宣言されている場合はtrueを返し、そうでない場合はfalseを返します</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、私は言及されたすべての関数の作業の小さなデモを見るよう提案します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のメソッドの戻り値</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LogAttribute</span> : <span class="hljs-title">Attribute</span><font></font>
{<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> LogName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerializeAttribute</span> : <span class="hljs-title">Attribute</span><font></font>
{<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> SerializeName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogBase1"</span>)</span>]<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogBase2"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeBase1"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeBase2"</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RandomDomainEntityBase</span><font></font>
{<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogMethod1"</span>)</span>]<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogMethod2"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeMethod1"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeMethod2"</span>)</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VirtualMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<font></font>
}<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogDerived1"</span>)</span>]<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogDerived2"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeDerived1"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeDerived2"</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RandomDomainEntityDerived</span> : <span class="hljs-title">RandomDomainEntityBase</span><font></font>
{<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogOverride1"</span>)</span>]<font></font>
[<span class="hljs-meta">Log(LogName = <span class="hljs-meta-string">"LogOverride2"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeOverride1"</span>)</span>]<font></font>
[<span class="hljs-meta">Serialize(SerializeName = <span class="hljs-meta-string">"SerializeOverride2"</span>)</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VirtualMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<font></font>
}<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
Type derivedType = <span class="hljs-keyword">typeof</span>(RandomDomainEntityDerived);<font></font>
MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string">"VirtualMethod"</span>);<font></font>
<font></font>
<span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found.</span>
<span class="hljs-comment">// overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found.</span>
<span class="hljs-comment">// Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found.</span><font></font>
<font></font>
IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); <span class="hljs-comment">//LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2</span>
IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); <span class="hljs-comment">//  ,    </span>
IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:<span class="hljs-literal">false</span>); <span class="hljs-comment">//LogOverride1 LogOverride2</span>
IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:<span class="hljs-literal">true</span>); <span class="hljs-comment">//LogOverride1 LogOverride2 LogMethod1 LogMethod2</span>
IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:<span class="hljs-literal">false</span>); <span class="hljs-comment">//SerializeOverride1 SerializeOverride2</span>
IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:<span class="hljs-literal">true</span>); <span class="hljs-comment">//SerializeOverride1 SerializeOverride2</span>
Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, <span class="hljs-keyword">typeof</span>(SerializeAttribute), inherit:<span class="hljs-literal">true</span>); <span class="hljs-comment">//SerializeOverride1 SerializeOverride2</span><font></font>
<font></font>
IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); <span class="hljs-comment">//LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2</span>
IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); <span class="hljs-comment">//  ,    </span>
IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(<span class="hljs-literal">false</span>); <span class="hljs-comment">//LogDerived1 LogDerived2</span>
IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(<span class="hljs-literal">true</span>); <span class="hljs-comment">//LogDerived1 LogDerived2 LogBase1 LogBase2</span>
IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(<span class="hljs-literal">false</span>); <span class="hljs-comment">//SerializeDerived1 SerializeDerived2</span>
IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(<span class="hljs-literal">true</span>); <span class="hljs-comment">//SerializeDerived1 SerializeDerived2</span><font></font>
}<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、学術的な関心のために、実行時に属性を定義する例を示します。</font><font style="vertical-align: inherit;">このコードは、最も美しくサポートされているとは主張していません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TypeCreator</span><font></font>
{<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> TypeSignature = <span class="hljs-string">"DynamicType"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> ModuleName = <span class="hljs-string">"DynamicModule"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> AssemblyName = <span class="hljs-string">"DynamicModule"</span>;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> TypeBuilder _typeBuilder = GetTypeBuilder();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> <span class="hljs-title">CreateTypeInstance</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    _typeBuilder.DefineNestedType(<span class="hljs-string">"ClassName"</span>);<font></font>
    CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string">"PropWithAttr"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>[<span class="hljs-number">0</span>]);<font></font>
    Type newType = _typeBuilder.CreateType();<font></font>
    <span class="hljs-keyword">return</span> Activator.CreateInstance(newType);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword">string</span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword">object</span>[] ctorArgs) <span class="hljs-keyword">where</span> T : Attribute<font></font>
{<font></font>
    <span class="hljs-keyword">var</span> attributeCtor = <span class="hljs-keyword">typeof</span>(T).GetConstructor(ctorTypes);<font></font>
    CustomAttributeBuilder caBuilder = <span class="hljs-keyword">new</span> CustomAttributeBuilder(attributeCtor, ctorArgs);<font></font>
    PropertyBuilder newProperty = CreateProperty(propertyName, propertyType);<font></font>
    newProperty.SetCustomAttribute(caBuilder);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> PropertyBuilder <span class="hljs-title">CreateProperty</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> propertyName, Type propertyType</span>)</span><font></font>
{<font></font>
    FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private);<font></font>
    PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal">null</span>);<font></font>
    MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig;<font></font>
    MethodBuilder getter = GenerateGetter();<font></font>
    MethodBuilder setter = GenerateSetter();<font></font>
    propertyBuilder.SetGetMethod(getter);<font></font>
    propertyBuilder.SetSetMethod(setter);<font></font>
    <span class="hljs-keyword">return</span> propertyBuilder;<font></font>
<font></font>
    <span class="hljs-function">MethodBuilder <span class="hljs-title">GenerateGetter</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string">$"get_<span class="hljs-subst">{propertyName}</span>"</span>, getSetAttr, propertyType, Type.EmptyTypes);<font></font>
        ILGenerator getterIl = getMethodBuilder.GetILGenerator();<font></font>
        getterIl.Emit(OpCodes.Ldarg_0);<font></font>
        getterIl.Emit(OpCodes.Ldfld, fieldBuilder);<font></font>
        getterIl.Emit(OpCodes.Ret);<font></font>
        <span class="hljs-keyword">return</span> getMethodBuilder;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">MethodBuilder <span class="hljs-title">GenerateSetter</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string">$"set_<span class="hljs-subst">{propertyName}</span>"</span>, getSetAttr, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> [] { propertyType });<font></font>
        ILGenerator setterIl = setMethodBuilder.GetILGenerator();<font></font>
        setterIl.Emit(OpCodes.Ldarg_0);<font></font>
        setterIl.Emit(OpCodes.Ldarg_1);<font></font>
        setterIl.Emit(OpCodes.Stfld, fieldBuilder);<font></font>
        setterIl.Emit(OpCodes.Ret);<font></font>
        <span class="hljs-keyword">return</span> setMethodBuilder;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TypeBuilder <span class="hljs-title">GetTypeBuilder</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword">new</span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run);<font></font>
    ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName);<font></font>
    TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature,<font></font>
    TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass |<font></font>
    TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">return</span> typeBuilder;<font></font>
}<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">object</span> instance = <span class="hljs-keyword">new</span> TypeCreator().CreateTypeInstance();<font></font>
    IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string">"PropWithAttr"</span>).GetCustomAttributes(); <span class="hljs-comment">// Serializable</span><font></font>
}<font></font>
}<font></font>
</code></pre><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468259/index.html">アムステルダムで開催されるHelm Summit 2019の5つのハイライト</a></li>
<li><a href="../ja468261/index.html">Three.jsの古い雰囲気の新しいゲーム</a></li>
<li><a href="../ja468265/index.html">Делаем из Vim-а конфетку</a></li>
<li><a href="../ja468267/index.html">Alistair Coburnの本にあるUseCase手法の強化</a></li>
<li><a href="../ja468277/index.html">プログラマーの仕事は難しいですか-心理生理学の観点からの視点</a></li>
<li><a href="../ja468289/index.html">AM</a></li>
<li><a href="../ja468291/index.html">マークゴールストンの本「I Can You Hear You Through」の概要</a></li>
<li><a href="../ja468293/index.html">Vive Cosmos-HTCの新しいVRセットのレビュー</a></li>
<li><a href="../ja468295/index.html">50シェードのmatplotlib-マスタープロット（完全なPythonコード付き）</a></li>
<li><a href="../ja468299/index.html">2019年以降に開発者のためにOracleを開発するもの</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>