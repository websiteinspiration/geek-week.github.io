<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📶 🚴 👨🏻‍🔬 2つのヤコズン、またはカサンドラ対HBaseの戦い。Sberbankチームの経験 😈 👨🏻‍⚖️ 👃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="これは冗談でもありません。この図はこれらのデータベースの本質を最も正確に反映しているようです。最終的にはその理由が明らかになります
 
 
 
 。DB-Enginesランキングによると、最も人気のある2つのNoSQL列ベースはCassandra（以下CS）とHBase（HB）です。
 
 
 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>2つのヤコズン、またはカサンドラ対HBaseの戦い。Sberbankチームの経験</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/484096/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは冗談でもありません。この図はこれらのデータベースの本質を最も正確に反映しているようです。最終的にはその理由が明らかになります</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i2/lk/zo/i2lkzo9tq7zpeprcbtgm3-mufk4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。DB-Enginesランキングによると、最も人気のある2つのNoSQL列ベースはCassandra（以下CS）とHBase（HB）です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/su/rd/39/surd39n7bmrbnxgpn0512tnxamm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
運命の意思で、Sberbankのデータ読み込み管理チームは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長い間</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HBと緊密に連携し</font><font style="vertical-align: inherit;">て</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">き</font></a><font style="vertical-align: inherit;">まし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">。この間、私たちはその長所と短所をかなりよく研究し、それを調理する方法を学びました。しかし、CSの形で代替案が常に存在することは、私に疑問を抱かせました。正しい選択をしましたか？また、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">比較</font></a><font style="vertical-align: inherit;">結果</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、DataStaxによって行われた、CSはほぼ圧倒的なスコアでHBを簡単に倒すと述べた。一方、DataStaxは関心のある人物であり、ここでは一言も言うべきではありません。また、テスト条件についての情報が少々恥ずかしかったので、BigData NoSqlの王者を自分で調べることにしました。その結果は非常に興味深いものでした。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、実行したテストの結果に進む前に、環境の構成の基本的な側面を説明する必要があります。実際には、CSはデータ損失許容モードで使用できます。それら。これは、特定のキーのデータを担当するサーバー（ノード）が1つだけの場合で、何らかの理由でサーバーが落ちると、このキーの値は失われます。多くのタスクではこれは重要ではありませんが、銀行セクターではこれは規則というよりは例外です。私たちのケースでは、信頼性の高いストレージのためにデータのコピーをいくつか持つことが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、トリプルレプリケーションモードでのCSの動作モードのみが考慮されました。ケースの作成は、次のパラメーターで実行されました。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> KEYSPACE ks <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">REPLICATION</span> = {<span class="hljs-string">'class'</span> : <span class="hljs-string">'NetworkTopologyStrategy'</span>, <span class="hljs-string">'datacenter1'</span> : <span class="hljs-number">3</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、必要なレベルの一貫性を確保するには2つの方法があります。一般的なルール：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NW + NR&gt; RF </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、書き込み時のノードからの確認の数（NW）と読み取り時のノードからの確認の数（NR）は、レプリケーション係数より大きくなければなりません。この例では、RF = 3であり、次のオプションが適していることを意味します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。2 + 2&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 + 1&gt; 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データをできるだけ確実に保存することが基本的に重要であるため、3 + 1スキームが選択されました。さらに、HBも同様に機能します。そのような比較はより正直になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DataStaxが調査で反対のことをしたことに注意してください。彼らはCSとHBの両方にRF = 1を設定しました（後者の場合、HDFS設定を変更することにより）。</font><font style="vertical-align: inherit;">この場合のCSパフォーマンスへの影響は非常に大きいため、これは非常に重要な側面です。</font><font style="vertical-align: inherit;">たとえば、次の図は、CSにデータをロードするために必要な時間の増加を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/az/r9/fwazr9muypegpgjpyaq4rnagg8u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、次のことがわかります。競合するスレッドがデータを書き込むほど、時間がかかります。</font><font style="vertical-align: inherit;">これは自然なことですが、RF = 3のパフォーマンスの低下が大幅に大きいことが重要です。</font><font style="vertical-align: inherit;">言い換えると、それぞれ5ストリーム（合計20）の4つのテーブルに書き込む場合、RF = 3は約2倍失われます（150秒RF = 3に対してRF = 1の75）。</font><font style="vertical-align: inherit;">しかし、5つのストリーム（合計40）のそれぞれで8つのテーブルにデータをロードすることによって負荷を増やすと、RF = 3の損失はすでに2.7倍になります（138に対して375秒）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれは、DataStaxテストのCSテストを成功させる秘訣かもしれません。なぜなら、私たちのスタンドのHBでは、複製係数を2から3に変更しても効果がなかったためです。それら。ディスクは、HBの構成のボトルネックではありません。ただし、他にも多くの落とし穴があります。HBのバージョンにはわずかなパッチが適用されて不明瞭になり、環境が完全に異なるなどです。また、CSを適切に準備する方法がわからないだけでなく、CSを操作するためのより効果的な方法がいくつかあることも注目に値します。コメントで確認できれば幸いです。しかし、まず最初に。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのテストは、4台のサーバーで構成され、それぞれが構成になっている</font><i><font style="vertical-align: inherit;">Iron</font></i><font style="vertical-align: inherit;"> Clusterで実行されました</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。CPU：Xeon E5-2680 v4 @ 2.40GHz 64スレッド。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスク：12個のSATA HDD</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaバージョン：1.8.0_111</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
CSバージョン：3.11.5</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータcassandra.yml</font></font></b><div class="spoiler_text">num_tokens: 256<br>
hinted_handoff_enabled: true<br>
hinted_handoff_throttle_in_kb: 1024<br>
max_hints_delivery_threads: 2<br>
hints_directory: /data10/cassandra/hints<br>
hints_flush_period_in_ms: 10000<br>
max_hints_file_size_in_mb: 128<br>
batchlog_replay_throttle_in_kb: 1024<br>
authenticator: AllowAllAuthenticator<br>
authorizer: AllowAllAuthorizer<br>
role_manager: CassandraRoleManager<br>
roles_validity_in_ms: 2000<br>
permissions_validity_in_ms: 2000<br>
credentials_validity_in_ms: 2000<br>
partitioner: org.apache.cassandra.dht.Murmur3Partitioner<br>
data_file_directories:<br>
 — /data1/cassandra/data #   dataN —  <br>
 — /data2/cassandra/data<br>
 — /data3/cassandra/data<br>
 — /data4/cassandra/data<br>
 — /data5/cassandra/data<br>
 — /data6/cassandra/data<br>
 — /data7/cassandra/data<br>
 — /data8/cassandra/data<br>
commitlog_directory: /data9/cassandra/commitlog<br>
cdc_enabled: false<br>
disk_failure_policy: stop<br>
commit_failure_policy: stop<br>
prepared_statements_cache_size_mb:<br>
thrift_prepared_statements_cache_size_mb:<br>
key_cache_size_in_mb:<br>
key_cache_save_period: 14400<br>
row_cache_size_in_mb: 0<br>
row_cache_save_period: 0<br>
counter_cache_size_in_mb:<br>
counter_cache_save_period: 7200<br>
saved_caches_directory: /data10/cassandra/saved_caches<br>
commitlog_sync: periodic<br>
commitlog_sync_period_in_ms: 10000<br>
commitlog_segment_size_in_mb: 32<br>
seed_provider:<br>
 — class_name: org.apache.cassandra.locator.SimpleSeedProvider<br>
 parameters:<br>
 — seeds: "*,*"<br>
concurrent_reads: 256 #  64 —   <br>
concurrent_writes: 256 #  64 —   <br>
concurrent_counter_writes: 256 #  64 —   <br>
concurrent_materialized_view_writes: 32<br>
memtable_heap_space_in_mb: 2048 #  16  —  <br>
memtable_allocation_type: heap_buffers<br>
index_summary_capacity_in_mb:<br>
index_summary_resize_interval_in_minutes: 60<br>
trickle_fsync: false<br>
trickle_fsync_interval_in_kb: 10240<br>
storage_port: 7000<br>
ssl_storage_port: 7001<br>
listen_address: *<br>
broadcast_address: *<br>
listen_on_broadcast_address: true<br>
internode_authenticator: org.apache.cassandra.auth.AllowAllInternodeAuthenticator<br>
start_native_transport: true<br>
native_transport_port: 9042<br>
start_rpc: true<br>
rpc_address: *<br>
rpc_port: 9160<br>
rpc_keepalive: true<br>
rpc_server_type: sync<br>
thrift_framed_transport_size_in_mb: 15<br>
incremental_backups: false<br>
snapshot_before_compaction: false<br>
auto_snapshot: true<br>
column_index_size_in_kb: 64<br>
column_index_cache_size_in_kb: 2<br>
concurrent_compactors: 4<br>
compaction_throughput_mb_per_sec: 1600<br>
sstable_preemptive_open_interval_in_mb: 50<br>
read_request_timeout_in_ms: 100000<br>
range_request_timeout_in_ms: 200000<br>
write_request_timeout_in_ms: 40000<br>
counter_write_request_timeout_in_ms: 100000<br>
cas_contention_timeout_in_ms: 20000<br>
truncate_request_timeout_in_ms: 60000<br>
request_timeout_in_ms: 200000<br>
slow_query_log_timeout_in_ms: 500<br>
cross_node_timeout: false<br>
endpoint_snitch: GossipingPropertyFileSnitch<br>
dynamic_snitch_update_interval_in_ms: 100<br>
dynamic_snitch_reset_interval_in_ms: 600000<br>
dynamic_snitch_badness_threshold: 0.1<br>
request_scheduler: org.apache.cassandra.scheduler.NoScheduler<br>
server_encryption_options:<br>
 internode_encryption: none<br>
client_encryption_options:<br>
 enabled: false<br>
internode_compression: dc<br>
inter_dc_tcp_nodelay: false<br>
tracetype_query_ttl: 86400<br>
tracetype_repair_ttl: 604800<br>
enable_user_defined_functions: false<br>
enable_scripted_user_defined_functions: false<br>
windows_timer_interval: 1<br>
transparent_data_encryption_options:<br>
 enabled: false<br>
tombstone_warn_threshold: 1000<br>
tombstone_failure_threshold: 100000<br>
batch_size_warn_threshold_in_kb: 200<br>
batch_size_fail_threshold_in_kb: 250<br>
unlogged_batch_across_partitions_warn_threshold: 10<br>
compaction_large_partition_warning_threshold_mb: 100<br>
gc_warn_threshold_in_ms: 1000<br>
back_pressure_enabled: false<br>
enable_materialized_views: true<br>
enable_sasi_indexes: true<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GC設定：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">### CMS設定</font></font></b><div class="spoiler_text">-XX:+UseParNewGC<br>
-XX:+UseConcMarkSweepGC<br>
-XX:+CMSParallelRemarkEnabled<br>
-XX:SurvivorRatio=8<br>
-XX:MaxTenuringThreshold=1<br>
-XX:CMSInitiatingOccupancyFraction=75<br>
-XX:+UseCMSInitiatingOccupancyOnly<br>
-XX:CMSWaitDuration=10000<br>
-XX:+CMSParallelInitialMarkEnabled<br>
-XX:+CMSEdenChunksRecordAlways<br>
-XX:+CMSClassUnloadingEnabled<br>
<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリjvm.optionsには16Gbが割り当てられていました（32Gbを試しましたが、違いはありませんでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルの作成は次のコマンドで実行されました：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ks.t1 (<span class="hljs-keyword">id</span> <span class="hljs-built_in">bigint</span> PRIMARY <span class="hljs-keyword">KEY</span>, title <span class="hljs-built_in">text</span>) <span class="hljs-keyword">WITH</span> compression = {<span class="hljs-string">'sstable_compression'</span>: <span class="hljs-string">'LZ4Compressor'</span>, <span class="hljs-string">'chunk_length_kb'</span>: <span class="hljs-number">64</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HBバージョン：1.2.0-cdh5.14.2（クラスorg.apache.hadoop.hbase.regionserver.HRegionで、MetricsRegionを除外しました。これにより、RegionServerに1000を超えるリージョンがあるGCにつながりました）</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルト以外のHBaseオプション</font></font></b><div class="spoiler_text">zookeeper.session.timeout: 120000<br>
hbase.rpc.timeout: 2 minute(s)<br>
hbase.client.scanner.timeout.period: 2 minute(s)<br>
hbase.master.handler.count: 10<br>
hbase.regionserver.lease.period, hbase.client.scanner.timeout.period: 2 minute(s)<br>
hbase.regionserver.handler.count: 160<br>
hbase.regionserver.metahandler.count: 30<br>
hbase.regionserver.logroll.period: 4 hour(s)<br>
hbase.regionserver.maxlogs: 200<br>
hbase.hregion.memstore.flush.size: 1 GiB<br>
hbase.hregion.memstore.block.multiplier: 6<br>
hbase.hstore.compactionThreshold: 5<br>
hbase.hstore.blockingStoreFiles: 200<br>
hbase.hregion.majorcompaction: 1 day(s)<br>
HBase Service Advanced Configuration Snippet (Safety Valve) for hbase-site.xml: <br>
hbase.regionserver.wal.codecorg.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec<br>
hbase.master.namespace.init.timeout3600000<br>
hbase.regionserver.optionalcacheflushinterval18000000<br>
hbase.regionserver.thread.compaction.large12<br>
hbase.regionserver.wal.enablecompressiontrue<br>
hbase.hstore.compaction.max.size1073741824<br>
hbase.server.compactchecker.interval.multiplier200<br>
Java Configuration Options for HBase RegionServer: <br>
-XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:ReservedCodeCacheSize=256m<br>
hbase.snapshot.master.timeoutMillis: 2 minute(s)<br>
hbase.snapshot.region.timeout: 2 minute(s)<br>
hbase.snapshot.master.timeout.millis: 2 minute(s)<br>
HBase REST Server Max Log Size: 100 MiB<br>
HBase REST Server Maximum Log File Backups: 5<br>
HBase Thrift Server Max Log Size: 100 MiB<br>
HBase Thrift Server Maximum Log File Backups: 5<br>
Master Max Log Size: 100 MiB<br>
Master Maximum Log File Backups: 5<br>
RegionServer Max Log Size: 100 MiB<br>
RegionServer Maximum Log File Backups: 5<br>
HBase Active Master Detection Window: 4 minute(s)<br>
dfs.client.hedged.read.threadpool.size: 40<br>
dfs.client.hedged.read.threshold.millis: 10 millisecond(s)<br>
hbase.rest.threads.min: 8<br>
hbase.rest.threads.max: 150<br>
Maximum Process File Descriptors: 180000<br>
hbase.thrift.minWorkerThreads: 200<br>
hbase.master.executor.openregion.threads: 30<br>
hbase.master.executor.closeregion.threads: 30<br>
hbase.master.executor.serverops.threads: 60<br>
hbase.regionserver.thread.compaction.small: 6<br>
hbase.ipc.server.read.threadpool.size: 20<br>
Region Mover Threads: 6<br>
Client Java Heap Size in Bytes: 1 GiB<br>
HBase REST Server Default Group: 3 GiB<br>
HBase Thrift Server Default Group: 3 GiB<br>
Java Heap Size of HBase Master in Bytes: 16 GiB<br>
Java Heap Size of HBase RegionServer in Bytes: 32 GiB<br>
<br>
+ZooKeeper<br>
maxClientCnxns: 601<br>
maxSessionTimeout: 120000</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルの作成：</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hbase org.apache.hadoop.hbase.util.RegionSplitter ns：t1 UniformSplit -c 64 -f cf </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
alter 'ns：t1'、{NAME =&gt; 'cf'、DATA_BLOCK_ENCODING =&gt; 'FAST_DIFF'、COMPRESSION =&gt; 'GZ'}</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここで重要な点が1つあります。DataStaxの説明には、HBテーブルの作成に使用されたリージョンの数は示されていませんが、これは大容量のボリュームでは重要です。したがって、テストでは、数値= 64が選択されました。これにより、最大640 GB、つまり中型のテーブル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストの時点では、HBaseには22千のテーブルと67千の領域がありました（これは、上記のパッチでない場合、バージョン1.2.0では致命的です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今度はコードです。</font><font style="vertical-align: inherit;">特定のデータベースにとってどの構成がより有利であるかが明確ではなかったため、テストはさまざまな組み合わせで実行されました。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">一部のテストでは、4つのテーブルに同時に負荷がかかりました（4つのノードすべてが接続に使用されました）。</font><font style="vertical-align: inherit;">他のテストでは、8つの異なるテーブルを使用しました。</font><font style="vertical-align: inherit;">バッチサイズが100の場合もあれば、200の場合もあります（バッチパラメータ-以下のコードを参照）。</font><font style="vertical-align: inherit;">valueのデータサイズは10バイトまたは100バイトです（dataSize）。</font><font style="vertical-align: inherit;">合計で500万件のレコードが書き込まれ、各テーブルで毎回差し引かれました。</font><font style="vertical-align: inherit;">同時に、5つのストリームが各テーブルに書き込まれた/読み取られました（ストリーム番号はthNum）。それぞれが独自のキー範囲を使用しました（カウント= 100万）。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (opType.equals(<span class="hljs-string">"insert"</span>)) {
    <span class="hljs-keyword">for</span> (Long key = count * thNum; key &lt; count * (thNum + <span class="hljs-number">1</span>); key += <span class="hljs-number">0</span>) {<font></font>
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"BEGIN BATCH "</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; batch; i++) {<font></font>
            String value = RandomStringUtils.random(dataSize, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<font></font>
            sb.append(<span class="hljs-string">"INSERT INTO "</span>)<font></font>
                    .append(tableName)<font></font>
                    .append(<span class="hljs-string">"(id, title) "</span>)<font></font>
                    .append(<span class="hljs-string">"VALUES ("</span>)<font></font>
                    .append(key)<font></font>
                    .append(<span class="hljs-string">", '"</span>)<font></font>
                    .append(value)<font></font>
                    .append(<span class="hljs-string">"');"</span>);<font></font>
            key++;<font></font>
        }<font></font>
        sb.append(<span class="hljs-string">"APPLY BATCH;"</span>);
        <span class="hljs-keyword">final</span> String query = sb.toString();<font></font>
        session.execute(query);<font></font>
    }<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">for</span> (Long key = count * thNum; key &lt; count * (thNum + <span class="hljs-number">1</span>); key += <span class="hljs-number">0</span>) {<font></font>
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"SELECT * FROM "</span>).append(tableName).append(<span class="hljs-string">" WHERE id IN ("</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; batch; i++) {<font></font>
            sb = sb.append(key);<font></font>
            <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span> &lt; batch)<font></font>
                sb.append(<span class="hljs-string">","</span>);<font></font>
            key++;<font></font>
        }<font></font>
        sb = sb.append(<span class="hljs-string">");"</span>);
        <span class="hljs-keyword">final</span> String query = sb.toString();<font></font>
        ResultSet rs = session.execute(query);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、HBにも同様の機能が提供されました。</font></font><br>
<br>
<pre><code class="java hljs">Configuration conf = getConf();<font></font>
HTable table = <span class="hljs-keyword">new</span> HTable(conf, keyspace + <span class="hljs-string">":"</span> + tableName);<font></font>
table.setAutoFlush(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<font></font>
List&lt;Get&gt; lGet = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<font></font>
List&lt;Put&gt; lPut = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">byte</span>[] cf = Bytes.toBytes(<span class="hljs-string">"cf"</span>);
<span class="hljs-keyword">byte</span>[] qf = Bytes.toBytes(<span class="hljs-string">"value"</span>);
<span class="hljs-keyword">if</span> (opType.equals(<span class="hljs-string">"insert"</span>)) {
    <span class="hljs-keyword">for</span> (Long key = count * thNum; key &lt; count * (thNum + <span class="hljs-number">1</span>); key += <span class="hljs-number">0</span>) {<font></font>
        lPut.clear();<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; batch; i++) {<font></font>
            Put p = <span class="hljs-keyword">new</span> Put(makeHbaseRowKey(key));<font></font>
            String value = RandomStringUtils.random(dataSize, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<font></font>
            p.addColumn(cf, qf, value.getBytes());<font></font>
            lPut.add(p);<font></font>
            key++;<font></font>
        }<font></font>
        table.put(lPut);<font></font>
        table.flushCommits();<font></font>
    }<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">for</span> (Long key = count * thNum; key &lt; count * (thNum + <span class="hljs-number">1</span>); key += <span class="hljs-number">0</span>) {<font></font>
        lGet.clear();<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; batch; i++) {<font></font>
            Get g = <span class="hljs-keyword">new</span> Get(makeHbaseRowKey(key));<font></font>
            lGet.add(g);<font></font>
            key++;<font></font>
        }<font></font>
        Result[] rs = table.get(lGet);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントはHB内のデータの均一な分散を処理する必要があるため、主なソルティング関数は次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] makeHbaseRowKey(<span class="hljs-keyword">long</span> key) {
    <span class="hljs-keyword">byte</span>[] nonSaltedRowKey = Bytes.toBytes(key);<font></font>
    CRC32 crc32 = <span class="hljs-keyword">new</span> CRC32();<font></font>
    crc32.update(nonSaltedRowKey);<font></font>
    <span class="hljs-keyword">long</span> crc32Value = crc32.getValue();
    <span class="hljs-keyword">byte</span>[] salt = Arrays.copyOfRange(Bytes.toBytes(crc32Value), <span class="hljs-number">5</span>, <span class="hljs-number">7</span>);
    <span class="hljs-keyword">return</span> ArrayUtils.addAll(salt, nonSaltedRowKey);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、最も興味深い部分は結果です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/id/yd/pc/idydpc9plsmulsycf0i-wqy3c3c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフの形式でも同じ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/72/ag/o1/72ago1u2gdnlufjanqwavk5p1jk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。HBの利点は非常に驚くべきものであり、CS設定になんらかのボトルネックがあると疑われています。</font><font style="vertical-align: inherit;">ただし、最も明白なパラメーター（concurrent_writesまたはmemtable_heap_space_in_mbなど）のグーグルとねじれは、加速を与えませんでした。</font><font style="vertical-align: inherit;">同時に、ログはクリーンで、何も誓わないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データはノード間で均等に配置され、すべてのノードの統計はほぼ同じです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、ノードの1つを含むテーブルの統計です</font></font></b><div class="spoiler_text">Keyspace: ks<br>
 Read Count: 9383707<br>
 Read Latency: 0.04287025042448576 ms<br>
 Write Count: 15462012<br>
 Write Latency: 0.1350068438699957 ms<br>
 Pending Flushes: 0<br>
 Table: t1<br>
 SSTable count: 16<br>
 Space used (live): 148.59 MiB<br>
 Space used (total): 148.59 MiB<br>
 Space used by snapshots (total): 0 bytes<br>
 Off heap memory used (total): 5.17 MiB<br>
 SSTable Compression Ratio: 0.5720989576459437<br>
 Number of partitions (estimate): 3970323<br>
 Memtable cell count: 0<br>
 Memtable data size: 0 bytes<br>
 Memtable off heap memory used: 0 bytes<br>
 Memtable switch count: 5<br>
 Local read count: 2346045<br>
 Local read latency: NaN ms<br>
 Local write count: 3865503<br>
 Local write latency: NaN ms<br>
 Pending flushes: 0<br>
 Percent repaired: 0.0<br>
 Bloom filter false positives: 25<br>
 Bloom filter false ratio: 0.00000<br>
 Bloom filter space used: 4.57 MiB<br>
 Bloom filter off heap memory used: 4.57 MiB<br>
 Index summary off heap memory used: 590.02 KiB<br>
 Compression metadata off heap memory used: 19.45 KiB<br>
 Compacted partition minimum bytes: 36<br>
 Compacted partition maximum bytes: 42<br>
 Compacted partition mean bytes: 42<br>
 Average live cells per slice (last five minutes): NaN<br>
 Maximum live cells per slice (last five minutes): 0<br>
 Average tombstones per slice (last five minutes): NaN<br>
 Maximum tombstones per slice (last five minutes): 0<br>
 Dropped Mutations: 0 bytes<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッチのサイズを（1つずつ送信するまで）削減しようとしても効果はなく、悪化しただけです。 CSで得られた結果はDataStaxで得られた結果と類似しているため、これは実際にはCSの最大パフォーマンスである可能性があります-1秒あたり約数十万の操作。さらに、リソースの使用率を見ると、CSがより多くのCPUとディスクを使用していることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/fo/i4/usfoi4-mgkktzlosilmz2ogm7uu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この図は、両方のデータベースのすべてのテストの実行中の使用率を示しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HBの強力な読書の利点について。ここで、両方のデータベースについて、読み取り中のディスク使用率が非常に低いことがわかります（読み取りテストは、各データベースのテストサイクルの最後の部分です（たとえば、CSの15:20から15:40まで）。 HBの場合、理由は明らかです。ほとんどのデータはメモリ、memstore、および一部はブロックキャッシュにキャッシュされています。 CSについては、その配置があまり明確ではありませんが、ディスク使用率も表示されませんが、念のため、row_cache_size_in_mb = 2048キャッシュをオンにして、キャッシング= {'keys'： 'ALL'、 'rows_per_partition'： 'を設定しようとしました2,000,000 '}、しかしそれはそれをさらに悪化させました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、HBの地域の数について重要なポイントを述べることもまた価値があります。この例では64の値が示されていましたが、これを減らして、たとえば4にすると、読み取り時の速度が2倍低下します。その理由は、memstoreはより速く詰まり、ファイルはより頻繁にフラッシュし、読み取り時にはより多くのファイルを処理する必要があるためです。これはHBにとってかなり複雑な操作です。実際の状況では、これは事前分割とコンパクト化の戦略を検討することで処理できます。特に、バックグラウンドでガベージを収集し、HFileを常に圧縮する自作のユーティリティを使用します。 DataStaxテストでは、通常、テーブルごとに1つの領域が割り当てられましたが（これは正しくありません）、これにより、HBが読み取りテストでそれほど多くを失った理由がある程度明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これからの予備的な結論は次のとおりです。テスト中に重大なエラーが発生しなかったとすると、Cassandraは粘土の足を持つ巨大なもののようなものです。より正確には、記事の冒頭の写真のように片足でバランスを取っている間、彼女は比較的良い結果を示していますが、同じ条件下で戦うと、彼女は完全に敗北します。同時に、ハードウェアのCPU使用率が低いため、ホストごとに2つのRegionServer HBを設置する方法を学び、生産性を2倍にしました。それら。リソースの使用率を考慮すると、CSの状況はさらに悲惨です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これらのテストは非常に総合的であり、ここで使用されたデータの量は比較的控えめです。テラバイトに切り替えると状況が異なる可能性がありますが、HBでテラバイトをロードできる場合、CSでこれが問題になることがわかりました。これらのボリュームがあっても、OperationTimedOutExceptionをスローすることがよくありますが、応答期待値パラメーターは、デフォルトのパラメーターと比較してすでに数倍に増加しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共同の取り組みにより、CSのボトルネックを見つけて、スピードアップできれば、最終的に最終結果に関する情報を投稿の最後に追加できることを願っています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の推奨事項がCSセットアップに適用されました：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disk_optimization_strategy：回転</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAX_HEAP_SIZE = "32G" </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HEAP_NEWSIZE = "3200M" </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-Xms32G </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-Xmx32G</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-XX：+ UseG1GC </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-XX：G1RSetUpdatingPauseTimePercent = 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-XX：MaxGCPauseMillis = 500 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-XX：InitiatingHeapOccupancyPercent = 70 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-XX：ParallelGCThreads = 32 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-XX：ConcGCThreads = 8</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
OS設定に関しては、取得が困難です（かなり長いプロセスです）サーバーを再起動するなど）、これらの推奨事項は適用されませんでした。</font><font style="vertical-align: inherit;">一方、両方のデータベースは等しい状態にあるため、すべてが公平です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード部分では、テーブルに書き込むすべてのスレッドに対して1つのコネクタが作成されます。</font></font><br>
<pre><code class="java hljs">connector = <span class="hljs-keyword">new</span> CassandraConnector();<font></font>
connector.connect(node, <span class="hljs-keyword">null</span>, CL);<font></font>
session = connector.getSession();<font></font>
session.getCluster().getConfiguration().getSocketOptions().setConnectTimeoutMillis(<span class="hljs-number">120000</span>);<font></font>
KeyspaceRepository sr = <span class="hljs-keyword">new</span> KeyspaceRepository(session);<font></font>
sr.useKeyspace(keyspace);<font></font>
prepared = session.prepare(<span class="hljs-string">"insert into "</span> + tableName + <span class="hljs-string">" (id, title) values (?, ?)"</span>);</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データはバインディングを介して送信されました：</font></font><br>
<pre><code class="java hljs"><span class="hljs-keyword">for</span> (Long key = count * thNum; key &lt; count * (thNum + <span class="hljs-number">1</span>); key++) {<font></font>
    String value = RandomStringUtils.random(dataSize, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<font></font>
    session.execute(prepared.bind(key, value));<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは録音パフォーマンスに大きな影響を与えませんでした。信頼性のために、YCSBツールでロードを起動しましたが、まったく同じ結果が得られました。以下は、1つのスレッドの統計（4つのうち）です</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。2020-01-1814：41：53：180 315秒：10000000操作。 21589.1現在の操作数/秒。 [クリーンアップ：カウント= 100、最大= 2236415、最小= 1、平均= 22356.39、90 = 4、99 = 24、99.9 = 2236415、99.99 = 2236415] [挿入：カウント= 119551、最大= 174463、最小= 273、平均= 2582.71、90 = 3491、99 = 16767、99.9 = 99711、99.99 = 171263] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[全体]、実行時間（ミリ秒）、315539 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[全体]、スループット（ops /秒）、31691.803548848162 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GCS_PS_Scavenge]、カウント、161 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[ TOTAL_GC_TIME_PS_Scavenge]、時間（ミリ秒）、2433 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GC_TIME _％_ PS_Scavenge]、時間（％）、0.7710615803434757 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GCS_PS_MarkSweep]、カウント、0</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GC_TIME_PS_MarkSweep]、時間（ms）、0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GC_TIME _％_ PS_MarkSweep]、時間（％）、0.0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GCs]、カウント、161 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_GC_TIME]、時間（ms）、2433 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[TOTAL_34％、753％、373％、37％、75％75％75％750％750 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT]、オペレーション、10000000 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT]、AverageLatency（us）、3114.2427012 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT]、MinLatency（us）、269 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT]、MaxLatency（us）、609279 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT]、95thPercentileLatency（us）、5007 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT] 、99thPercentileLatency（us）、33439 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[INSERT]、Return = OK、10000000</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここでは、1つのストリームの速度が約32千レコード/秒、4スレッドが機能し、128千であることがわかります。ディスクサブシステムの現在の設定をさらに絞り出すことはできないようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もっとおもしろい読み方について。同志の助言のおかげで、彼は根本的に加速することができました。読み取りは5ストリームではなく100ストリームで実行されました。200に増やしても効果はありませんでした。ビルダーにも追加：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.withLoadBalancingPolicy（新しいTokenAwarePolicy（DCAwareRoundRobinPolicy.builder（）.Build（）））</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として、テストで159 644の演算（5スレッド、4テーブル、100バッチ）を表示する場合、現在：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100スレッド、4テーブル、バッチ= 1（ピース単位）：301 969 ops </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100ストリーム、4テーブル、バッチ= 10：447 608 ops </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100ストリーム、4テーブル、バッチ= 100：625 655 ops </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はバッチの方が優れているため、同様の*テストをHB：</font></font><br>
<img src="https://habrastorage.org/webt/ct/bk/-y/ctbk-yrecbwegasrbpauq6f1vv8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 400スレッドで作業する場合、以前に使用されていたRandomStringUtils関数がCPUを100％ロードしたため、より高速なジェネレーターに置き換えられました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、データをロードする際のスレッド数の増加は、HBパフォーマンスのわずかな増加をもたらします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読書に関しては、ここにいくつかのオプションの結果があります。</font><font style="vertical-align: inherit;">リクエストにより</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x62ash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flushコマンドは読み取り前に実行され、他のいくつかのオプションも比較のために示されています</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Memstore-メモリからの読み取り、つまりディスクにフラッシュする前。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HFile + zip-GZアルゴリズムで圧縮されたファイルからの読み取り。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HFile + upzip-圧縮せずにファイルから読み取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深い機能は注目に値します-小さなファイル（10バイトが書き込まれる「データ」フィールドを参照）は、特に圧縮されている場合、処理が遅くなります。明らかに、これは特定のサイズまでしか可能ではなく、明らかに5 GBのファイルは10 MBより速く処理されませんが、これらのすべてのテストで、さまざまな構成を調査するための耕されたフィールドがまだないことは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、レイテンシなどを測定するために、それぞれ100のHBバッチを処理するためにYCSBコードを修正しました。</font><font style="vertical-align: inherit;">以下は、それぞれ100スレッドのテーブルに書き込んだ4つのコピーの作業結果です。</font><font style="vertical-align: inherit;">次のことが判明しました。</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの操作= 100レコード</font></font></b><div class="spoiler_text">[OVERALL], RunTime(ms), 1165415<br>
[OVERALL], Throughput(ops/sec), 858.06343662987<br>
[TOTAL_GCS_PS_Scavenge], Count, 798<br>
[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 7346<br>
[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.6303334005483026<br>
[TOTAL_GCS_PS_MarkSweep], Count, 1<br>
[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 74<br>
[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.006349669431061038<br>
[TOTAL_GCs], Count, 799<br>
[TOTAL_GC_TIME], Time(ms), 7420<br>
[TOTAL_GC_TIME_%], Time(%), 0.6366830699793635<br>
[INSERT], Operations, 1000000<br>
[INSERT], AverageLatency(us), 115893.891644<br>
[INSERT], MinLatency(us), 14528<br>
[INSERT], MaxLatency(us), 1470463<br>
[INSERT], 95thPercentileLatency(us), 248319<br>
[INSERT], 99thPercentileLatency(us), 445951<br>
[INSERT], Return=OK, 1000000<br>
<br>
20/01/19 13:19:16 INFO client.ConnectionManager$HConnectionImplementation: Closing zookeeper sessionid=0x36f98ad0a4ad8cc<br>
20/01/19 13:19:16 INFO zookeeper.ZooKeeper: Session: 0x36f98ad0a4ad8cc closed<br>
20/01/19 13:19:16 INFO zookeeper.ClientCnxn: EventThread shut down<br>
[OVERALL], RunTime(ms), 1165806<br>
[OVERALL], Throughput(ops/sec), 857.7756504941646<br>
[TOTAL_GCS_PS_Scavenge], Count, 776<br>
[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 7517<br>
[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.6447899564764635<br>
[TOTAL_GCS_PS_MarkSweep], Count, 1<br>
[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 63<br>
[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.005403986598113236<br>
[TOTAL_GCs], Count, 777<br>
[TOTAL_GC_TIME], Time(ms), 7580<br>
[TOTAL_GC_TIME_%], Time(%), 0.6501939430745767<br>
[INSERT], Operations, 1000000<br>
[INSERT], AverageLatency(us), 116042.207936<br>
[INSERT], MinLatency(us), 14056<br>
[INSERT], MaxLatency(us), 1462271<br>
[INSERT], 95thPercentileLatency(us), 250239<br>
[INSERT], 99thPercentileLatency(us), 446719<br>
[INSERT], Return=OK, 1000000<br>
<br>
20/01/19 13:19:16 INFO client.ConnectionManager$HConnectionImplementation: Closing zookeeper sessionid=0x26f98ad07b6d67e<br>
20/01/19 13:19:16 INFO zookeeper.ZooKeeper: Session: 0x26f98ad07b6d67e closed<br>
20/01/19 13:19:16 INFO zookeeper.ClientCnxn: EventThread shut down<br>
[OVERALL], RunTime(ms), 1165999<br>
[OVERALL], Throughput(ops/sec), 857.63366863951<br>
[TOTAL_GCS_PS_Scavenge], Count, 818<br>
[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 7557<br>
[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.6481137633908777<br>
[TOTAL_GCS_PS_MarkSweep], Count, 1<br>
[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 79<br>
[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.006775305982252128<br>
[TOTAL_GCs], Count, 819<br>
[TOTAL_GC_TIME], Time(ms), 7636<br>
[TOTAL_GC_TIME_%], Time(%), 0.6548890693731299<br>
[INSERT], Operations, 1000000<br>
[INSERT], AverageLatency(us), 116172.212864<br>
[INSERT], MinLatency(us), 7952<br>
[INSERT], MaxLatency(us), 1458175<br>
[INSERT], 95thPercentileLatency(us), 250879<br>
[INSERT], 99thPercentileLatency(us), 446463<br>
[INSERT], Return=OK, 1000000<br>
<br>
20/01/19 13:19:17 INFO client.ConnectionManager$HConnectionImplementation: Closing zookeeper sessionid=0x36f98ad0a4ad8cd<br>
20/01/19 13:19:17 INFO zookeeper.ZooKeeper: Session: 0x36f98ad0a4ad8cd closed<br>
20/01/19 13:19:17 INFO zookeeper.ClientCnxn: EventThread shut down<br>
[OVERALL], RunTime(ms), 1166860<br>
[OVERALL], Throughput(ops/sec), 857.000839860823<br>
[TOTAL_GCS_PS_Scavenge], Count, 707<br>
[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 7239<br>
[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.6203829079752499<br>
[TOTAL_GCS_PS_MarkSweep], Count, 1<br>
[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 67<br>
[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0057419056270675145<br>
[TOTAL_GCs], Count, 708<br>
[TOTAL_GC_TIME], Time(ms), 7306<br>
[TOTAL_GC_TIME_%], Time(%), 0.6261248136023173<br>
[INSERT], Operations, 1000000<br>
[INSERT], AverageLatency(us), 116230.849308<br>
[INSERT], MinLatency(us), 7352<br>
[INSERT], MaxLatency(us), 1443839<br>
[INSERT], 95thPercentileLatency(us), 250623<br>
[INSERT], 99thPercentileLatency(us), 447487<br>
[INSERT], Return=OK, 1000000</div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CS AverageLatency（us）のレコードが3114の場合、HB AverageLatency（us）= 1162（1オペレーション= 100レコードであるため、分割する必要があることを思い出してください）であることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、この結論は得られます-特定の条件下で、HBaseの重要な利点があります。</font><font style="vertical-align: inherit;">ただし、SSDとOSの注意深い調整によって状況が根本的に変化することは否定できません。</font><font style="vertical-align: inherit;">また、多くは使用シナリオに依存することを理解する必要があります。4つのテーブルではなく、400を使用してテラバイトで作業すると、力のバランスがまったく異なる方法で発生することが簡単にわかります。</font><font style="vertical-align: inherit;">古典が言ったように：実践は真実の基準です。</font><font style="vertical-align: inherit;">試す必要があります。</font><font style="vertical-align: inherit;">1つには、ScyllaDBを確認することが理にかなっているので、続行するために...</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484084/index.html">1C-Bitrixとその導入の試み</a></li>
<li><a href="../ja484088/index.html">パスワードヒットパレード（リークからの50億までのパスワードの分析）</a></li>
<li><a href="../ja484090/index.html">ロシアのポストデータセンターの新しいITインフラストラクチャ</a></li>
<li><a href="../ja484092/index.html">少し服を着た王子と貴族</a></li>
<li><a href="../ja484094/index.html">DOTSで3人称ゾンビシューターを作成する</a></li>
<li><a href="../ja484100/index.html">Android向けGoogle Maps SDKのインターフェースの操作</a></li>
<li><a href="../ja484108/index.html">Etherblade.netカプセル化装置とネットワークコンポーネントのインポート置換（パート2）</a></li>
<li><a href="../ja484112/index.html">飛行機をハックすることは可能ですか</a></li>
<li><a href="../ja484114/index.html">ポールグラハムのエッセイの143の翻訳の抜粋（184から）</a></li>
<li><a href="../ja484118/index.html">1月32日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>