<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 💽 ⌨️ Algoritmo de compressão de Huffman 📯 👩‍❤️‍👩 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecipando o início do curso, "Algoritmos para desenvolvedores" preparamos para você uma tradução de outro material útil.
 
 
 
 A codificação de Huf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmo de compressão de Huffman</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/497566/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antecipando o início do curso, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Algoritmos para desenvolvedores"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preparamos para você uma tradução de outro material útil.</font></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/u2/bz/ax/u2bzaxiq2huxqrzfavfpesnofvo.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A codificação de Huffman é um algoritmo de compactação de dados que formula a idéia básica da compactação de arquivos. Neste artigo, falaremos sobre codificação de comprimento fixo e variável, códigos decodificados exclusivamente, regras de prefixo e a construção de uma árvore Huffman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabemos que cada caractere é armazenado como uma sequência de 0 e 1 e leva 8 bits. Isso é chamado de codificação de comprimento fixo, porque cada caractere usa o mesmo número fixo de bits para armazenar.</font></font><a name="habracut"></a><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que o texto seja dado. Como podemos reduzir a quantidade de espaço necessária para armazenar um personagem?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A idéia básica é a codificação de comprimento variável. Podemos usar o fato de que alguns caracteres no texto são mais comuns que outros ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veja aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) para desenvolver um algoritmo que representará a mesma sequência de caracteres com menos bits. Ao codificar um comprimento variável, atribuímos um número variável de bits aos caracteres, dependendo da frequência de sua aparência neste texto. Por fim, alguns caracteres podem ocupar apenas 1 bit e outros 2 bits, 3 ou mais. O problema com a codificação de comprimento variável é apenas a decodificação subsequente da sequência. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como, conhecendo a sequência de bits, decodificá-la exclusivamente?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere a string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Possui 8 caracteres e, ao codificar um comprimento fixo, serão necessários 64 bits para armazená-lo. Observe que a frequência dos caracteres </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é 4, 2, 1, 1, respectivamente. Vamos tentar imaginar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab" com</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menos bits, usando o fato de que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é mais comum que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"b"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"b"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é mais comum que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para começar, codificamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“a”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando um bit igual a 0, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“b”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atribuímos um código de dois bits 11 e, usando três bits 100 e 011, codificamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“c”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"D"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, teremos sucesso:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onze</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">011</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codificamos a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> string </font><i><font style="vertical-align: inherit;">"aabacdab"</font></i><font style="vertical-align: inherit;"> como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00110100011011 (0 | 0 | 11 | 0 | 100 | 011 | 0 | 11)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando os códigos apresentados acima. </font><font style="vertical-align: inherit;">No entanto, o principal problema será a decodificação. </font><font style="vertical-align: inherit;">Quando tentamos decodificar a linha </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00110100011011</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , obtemos um resultado ambíguo, pois pode ser representado como:</font></font><br>
<br>
<pre><code class="plaintext hljs">0|011|0|100|011|0|11    adacdab<font></font>
0|0|11|0|100|0|11|011   aabacabd<font></font>
0|011|0|100|0|11|0|11   adacabab <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar essa ambiguidade, precisamos garantir que nossa codificação satisfaça um conceito como uma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regra de prefixo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que implica que os códigos podem ser decodificados de uma única maneira. Uma regra de prefixo garante que nenhum código seja um prefixo de outro. Por código, queremos dizer bits usados ​​para representar um caractere específico. No exemplo acima, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o prefixo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">011</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que viola a regra do prefixo. Portanto, se nossos códigos atenderem à regra do prefixo, poderemos decodificar exclusivamente (e vice-versa). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos revisar o exemplo acima. Desta vez, atribuiremos os caracteres </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Códigos que atendem à regra de prefixo.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando essa codificação, a cadeia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“aabacdab”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> será codificada como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00100100011010 (0 | 0 | 10 | 0 | 100 | 011 | 0 | 10)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E aqui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00100100011010</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podemos decodificar e retornar exclusivamente à nossa linha original </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codificação de Huffman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que descobrimos a codificação de comprimento variável e uma regra de prefixo, vamos falar sobre a codificação de Huffman. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O método é baseado na criação de árvores binárias. Nele, um nó pode ser finito ou interno. Inicialmente, todos os nós são considerados folhas (folhas), que representam o próprio símbolo e seu peso (ou seja, a frequência da ocorrência). Nós internos contêm o peso do caractere e se referem a dois nós descendentes. Por concordância geral, o bit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"0"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> representa uma sequência no ramo esquerdo e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"1"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> representa </font><font style="vertical-align: inherit;">à direita. Em uma árvore completa, existem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folhas e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nós internos. Recomenda-se que, ao construir uma árvore Huffman, caracteres não utilizados sejam descartados para obter códigos de tamanho ideal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usaremos a fila de prioridade para construir a árvore Huffman, onde o nó com a menor frequência receberá a maior prioridade. </font><font style="vertical-align: inherit;">As etapas de construção são descritas abaixo:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um nó folha para cada caractere e adicione-os à fila de prioridade.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto estiver na fila por mais de uma planilha, faça o seguinte:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remova os dois nós com a maior prioridade (com a menor frequência) da fila;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um novo nó interno no qual esses dois nós serão herdeiros e a frequência de ocorrência será igual à soma das frequências desses dois nós.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um novo nó à fila de prioridade.</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O único nó restante será a raiz; isso terminará a construção da árvore.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine que temos um texto que consiste apenas nos caracteres </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c", "d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"e"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e as frequências de sua aparência são 15, 7, 6, 6 e 5, respectivamente. Abaixo estão ilustrações que refletem as etapas do algoritmo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/08/nz/g9/08nzg9y-qguo05argcfhzg7dfbo.png"><br>
<br>
<img src="https://habrastorage.org/webt/1t/fb/5l/1tfb5lnkadshv9ckwwbq2w8jm0k.png"><br>
<br>
<img src="https://habrastorage.org/webt/dh/uo/be/dhuobemww5m4uoxswnpndawrfok.png"><br>
<br>
<img src="https://habrastorage.org/webt/i-/9a/we/i-9awedtfaylpuh834b3xwby0pu.png"><br>
<br>
<img src="https://habrastorage.org/webt/vu/1z/us/vu1zusm2bv_1z0qunv7okiv8s5k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O caminho da raiz para qualquer nó final armazenará o código do prefixo ideal (também conhecido como código Huffman) correspondente ao caractere associado a esse nó final. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/cc/vy/qm/ccvyqm21nyslsu41zf-f-ppl9go.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árvore Huffman</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Abaixo, você encontrará a implementação do algoritmo de compactação Huffman em C ++ e Java:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-comment">// A Tree node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
	<span class="hljs-keyword">char</span> ch;
	<span class="hljs-keyword">int</span> freq;<font></font>
	Node *left, *right;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Function to allocate a new tree node</span>
<span class="hljs-function">Node* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq, Node* left, Node* right)</span>
</span>{<font></font>
	Node* node = <span class="hljs-keyword">new</span> Node();<font></font>
<font></font>
	node-&gt;ch = ch;<font></font>
	node-&gt;freq = freq;<font></font>
	node-&gt;left = left;<font></font>
	node-&gt;right = right;<font></font>
<font></font>
	<span class="hljs-keyword">return</span> node;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Comparison object to be used to order the heap</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">comp</span>
{</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node* l, Node* r)</span>
	</span>{
		<span class="hljs-comment">// highest priority item has lowest frequency</span>
		<span class="hljs-keyword">return</span> l-&gt;freq &gt; r-&gt;freq;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
<span class="hljs-comment">// in a map.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node* root, <span class="hljs-built_in">string</span> str,
			<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; &amp;huffmanCode)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
		<span class="hljs-keyword">return</span>;<font></font>
<font></font>
	<span class="hljs-comment">// found a leaf node</span>
	<span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) {<font></font>
		huffmanCode[root-&gt;ch] = str;<font></font>
	}<font></font>
<font></font>
	encode(root-&gt;left, str + <span class="hljs-string">"0"</span>, huffmanCode);<font></font>
	encode(root-&gt;right, str + <span class="hljs-string">"1"</span>, huffmanCode);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// traverse the Huffman Tree and decode the encoded string</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node* root, <span class="hljs-keyword">int</span> &amp;index, <span class="hljs-built_in">string</span> str)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {
		<span class="hljs-keyword">return</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// found a leaf node</span>
	<span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;ch;
		<span class="hljs-keyword">return</span>;<font></font>
	}<font></font>
<font></font>
	index++;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (str[index] ==<span class="hljs-string">'0'</span>)<font></font>
		decode(root-&gt;left, index, str);<font></font>
	<span class="hljs-keyword">else</span><font></font>
		decode(root-&gt;right, index, str);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Builds Huffman Tree and decode given input text</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text)</span>
</span>{
	<span class="hljs-comment">// count frequency of appearance of each character</span>
	<span class="hljs-comment">// and store it in a map</span>
	<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; freq;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: text) {<font></font>
		freq[ch]++;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create a priority queue to store live nodes of</span>
	<span class="hljs-comment">// Huffman tree;</span>
	priority_queue&lt;Node*, <span class="hljs-built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;<font></font>
<font></font>
	<span class="hljs-comment">// Create a leaf node for each character&nbsp;and add it</span>
	<span class="hljs-comment">// to the priority queue.</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: freq) {<font></font>
		pq.push(getNode(pair.first, pair.second, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// do till there is more than one node in the queue</span>
	<span class="hljs-keyword">while</span> (pq.size() != <span class="hljs-number">1</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">// Remove the two nodes of highest priority</span>
		<span class="hljs-comment">// (lowest frequency) from the queue</span><font></font>
		Node *left = pq.top(); pq.pop();<font></font>
		Node *right = pq.top();	pq.pop();<font></font>
<font></font>
		<span class="hljs-comment">// Create a new internal node with these two nodes</span>
		<span class="hljs-comment">// as children and with frequency equal to the sum</span>
		<span class="hljs-comment">// of the two nodes' frequencies. Add the new node</span>
		<span class="hljs-comment">// to the priority queue.</span>
		<span class="hljs-keyword">int</span> sum = left-&gt;freq + right-&gt;freq;<font></font>
		pq.push(getNode(<span class="hljs-string">'\0'</span>, sum, left, right));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// root stores pointer to root of Huffman Tree</span><font></font>
	Node* root = pq.top();<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
	<span class="hljs-comment">// in a map. Also prints them</span>
	<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; huffmanCode;<font></font>
	encode(root, <span class="hljs-string">""</span>, huffmanCode);<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: huffmanCode) {
		<span class="hljs-built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nOriginal string was :\n"</span> &lt;&lt; text &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
	<span class="hljs-comment">// print encoded string</span>
	<span class="hljs-built_in">string</span> str = <span class="hljs-string">""</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: text) {<font></font>
		str += huffmanCode[ch];<font></font>
	}<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree again and this time</span>
	<span class="hljs-comment">// decode the encoded string</span>
	<span class="hljs-keyword">int</span> index = <span class="hljs-number">-1</span>;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nDecoded string is: \n"</span>;
	<span class="hljs-keyword">while</span> (index &lt; (<span class="hljs-keyword">int</span>)str.size() - <span class="hljs-number">2</span>) {<font></font>
		decode(root, index, str);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Huffman coding algorithm</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">string</span> text = <span class="hljs-string">"Huffman coding is a data compression algorithm."</span>;<font></font>
<font></font>
	buildHuffmanTree(text);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.PriorityQueue;<font></font>
<font></font>
<span class="hljs-comment">// A Tree node</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
</span>{
	<span class="hljs-keyword">char</span> ch;
	<span class="hljs-keyword">int</span> freq;<font></font>
	Node left = <span class="hljs-keyword">null</span>, right = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
	Node(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq)<font></font>
	{<font></font>
		<span class="hljs-keyword">this</span>.ch = ch;
		<span class="hljs-keyword">this</span>.freq = freq;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq, Node left, Node right)</span> </span>{
		<span class="hljs-keyword">this</span>.ch = ch;
		<span class="hljs-keyword">this</span>.freq = freq;
		<span class="hljs-keyword">this</span>.left = left;
		<span class="hljs-keyword">this</span>.right = right;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span>
</span>{
	<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
	<span class="hljs-comment">// in a map.</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node root, String str,
							  Map&lt;Character, String&gt; huffmanCode)</span>
	</span>{
		<span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span>;<font></font>
<font></font>
		<span class="hljs-comment">// found a leaf node</span>
		<span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {<font></font>
			huffmanCode.put(root.ch, str);<font></font>
		}<font></font>
<font></font>
<font></font>
		encode(root.left, str + <span class="hljs-string">"0"</span>, huffmanCode);<font></font>
		encode(root.right, str + <span class="hljs-string">"1"</span>, huffmanCode);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree and decode the encoded string</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span> index, StringBuilder sb)</span>
	</span>{
		<span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span> index;<font></font>
<font></font>
		<span class="hljs-comment">// found a leaf node</span>
		<span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)<font></font>
		{<font></font>
			System.out.print(root.ch);<font></font>
			<span class="hljs-keyword">return</span> index;<font></font>
		}<font></font>
<font></font>
		index++;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (sb.charAt(index) == <span class="hljs-string">'0'</span>)<font></font>
			index = decode(root.left, index, sb);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			index = decode(root.right, index, sb);<font></font>
<font></font>
		<span class="hljs-keyword">return</span> index;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Builds Huffman Tree and huffmanCode and decode given input text</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(String text)</span>
	</span>{
		<span class="hljs-comment">// count frequency of appearance of each character</span>
		<span class="hljs-comment">// and store it in a map</span>
		Map&lt;Character, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; text.length(); i++) {
			<span class="hljs-keyword">if</span> (!freq.containsKey(text.charAt(i))) {<font></font>
				freq.put(text.charAt(i), <span class="hljs-number">0</span>);<font></font>
			}<font></font>
			freq.put(text.charAt(i), freq.get(text.charAt(i)) + <span class="hljs-number">1</span>);<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// Create a priority queue to store live nodes of Huffman tree</span>
		<span class="hljs-comment">// Notice that highest priority item has lowest frequency</span>
		PriorityQueue&lt;Node&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<font></font>
										(l, r) -&gt; l.freq - r.freq);<font></font>
<font></font>
		<span class="hljs-comment">// Create a leaf node for each character&nbsp;and add it</span>
		<span class="hljs-comment">// to the priority queue.</span>
		<span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) {<font></font>
			pq.add(<span class="hljs-keyword">new</span> Node(entry.getKey(), entry.getValue()));<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// do till there is more than one node in the queue</span>
		<span class="hljs-keyword">while</span> (pq.size() != <span class="hljs-number">1</span>)<font></font>
		{<font></font>
			<span class="hljs-comment">// Remove the two nodes of highest priority</span>
			<span class="hljs-comment">// (lowest frequency) from the queue</span><font></font>
			Node left = pq.poll();<font></font>
			Node right = pq.poll();<font></font>
<font></font>
			<span class="hljs-comment">// Create a new internal node with these two nodes as children </span>
			<span class="hljs-comment">// and with frequency equal to the sum of the two nodes</span>
			<span class="hljs-comment">// frequencies. Add the new node to the priority queue.</span>
			<span class="hljs-keyword">int</span> sum = left.freq + right.freq;<font></font>
			pq.add(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'\0'</span>, sum, left, right));<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// root stores pointer to root of Huffman Tree</span><font></font>
		Node root = pq.peek();<font></font>
<font></font>
		<span class="hljs-comment">// traverse the Huffman tree and store the Huffman codes in a map</span>
		Map&lt;Character, String&gt; huffmanCode = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
		encode(root, <span class="hljs-string">""</span>, huffmanCode);<font></font>
<font></font>
		<span class="hljs-comment">// print the Huffman codes</span>
		System.out.println(<span class="hljs-string">"Huffman Codes are :\n"</span>);
		<span class="hljs-keyword">for</span> (Map.Entry&lt;Character, String&gt; entry : huffmanCode.entrySet()) {<font></font>
			System.out.println(entry.getKey() + <span class="hljs-string">" "</span> + entry.getValue());<font></font>
		}<font></font>
<font></font>
		System.out.println(<span class="hljs-string">"\nOriginal string was :\n"</span> + text);<font></font>
<font></font>
		<span class="hljs-comment">// print encoded string</span>
		StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; text.length(); i++) {<font></font>
			sb.append(huffmanCode.get(text.charAt(i)));<font></font>
		}<font></font>
<font></font>
		System.out.println(<span class="hljs-string">"\nEncoded string is :\n"</span> + sb);<font></font>
<font></font>
		<span class="hljs-comment">// traverse the Huffman Tree again and this time</span>
		<span class="hljs-comment">// decode the encoded string</span>
		<span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;<font></font>
		System.out.println(<span class="hljs-string">"\nDecoded string is: \n"</span>);
		<span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">2</span>) {<font></font>
			index = decode(root, index, sb);<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>
	</span>{<font></font>
		String text = <span class="hljs-string">"Huffman coding is a data compression algorithm."</span>;<font></font>
<font></font>
		buildHuffmanTree(text);<font></font>
	}<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memória usada pela sequência de entrada é 47 * 8 = 376 bits, e a sequência codificada leva apenas 194 bits, ou seja, </font><font style="vertical-align: inherit;">os dados são compactados em cerca de 48%. </font><font style="vertical-align: inherit;">No programa C ++ acima, usamos a classe string para armazenar a string codificada para tornar o programa legível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como estruturas de dados efetivas da fila de prioridade exigem tempo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log (N))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para serem inseridas, e em uma árvore binária completa com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folhas existem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nós, e a árvore Huffman é uma árvore binária completa, o algoritmo funciona para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (Nlog (N ))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hora, onde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o número de caracteres.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fontes:</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">en.wikipedia.org/wiki/Huffman_coding</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">en.wikipedia.org/wiki/Variable-length_code</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.youtube.com/watch?v=5wRPin4oxCo</a> <br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .<br>
</a><br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt497554/index.html">IntelliJ IDEA 2020.1: Java 14, análise do fluxo de dados no depurador, o novo modo LightEdit e muito mais</a></li>
<li><a href="../pt497558/index.html">Ensinamos física com uma criança, para que todos se interessem</a></li>
<li><a href="../pt497560/index.html">Como a quarentena afeta o mercado de trabalho em TI</a></li>
<li><a href="../pt497562/index.html">Mitap: fique em casa e GOnline</a></li>
<li><a href="../pt497564/index.html">Dia Local do Hack - Hackathon Online</a></li>
<li><a href="../pt497568/index.html">Como os funcionários da LANIT trabalham em locais remotos na Itália e na Bielorrússia</a></li>
<li><a href="../pt497570/index.html">Bancos de dados na plataforma IIoT: como o Mail.ru Cloud Solutions funciona com petabytes de dados de vários dispositivos</a></li>
<li><a href="../pt497572/index.html">Gerenciamento de estado orientado a serviços com lamp-luwak</a></li>
<li><a href="../pt497574/index.html">Oncologia no contexto da pandemia de COVID-19: como salvar vidas máximas</a></li>
<li><a href="../pt497578/index.html">A AMD está comprometida em conquistar uma parcela significativa do mercado de data centers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>