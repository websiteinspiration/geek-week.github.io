<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎍 🧟 🧞 用蚂蚁绘制：使用蚁群优化算法的程序图像 🌆 ⏸️ 🛐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我为什么要画蚂蚁
 我想创作一幅艺术品，探讨软件设计的复杂性。当我提出一个庞大的代码库时，我会想到它的独立产生的复杂性及其相互联系的相互联系的部分。可以说，它的一般形式来自许多个人的行为。
 
 我当时正在考虑如何以图形方式呈现此图像，而在我身上引起反响的图像之一就是蚁群的图像。蚂蚁是新兴（新兴）复...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>用蚂蚁绘制：使用蚁群优化算法的程序图像</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487098/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我为什么要画蚂蚁</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想创作一幅艺术品，探讨软件设计的复杂性。当我提出一个庞大的代码库时，我会想到它的独立产生的复杂性及其相互联系的相互联系的部分。可以说，它的一般形式来自许多个人的行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我当时正在考虑如何以图形方式呈现此图像，而在我身上引起反响的图像之一就是蚁群的图像。蚂蚁是新兴（新兴）复杂性的一个很好的例子。没有一个蚂蚁是建筑师，但是他们共同构建了宏伟的复杂结构。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/4f3/a72/5b14f3a72a15eefbeef534448a51647b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">杀虫剂方案。资料来源：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia Commons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我从寻找有关蚁群模拟的信息开始。显然，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关于此的文献，它是美丽的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是诀窍在于，蚁丘的出现部分取决于它们所在的沙子和地球的物理特性-因为它们的产生取决于当蚂蚁将其放置时粒子的位置。我想在2D中创建某些东西，所以我尝试不编写沙子物理代码而直接进行模拟，也就是说，我不得不放弃蚁丘的物理模拟。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我再次开始搜索，他们将我带到了完全</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的蚂蚁模拟类：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蚁群优化算法（ant Colony algorithm）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
蚁群优化是一种代理算法，用于解决在图形的两个点之间找到最短路径的问题。 “代理”是指算法由单独的过程（在这种情况下为“蚂蚁”）组成，这些过程的紧急行为解决了该问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它的工作非常简单。每个蚂蚁在其路径中都留下一丝“信息素”。蚂蚁离开蚁丘后会留下一种信息素，而当他们找到食物时会留下另一种信息素。寻求食物的蚂蚁试图找到一种“食物”信息素，而那些寻求蚁丘的蚂蚁则寻求一种“家庭”信息素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发现自己走的路较短的蚂蚁可以更快地从家到食物，反之亦然。</font><font style="vertical-align: inherit;">这意味着它们将创建更饱和的信息素层。</font><font style="vertical-align: inherit;">蚂蚁移动的时间越长，轨道越丰富，移动路径越短。</font><font style="vertical-align: inherit;">每个蚂蚁都按照非常简单的规则工作，但是随着时间的流逝，蚂蚁会发现两点之间的最优路径。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模拟</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在Processing 3上编写了我的蚂蚁模拟器。我通过模拟</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gregory Brown的这篇令人惊奇的帖子中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的代码</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">来</font></a><font style="vertical-align: inherit;">开始自己的实现</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
蚂蚁开始移动后，我开始扩展和修改代码，以使其在较大的像素网格中更好地工作。我想获得有趣的外观模拟（不一定</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），这决定了我在代码上的工作。我为蚂蚁创建了一个非常基本的构想，以便每个蚂蚁可以看到前方几个像素。我添加了蚂蚁的死亡和重生，以使它们不会在整个空间中随机散布。最后，我使蚂蚁有些笨拙：即使搜索不成功，它们也会不断离开信息素，这与蚂蚁的真实行为相似。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在浏览器中直接在p5.js上播放模拟端口！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您也可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Github上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">移植的源代码。</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在仿真中最重要的是，我对蚂蚁​​创造的美丽，奇怪和复杂的形状着迷。</font><font style="vertical-align: inherit;">它们不是沿直线前进，而是形成循环，转弯和分支。</font><font style="vertical-align: inherit;">更有趣的是，您可以通过更改蚂蚁世界中的各种变量来控制它们创建的图形的外观。</font><font style="vertical-align: inherit;">例如，您可以更改信息素蒸发速率和蚂蚁的视觉范围（以像素为单位）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">把蚂蚁变成艺术</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模拟开始工作之后，下一步就是研究其输出的数据。我的目标是创建某种二维图像，也就是说，我需要捕获并绘制由蚂蚁创建的图形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我编写了不同类型的输出：几种类型的栅格输出和一个矢量。为了捕获栅格输出，我跟踪了蚂蚁访问过的像元以及它们访问的频率。在使用了此结论的筛选器之后，您可以幽灵地找到蚂蚁去过的那些地方。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/930/8ca/b029308ca64dee625eccbe87749bfc87.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">栅格输出的示例。</font><font style="vertical-align: inherit;">沿着流行的蚂蚁步道和蚂蚁随机在蚂蚁山周围漫游的路径要宽得多。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
栅格输出很有趣，但是我想更清楚地看到各个路径，因此我探索了导出到svg的可能性。</font><font style="vertical-align: inherit;">对于矢量输出，我保存了每只蚂蚁的历史记录，当它们到达食物或蚁丘时，我在列表上写下了这个故事。</font><font style="vertical-align: inherit;">为了进行渲染，我对每个保存的路径进行了采样，并将其渲染为一系列曲线。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/069/397/a81/069397a81dcb254778ab2ce864bab992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量输出的示例。</font><font style="vertical-align: inherit;">在这里，您可以看到蚂蚁的各个路径。</font><font style="vertical-align: inherit;">在有很多蚂蚁的地方，稍微重叠的线形成了更宽的路径。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将点连接</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我知道我想绘制在多个点之间移动的蚂蚁，因此将多个模拟链接到一个图像中的代码是最早的代码之一。但是那我应该画什么呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，我决定创建非常文字的图：从简单的二叉树开始，然后继续进行更复杂的可视化。这似乎是很自然的一步，因为优化蚁群可以解决在图形中查找路径的问题。我还认为这是一种可视化代码复杂性的有趣方式：为什么不采用UML图或依赖图并用蚂蚁渲染它们？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我已经熟悉</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphviz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此决定使用此工具包和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOT图形描述语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定模拟的节点和边缘。</font><font style="vertical-align: inherit;">Graphviz具有输出带有像素坐标注释的DOT文件的模式。</font><font style="vertical-align: inherit;">我编写了一个非常难看的DOT文件解析器，并将其与带注释的DOT文件一起使用，以模拟蚁丘和食物位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用二叉树进行的实验似乎很有希望，并给出了非常自然的有机外观。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/971/59e/e53/97159ee533223d92707a989ba83c10c3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个简单的二叉树。</font><font style="vertical-align: inherit;">有人告诉我，这就像血管造影。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/278/845/f30/278845f30db3fab5dc9085c6261130b7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稍复杂的树，已经很深了。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我开始使用各种代码库作为输入来构建更多图形。</font><font style="vertical-align: inherit;">我编写了一些简单的Python脚本：一个将git树转换为DOT文件，另一个将C导入依赖项转换为DOT文件。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d41/699/426/d41699426c3cf2e31c97b2ee429dc34b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
蚂蚁在git对象树中绘制的对象图。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/813/525/30d/81352530da26c9e3cdf334d6909c479e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux内核中文件之间的依赖关系。使用Graphviz图的正方形样式创建节点和边。实际上，没有什么比随机图有趣得多了。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
尽管所有这些图都很有趣并且肯定很复杂，但令我感到失望的是，实际上它们并没有说明构建它们的代码库的一般形式。我对代码可视化进行的试验越多，我越意识到从代码库本身构造一个有趣的图形是一项单独的，更加困难的任务。但是，我喜欢非常大的图的复杂性，后来我又回到了这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的下一个实验是使用简单形式的游戏。我根据线，圆，正弦曲线和其他易于用节点和边线描述的形状创建了图形。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fab/5f3/287/fab5f32876434586bafc780db2d897d9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">段上的点，在段的右侧，这些点彼此靠近。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d5/8e5/ef1/2d58e5ef1de0f74706ee2e47321b94d0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的正弦波频率。</font><font style="vertical-align: inherit;">我想蚂蚁会产生出很好的示波器。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，最简单的三角空间似乎最有趣。</font><font style="vertical-align: inherit;">我生成了许多均匀分布的点（随机地或通过绘制形状），然后使用处理库将这些点转换为Delaunay三角剖分或Voronoi图。</font><font style="vertical-align: inherit;">然后，将所得的肋骨用于模拟蚂蚁，其中每个肋骨表示一个“蚁丘”或“食物”。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由蚂蚁Voronoi图绘制。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这导致出现了复杂的蚂蚁错综复杂的美丽空间，它描述了使我更感兴趣的复杂性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我从另一个角度完成了任务。一位朋友查看了模拟情况，并询问蚂蚁与墙壁碰撞时会发生什么-他们可以避免简单的障碍吗？我的代码已经知道如何将墙作为边界案例处理，因此我只是添加了内墙，然后花了很多时间尝试教蚂蚁如何解决迷宫问题。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/803/088/e74803088c3d09ddb1b2b77902004c72.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蚂蚁试图解决一个简单的迷宫的路径。</font><font style="vertical-align: inherit;">通过注意蚂蚁无法到达的地方，可以看到迷宫的形状。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的想法是，如果蚂蚁可以解决简单的迷宫，那么您可以将它们组合在一起以创建更大的作品。</font><font style="vertical-align: inherit;">我花了很多时间来设置模拟变量，以便蚂蚁可以解决它们，但是我仍然无法让他们稳定地解决迷宫。</font><font style="vertical-align: inherit;">最后，所有这些变成了蚂蚁路径的弯曲，受到迷宫本身形状的限制。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">艺术品完成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这个阶段，我决定退后一步，考虑所有实验的结果。我意识到，最有趣的图像是从半随机点和边缘的大区域中获得的，因此，我决定通过设置模拟以在随机点的Delaunay三角剖分之间绘制线来做出最终决定。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/09f/a33/3b309fa331b59c059e4b722d4e4c7c10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成模拟运行。它包含许多叠加路径，可从这些路径获得模糊点。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最后一个问题是如何将SVG折弯加工成成品。通过实验，我知道我想以某种方式对路径进行排序，以突出显示形状优美的路径。但是完成的模拟过程要花一到两个小时，这就是为什么在每次实验中都难以更改变量的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定编写</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理图，将模拟输出加载到SVG中，然后应用所需的视觉效果。此外，我想使后处理脚本具有交互性，以便可以试验不同的线条粗细和颜色以及排序阈值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我尝试了几种不同的方法来评估应该位于前台和后台的路径。计算了几个不同的因素：线的自交点数，斜率线的交点数以及该线遵循前两个点预测的斜率的可能性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将后处理脚本用于这些估计的不同权重和值的实验，直到获得所需的外观为止。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/8a0/5e7/6ac8a05e7e250a030461dab605e0770f.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前线和背景线的阈值设置。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这一点上，更改每个变量时保存图像很有帮助。当我接近所需的图像时，比较多个较小的变化比一次更改多个因素要容易得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过长时间的设置并进行了少量更改，我从仿真中创建了以下图像：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/a92/940/781a92940d65d658abfd788b7e0a27db.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我放大了对我来说最有趣的区域，并对其进行裁剪以在空白空间和填充空间之间建立良好的平衡。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后一步是如何将图像转换为物理对象的选择。我曾经以40×50厘米的海报进行数字打印，然后尝试（不成功）在彩色纸上打印屏幕。数字印刷的海报看起来很棒，但将来我想将图像复制为图片的一部分。我发现复杂的图纸具有冥想性，我认为通过手动绘制它们可以实现有趣的效果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这个项目上花费的时间比我预期的要多得多，结果比一开始看起来要复杂得多。</font><font style="vertical-align: inherit;">但这是尝试各种计算几何和算法问题的好方法。</font><font style="vertical-align: inherit;">我为复杂性工作编写了数千行代码，这很具有讽刺意味，但是我很高兴它看起来很酷并且可以说明一切。</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487088/index.html">在Arduino上调试GSM规模</a></li>
<li><a href="../zh-CN487090/index.html">Windows优化的新高度</a></li>
<li><a href="../zh-CN487092/index.html">将业务流程建模为ERP系统实施项目的一部分</a></li>
<li><a href="../zh-CN487094/index.html">重新处理从卡夫卡收到的事件</a></li>
<li><a href="../zh-CN487096/index.html">片段。如何简化使用文档的过程</a></li>
<li><a href="../zh-CN487100/index.html">最先进的不可变数据结构</a></li>
<li><a href="../zh-CN487106/index.html">PVS-Studio分析仪RunUO检查</a></li>
<li><a href="../zh-CN487108/index.html">手机游戏玩家资料：MyTracker研究</a></li>
<li><a href="../zh-CN487110/index.html">Slurm SRE。由Booking.com和Google.com的专家进行的完整实验</a></li>
<li><a href="../zh-CN487112/index.html">疯狂边缘：基本圈子</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>