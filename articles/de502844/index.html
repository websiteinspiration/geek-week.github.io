<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆚 👐🏽 👶🏿 [Teil 2/2] Anleitung zu FFmpeg und SDL oder Schreiben eines Videoplayers in weniger als 1000 Zeilen 💀 🙄 🤟🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir veröffentlichen den Rest der Übersetzung des Handbuchs ins Russische, das etwas veraltet ist, aber nicht an Relevanz verloren hat, da dieses Tutor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[Teil 2/2] Anleitung zu FFmpeg und SDL oder Schreiben eines Videoplayers in weniger als 1000 Zeilen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/502844/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/yx/qh/nq/yxqhnqwvdlvzfw22erhmpfzpfba.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir veröffentlichen den Rest der Übersetzung des Handbuchs ins Russische, das etwas veraltet ist, aber nicht an Relevanz verloren hat, da dieses Tutorial hilft, die „Küche“ beim Erstellen von Videoanwendungen mit den Bibliotheken FFmpeg und SDL zu verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und obwohl wir es versucht haben, sind </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwierigkeiten bei der Übersetzung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in einem so umfangreichen Text unvermeidlich </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fehler melden (vorzugsweise in privaten Nachrichten) - gemeinsam werden wir es besser machen.</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 1: Erstellen von Screencaps </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 2: Anzeigen der </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 3: Abspielen von Sound </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 4: Mehrere Themen </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 5: Synchronisieren von Videos</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 6: Audiosynchronisation </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 7: </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachwort </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">suchen </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang 1. Liste der Funktionen </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang 2. Datenstrukturen </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links</font></font></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><br>
<a name="audio"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right">
     EDISON.<br>
<br>
    ,      .<br>
<br>
,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Axxon Next  SureView Immix</a>.<br>
<br>
      ! ;-)</blockquote><br>
<h2> 6:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 5: Videosynchronisation">←</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 7: Suchen">→</a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">  tutorial06.c</b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da wir einen mehr oder weniger anständigen Player haben, auf dem Sie sogar einen Film sehen können, kommen wir jetzt über die Runden. </font><font style="vertical-align: inherit;">Beim letzten Mal haben wir die Synchronisation leicht angesprochen, nämlich die Synchronisation von Ton und Video in dieser Reihenfolge, nicht umgekehrt. </font><font style="vertical-align: inherit;">Wir werden das gleiche Layout wie bei Video erstellen: Erstellen Sie eine interne Videotakt, um zu verfolgen, wie weit der Videostream entfernt ist, und synchronisieren Sie Audio damit. </font><font style="vertical-align: inherit;">Später werden wir noch mehr verallgemeinern - wir synchronisieren Audio und Video mit einer externen Uhr.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung der Videowache</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt möchten wir eine Videouhr erstellen, die der Audiouhr ähnelt, die wir zuletzt hatten: einen internen Wert, der den aktuellen Zeitversatz des aktuell wiedergegebenen Videos zurückgibt. Sie könnten denken, dass es so einfach ist, den Timer mit dem aktuellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS des</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zuletzt angezeigten Frames zu </font><font style="vertical-align: inherit;">aktualisieren </font><font style="vertical-align: inherit;">. Vergessen Sie jedoch nicht, dass die Zeit zwischen Videobildern zu lang sein kann, wenn wir auf das Millisekundenniveau fallen. Daher besteht die Lösung darin, einen anderen Wert zu verfolgen, den Zeitpunkt, zu dem wir die Videotakt auf dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS des</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letzten Frames </font><font style="vertical-align: inherit;">einstellen </font><font style="vertical-align: inherit;">. Somit ist der aktuelle Wert der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videotakt PTS_of_last_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_elapsed_since_PTS_value_was_set</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Diese Lösung ist sehr ähnlich zu dem, was wir mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock gemacht haben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer vollständigen Struktur werden wir also </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double video_current_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t video_current_pts_time einfügen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Uhr wird in der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_refresh_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktualisiert </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* ... */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen Sie nicht, es in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu initialisieren </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt brauchen wir nur noch einen Weg, um die Informationen zu erhalten:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstrahieren von der Uhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber warum zwingen Sie sich, eine Videouhr zu benutzen? </font><font style="vertical-align: inherit;">Sie können noch weiter gehen und unseren Videosynchronisationscode ändern, damit Audio und Video nicht versuchen, sich gegenseitig zu synchronisieren. </font><font style="vertical-align: inherit;">Stellen Sie sich vor, was für ein Durcheinander es sein wird, wenn wir versuchen, dies mit einer Befehlszeilenoption wie in FFplay zu tun. </font><font style="vertical-align: inherit;">Lassen Sie uns also abstrahieren: Wir erstellen eine neue Wrapper-Funktion, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_master_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die Variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_sync_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> überprüft </font><font style="vertical-align: inherit;">und dann </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_video_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder eine andere Uhr </font><b><font style="vertical-align: inherit;">aufruft,</font></b><font style="vertical-align: inherit;"> die sie verwenden könnte. </font><font style="vertical-align: inherit;">Wir können sogar eine Computeruhr verwenden, die wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_external_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nennen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
main() {<font></font>
...<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audio-Synchronisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt der schwierigste Teil: Audio mit der Videotakt synchronisieren. Unsere Strategie besteht darin, zu messen, wo sich das Audio befindet, es mit der Videotakt zu vergleichen und dann herauszufinden, wie viele Samples wir anpassen müssen, dh müssen wir beschleunigen, indem wir die Samples ablegen oder durch Hinzufügen verlangsamen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Mal aus, wenn wir jeden Satz von Audio-Samples verarbeiten, den wir erhalten, um diesen Satz richtig zu reduzieren oder zu erhöhen. Wir möchten jedoch nicht immer synchronisieren, da die Audioverarbeitung viel häufiger erfolgt als die Verarbeitung von Videopaketen. Wir werden also die Mindestanzahl aufeinanderfolgender Aufrufe der Funktion </font><b><font style="vertical-align: inherit;">synchronize_audio</font></b><font style="vertical-align: inherit;"> festlegen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese werden als nicht synchronisiert betrachtet, bevor wir uns die Mühe machen, etwas zu tun. Natürlich bedeutet "Nicht-Synchronisation" wie beim letzten Mal, dass sich die Audio- und die Video-Uhr um einen Betrag unterscheiden, der größer als der Synchronisationsschwellenwert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also werden wir einen Bruchkoeffizienten verwenden, sagen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und jetzt nehmen wir an, wir haben </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sätze von Audio-Samples, die nicht synchron waren. Die Anzahl der Samples, die wir nicht synchronisieren, kann ebenfalls stark variieren. Daher nehmen wir den Durchschnittswert dafür, wie viel jedes von ihnen nicht synchronisiert ist. Zum Beispiel könnte der erste Aufruf zeigen, dass wir 40 ms lang nicht synchronisiert sind, der nächste 50 ms lang und so weiter. Aber wir werden keinen einfachen Mittelwert nehmen, weil die neuesten Werte wichtiger sind als die, die vor ihnen liegen. Wir werden also einen </font><b><font style="vertical-align: inherit;">Bruchkoeffizienten verwenden</font></b><font style="vertical-align: inherit;"> , z. B. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und die Unterschiede wie folgt zusammenfassen: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn wir bereit sind, die durchschnittliche Differenz zu ermitteln, berechnen wir einfach </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avg_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * (1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was zur Hölle geht hier vor? </font><font style="vertical-align: inherit;">Die Gleichung sieht aus wie eine Art Magie. </font><font style="vertical-align: inherit;">Nun, dies ist im Grunde ein gewichteter Durchschnitt, der eine geometrische Reihe als Gewichte verwendet. </font><font style="vertical-align: inherit;">Ich weiß nicht, ob es einen Namen dafür gibt (ich habe sogar auf Wikipedia nachgesehen!), Aber für weitere Informationen hier eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erklärung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder hier: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weightedmean.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht unsere Funktion aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
  <font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size, nb_samples;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);<font></font>
<font></font>
       <span class="hljs-comment">/* Shrinking/expanding buffer code.... */</span><font></font>
<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also ist alles in Ordnung mit uns; </font><font style="vertical-align: inherit;">Wir wissen ungefähr, inwieweit der Ton nicht mit dem Video oder dem, was wir als Uhr verwenden, übereinstimmt. </font><font style="vertical-align: inherit;">Berechnen wir nun, wie viele Beispiele wir hinzufügen oder verwerfen müssen, indem wir diesen Code in den Abschnitt „Reduzieren / Erweitern des Puffercodes“ einfügen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
  wanted_size = samples_size + <font></font>
  ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_st-&gt;codec-&gt;sample_rate) * n);<font></font>
  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX)<font></font>
                             / <span class="hljs-number">100</span>);<font></font>
  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) <font></font>
                             / <span class="hljs-number">100</span>);
  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
    wanted_size = min_size;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
    wanted_size = max_size;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daran, dass </font><b><font style="vertical-align: inherit;">audio_length</font></b><font style="vertical-align: inherit;"> * ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * # </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von Kanal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 2) die Anzahl der Samples in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_length</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekunden von Audio ist. </font><font style="vertical-align: inherit;">Daher entspricht die Anzahl der gewünschten Samples der Anzahl der bereits vorhandenen Samples plus oder minus der Anzahl der Samples, die der Zeitspanne entsprechen, in der der Sound abgespielt wurde. </font><font style="vertical-align: inherit;">Wir werden auch ein Limit festlegen, wie groß oder klein unsere Korrektur sein kann, denn wenn wir unseren Puffer zu stark ändern, wird dies für den Benutzer zu ärgerlich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korrektur der Anzahl der Proben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir den Sound reparieren. </font><font style="vertical-align: inherit;">Möglicherweise haben Sie bemerkt, dass unsere Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Stichprobengröße zurückgibt, die uns dann mitteilt, wie viele Bytes an den Stream gesendet werden sollen. </font><font style="vertical-align: inherit;">Wir müssen also nur die Stichprobengröße auf den gewünschten Wert einstellen. </font><font style="vertical-align: inherit;">Dies reduziert die Stichprobengröße. </font><font style="vertical-align: inherit;">Wenn Sie es jedoch erhöhen müssen, können wir nicht nur die Stichprobengröße erhöhen, da sich keine Daten mehr im Puffer befinden! </font><font style="vertical-align: inherit;">Deshalb müssen wir ein wenig hinzufügen. </font><font style="vertical-align: inherit;">Aber was genau hinzufügen? </font><font style="vertical-align: inherit;">Es wäre dumm zu versuchen, das Audio zu extrapolieren. Verwenden wir also einfach das bereits vorhandene Audio und addieren den Wert des letzten Samples zum Puffer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
  <span class="hljs-comment">/* remove samples */</span><font></font>
  samples_size = wanted_size;<font></font>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
  <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
  <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
  <span class="hljs-comment">/* add samples by copying final samples */</span><font></font>
  nb = (samples_size - wanted_size);<font></font>
  samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
  q = samples_end + n;<font></font>
  <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
    q += n;<font></font>
    nb -= n;<font></font>
  }<font></font>
  samples_size = wanted_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt geben wir die Stichprobengröße zurück und sind mit dieser Funktion fertig. </font><font style="vertical-align: inherit;">Jetzt müssen wir nur noch Folgendes verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben lediglich einen Aufruf von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eingefügt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Überprüfen Sie auch unbedingt den Quellcode, in dem wir die Variablen initialisieren, die ich nicht definiert habe.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die letzte, bevor wir fertig sind: Wir müssen die "if" -Bedingung hinzufügen, um sicherzustellen, dass wir das Video nicht synchronisieren, wenn es die Hauptuhr ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
  ref_clock = get_master_clock(is);<font></font>
  diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
  <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
     FFPlay still doesn't "know if this is the best guess." */</span><font></font>
  sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay :<font></font>
                    AV_SYNC_THRESHOLD;<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
    <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
      delay = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
      delay = <span class="hljs-number">2</span> * delay;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und es funktioniert! </font><font style="vertical-align: inherit;">Stellen Sie sicher, dass Sie die Quelldatei überprüfen, um alle Variablen zu initialisieren, die ich nicht definiert oder initialisiert habe. </font><font style="vertical-align: inherit;">Dann kompilieren Sie:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial06 tutorial06.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und der Flug wird normal sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der letzten Lektion werden wir zurückspulen.</font></font><a name="seeking"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 7: Suche </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 6: Audiosynchronisation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Nachwort"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Auflistung tutorial07.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;
  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
AVPacket flush_pkt;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_ctx);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;seek_req) {
      <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
	seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
				  pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
		       seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
		is-&gt;pFormatCtx-&gt;filename);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;audioq);<font></font>
	  packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;videoq);<font></font>
	  packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
	}<font></font>
      }<font></font>
      is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;
      <span class="hljs-comment">/*
       * If the video has finished playing, then both the picture and
       * audio queues are waiting for more data.  Make them stop
       * waiting and terminate normally.
       */</span><font></font>
      SDL_CondSignal(is-&gt;audioq.cond);<font></font>
      SDL_CondSignal(is-&gt;videoq.cond);<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchbefehlsverarbeitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt werden wir einige Suchfunktionen in unseren Player aufnehmen, da es sehr ärgerlich ist, wenn Sie den Film nicht zurückspulen können. Außerdem werden wir sehen, wie einfach es ist, die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame zu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwenden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Pfeile auf der Tastatur "links" und "rechts" machen, um den Film ein wenig vorwärts und rückwärts zu scrollen, und die Pfeile "hoch" und "runter" sind bereits bedeutender. "Ein wenig" - es sind 10 Sekunden und "viel" - alle 60. Daher müssen wir unsere Hauptschleife so konfigurieren, dass sie Tastenanschlagereignisse abfängt. Tatsache ist jedoch, dass wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame nicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direkt </font><font style="vertical-align: inherit;">aufrufen können, wenn wir einen Tastendruck erhalten </font><font style="vertical-align: inherit;">. Dies muss in unserer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptdecodierungsschleife decode_thread erfolgen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher fügen wir stattdessen der Hauptstruktur einige Werte hinzu, die eine neue Position für die Suche und einige Suchflags enthalten:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir unsere Hauptschleife konfigurieren, die Tastenanschläge abfängt:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, <font></font>
                      (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Tastendruck </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abzufangen, prüfen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir zunächst, ob das Ereignis </font><b><font style="vertical-align: inherit;">SDL_KEYDOWN aufgetreten ist</font></b><font style="vertical-align: inherit;"> . Dann prüfen wir mit </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.key.keysym.sym</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , welcher Schlüssel empfangen </font><nobr><b><font style="vertical-align: inherit;">wird</font></b></nobr><font style="vertical-align: inherit;"> . Sobald wir herausfinden, in welche Richtung wir schauen, berechnen wir eine neue Zeit und fügen dem Wert unserer neuen Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_master_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Inkrement </font><b><font style="vertical-align: inherit;">hinzu</font></b><font style="vertical-align: inherit;"> . Dann rufen wir die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf, um die Werte für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seek_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw. </font><b><font style="vertical-align: inherit;">festzulegen</font></b><font style="vertical-align: inherit;"> . Konvertieren Sie unsere neue Zeit in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interne Zeitstempeleinheiten </font><font style="vertical-align: inherit;">. Denken Sie daran, dass Zeitstempel in Streams nach der folgenden Formel in Frames und nicht in Sekunden gemessen werden: </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekunden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardmäßig ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf 1.000.000 Bilder pro Sekunde eingestellt (eine Position von 2 Sekunden hat also einen Zeitstempel von 2.000.000). Warum müssen wir diesen Wert konvertieren - siehe später. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist unsere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">. Beachten Sie, dass wir das Flag setzen, wenn wir zurückgehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir nun </font><font style="vertical-align: inherit;">
mit unserem </font><b><font style="vertical-align: inherit;">decode_thread fort</font></b><font style="vertical-align: inherit;"> , in dem wir tatsächlich eine Suche durchführen. In den Quelldateien sehen Sie, dass wir den Bereich "Suche läuft" markiert haben. Nun, wir werden es gleich dort platzieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Suche konzentriert sich auf die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Funktion verwendet als Argument den Formatkontext, den Stream, den Zeitstempel und den Flag-Satz. Die Funktion sucht nach dem Zeitstempel, den Sie ihm geben. Die Einheit des Zeitstempels ist die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitbasis des</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streams, den Sie an die Funktion übergeben. Sie müssen es jedoch nicht an den Stream übergeben (angezeigt durch Übergabe des Werts -1). Wenn Sie dies tun, befindet sich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der internen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiteinheit von avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder 1000000fps. Deshalb haben wir unsere Position mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE multipliziert,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seek_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesetzt </font><b><font style="vertical-align: inherit;">haben</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal kann es jedoch (selten) zu Problemen bei einigen Dateien kommen, wenn Sie </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für den Stream </font><font style="vertical-align: inherit;">übergeben. </font><nobr><b><font style="vertical-align: inherit;">Daher</font></b></nobr><font style="vertical-align: inherit;"> wählen wir den ersten Stream in unserer Datei aus und übergeben ihn an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vergessen Sie nicht, dass wir den Maßstab unseres Zeitstempels ändern müssen, um im neuen „Koordinatensystem“ zu sein.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;seek_req) {
  <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
    seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
                      pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
                    seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
            is-&gt;pFormatCtx-&gt;filename);<font></font>
  } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">/* handle packet queues... more later... */</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_rescale_q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ist eine Funktion, die den Zeitstempel von einer Basis zur anderen skaliert. Grundsätzlich wird </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berechnet </font><font style="vertical-align: inherit;">, aber diese Funktion ist praktisch, da diese Berechnung manchmal zu einem Überlauf führt. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilversion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font><b><font style="vertical-align: inherit;">AV_TIME_BASE</font></b><font style="vertical-align: inherit;"> . Sie sind völlig unterschiedlich: </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (beachten </font><b><font style="vertical-align: inherit;">Sie</font></b><font style="vertical-align: inherit;"> jedoch, dass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist eigentlich ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">, daher müssen Sie spezielle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen </font><font style="vertical-align: inherit;">in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um es zu verarbeiten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pufferreinigung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben unsere Suche also korrekt eingerichtet, sind aber noch nicht fertig. Denken Sie daran, haben wir eine Warteschlange konfiguriert, um Pakete zu akkumulieren? Jetzt, da wir uns in einem anderen Zeitstempel befinden, müssen wir diese Warteschlange löschen, sonst funktioniert die Suche im Film nicht! Darüber hinaus verfügt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über eigene interne Puffer, die für jeden Stream ebenfalls </font><b><font style="vertical-align: inherit;">geleert werden</font></b><font style="vertical-align: inherit;"> müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu müssen Sie zuerst eine Funktion schreiben, die unsere Paketwarteschlange löscht. Dann müssen Sie den Audio- und Videostream irgendwie anweisen, dass die internen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avcodec-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer gelöscht wurden </font><font style="vertical-align: inherit;">. Wir können dies tun, indem wir ein spezielles Paket in die Warteschlange stellen, nachdem es bereinigt wurde. Wenn sie (Threads) dieses spezielle Paket entdecken, löschen sie einfach ihre Puffer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Reset-Funktion. </font><font style="vertical-align: inherit;">Es ist wirklich ganz einfach, also zeige ich Ihnen nur den Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Warteschlange gelöscht wurde, fügen Sie unser "Reinigungspaket" hinzu. </font><font style="vertical-align: inherit;">Aber zuerst wäre es schön zu definieren, was es ist und es zu erstellen:</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket flush_pkt;<font></font>
<font></font>
main() {<font></font>
  ...<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie nun dieses Paket in die Warteschlange:</font></font><br>
<br>
<pre><code class="cpp hljs">  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;audioq);<font></font>
      packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;videoq);<font></font>
      packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
    }<font></font>
  }<font></font>
  is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Dieses Code-Snippet setzt das obige Code-Snippet für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread fort</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Wir müssen auch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ändern, </font><font style="vertical-align: inherit;">damit wir kein spezielles Paket für die Reinigung duplizieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann in den Audio- und Video - </font><font style="vertical-align: inherit;">Stream setzen wir diesen Aufruf in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_flush_buffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direkt nach </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_st-&gt;codec);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das obige Code-Snippet ist für den Videostream genau das gleiche, wobei "Audio" durch "Video" ersetzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist es! </font><font style="vertical-align: inherit;">Wir haben es geschafft! </font><font style="vertical-align: inherit;">Stellen Sie Ihren Player zusammen:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial07 tutorial07.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und genießen Sie Ihren Movie Player, der in weniger als 1000 Zeilen C erstellt wurde! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es natürlich viele Dinge gibt, die hinzugefügt oder verbessert werden können.</font></font><a name="epilogue"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachwort </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 7: Suchen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Anhang 1. Liste der Funktionen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also einen funktionierenden Spieler, aber natürlich ist es nicht so gut wie es sein könnte. </font><font style="vertical-align: inherit;">Es wäre möglich, die Datei zu ändern und viele nützliche Dinge hinzuzufügen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seien wir ehrlich, dieser Spieler ist scheiße. </font><font style="vertical-align: inherit;">Die Version von ffplay.c, auf der es basiert, ist vollständig veraltet. Daher muss dieses Tutorial gründlich überarbeitet werden. </font><font style="vertical-align: inherit;">Wenn Sie mit den FFmpeg-Bibliotheken zu ernsthafteren Projekten übergehen möchten, empfehle ich dringend, als nächste Aufgabe die neueste Version von ffplay.c zu überprüfen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Fehlerbehandlung in unserem Code ist schrecklich und kann viel besser implementiert werden.</font></font></li>
<li>      ,  ,   ,     .   ,    <b>paused</b>    ,   ,    .   ,    ,      .     <b>av_read_play</b>.   -   ,     .  ,    ,       . : ,     ffplay.c.</li>
<li> .</li>
<li> .       ,    ,      ,    ,   <b>VOB-</b>.</li>
<li> .   ,        .</li>
<li> .       .</li>
<li>  ,   ,  ,      ,   <b>YUV</b>,             <b>time_base</b>.</li>
<li> .</li>
<li>--,    ;  ffplay.c      .</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mehr über FFmpeg erfahren möchten, dann haben wir hier weit von allem nachgedacht. Der nächste Schritt ist das Studium der Multimedia-Codierung. Beginnen Sie am besten mit der Datei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">output_example.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Sie in der FFmpeg-Distribution finden. Ich könnte bereits ein weiteres Lehrbuch zu diesem Thema schreiben, aber es ist unwahrscheinlich, dass es diesen Leitfaden übertrifft. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor langer Zeit habe ich diesen Text nicht aktualisiert, aber mittlerweile steht die Welt nicht still. Dieses Tutorial erfordert nur einfache API-Updates. An den Grundkonzepten hat sich sehr wenig geändert. Die meisten dieser Updates haben den Code tatsächlich vereinfacht. Obwohl ich den gesamten Code durchgesehen und aktualisiert habe, ist FFplay diesem Spielzeugspieler immer noch überlegen. Hand aufs Herz, wir geben zu: In diesen Lektionen haben wir einen ziemlich miesen Filmspieler geschrieben. Wenn Sie dieses Tutorial heute (oder in Zukunft) verbessern möchten, empfehle ich Ihnen, sich mit FFplay vertraut zu machen und herauszufinden, was fehlt. Ich glaube, dass dies hauptsächlich die Verwendung von Videogeräten betrifft, aber möglicherweise fehlen mir einige andere offensichtliche Dinge. Vielleicht würde ein Vergleich mit dem aktuellen FFplay zu einer radikalen Umschreibung einiger Dinge führen - ich habe es noch nicht gesehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich bin sehr stolz darauf, dass meine Arbeit im Laufe der Jahre viel geholfen hat, auch wenn man berücksichtigt, dass die Leute oft anderswo nach Code gesucht haben. </font><font style="vertical-align: inherit;">Ich bin </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chelyaev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehr dankbar, der es sich zur </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Aufgabe gemacht hat</font></a><font style="vertical-align: inherit;"> , alle Funktionen </font><font style="vertical-align: inherit;">zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">ersetzen</font></a><font style="vertical-align: inherit;"> , die seit dem Schreiben dieser Monographie vor 8 (!) Jahren veraltet sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich freue mich in der Hoffnung, dass sich diese Lektionen als nützlich und nicht langweilig erwiesen haben. </font><font style="vertical-align: inherit;">Wenn es Vorschläge, Fehler, Beschwerden, Dankeschöns usw. zu diesem Handbuch gibt, schreiben Sie mir bitte an dranger dog gmail dot com. </font><font style="vertical-align: inherit;">Und ja, es macht keinen Sinn, mich zu bitten, bei Ihrem FFmpeg-Projekt zu helfen. </font><font style="vertical-align: inherit;">Es gibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> viele </font><font style="vertical-align: inherit;">ähnliche Buchstaben </font><font style="vertical-align: inherit;">.</font></font><a name="functions"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang 1. Liste der Funktionen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Nachwort"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Anhang 2. Datenstrukturen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avformat_open_input</span><span class="hljs-params">(AVFormatContext **ptr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, AVInputFormat *fmt, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Öffnet den Namen der Mediendatei und speichert den Formatkontext unter der in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegebenen Adresse </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn nicht NULL, wird das Dateiformat festgelegt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Puffergröße (optional). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : AVDictionary wird mit den Parametern von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Demultiplexer </font><b><font style="vertical-align: inherit;">gefüllt</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avformat_close_input</span><span class="hljs-params">(AVFormatContext **s)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließt die Mediendatei. </font><font style="vertical-align: inherit;">Die Codecs werden jedoch nicht geschlossen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">nt <span class="hljs-title">avio_open2</span> <span class="hljs-params">(AVIOContext **s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *url, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellt einen E / A-Kontext für die Verwendung der in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegebenen Ressource </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zeiger auf die Stelle, an der der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellt wird </font><font style="vertical-align: inherit;">. Im Fehlerfall wird der angegebene Wert auf NULL gesetzt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">url</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Name der Ressource, auf die zugegriffen werden soll. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Steuern Sie das Öffnen der in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegebenen Ressource </font><font style="vertical-align: inherit;">. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int_cb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Interrupt-Rückruf zur Verwendung auf Protokollebene. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ein Wörterbuch mit privaten Protokollparametern. Wenn die Funktion zurückkehrt, wird der Parameter zerstört und durch ein Diktat ersetzt, das Optionen enthält, die nicht gefunden wurden. Kann NULL sein.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_dup_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist natürlich ein Hack: Wenn dieses Paket nicht zugewiesen wurde, veröffentlichen wir es hier. </font><font style="vertical-align: inherit;">Gibt bei Erfolg 0 oder bei Fehler AVERROR_NOMEM zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_find_stream_info</span><span class="hljs-params">(AVFormatContext *s, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion sucht nach nicht offensichtlichen Stream-Informationen, wie z. B. der Bildrate. </font><font style="vertical-align: inherit;">Dies ist nützlich für Headerless-Dateiformate wie MPEG. </font><font style="vertical-align: inherit;">Es wird empfohlen, nach dem Öffnen der Datei aufzurufen. </font><font style="vertical-align: inherit;">Gibt bei Erfolg&gt; = 0 zurück, im Fehlerfall AVERROR_ *.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_free_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alter Name für av_frame_free. </font><font style="vertical-align: inherit;">Geändert in lavc 55.28.1.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_frame_free</span> <span class="hljs-params">(AVFrame **frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt einen Frame und alle dynamisch zugewiesenen Objekte frei, z. B. Extended_Data.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt den mit av_malloc () oder av_realloc () zugewiesenen Speicher frei. </font><font style="vertical-align: inherit;">Sie können diese Funktion mit ptr == NULL aufrufen. </font><font style="vertical-align: inherit;">Es wird empfohlen, stattdessen av_freep () aufzurufen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_freep</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt Speicher frei und setzt den Zeiger auf NULL. </font><font style="vertical-align: inherit;">Verwendet intern av_free ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wrap um die Paketzerstörungsmethode (pkt-&gt; destruct).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_gettime</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Holen Sie sich die aktuelle Zeit in Mikrosekunden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_init_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialisieren optionaler Paketfelder.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_malloc</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Byte-Größe der Speicherzuordnung mit Ausrichtung, die für alle Speicherzugriffe geeignet ist (einschließlich Vektoren, falls auf der CPU verfügbar). </font><font style="vertical-align: inherit;">av_malloc (0) sollte einen Zeiger ungleich Null zurückgeben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_mallocz</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entspricht av_malloc (), initialisiert jedoch den Speicher auf Null.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">av_q2d</span><span class="hljs-params">(AVRational a)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verdoppelt AVRational.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_read_frame</span><span class="hljs-params">(AVFormatContext *s, AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt den nächsten Stream-Frame zurück. Informationen werden als Paket in pkt gespeichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zurückgegebene Paket ist bis zum nächsten av_read_frame () oder bis av_close_input_file () gültig und muss mit av_free_packet freigegeben werden. Denn ein Videopaket enthält genau einen Frame. Für Audio enthält es eine ganzzahlige Anzahl von Frames, wenn jeder Frame eine bekannte feste Größe hat (z. B. PCM- oder ADPCM-Daten). Wenn die Audio-Frames eine variable Größe haben (z. B. MPEG-Audio), enthält sie einen Frame. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pkt-&gt; pts, pkt-&gt; dts und pkt-&gt; duration werden immer auf die richtigen Werte in Einheiten von AVStream.timebase gesetzt (und es wird angenommen, dass das Format sie nicht bereitstellen kann). pkt-&gt; pts kann AV_NOPTS_VALUE sein, wenn das Videoformat B-Frames enthält. Wenn Sie die Nutzdaten nicht entpacken, ist es daher besser, sich auf pkt-&gt; dts zu verlassen.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurückgegebenes Ergebnis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0, wenn alles in Ordnung ist, &lt;0, wenn ein Fehler vorliegt oder das Ende der Datei.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_register_all</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Registriert alle Codecs in der Bibliothek.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_rescale_q</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> a, AVRational bq, AVRational cq)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cq zurück</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_seek_frame</span><span class="hljs-params">(AVFormatContext *s, <span class="hljs-keyword">int</span> stream_index, <span class="hljs-keyword">int64_t</span> timestamp, <span class="hljs-keyword">int</span> flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sucht zu einem Zeitstempel nach einem Keyframe. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn stream_index -1 ist, wird der Standard-Stream ausgewählt und der Zeitstempel wird automatisch von AV_TIME_BASE-Einheiten in eine streamspezifische Zeitbasis konvertiert. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zeitstempel gemessen in Einheiten von AVStream.time_base oder, wenn kein Stream angegeben ist, in Einheiten von AV_TIME_BASE. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Legen Sie </font><font style="vertical-align: inherit;">die Parameter für die Richtung und den Suchmodus fest: </font><font style="vertical-align: inherit;">AVSEEK_FLAG_ANY: Suchen Sie in einem beliebigen Frame, nicht nur in den wichtigsten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BACKWARD: Suche in die entgegengesetzte Richtung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BYTE: Suche basierend auf der Position in Bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_alloc_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alter Name für av_frame_alloc. </font><font style="vertical-align: inherit;">Geändert in lavc 55.28.1.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">av_frame_alloc</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wählt einen AVFrame aus und initialisiert ihn. </font><font style="vertical-align: inherit;">Kann mit av_frame_free () freigegeben werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_audio4</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *frame, <span class="hljs-keyword">int</span> *got_frame_ptr, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dekodiert ein Audio-Frame von avpkt zu Frame. Die Funktion avcodec_decode_audio4 () decodiert eine Audiodatei von AVPacket. Für die Dekodierung wird ein Audio-Codec verwendet, der mit avctx über avcodec_open2 () verknüpft wurde. Der resultierende decodierte Frame wird im angegebenen AVFrame gespeichert. Wenn der Frame entpackt wurde, wird got_frame_ptr auf 1 gesetzt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnung: Der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingabepuffer avpkt-&gt; data muss FF_INPUT_BUFFER_PADDING_SIZE größer sein als die tatsächlichen Lesebytes, da einige optimierte Bitstream-Lesegeräte jeweils 32 oder 64 Bit lesen und bis zu lesen können das Ende. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Codec-Kontext. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zielframe. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">got_frame_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ziel-Int, das festgelegt wird, wenn der Frame entpackt wurde. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPKT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: AVPacket mit Audio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurückgegebenes Ergebnis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn ein Fehler zurückgegeben wird, wird ein negativer Wert zurückgegeben, andernfalls wird die Anzahl der vom Eingabe-AVPacket verwendeten Bytes zurückgegeben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_video2</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *picture, <span class="hljs-keyword">int</span> *frameFinished, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dekodiert ein Videobild von buf in ein Bild. Die Funktion avcodec_decode_video2 () decodiert einen Videorahmen aus einem Eingabepuffer der Größe buf_size. Für die Dekodierung wird ein Videocodec verwendet, der mit avctx über avcodec_open2 () verknüpft wurde. Der resultierende dekodierte Rahmen wird im Bild gespeichert. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausrichtungsbeispiele und Pufferprobleme, die für avcodec_decode_audio4 gelten, gelten auch für diese Funktion. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Codec-Kontext. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : AVFrame, in dem das dekodierte Video gespeichert wird. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Null, wenn keine Frames entpackt werden können, andernfalls ist es nicht gleich Null. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: AVPacket mit Eingangspuffer eingeben. </font><font style="vertical-align: inherit;">Sie können ein solches Paket mit av_init_packet () erstellen. Bei angegebenen Daten und Größen benötigen einige Decoder möglicherweise zusätzlich andere Felder, z. B. Flags und AV_PKT_FLAG_KEY. </font><font style="vertical-align: inherit;">Alle Decoder sind so konzipiert, dass möglichst wenige Felder verwendet werden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurückgegebenes Ergebnis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei einem Fehler wird ein negativer Wert zurückgegeben, andernfalls wird die Anzahl der Bytes verwendet oder Null, wenn keine Frames dekomprimiert werden können.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_frame_get_best_effort_timestamp</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVFrame *frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine einfache Zugriffsmethode, um best_effort_timestamp von einem AVFrame-Objekt abzurufen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodec *<span class="hljs-title">avcodec_find_decoder</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> CodecID id)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sucht nach einem Decoder mit CodecID. </font><font style="vertical-align: inherit;">Gibt bei einem Fehler NULL zurück. </font><font style="vertical-align: inherit;">Es sollte aufgerufen werden, nachdem der erforderliche AVCodecContext aus dem Stream in AVFormatContext mit codecCtx-&gt; codec_id abgerufen wurde.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avcodec_flush_buffers</span><span class="hljs-params">(AVCodecContetx *avctx)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pufferspülung. </font><font style="vertical-align: inherit;">Wird beim Suchen oder Wechseln zu einem anderen Stream aufgerufen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodecContext * <span class="hljs-title">avcodec_alloc_context3</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVCodec *codec)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weist AVCodecContext zu und setzt seine Felder auf Standardwerte.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_copy_context</span> <span class="hljs-params">(AVCodecContext *dest, <span class="hljs-keyword">const</span> AVCodecContext *src)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie die Einstellungen des Quell-AVCodecContext in den Ziel-AVCodecContext. </font><font style="vertical-align: inherit;">Der resultierende Kontext des Zielcodecs wird geschlossen, d.h. </font><font style="vertical-align: inherit;">Sie müssen avcodec_open2 () aufrufen, bevor Sie diesen AVCodecContext zum Decodieren / Codieren von Video- / Audiodaten verwenden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dest</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : muss mit avcodec_alloc_context3 (NULL) initialisiert werden, sonst wird es nicht initialisiert.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_open2</span><span class="hljs-params">(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialisiert avctx so, dass der im Codec angegebene </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codec verwendet wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sollte nach avcodec_find_decoder verwendet werden. </font><font style="vertical-align: inherit;">Gibt bei Erfolg Null und bei Fehler einen negativen Wert zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_fill</span><span class="hljs-params">(AVPicture *picture, <span class="hljs-keyword">uint8_t</span> *ptr, <span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Legt die Struktur fest, auf die das Bild zeigt, mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">, dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format </font><font style="vertical-align: inherit;">und der angegebenen Breite und Höhe. </font><font style="vertical-align: inherit;">Gibt die Größe der Bilddaten in Bytes zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_get_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berechnet, wie viele Bytes für ein Bild mit einer bestimmten Breite, Höhe und einem bestimmten Bildformat benötigt werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct SwsContext* <span class="hljs-title">sws_getContext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcW, <span class="hljs-keyword">int</span> srcH, <span class="hljs-keyword">int</span> srcFormat, <span class="hljs-keyword">int</span> dstW, <span class="hljs-keyword">int</span> dstH, <span class="hljs-keyword">int</span> dstFormat, <span class="hljs-keyword">int</span> flags, SwsFilter *srcFilter, SwsFilter *dstFilter, <span class="hljs-keyword">double</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt SwsContext zur Verwendung in sws_scale zurück. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Breite, Höhe und Format der gewünschten Pixel. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Breite, Höhe und Format der endgültigen Pixel. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die zu verwendende Skalierungsmethode. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgende Optionen stehen zur Verfügung: SWS_FAST_BILINEAR, SWS_BILINEAR, SWS_BICUBIC, SWS_X, SWS_POINT, SWS_AREA, SWS_BICUBLIN, SWS_GAUSS, SWS_SINC, SWS_LANCZOS, SWS_SPLINE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Flags umfassen CPU-Fähigkeitsflags: SWS_CPU_CAPS_MMX, SWS_CPU_CAPS_MMX2, SWS_CPU_CAPS_3DNOW, SWS_CPU_CAPS_ALTIVEC.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Flags sind (derzeit nicht vollständig implementiert) SWS_FULL_CHR_H_INT, SWS_FULL_CHR_H_INP und SWS_DIRECT_BGR. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich gibt es SWS_ACCURATE_RND und vielleicht das nützlichste für Anfänger, SWS_PRINT_INFO. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe keine Ahnung, was die meisten von ihnen tun. Vielleicht an mich schreiben? </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : SwsFilter für Quelle und Ziel. SwsFilter aktiviert die Farb- / Helligkeitsfilterung. Der Standardwert ist NULL. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : sollte ein Zeiger auf einen int [2] </font><b><font style="vertical-align: inherit;">-Puffer</font></b><font style="vertical-align: inherit;"> mit Koeffizienten sein. Nicht dokumentiert. Es scheint verwendet zu werden, um Standard-Skalierungsalgorithmen leicht zu modifizieren. Der Standardwert ist NULL. Nur für Experten!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sws_scale</span><span class="hljs-params">(SwsContext *c, <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">int</span> srcStride[], <span class="hljs-keyword">int</span> srcSliceY, <span class="hljs-keyword">int</span> srcSliceH, <span class="hljs-keyword">uint8_t</span> dst[], <span class="hljs-keyword">int</span> dstStride[]
sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height, pict.data, pict.linesize);</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skaliert Daten in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gemäß unseren Einstellungen in unserem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwsContext * c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind die Quell- </font><font style="vertical-align: inherit;">und </font><b><font style="vertical-align: inherit;">Zielzeilengrößen</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_TimerID <span class="hljs-title">SDL_AddTimer</span><span class="hljs-params">(Uint32 interval, SDL_NewTimerCallback callback, <span class="hljs-keyword">void</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügt eine Rückruffunktion hinzu, die nach einer bestimmten Anzahl von Millisekunden ausgeführt wird. Die Rückruffunktion übergibt das aktuelle Zeitintervall und den vom Benutzer angegebenen Parameter aus dem Aufruf SDL_AddTimer und gibt das nächste Zeitintervall zurück. (Wenn der Rückgabewert des Rückrufs mit dem übergebenen Wert übereinstimmt, arbeitet der Timer mit der gleichen Geschwindigkeit weiter.) Wenn der Rückgabewert des Rückrufs 0 ist, wird der Timer abgebrochen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Möglichkeit, den aktuellen Timer abzubrechen, besteht darin, SDL_RemoveTimer mit der Timer-ID aufzurufen (die von SDL_AddTimer zurückgegeben wurde). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Timer-Rückruffunktion wird möglicherweise in einem anderen Thread als Ihrem Hauptprogramm ausgeführt und sollte daher keine Funktionen von sich aus aufrufen. Sie können jedoch jederzeit SDL_PushEvent aufrufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Detaillierungsgrad des Timers hängt von der Plattform ab. Sie müssen jedoch mit mindestens 10 ms rechnen, da dies der häufigste Wert ist. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Rückruf auf einem entladenen System nach ca. 20 ms startet, wenn Sie einen 16-ms-Timer anfordern. </font><font style="vertical-align: inherit;">Wenn Sie ein Flag setzen müssen, das die Aktualisierung von Frames mit einer Geschwindigkeit von 30 Frames pro Sekunde (alle 33 ms) signalisiert, können Sie einen Timer für 30 ms setzen (siehe Beispiel unten). </font><font style="vertical-align: inherit;">Wenn Sie diese Funktion verwenden, müssen Sie SDL_INIT_TIMER an SDL_Init übergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt den Bezeichnerwert für den hinzugefügten Timer oder NULL zurück, wenn ein Fehler auftritt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Format für Rückruf:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">Uint32 <span class="hljs-title">callback</span> <span class="hljs-params">( Uint32, <span class="hljs-keyword">void</span> * param)</span></span></code></pre><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondSignal</span><span class="hljs-params">(SDL_cond *cond)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neustarten eines der Gewinde für die Warte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cond</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bedingungsvariable </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gibt bei Erfolg 0 und bei Fehler -1 zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondWait</span><span class="hljs-params">(SDL_cond *cond, SDL_mutex *mut)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entsperren Sie den bereitgestellten Mutex und warten Sie, bis ein anderer Thread SDL_CondSignal oder SDL_CondBroadcast für die Bedingungsvariable cond aufruft. Sperren Sie dann den Mutex erneut. </font><font style="vertical-align: inherit;">Der Mutex muss vor dem Aufrufen dieser Funktion gesperrt sein. </font><font style="vertical-align: inherit;">Gibt 0 zurück, wenn ein Signal empfangen wird, oder -1 bei einem Fehler.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_cond *<span class="hljs-title">SDL_CreateCond</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellt eine Bedingungsvariable.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Thread *<span class="hljs-title">SDL_CreateThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *data)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateThread erstellt einen neuen Ausführungsthread, der den gesamten globalen Speicher des übergeordneten Elements, der Signalhandler, der Dateideskriptoren usw. gemeinsam nutzt. </font><font style="vertical-align: inherit;">Und es führt die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fn</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus </font><font style="vertical-align: inherit;">und übergibt ihr die ungültigen Zeigerdaten. </font><font style="vertical-align: inherit;">Der Thread wird beendet, wenn fn einen Wert zurückgibt.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Delay</span> <span class="hljs-params">(Uint32 )</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wartet auf die angegebene Anzahl von Millisekunden. SDL_Delay wartet mindestens die angegebene Zeit, möglicherweise jedoch aufgrund der Betriebssystemplanung länger. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erwarten Sie eine Verzögerungsgranularität von mindestens 10 ms. Einige Plattformen haben kürzere Maßnahmen, dies ist jedoch die häufigste Option.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Overlay *<span class="hljs-title">SDL_CreateYUVOverlay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Uint32 format, SDL_Surface *display)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateYUVOverlay erstellt eine YUV-Überlagerung mit der angegebenen Breite, Höhe und dem angegebenen Format (eine Liste der verfügbaren Formate finden Sie in der SDL_Overlay-Datenstruktur) für die bereitgestellte Anzeige. </font><font style="vertical-align: inherit;">Gibt SDL_Overlay zurück. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzeige</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sollte eigentlich eine von SDL_SetVideoMode abgeleitete Oberfläche sein, andernfalls funktioniert diese Funktion standardmäßig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Begriff „Überlagerung“ ist falsch, da der Inhalt der Anzeigefläche unterhalb des Bereichs, in dem die Überlagerung angezeigt wird, überschrieben wird, wenn die Überlagerung angezeigt wird, wenn die Überlagerung nicht in Hardware erstellt wird.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockYUVOverlay blockiert die Überlagerung für den direkten Zugriff auf Pixeldaten. </font><font style="vertical-align: inherit;">Gibt bei Erfolg 0 oder bei Fehler -1 zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_UnlockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schaltet eine zuvor gesperrte Überlagerung frei. </font><font style="vertical-align: inherit;">Das Overlay muss entsperrt sein, bevor es angezeigt werden kann.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_DisplayYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay, SDL_Rect *dstrect)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzt die Überlagerung auf die Oberfläche, die beim Erstellen angegeben wurde. </font><font style="vertical-align: inherit;">Die Struktur SDL_Rect dstrect definiert die Position und Größe des Ziels. </font><font style="vertical-align: inherit;">Wenn dstrect mehr oder weniger Overlay ist, wird das Overlay skaliert. Dies ist für die zweifache Skalierung optimiert. </font><font style="vertical-align: inherit;">Gibt bei Erfolg 0 zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_FreeYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt das von SDL_CreateYUVOverlay erstellte Overlay frei.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_Init</span><span class="hljs-params">(Uint32 flags)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialisiert die SDL. Dies sollte vor allen anderen SDL-Funktionen aufgerufen werden. Der Parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt an, welche Teile der SDL initialisiert werden sollen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_TIMER - Initialisiert das Timer-Subsystem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_AUDIO - Initialisiert das Audio-Subsystem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_VIDEO - Initialisiert das Video-Subsystem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_CDROM - Initialisiert das CD-ROM-Subsystem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_JOYSTICK - Initialisiert das Joystick-Subsystem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVERYTHING - Initialisiert alle oben genannten Elemente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_NOPARACHUTE - SDL kann keine schwerwiegenden Fehler abfangen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVENTTHREAD - Startet den Event Manager in einem separaten Thread.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gibt bei Fehler -1 oder bei Erfolg 0 zurück. </font><font style="vertical-align: inherit;">Sie können eine erweiterte Fehlermeldung erhalten, indem Sie SDL_GetError aufrufen. </font><font style="vertical-align: inherit;">Eine typische Fehlerursache ist die Verwendung einer bestimmten Anzeige ohne die entsprechende Unterstützung für das Subsystem, z. B. das Fehlen eines Maustreibers bei Verwendung eines Bildpuffers mit dem Gerät. </font><font style="vertical-align: inherit;">In diesem Fall können Sie SDL entweder ohne Maus kompilieren oder die Umgebungsvariable "SDL_NOMOUSE = 1" festlegen, bevor Sie die Anwendung starten.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_mutex *<span class="hljs-title">SDL_CreateMutex</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellt einen neuen, freigeschalteten Mutex.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockMutex</span><span class="hljs-params">(SDL_mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockMutex ist ein Alias ​​für SDL_mutexP. </font><font style="vertical-align: inherit;">Es blockiert einen Mutex, der zuvor mit SDL_CreateMutex erstellt wurde. </font><font style="vertical-align: inherit;">Wenn der Mutex bereits von einem anderen Thread blockiert ist, gibt SDL_mutexP keinen Wert zurück, bis der von ihm blockierte Thread ihn entsperrt (mithilfe von SDL_mutexV). </font><font style="vertical-align: inherit;">Wenn der Mutex erneut aufgerufen wird, muss SDL_mutexV (auch bekannt als SDL_UnlockMutex) gleich oft aufgerufen werden, um den Mutex in einen entsperrten Zustand zurückzusetzen. </font><font style="vertical-align: inherit;">Gibt bei Erfolg 0 oder bei Fehler -1 zurück.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_UnlockMutex</span><span class="hljs-params">(SDL_Mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex entsperren.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_OpenAudio</span><span class="hljs-params">(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion öffnet die Audioeinheit mit den erforderlichen Parametern und gibt bei Erfolg 0 zurück, wobei die tatsächlichen Hardwareparameter in der Struktur platziert werden, auf die sie letztendlich zeigt. Wenn ein NULL-Wert empfangen wird, haben die an die Rückruffunktion übergebenen Audiodaten garantiert das erforderliche Format und werden bei Bedarf automatisch in das Hardware-Audioformat konvertiert. Diese Funktion gibt -1 zurück, wenn das Audiogerät nicht geöffnet oder der Audiostream nicht konfiguriert werden konnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Audiogerät zu öffnen, müssen Sie die gewünschte SDL_AudioSpec erstellen. Dann müssen Sie diese Struktur mit den gewünschten Audiospezifikationen füllen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschte-&gt; Frequenz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : gewünschte Schallfrequenz in Samples pro Sekunde. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschtes-&gt; Format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : gewünschtes Audioformat (siehe SDL_AudioSpec). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschte-&gt; Kanäle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Erforderliche Kanäle (1 für Mono, 2 für Stereo, 4 für Surround-Sound, 6 für Surround-Sound mit Zentrierung und LFE). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschte-&gt; Samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : gewünschte </font><b><font style="vertical-align: inherit;">Audiopuffergröße</font></b><font style="vertical-align: inherit;"> in Samples. Diese Zahl muss eine Zweierpotenz sein und kann vom Audiotreiber auf einen für die Hardware besser geeigneten Wert eingestellt werden. Die optimalen Werte reichen von 512 bis einschließlich 8192, abhängig von der Anwendung und der Prozessorgeschwindigkeit. Kleinere Werte führen zu schnelleren Antwortzeiten, können jedoch zu einer schlechten Leistung führen, wenn die Anwendung eine umfangreiche Verarbeitung durchführt und den Audiopuffer nicht rechtzeitig füllen kann. Das Stereo-Sample besteht aus dem rechten und dem linken Kanal in LR-Reihenfolge. Bitte beachten Sie, dass die Anzahl der Proben mit der folgenden Formel direkt mit der Zeit zusammenhängt: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ms</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 1000) / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünscht-&gt; Rückruf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : muss auf eine Funktion eingestellt sein, die aufgerufen wird, wenn die Audioeinheit bereit ist, zusätzliche Daten zu empfangen. Der Zeiger auf den Audiopuffer und die Länge des Audiopuffers in Bytes werden übertragen. Diese Funktion wird normalerweise in einem separaten Thread ausgeführt. Daher müssen die Datenstrukturen, auf die zugegriffen wird, durch Aufrufen von SDL_LockAudio und SDL_UnlockAudio im Code geschützt werden. Der Callback-Prototyp ist </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerdaten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ein Zeiger, der im Benutzerdatenfeld SDL_AudioSpec gespeichert ist. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strom</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist ein Zeiger auf den Audiopuffer, den Sie mit Informationen füllen möchten, und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Länge des Audiopuffers in Bytes. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erforderlich-&gt; Benutzerdaten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dieser Zeiger wird als erster Parameter an die Rückruffunktion übergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudio liest diese Felder aus der gewünschten SDL_AudioSpec-Struktur, die an die Funktion übergeben wurde, und versucht, die Audiokonfiguration zu finden, die Ihrem Wunsch entspricht. Wie oben erwähnt, wird SDL während der Wiedergabe von den gewünschten Soundeinstellungen in Geräteeinstellungen konvertiert, wenn der resultierende Parameter NULL ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn NULL zurückgegeben wird, ist die erforderliche SDL_AudioSpec Ihre Arbeitsspezifikation, andernfalls wird die resultierende SDL_AudioSpec zu einer Arbeitsspezifikation, und die gewünschte Spezifikation kann gelöscht werden. Die Daten in der Arbeitsspezifikation werden beim Erstellen von SDL_AudioCVT verwendet, um die heruntergeladenen Daten in das Geräteformat zu konvertieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudio berechnet Größen- und Stillefelder sowohl für die gewünschte als auch für die resultierende Spezifikation. Das Größenfeld speichert die Gesamtgröße des Audiopuffers in Bytes, während die Stille den Wert speichert, der zur Darstellung der Stille im Audiopuffer verwendet wird</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Audiogerät beginnt mit der Wiedergabe der Stille, wenn es geöffnet ist, und sollte für die Wiedergabe durch Aufrufen von SDL_PauseAudio (0) eingeschaltet werden, wenn Sie bereit sind, die Audio-Rückruffunktion aufzurufen. </font><font style="vertical-align: inherit;">Da der Audiotreiber die angeforderte Größe des Audiopuffers ändern kann, müssen Sie nach dem Öffnen des Audiogeräts alle lokalen Mischpuffer auswählen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_PauseAudio</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pause_on)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion pausiert und stoppt die Audio-Rückrufverarbeitung. </font><font style="vertical-align: inherit;">Es muss nach dem Öffnen des Audiogeräts mit pause_on = 0 aufgerufen werden, um die Tonwiedergabe zu starten. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie die Daten für die Rückruffunktion nach dem Öffnen der Audioeinheit sicher initialisieren. </font><font style="vertical-align: inherit;">Während einer Pause wird die Stille auf dem Audiogerät aufgezeichnet.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_PushEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Ereigniswarteschlange, die tatsächlich als bidirektionaler Kommunikationskanal verwendet wird. </font><font style="vertical-align: inherit;">Es können nicht nur Ereignisse aus der Warteschlange gelesen werden, sondern der Benutzer kann auch seine eigenen Ereignisse in die Warteschlange stellen. </font><font style="vertical-align: inherit;">Ein Ereignis ist ein Zeiger auf die Struktur des Ereignisses, das Sie in die Warteschlange stellen möchten. </font><font style="vertical-align: inherit;">Das Ereignis wird in die Warteschlange kopiert, und der Aufrufer kann den Speicher verwalten, auf den nach der Rückgabe von SDL_PushEvent verwiesen wird. </font><font style="vertical-align: inherit;">Diese Funktion ist threadorientiert und kann sicher von anderen Threads aufgerufen werden. </font><font style="vertical-align: inherit;">Gibt 0 zurück, wenn erfolgreich, oder -1, wenn das Ereignis nicht ausgelöst werden konnte.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_WaitEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wartet auf unbestimmte Zeit auf das nächste verfügbare Ereignis und gibt 0 zurück, wenn beim Warten auf Ereignisse ein Fehler aufgetreten ist, andernfalls 1. </font><font style="vertical-align: inherit;">Wenn das Ereignis nicht NULL ist, wird das nächste Ereignis aus der Warteschlange entfernt und in diesem Bereich gespeichert.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Quit</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deaktiviert alle SDL-Subsysteme und gibt die ihm zugewiesenen Ressourcen frei. Dies sollte immer vor dem Beenden aufgerufen werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Surface *<span class="hljs-title">SDL_SetVideoMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> bitsperpixel, Uint32 flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Videomoduseinstellung mit den angegebenen Breiten-, Höhen- und Pixelbits. Ab SDL 1.2.10 werden bei einer Breite und Höhe von 0 die Breite und Höhe des aktuellen Videomodus (oder des Desktop-Modus, wenn der Modus nicht eingestellt ist) verwendet. Wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitsperpixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 ist, wird es als die aktuellen Anzeigebits pro Pixel behandelt. Der Parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist derselbe wie das Feld flags der Struktur SDL_Surface. Oder eine Kombination der folgenden Werte: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE - Erstellen Sie eine Videooberfläche im Systemspeicher. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE - Erstellt eine Videooberfläche im Videospeicher. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT - Aktivieren Sie die Verwendung von asynchronen Aktualisierungen der Anzeigeoberfläche. Dies verlangsamt normalerweise die Arbeit auf Einzelprozessor-Computern, kann jedoch die Geschwindigkeit in SMP-Systemen erhöhen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT - Wenn normalerweise eine Videooberfläche mit den angeforderten Bits pro Pixel (bpp - von Bits pro Pixel) nicht verfügbar ist, emuliert SDL Videos mit einer schattierten Oberfläche. Das Übergeben von SDL_ANYFORMAT verhindert dies und zwingt die SDL, die Oberfläche des Videos unabhängig von seiner Pixeltiefe zu verwenden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE - Bietet exklusiven SDL-Zugriff auf die Palette. Ohne dieses Flag können Sie mit SDL_SetColors oder SDL_SetPalette nicht immer die gewünschten Farben abrufen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF - Hardware-Doppelpufferung aktivieren; Nur gültig mit SDL_HWSURFACE. Ein Aufruf von SDL_Flip kehrt die Puffer um und aktualisiert den Bildschirm. Alle Zeichnungen finden auf einer Oberfläche statt, die derzeit nicht angezeigt wird. Wenn die doppelte Pufferung nicht aktiviert werden kann, führt SDL_Flip einfach SDL_UpdateRect im Vollbildmodus aus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN SDL - Versuchen Sie, den Vollbildmodus zu verwenden. Wenn eine Änderung der Hardwareauflösung (aus irgendeinem Grund) nicht möglich ist, wird die nächsthöhere Auflösung verwendet und das Anzeigefenster wird auf einem schwarzen Hintergrund zentriert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL - Erstellt einen OpenGL-Rendering-Kontext. Es wird davon ausgegangen, dass die OpenGL-Videoattribute mit SDL_GL_SetAttribute voreingestellt sind.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT - Erstellen Sie einen OpenGL-Rendering-Kontext wie oben beschrieben, lassen Sie jedoch normale Blitting-Vorgänge zu. Eine Bildschirmoberfläche (2D) kann einen Alphakanal haben, und SDL_UpdateRects sollte verwendet werden, um Änderungen der Bildschirmoberfläche zu aktualisieren. HINWEIS. Diese Option wird nur aus Kompatibilitätsgründen gespeichert und in zukünftigen Versionen entfernt. Nicht für die Verwendung in neuem Code empfohlen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABL - Erstellt ein Fenster mit veränderbarer Größe. Wenn die Fenstergröße vom Benutzer geändert wird, wird das Ereignis SDL_VIDEORESIZE generiert und SDL_SetVideoMode kann erneut mit einer neuen Größe aufgerufen werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_NOFRAME Wenn möglich, zwingt SDL_NOFRAME SDL, ein Fenster ohne Titel oder Rahmen zu erstellen. Dieses Flag wird automatisch im Vollbildmodus gesetzt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis. Unabhängig davon, welche SDL_SetVideoMode-Flags erfüllen können, werden sie im flags-Element der zurückgegebenen Oberfläche gesetzt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HINWEIS. Das Bitpixel 24 verwendet eine gepackte Darstellung von 3 Bytes pro Pixel. Verwenden Sie für den gängigeren 4-Byte-pro-Pixel-Modus 32-Bit-Pixel. Seltsamerweise fordern sowohl 15 als auch 16 einen 2-Byte-pro-Pixel-Modus an, jedoch mit unterschiedlichen Pixelformaten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HINWEIS. Verwenden Sie SDL_SWSURFACE, wenn Sie separate Pixelmanipulationen durchführen oder Oberflächen mithilfe von Alphakanälen ziehen möchten und eine hohe Bildrate benötigen. Wenn Sie Hardwareoberflächen (SDL_HWSURFACE) verwenden, kopiert die SDL Oberflächen aus dem Videospeicher in den Systemspeicher, wenn Sie sie sperren, und umgekehrt, wenn Sie sie entsperren. Dies kann zu einer deutlichen Leistungsminderung führen. (Beachten Sie, dass Sie nach einer Hardwareoberfläche fragen können, aber dennoch eine Softwareoberfläche erhalten. Viele Plattformen können nur bei Verwendung von SDL_FULLSCREEN eine Hardwareoberfläche bereitstellen.) SDL_HWSURFACE wird am besten verwendet, wenn die Oberflächen, die Sie blotten, auch im Videospeicher gespeichert werden können.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HINWEIS. </font><font style="vertical-align: inherit;">Wenn Sie die Position auf dem Bildschirm beim Erstellen der Fensteroberfläche steuern möchten, können Sie dazu die Umgebungsvariablen "SDL_VIDEO_CENTERED = center" oder "SDL_VIDEO_WINDOW_POS = x, y" festlegen. </font><font style="vertical-align: inherit;">Sie können sie über SDL_putenv installieren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückgabewert:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frame Buffer Surface oder NULL im Fehlerfall. </font><font style="vertical-align: inherit;">Die zurückgegebene Oberfläche wird von SDL_Quit freigegeben und darf vom Aufrufer nicht freigegeben werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HINWEIS. </font><font style="vertical-align: inherit;">Diese Regel umfasst aufeinanderfolgende Aufrufe von SDL_SetVideoMode (d. H. Größenänderung) - die vorhandene Oberfläche wird automatisch freigegeben.</font></font><a name="data"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang 2. Datenstrukturen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Anhang 1. Liste der Funktionen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Verweise"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<br>
<pre><code class="cpp hljs">AVCodecContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Informationen zum Codec aus dem Stream, von AVStream-&gt; Codec. Einige wichtige Attribute: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anzahl der Frames pro Sekunde </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Samples pro Sekunde </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">channel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anzahl der Kanäle </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vollständige Liste (sehr beeindruckend) finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20090410064257/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webarchiv, da der ursprüngliche Link bereits nicht vorhanden ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Viele Parameter werden hauptsächlich zum Codieren verwendet, nicht zum Decodieren.</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Datenfelder: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_class </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVInputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVOutputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leere</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : für Low-Level - </font><font style="vertical-align: inherit;">Datei Manipulation. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anzahl der Threads in der Datei. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream * -Streams [MAX_STREAMS]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Hier werden Daten für jeden Stream gespeichert. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char Dateiname [1024]:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aber was ist ohne ihn (im Original - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">
Dateiinformationen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">title</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">author</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copyright</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">album</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">year</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">track</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [32]: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ctx_flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mögliche Werte sind AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS, AVFMT_RAWPICTURE, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dieser Puffer wird nur benötigt, wenn Pakete bereits gepuffert, aber nicht decodiert sind, um beispielsweise Codec-Parameter in MPEG-Streams zu empfangen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int64_t</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : beim Decodieren: Die Position des ersten Frames der Komponente in Bruchteilen einer Sekunde, AV_TIME_BASE. Stellen Sie diesen Wert NIEMALS direkt ein: Er wird aus den Werten von AVStream abgeleitet. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t Dauer: Dekodierung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dauer des Streams in Bruchteilen von AV_TIME_BASE. Stellen Sie diesen Wert NIEMALS direkt ein: Er wird aus den Werten von AVStream abgeleitet. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t file_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Gesamtgröße der Datei, 0, falls unbekannt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int bit_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : decoding: Gesamtbitrate des Streams in Bit / s, 0, falls nicht verfügbar. Stellen Sie es NIEMALS direkt ein, wenn file_size und die in ffmpeg bekannte Dauer es automatisch berechnen können. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream * cur_st </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * cur_ptr </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int cur_len </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket cur_pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t data_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index_built</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Offset des ersten Pakets. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mux_rate int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int Vorbelastung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_output</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anzahl der Ausgangsschleifen in den </font><font style="vertical-align: inherit;">unterstützten Formaten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_input</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int probesize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : decoding: Beispieldatengröße; wird bei der Codierung nicht verwendet. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_analyze_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : maximale Dauer in Einheiten von AV_TIME_BASE, während der die Eingabedaten in av_find_stream_info () analysiert werden müssen </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int keylen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E / A-Kontext für den Zugriff auf Ressourcen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const AVClass * av_class</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Klasse für private Einstellungen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenloser char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Beginn des Puffers. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : maximale Puffergröße. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : aktuelle Position im Puffer. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Daten können kleiner als buffer + buffer_size sein, wenn die Lesefunktion beispielsweise weniger Daten als angefordert zurückgibt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : privater Zeiger an read / write / search / ... </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_packet) übergeben (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* write_packet) (void * opaque, uint8_t * buf, int buf_size )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t (* seek) (void * undurchsichtig, int64_t offset, int </font></font></b><font style="vertical-align: inherit;"></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wherece </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">)</font></b><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">int64_t pos</font></b><font style="vertical-align: inherit;"> : Position in der Datei des aktuellen Puffers. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true, wenn die nächste Suche zurückgesetzt werden soll. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true, wenn das Dateiende erreicht ist. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true, wenn zum Schreiben geöffnet. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenlose lange Prüfsumme</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenlose char * Prüfsumme_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenlose lange </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Prüfsumme </font></b><b><font style="vertical-align: inherit;">(* update_checksum) (vorzeichenlose lange Prüfsumme, const uint8_t * buf, vorzeichenlose int-Größe)</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : enthält den Fehlercode oder 0, wenn kein Fehler aufgetreten ist. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_pause) (void * undurchsichtig, int pause)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Unterbrechen oder setzen Sie beispielsweise die Wiedergabe für Netzwerk-Streaming-Protokolle fort. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t (* read_seek) (void * opaque, int stream_index, int64_t timestamp, int flags)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Suche nach dem angegebenen Zeitstempel im Stream mit dem angegebenen stream_index-Index. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int seekable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Kombination der Flags AVIO_SEEKABLE_ oder 0, wenn der Stream nicht durchsuchbar ist. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t maxsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Maximale Dateigröße, mit der die Auswahl eingeschränkt wird. Dieses Feld ist für libavformat intern und der Zugriff von außen ist verboten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int direct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : avio_read und avio_write sollten nach Möglichkeit direkt ausgeführt werden und nicht den Puffer durchlaufen, und avio_seek ruft immer direkt die Hauptsuchfunktion auf. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t bytes_read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Byte Read Statistics Dieses Feld ist intern für libavformat und der externe Zugriff wird verweigert. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int seek_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">Suchstatistik</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieses Feld ist für libavformat intern und der Zugriff von außen ist verboten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int writeout_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Statistik schreiben. </font><font style="vertical-align: inherit;">Dieses Feld ist für libavformat intern und der Zugriff von außen ist verboten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int orig_buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die ursprüngliche Puffergröße, die intern verwendet wird, nachdem die Puffergröße überprüft und zurückgegeben wurde. </font><font style="vertical-align: inherit;">Dieses Feld ist für libavformat intern und der Zugriff von außen ist verboten.</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionary</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird verwendet, um Parameter an ffmpeg zu übergeben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVDictionaryEntry * elems</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionaryEntry</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird zum Speichern von Wörterbucheinträgen in AVDictionary verwendet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * ket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * value</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur hängt von der Art des Codecs ab und wird daher dynamisch bestimmt. Es gibt jedoch allgemeine Eigenschaften und Methoden für diese Struktur: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int linesize [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : information stride. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * base [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int key_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int pict_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies sind nicht die Punkte, die Sie beim Decodieren erwarten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int coded_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int display_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int Qualität</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int Alter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int Referenz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * qscale_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qstride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * mbskip_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int16_t (* motion_val [2]) [2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t * mb_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t motion_subsample_log2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * undurchsichtig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Benutzerdaten </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint64_t Fehler [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int repeat_pict</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">Weist</font></b><font style="vertical-align: inherit;"> Sie an, das Bild eine bestimmte Anzahl von Malen zu wiederholen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qscale_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int interlaced_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int top_field_first</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPanScan * pan_scan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int palette_has_changed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_hints</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">short * dct_coeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * ref_index [2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur, in der die Rohpaketdaten gespeichert werden. Diese Daten müssen an avcodec_decode_audio2 oder avcodec_decode_video übertragen werden, um einen Frame zu erhalten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Präsentationszeitstempel in time_base-Einheiten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zeitstempel der Dekomprimierung in Einheiten der Zeitbasis. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Rohdaten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Datengröße. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Stream, aus dem AVPacket stammt, basierend auf der Menge in AVFormatContext. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : PKT_FLAG_KEY wird gesetzt, wenn das Paket ein Schlüsselbild ist. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dauer der Präsentation in Einheiten von time_base (0, falls nicht verfügbar)</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void (* destruct) (struct AVPacket *)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ressourcenfreigabefunktion für dieses Paket (standardmäßig av_destruct_packet). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Byte-Position im Stream, -1, falls unbekannt.</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacketList</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine einfache verknüpfte Liste für Pakete. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList * next</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVPicture</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur entspricht genau den ersten beiden AVFrame-Datenelementen und wird daher häufig verworfen. </font><font style="vertical-align: inherit;">Wird häufig in SWS-Funktionen verwendet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int linesize [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Anzahl der Bytes in der Zeichenfolge.</font></font><br>
<br>
<pre><code class="cpp hljs">AVRational</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einfache Struktur zur Darstellung rationaler Zahlen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int num</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zähler. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Nenner.</font></font><br>
<br>
<pre><code class="cpp hljs">AVStream</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur für den Stream. Sie werden diese Informationen wahrscheinlich am häufigsten im Codec verwenden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext * Codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational r_frame_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t codec_info_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int codec_info_nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrac pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int pts_wrap_bits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_copy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Enumeration AVDiscard den Ablage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Sie können die Pakete auswählen , </font><font style="vertical-align: inherit;">die weggeworfen werden, weil sie nicht brauchen beim Demultiplexen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Float-Qualität</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t Startzeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t Dauer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Char Sprache [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int need_parsing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 1 -&gt; müssen voll Parsing, 2 -&gt; Parse - </font><font style="vertical-align: inherit;">Header nur ohne Umpacken </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecParserContext * Parser</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t cur_dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int last_IP_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t last_IP_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIndexEntry * index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int nb_index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int index_entries_allocated_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anzahl der Frames in diesem Stream (falls bekannt) oder 0 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts_buffer [MAX_REORDER_DELAY + 1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">ByteIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Struktur, in der Informationen zu einer Filmdatei auf niedriger Ebene gespeichert werden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenloser char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenloser char * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenloser char * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_packet) (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* write_packet) (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t (* seek) (void * undurchsichtig, offset_t offset, int woher)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int is_streamed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenlose lange Prüfsumme</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenlose char * Prüfsumme_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorzeichenlose lange (* update_checksum) (vorzeichenlose lange Prüfsumme: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const uint8_t * buf, vorzeichenlose int-Größe)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : enthält den Fehlercode oder 0, wenn kein Fehler aufgetreten ist.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_AudioSpec</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird verwendet, um das Format einiger Audiodaten zu beschreiben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequenz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Schallfrequenz in Samples pro Sekunde. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Audiodatenformat. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanäle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anzahl der Kanäle: 1 - Mono, 2 - Stereo, 4 Surround, 6 Surround mit Zentrierung und LFE- </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stille</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">Stillewert</font></b><font style="vertical-align: inherit;"> des Schallpuffers (berechnet). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Audiopuffergröße in Samples. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Größe des Audiopuffers in Bytes (berechnet). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückruf (..)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Rückruffunktion zum Füllen des Audiopuffers. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerdaten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ein Zeiger auf Benutzerdaten, der an die Rückruffunktion übergeben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Formatwerte sind </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gültig </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">AUDIO_U8 - ​​8-Bit-Samples ohne Vorzeichen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S8 - signierte 8-Bit-Samples. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16 oder AUDIO_U16LSB - wird nicht von der gesamten Hardware unterstützt (vorzeichenlose 16-Bit-Low-Byte-Reihenfolge). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16 oder AUDIO_S16LS - nicht von der gesamten Hardware unterstützt (16-Bit mit alter Bytereihenfolge) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16MSB - nicht von der gesamten Hardware unterstützt (vorzeichenloser 16-Bit-Big-Endian). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16MS - wird nicht von der gesamten Hardware unterstützt (16-Bit mit hoher Bytereihenfolge). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16SYS: entweder AUDIO_U16LSB oder AUDIO_U16MSB - je nach Hardwareprozessor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16SYS: entweder AUDIO_S16LSB oder AUDIO_S16MSB - je nach Hardwareprozessor.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundstruktur für Ereignisse. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Art des Ereignisses. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktiv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Aktivierungsereignis (siehe SDL_ActiveEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Tastaturereignis (siehe SDL_KeyboardEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Mausbewegungsereignis (siehe SDL_MouseMotionEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltfläche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Mausklickereignis (siehe SDL_MouseButtonEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jaxis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Bewegungsereignis der Joystickachse (siehe SDL_JoyAxisEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jball</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Joystick-Trackball-Bewegungsereignis (siehe SDL_JoyBallEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jhat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Joystick-Header-Bewegungsereignis (siehe SDL_JoyHatEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jbutton</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ereignis beim Drücken der Joystick-Taste (siehe SDL_JoyButtonEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe ändern</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Ereignis zur Größenänderung des Anwendungsfensters (siehe SDL_ResizeEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ereignis zum Öffnen des Anwendungsfensters (siehe SDL_ExposeEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anwendungs-Exit-Anforderungsereignis (siehe SDL_QuitEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Benutzerereignis (siehe SDL_UserEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syswm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : undefiniertes Fenstermanagerereignis (siehe SDL_SysWMEvent). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Arten von Ereignissen. Siehe SDL - </font><font style="vertical-align: inherit;">Dokumentation Weitere Informationen :. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ACTIVEEVENT SDL_ActiveEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_KEYDOWN / UP SDL_KeyboardEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEMOTION SDL_MouseMotionEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEBUTTONDOWN / UP SDL_MouseButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYAXISMOTION SDL_JoyAxisEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBALLMOTION SDL_JoyBallEvent</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JoyHatEvent SDL_JOYHATMOTION </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBUTTONDOWN / UP SDL_JoyButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEORESIZE SDL_ResizeEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEOEXPOSE SDL_ExposeEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Quit SDL_QuitEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_USEREVENT SDL_UserEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SYSWMEVENT SDL_SysWMEvent</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
YUV-Overlay. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Überlagerungsformat (siehe unten). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Breite / Höhe der Überlagerung. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flugzeuge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Anzahl der zu überlagernden Pläne. Normalerweise entweder 1 oder 3. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tonhöhen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : eine Reihe von Einrückungen, eine für jeden Plan. Einzug ist die Länge der Zeichenfolge in Bytes. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ein Array von Datenzeigern für jeden Plan. Die Überlagerung muss gesperrt sein, bevor diese Zeiger verwendet werden können. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hw_overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">Wird</font></b><font style="vertical-align: inherit;"> auf 1 gesetzt, wenn das Overlay hardwarebeschleunigt ist.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der rechteckige Bereich. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sint16 x, y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Position der oberen linken Ecke des Rechtecks. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint16 w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Breite und Höhe des Rechtecks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Rect definiert einen rechteckigen Pixelbereich. Es wird von SDL_BlitSurface verwendet, um Blitting-Bereiche und einige andere Videofunktionen zu identifizieren.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grafische Struktur der Außenseite (Oberfläche). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint32-Flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Flags der externen Stotrons. Nur zum Lesen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PixelFormat * -Format</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : schreibgeschützt. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Breite und Höhe. Nur zum Lesen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint16 Tonhöhe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Schritt. Nur zum Lesen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * pixels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ein Zeiger auf die tatsächlichen Pixeldaten. Nur zur Aufnahme. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Rect clip_rect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die rechteckige Außenseite des Clips. Nur zum Lesen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int refcount</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">Wird</font></b><font style="vertical-align: inherit;"> zum </font><b><font style="vertical-align: inherit;">Zuweisen</font></b><font style="vertical-align: inherit;"> von Speicher verwendet. Meistens zum Lesen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur enthält auch private Felder, die hier nicht angezeigt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Surface repräsentiert einen Bereich des "grafischen" Speichers, der gezeichnet werden kann. Der Videopufferrahmen wird mit SDL_SetVideoMode und SDL_GetVideoSurface als SDL_Surface zurückgegeben. Die Felder w und h sind Werte, die die Breite und Höhe der Oberfläche in Pixel darstellen. Das Pixelfeld ist ein Zeiger auf die tatsächlichen Pixeldaten. Hinweis: Die Oberfläche muss gesperrt sein (über SDL_LockSurface), bevor auf dieses Feld zugegriffen werden kann. Das Feld clip_rect ist das von SDL_SetClipRect festgelegte abgeschnittene Rechteck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Flag-Feld unterstützt die folgenden ODER-Werte: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE - Die Außenseite wird im Systemspeicher gespeichert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE - Die Außenseite wird im Videospeicher gespeichert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT - Die Außenseite verwendet nach Möglichkeit asynchrone Blendung.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT - Jedes Pixelformat (Anzeigefläche) ist zulässig. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE - Die Oberfläche verfügt über eine exklusive Palette. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF - doppelt gepufferte Oberfläche (Anzeigefläche). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN - Vollbildfläche (Anzeigefläche). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL - Die Oberfläche hat einen OpenGL-Kontext (Anzeigefläche). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT - Die Oberfläche unterstützt das Blining von OpenGL (Anzeigefläche). HINWEIS. Diese Option dient nur der Kompatibilität und wird für neuen Code nicht empfohlen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABLE - Die Größenänderung ist für eine Oberfläche (Anzeigefläche) möglich. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWACCEL - Surface Blit verwendet Hardwarebeschleunigung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCCOLORKEY - Oberflächlichkeit verwendet Farbblitting.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RLEACCEL - Farbblitting wird mit RLE beschleunigt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCALPHA - Surface Blyth verwendet Alpha-Blending. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_PREALLOC - Die Oberfläche verwendet vorab zugewiesenen Speicher.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Thread</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur ist systemunabhängig und muss wahrscheinlich nicht verwendet werden. </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie unter src / thread / sdl_thread_c.h im Quellcode.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_cond</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur ist systemunabhängig und muss wahrscheinlich nicht verwendet werden. </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie im Quellcode unter src / thread / &lt;system&gt; /SDL_syscond.c.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_mutex</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur ist systemunabhängig und muss wahrscheinlich nicht verwendet werden. </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie im Quellcode unter src / thread / &lt;system&gt; /SDL_sysmutex.c.</font></font><a name="links"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Anhang 2. Datenstrukturen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑</font></font></a></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/ts/cs/ro/tscsrofdmymu7o1rbml2evolway.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein FFmpeg- und SDL-Tutorial oder Schreiben eines Videoplayers in weniger als 1000 Zeilen </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">FFmpeg HomePage </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">SDL HomePage</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/z0/e1/6o/z0e16ozcekig9i8jdthljdqpgga.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="60" height="30" src="https://habrastorage.org/webt/js/4n/23/js4n231ba7glkow_nud5i3dsveq.png"> </a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie auch im Blog der Firma EDISON:</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg libav Handbuch</font></font></b></a><br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502834/index.html">So werden Sie in sechs Monaten oder noch schneller DevOps-Ingenieur. Teil 5. Bereitstellung</a></li>
<li><a href="../de502836/index.html">Unity Editor Adventures: Serialisierte Matroschka</a></li>
<li><a href="../de502838/index.html">Was ist der Unterschied zwischen IT- und digitalen Berufen: digitale Transformation und Expertenmeinungen</a></li>
<li><a href="../de502840/index.html">Glänzender 3D EinScan Pro 2X Plus 3D-Scanner Test</a></li>
<li><a href="../de502842/index.html">So schützen Sie biometrische Benutzerdaten vor krimineller Verwendung</a></li>
<li><a href="../de502846/index.html">Zuckerberg startete Geschäfte. Instagram und Facebook werden nach und nach zu Läden.</a></li>
<li><a href="../de502852/index.html">Warum widersetzen sich Menschen Veränderungen und wie können sie ihnen beim Wiederaufbau helfen?</a></li>
<li><a href="../de502854/index.html">Warum schlagen ERP-Implementierungen fehl?</a></li>
<li><a href="../de502860/index.html">Transport am 20. Mai: Eine rasche Erholung der Luftfahrt ist sichtbar</a></li>
<li><a href="../de502862/index.html">LabVIEW NXG - Grundlagen der Frontplatte - Bedienelemente und Anzeigen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>