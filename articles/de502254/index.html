<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèΩ üéÅ ü§úüèª PostgreSQL: Serverseitige Programmierung in der menschlichen Sprache (PL / Perl, PL / Python, PL / v8) üõ∂ üë®üèΩ‚Äçüî¨ üç¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgres ist ber√ºhmt f√ºr seine Erweiterbarkeit, die auch f√ºr die Unterst√ºtzung von prozeduralen Sprachen (PL) gilt. Niemand kann sich einer Sprache mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL: Serverseitige Programmierung in der menschlichen Sprache (PL / Perl, PL / Python, PL / v8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres ist ber√ºhmt f√ºr seine Erweiterbarkeit, die auch f√ºr die Unterst√ºtzung von prozeduralen Sprachen (PL) gilt. Niemand kann sich einer </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprache mit einer</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Liste von Sprachen dieser L√§nge </font><font style="vertical-align: inherit;">r√ºhmen </font><font style="vertical-align: inherit;">, und m√∂glicherweise ist diese Liste √ºberhaupt nicht beschr√§nkt: Um die Sprache mit dem Server zu verbinden, ist kein zus√§tzlicher Aufwand erforderlich. Sie k√∂nnen sogar Ihre eigene Sprache erstellen und sie zu einer prozeduralen Serversprache machen. √Ñnderungen im DBMS erfordern dies nicht. Wie so viel mehr wurde diese Erweiterbarkeit von Anfang an in die Postgres-Architektur integriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist m√∂glich und manchmal notwendig, PL-Sprachen f√ºr Aufgaben zu schreiben. Besser noch, wenn jemand ein solches Framework zum Schreiben von Sprachen schreibt, damit Sie nicht in C schreiben k√∂nnen, sondern eine Sprache w√§hlen, die f√ºr einen Sprachentwickler komfortabler ist. Wie bei FDW, das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Python geschrieben werden kann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel wurde auf der Grundlage einer Reihe von Berichten und Meisterkursen zu diesem Thema verfasst, die der Autor auf den Konferenzen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017 verfasst hat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier geht es nicht um Exotik, sondern um die g√§ngigsten prozeduralen Sprachen PL / Perl, PL / Python und PL / V8 (d. H. JavaScript) und den Vergleich ihrer F√§higkeiten mit PL / pgSQL.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wann lohnt es sich, diese Sprachen zu verwenden? </font><font style="vertical-align: inherit;">Wann fehlen SQL und PL / pgSQL?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann, wenn Sie mit komplexen Strukturen arbeiten m√ºssen, mit Algorithmen: zum Beispiel B√§ume durchlaufen oder wenn HTML- oder XML-Analyse erforderlich ist, insbesondere wenn Sie sie aus Archiven extrahieren;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie komplexes SQL (Berichte, ORM) dynamisch generieren m√ºssen. </font><font style="vertical-align: inherit;">Unter PL / pgSQL ist dies nicht nur unpraktisch, sondern funktioniert in einigen F√§llen auch langsamer.</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   ‚Äî    .   , ,   untrusted- (  ‚Äî . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und noch etwas: Wenn Sie etwas in C schreiben m√∂chten, k√∂nnen Sie einen Prototyp in diesen Sprachen erstellen, der f√ºr eine schnelle Entwicklung besser geeignet ist.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So binden Sie eine Sprache in Postgres ein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Sprache zu implementieren, die Sie ben√∂tigen: Schreiben Sie in C eine bis drei Funktionen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER - ein Call-Handler, der eine Funktion in der Sprache ausf√ºhrt (dies ist ein erforderlicher Teil);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE - anonymer Blockhandler (wenn die Sprache anonyme Bl√∂cke unterst√ºtzen soll);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VALIDATOR - Code√ºberpr√ºfungsfunktion beim Erstellen einer Funktion (wenn diese √úberpr√ºfung durchgef√ºhrt werden soll).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wird in der Dokumentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausf√ºhrlich beschrieben </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Sprachen aus der Box" und andere Sprachen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nur vier Sprachen, die "out of the box" unterst√ºtzt werden: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tcl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber das Kitzeln ist eher eine Hommage an die Geschichte: </font><font style="vertical-align: inherit;">Nur </font><font style="vertical-align: inherit;">wenige Leute verwenden es jetzt, wir werden nicht mehr dar√ºber sprechen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl, PL / Python und nat√ºrlich PL / pgSQL werden von der Postgres-Community unterst√ºtzt. Die Unterst√ºtzung f√ºr andere, sofort einsatzbereite Sprachen liegt bei ihren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betreuern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Unternehmen, Communitys oder bestimmten Entwicklern, die daran interessiert sind, dass die Sprache im DBMS funktioniert. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√∂rdert Google. Aber von Zeit zu Zeit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt es Gr√ºnde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bezweifle die wolkenlose Zukunft von PL / V8. Der aktuelle PL / V8-Projektbetreuer von Google, Jerry Sievert, erw√§gt die serverbasierte JS-Unterst√ºtzung auf Postgres-Basis, die auf einer anderen Engine (wie QuickJS) basiert, da PL / V8 schwierig zu erstellen ist und 3 bis 5 GB erfordert Alle m√∂glichen Dinge unter Linux beim Erstellen, und dies f√ºhrt h√§ufig zu Problemen auf verschiedenen Betriebssystemen. Der PL / V8 ist jedoch weit verbreitet und gr√ºndlich getestet. Es ist m√∂glich, dass PL / JS als Alternative zu einer anderen JS-Engine oder vorerst nur als Name erscheint, an den wir uns w√§hrend der √úbergangszeit gew√∂hnen werden. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird selten verwendet. Ich pers√∂nlich musste nicht in PL / Java schreiben, da in PL / Perl und in PL / V8 gen√ºgend Funktionen f√ºr fast alle Aufgaben vorhanden sind. Selbst Python f√ºgt keine besonderen Funktionen hinzu. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ºtzlich f√ºr diejenigen, die Statistiken m√∂gen und diese Sprache lieben. Wir werden auch hier nicht √ºber ihn sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beliebte Sprachen sind beim Schreiben von Speichern nicht unbedingt beliebt: Es gibt PL / PHP, aber jetzt wird es praktisch von niemandem unterst√ºtzt - es gibt nur wenige, die Serverprozeduren darauf schreiben m√∂chten. F√ºr die PL / Ruby-Sprache ist das Bild irgendwie das gleiche, obwohl die Sprache moderner zu sein scheint. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Go-basierte prozedurale Sprache wird entwickelt, siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und anscheinend auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es wird notwendig sein, sie zu studieren. F√ºr hartn√§ckige Fans der Shell gibt es sogar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es ist schwer vorstellbar, wof√ºr es sein k√∂nnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt mindestens eine dom√§nenspezifische prozedurale Sprache (DSL), die eng auf ihre Aufgabe spezialisiert ist - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das fr√ºher sehr beliebt war, um die Serverlast zu vertreten und auszugleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden die wichtigsten, am h√§ufigsten verwendeten Sprachen behandelt. Dies ist nat√ºrlich PL / PgSQL, PL / Perl, PL / Python und PL / V8, wir werden sie unten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / * nennen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sprachen ‚Äûout of the box‚Äú werden fast buchst√§blich sofort installiert - normalerweise ist die Installation schmerzlos. Um PL / V8 zu installieren, ist dies fast eine Leistung, wenn Sie im Repository Ihres Betriebssystems kein Paket mit der erforderlichen Version gefunden haben, da Sie daf√ºr tats√§chlich die gesamte V8 oder mit anderen Worten Chromium erstellen m√ºssen. Gleichzeitig wird die gesamte Entwicklungsinfrastruktur zusammen mit V8 selbst von google.com heruntergeladen - rechnen Sie mit ein paar Gigabyte Datenverkehr. F√ºr Postgres 11 unter Ubuntu ist das PL / V8-Paket noch nicht erschienen. Bisher ist nur V8 f√ºr PG 10 im Repository verf√ºgbar. Wenn Sie m√∂chten, stellen Sie es von Hand zusammen. Es ist auch wichtig, dass die Version, die Sie im Repository finden, h√∂chstwahrscheinlich ziemlich alt ist. Zum Zeitpunkt der Ver√∂ffentlichung des Artikels ist die neueste Version 2.3.14.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Sprache selbst installiert wurde, m√ºssen Sie auch die Sprache ‚Äûerstellen‚Äú - im Systemverzeichnis registrieren. </font><font style="vertical-align: inherit;">Dies sollte vom Team durchgef√ºhrt werden.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Anstelle von plperl k√∂nnen Sie den Namen einer anderen Sprache ersetzen, es gibt bestimmte Nuancen, siehe unten). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schauen uns an, was passiert ist:</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL muss nicht speziell erstellt werden, es befindet sich immer bereits in der Datenbank. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachtung! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL sollte nicht mit SQL verwechselt werden. </font><font style="vertical-align: inherit;">Dies ist eine andere Sprache. </font><font style="vertical-align: inherit;">Postgres kann jedoch auch Funktionen in einfachem SQL schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standards</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Welt von DBMS wird h√§ufig √ºber die Einhaltung von SQL-Standards gesprochen. </font><font style="vertical-align: inherit;">Verfahrenssprachen haben auch Standards, √ºber die jedoch nicht so oft gesprochen wird. </font><font style="vertical-align: inherit;">Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / PSM-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standard </font><font style="vertical-align: inherit;">ist in hohem Ma√üe mit der prozeduralen Sprache DB2 kompatibel. </font><font style="vertical-align: inherit;">Die Implementierung ist weit entfernt von PL / pgSQL, obwohl sie konzeptionell nahe beieinander liegen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Standard f√ºr Java-Prozeduren, und PL / Java </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">passt</font></a><font style="vertical-align: inherit;"> gut dazu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertrauensw√ºrdige und nicht vertrauensw√ºrdige Sprachen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres-Verfahrenssprachen sind vertrauensw√ºrdig (VERTRAUEN) und nicht vertrauensw√ºrdig (NICHT VERTRAUEN). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In VERTRAUENEN Sprachen gibt es keine M√∂glichkeit der direkten Arbeit mit E / A, einschlie√ülich des Netzwerks, und tats√§chlich mit Systemressourcen. Daher k√∂nnen solche Funktionen von jedem Datenbankbenutzer erstellt werden, etwas verderben und er wird nicht in der Lage sein, zu viel zu lernen. Funktionen in UNTRUSTED-Sprachen k√∂nnen nur von einem Supervisor erstellt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Sprachinterpreter solche Einschr√§nkungen unterst√ºtzt, k√∂nnen damit sowohl vertrauensw√ºrdige als auch nicht vertrauensw√ºrdige Sprachen erstellt werden. Also mit Perl gibt es also verschiedene Sprachen </font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Buchstabe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende gibt es den nicht vertrauensw√ºrdigen Charakter der Sprache aus. </font><font style="vertical-align: inherit;">Python existiert nur in einer nicht vertrauensw√ºrdigen Version. </font><font style="vertical-align: inherit;">PL / v8 - im Gegenteil, nur in vertrauensw√ºrdigen. </font><font style="vertical-align: inherit;">Infolgedessen kann PL / v8 keine Module oder Bibliotheken von der Festplatte laden, sondern nur von der Datenbank. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Funktion in der Sprache UNTRUSTED kann alles: Senden einer E-Mail, Pingen einer Site, Anmelden bei einer fremden Datenbank und Ausf√ºhren einer HTTP-Anforderung. </font><font style="vertical-align: inherit;">VERTRAUENE Sprachen beschr√§nken sich auf die Verarbeitung von Daten aus der Datenbank. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu VERTRAUEN geh√∂ren : </font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von UNTRUSTED geh√∂ren : </font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie: Es gibt kein PL / Python wie TRUSTED (da Sie dort keine Einschr√§nkungen f√ºr den Zugriff auf Ressourcen festlegen k√∂nnen), und PLpgSQL und PL / V8 sind umgekehrt: Sie sind nicht UNTRUSTED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl und Java sind jedoch in beiden Versionen verf√ºgbar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL vs PL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL-Code funktioniert nativ mit allen Datentypen, die Postgres hat. Andere Sprachen haben nicht viele Postgres-Typen, und der Sprachinterpreter sorgt daf√ºr, dass die Daten in eine interne Darstellung der Sprache konvertiert werden und obskure Typen durch Text ersetzt werden. Ihm kann jedoch mit Hilfe von TRANSFORM geholfen werden, wor√ºber ich am Ende des Artikels sprechen werde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionsaufrufe in PL / pgSQL sind oft teurer. Funktionen in anderen Sprachen k√∂nnen auf ihre Bibliotheken zugreifen, ohne den Systemkatalog zu lesen. PL / pgSQL kann so nicht funktionieren. Einige Abfragen in PL / pgSQL funktionieren lange Zeit, da viele Typen unterst√ºtzt werden: Um zwei Ganzzahlen hinzuzuf√ºgen, muss der Interpreter erkennen, dass es sich um Ganzzahlen und nicht um einige andere exotische Typen handelt, und dann entscheiden wie man sie faltet und erst danach faltet man sie tats√§chlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da PL / pgSQL VERTRAUEN ist, k√∂nnen Sie nicht mit dem Netzwerk und den Festplatten davon arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es um die Arbeit mit verschachtelten Datenstrukturen geht, verf√ºgt PL / pgSQL nur √ºber Postgres-Tools f√ºr die Arbeit mit JSON, die sehr umst√§ndlich und unproduktiv sind. In anderen Sprachen ist die Arbeit mit verschachtelten Strukturen viel einfacher und wirtschaftlicher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / * verf√ºgt √ºber eine eigene Speicherverwaltung, und Sie m√ºssen den Speicher √ºberwachen oder m√∂glicherweise einschr√§nken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sollten die Fehlerbehandlung sorgf√§ltig √ºberwachen, die auch f√ºr alle unterschiedlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / * gibt es jedoch einen globalen Interpreter-Kontext, der beispielsweise zum Zwischenspeichern von Daten einschlie√ülich Abfragepl√§nen verwendet werden kann. </font><font style="vertical-align: inherit;">Wenn die Sprache NICHT VERTRAUEN ist, sind das Netzwerk und die Laufwerke verf√ºgbar. </font><font style="vertical-align: inherit;">Alle diese Sprachen arbeiten in der Regel √ºber das SPI mit der Datenbank, aber dazu sp√§ter mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die Funktionen der PL / * -Sprachen genauer betrachten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Perl-Interpreter ist ein umfangreicher Code im Speicher, der jedoch gl√ºcklicherweise nicht beim √ñffnen der Verbindung erstellt wird, sondern nur beim Starten der ersten gespeicherten Prozedur / Funktion PL / Perl. </font><font style="vertical-align: inherit;">Bei der Initialisierung wird der in den Postgres-Konfigurationsparametern angegebene Code ausgef√ºhrt. </font><font style="vertical-align: inherit;">Normalerweise werden Module geladen und Vorberechnungen durchgef√ºhrt. </font><font style="vertical-align: inherit;">
Wenn Sie der Konfigurationsdatei hinzugef√ºgt haben, w√§hrend die Datenbank ausgef√ºhrt wird, lassen Sie Postgres die Konfiguration erneut lesen. </font><font style="vertical-align: inherit;">In diesem Artikel verwenden die Beispiele ein Modul </font><font style="vertical-align: inherit;">zur Visualisierung von Datenstrukturen. </font><font style="vertical-align: inherit;">
Es gibt Parameter f√ºr die separate Initialisierung von TRUSTED und UNTRUSTED Perl und nat√ºrlich einen Parameter </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diejenigen, die in Perl programmieren, wissen, dass ohne Perl </font><font style="vertical-align: inherit;">keine Sprache, sondern ein Missverst√§ndnis ist.</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darin wird der Interpreter beim ersten Zugriff auf dieselbe Weise erstellt. Und hier ist es wichtig, sofort zu entscheiden, welche Python Sie wollen: zweite oder dritte. Wie Sie wissen, gibt es Python in zwei g√§ngigen Versionen (Python 2 und Python 3), aber das Problem ist, dass ihre So-Shki nicht in einem Prozess miteinander auskommen: Es gibt einen Namenskonflikt. Wenn Sie in einer Sitzung mit v2 gearbeitet und dann v3 aufgerufen haben, st√ºrzt Postgres ab, und f√ºr den Serverprozess (Backend) ist dies ein schwerwiegender Fehler. Um auf eine andere Version zuzugreifen, m√ºssen Sie eine andere Sitzung √∂ffnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu Perl kann Python w√§hrend der Initialisierung nicht gesagt werden, was zu tun ist. Eine weitere Unannehmlichkeit: Einzeiler sind unpraktisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In allen Python-Funktionen sind zwei W√∂rterb√ºcher definiert - statisch </font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und global </font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Global </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erlaubt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenaustausch mit allen Funktionen in einem Backend - was gleichzeitig attraktiv und gef√§hrlich ist. </font><font style="vertical-align: inherit;">Jede Funktion verf√ºgt √ºber ein statisches W√∂rterbuch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Python k√∂nnen Sie Subtransaktionen durchf√ºhren, die im Folgenden erl√§utert werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nur vertrauensw√ºrdig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Praktischerweise werden JSON-Daten automatisch in eine JS-Struktur konvertiert. In PL / V8 k√∂nnen Sie wie in PL / Python Subtransaktionen durchf√ºhren. Es gibt eine Schnittstelle f√ºr vereinfachte Funktionsaufrufe. Dies ist die einzige fragliche prozedurale Sprache, in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fensterfunktionen definiert werden k√∂nnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie schlagen vor, dass sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in PL / R definiert werden k√∂nnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber diese Sprache liegt au√üerhalb des Geltungsbereichs dieses Artikels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und nur in PL / V8 gibt es ein Ausf√ºhrungszeitlimit. Richtig, es ist nicht standardm√§√üig aktiviert. Wenn Sie PL / V8 von Hand erstellen, m√ºssen Sie angeben, dass es w√§hrend der Assembly aktiviert wurde. Anschlie√üend k√∂nnen Sie mit dem Konfigurationsparameter Zeit√ºberschreitungen f√ºr Funktionsaufrufe festlegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung in PL / V8 sieht interessant aus: Da es vertrauensw√ºrdig ist, kann es die Bibliothek nicht von der Festplatte lesen und nichts von irgendwoher laden. </font><font style="vertical-align: inherit;">Er kann alles, was er braucht, nur von der Basis nehmen. </font><font style="vertical-align: inherit;">Daher wird eine gespeicherte Initialisierungsfunktion definiert, die beim Start des Sprachinterpreters aufgerufen wird. </font><font style="vertical-align: inherit;">Der Funktionsname wird in einem speziellen Konfigurationsparameter angegeben:</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Initialisierung k√∂nnen globale Variablen und Funktionen erstellt werden, indem ihre Werte den Attributen dieser Variablen zugewiesen werden. </font><font style="vertical-align: inherit;">Zum Beispiel so:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich von PL / Perl gegen PL / Python gegen PL / V8 in der Praxis</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Welt!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns eine einfache √úbung mit der Ausgabe dieser Phrase in allen drei Sprachen durchf√ºhren, zuerst in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und lassen Sie ihn etwas anderes N√ºtzliches tun, zum Beispiel, sagt seine Version:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen auch die √ºblichen Perl-Funktionen </font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Genauer gesagt auf PL / Python3u (nicht vertrauensw√ºrdig) - f√ºr die Bestimmtheit.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kann verwenden </font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt viele Dinge, die Sie aus Postgres-Nachrichten extrahieren k√∂nnen: Sie enthalten Hinweis, Details, Zeilennummer und viele andere Parameter. </font><font style="vertical-align: inherit;">In PL / Python k√∂nnen sie √ºbergeben werden, jedoch nicht in den anderen betrachteten Sprachen: Ihre Mittel k√∂nnen nur mit einer einfachen Textzeile verflucht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Python hat jede Postgres-Protokollierungsstufe ihre eigene Funktion: HINWEIS, WARNUNG, DEBUG, LOG, INFO, FATAL. </font><font style="vertical-align: inherit;">Wenn es sich um ERROR handelt, ist die Transaktion gefallen. Wenn FATAL, ist das gesamte Backend gefallen. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise erreichte die Angelegenheit PANIC nicht. </font><font style="vertical-align: inherit;">Sie k√∂nnen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier lesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In dieser Sprache ist Hello World Pearl sehr √§hnlich. </font><font style="vertical-align: inherit;">Sie k√∂nnen die </font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung </font><font style="vertical-align: inherit;">beenden </font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dies ist auch eine Fehlerbehandlung, obwohl die Tools nicht so fortgeschritten sind wie in Python. </font><font style="vertical-align: inherit;">Wenn du schreibst</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Effekt wird √ºbrigens der gleiche sein.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeite mit der Basis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun wollen wir sehen, wie man mit einer Datenbank aus gespeicherten Prozeduren arbeitet. Postgres verf√ºgt √ºber eine SPI (Server Programming Interface). Dies ist eine Reihe von C-Funktionen, die allen Autoren von Erweiterungen zur Verf√ºgung stehen. Fast alle PL-Sprachen bieten Wrapper f√ºr SPI, aber jede Sprache macht es ein bisschen anders. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine in C geschriebene Funktion, die jedoch SPI verwendet, bietet im Vergleich zu PL / PgSQL und anderen prozeduralen Sprachen wahrscheinlich keine signifikanten Vorteile. Eine C-Funktion, die SPI umgeht und beispielsweise mit Daten ohne Zwischenh√§ndler arbeitet, arbeitet </font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedoch um eine Gr√∂√üenordnung schneller.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Java verwendet auch SPI. Die Arbeit mit der Datenbank erfolgt jedoch weiterhin im Stil von JDBC und des JDBC-Standards. F√ºr den Ersteller von Code in PL / Java geschieht alles so, als w√ºrden Sie von einer Clientanwendung aus arbeiten, aber JNI (Java Native Interface) √ºbersetzt Aufrufe an die Datenbank in dieselben SPI-Funktionen. Es ist praktisch und es gibt keine grundlegenden Hindernisse, um dieses Prinzip in PL / Perl und PL / Python zu √ºbersetzen, aber aus irgendeinem Grund wurde dies nicht getan und ist bisher in den Pl√§nen nicht sichtbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie m√∂chten, k√∂nnen Sie nat√ºrlich auf die √ºbliche Weise zu ausl√§ndischen St√ºtzpunkten gehen - √ºber DBI oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es ist m√∂glich, lokale Datenbank, aber warum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich nicht mit dem ganzheitlichen Thema "Prozess in der Basis vs. Prozess auf dem Client" befassen und sofort von der maximalen Verarbeitung n√§her an den Daten fortfahren (zumindest, um keine riesigen Proben √ºber das Netzwerk zu √ºbertragen), ist die L√∂sung f√ºr die Verwendung der auf dem Server gespeicherten Funktionen eine gute Wahl nat√ºrlich. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Beachten Sie, dass SPI einen gewissen Overhead hat und SQL-Abfragen in Funktionen m√∂glicherweise langsamer sind als ohne Funktionen. Das 13. Postgres enthielt einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patch von Konstantin Knizhnik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der diese Kosten reduziert. Die Verarbeitung von Abfrageergebnissen in einer gespeicherten Funktion erfordert jedoch nat√ºrlich nicht die √úbertragung des Ergebnisses an den Client und kann daher hinsichtlich der Leistung vorteilhaft sein. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherheit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Eine Reihe von debuggten und getesteten Funktionen isoliert die Datenbankstruktur vom Benutzer und sch√ºtzt vor SQL-Injektionen und anderem Unfug. </font><font style="vertical-align: inherit;">Andernfalls bleibt es jedem Anwendungsentwickler Kopfschmerzen. </font><font style="vertical-align: inherit;">Wiederverwendung von </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn eine gro√üe Anzahl komplexer Anwendungen mit der Datenbank arbeiten, ist es praktisch, n√ºtzliche Funktionen auf dem Server zu speichern, anstatt sie in jeder Anwendung erneut zu schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie und in welcher Form erhalten wir Daten aus der Datenbank</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist alles einfach und klar. </font><font style="vertical-align: inherit;">Der Aufruf </font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt die Anzahl der verarbeiteten Zeilen, den Status und das von der SQL-Abfrage ausgew√§hlte Zeilenarray zur√ºck:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python sehen die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abfrage und das Ergebnis ungef√§hr so ‚Äã‚Äãaus, aber hier gibt die Funktion keine Datenstruktur zur√ºck, sondern ein spezielles Objekt, mit dem Sie auf verschiedene Arten arbeiten k√∂nnen. </font><font style="vertical-align: inherit;">Normalerweise gibt es vor, ein Array zu sein, und dementsprechend k√∂nnen Sie Zeichenfolgen daraus extrahieren.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt nehmen wir die erste Zeile, verlassen X und erhalten den Wert - die Zahl.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Struktur zu sehen, haben wir die Bibliotheksfunktion JSON.stringify verwendet, die nicht speziell geladen werden muss. Sie ist standardm√§√üig bereits als Teil von PL / v8 einsatzbereit. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschirmung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um b√∂swillige SQL-Injektionen zu vermeiden, m√ºssen einige Zeichen in Abfragen maskiert werden. Dazu gibt es zum einen SPI-Funktionen und entsprechende Funktionen (in C geschrieben) in Sprachen, die wie SPI-Wrapper funktionieren. Zum Beispiel in PL / Perl: </font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nimmt Apostrophe auf und verdoppelt 'und \. Entwickelt f√ºr das Screening von Textdaten. </font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- gleich, aber </font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in NULL konvertiert. </font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- zitiert gegebenenfalls den Namen der Tabelle oder des Feldes. N√ºtzlich, wenn Sie eine SQL-Abfrage erstellen und die Namen der darin enthaltenen Datenbankobjekte ersetzen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie: Der Tabellenname darf nicht wie eine Textzeile maskiert werden. </font><font style="vertical-align: inherit;">Deshalb gibt es eine Funktion </font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Perl gibt es jedoch andere Funktionen zum Abschirmen von Daten einzelner Post-Gres-Typen: </font><font style="vertical-align: inherit;">
Eine Funktion </font><font style="vertical-align: inherit;">sollte jeden Typ akzeptieren und atypische zweifelhafte Zeichen in etwas offensichtlich Sicheres verwandeln. </font><font style="vertical-align: inherit;">Es funktioniert mit einer Vielzahl von Typen, aber dennoch nicht mit allen. </font><font style="vertical-align: inherit;">Sie wird beispielsweise </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Bereichstypen</font></a><font style="vertical-align: inherit;"> nicht verstehen </font><font style="vertical-align: inherit;">und sie einfach als Textzeichenfolgen wahrnehmen.</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt </font><font style="vertical-align: inherit;">es drei √§hnliche Funktionen, die </font><font style="vertical-align: inherit;">auf </font><font style="vertical-align: inherit;">die gleiche Weise funktionieren:</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sind die Funktionen in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na sicher! </font><font style="vertical-align: inherit;">Bis auf syntaktische Merkmale ist alles gleich.</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Welche Sprache ist die schnellste? Normalerweise antworten sie: C. Aber die richtige Antwort ist C </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL. Warum SQL? Tatsache ist, dass eine Funktion in dieser Sprache nicht immer explizit ausgef√ºhrt wird. Es kann in die Anforderung eingebettet werden (der Scheduler bettet die Funktion in den Hauptteil der Hauptanforderung ein), kann mit der Anforderung gut optimiert werden und das Ergebnis ist schneller. Aber unter welchen Bedingungen kann Code in eine Anfrage eingebettet werden? Es gibt ein paar einfache Bedingungen , </font><font style="vertical-align: inherit;">dass Sie lesen k√∂nnen, sagen wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Beispielsweise sollte eine Funktion nicht mit den Rechten des Eigent√ºmers ausgef√ºhrt werden (um SECURITY DEFINER zu sein). Die meisten einfachen Funktionen passen zu diesen Bedingungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden wir "am Knie" messen, nicht ernsthaft. Wir brauchen einen groben Vergleich. Schalten Sie zuerst das Timing ein:</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir es mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Die Ausf√ºhrungszeiten der folgenden Befehle sind die gerundeten Durchschnittswerte, die der Autor auf einem entladenen sechs Jahre alten PC erhalten hat. Sie k√∂nnen miteinander verglichen werden, erheben jedoch keinen Anspruch auf Wissenschaftlichkeit):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es funktioniert sehr schnell. </font><font style="vertical-align: inherit;">In anderen Sprachen wird Zeit damit verschwendet, Funktionen aus der Sprache aufzurufen. </font><font style="vertical-align: inherit;">Nat√ºrlich wird die Anforderung beim ersten Mal aufgrund der Initialisierung des Interpreters langsamer ausgef√ºhrt. </font><font style="vertical-align: inherit;">Dann stabilisiert es sich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir es mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war Python 2. Jetzt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (R√ºckruf: Python2 und Python3 leben nicht friedlich in derselben Sitzung, ein Namenskonflikt ist m√∂glich):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schlie√ülich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es ist irgendwie sehr schnell. </font><font style="vertical-align: inherit;">Versuchen wir, die Abfrage 1000 Mal oder 1 Million Mal auszuf√ºhren. Pl√∂tzlich wird der Unterschied deutlicher: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass das Experiment mit PL / V8 mit tausend und nicht mit einer Million Iterationen durchgef√ºhrt wurde. Mit moderaten Ressourcen wird der PL / V8 in einem Zyklus von 1 Million Operationen den gesamten Speicher verbrauchen und das Auto vollst√§ndig aufh√§ngen. Bereits bei tausend Iterationen w√§hlt der Postgres-Prozess 3,5 GB Speicher und 100% Schreibzugriff auf die Festplatte. Tats√§chlich startet postgres die V8-Umgebung und frisst nat√ºrlich Speicher. Nach Ausf√ºhrung der Anfrage wird dieses Turbomonster keinen Speicher mehr zur√ºckgeben. Um Speicher freizugeben, m√ºssen Sie die Sitzung beenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass PL / pgSQL bereits zweimal schneller ist als PL / Perl und PL / Python. PL / V8 ist immer noch etwas dahinter, aber gegen Ende des Artikels wird er teilweise rehabilitiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen zeigen Perl mit Python in diesen Experimenten ungef√§hr die gleichen Ergebnisse. </font><font style="vertical-align: inherit;">Perl war Python fr√ºher etwas unterlegen, in modernen Versionen ist es etwas schneller. </font><font style="vertical-align: inherit;">Die dritte Python ist etwas langsamer als die zweite. </font><font style="vertical-align: inherit;">Der gesamte Unterschied liegt innerhalb von 15%.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung mit PREPARE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leute, die es wissen, werden verstehen: etwas stimmt nicht. </font><font style="vertical-align: inherit;">PL / pgSQL kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abfragepl√§ne automatisch zwischenspeichern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in PL / * jedes Mal, wenn die Abfrage erneut geplant wurde. </font><font style="vertical-align: inherit;">Auf eine gute Weise m√ºssen Sie Anforderungen vorbereiten, einen Anforderungsplan erstellen und dann gem√§√ü diesem Plan so oft wie n√∂tig ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">In PL / * k√∂nnen Sie explizit mit Abfragepl√§nen arbeiten, die wir ab </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versuchen werden </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unseren beiden Sprachen haben wir PL / pgSQL fast eingeholt, w√§hrend die dritte ebenfalls wollte, aber aufgrund der wachsenden Nachfrage nach Speicher nicht die Ziellinie erreichte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wenn Sie das Ged√§chtnis nicht ber√ºcksichtigen, ist es klar, dass alle Sprachen fast Kopf an Kopf gehen - und nicht zuf√§llig. </font><font style="vertical-align: inherit;">Ihr Engpass ist mittlerweile weit verbreitet - die Arbeit mit der Datenbank √ºber SPI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechenleistung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass die Sprachleistung in der Arbeit mit der Datenbank ruht. </font><font style="vertical-align: inherit;">Um Sprachen miteinander zu vergleichen, versuchen wir, etwas zu berechnen, ohne auf die Datenbank zur√ºckzugreifen, z. B. die Summe der Quadrate. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass PL / Perl und PL / Python PL / pgSQL √ºberholt und √ºberholt haben, sie sind viermal schneller. </font><font style="vertical-align: inherit;">Und die Acht zerrei√üt alle! </font><font style="vertical-align: inherit;">Aber ist es wirklich umsonst? </font><font style="vertical-align: inherit;">Oder bekommen wir es f√ºr den Kopf? </font><font style="vertical-align: inherit;">Ja wir werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zahl in JavaScript ist ein Float und das Ergebnis ist schnell, aber nicht genau: 333333833333127550 anstelle von 333333833333500000. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Formel, nach der das genaue Ergebnis </font><font style="vertical-align: inherit;">berechnet wird </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">‚àë = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als √úbung k√∂nnen Sie dies durch mathematische Induktion beweisen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Reihenfolge des Lachens</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Javascript wird </font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer noch ein Float ausgef√ºhrt, kein Int. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotzdem erschien </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2018 in V8 </font><font style="vertical-align: inherit;">, und es kann jetzt sicher gez√§hlt werden, jedoch mit einem Nachteil f√ºr die Geschwindigkeit, da es sich nicht um eine 64-Bit-Ganzzahl handelt, sondern um eine Ganzzahl mit beliebiger Bittiefe. </font><font style="vertical-align: inherit;">In PL / V8 hat diese Innovation jedoch noch nicht getroffen. </font><font style="vertical-align: inherit;">In anderen prozeduralen Sprachen werden beliebige Bitnummern (Analoga von SQL </font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) durch spezielle Bibliotheken unterst√ºtzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Perl gibt es ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math :: BigFloat-Modul</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr Arithmetik mit beliebiger Genauigkeit, und in Python ist das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bigfloat-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket </font><font style="vertical-align: inherit;">ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wrapper </font><font style="vertical-align: inherit;">um die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU MPFR-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistungsfunktionen zum Sortieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein praktisches Beispiel, das den Unterschied in der Leistung der Sortierung nach Funktionen zeigt, wenn diese Funktion in verschiedenen Sprachen geschrieben ist. </font><font style="vertical-align: inherit;">Aufgabe: Sortieren der Textfelder mit den Nummern der Ausgaben des Journals, die wie folgt lauten k√∂nnen:</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Es ist eigentlich eine Zeichenfolge, aber sie beginnt mit einer Zahl, und Sie m√ºssen nach diesen Zahlen sortieren. </font><font style="vertical-align: inherit;">Um korrekt als Zeichenfolgen zu sortieren, erg√§nzen wir den numerischen Teil links mit Nullen, um Folgendes zu erhalten:</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, ich wei√ü, dass dies nicht die einzige L√∂sung f√ºr das Problem ist (und nicht einmal ganz richtig). </font><font style="vertical-align: inherit;">Aber zum Beispiel wird es reichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Typ anzufordern, </font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schreiben wir Funktionen in PL / Perl, SQL, PL / Python und PL / V8, die die Journalnummern in diese Form konvertieren:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In meiner Bibliothek mit 15,5 Tausend Zeitschriftenartikeln dauert eine Abfrage mit einer Funktion in PL / Perl ungef√§hr 64 ms gegen√ºber 120 ms in PL / Python und 200 ms in PL / PgSQL. </font><font style="vertical-align: inherit;">Aber das schnellste - PL / v8: 54ms. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie mit dem Sortieren experimentieren, stellen Sie die erforderliche Menge an Arbeitsspeicher bereit, damit die Sortierung im Speicher abl√§uft (EXPLAIN wird dann angezeigt </font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Die Speichermenge wird durch den Parameter eingestellt </font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnerung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl mag keine geschlungenen Strukturen, er wei√ü nicht, wie man sie reinigt. </font><font style="vertical-align: inherit;">Wenn Sie </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Zeiger auf </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einen </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiger auf haben </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird der Referenzz√§hler niemals zur√ºckgesetzt und der Speicher wird nicht freigegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Garbage Collection-Sprachen haben andere Probleme. </font><font style="vertical-align: inherit;">Es ist beispielsweise nicht bekannt, wann Speicher freigegeben wird oder ob er √ºberhaupt freigegeben wird. </font><font style="vertical-align: inherit;">Oder - wenn Sie sich nicht absichtlich darum k√ºmmern - Sammler werden im ung√ºnstigsten Moment M√ºll sammeln. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt aber auch Speicherverwaltungsfunktionen, die in direktem Zusammenhang mit Postgres stehen. </font><font style="vertical-align: inherit;">Es gibt Strukturen, die SPI zuweist, und Perl erkennt nicht immer, dass sie freigegeben werden m√ºssen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
So geht es NICHT:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so geht es:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Hinrichtung </font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">der Handler </font><font style="vertical-align: inherit;">am Leben, obwohl keine einzige lebende Verbindung zu ihm besteht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist in Ordnung, Sie m√ºssen sich nur an die Notwendigkeit erinnern, Ressourcen explizit freizugeben mit </font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flie√üt nie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der Plan wird automatisch freigegeben:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Gleiche Geschichte wie Perl. </font><font style="vertical-align: inherit;">Es flie√üt nicht so:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‚Äò
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so geht es:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nochmals: Vergessen Sie nicht, Ressourcen freizugeben. </font><font style="vertical-align: inherit;">Hier tut es. </font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es flie√üt nicht:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit zu verstehen, wie Argumente an Funktionen √ºbergeben werden. </font><font style="vertical-align: inherit;">In den Beispielen √ºbergeben wir 4 Parameter mit Typen an die Funktion:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ganze;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Anordnung;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytea und</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie </font><font style="vertical-align: inherit;">
kommen sie zu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird es JSON oder JSONB sein - in diesem Fall macht es keinen Unterschied: Sie erhalten immer noch die Form eines Strings. Dies ist eine Geb√ºhr f√ºr die Vielseitigkeit: Postgres hat viele Typen mit unterschiedlichem Grad an "eingebaut". Vom Entwickler zu verlangen, dass er mit dem neuen Typ sofort Konvertierungsfunktionen f√ºr alle PL / * bereitstellt, w√§re zu viel. Standardm√§√üig werden viele Typen als Zeichenfolgen √ºbergeben. Dies ist jedoch nicht immer praktisch. Sie m√ºssen diese Begriffe analysieren. Nat√ºrlich m√∂chte ich, dass Postgres-Daten sofort in die entsprechenden Perl-Strukturen umgewandelt werden. Standardm√§√üig ist dies nicht der Fall, aber ab 9.6 wurde der TRANSFORM-Mechanismus angezeigt - die M√∂glichkeit, Typkonvertierungsfunktionen zu definieren: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um TRANSFORM zu erstellen, m√ºssen Sie zwei Funktionen in C schreiben: Eine konvertiert Daten eines bestimmten Typs auf die eine Seite, die andere zur√ºck. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass TRANSFORM an vier Stellen funktioniert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim √úbergeben von Parametern an eine Funktion;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei R√ºckgabe eines Funktionswertes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim √úbergeben von Parametern an einen SPI-Aufruf innerhalb einer Funktion;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Erhalt des Ergebnisses des SPI-Aufrufs innerhalb der Funktion.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRANSFORM JSONB f√ºr Perl und Python, entwickelt von Anton Bykov, erschien in der 11. Version von Postgres. </font><font style="vertical-align: inherit;">Jetzt m√ºssen Sie JSONB nicht mehr analysieren, es wird sofort als entsprechende Struktur in Perl √ºbertragen. </font><font style="vertical-align: inherit;">Sie m√ºssen die Erweiterung jsonb_plperl erstellen und k√∂nnen dann TRANSFORM verwenden:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen diese Funktion aufrufen, um zu √ºberpr√ºfen, ob JSONB zu einem Perlen-Hash geworden ist:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ganz andere Sache! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Autor dieses Artikels war auch an der Entwicklung von TRANSFORMs beteiligt. Es stellte sich heraus, dass ein so einfacher Datentyp, wie er </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einer unbequemen Form an PL / Perl √ºbergeben wurde, als Textzeichenfolgen </font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aber nach Perls Verst√§ndnis ist die Zeichenfolge 'f' wahr. Um die Unannehmlichkeiten zu beseitigen, wurde ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfunden </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">, der die Konvertierung f√ºr den Booleschen Typ definiert</font></a><font style="vertical-align: inherit;"> . Dieser Patch hat PostgreSQL 13 erreicht und wird in K√ºrze verf√ºgbar sein. Aufgrund seiner Einfachheit kann bool_plperl als minimales Startmodell f√ºr das Schreiben anderer Konvertierungen dienen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, jemand wird TRANSFORM f√ºr andere Datentypen (Bytea, Arrays, Datumsangaben, numerisch) entwickeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun wollen wir sehen, wie die Parameter in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python √ºbergeben werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Array wird in ein Array konvertiert - das ist gut (da mehrdimensionale Arrays der Version PG10 auch korrekt in Python √ºbertragen werden). </font><font style="vertical-align: inherit;">In Perl wurde ein Array in ein Objekt einer speziellen Klasse konvertiert. </font><font style="vertical-align: inherit;">Nun, </font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwandelt. </font><font style="vertical-align: inherit;">Ohne TRANSFORM wird jsonb als String √ºbergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun wollen wir sehen, in welcher Form die Parameter in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS gelangen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONB wurde ohne TRANSFORM in ein JavaScript-Objekt konvertiert! </font><font style="vertical-align: inherit;">Tempor√§re Postgres-Typen werden ebenfalls in den Datums-JS-Typ konvertiert. </font><font style="vertical-align: inherit;">Gleiches gilt f√ºr Boolesche Werte. </font><font style="vertical-align: inherit;">Alle Transformationen sind bereits in PL / V8 integriert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeite mit Unendlichkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die INFINITY-Konstante wird nicht sehr oft verwendet, aber schlampiges Arbeiten damit ist gef√§hrlich. </font><font style="vertical-align: inherit;">In PostgreSQL existieren Infinity und -Infinity als spezielle Werte f√ºr einige tempor√§re und Gleitkommatypen. </font><font style="vertical-align: inherit;">Die √úbertragung von Infinity in prozedurale Sprachen und umgekehrt muss jedoch ausf√ºhrlich er√∂rtert werden, da die Arbeit mit ihnen nicht nur von der Sprache, sondern auch von Bibliotheken, vom Betriebssystem und sogar von der Hardware abh√§ngen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python hat ein Numpy-Modul, das die numerische Unendlichkeit definiert:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl hat auch unendlich, es verwendet eine Zeichenfolge </font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die verk√ºrzt werden kann </font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zum Beispiel k√∂nnte man sagen:</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oder</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Perl, PL / Python, PL / v8 wird die numerische Unendlichkeit von Postgres korrekt √ºbergeben, aber ein unendliches Datum ist nicht ganz richtig. </font><font style="vertical-align: inherit;">Vielmehr gibt es in PL / Perl und PL / Python keinen eingebauten Datentyp f√ºr die Zeit, sondern eine Zeichenfolge. </font><font style="vertical-align: inherit;">In PL / V8 ist ein Datum vom Typ integriert, aus dem das √ºbliche Datum eines Postgres wird. </font><font style="vertical-align: inherit;">Aber der V8 kennt das endlose Datum nicht und wenn es √ºbertragen wird, verwandelt es sich in </font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbergabe von Parametern an vorbereitete Anforderungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur√ºck zu </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √ºberlegen Sie, wie die Parameter dort √ºbergeben werden. </font><font style="vertical-align: inherit;">Verschiedene Sprachen haben viel gemeinsam, da sie alle auf SPI basieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine Abfrage in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorbereiten </font><font style="vertical-align: inherit;">, m√ºssen Sie den Typ der √ºbergebenen Parameter bestimmen. Wenn Sie die Abfrage ausf√ºhren, geben Sie nur die Werte dieser Parameter an (die Parameter werden auf dieselbe Weise an PL / pgSQL √ºbergeben).</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python ist die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essenz dieselbe, aber die Syntax unterscheidet sich geringf√ºgig:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8 sind die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterschiede minimal:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alles anders. </font><font style="vertical-align: inherit;">Dort wird SPI eindeutig nicht verwendet, es wird jedoch eine Pseudo-JDBC-Verbindung zur Datenbank hergestellt. </font><font style="vertical-align: inherit;">F√ºr einen PL / Java-Programmierer geschieht alles so, als w√ºrde er eine Clientanwendung erstellen. </font><font style="vertical-align: inherit;">Dies ist praktisch und man k√∂nnte sich auch dem Design von PL / Perl und PL / Python n√§hern, aber aus irgendeinem Grund wurde dies nicht getan (jedoch verbietet niemand, ein paar weitere Implementierungen von PL / Perl und PL / Python zu erstellen).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Cursor arbeiten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle SPI-Funktionen, die wir beim Aufrufen der Datenbank verwendet haben - </font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und andere - haben einen Parameter, der die Anzahl der zur√ºckgegebenen Zeilen begrenzt. </font><font style="vertical-align: inherit;">Wenn Sie viele zur√ºckgegebene Zeilen ben√∂tigen, k√∂nnen Sie nicht auf einen Cursor verzichten, um sie ein wenig nach oben zu ziehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cursor arbeiten in all diesen Sprachen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><b><font style="vertical-align: inherit;">PL / Perl</font></b></font><br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen Cursor zur√ºck, aus dem Sie nacheinander Zeichenfolgen extrahieren k√∂nnen. </font><font style="vertical-align: inherit;">Es ist nicht erforderlich, den Cursor zu schlie√üen, er schlie√üt sich von selbst. </font><font style="vertical-align: inherit;">Wenn Sie es jedoch erneut entdecken m√∂chten, k√∂nnen Sie es explizit mit einem Befehl schlie√üen </font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alles sehr √§hnlich, aber der Cursor wird als Objekt dargestellt, durch das Sie bl√§ttern k√∂nnen:</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / v8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist auch alles sehr √§hnlich, aber vergessen Sie nicht, den vorbereiteten Abfrageplan </font><b><font style="vertical-align: inherit;">freizugeben</font></b><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8: Schneller Zugriff auf Funktionen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / V8 k√∂nnen Sie eine Funktion nicht von einem regul√§ren SELECT aus aufrufen, sondern anhand des Namens suchen und sofort mit starten </font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass in JS eine Funktion nicht polymorph sein kann, wie in PostgreSQL, in dem Funktionen mit demselben Namen, aber unterschiedlichen Parametern nebeneinander existieren k√∂nnen. </font><font style="vertical-align: inherit;">In PL / v8 k√∂nnen wir nat√ºrlich polymorphe Funktionen erstellen, aber beim Versuch, </font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font><font style="vertical-align: inherit;">zu verwenden </font><font style="vertical-align: inherit;">, tritt ein Fehler </font><font style="vertical-align: inherit;">auf </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Funktion nach Namen eindeutig ist, kann sie ohne SPI- und Typkonvertierungen aufgerufen werden, d. H. </font><font style="vertical-align: inherit;">viel schneller. </font><font style="vertical-align: inherit;">Zum Beispiel so:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaktionen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres 11 hat viel Spa√ü: Es sind </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">echte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prozeduren </font><font style="vertical-align: inherit;">erschienen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Postgres hatte fr√ºher nur Funktionen. </font><font style="vertical-align: inherit;">Die Freude liegt nicht nur an der Kompatibilit√§t und Konformit√§t mit dem SQL-Standard, sondern auch daran, warum: Innerhalb der Prozeduren k√∂nnen Sie Transaktionen festschreiben und zur√ºcksetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl und PL / Python verf√ºgen bereits √ºber SPI-Funktionen zum Verwalten von Transaktionen, PL / V8 noch nicht. </font><font style="vertical-align: inherit;">In PL / Perl, werden diese Funktionen aufgerufen </font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und ein Beispiel f√ºr die </font><font style="vertical-align: inherit;">Verwendung ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In PL / Python ist dies </font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtransaktion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Subtransaktionen sind praktisch f√ºr die korrekte Fehlerbehandlung in komplexer mehrstufiger Logik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> innerhalb einer Transaktion ist jeder Block mit dem Schl√ºsselwort EXCEPTION eine Subtransaktion. Informationen zu einigen Leistungs- und Zuverl√§ssigkeitsproblemen, die in diesem Fall auftreten k√∂nnen, finden Sie beispielsweise </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt </font><font style="vertical-align: inherit;">keine expliziten Subtransaktionen </font><font style="vertical-align: inherit;">in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber sie k√∂nnen durch Savaepoints simuliert werden. Wenn Sie m√∂chten, ist es anscheinend einfach, ein Perlenmodul zu schreiben, das Subtransaktionen in expliziter Form implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python sind</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subtransaktionen vor langer Zeit aufgetreten: ab 9.5 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explizit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , davor gab es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implizite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie k√∂nnen eine Transaktion definieren und einschlie√üen</font></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ausf√ºhren. </font><font style="vertical-align: inherit;">Wenn die Subtransaktion abf√§llt, fallen wir in den Block </font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wenn nicht abfallen, dann in den Block </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gehen weiter.</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein √§hnliches Design gibt es in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur in JS-Syntax.</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen Sie es, aber missbrauchen Sie es nicht :) Kenntnisse in PL / * k√∂nnen einige Vorteile bringen. </font><font style="vertical-align: inherit;">Wie jedes Werkzeug lieben sie es, f√ºr ihren beabsichtigten Zweck verwendet zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / v8 ist sehr vielversprechend, verh√§lt sich aber manchmal unerwartet und weist eine Reihe von Problemen auf. </font><font style="vertical-align: inherit;">Daher ist es besser, Sprachen aus der Verpackung zu nehmen, wenn sie f√ºr Ihre Aufgabe geeignet sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte Igor Levshin danken (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Igor_Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), der mir bei der Vorbereitung des Materials f√ºr den Artikel sehr geholfen und einige n√ºtzliche Ideen eingebracht hat, sowie Jewgeni Sergejew und Alexey Fadeev f√ºr die von ihnen vorgeschlagenen Korrekturen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502234/index.html">–ò–Ω—Å–∞–π–¥—ã –æ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ Facebook: –∫–∞–∫ –ø–æ–ø–∞—Å—Ç—å –Ω–∞ —Å—Ç–∞–∂–∏—Ä–æ–≤–∫—É, –ø–æ–ª—É—á–∏—Ç—å –æ—Ñ—Ñ–µ—Ä –∏ –≤—Å–µ –æ —Ä–∞–±–æ—Ç–µ –≤ –∫–æ–º–ø–∞–Ω–∏–∏</a></li>
<li><a href="../de502246/index.html">Was haben Alices k√ºhne Antworten mit Drohnen gemeinsam?</a></li>
<li><a href="../de502248/index.html">Ein neues GOST f√ºr digitale Ressourcen trat in Kraft: Alle Plattformen sollten f√ºr Menschen mit Behinderungen zug√§nglich sein</a></li>
<li><a href="../de502250/index.html">Zivilluftfahrt heute: Wichtige Aspekte und Herausforderungen in der Ausbildung</a></li>
<li><a href="../de502252/index.html">Fernbedienung und Drohnen</a></li>
<li><a href="../de502256/index.html">Wie visualisiere ich ein Spring Integration-Diagramm mit Neo4j?</a></li>
<li><a href="../de502260/index.html">ESP-NOW ist ein alternatives Kommunikationsprotokoll f√ºr ESP8266 und ESP32. Grundlegendes Konzept</a></li>
<li><a href="../de502262/index.html">Warum AIOps und Umbrella-Monitoring f√ºr die Bank oder worauf Kundenbeziehungen aufbauen</a></li>
<li><a href="../de502264/index.html">Infrastruktur f√ºr √∂ffentliche Schl√ºssel. Ausstellung von Zertifikaten unter Bedingungen der Selbstisolation</a></li>
<li><a href="../de502266/index.html">Aurora auf Intel-Plattform. Morgend√§mmerung der Exaflops-√Ñra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>