<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏿 🎅🏿 👩🏾‍🤝‍👨🏿 独自のナビゲーションスタック。ROSより良いですか？ ♌️ 🌡️ 👩‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="これは、Eurobot Open競技用の自律ロボットを作成し、これにROSを使用した経験に関するsetUPチームの2番目の記事です。
 
 最初の記事は、ロボットの力学と一般的なアーキテクチャについてです。
 
 ロボットは平らな場所を移動し、ほとんどの障害物は事前にわかっていますが、油断のない敵は...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>独自のナビゲーションスタック。ROSより良いですか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、Eurobot Open競技用の自律ロボットを作成し、これにROSを使用した経験に関するsetUPチームの2番目の記事です。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の記事は、ロボットの力学と一般的なアーキテクチャについてです。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ロボットは平らな場所を移動し、ほとんどの障害物は事前にわかっていますが、油断のない敵はリソースを盗もうとする可能性があり（場合によっては数十個の余分なポイントを食べたいことがあります）、できるだけ早く目的のポイントに移動して障害物に触れないようにします。フィールド上の外部カメラから、敵の位置に関するデータを取得し、敵の現在の位置を把握します。ただし、彼の立場を知るだけでは不十分です。この情報を使用できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日は、野原で眠りに落ちた猫の尻尾に沿って移動することなく、A地点からB地点まで運転しようとします。</font><font style="vertical-align: inherit;">特に、ルートを構築してロボットの速度を制御する方法、およびコンピューター上ですべてを開始する方法について説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少しの血でうまくやっていく</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するとき、専門家によって書かれた既製の資料を利用できます。そうすれば、次の「自転車」の苦痛や発明はありません。</font><font style="vertical-align: inherit;">したがって、オムニホイールプラットフォームを使用しましたが、ROSの既成のローカルプレーナを使用する試みがありましたが、いくつかの理由でこれは期待できないことがわかりました。</font><font style="vertical-align: inherit;">以下に、標準的なグライダーの設計者がどれだけ必要とするかを示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/**
   * @class TrajectoryPlanner
   * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. 
   */</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrajectoryPlanner</span>{</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrajectoryPlannerTest</span>;</span> <span class="hljs-comment">//Need this for gtest to work</span>
    <span class="hljs-keyword">public</span>:
      <span class="hljs-comment">/**
       * @brief  Constructs a trajectory controller
       * @param world_model The WorldModel the trajectory controller uses to check for collisions 
       * @param costmap A reference to the Costmap the controller should use
       * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex)
       * @param inscribed_radius The radius of the inscribed circle of the robot
       * @param circumscribed_radius The radius of the circumscribed circle of the robot
       * @param acc_lim_x The acceleration limit of the robot in the x direction
       * @param acc_lim_y The acceleration limit of the robot in the y direction
       * @param acc_lim_theta The acceleration limit of the robot in the theta direction
       * @param sim_time The number of seconds to "roll-out" each trajectory
       * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things
       * @param vx_samples The number of trajectories to sample in the x dimension
       * @param vtheta_samples The number of trajectories to sample in the theta dimension
       * @param pdist_scale A scaling factor for how close the robot should stay to the path
       * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal
       * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles
       * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities
       * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past
       * @param escape_reset_dist The distance the robot must travel before it can exit escape mode
       * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode
       * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise
       * @param max_vel_x The maximum x velocity the controller will explore
       * @param min_vel_x The minimum x velocity the controller will explore
       * @param max_vel_th The maximum rotational velocity the controller will explore
       * @param min_vel_th The minimum rotational velocity the controller will explore
       * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore
       * @param backup_vel The velocity to use while backing up
       * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits
       * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep
       * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories
       * @param meter_scoring adapt parameters to costmap resolution
       * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation
       * @param y_vels A vector of the y velocities the controller will explore
       * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things
       */</span><font></font>
      TrajectoryPlanner(WorldModel&amp; world_model, <font></font>
          <span class="hljs-keyword">const</span> costmap_2d::Costmap2D&amp; costmap, 
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;geometry_msgs::Point&gt; footprint_spec,
          <span class="hljs-keyword">double</span> acc_lim_x = <span class="hljs-number">1.0</span>, <span class="hljs-keyword">double</span> acc_lim_y = <span class="hljs-number">1.0</span>, <span class="hljs-keyword">double</span> acc_lim_theta = <span class="hljs-number">1.0</span>,
          <span class="hljs-keyword">double</span> sim_time = <span class="hljs-number">1.0</span>, <span class="hljs-keyword">double</span> sim_granularity = <span class="hljs-number">0.025</span>, 
          <span class="hljs-keyword">int</span> vx_samples = <span class="hljs-number">20</span>, <span class="hljs-keyword">int</span> vtheta_samples = <span class="hljs-number">20</span>,
          <span class="hljs-keyword">double</span> pdist_scale = <span class="hljs-number">0.6</span>, <span class="hljs-keyword">double</span> gdist_scale = <span class="hljs-number">0.8</span>, <span class="hljs-keyword">double</span> occdist_scale = <span class="hljs-number">0.2</span>,
          <span class="hljs-keyword">double</span> heading_lookahead = <span class="hljs-number">0.325</span>, <span class="hljs-keyword">double</span> oscillation_reset_dist = <span class="hljs-number">0.05</span>, 
          <span class="hljs-keyword">double</span> escape_reset_dist = <span class="hljs-number">0.10</span>, <span class="hljs-keyword">double</span> escape_reset_theta = M_PI_2,
          <span class="hljs-keyword">bool</span> holonomic_robot = <span class="hljs-literal">true</span>,
          <span class="hljs-keyword">double</span> max_vel_x = <span class="hljs-number">0.5</span>, <span class="hljs-keyword">double</span> min_vel_x = <span class="hljs-number">0.1</span>, 
          <span class="hljs-keyword">double</span> max_vel_th = <span class="hljs-number">1.0</span>, <span class="hljs-keyword">double</span> min_vel_th = <span class="hljs-number">-1.0</span>, <span class="hljs-keyword">double</span> min_in_place_vel_th = <span class="hljs-number">0.4</span>,
          <span class="hljs-keyword">double</span> backup_vel = <span class="hljs-number">-0.1</span>,
          <span class="hljs-keyword">bool</span> dwa = <span class="hljs-literal">false</span>, <span class="hljs-keyword">bool</span> heading_scoring = <span class="hljs-literal">false</span>, <span class="hljs-keyword">double</span> heading_scoring_timestep = <span class="hljs-number">0.1</span>,
          <span class="hljs-keyword">bool</span> meter_scoring = <span class="hljs-literal">true</span>,
          <span class="hljs-keyword">bool</span> simple_attractor = <span class="hljs-literal">false</span>,
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; y_vels = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">0</span>),
          <span class="hljs-keyword">double</span> stop_time_buffer = <span class="hljs-number">0.2</span>,
          <span class="hljs-keyword">double</span> sim_period = <span class="hljs-number">0.1</span>, <span class="hljs-keyword">double</span> angular_sim_granularity = <span class="hljs-number">0.025</span>);
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、速度と軌道全体を調整するためのパラメータの初期化の例です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全な計算のための重要なパラメーター：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータworld_model。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コストマップパラメーター：潜在的な衝突を考慮した、障害物とその「仮想拡張」を含むマップへのリンク。 </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準スタックの利点の中で、ドキュメントの可用性とフォーラムで情報を検索する機能を強調できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳細については、公式ウェブサイトのドキュメントをご覧ください</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。ROSパッケージは2輪プラットフォーム用に作成されており、360度まで移動すると利用可能な回転角度が増加するため、オムニ向けに最適化されて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">いる</font></a><font style="vertical-align: inherit;">ことは重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトを分析した結果、学習や補充が困難であるだけでなく、不要な重いチップがたくさんあることがわかりました。</font><font style="vertical-align: inherit;">どうやらそうかもしれませんが、私たちはOdroid xu4（Samsung s5にまだ搭載されていたプロセッサー）を使用しました。パフォーマンスの結果は憂鬱で、より強力なもの（およびラズベリー4とjetson nanoプロセッサー）のスペースは、彼と一緒に）いいえ。</font><font style="vertical-align: inherit;">標準スタックを放棄し、グローバルプランナー、ローカルプランナー、および軌道レギュレーターを自分で作成する必要がありました</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルプランナー、ローカルプランナー、軌道レギュレーター、その他すべて</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目的地へのルートを取得するには、グローバルおよびローカルのグライダーが必要です。なぜ分離が必要なのですか？なぜ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に乗って乗れないのですか？原則として、グローバルプランナーはルートを構築する際に、マップ全体を作業に使用できるため、アルゴリズムは可能な限り高速である必要があります。これらの簡素化をスムーズにするために、ローカルプランナーも使用します。ローカルプランナーは、グローバルプランナー（またはロボットの周囲の限られた領域）の結果に基づいて、すべてのニュアンスを考慮に入れようとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートを作成した後、ロボットがどこに行くべきかがわかりますが、これについて彼にどのように伝えることができますか？これを行うには、軌道レギュレータがあります。軌跡から逸脱しないように、現時点でロボットが移動する速度と方向を計算します。多くの点で、このパッケージは、ロボットがどれほど速くて美しいかを決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの3つのエンティティに加えて、4つ目のマップサーバーがあります。これにより、世界の状態を簡単に処理できます。これは、マップの記述方法、マップを操作するときの可能性を設定し、さまざまな方法でグライダーの速度を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ナビゲーションスタックの説明に進む前に、マップサーバーとしてcost_mapが選択された理由の概要を説明すると便利です。</font><font style="vertical-align: inherit;">一般的に、マップハンドラーのさまざまなオプションを試しました：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Occupancy_grid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid_map</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cost_map</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、後者で解決しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原因：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地図を便利に操作します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな形式（円形、線形、長方形など）で必要なさまざまなイテレータがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータの異なる複数のマップレイヤーを保存できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れたメモリ管理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして最も重要なのは、スピード。</font><font style="vertical-align: inherit;">グリッドマップはdoubleタイプで動作します。そのため、int8を使用して動作するマップサーバーよりも数倍遅くなります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Occupancyグリッドもint8で機能するという事実にもかかわらず、それは同じ使いやすさを誇ることができないので、私はそれを放棄しなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地図から、自由で危険な、たまらないゾーンがどこにあるかを知る必要があります。</font><font style="vertical-align: inherit;">フィールド上にあるオブジェクトごとに、膨張フィールドを調整できます。この値は、オブジェクトまでの距離に応じて、セルの透過性を特徴付けます。</font><font style="vertical-align: inherit;">インフレは猫のしっぽであり、気づかないことは簡単ですが、それを非常に長い間後悔することになります。</font><font style="vertical-align: inherit;">敵のロボットをマッピングし、ローカルプランナーだけが考慮に入れる危険ゾーンを追加します。</font><font style="vertical-align: inherit;">グローバルプランナーは、障害がなければ、すべてのポイントを無視します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルプランナー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らがナビゲーションで最初に書いたのは、グローバルプランナーです。</font><font style="vertical-align: inherit;">シータ*アルゴリズムに基づいています。</font><font style="vertical-align: inherit;">つまり、これは修正された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、直接到達できる親ノードの検索に重点が置かれています。</font><font style="vertical-align: inherit;">彼女に障害はありません。</font><font style="vertical-align: inherit;">これにより、ローカルプランナーで使用される便利でスムーズなパスを構築できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *とtheta *の比較</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
グローバルプランナーの場合、マップトピックとすべてのロボットの場所を含むトピック（params / path_planner.yaml）を含むファイル（params / path_planner.yaml）があります（「null」は、現在のロボット）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># small robot debug param list</span>
robot_id: <span class="hljs-string">"small"</span><font></font>
<font></font>
###########################<font></font>
# cost_map_server params ##<font></font>
###########################<font></font>
cost_map_server/big_robot_size: <span class="hljs-number">0.45</span>
cost_map_server/little_robot_size: <span class="hljs-number">0.45</span>
cost_map_server/cube_size: <span class="hljs-number">0.11</span>
cost_map_server/inscribed_radius: <span class="hljs-number">0.3</span>
cost_map_server/inflation_radius: <span class="hljs-number">0.3</span>
cost_map_server/inflation_exponential_rate: <span class="hljs-number">0.6</span>
cost_map_server/big_robot1: <span class="hljs-string">"/aruco/big_robot"</span>
cost_map_server/big_robot2: <span class="hljs-string">"/aruco/enemy_robot1"</span>
cost_map_server/small_robot1: <span class="hljs-string">"null"</span> 
cost_map_server/small_robot2: <span class="hljs-string">"/aruco/enemy_robot2"</span>
cost_map_server/collision: <span class="hljs-string">"collision"</span>
cost_map_server/image_resource_name: <span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span>
cost_map_server/min_diff_points: <span class="hljs-number">0.01</span><font></font>
<font></font>
###########################<font></font>
### path_planner params ###<font></font>
###########################<font></font>
global_planner/path_layer: <span class="hljs-string">"inflation_layer"</span>
global_planner/path_force_layer: <span class="hljs-string">"obstacle_inflation_layer"</span>
global_planner/frame_id: <span class="hljs-string">"map"</span>
global_planner/current_position: <span class="hljs-string">"real_corr"</span>
global_planner/path_filter_epsilon: <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、次のことも示しています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルートを構築するために選択できるアルゴリズムの1つ、 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルート自体を構築するレイヤーの名前 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルターされたデータが発行される私たちの位置に関するトピック（この場合は、カメラからの位置データとオドメトリの組み合わせです）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パス検索アルゴリズム自体-シータスター-は、新しいアルゴリズムを追加するために、別のファイル（src / global_planner.cpp）で強調表示されています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> cost_so_far[<span class="hljs-number">300</span>][<span class="hljs-number">200</span>];<font></font>
PriorityPoint neighbors[<span class="hljs-number">8</span>];<font></font>
PriorityPoint current;<font></font>
<span class="hljs-keyword">int</span> come_from[<span class="hljs-number">300</span>][<span class="hljs-number">200</span>][<span class="hljs-number">2</span>];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">makePath_ThetaStar</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> layer, cost_map::CostMap &amp;cost_map, <span class="hljs-keyword">double</span> grid_cost, <span class="hljs-keyword">bool</span> only_cost)</span>
</span>{
  <span class="hljs-built_in">std</span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PriorityPoint&gt;, myCompare&gt; openSet;
  <span class="hljs-keyword">size_t</span> max_x = cost_map.getSize()[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">size_t</span> max_y = cost_map.getSize()[<span class="hljs-number">1</span>];
  <span class="hljs-built_in">std</span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">float</span>&gt;::max());<font></font>
  cost_so_far[start.x][start.y] = <span class="hljs-number">0</span>;<font></font>
  come_from[start.x][start.y][<span class="hljs-number">0</span>] = start.x;<font></font>
  come_from[start.x][start.y][<span class="hljs-number">1</span>] = start.y;<font></font>
  openSet.push(start);<font></font>
  grid_cost=<span class="hljs-number">5</span>;
  <span class="hljs-keyword">while</span> (!openSet.empty())<font></font>
  {<font></font>
    current = openSet.top();<font></font>
    openSet.pop();<font></font>
    <span class="hljs-keyword">if</span> (current == goal)<font></font>
    {<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    current.GetNeighbors(neighbors);<font></font>
    <span class="hljs-keyword">float</span> current_cost = cost_so_far[current.x][current.y];
    <span class="hljs-keyword">int</span> parent_carent[<span class="hljs-number">2</span>] ={come_from[current.x][current.y][<span class="hljs-number">0</span>], come_from[current.x][current.y][<span class="hljs-number">1</span>]};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (!neighbors[i].OnMap(max_x, max_y))<font></font>
      {<font></font>
        <span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">bool</span> onLine = lineOfSight(parent_carent[<span class="hljs-number">0</span>], parent_carent[<span class="hljs-number">1</span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (onLine)<font></font>
      {<font></font>
        <span class="hljs-keyword">float</span> new_cost = cost_so_far[parent_carent[<span class="hljs-number">0</span>]][parent_carent[<span class="hljs-number">1</span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number">10</span>);
        <span class="hljs-keyword">if</span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y])<font></font>
        {<font></font>
          cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost;<font></font>
          neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number">10</span>) + new_cost;<font></font>
          openSet.push(neighbors[i]);<font></font>
          come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number">0</span>] = parent_carent[<span class="hljs-number">0</span>];<font></font>
          come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number">1</span>] = parent_carent[<span class="hljs-number">1</span>];<font></font>
        }<font></font>
      }<font></font>
      <span class="hljs-keyword">else</span><font></font>
      {<font></font>
        <span class="hljs-keyword">float</span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority;
        <span class="hljs-keyword">float</span> new_cost = current_cost + neighbor_price;
        <span class="hljs-keyword">if</span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y])<font></font>
        {<font></font>
          cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost;<font></font>
          neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number">10</span>) + new_cost;<font></font>
          openSet.push(neighbors[i]);<font></font>
          come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number">0</span>] = current.x;<font></font>
          come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number">1</span>] = current.y;<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (only_cost)<font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> cost_so_far[current.x][current.y];<font></font>
  }<font></font>
  path.clear();<font></font>
  PriorityPoint temp_point;<font></font>
  <font></font>
  <span class="hljs-keyword">while</span> (current != start)<font></font>
  {<font></font>
    path.push_back({current.x, current.y});<font></font>
    temp_point.x = come_from[current.x][current.y][<span class="hljs-number">0</span>];<font></font>
    temp_point.y = come_from[current.x][current.y][<span class="hljs-number">1</span>];<font></font>
    current = temp_point;<font></font>
  }<font></font>
  path.push_back({current.x, current.y});<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のファイルでは、RamerDouglasPeuckerパスの余分なポイントを削除するアルゴリズムも強調表示されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接する2つの点を結ぶ線から所定の距離よりも遠い場合、パスから点を削除します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルプランナー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 彼は潜在的な分野での勾配降下法に基づいて私たちのために働いています。入力として、これはグローバルプランナーからのパスです。しかし、これは彼ができるすべてではありません。 local_plannerには、パス構築モードを選択するための内部サービスがあります。操作には2つのモードがあります。マップ上の複数のパスを使用してグラデーションに沿ってポイントをシフトするモードと、2つの座標の増分をすぐに計算してポイントをセーフゾーンの端に移動するシフトモードです。ポイントがそのようないくつかのゾーンに該当する場合は、最も安全であるため、交差点の場所に移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操作モードは次のとおりです。前の反復からのパスに障害物がない場合は、パスを2 cmごとに分割し、勾配に沿って移動します。それ以外の場合は、2番目のローカルプランナー操作モードを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプションは非常に軽量であり、グローバルプランナーのようにプロセッサにあまり負荷をかけません。このアルゴリズムのいくつかのバージョンと、マップでのさまざまな操作を使用しました。たとえば、頂点が10 cmごとに見つかり、最大で4 cmシフトするグラフを作成しようとしました。その後、取得したグラフでダイクストラのアルゴリズムを使用して最小距離を見つけました。この場合の終点は、最も近いオフセットポイントを使用します。ただし、そのようなアルゴリズムはグローバルプランナーに適していたため、この実装を中止することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、勾配降下法を使用して、最初からパス構築を使用してみました。このメソッドは、最初に作成することを決めたものです。メモリ効率が悪く（パスごとにコストマップを使用したため、純粋なRAMの400 mb以上を占めていました）、速度が遅いことがわかりました。最適化が不十分なために周波数制御が無効になり、速度は1秒あたり30回未満でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、グローバルプレーナのパスに基づいて、ポテンシャルフィールドで勾配降下法を使用することにしました。その結果、軽量で比較的単純なアルゴリズムが得られました。100〜150 mbの領域で消費されるRAMの量は、パスの品質、作業時間、および開発の最初の反復よりも数分の1です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルプレーナーによるパスオフセットの例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。global_plannerとは異なり、local_plannerには非常に少数のパラメーターがあります。これは、最も重要なタスクがすべてglobal_plannerにあるため、単純であるためです。</font></font><br>
<br>
<pre><code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number">0.4</span>
grid_map_server/big_robot2 : <span class="hljs-number">0.4</span>
grid_map_server/small_robot1 : <span class="hljs-number">0.4</span>
grid_map_server/small_robot2 : <span class="hljs-number">0.4</span>
local_planner/radius : <span class="hljs-number">0.15</span>
global_planner/frame_id : <span class="hljs-string">"map"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、以下を構成します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ロボットのセーフゾーンの半径。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルプレーナによる最大パスオフセット。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用しているマップレイヤーの名前。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のクラスでは、すべての最も重要な機能が割り当てられました。</font><font style="vertical-align: inherit;">この場合、それはパスの再帰的な内訳であり、グライダーの作成と仮想コンストラクタとデストラクタです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Planner</span>
{</span>
  <span class="hljs-keyword">public</span>:<font></font>
    Planner(<span class="hljs-keyword">double</span> inflation_radius_, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> frame_id_)<font></font>
    {    <font></font>
      inflation_radius = inflation_radius_;<font></font>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++)<font></font>
      {<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">200</span>; j++)<font></font>
          our_map[i][j] = <span class="hljs-number">3000.0</span>;<font></font>
      }<font></font>
      OurPath-&gt;poses.resize(<span class="hljs-number">50</span>);<font></font>
      <font></font>
      geometry_msgs::Pose pose;<font></font>
      <font></font>
      pose.position.x = <span class="hljs-number">0.0</span>;<font></font>
      pose.position.y = <span class="hljs-number">0.0</span>;<font></font>
    <font></font>
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<font></font>
      {<font></font>
        OurPath-&gt;poses[i].pose = pose;<font></font>
      }<font></font>
      <font></font>
      frame_id = frame_id_;<font></font>
    }<font></font>
    <span class="hljs-keyword">virtual</span> ~Planner() {  } 
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdatePath</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
    ros::Publisher move_pub;  <font></font>
    ros::Publisher BigEnemyPub;<font></font>
    ros::Publisher LittleEnemyPub;<font></font>
    ros::Publisher local_path_publisher;<font></font>
    <font></font>
  <span class="hljs-keyword">protected</span>:<font></font>
<font></font>
    <span class="hljs-comment">// virtual double Calculate_Path_Len();</span><font></font>
<font></font>
    <span class="hljs-function">nav_msgs::Path* <span class="hljs-title">recursive_path</span><span class="hljs-params">(nav_msgs::Path *path, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; start, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; end,
              <span class="hljs-keyword">double</span> epsilon, <span class="hljs-keyword">int</span> &amp;index)</span>
    </span>{
      <span class="hljs-keyword">if</span> (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; <span class="hljs-number">200</span>)
        <span class="hljs-keyword">return</span> path;<font></font>
<font></font>
      <span class="hljs-keyword">double</span> start_x = (start.first + end.first) / <span class="hljs-number">2.0</span>;
      <span class="hljs-keyword">double</span> start_y = (start.second + end.second) / <span class="hljs-number">2.0</span>;<font></font>
<font></font>
      index = find_out(path, start);<font></font>
<font></font>
      geometry_msgs::PoseStamped pose;<font></font>
      pose.pose.position.x = start_x;<font></font>
      pose.pose.position.y = start_y;<font></font>
      path-&gt;poses.insert(path-&gt;poses.begin() + index, pose);<font></font>
<font></font>
      recursive_path(path, start, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;{start_x, start_y}, epsilon, index);<font></font>
      recursive_path(path, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;{start_x, start_y}, end, epsilon, index);<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_out</span><span class="hljs-params">(nav_msgs::Path *path, pair_double point)</span>
    </span>{
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; path-&gt;poses.size(); i++)
        <span class="hljs-keyword">if</span> (path-&gt;poses[i].pose.position.x == point.first &amp;&amp;<font></font>
          path-&gt;poses[i].pose.position.y == point.second)<font></font>
          <span class="hljs-keyword">return</span> ++i;
      <span class="hljs-keyword">return</span> index;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_in_path</span><span class="hljs-params">(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, <span class="hljs-keyword">int</span>&amp; Index)</span>
    </span>{<font></font>
      Path-&gt;poses[Index % max_size] = pose;<font></font>
      Index++;<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-keyword">double</span> inflation_radius;
    <span class="hljs-keyword">double</span> our_map[<span class="hljs-number">300</span>][<span class="hljs-number">200</span>];<font></font>
<font></font>
    <span class="hljs-keyword">int</span> max_size = <span class="hljs-number">49</span>;<font></font>
    <font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> frame_id;<font></font>
<font></font>
    nav_msgs::Path *path = <span class="hljs-keyword">new</span> nav_msgs::Path;<font></font>
    nav_msgs::Path *OurPath = <span class="hljs-keyword">new</span> nav_msgs::Path; <font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LocalPlanningクラスはこのクラスから継承され、グライダーのコア全体が配置されます。つまり、ポイントをセーフゾーンの端に移動し、パスをどう処理するかを決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のすべての関数は別のファイルfichi.hppで強調表示され、gradient descentはpotential_field.hppで強調表示されます。</font><font style="vertical-align: inherit;">以下は、このファイルのスナップショットであり、cost_mapマップで潜在的なフィールドを作成するための関数を示しています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalcAttractivePotential</span><span class="hljs-params">(grid_map::Index index, <span class="hljs-keyword">double</span> goalx, <span class="hljs-keyword">double</span> goaly)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(index[<span class="hljs-number">0</span>] - goalx, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(index[<span class="hljs-number">1</span>] - goaly, <span class="hljs-number">2</span>));<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CalcPotential</span><span class="hljs-params">(<span class="hljs-keyword">double</span> startx, <span class="hljs-keyword">double</span> starty, <span class="hljs-keyword">double</span> goalx, <span class="hljs-keyword">double</span> goaly, cost_map::CostMap &amp;cost_map, <span class="hljs-keyword">double</span> (&amp;our_map)[<span class="hljs-number">300</span>][<span class="hljs-number">200</span>])</span>
</span>{
    <span class="hljs-comment">// Use some magic for normalisation of Field</span>
    <span class="hljs-keyword">double</span> max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + <span class="hljs-number">15</span>);
    <span class="hljs-keyword">if</span> (max_distance == <span class="hljs-number">0.0</span>)<font></font>
    {<font></font>
        max_distance = <span class="hljs-number">0.01</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span> (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / <span class="hljs-number">100.0</span>, starty / <span class="hljs-number">100.0</span>), max_distance / <span class="hljs-number">100.</span>);<font></font>
            !iterator.isPastEnd(); ++iterator)<font></font>
    {<font></font>
        <span class="hljs-keyword">try</span><font></font>
        {<font></font>
            <span class="hljs-function">grid_map::Index <span class="hljs-title">index</span><span class="hljs-params">(*iterator)</span></span>;
            <span class="hljs-keyword">double</span> uf;<font></font>
            uf = cost_map.at(<span class="hljs-string">"obstacle_inflation_layer"</span>, *iterator);<font></font>
<font></font>
            <span class="hljs-comment">// if we on free podouble - field is more less then if it not free podouble</span>
            <span class="hljs-keyword">if</span> ( uf &gt;= <span class="hljs-number">10</span>)<font></font>
            {<font></font>
                uf = <span class="hljs-number">3000.0</span>; <span class="hljs-comment">// CP - is const variable</span><font></font>
            }<font></font>
            <span class="hljs-keyword">else</span>
                uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * <span class="hljs-number">256</span>;<font></font>
<font></font>
            our_map[<span class="hljs-number">299</span>-index(<span class="hljs-number">0</span>)][<span class="hljs-number">199</span>-index(<span class="hljs-number">1</span>)] = uf;<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">std</span>::exception&amp; e)<font></font>
        {<font></font>
            ROS_INFO(<span class="hljs-string">"Exception! %s"</span>, e.what() );<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軌道レギュレーター </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に重要なのは、軌道レギュレーターです。彼はローカルプランナーパスをパスに変換し、現在のステップの速度を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーロボット2018の決勝で使用した最初のバージョンは、加速とブレーキングpidコントローラーの混合であり、ベクトルは、終点までの距離を基準にして、パスの次の点に正規化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに、Pidコントローラーはシステムの3つの状態の合計であり、時々発生するシステムエラーとランダムエラーの修正に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの関数は経験的に選択され、パスの終点までの距離に依存します（2次、3次、逆の場合がありますが、2次で解決しました）。これはうまくいきましたが、私たちに合わなかった唯一のことは、ロボットが毎秒0.7メートルを超える速度で時間内にブレーキをかけることができなかったことです。したがって、その時が来たとき、アルゴリズム全体を再構築することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい軌道への道の最初の反復は、これから行うベクトルの置き換えでした。これは、係数が異なる次の3つのベクトルの合計です。 2番目の反復では、Minimum Jerkを作成しました。つまり、これは5次多項式の構成であり、x座標とy座標は各ポイントへの到着時間に依存します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図は、いずれかの座標の時間依存性とこの座標に沿った速度のグラフを示しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このタイプの軌道コントローラは、すべての係数が時間に基づいて計算された多項式の値であるため、異なる係数の選択による操作が少なくて済むため、より適しています。アプローチでは、現在の速度と加速、出力速度と加速。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
軌道を書き直した結果、ロボットの平均速度を2倍にすることができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の2つのケースと同様に、簡単に操作できるように、すべての主要な機能が別のファイルで強調表示されています。今回は、PlannerTrajectoryクラスが、MinimumJerkに基づいて軌道を構築します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> {</span>
    <span class="hljs-keyword">double</span> velocity;
    <span class="hljs-keyword">double</span> acceleration;<font></font>
<font></font>
    State(<span class="hljs-keyword">double</span> v_, <span class="hljs-keyword">double</span> a_) : velocity(v_), acceleration(a_) {}<font></font>
<font></font>
    State() {<font></font>
        velocity = <span class="hljs-number">0</span>;<font></font>
        acceleration = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlannerTrajectory</span> {</span>
<span class="hljs-keyword">private</span>:<font></font>
    nav_msgs::Path global_path;<font></font>
    cost_map::CostMap *costmap_ptr;<font></font>
    geometry_msgs::PoseStamped Goal_pred;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; trajectory_x;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; trajectory_y;<font></font>
<font></font>
    <span class="hljs-keyword">double</span> average_velocity = <span class="hljs-number">80</span>; <span class="hljs-comment">// Defualt or get from param //</span>
    <span class="hljs-keyword">double</span> max_velocity = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">double</span> coef_x[<span class="hljs-number">6</span>];
    <span class="hljs-keyword">double</span> coef_y[<span class="hljs-number">6</span>];
    <span class="hljs-keyword">int</span> frequency = <span class="hljs-number">30</span>; <span class="hljs-comment">// Defualt or get from param //</span>
    <span class="hljs-keyword">int</span> index;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
    PlannerTrajectory(cost_map::CostMap *costmap_, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;frequency_, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;max_velocity_,
                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;average_velocity_) {<font></font>
        average_velocity = average_velocity;;<font></font>
        max_velocity = max_velocity_;<font></font>
        costmap_ptr = costmap_;<font></font>
        frequency = frequency_;<font></font>
        Goal_pred.pose.position.x = <span class="hljs-number">0.0</span>;<font></font>
        Goal_pred.pose.position.y = <span class="hljs-number">0.0</span>;<font></font>
    }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真は、使用するすべての宣言された変数を示しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
他のファイル（include / trajectory_regulator.h）では、他のすべてが強調表示されています。トピックからポイントを受け取り、次のポイントに進むかどうかを決定します（障害物にある場合、それから行きません）そして、はるかに。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROS Melodicへの移行 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
昨年まで、ROS-ROS Kineticのlteリリースを使用していました。</font><font style="vertical-align: inherit;">彼は一般的に私たちに適していましたが、来年彼のサポートは終了し、私たちが必要とする多くのパッケージがROS Melodic専用に出てき始めました。</font><font style="vertical-align: inherit;">そして、使用しているcostmap_serverがMelodicの下にないことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カードからのデータの処理中に問題が発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックは似ていますが、マップの先頭が別の場所にあり、マップ自体の値が0から1まで変化するため、グリッドマップを選択しました。これは、ナビゲーションスタック全体で大きな問題になっています。以前にグローバルプランナーが1秒間に50回起動された場合（周波数制限があり、したがって、1つのスレッドの半分でもプロセッサーがあまり使用されなかった）、2秒ごとに道を開き、悪いと見なしました：1つのコアを完全にロードしました。 2秒で、ロボットはマップ全体を横切ることができました。これは私たちには適しておらず、このプロセスを並列化する試みは失敗しました。それ以降、他のプロジェクトのパフォーマンスは残っていません（並列化のコストを考慮すると）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
占有グリッドを優先してグリッドマップを破棄し、スタックを再度変更することにしました。</font><font style="vertical-align: inherit;">新しい問題が発生しました-複数のバージョンのマップを同時に保存できない（たとえば、すべての障害物がある完全なマップと、動的な障害物のみがある静的なマップ）。</font><font style="vertical-align: inherit;">コードの半分を変更する必要がありましたが、特に信頼性はありませんでした。</font><font style="vertical-align: inherit;">したがって、この問題の代替ソリューションを探すことにしました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コストマップサーバー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い検索の結果、フォークマップcostmap_serverrが見つかりました：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">//github.com/lelongg/cost_map.git-</font></a><font style="vertical-align: inherit;">フォークシステムに非常に役立ちます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、グリッドマップのみにサービスを提供する代わりに、配信のために、カルマンフィルターの予測に基づいて敵の推定位置を計算します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マップサーバーで最も重要なことの1つは、すべてのレイヤーの最初の作成に使用されるマップファイルです。これは、後でのみ更新されます。</font><font style="vertical-align: inherit;">これはバイナリpng画像で、黒は障害物で、白はフリーゾーンです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cost_map_server構成用の設定ファイルもあります。</font><font style="vertical-align: inherit;">敵のポイント、インフレゾーン、正方形のサイズなどのトピックが含まれています。これらは、敵の危険なゾーンをマップに配置するためにも使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs">###########################<font></font>
# cost_map_server params ##<font></font>
###########################<font></font>
cost_map_server/big_robot_size: <span class="hljs-number">0.4</span>
cost_map_server/little_robot_size: <span class="hljs-number">0.4</span>
cost_map_server/cube_size: <span class="hljs-number">0.11</span>
cost_map_server/inscribed_radius: <span class="hljs-number">0.25</span>
cost_map_server/inflation_radius: <span class="hljs-number">0.25</span>
cost_map_server/inflation_exponential_rate: <span class="hljs-number">0.6</span>
cost_map_server/big_robot1: <span class="hljs-string">"/aruco/robot1"</span>
cost_map_server/big_robot2: <span class="hljs-string">"/aruco/robot2"</span>
cost_map_server/small_robot1: <span class="hljs-string">"/aruco/robot3"</span> 
cost_map_server/small_robot2: <span class="hljs-string">"/aruco/robot4"</span>
cost_map_server/collision: <span class="hljs-string">"collision"</span>
cost_map_server/image_resource_name: <span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span>
cost_map_server/min_diff_points: <span class="hljs-number">0.01</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのレイヤーは、誰かがサブスクライブした場合にのみ公開されます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PublishChanges</span><span class="hljs-params">()</span>
    </span>{<font></font>
        nav_msgs::OccupancyGrid msg;<font></font>
        cost_map_msgs::CostMap cost_map_msg;<font></font>
        <span class="hljs-keyword">if</span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number">0</span>)<font></font>
        {<font></font>
            cost_map::toOccupancyGrid(costmap, <span class="hljs-string">"obstacle_layer"</span>, msg);<font></font>
            obstacle_inflation_publisher.publish(msg);<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number">0</span>)<font></font>
        {<font></font>
            cost_map::toOccupancyGrid(costmap, <span class="hljs-string">"inflation_layer"</span>, msg);<font></font>
            inflation_publisher.publish(msg);<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number">0</span>)<font></font>
        {<font></font>
            cost_map::toMessage(costmap, cost_map_msg);<font></font>
            cost_map_publisher.publish(cost_map_msg);<font></font>
        }<font></font>
    }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピューターで実行する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタック全体を開始するには、次のことを行う必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ROSを置く </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">roslaunch cost_map_server cost_map_server_alone.launch-マップを開始します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">roslaunch global_planner global_planner.launch-パラメータでグローバルプレーナを起動します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rosparam load $（local_plannerを見つける）/param/param.yaml</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rosrun local_planner local_planning</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rosrun trajectory_regulator trajectory_regulator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rosrun global_planner mover </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロスラン・ルビズ </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inflation_layerを追加 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピック/ gp /ゴールにメッセージを送信し、ロボットを目的のポイントに送信します </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのアイテムを起動した結果として、コンピューターでスタックを起動するシミュレーションの準備が整います。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なフォーク</font></font></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、私たちはロボットが美しく、迅速かつ正確にオムニホイールで走行するのを助けるナビゲーションが必要でした。</font><font style="vertical-align: inherit;">大会の準備中、怪我をした猫は一人もおらず、ロボットはハンサムです。</font><font style="vertical-align: inherit;">その結果、ユーロボットに似たコンテスト用の軽量ナビゲーションスタックができ、これは非常に満足しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにとって、このスタックは標準のものよりも優れていますが、... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの電報：t.me/SetUpSber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての私たちの創造性のリポジトリ</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja479620/index.html">逆論理</a></li>
<li><a href="../ja479622/index.html">Wavesブロックチェーンでの匿名トランザクションのプロトタイプの仕組み</a></li>
<li><a href="../ja479624/index.html">Postgres Professionalのgendar Oleg BartunovがFaride RoslovetsにPostgreSQLとロシアでのビジネスについて語った</a></li>
<li><a href="../ja479626/index.html">物理学者が知らないひねりを加えた共振器</a></li>
<li><a href="../ja479630/index.html">注意のために戦う</a></li>
<li><a href="../ja479642/index.html">第二次世界大戦の飛行機を設計するときの愚かな決定がMacintoshの作成につながった方法</a></li>
<li><a href="../ja479644/index.html">プログラマティックに関する簡単な単語</a></li>
<li><a href="../ja479646/index.html">中級後も英語を学び続けるための悪いアドバイスや理由</a></li>
<li><a href="../ja479650/index.html">ITダイナミックダイナミックインフォグラフィックのトップ12</a></li>
<li><a href="../ja479654/index.html">Django vueジェネレーター</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>