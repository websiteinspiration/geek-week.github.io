<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖 📊 🤦🏼 Polymorphisme basé sur le concept C ++ dans le code produit: PassManager dans LLVM 👨🏼‍🏫 👊🏻 👀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous allons parler d'un idiome intéressant introduit par Sean Parent (Adobe), une figure bien connue de la communauté C ++. Il donne souv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Polymorphisme basé sur le concept C ++ dans le code produit: PassManager dans LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aujourd'hui, nous allons parler d'un idiome intéressant introduit par Sean Parent (Adobe), une figure bien connue de la communauté C ++. </font><font style="vertical-align: inherit;">Il donne souvent des présentations et publie une série d'articles Better Code. </font><font style="vertical-align: inherit;">Une de ses idées que Photoshop utilise est le polymorphisme basé sur les concepts. </font><font style="vertical-align: inherit;">C'est lorsque nous implémentons le polymorphisme non pas par héritage explicite, mais en utilisant une technique qui inclut une programmation généralisée, et en conséquence nous obtenons des avantages supplémentaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article est organisé comme suit:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que le polymorphisme conceptuel et pourquoi est-il nécessaire?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu sur LLVM et son appareil</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de polymorphisme basé sur un concept dans LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avantages de l'approche</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une image illustrant la thèse "L'hérédité est mauvaise". </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que le polymorphisme conceptuel et pourquoi est-il nécessaire?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En C ++, le polymorphisme dynamique est implémenté à l'aide de fonctions virtuelles et de l'héritage, et le polymorphisme statique à l'aide de modèles. </font><font style="vertical-align: inherit;">Ici, nous combinons ces deux approches et en tirons le meilleur parti. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation explicite de l'héritage conduit souvent à une connectivité excessive du code et à une violation du principe de séparation d'interface ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Comment mettre en œuvre le polymorphisme dynamique sans ces inconvénients? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent a proposé un idiome appelé polymorphisme basé sur le concept, où l'héritage est implicite et caché à l'utilisateur. </font><font style="vertical-align: inherit;">Vous pouvez en apprendre plus à ce sujet dans son rapport </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inheritance Is The Base Class Of Evil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - où il montre toute l'idée en utilisant Photoshop et l'historique des actions à titre d'exemple - vous apprendrez comment le «pinceau historique» fonctionne réellement.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu sur LLVM et son appareil</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais montrer les avantages de cet idiome en utilisant l'exemple de LLVM. </font><font style="vertical-align: inherit;">Qui ne sait pas, LLVM est une infrastructure pour développer des compilateurs. </font><font style="vertical-align: inherit;">Vous trouverez ci-dessous une architecture LLVM de très haut niveau, qui ne couvre que les entités utilisées plus loin dans l'article. </font><font style="vertical-align: inherit;">Pour plus d'informations, consultez la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> officielle </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit de l'architecture de LLVM et, en principe, de tout compilateur moderne.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Les principales parties sont les suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Front End prend le code source du programme et le transforme en une représentation intermédiaire (IR). </font><font style="vertical-align: inherit;">Cela simplifie le travail du reste du compilateur afin qu'il ne traite pas le code C ++ complexe.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End - un ensemble d'optimisations, d'analyses et de transformations. </font><font style="vertical-align: inherit;">Dans sa forme la plus générale, il s'agit d'un ensemble de passes (Passes). </font><font style="vertical-align: inherit;">Toutes les passes sont enregistrées et lancées par un composant spécial appelé PassManager.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back End génère directement le code cible.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le compilateur présente le programme sous la forme de plusieurs entités de base. </font><font style="vertical-align: inherit;">Il s'agit d'un module (fichier conditionnellement .cpp), d'une fonction, d'une unité de base qui contient un ensemble d'instructions. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM dispose désormais de deux versions de PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager, il utilise le polymorphisme basé sur l'héritage d'exécution classique. </font><font style="vertical-align: inherit;">La hiérarchie d'héritage comprend les passes exécutées sur un module, une fonction, une boucle, etc.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager - une nouvelle version, juste basée sur le polymorphisme basé sur le concept, il est proposé de remplacer LegacyPassManager. </font><font style="vertical-align: inherit;">Les deux versions existent en parallèle et se développent indépendamment.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'idée de l'article est de démontrer le concept de code produit réel, qui est implémenté de deux manières différentes, et de montrer les avantages de cette dernière approche.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de polymorphisme basé sur un concept dans LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme implémenté dans Legacy</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, comment tout est organisé de manière classique, dans le LegacyPassManager. </font><font style="vertical-align: inherit;">Disons que nous avons un PassManager de classe et qu'il y a un Pass de classe - un passage. </font><font style="vertical-align: inherit;">Nous avons une telle hiérarchie: ModulePass, dont notre classe hérite, par exemple, de la propagation constante. </font><font style="vertical-align: inherit;">Il existe une méthode runOnModule, ici elle est virtuelle. </font><font style="vertical-align: inherit;">Nous avons donc le polymorphisme d'exécution habituel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le code, quel est le problème ici? On voit que dans cette hiérarchie, les méthodes de démarrage d'un passage sont différentes selon ce sur quoi elles doivent être effectuées (sur une fonction - runOnFunction, un module - runOnModule, un cycle - runOnLoop, etc.). À son tour, cela rend impossible de traiter la collection de passes qui fonctionnent avec différentes entités IR d'une manière unique (en fait, appliquer le polymorphisme). Il semblerait, évidemment, comment le faire correctement: vous avez besoin d'une méthode d'exécution virtuelle, qui sera redéfinie chez les héritiers. Mais alors un problème se pose: les méthodes d'exécution dans les classes successives auront une signature différente, car le paramètre est toujours transmis de son type - fonction, module, etc. Donc, vous devez créer une classe de base factice pour Module, Function, etc., passer un pointeur vers cette classe lors de l'exécution et effectuer une conversion vers le bas à l'intérieur de la méthode,en fonction du type d'objet situé sur ce pointeur. Et quelque chose d'étrange commence: lorsqu'une nouvelle entité subordonnée apparaît, nous sommes maintenant obligés de réécrire le code supérieur à chaque fois, ce qui contredit tous les principes de conception.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez écrire manuellement une classe d'adaptateur pour chaque cas. </font><font style="vertical-align: inherit;">Mais c'est une idée longue et inintéressante, et en fait étrange, d'écrire des classes wrapper pour le fonctionnement pratique de la portion uniquement des composants. </font><font style="vertical-align: inherit;">Il serait préférable de générer ce code automatiquement à l'aide de modèles. </font><font style="vertical-align: inherit;">C'est exactement ce qu'il est proposé de traiter dans l'approche à l'examen. </font><font style="vertical-align: inherit;">De plus, comme vous le verrez plus tard, nous obtiendrons des conséquences plus utiles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme suggéré dans la nouvelle version</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les événements suivants se produisent dans le nouveau PassManager. </font><font style="vertical-align: inherit;">Le concept d'un objet polymorphe est généralisé comme suit. </font><font style="vertical-align: inherit;">Nous disons que si un objet implémente une méthode, alors nous introduisons un ensemble de méthodes que nous voulons être polymorphes, et nous disons que toutes les classes qui implémentent cette méthode sont polymorphes, c'est-à-dire que nous pouvons les utiliser dans des contextes interchangeables dans c'est PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez la classe PassManager dans LLVM. </font><font style="vertical-align: inherit;">Voici une version simplifiée, et la version complète se trouve dans llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">Le paramètre de modèle IR se spécialise directement dans l'entité sur laquelle nous passons (la fonction d'exécution). </font><font style="vertical-align: inherit;">Il peut s'agir d'un module, d'une fonction ou d'un cycle. </font><font style="vertical-align: inherit;">Nous regardons le code, d'autres explications seront:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons les entités de base suivantes:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes — ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, quel genre de type cela devrait-il être? </font><font style="vertical-align: inherit;">Qu'est-ce qui est stocké dans le vecteur Passes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons d'abord ce que sont PassModel et PassConcept. </font><font style="vertical-align: inherit;">Ce sont des classes d'assistance internes à PassManager. </font><font style="vertical-align: inherit;">Ils sont tous deux dans l'espace de noms de détail. </font><font style="vertical-align: inherit;">Voyons d'abord à quoi ressemble la classe PassConcept. </font><font style="vertical-align: inherit;">Il contient à nouveau la même méthode d'exécution, ici c'est une méthode purement virtuelle.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxième classe, PassModel, est également passe-partout. </font><font style="vertical-align: inherit;">Il est hérité de PassConcept.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qu'il contient:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Champ pass_ privé de type PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un constructeur qui accepte un objet de type PassT comme entrée. </font><font style="vertical-align: inherit;">Il ne fait rien d'intrigant, il initialise uniquement pass_ en utilisant la sémantique du mouvement</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode run, qui appelle simplement la méthode run à la passe. </font><font style="vertical-align: inherit;">Passer, respectivement, tous les arguments qui peuvent être là.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous rappelons maintenant où nous avons commencé. À son tour, PassManager stocke tous ces passages. Dans les passes vectorielles des éléments de type PassConcept. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, la grande image. Créé par PassManager. En utilisant AddPass, il enregistre les passes que nous voulons effectuer sur le module, la fonction, la boucle, etc. Par exemple, en ligne, propagation constante, déroulement de boucle, etc. Ils ne sont eux-mêmes hérités de personne, ils ne devraient avoir qu'une méthode run. Et tout ce concept le fournit. Comment?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disons que nous avons une optimisation en ligne. Nous ajoutons un objet de type Inline à addPass. En conséquence, dans Passes, dans le vecteur, nous mettons cette Inline, déjà sous la forme de PassConcept. Comment peut-on le faire? Inline n'est pas hérité de la classe PassConcept. Comment mettre un élément dans un vecteur? Nous ne pouvons pas faire le casting sur le type de base (upcasting) car il n'y a pas d'héritage. Et ici une telle astuce est faite. Nous avons cette classe d'assistance PassConcept qui définit l'interface. Il dit que tous ses descendants doivent implémenter la méthode run. Nous avons PassModel, qui à son tour est passe-partout. Et donc, lorsque nous mettons Inline, ce PassModel est instancié avec ce type Inline, cet objet est compilé à l'intérieur de cette classe. PassModel lui-même redéfinit run, qui pour lui-même appelle déjà run pour ce passage,c'est-à-dire exécuter à partir de la classe Inline. Tout cela est résolu au moment de la compilation: si Inline ne définit pas la méthode d'exécution, nous aurons une erreur au moment de la compilation.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, ce polymorphisme est obtenu sans héritage. La question peut se poser: comment n'est-ce pas l'héritage, car ici, PassModel est hérité de PassConcept? Réponse: il y a héritage, mais c'est interne, ça ne dépasse pas, l'utilisateur n'en sait rien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous parlons à un niveau conceptuel. Ici, nous avons un utilisateur, il veut remplacer une certaine méthode. En même temps, il ne veut pas être hérité, afin de ne pas tirer des dépendances supplémentaires sur lui-même. Comment faire? Nous en nous-mêmes, via PassConcept, PassModel, faisons du polymorphisme d'exécution, par héritage, mais l'utilisateur ne le sait pas: ce sont tous les intérieurs de ces deux classes, ils sont définis dans leur espace de noms.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, comment y parvenir? </font><font style="vertical-align: inherit;">J'ai une classe, appelons-la, que ce soit Inline, en termes de compilateur. </font><font style="vertical-align: inherit;">Nous ajoutons Inline au vecteur, respectivement, créons l'objet PassModel. </font><font style="vertical-align: inherit;">Il a un constructeur qui prend l'objet de ce paramètre de modèle. </font><font style="vertical-align: inherit;">Et donc, lorsque nous appelons la méthode run dans PassManager, elle parcourt tous les passages, dans ce cas, nous n'avons qu'une seule passe, elle a le type Inline. </font><font style="vertical-align: inherit;">Il appelle la méthode runC de PassConcept. </font><font style="vertical-align: inherit;">La même méthode d'exécution qui se trouve à l'intérieur de PassModel, qui est instanciée par le type Inline. </font><font style="vertical-align: inherit;">Et déjà, cette méthode appelle la méthode run sur le passage enregistré, dans ce cas, Inline, et par conséquent, run on Inline est appelé.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avantages de l'approche</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est ainsi que nous avons fait des comportements différents sans utiliser explicitement l'héritage. Nous n'avons plus la dépendance explicite qui existait auparavant dans LegacyPassManager.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle chose récursive inhabituelle que cela s'avère. Nous pouvons utiliser le polymorphisme pour tout objet qui remplace la méthode run. Étant donné que la méthode run remplace PassManager elle-même, elle peut s'enregistrer, c'est-à-dire s'incorporer dans le vecteur de passe Passes et se rappeler.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que nous pouvons tout mélanger. L'ancien PassManager, qui est hérité, a une séparation claire. Il y a l'optimisation modulaire, qui se fait sur le module; il y a une optimisation qui se produit sur la fonction. Et ici, tout se passe bien. Nous faisons PassManager, l'instancions avec le type «Module», y mettons Inline, autre chose, quelques autres optimisations modulaires. Ensuite, le deuxième PassManager, nous l'instancions avec le type «Function», mettons des optimisations sur la fonction. Et puis dans le PassManager, qui est instancié par le module, vous pouvez placer un autre PassManager, qui est instancié par la fonction, via ce vecteur Passes.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avez-vous le temps de suivre? Nous avons deux PassManagers. L'un avec le module IR de type, l'autre avec la fonction IR de type. Disons que dans celui avec le module, nous avons déjà mis un certain nombre de passes. Maintenant, nous voulons les mélanger avec des passes qui sont exécutées sur une fonction. Qu'est-ce que nous faisons? Nous appelons addPass et passons PassManager en tant que Pass, qui est instancié avec le type IR "Function" (dans le code réel, ce n'est pas PassManager lui-même qui est placé là, mais une classe spéciale qui l'enveloppe, mais au niveau conceptuel, cela n'a pas d'importance).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, nous pouvons mélanger différents niveaux d'optimisation - grâce à l'imbrication de PassManagers, exécuter alternativement des passes vers le module, la fonction, le cycle, etc. </font><font style="vertical-align: inherit;">Dans Legacy PassManager, c'est plus compliqué, il existe une classe distincte pour les modules qui a une fonction virtuelle runOnModule, une classe distincte pour les fonctions avec une méthode virtuelle runOnFunction, etc. </font><font style="vertical-align: inherit;">Ces deux classes sont héritées de l'ancêtre commun de Pass, mais elles sont indépendantes l'une de l'autre et ont une interface différente, ce qui rend l'utilisation du LegacyPassManager peu pratique pour appeler des passes sur différentes entités IR (module, fonction, boucle) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Documents de lecture supplémentaires:</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM pour les étudiants diplômés</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Une introduction simple au LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Présentation par</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut sur la façon dont les passes LLVM sont organisées</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Présentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth sur les détails de l'implémentation PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la liste de diffusion qui discute de la différence entre LegacyPassManager et PassManager</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auteurs: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ingénieur expert </font><font style="vertical-align: inherit;">, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
équipe de compilateurs AI </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, Russie </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bientôt Roman prendra la parole à la conférence C ++ Russie 2020 à Moscou avec Anton Polukhin: là, ils parleront de la version actuelle et future de la copie: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien vers le rapport</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
spécialiste en chef des </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
affaires Équipe de développement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, Russie</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505824/index.html">Guide: votre propre VPN L2TP</a></li>
<li><a href="../fr505826/index.html">Comment obtenir une vision à 100% et encore plus</a></li>
<li><a href="../fr505834/index.html">Échantillons médians. Intervalles de confiance et comparaison</a></li>
<li><a href="../fr505838/index.html">Technologie FPGA pour des milliers d'applications</a></li>
<li><a href="../fr505846/index.html">Quels sont les vrais problèmes mathématiques lors du développement de vaccins à partir de COVID-19?</a></li>
<li><a href="../fr505856/index.html">De Brute-Force à la tentative de confidentialité - ce à quoi les fournisseurs de SaaS sont confrontés</a></li>
<li><a href="../fr505860/index.html">Spring Boot, Hibernate et Kotlin pour les débutants étape par étape</a></li>
<li><a href="../fr505870/index.html">Comment promouvoir les jeux et applications mobiles au Japon, en Corée et en Chine</a></li>
<li><a href="../fr505872/index.html">Histoire des véhicules sans pilote</a></li>
<li><a href="../fr505880/index.html">Comment écrire votre index dans Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>