<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋 🕯️ 👂🏽 Berdebar. BlOC, Penyedia, async - Arsitektur Rak 🚣🏾 🤛🏿 🙆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="pengantar
 Ketika Anda mencoba menulis aplikasi, hal pertama yang Anda temui adalah bagaimana mengatur arsitektur aplikasi. Dan ketika datang ke Flutt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Berdebar. BlOC, Penyedia, async - Arsitektur Rak</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengantar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda mencoba menulis aplikasi, hal pertama yang Anda temui adalah bagaimana mengatur arsitektur aplikasi. </font><font style="vertical-align: inherit;">Dan ketika datang ke Flutter, kepala dapat sepenuhnya berputar dari apa yang Google berikan - Vanilla, Scoped Model, BLoC, MVP, MVC, MVVM, MVI, dll. </font><font style="vertical-align: inherit;">Misalkan Anda memutuskan untuk menggunakan cara yang paling modis (yang disarankan Google pada tahun 2018) dan menggunakan BLOC. </font><font style="vertical-align: inherit;">Apa itu? </font><font style="vertical-align: inherit;">Bagaimana cara menggunakannya? </font><font style="vertical-align: inherit;">Atau mungkin Redux atau RxDart? </font><font style="vertical-align: inherit;">- meskipun berhenti adalah tentang "yang lain" ... Tapi tetap saja, apa yang selanjutnya? </font><font style="vertical-align: inherit;">Perpustakaan apa yang harus dihubungkan? </font><font style="vertical-align: inherit;">Blok, Flutter_bloc, bloc_pattern, dll? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejumlah opsi dan alat arsitektur untuk implementasinya benar-benar dapat menunda tahap pemilihan untuk waktu yang lama.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk siapa artikelnya</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini terutama bermanfaat bagi mereka yang baru mulai mempelajari Flutter dan tidak tahu harus mulai dari mana. </font><font style="vertical-align: inherit;">Saya akan menunjukkan salah satu opsi untuk mengimplementasikan aplikasi pada Flutter. </font><font style="vertical-align: inherit;">Ini akan memungkinkan Anda untuk "merasakan" Flutter, dan kemudian memutuskan sendiri bagaimana dan menggunakan mana Anda akan menulis aplikasi Anda.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola dan alat. </font><font style="vertical-align: inherit;">Singkat dan sederhana</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita mulai. Hal pertama yang perlu diperhatikan adalah bahwa ada arsitektur aplikasi (pola, templat, beberapa konsep konstruksi) - ini persis sama: BLoC, MVP, MVC, MVVM, MVI, dll. Banyak dari arsitektur ini digunakan tidak hanya dalam Flutter, tetapi juga dalam bahasa pemrograman lain. Pertanyaan - apa yang harus dipilih? Menurut pendapat saya, Anda perlu memilih apa yang Anda ketahui dengan baik, tetapi hanya jika ini menyiratkan reaktivitas dan pemisahan yang ketat dari logika bisnis dari antarmuka (ya, ya - "mobil dapat warna apa saja jika hitam"). Adapun pemisahan antarmuka dan logika bisnis, saya pikir tidak perlu dijelaskan, tetapi untuk reaktivitas - coba, jika Anda belum mencoba - pada akhirnya itu benar-benar sangat nyaman dan "indah". Jika Anda tidak dapat memilihnya sendiri, biarkan kami mengizinkannya dilakukan untuk kami oleh bukan orang paling bodoh dari Google - BLOC. Kami menemukan arsitekturnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang alat - ada perpustakaan yang sudah jadi - Bloc, Flutter_bloc, bloc_pattern - mana yang lebih baik? Saya tidak tahu - semua orang baik. Anda dapat memilih dan membandingkan untuk waktu yang lama, tetapi di sini lagi, seperti di pasukan - lebih baik untuk membuat keputusan yang salah untuk saat ini daripada tidak membuat. Dan untuk saat ini, saya sarankan kembali setelah mod dan menggunakan Penyedia (apa yang direkomendasikan orang yang sama menggunakan pada 2019).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua ini akan memungkinkan kami untuk membuat blok global dan lokal, sesuai kebutuhan. </font><font style="vertical-align: inherit;">Banyak yang telah ditulis tentang arsitektur BLoC (yaitu, pola, bukan perpustakaan), saya pikir Anda tidak harus memikirkannya lagi secara detail. </font><font style="vertical-align: inherit;">Saya perhatikan hanya satu poin dalam artikel ini, bukan BLoC klasik yang akan digunakan, tetapi sedikit dimodifikasi - dalam tindakan BLoC (peristiwa) tidak akan dikirim melalui Sinks, tetapi fungsi BLoC akan dipanggil. </font><font style="vertical-align: inherit;">Hanya saja saat ini saya tidak melihat manfaat menggunakan Sinks - dan karena mereka tidak ada di sana, lalu mengapa menyulitkan hidup Anda?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrony dan Komputasi Paralel di Dart</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu juga sedikit klarifikasi tentang konsep asinkron di Dart, karena kita berbicara tentang reaktivitas. Sangat sering, pada tahap pertama berkenalan dengan Dart, arti fungsi asinkron (async) tidak dipahami dengan benar. Anda harus selalu ingat bahwa "secara default" program berjalan dalam satu utas, dan asinkron hanya memungkinkan Anda untuk mengubah urutan perintah, daripada menjalankannya secara paralel. Artinya, jika Anda hanya menjalankan fungsi dengan perhitungan besar hanya dengan menandainya async, maka antarmuka akan diblokir. Async TIDAK memulai utas baru. Bagaimana async dan menunggu bekerja ada banyak informasi di Internet, jadi saya tidak akan memikirkan hal ini juga.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda perlu membuat perhitungan besar dan pada saat yang sama tidak memblokir antarmuka, Anda perlu menggunakan fungsi komputasi (untuk hardcore khusus Anda dapat menggunakan isolat). </font><font style="vertical-align: inherit;">Ini akan benar-benar memulai utas eksekusi yang terpisah, yang juga akan memiliki area memori tersendiri (yang sangat sedih dan sedih). </font><font style="vertical-align: inherit;">Anda dapat berkomunikasi dengan aliran seperti itu hanya melalui pesan yang dapat berisi tipe data sederhana, daftar mereka.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai berlatih</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perumusan masalah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba menulis aplikasi yang paling sederhana - biarkan menjadi semacam direktori telepon. </font><font style="vertical-align: inherit;">Kami akan menggunakan Firebase sebagai penyimpanan - ini akan memungkinkan kami untuk membuat aplikasi "cloud". </font><font style="vertical-align: inherit;">Saya akan melewati cara menghubungkan Firebase ke proyek (lebih dari satu artikel telah ditulis tentang topik ini dan saya tidak melihat titik pengulangan. Catatan: Cloud Firestore digunakan dalam proyek ini.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seharusnya seperti ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi aplikasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplikasi kami akan berisi:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela otorisasi Firebase (logika dari jendela ini akan dimuat di MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela informasi - akan menampilkan informasi tentang pengguna yang programnya diotorisasi (logika jendela ini juga akan dimuat dalam MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela direktori dalam bentuk daftar telepon (logika dari jendela ini akan dimuat dalam Buku telepon terpisahBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu aplikasi yang akan berganti layar.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplikasi internal akan dibangun sebagai berikut: setiap layar akan berisi file dengan widget layar, file blok (dengan kelas blok yang sesuai), file tindakan (berisi kelas sederhana yang menjelaskan peristiwa yang mempengaruhi keadaan blok), file status (berisi kelas sederhana yang mencerminkan status blok) ), file data_model yang berisi kelas repositori (bertanggung jawab untuk menerima data) dan kelas data (menyimpan data logika bisnis blok).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplikasi akan berfungsi seperti ini - ketika layar dibuka, blok terkait diinisialisasi dengan nilai keadaan awal dan, jika perlu, beberapa tindakan awal disebut dalam konstruktor blok. </font><font style="vertical-align: inherit;">Layar dibangun / dibangun kembali berdasarkan negara, yang mengembalikan blok. </font><font style="vertical-align: inherit;">Pengguna melakukan beberapa tindakan dalam aplikasi yang memiliki tindakan yang sesuai. </font><font style="vertical-align: inherit;">Tindakan diteruskan ke kelas blok, di mana mereka diproses dalam fungsi mapEventToState dan blok mengembalikan status baru kembali ke layar, berdasarkan di mana layar dibangun kembali.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur file</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama, kita membuat proyek Flutter kosong dan membuat struktur proyek semacam ini (saya perhatikan bahwa dalam proyek demo beberapa file pada akhirnya akan tetap kosong):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela otorisasi. </font><font style="vertical-align: inherit;">Mainbloc</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda perlu menerapkan otorisasi di Firebase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan membuat kelas acara (lebih mudah untuk mentransfer data melalui acara dalam blok) dan menyatakan untuk blok Utama: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
file MainBloc \ tindakan</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mengajukan MainBloc \ state</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bendera sibuk di kelas negara digunakan untuk menampilkan progress_hud di antarmuka dan mengecualikan data yang tidak perlu dibaca dari database saat menggulir daftar. </font><font style="vertical-align: inherit;">Sebelum semua operasi di blok dimulai, keadaan baru dari tipe lama dengan set flag sibuk dikeluarkan ke aliran output - dengan cara ini antarmuka menerima pemberitahuan bahwa operasi telah dimulai. </font><font style="vertical-align: inherit;">Di akhir operasi, negara baru dikirim ke aliran dengan bendera sibuk dihapus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahli waris dari kelas MainBlocState menggambarkan keadaan blok aplikasi utama. </font><font style="vertical-align: inherit;">Ahli waris MainBlocAction menggambarkan peristiwa yang terjadi di dalamnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas MainBloc berisi 4 elemen utama - fungsi "mengubah" peristiwa menjadi status (Future mapEventToState), negara Bloc adalah _blocState, repositori negara blok adalah repo, dan aliran status "output" (yang melacak elemen antarmuka) blocStream. Pada dasarnya, ini semua adalah elemen yang menyediakan fungsionalitas blok-a. Terkadang disarankan untuk menggunakan 2 aliran output dalam satu blok - contoh seperti itu akan lebih rendah. Saya tidak akan mencantumkannya di sini - Anda dapat melihatnya dengan mengunduh proyek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas repositori blok berisi logika untuk bekerja dengan Firebase dan objek (data) yang menyimpan data yang diperlukan untuk logika bisnis yang diterapkan blok ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas MainData juga menyimpan status, tetapi status otorisasi di Firebase, dan bukan status Blok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menulis logika untuk blok utama, sekarang kami dapat mulai mengimplementasikan layar otorisasi / registrasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc diinisialisasi dalam file utama: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File utama</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saatnya melakukan penyimpangan kecil tentang StreamBuilder, Penyedia, StreamProvider, Konsumen dan Pemilih.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mundur tentang Penyedia</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyedia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - hanya mentransfer nilai yang disimpan ke pohon. Dan Anda dapat mengaksesnya hanya setelah membangun anak, yaitu Anda perlu membuat sub widget. Tidak bertanggung jawab untuk memperbarui widget. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - widget yang memantau aliran dan sepenuhnya dibangun kembali ketika </font><b><font style="vertical-align: inherit;">menerima</font></b><font style="vertical-align: inherit;"> objek baru dari aliran. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - widget yang memantau aliran dan setelah menerima objek baru, menandakan bahwa widget anak (yang dinyatakan sebagai kelas terpisah dengan metode build) harus dibangun kembali. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsumen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemilih</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah "gula sintaksis", yaitu ini sebenarnya adalah "pembungkus" yang berisi build dan menyembunyikan widget di bawahnya. Di Selector-e, Anda dapat melakukan pemfilteran pembaruan tambahan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, ketika Anda perlu membangun kembali sebagian besar layar di setiap acara, Anda dapat menggunakan opsi dengan Penyedia dan StreamBuilder. </font><font style="vertical-align: inherit;">Ketika perlu untuk membangun kembali bagian-bagian pohon widget dekat dengan daun, disarankan untuk menggunakan StreamProvider dalam kombinasi dengan Konsumen dan Pemilih untuk mengecualikan pembangunan kembali pohon yang tidak perlu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otorisasi </font><font style="vertical-align: inherit;">Kelanjutan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat memasuki aplikasi, pengguna harus masuk ke jendela otorisasi / registrasi, dan pada saat itu menu aplikasi belum tersedia untuknya. Poin kedua - untuk menyegarkan sebagian layar ini tidak masuk akal, jadi kita bisa menggunakan StreamBuilder untuk membangun antarmuka. Dan poin ketiga dalam proyek ini adalah menggunakan Navigator untuk menavigasi antar layar. Setelah menerima acara otorisasi yang berhasil, perlu untuk memanggil transisi ke layar informasi. Tapi di dalam build StreamBuilder, ini tidak akan berfungsi - akan ada kesalahan. Untuk menyiasati ini, Anda dapat menggunakan kelas pembungkus tambahan StreamBuilderWithListener (Eugene Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang daftar layar ini adalah auth_screen sendiri (saya akan berikan di sini sebagian): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, StreamBuilderWithListener dibuat untuk mendengarkan aliran dari blok. </font><font style="vertical-align: inherit;">Dan berdasarkan kondisi saat ini, baik widget LoggedWidget (jika pengguna sudah diotorisasi) atau SignInAndSignUpWidget (jika pengguna belum diotorisasi) dipanggil. </font><font style="vertical-align: inherit;">Jika blok mengembalikan status IsLogged, beralih ke layar baru menggunakan Navigator tidak terjadi di pembangun (yang akan menyebabkan kesalahan), tetapi di pendengar. </font><font style="vertical-align: inherit;">Di widget yang mendasarinya, antarmuka dibangun berdasarkan data yang dikembalikan di sini. </font><font style="vertical-align: inherit;">Di sini, bundel Provider + StreamBuilder sebenarnya digunakan, karena </font><font style="vertical-align: inherit;">ketika keadaan blok berubah, hampir seluruh antarmuka berubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mentransfer data ke blok, TextEditingController dan parameter tindakan digunakan: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
file auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela PhoneBookScreen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang mari kita bicara sedikit tentang jendela PhoneBookScreen kita. Ini adalah jendela yang paling menarik - di sini antarmuka dibangun berdasarkan 2 aliran dari blok, dan ada juga daftar dengan gulir dan pagination (pagination). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File layar Buku telepon \ Layar</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StreamProvider pertama diperlukan untuk beralih di antara berbagai layar direktori - daftar, kartu kontak, kartu kontak untuk diedit, dll. Widget untuk layar dipilih dalam fungsi caseWidget (tetapi dalam contoh ini hanya tampilan untuk daftar yang diterapkan - Anda dapat mencoba menerapkan tampilan untuk kartu kontak - ini sangat sederhana dan tidak akan menjadi awal yang buruk.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di layar ini, sekelompok StreamProvider + Selector / Consumer sudah digunakan, karena ada gulungan daftar dan tidak disarankan untuk membangun kembali seluruh layar dengannya (mis. membangun kembali widget berasal dari Pemilih / Konsumen yang sesuai dan lebih rendah di pohon). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini adalah implementasi dari daftar itu sendiri: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File layar Buku telepon \ layar</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita melihat StreamProvider kedua, yang memantau aliran blok kedua, yang bertanggung jawab atas gulir. Pagination diatur sebagai standar melalui _scrollListener (controller: _scrollController). Meskipun jendelanya menarik, tetapi mengingat deskripsi terperinci dari jendelanya, tidak ada lagi yang bisa dikatakan di sini. Karena itu, itu saja hari ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan artikel ini bukan untuk menunjukkan kode ideal, yaitu, di sini Anda dapat menemukan banyak poin untuk optimasi - dengan benar “dipecah” oleh file, gunakan instance, mixin dan sejenisnya di suatu tempat. </font><font style="vertical-align: inherit;">Juga, apa yang "meminta" langkah selanjutnya - Anda dapat membuat kartu kontak. </font><font style="vertical-align: inherit;">Tugas utama adalah untuk membangun pengetahuan, menetapkan vektor tertentu untuk membangun aplikasi, memberikan penjelasan tentang beberapa saat merancang aplikasi di Flutter yang tidak terlalu jelas pada tahap pertama dari kenalan. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek dapat diunduh di</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (untuk pendaftaran Anda dapat menggunakan surat apa pun dengan kata sandi minimal 6 karakter. Saat melakukan otorisasi ulang, kata sandi harus sama dengan yang digunakan saat pendaftaran).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489496/index.html">Mencari karyawan dan mencari pekerjaan: pandangan saya dari dalam dan luar</a></li>
<li><a href="../id489500/index.html">Menilai Tugas di Poin Cerita</a></li>
<li><a href="../id489502/index.html">Selenium + AutoIT. Windows Test Automation Windows</a></li>
<li><a href="../id489504/index.html">Cara mulai membuat peta di UE4</a></li>
<li><a href="../id489510/index.html">Mencoba memecahkan masalah memilih tiket sebelum liburan # 2</a></li>
<li><a href="../id489514/index.html">Unduh dan simpan file dengan ukuran apa pun di Google Drive secara gratis. Bug atau fitur?</a></li>
<li><a href="../id489516/index.html">Teman Bereaksi Asli dan Fastlane</a></li>
<li><a href="../id489518/index.html">Pertukaran Anggota Pertukaran Biaya Rendah Muncul Di AS</a></li>
<li><a href="../id489526/index.html">Game zero-sum dan kondisi Karush-Kun-Takker</a></li>
<li><a href="../id489528/index.html">Anda tidak menonton iklan selama pengembangan? Kekacauan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>