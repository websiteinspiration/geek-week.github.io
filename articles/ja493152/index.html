<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛸️ 🌾 🏑 ニューラルネットワークとプロセスマイニング：友達を作ろう 👨🏾‍⚕️ 👩🏽‍🔬 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プロセスマイニングは、情報システムのログに基づいてプロセスを分析できるデータ分析フィールドです。 Habréのこの分野での機械学習の使用に関するトピックに関する出版物はほとんどないため、プロセス指向の問題を解決するための予測モデルの開発における経験を共有することにしました。 VTBプログラムの一部と...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ニューラルネットワークとプロセスマイニング：友達を作ろう</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vtb/blog/493152/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスマイニングは、情報システムのログに基づいてプロセスを分析できるデータ分析フィールドです。 Habréのこの分野での機械学習の使用に関するトピックに関する出版物はほとんどないため、プロセス指向の問題を解決するための予測モデルの開発における経験を共有することにしました。 VTBプログラムの一部として、ITプロフェッショナルを始めるためのITジュニアであるプロセスマイニングチームのインターンは、銀行プロセスの調査のタスクのコンテキストで機械学習方法をテストしました。カットの下では、いつ、どのようにしてそのような問題を解決するという考えがあったか、何をしたか、どのような結果を得たかについて話します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/hi/lg/6nhilgitc0hyxrpmzuypu6w0irg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IT Junior Programは、2019年9月に開始されたVTB Bankの初心者ITプロフェッショナル向けの年間インターンシッププログラムです。</font><font style="vertical-align: inherit;">インターンシップは6ヶ月続きます。</font><font style="vertical-align: inherit;">2019プログラムの結果によると、インターンの半数以上がスタッフに加わり、会社の従業員になりました。</font><font style="vertical-align: inherit;">プログラムの詳細、選考の開始、候補者の要件については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようにして、このプログラムの研修生は銀行の業務に取り組みました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的な座標系では、プロセスを理解して形式化するために、次のことが必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">従業員との面接を実施します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用可能なレポートとドキュメントを分析します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスマイニングアプローチでは、デジタルプロセスモデルは、プロセス参加者の専門家の意見だけでなく、情報システムからの関連データにも基づいて形成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、プロセスの客観的なデジタルモデルが得られます。これは、プロセスのITシステムにおける実際のデータの動きを反映しています。結果のモデルはリアルタイムで機能し、プロセスの現在の状態を必要な詳細度で表示できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスマイニングプラットフォームと世銀の実際のタスクについて話し合いました。</font><font style="vertical-align: inherit;">実装されたソリューションにより、政府機関への必須レポートの準備に必要な時間を大幅に削減し、プロセスの欠陥を特定して最適化し、作業中の購入状況の毎日のプレゼンテーションを確立することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、お客様はプロセスの現在の状態を定性的に判断するだけでなく、将来の状態を予測する必要もありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、NVIDIAから調査のために親切に提供された高性能DGXステーションを使用した一連の既知のイベントを使用して、調達プロセスの期間を予測する問題（例としてBPIチャレンジ2019データセットを使用）を解決する方法を段階的に説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスマイニング用の機械学習アプリケーション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、CatBoostRegressorを使用してベースラインを構築し、ニューラルネットワークとカテゴリ変数を埋め込むソリューションを開発しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースデータにカテゴリ機能とマテリアル機能が存在するため、ブースティングを使用することを決定しました。ブースティングは、コーディングなしでカテゴリ機能を処理でき、離散およびマテリアル入力の問題も解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットは、完全にマテリアルな属性を構築し、マテリアル入力全体の問題を解決するために使用されました。次に、これら2つのアプローチを比較し、ネットを気にするかどうかを決定しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの説明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事業分野で私たちに適しており、同様の特性セットを持つ外部データを使用することが決定されました。</font><font style="vertical-align: inherit;">使用されたBPIチャレンジ2019データセットには、25万件のケースが含まれています。これは150万件のイベントです。</font><font style="vertical-align: inherit;">初期データは、21の記号のセットで記述されます。18のカテゴリカル（インデックス記号があります）、2つのブール値、1つの実数です。</font><font style="vertical-align: inherit;">調達プロセスの実行時間は、ビジネスの実際のニーズに対応するターゲット変数として選択されました。</font><font style="vertical-align: inherit;">特性の詳細な説明</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">については、データセットの説明を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースライン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルをトレーニングする前に、データはトレーニング（トレーニング）サンプルとテスト（テスト）サンプルに0.8 / 0.2の比率で分割されました。さらに、分割はイベントごとではなく、ケースごとに発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークの形で複雑な独自のソリューションを使用することがどれほど適切かを判断するために、ベースラインは、決定木に対する勾配ブースティングの高度なライブラリであるCatBoostを使用して構築されました。ベースラインを構築するために、最小限のデータ前処理が実行され（データ内の対応する頻度によるカテゴリカル特徴のコーディング）、ターゲット変数（ケース期間）および多数の新しい特徴（元のデータセットにすでに含まれているものに加えて）が開発されました。</font></font><br>
<br>
<ul>
<li>   .  ,        :      ,         ,     ,          ,   ,      .<br>
</li>
<li>Exponential Moving Average     . EMA     ,         .<br>
</li>
<li>     (, ,  ).<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングセットでCatBoostRegressorをトレーニングした後、次の結果が得られました。MAE（平均絶対誤差）= 17.5日（つまり、予測されたターゲット変数の値は、平均で真の値とは17.5日異なります）。この結果は、ニューラルネットワークの有効性をテストするために使用されました。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで重要な詳細の1つは、ベースラインのターゲット変数の開発です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を挙げましょう。セットC（データセット内のすべてのケースのセット）のc_iでそれを示します。各ケースは、イベントの順序付けされたシーケンスです。つまり、c_i =（e_0、...、e_ni）です。ここで、niはi番目のケースの長さです。イベントごとに、タイムスタンプ（開始時刻）があります。これらの一時的なスタンプを使用して、最後のイベントがない場合のケースの期間を計算できます。ただし、そのようなターゲットを各イベントに割り当てる、つまりek ci ci、ek→ti（tiはi番目のケースの期間）に対応させることは、あまり適切ではありません。まず、期間が異なる場合に、同様のイベント（通常）が発生する可能性があります。次に、イベントの特定のサブシーケンス（時間順）からケースの期間を予測します（これは、イベントのシーケンス全体がわからない、つまり前にケースがわからないという事実が動機ですどのようにそれが起こったか、しかし私たちはこのケースからのいくつかの既知の（発生した）イベントに従ってケース全体の期間の評価をしたいと思います）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、各ケースを1から時間順イベントのケースの長さまでの長さのサブシーケンスに分割し、これらのサブシーケンスが取得されるケースの期間に等しいターゲット変数を割り当てる必要があります。つまり、対応するci∈C、ci→{sub_cj} ni（ni前と同じように、i番目のケースの長さ）、j = 1およびlen（sub_cj）= j。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、各ケースをサブシーケンスに分割し、ケース全体の期間をそのような各サブシーケンスに割り当てます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブシーケンスの詳細</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
前述のように、ケースをサブシーケンスに分割し、それぞれにケースの期間を割り当てます。入力データのサイズに正確なブースティングを使用します。これでX = {{sub_c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ni </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1 N</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、sub_c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ik</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はi番目のケースのk番目のサブシーケンス、t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><sub><font style="vertical-align: inherit;">i</font></sub><font style="vertical-align: inherit;">番目のケース</font><font style="vertical-align: inherit;">の長さ、Nはケースの数です。つまり、次元[∑ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、sc、17]、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、対応するケースのサブシーケンスの長さに等しい変数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カテゴリー変数を頻度でコーディングした後、実際の変数とブール変数、およびコード化されたカテゴリー変数があります（インデックス変数は学習プロセスでは使用されません）。また、サブシーケンスで値を平均化することもできますが、カテゴリ機能では、発生するカテゴリ値の平均頻度を取得します。これは、ケースのイベントのサブセットの集約を説明する特性、つまりサブシーケンスを説明する特性と見なすこともできます。そのままにして、何が起こるか見てください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次元でscを平均化すると、次の次元が得られます：[：</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、17]。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル構築</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケースに基づいて、トレインを別のトレインと検証サンプルに分割し、デフォルトのパラメーターでCatBoostRegressorを受け取り、トレーニングサンプルを渡し、検証サンプルで検証し、最適な反復を行い、MAEを検証メトリックとして使用します。テストでは次の結果が得られます（下図）（トレインが構築されたのと同じパイプラインのテストを個別に準備します。すべての兆候はテストにあるデータに基づいています。つまり、ターゲット変数に焦点を当てた兆候はありません。唯一の警告：テストのカテゴリ特徴がトレーニングで見た値と一致しない場合は、テストでのこの値の頻度を考慮し、エンコーディング用のディクショナリを更新します）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースライン結果</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90b/f18/386/90bf183863f8ad2cdb50098c58d06a37.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
•反復：500。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•学習率：0.1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングパラメータ：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•トレーニング時間：2分未満。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•鉄：テスラk80（コラボ製）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•MAEのテスト：17.5日。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•テストでのケースの平均期間：66.3日。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神経網</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットアップ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークをトレーニングするために、データが改善されました。カテゴリ変数の埋め込みが作成され、ターゲット変数の分布が調整されました。</font><font style="vertical-align: inherit;">次に、ニューラルネットワークはNVIDIA Tesla K80（Google Colab）とNVIDIA DGX Stationでトレーニングされました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の結果が得られました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA K80（Google Colab）でのトレーニング時間：20分。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA DGXステーションでのトレーニング時間：8分。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークのトレーニング時間は、使用するGPUの技術特性の違いによるものです。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA Tesla K80（Google Colab）</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA DGXステーション</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1X NVIDIA Tesla K80 12GB</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4X NVIDIA Tesla V100 32GB</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前処理</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい兆候</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントの価値に関するEMA：各ケースの活動コストの傾向を把握したいと考えています。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欠陥のタイプ：データセットの説明には、購入（イベント）の4つのタイプの記述統計に関する情報があります。これらのタイプは、元のデータセットの2つの変数の値に分けられます。</font><font style="vertical-align: inherit;">単純に集計し直します（データセットの説明を見ると、何を話しているかがわかります）。</font></font><br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カテゴリー符号我々</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、カテゴリー符号の一意の値を順番に自然数で単純にエンコードするため、後で埋め込みを教えることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カテゴリー変数</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の埋め込み各カテゴリー変数の埋め込みの次元を決定します。</font></font><br>
<br>
<ul>
<li>,   ̆  ̆ ̆.    ̆ ,         ̆  ̆ ,    ̆,  .  : MUi&nbsp; = min(CAT_EMBEDDING_DIM; (len(uniquei) + 1) // 2), CAT_EMBEDDING_DIM — , uniquei —   i-  .<br>
</li>
<li> ,      3,       i-̆ ̆   max(3;MUi)+1,  1,        ,     train,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">unk</a>-.<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレインサンプルのターゲットの分布を調整します。</font></font></b>&nbsp;<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初の分布は、外れ値（25万日続いたケース）と多数の短いケースのために左に大きくシフトしていることが判明したため、0.05パーセンタイルと0.95パーセンタイルをカウントし、ターゲット間のトレインのデータを残しますこれらの急流。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、約1日と約100日間続くケースがあります。つまり、ターゲット変数は数桁の大きさになります。したがって、決定アルゴリズムの周りのターゲット変数の分布では分散が一定であるという仮定はほとんど満たされません。つまり、ターゲット変数の分布は正常に近いですが、ターゲット変数が1未満または100を超える可能性があるため、分散は一定ではありません。したがって、少なくともどういうわけかこの効果を平準化して、データを正規化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果を下のグラフに示します（黒い線は正規分布です）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k4/qs/vz/k4qsvz1egedfnm9q4y6nljidoam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、データをケースごとにトレーニングと検証に分割します。</font><font style="vertical-align: inherit;">ここにも明らかなニュアンスがあります。すべてのデータに従って計算された平均と偏差でターゲットを正規化し、次に列車と検証で除算します。つまり、列車内の顔のように見えますが、補助問題を解決しているため、この顔はクリティカル。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建物の看板</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自然数でエンコードされたカテゴリ標識のみを列車から取得します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケースから部分文字列を取得するのではなく、単にイベント、つまり埋め込み用のデータの1行を取得します。これは、コード化されたカテゴリ機能によって特徴付けられる1つのイベントです。</font></font><br>
</li>
<li> :     ,   ̆,      ,   ,        ,            ̆  ̆    ̆. - ,         ̆,  ,  ,     ̆ (    ),      (     ,  - ̆  ).<br>
</li>
<li>       ̆        .<br>
</li>
<li>     ,     8-̆̆   elu   ̆,   (  ,   ,     ,  L2-)     .<br>
</li>
<li>,           , —    ,      ,    .<br>
</li>
<li>Summary:    — ̆  ̆ ̆ ̆        —  ̆.<br>
</li>
</ul><br>
<h3>   </h3><br>
<ul>
<li>Batch size = 1000</li>
<li>Learning rate = 3e-04.</li>
<li>  = 15.</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station .</li>
<li> (colab) – 50 .</li>
<li> (Nvidia DGX Station) — 18 .</li>
</ul><br>
<img src="https://habrastorage.org/webt/53/4y/gh/534yghkinehatjl8cm1xwg5j0oi.png"><br>
<br>
<h3> </h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ準備</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これで、カテゴリ変数の埋め込みがあります（ニュアンスがここにあります：トレーニングのカテゴリ変数の一意の値を正直に取得しました（トレーニングの埋め込みに割り当てたものではなく、最初に割り当てたもの）トレーニング）、したがって、テストデータに、トレインで見なかったカテゴリ変数の値が存在する可能性があります。つまり、この値の埋め込みをトレーニングしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような値の場合、埋め込み行列に別の行が作成されますが、この場合の問題は、トレーニング中には含まれないため、学習しないということです。これから進んで、以前に見られなかったカテゴリー変数の値に遭遇した場合、このベクトルを使用しますが、実際には初期化分布から単純に取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベクトルをトレーニングする方法には、モデルを改善する方向性があります。アイデアは、トレイン内の非常にまれな値がこのベクトルでエンコードできるということです。なぜなら、条件付きで初期サンプル全体の20％を構成するテストでのみ新しい値が表示される場合、この値はまれであり、おそらく動作します。電車の中の珍しい値と同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各イベントで、カテゴリ変数を対応する埋め込みに置き換え、実属性とブール属性に接続し、サイズ[N、F]の行列を取得します。ここで、Fはカテゴリ変数の埋め込みの次元の合計、実属性とブール属性の数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントのグループ化をサブシーケンスで実行します（以前に行ったように）。</font><font style="vertical-align: inherit;">サブシーケンスのターゲット変数は、サブシーケンスが取得されたケースの期間です。</font><font style="vertical-align: inherit;">このサブシーケンスのイベント数とイベントのコストの合計をサブシーケンスのベクトルに追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで固定サイズのマトリックスができました-モデルにフィードできます（マトリックスを正規化する前に）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列化方法</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各GPUに対してタワーを作成します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ステップで、タワー間でパラメーターを分割します。</font></font><br>
</li>
<li>       .<br>
</li>
<li> ̆   ,   .<br>
</li>
<li>       (      ,       ̆ ̆         ).<br>
</li>
<li>        .<br>
</li>
<li>     ,   -  (   ,  word2vec-style,     ).<br>
</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>          ()   ()  ().<br>
</li>
<li>̆ :   —   ,     gpu     ,    ,   gpu     .<br>
</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>: 7-̆̆    elu.<br>
</li>
<li>   ̆ ,    .<br>
</li>
<li>Batch size = 1000.<br>
</li>
<li>Learning rate = 3e-04.<br>
</li>
<li>  = 15.<br>
</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station.<br>
</li>
<li> (colab) = 20 .<br>
</li>
<li> (Nvidia DGX Station) = 8 .<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルグラフの一部</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/u5/4e/3e/u54e3eoth5n5kmcdryndbpqgcua.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースの消費と並列化</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
CPUでのニューラルネットワークのトレーニングには、NVIDIA DGXステーションの約4倍の時間がかかります。この場合、違いは重要ではないようです。NVIDIADGXステーションでは8分、CPUでは32分です。ただし、これはデータ量が少ない小さなモデルです。実際のプロジェクトを実装すると、ケースとイベントが数倍になるため、CPUのトレーニングには少なくとも1週間かかります。この場合、NVIDIA DGX Stationを使用すると、トレーニング時間が2日間に短縮され、作業効率が大幅に向上します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、学習プロセスの速度は、使用するGPUの数に大きく依存することも明らかになりました。これは、NVIDIA DGX Stationの利点を示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、前処理なしで元のデータセットを使用してNVIDIA DGXステーションのCPUおよびGPUでの以前の実験で確認されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUの学習時間：6分18秒。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUトレーニング時間：34秒。</font></font><br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU </font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f1/015/d82/6f1015d82101dda1e0af40e599ee96a2.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">負荷の視覚化CPU負荷の視覚化</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/efe/3ae/f3b/efe3aef3b801dcbd14655b3851ae9ad3.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルネットワークの結果</font></font></h3><br>
<img src="https://habrastorage.org/webt/-g/2g/p1/-g2gp1o1sdktbwtspcurjfdiwqu.png"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストMAE = 10日。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストでのケースの平均期間= 67日。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推論時間= 20秒。</font></font><br>
</li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスマイニングタスクのコンテキストで機械学習方法を評価するパイロットを実装しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは、ビジネスにとって重要な問題を解決するためのツールのリストをテストし、拡大しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味深い結果の1つは、DGXステーションが装備された4つのTesla v100カードでの並列コンピューティングの独自の実装の作成でした。複数のgpuを使用すると、gpuの数とほぼ一致して学習が加速します（コードは並列化されます）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に継続的なエントリへの移行とニューラルネットワークの使用により、ベースラインを1週間外れるようになりました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間は数分から1時間半に増加します（最終的なアーキテクチャと埋め込みでのトレーニングですが、埋め込みは事前トレーニングで使用できるため、時間は20分に短縮されます）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されている実験は、プロセスマイニングの分野で、機械および深層学習アルゴリズムがうまく適用できることを示しています。</font><font style="vertical-align: inherit;">さらに、学習プロセスの速度は、使用するGPUの数に大きく依存することが明らかになりました。これは、NVIDIA DGX Stationの利点を示しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をどのように改善できるか</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントのWord2vecスタイルの埋め込み</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
カテゴリカル変数の埋め込みを含むモデルを作成したとき、相互に関連するイベントのシーケンス、つまりケース内のイベントの固有のセマンティクスは考慮していませんでした。</font><font style="vertical-align: inherit;">ケース内のイベントの順序から役立つ情報を学ぶには、これらのイベントの埋め込みをトレーニングする必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのカテゴリー特徴と1つの実数を取り、実数をバケットで除算すると、各トランザクションは、カテゴリー変数の値と、実変数の値が入るバケットによって特徴付けられます。</font><font style="vertical-align: inherit;">これらの2つの値を組み合わせると、イベントの単語の類似語が得られます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケースを文と見なします（文の単語のセットは、ケースのイベントのセットに対応します）。</font></font><br>
</li>
<li> ̆      ,          ̆   ̆,    ,             .<br>
</li>
<li>   ̆,     Skipgram  CBOW   .<br>
</li>
<li>  ,      ̆,            .<br>
</li>
</ul><br>
<b> </b><br>
<br>
<ul>
<li>  Skipgram.<br>
</li>
<li>  — 5.<br>
</li>
</ul><br>
<ul>
<li>Batch size = 1000.<br>
</li>
<li>Learning rate = 3e-04.<br>
</li>
<li>  = 10.<br>
</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station.<br>
</li>
<li> (colab) — 20 .<br>
</li>
<li> (Nvidia DGX Station) — 8 .<br>
</li>
<li>Test MAE    : 10 ̆.&nbsp;<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/438/137/cb8/438137cb87ac22637e44a01da4a56dfc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
埋め込みの機能を使用して</font><b><font style="vertical-align: inherit;">カウント</font></b><font style="vertical-align: inherit;">すると、1日の10分の2の増加になります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的に</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らが少し訓練したので、もちろん、埋め込みは教育を受けていませんでした。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カテゴリカル埋め込みからの約290の機能と、セマンティック埋め込みからの20の機能があります（ディクショナリのサイズが小さいため、これを行うのは意味がありません）。そのため、機能の比率の不均衡により、これらのセマンティック機能の影響を平準化できます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント（ケース）のシーケンスは順序付けられているため、順序が重要であり、これから情報を抽出できるため、イベント間のセマンティクスを何らかの方法でトレーニングセットに追加する必要があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">埋め込みには、より洗練されたアーキテクチャを使用できます。</font></font><br>
</li>
<li>      ,       ,    —     .<br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja493138/index.html">私に話しかけてください：今日、音声ボットができること</a></li>
<li><a href="../ja493140/index.html">シポッリーノの冒険：FlantによるITクエストの隔離</a></li>
<li><a href="../ja493142/index.html">「Kubernetesを使いましょう！」8つの問題があります</a></li>
<li><a href="../ja493146/index.html">今日できるエキサイティングなサイドプロジェクト</a></li>
<li><a href="../ja493150/index.html">Ciscoルータを使用した「リモート」</a></li>
<li><a href="../ja493158/index.html">Loghouse 0.3-Kubernetesのロギングシステムの待望のアップデート</a></li>
<li><a href="../ja493160/index.html">2019年にhh.ruでスマート検索を改善した方法：インフォグラフィック</a></li>
<li><a href="../ja493162/index.html">オンライン会議と会議の公開リスト</a></li>
<li><a href="../ja493164/index.html">オンラインビジネスは現在の環境で生き残っていることがわかります。どうして？削除されたDNA</a></li>
<li><a href="../ja493166/index.html">Ontol：「バーンアウト」に関する記事の選択[100+]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>