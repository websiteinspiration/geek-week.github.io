<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆑 🥡 👩🏿‍⚕️ Bagaimana kami memecahkan masalah memori tumpukan tidak diinisialisasi pada Windows ☁️ 👨🏻‍⚕️ 📡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam catatan ini, saya akan menguraikan bagaimana Microsoft menghilangkan kerentanan yang terkait dengan memori tumpukan tidak diinisialisasi dan men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami memecahkan masalah memori tumpukan tidak diinisialisasi pada Windows</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam catatan ini, saya akan menguraikan bagaimana Microsoft menghilangkan kerentanan yang terkait dengan memori tumpukan tidak diinisialisasi dan mengapa kita melakukan ini sama sekali.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kemudahan navigasi, catatan dibagi menjadi beberapa bagian:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja dengan memori yang tidak diinisialisasi: riwayat masalah</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obat untuk kerentanan memori yang tidak diinisialisasi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - inisialisasi otomatis</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengamatan menarik terkait dengan penggunaan InitAll</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi kinerja</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai Pengguna</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana masa depan</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karya ini tidak akan mungkin terjadi tanpa kolaborasi erat antara Visual Studio, Windows, dan MSRC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja dengan memori yang tidak diinisialisasi: riwayat masalah</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membuat bahasa pemrograman C dan C ++, penekanannya adalah pada kecepatan tinggi dan kontrol fleksibel oleh pengembang. </font><font style="vertical-align: inherit;">Karena alasan ini, bahasa-bahasa ini tidak memaksa inisialisasi variabel. </font><font style="vertical-align: inherit;">Bekerja dengan variabel yang tidak diinisialisasi menyebabkan perilaku yang tidak terdefinisi, sehingga mereka harus diinisialisasi sebelum digunakan, dan tanggung jawab untuk mematuhi aturan ini sepenuhnya berada pada pengembang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerentanan terkait dengan memori yang tidak diinisialisasi berkurang menjadi dua jenis:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengungkapan konten: data yang disimpan dalam bagian memori yang tidak diinisialisasi disalin di luar area tepercaya dan diketahui oleh orang-orang yang tidak memiliki wewenang yang sesuai.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan langsung memori yang tidak diinisialisasi. </font><font style="vertical-align: inherit;">Contoh: tulis dengan pointer yang tidak diinisialisasi.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dipahami bahwa masalah dapat terjadi terlepas dari apakah memori dialokasikan pada stack atau pada heap. </font><font style="vertical-align: inherit;">Posting ini adalah tentang memori tumpukan, dan selanjutnya kita akan berbicara tentang tumpukan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh menggunakan memori yang tidak diinisialisasi</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> size;  <font></font>
GetSize(&amp;size); <span class="hljs-comment">//       ?</span>
<span class="hljs-built_in">memcpy</span>(dest, src, size); <span class="hljs-comment">//  memcpy </span>
                         <span class="hljs-comment">//  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya di sini adalah bahwa jika fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak memberikan nilai ke variabel 'ukuran' di semua cabang program, maka </font><font style="vertical-align: inherit;">ukuran yang tidak diinisialisasi akan diteruskan ke </font><font style="vertical-align: inherit;">panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Karena itu, kesalahan baca atau tulis di luar buffer dapat terjadi jika nilai 'size' lebih besar dari ukuran buffer 'src' atau 'dest'.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh ekspansi memori yang tidak diinisialisasi</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
      <span class="hljs-keyword">uint8_t</span> field1;
      <span class="hljs-keyword">uint64_t</span> field2;<font></font>
};<font></font>
mystruct s {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">memcpy</span>(dest, &amp;s, <span class="hljs-keyword">sizeof</span>(s));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyalin struktur di luar area tepercaya (mis., Dari mode kernel ke mode pengguna). Pada pandangan pertama, tampaknya struktur sepenuhnya diinisialisasi, tetapi antara 'field1' dan 'field2' kompiler memasukkan byte placeholder yang tidak secara eksplisit diinisialisasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai hasil dari memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byte placeholder akan disalin di luar area tepercaya bersama dengan konten yang tidak diinisialisasi yang ditulis sebelumnya ke alamat virtual ini. </font><font style="vertical-align: inherit;">Mungkin, misalnya, sepotong kunci enkripsi rahasia (yang akan menjadi terlihat dalam mode pengguna), sebuah penunjuk (yang akan menyebabkan ASLR rusak), atau sesuatu yang lain. </font><font style="vertical-align: inherit;">Dalam beberapa kasus, dapat dengan mudah dibuktikan bahwa tidak ada data yang sangat penting ditransmisikan, dalam kasus lain akan sangat sulit. </font><font style="vertical-align: inherit;">Tapi bagaimanapun, mencari tahu seberapa serius masalah dengan memori yang tidak diinisialisasi adalah pekerjaan yang tidak berterima kasih, dan kami akan rela melakukan sesuatu yang lain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistik kesalahan memori yang tidak diinisialisasi</font></font></h3><br>
<p><img src="https://habrastorage.org/webt/hb/la/gn/hblagnxiqxpsgewdennaq6tx8o8.png" alt="Gambar 8"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: dalam gambar ini, menggunakan memori yang tidak diinisialisasi mengacu pada kedua jenis masalah: penggunaan langsung dan pengungkapan konten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam beberapa tahun terakhir, jumlah kesalahan tersebut telah meningkat. </font><font style="vertical-align: inherit;">Ini mungkin sebagian karena meningkatnya minat pada mereka dari para peneliti dan, sebagai akibatnya, munculnya alat yang efektif untuk pencarian mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klasifikasi yang lebih rinci dari kesalahan-kesalahan ini mengungkapkan beberapa tren yang lebih menarik.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/od/bg/sq/odbgsqun-kof4vx6j8ws_v9d9f8.png" alt="Gambar 6"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: dalam diagram ini, penggunaan memori yang tidak diinisialisasi TIDAK termasuk pengungkapan kontennya.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/rl/ql/ee/rlqleezbmgk3oeo-bxztqaaphry.png" alt="Gambar 5"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melihat diagram-diagram ini, kita dapat menarik kesimpulan berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antara 2017 dan 2018, kerentanan memori yang tidak diinisialisasi menyumbang sekitar 5-10% dari semua kerentanan dalam laporan Microsoft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerentanan terkait dengan alokasi memori pada stack dan kerentanan terkait dengan alokasi memori di heap / pool ternyata hampir sama.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada lebih banyak kasus pengungkapan konten memori yang tidak diinisialisasi daripada ada kasus yang menggunakan memori yang tidak diinisialisasi.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literatur tambahan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pengantar topik yang lebih lengkap, lihat sumber daya berikut:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obat untuk kerentanan memori yang tidak diinisialisasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka mencoba memecahkan masalah yang dijelaskan dalam beberapa cara.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis statis (baik selama kompilasi dan setelah)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ulasan Kode</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi otomatis</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis statis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft menggunakan banyak peringatan penganalisa statis untuk menangkap variabel yang tidak diinisialisasi (termasuk C4700, C4701, C4703, C6001, C26494, dan C26495). </font><font style="vertical-align: inherit;">Diagnosis ini konservatif, mis. </font><font style="vertical-align: inherit;">Untuk mengurangi kebisingan, mereka mengabaikan beberapa pola yang dapat menyebabkan memori yang tidak diinisialisasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejumlah aturan ketat untuk penganalisis statis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semmle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juga telah ditulis </font><font style="vertical-align: inherit;">, yang dijalankan pada beberapa basis kode Windows. </font><font style="vertical-align: inherit;">Tetapi diagnostik ini menimbulkan banyak kebisingan dan sulit untuk memeriksa kode dalam jumlah besar. </font><font style="vertical-align: inherit;">Selain itu, kepatuhan terhadap aturan-aturan ini dan memperbaiki kesalahan sangat memakan waktu. </font><font style="vertical-align: inherit;">Akibatnya, ternyata sulit dan mahal untuk menggunakannya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuzzing, seperti yang Anda tahu, sulit untuk diukur. </font><font style="vertical-align: inherit;">Fuzzer yang baik mahal untuk dirawat dan membutuhkan penyesuaian untuk tugas tertentu. </font><font style="vertical-align: inherit;">Dengan basis kode ukuran seperti Microsoft, sangat sulit untuk memastikan cakupan fuzzing penuh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekalipun dimungkinkan untuk dengan sempurna menutupi semua kode dengan mereka, fuzzers tidak dapat mendeteksi pengungkapan isi memori yang tidak diinisialisasi, karena tidak menyebabkan crash program. </font><font style="vertical-align: inherit;">Untuk mendeteksi cacat tersebut menggunakan fuzzing, diperlukan satu dari dua solusi:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazzer, yang memahami protokol dan mampu mendeteksi kembalinya memori yang tidak diinisialisasi (atau lebih tepatnya, data yang tidak terduga) ke dalamnya.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penganalisa dinamis yang mampu mendeteksi akses ke memori yang tidak diinisialisasi.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ulasan Kode</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tinjauan umum kode tidak dapat diskalakan dan sangat rawan kesalahan. </font><font style="vertical-align: inherit;">Kode dengan kerentanan ditinjau, tetapi mereka disamarkan dengan baik sehingga programmer tidak memperhatikannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian dari kode di mana kami menemukan pengungkapan isi memori yang tidak diinisialisasi ditulis kembali pada zaman Windows 32-bit, dan tidak ada kesalahan seperti itu. </font><font style="vertical-align: inherit;">Ketika transisi ke arsitektur 64-bit terjadi, ukuran pointer meningkat dari 32 menjadi 64 bit, itulah sebabnya beberapa struktur memiliki bidang placeholder yang tidak diinisialisasi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - Inisialisasi Otomatis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain pendekatan yang disebutkan, Microsoft untuk beberapa waktu telah menggunakan mekanisme yang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - secara otomatis menginisialisasi variabel stack pada tahap kompilasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bagian ini, saya akan menjelaskan bagaimana teknologi ini digunakan di Windows dan mengapa dengan cara ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengaturan Windows saat ini:</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis-jenis berikut diinisialisasi secara otomatis:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalar (array, pointer, angka floating point)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array Pointer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur (Struktur Data Sederhana - POD)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis-jenis berikut ini tidak diinisialisasi secara otomatis:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel volatil</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array tipe selain pointer (yaitu array integer, array struktur, dll.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas yang Bukan POD</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam majelis ritel yang dioptimalkan, variabel diinisialisasi dengan nilai 0. Untuk angka floating-point, nilai 0,0 digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Majelis debugging atau majelis untuk pengembang (mis. Pengecer yang tidak dioptimalkan) menggunakan nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xE2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">angka floating point diinisialisasi ke 1.0. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berlaku untuk komponen-komponen berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kode dari repositori Windows yang dieksekusi dalam mode kernel (mis. Semua kode yang dikompilasi dengan switch / KERNEL) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kode terkait Hyper-V (hypervisor, komponen mode kernel, komponen mode pengguna)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejumlah proyek lain, seperti layanan jaringan mode pengguna</font></font></li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diimplementasikan di ujung depan kompiler. </font><font style="vertical-align: inherit;">Semua variabel yang memenuhi kriteria yang tercantum di atas dan tidak diinisialisasi oleh programmer akan diinisialisasi oleh frontend setelah deklarasi. </font><font style="vertical-align: inherit;">Salah satu keuntungan dari pendekatan ini adalah bahwa, dari sudut pandang pengoptimal, inisialisasi otomatis tidak berbeda dari inisialisasi oleh pengembang. </font><font style="vertical-align: inherit;">Oleh karena itu, optimasi yang kami tambahkan untuk mempercepat pekerjaan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak hanya terikat pada fungsi ini dan akan berfungsi jika Anda menginisialisasi variabel sendiri saat mendeklarasikan (atau sebelum menggunakan).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana kita menghindari masalah garpu bahasa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu tangkapan dengan inisialisasi nol otomatis: nol adalah makna khusus dalam bahasa pemrograman, terutama untuk pointer. Dan ini mungkin nilai yang paling umum yang menginisialisasi variabel individual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika diinisialisasi ke nol, pointer yang tidak diinisialisasi dengan benar oleh programmer dapat jatuh ke cabang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointer NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Akibatnya, Anda bisa mendapatkan program yang tidak macet, tetapi tidak menghasilkan hasil yang diinginkan. Jika Anda menginisialisasi pointer dengan nilai sampah, itu tidak akan jatuh ke cabang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointer NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan, jika Anda mencoba menggunakannya, akan menyebabkan program macet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memecahkan masalah ini dengan menggunakan nilai inisialisasi non-nol (0xE2) di CHK builds dan yang disebut builds untuk pengembang, yang sering kali build rilis tidak dioptimalkan. Karena hal ini, di satu sisi, dimungkinkan untuk mempertahankan kinerja tinggi dari kode yang dikirim ke klien, dan di sisi lain, untuk mendapatkan perilaku dalam rakitan yang sedang diuji yang membuatnya lebih mudah untuk melihat inisialisasi yang terlewat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya perhatikan bahwa C ++ sudah memerlukan inisialisasi nol otomatis dari semua anggota statis. </font><font style="vertical-align: inherit;">Semantik ini membantu pengembang. </font><font style="vertical-align: inherit;">Misalnya, ketika Anda melihat variabel statis dengan nilai nol, Anda akan tahu bahwa Anda perlu menginisialisasi, karena ini adalah penggunaan pertama. </font><font style="vertical-align: inherit;">InitAll memperkenalkan semantik serupa untuk variabel otomatis (tumpukan) dengan satu peringatan penting: kami mencoba untuk tidak mengikat pengembang ke nilai awal tertentu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana kami memilih komponen mana yang akan digunakan InitAll</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awalnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berencana untuk menggunakan dua komponen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode mode kernel - terutama karena sejumlah besar kerentanan yang diamati terkait dengan memori kernel yang tidak diinisialisasi.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Hyper-V terutama karena pentingnya untuk Azure dan karena statistik up-to-date yang mengecewakan pada kasus pengungkapan konten memori stack yang tidak diinisialisasi.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa di Microsoft mengetahui tentang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mulai secara aktif menggunakannya pada komponen mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasan kami tidak menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segera pada seluruh kode adalah karena kami ingin melakukan setidaknya sesuatu dengan baik terlebih dahulu, dan tidak gagal, mencoba melakukannya sekaligus. </font><font style="vertical-align: inherit;">Semakin banyak kode yang kami proses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada suatu waktu, semakin sulit untuk men-debug penurunan kinerja, menyelesaikan masalah kompatibilitas, dll. </font><font style="vertical-align: inherit;">Sekarang kami telah berhasil menerapkan teknologi pada komponen yang paling penting, Anda dapat melakukan sisa kode.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah InitAll merusak analisis statis?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analisis statis sangat berguna karena mengingatkan pengembang tentang variabel yang mereka lupa untuk diinisialisasi sebelum digunakan. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memberi tahu penganalisa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREfast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan backend compiler (keduanya memberikan peringatan tentang variabel yang tidak diinisialisasi) tentang inisialisasi yang telah ditambahkan. </font><font style="vertical-align: inherit;">Berkat ini, analisa statis dapat mengabaikan tempat-tempat seperti itu dan masih memberikan peringatan mereka. </font><font style="vertical-align: inherit;">Ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll diaktifkan,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda masih akan menerima pesan analisa statis tentang variabel yang tidak diinisialisasi - bahkan jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menginisialisasi mereka untuk Anda.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa kami tidak menginisialisasi semua jenis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama pengujian pendahuluan, kami dengan paksa menginisialisasi semua jenis data yang dialokasikan pada tumpukan dan mengamati penurunan kinerja lebih dari 10% dalam beberapa skenario penting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika hanya struktur POD diinisialisasi, kinerja tidak turun begitu banyak, dan optimisasi kompiler ditujukan untuk mengurangi jumlah operasi penulisan yang tidak perlu (baik di dalam unit dasar dan di antara mereka) memungkinkan kami untuk lebih mengurangi perlambatan dari tingkat yang terlihat ke tingkat kesalahan di tingkat sebagian besar tes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berencana untuk kembali ke ide inisialisasi semua jenis (terutama sekarang kami memiliki optimasi yang lebih kuat), kami belum mencapai titik ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa kita menginisialisasi variabel dengan nol</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi ke nol memberikan hasil terbaik dalam hal kinerja (baik dari segi kecepatan dan ukuran biner), serta dari segi keamanan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari perspektif keamanan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi nol memiliki keunggulan sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah null pointer akan mengeluarkan pengecualian SEH ketika melakukan dereferencing pada Windows (mis., Dalam kasus terburuk, ini akan menyebabkan kesalahan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penolakan layanan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi eksekusi kode jarak jauh tidak mungkin dilakukan), yang biasanya berakhir dengan crash program.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabel yang menentukan ukuran atau indeks akan menerima nilai nol. </font><font style="vertical-align: inherit;">Ini harus meminimalkan risiko melewatkan ukuran yang tidak diinisialisasi ke fungsi-fungsi seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekerja dengan buffer yang ukurannya diberikan oleh nilai dari variabel yang dikirimkan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memeriksa pointer nol, program akan menjalankan cabang yang sesuai dan tidak akan mencoba menggunakannya. </font><font style="vertical-align: inherit;">Jadi, setidaknya, akan mungkin untuk memproses pointer yang benar yang pengembang lupa untuk menginisialisasi (karena upaya untuk mengakses memori menggunakan pointer yang diinisialisasi secara otomatis akan selalu menyebabkan crash).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabel tipe Boolean dengan nilai 0 berarti "salah," yang dalam pengujian dapat mengindikasikan status kesalahan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi dengan nol juga memiliki beberapa kelemahan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabel NTSTATUS akan memiliki nilai STATUS_SUCCESS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HRESULT akan menjadi S_OK </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi nilai yang dikembalikan bisa sangat berbeda, dan tidak ada nilai universal tunggal yang digunakan untuk menginisialisasi semuanya, terutama mengingat bahwa itu juga harus digunakan untuk ukuran, indeks, pointer, dll.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari perspektif kinerja</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kecepatan program dan ukuran kode juga tergantung pada nilai inisialisasi yang dipilih. </font><font style="vertical-align: inherit;">Kami tidak mengukur seberapa buruk hasilnya ketika menggunakan nilai bukan nol, karena kami terutama tertarik pada manfaat keamanan yang diberikan inisialisasi nol, dan kami tahu bahwa pada saat yang sama itu akan memiliki efek positif pada kinerja (baik kecepatan dan ukuran kode). </font><font style="vertical-align: inherit;">Rekan-rekan kami dari Google melakukan pengukuran dan menunjukkan bahwa di Dentang, inisialisasi dengan nol saat ini terasa lebih menguntungkan daripada inisialisasi dengan nilai bukan nol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah ini saya akan menunjukkan dengan contoh mengapa ketika menginisialisasi dengan nol, kode lebih sedikit diperoleh.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh 1: Inisialisasi Menggunakan Register Tujuan Umum</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi dengan nol:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">31</span> c0                            <span class="hljs-keyword">xor</span>    eax,eax
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi dengan nilai bukan nol:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> b8 e2 e2 e2 e2 e2 e2 e2 e2    movabs rax,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, kami tertarik pada dua poin: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, mengatur register RAX ke nol membutuhkan 2 byte kode dibandingkan 10 byte ketika diatur ke nilai bukan nol. Ternyata keuntungan dalam ukuran kode dan kecepatan. Banyak prosesor membaca instruksi 16 byte pada satu waktu, jadi menulis konstanta tetap ke register menggunakan instruksi 10-byte mencegah instruksi berikut ini dikeluarkan yang dapat dieksekusi secara paralel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, sebelum menjadi mungkin untuk menulis nilai ke register RCX, Anda harus menunggu sampai penulisan ke RAX selesai, yang dapat menyebabkan idle prosesor. </font><font style="vertical-align: inherit;">Urutan seperti "xor eax, eax" diakui di bagian paling awal dari pipa, dan eksekusi nyata dari perintah XOR tidak diperlukan - prosesor hanya mengatur ulang register RAX. </font><font style="vertical-align: inherit;">Alhasil, jalur pipa tidak banyak waktu dan program berjalan lebih cepat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh 2: Inisialisasi Menggunakan Register XMM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menulis nilai yang lebih besar, kompiler biasanya menggunakan register XMM (serta YMM atau ZMM, tergantung pada apakah dukungan untuk set instruksi AVX atau AVX512 diaktifkan). </font><font style="vertical-align: inherit;">Sebagai aturan, prosesor tidak dapat menyelesaikan lebih dari satu perintah tulis dalam satu siklus clock, jadi akan lebih bijaksana untuk menggunakan perintah yang mengatur byte sebanyak mungkin. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi dengan nol:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">0f</span> <span class="hljs-number">57</span> c0                         xorps  xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi dengan nilai bukan nol (diambil dari variabel global, yang biasanya dilakukan oleh kompiler):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">66</span> <span class="hljs-number">0f</span> <span class="hljs-number">6f</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movdqa xmm0,XMMWORD PTR ds:<span class="hljs-number">0x0</span>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi dengan nilai bukan nol (dimuat dari konstanta tetap dalam kode, yang tidak dikompilasi oleh kompiler):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> ba e2 e2 e2 e2 e2 e2 e2 e2    movabs rdx,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">66</span> <span class="hljs-number">48</span> <span class="hljs-number">0f</span> <span class="hljs-number">6</span>e c2                   movq   xmm0,rdx
<span class="hljs-number">0f</span> <span class="hljs-number">16</span> c0                         movlhps xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, dalam kasus register XMM gambar yang sama diamati. Ketika diinisialisasi ke nol, kode ini sangat kecil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak mungkin untuk menulis konstanta tetap secara langsung ke register XMM. Pertama Anda harus menyimpannya ke register umum, dari sana pindahkan ke register XMM, dan kemudian salin 64 bit rendah dari register XMM ke 64 bit yang tinggi. Akibatnya, kami mendapatkan kode panjang dan tiga perintah, yang masing-masing harus menunggu yang sebelumnya selesai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghindari hal ini, kompiler, sebagai suatu peraturan, menyimpan konstanta tetap dalam bentuk variabel global, dari mana mereka kemudian dapat membaca nilainya - ini menghasilkan kode yang jauh lebih sedikit. Sayangnya, Anda harus menunggu hingga akhir penulisan ke register XMM sebelum tersedia untuk digunakan. Jika variabel global diturunkan dari memori, operasi mungkin memakan waktu beberapa ribu siklus jam. Operasi baca memerlukan beberapa siklus jam, bahkan dalam skenario kasus terbaik, ketika data disimpan dalam cache L1. Dan bahkan dalam kasus ini, kodenya jauh lebih lama daripada jika Anda baru mengatur ulang register. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mengungkapkan keuntungan lain dari inisialisasi nol: hasil yang lebih deterministik. Waktu inisialisasi tidak tergantung pada apakah variabel global dalam cache L1, L2 atau L3, apakah itu diturunkan dari memori, dll.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengamatan menarik terkait dengan penggunaan InitAll</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows 10 1903 (dirilis pada musim semi 2019) adalah versi pertama di mana </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diaktifkan secara default. </font><font style="vertical-align: inherit;">Sejauh ini, kami belum menerima keluhan tentang penurunan kinerja karena hal itu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesesuaian</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anti curang</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak lama setelah menyalakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Windows, kami mulai menerima keluhan tentang crash kernel yang disebabkan oleh beberapa program anti-cheat. </font><font style="vertical-align: inherit;">Setelah memeriksa masalah, kami menemukan bahwa program-program ini berisi driver mode kernel yang memindai citra kernel NT dalam memori dan mencari urutan byte spesifik yang menunjukkan awal dari fungsi tidak berdokumen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menambahkan inisialisasi tambahan (redundansi yang tidak dapat dibuktikan) pada awal fungsi-fungsi ini, karena tanda tangan mereka telah berubah. </font><font style="vertical-align: inherit;">Kami menghubungi pengembang anti-cheat ini, dan atas permintaan kami, mereka memperbarui driver mereka sehingga mereka tidak lagi menyebabkan crash kernel.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan memori yang dibebaskan di FAT32</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segera setelah mengaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk tipe data skalar (mis. </font><i><font style="vertical-align: inherit;">Integer</font></i><font style="vertical-align: inherit;"> , angka floating-point, dll.), Kami mengalami masalah yang menarik dalam driver sistem file FAT, yang tidak memungkinkan memperbarui rakitan Windows internal dari flash drive USB yang dapat di-boot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode di mana masalah terjadi tampak seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
{<font></font>
      <span class="hljs-keyword">int</span> tmp;<font></font>
      DoStuff(&amp;tmp, i);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada loop di mana variabel dideklarasikan. Pada iterasi pertama dari loop, fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoStuff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menginisialisasi variabel 'tmp', alamat yang diteruskan ke sana sebagai argumen. Pada setiap iterasi berikutnya, variabel 'tmp' digunakan sebagai parameter input / output. Dengan kata lain, nilainya dibaca pertama dan kemudian diperbarui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa variabel yang dipertanyakan pada awal setiap iterasi dari loop memasuki ruang lingkupnya, dan meninggalkannya di akhir iterasi. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menginisialisasi variabel ini menjadi nol sebelum setiap iterasi. Bahkan, kami mendapatkan kerentanan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penggunaan-setelah-gratis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Untuk operasi normal kode, diperlukan bahwa variabel 'tmp' mempertahankan nilainya di setiap iterasi, bahkan jika pada akhir iterasi keluar dari ruang lingkup. </font><font style="vertical-align: inherit;">Sayangnya, masalah ini tidak menyebabkan crash driver, tetapi untuk logika yang salah dari operasinya dan, sebagai akibatnya, perilaku yang tidak terduga dari sistem file. </font><font style="vertical-align: inherit;">Selama debugging, tim kernel menentukan penyebab masalah dan memperbaikinya dengan mengeluarkan variabel dari loop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasus ini adalah contoh yang baik tentang bagaimana peningkatan keamanan dapat memecahkan kode yang belum terlihat selama bertahun-tahun.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi kinerja</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
kinerja </font><i><font style="vertical-align: inherit;">InitAll</font></i><font style="vertical-align: inherit;"> memiliki </font><font style="vertical-align: inherit;">tiga tujuan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memberi pengembang kemampuan untuk menonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk kode kritis</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika memungkinkan, hapus operasi penulisan yang tidak perlu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mempercepat operasi penulisan yang tersisa sebanyak mungkin</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menonaktifkan InitAll untuk Kode Kritis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimalisasi yang paling jelas adalah membiarkan kode:</font></font><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll sepenuhnya</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk jenis tertentu (mis. Struktur typedef)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk semua operasi alokasi memori dalam fungsi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk deklarasi variabel tertentu dalam suatu fungsi</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
saat ini </font><font style="vertical-align: inherit;">dinonaktifkan (karena </font><i><font style="vertical-align: inherit;">alasan</font></i><font style="vertical-align: inherit;"> kinerja) untuk satu jenis - struktur _CONTEXT, yang menyimpan nilai-nilai semua register. Inisialisasi paksa menyebabkan penurunan kinerja dalam tes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki ukuran lebih dari 1000 byte, dan ini cukup untuk menyimpan nilai semua register. Dengan pencatatan ETW diaktifkan untuk melacak sakelar konteks, setiap kali konteks diubah, nilai-nilai semua register dicatat. Struktur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam hal ini akan dialokasikan pada stack, diisi dengan fungsi assembler, dan kemudian diteruskan ke ETW. Karena kenyataan bahwa struktur diinisialisasi oleh fungsi assembler, kompiler tidak dapat menghapus inisialisasi yang dilakukan</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Karena struktur ini sudah berisi data penting (keadaan setiap register), besar dan digunakan di cabang yang sangat menuntut kinerja, kami memutuskan untuk tidak menerapkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke dalamnya </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk semua jenis, variabel, dan fungsi lainnya, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak </font><i><font style="vertical-align: inherit;">dinonaktifkan</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghapus operasi penulisan yang tidak perlu</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menghapus operasi penulisan yang tidak perlu adalah pengoptimalan yang dilakukan oleh kompiler Visual Studio, yang menghilangkan operasi penulisan yang dapat terbukti berlebihan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah contoh dari berbagai jenis optimasi yang digunakan oleh Visual Studio.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghapus banyak memset</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tautan ke Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/Ldu7AP</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pola kode berikut (dengan variasi yang berbeda) sangat umum. Aturan pemrograman NT awal mengharuskan semua variabel dideklarasikan pada awal fungsi, dan diinisialisasi selambat mungkin. Sebagai hasilnya, kami memiliki kasus ketika variabel dideklarasikan di awal fungsi, dan diinisialisasi hanya di salah satu cabang segera sebelum digunakan. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menambahkan inisialisasi variabelnya di awal fungsi. Kompiler dapat menghapus duplikat, tetapi ini tidak selalu mudah dilakukan.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
  <font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/hq/dl/ee/hqdleeuo4icifkr9_ijrp0rt_ps.png" alt="Gambar 4"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya contoh sederhana ini harus mudah dioptimalkan, namun, GCC 9.3 dan Dentang 10.0.0 (versi terbaru yang tersedia di Godbolt) tidak mampu dalam hal ini untuk menghapus panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambahan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya tidak membicarakan hal ini untuk mengkritik kompiler ini - mereka berdua mengoptimalkan kode dengan sangat baik. </font><font style="vertical-align: inherit;">Saya hanya ingin menunjukkan bahwa beberapa pola dapat menyebabkan kesulitan bahkan untuk kompiler yang paling kuat. </font><font style="vertical-align: inherit;">Sebelum kedatangan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan optimasi terkait, Visual Studio tidak dapat menghapus panggilan ekstra. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang bahkan lebih sederhana:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Antara dua panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya ada satu panggilan fungsi tanpa argumen. </font><font style="vertical-align: inherit;">Pola ini, seperti yang sebelumnya, sangat umum dalam kode Microsoft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tautan ke Godbolt:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/HqFMx_</font></font></a><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    Dummy();<font></font>
<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    DoStuff(&amp;s);<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fe/qo/7e/feqo7evdydknbjjwx9wwlvxt61a.png" alt="Gambar 3"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC menghapus kelebihan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam contoh ini. Dentang 10.0.0 - juga, tetapi GCC 9.3 masih gagal. Tampaknya kode ini dapat dengan mudah dioptimalkan, tetapi untuk ini kompiler harus melakukan analisis non-sepele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya di sini (dalam MSVC) adalah bahwa kompiler menggunakan analisis jangkauan objek, terlepas dari percabangan atau eksekusi ulir. Dari sudut pandang kompiler, variabel '' lolos 'dari fungsi saat ini (dengan kata lain, alamatnya dikirimkan di suatu tempat di luar fungsi ini), karena alamatnya dilewatkan ke fungsi' DoStuff '. Kompiler juga melihat panggilan untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's', lalu panggilan ke 'Dummy', diikuti oleh panggilan lain untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ''s '.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari sudut pandang kompiler, karena variabel 's' 'lolos' dari fungsi, fungsi 'Dummy' secara teoritis dapat membaca konten 's' atau memodifikasinya sebelum memanggil fungsi 'DoStuff'. </font><font style="vertical-align: inherit;">Ini berarti bahwa panggilan untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak dapat dihapus sebelum atau sesudah 'Dummy'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat melihat bahwa meskipun variabel 's' dan "keluar" dari fungsi saat ini, ini tidak terjadi sebelum fungsi 'DoStuff' dipanggil. </font><font style="vertical-align: inherit;">Kompiler MSVC sekarang juga memahami ini (sampai tingkat tertentu) dan dapat menghapus panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pertama </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengurangan ukuran memset</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tautan ke Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/fyLVUF</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pola berikut ini juga tidak biasa. </font><font style="vertical-align: inherit;">Struktur sebagian diinisialisasi, dan kemudian dipindahkan ke fungsi lain. </font><font style="vertical-align: inherit;">Fungsi kedua ini cenderung menginisialisasi sisa data struktur (atau setidaknya tidak membacanya), tetapi kompiler tidak dapat membuktikan ini.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">320</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s)<span class="hljs-number">-0x160</span>);<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/qv/zv/ix/qvzvix4pxzqvazgvfzafdg_zraa.png" alt="Gambar 2"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC sekarang dapat memotong ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pertama </font><font style="vertical-align: inherit;">sehingga hanya menginisialisasi elemen-elemen dalam struktur yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kedua tidak menginisialisasi </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sekali lagi, GCC 9.3 dan Dentang 10.0.0 belum tahu bagaimana melakukan optimasi ini dalam contoh ini.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sapu memset lebih efisien</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan ke Godbolt.</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dalam contoh berikut, panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak dapat dihapus. </font><font style="vertical-align: inherit;">Jadi, itu harus dilakukan seefisien mungkin.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">12</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
    DoStuff(&amp;s);<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fm/yf/7v/fmyf7vxnqesyecgskxvarcbgyc4.png" alt="Gambar 1"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC (seperti kebanyakan kompiler) dapat "menggunakan" panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kecil </font><font style="vertical-align: inherit;">dengan ukuran dan nilai padding yang ditentukan secara statis. Artinya, panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diganti dengan urutan perintah tulis langsung ke memori. Berkat optimasi ini, waktu pelaksanaan panggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kecil </font><font style="vertical-align: inherit;">(hingga 128 byte) dikurangi menjadi seperempat dari biasanya dengan jumlah kode yang lebih kecil (tidak perlu menyimpan nilai register pada stack, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> panggilan </font><font style="vertical-align: inherit;">, dan kemudian mengembalikan status register). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC digunakan untuk menyebarkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada AMD64 menggunakan register tujuan umum. </font><font style="vertical-align: inherit;">Sekarang ia menggunakan register vektor, yang memungkinkan Anda untuk mengerahkan panggilan dua kali ukurannya. </font><font style="vertical-align: inherit;">Akibatnya, kami mendapatkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih cepat </font><font style="vertical-align: inherit;">dan tidak membiarkan kode tumbuh. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi memset yang lebih produktif</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Kami akan </font><b><font style="vertical-align: inherit;">menganalisis</font></b><font style="vertical-align: inherit;"> item ini secara rinci di lain waktu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai Pengguna</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejak kami merilis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , banyak kerentanan yang dilaporkan pengguna ke MSRC telah berhenti diputar pada versi Windows terbaru. Berkat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kerentanan ini telah </font><i><font style="vertical-align: inherit;">berkembang</font></i><font style="vertical-align: inherit;"> dari "masalah keamanan" menjadi "cacat kode yang saat ini tidak memiliki konsekuensi negatif." Ini berarti bahwa kita tidak perlu lagi memberikan pembaruan keamanan untuk sistem operasi yang sudah dirilis dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diinstal </font><font style="vertical-align: inherit;">, yang menyelamatkan pengguna dari sakit kepala yang menyertai instalasi patch, dan Microsoft dari sakit kepala yang menyertai perkembangan mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di cabang repositori kami yang aktif, kami masih meningkatkan kode dan memperbaiki kesalahan, serta membuat perubahan pada sistem operasi yang sudah dirilis di mana </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hilang dan yang karenanya masih rentan. </font><font style="vertical-align: inherit;">Seiring waktu, versi tanpa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak akan lagi didukung. </font><font style="vertical-align: inherit;">Ketika ini terjadi, kesalahan yang dinetralkan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll hanya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan diperbaiki di cabang pengembangan aktif, dan pada sistem saat ini jenis cacat ini tidak lagi harus diperbaiki.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana masa depan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, kami berencana untuk menangani dua tugas utama dalam konteks masalah dengan variabel stack yang tidak diinisialisasi:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mempelajari dan menggunakan kemungkinan menerapkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke semua jenis data yang dialokasikan (yaitu array semua jenis dan semua kelas, bukan hanya POD)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyebarkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada semua kode Windows.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di masa depan, kami berencana untuk mencari tahu apakah mungkin untuk membakukan proses penghapusan jenis masalah yang dijelaskan dalam C dan C ++. Secara default, tidak perlu membiarkan variabel tidak diinisialisasi demi kinerja (terutama jika kompiler dapat mengoptimalkan operasi penulisan redundan dengan baik). Sebagai gantinya, akan lebih baik untuk meminta pengembang untuk menginisialisasi variabel sebelum digunakan, "jika kebutuhan seperti itu telah terbukti", dan untuk membiarkan aturan ini dilanggar hanya jika kata kunci khusus digunakan untuk variabel yang tidak diinisialisasi. Solusi semacam itu akan menjaga kinerja tinggi dan pada saat yang sama menyelamatkan programmer dari kesalahan yang tidak perlu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berencana untuk menerbitkan catatan lain tentang pekerjaan yang sedang berlangsung untuk menetralisir kerentanan memori yang belum diinisialisasi dalam mekanisme untuk mengalokasikan kumpulan memori di kernel Windows.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komentar Penerjemah</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini hampir tidak terkait dengan topik asli saya tentang analisis kode statis, tetapi tampaknya menarik bagi saya dan saya ingin berbagi terjemahan dengan audiens yang berbahasa Rusia. </font><font style="vertical-align: inherit;">Dari saya sendiri, saya ingin menambahkan bahwa masalah keamanan yang terkait dengan "kebocoran" data pribadi biasanya terdiri dari dua komponen. </font><font style="vertical-align: inherit;">Pertama: ada tempat di mana data pribadi harus dihapus, tetapi ini tidak terjadi ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Kedua: data pribadi yang tidak bersih sebagai bagian dari memori yang tidak diinisialisasi dapat ditransfer ke suatu tempat ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contoh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id505476/index.html">API CRUD di Deno dan PostegreSQL: bekerja dengan dinosaurus</a></li>
<li><a href="../id505478/index.html">Mengganti sistem CRM dengan sistem CRM</a></li>
<li><a href="../id505488/index.html">12 tips untuk mengimplementasikan TypeScript di Bereaksi aplikasi</a></li>
<li><a href="../id505494/index.html">Pembingkaian Pengembang</a></li>
<li><a href="../id505496/index.html">Flutter Dev Podcast dengan CTO Meduza Boris Goryachev: hal utama tentang aplikasi Meduz dan pengembangan media</a></li>
<li><a href="../id505502/index.html">Omnichannel dalam layanan pelanggan: apa yang harus dicari dan bagaimana melakukan semuanya dengan benar?</a></li>
<li><a href="../id505506/index.html">Dia tidak menggigit: bagaimana membuat robot industri aman bagi pekerja</a></li>
<li><a href="../id505508/index.html">Bukan hanya teknologi tak berawak: masa depan industri otomotif</a></li>
<li><a href="../id505510/index.html">Merampingkan Check Point API dengan Python SDK</a></li>
<li><a href="../id505516/index.html">Pembelajaran mesin: mulai dari mana atau bagaimana membangun model pertama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>